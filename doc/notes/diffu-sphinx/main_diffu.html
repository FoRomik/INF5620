
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite difference methods for diffusion processes &mdash; Finite difference methods for diffusion processes 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Finite difference methods for diffusion processes 1.0 documentation" href="index.html" />
    <link rel="prev" title="Finite difference methods for diffusion processes" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Finite difference methods for diffusion processes"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite difference methods for diffusion processes 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="finite-difference-methods-for-diffusion-processes">
<h1>Finite difference methods for diffusion processes<a class="headerlink" href="#finite-difference-methods-for-diffusion-processes" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Nov 15, 2012</td>
</tr>
</tbody>
</table>
<p>Note: <strong>VERY PRELIMINARY VERSION</strong></p>
</div>
<div class="section" id="a-simple-1d-diffusion-equation">
<h1>A simple 1D diffusion equation<a class="headerlink" href="#a-simple-1d-diffusion-equation" title="Permalink to this headline">¶</a></h1>
<p>We consider a diffusion problem for a quantity <span class="math">\(u(x,t)\)</span>:</p>
<div class="math">
\[\begin{split}\frac{\partial u}{\partial t} &amp;=
\alpha \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]
\\
u(x,0) &amp;= I(x), \quad  x\in [0,L]
\\
u(0,t) &amp; = 0, \quad  t&gt;0,
\\
u(L,t) &amp; = 0, \quad  t&gt;0\thinspace .\end{split}\]</div>
<p>Equation (<em class="xref std std-ref">diffu:pde1</em>) is known as a one-dimensional
<em>diffusion equation</em>, also often referred to as a
<em>heat equation</em>. With only a first-order derivative in time,
only one <em>initial condition</em> is needed, while the second-order
derivative in time leads to a demand for two <em>boundary conditions</em>.
The parameter <span class="math">\(\alpha\)</span> must be given and is referred to as the
<em>diffusion coefficient</em>.</p>
<p>Diffusion equations like (<em class="xref std std-ref">diffu:pde1</em>) have a wide range of
applications throughout physical, biological, and financial sciences.
One of the most common applications is propagation of heat, where
<span class="math">\(u(x,t)\)</span> represents the temperature of some substance at point <span class="math">\(x\)</span> and
time <span class="math">\(t\)</span>. the chapter <em class="xref std std-ref">diffu:app</em> goes into several widely occurring
applications.</p>
<div class="section" id="forward-euler-scheme">
<span id="diffu-pde1-fe"></span><h2>Forward Euler scheme<a class="headerlink" href="#forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>The first step in the discretization procedure is to replace the
domain <span class="math">\([0,L]\times [0,T]\)</span> by a set of mesh points. Here we apply
equally spaced mesh points</p>
<div class="math">
\[x_i=i\Delta x,\quad i=0,\ldots,N_x,\]</div>
<p>and</p>
<div class="math">
\[t_n=n\Delta t,\quad n=0,\ldots,N \thinspace .\]</div>
<p>Moreover, <span class="math">\(u^n_i\)</span> denotes the numerical approximation of <span class="math">\(u(x_i,t_n)\)</span>.
Approximating the PDE (<em class="xref std std-ref">diffu:pde1</em>) at a mesh point <span class="math">\((x_i,t_n)\)</span>
leads to</p>
<div class="math" id="equation-diffu:pde1:step2">
<span class="eqno">(1)</span>\[     \frac{\partial}{\partial t} u(x_i, t_n) =
     \alpha\frac{\partial^2}{\partial x^2} u(x_i, t_n),\]</div>
<p>Let us first replace
the time derivative by a forward difference and the spatial
derivative by a central difference:</p>
<div class="math" id="equation-diffu:pde1:step3a">
<span class="eqno">(2)</span>\[     [D_t^+ u = \alpha D_xD_x u]^n_i \thinspace .\]</div>
<p>Written out,</p>
<div class="math" id="equation-diffu:pde1:step3b">
<span class="eqno">(3)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = \alpha \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} \thinspace .\]</div>
<p>As usual, we anticipate that <span class="math">\(u^n_i\)</span> is already computed such that
<span class="math">\(u^{n+1}_i\)</span> is the only unknown, which we can easily solve for:</p>
<div class="math" id="equation-diffu:pde1:step4">
<span class="eqno">(4)</span>\[     u^{n+1}_i = u^n_i + \alpha\frac{\Delta t}{\Delta x^2}\left(
     u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right) \thinspace .\]</div>
<p>The computational algorithm is then</p>
<blockquote>
<div><ol class="arabic simple">
<li>compute $u^0_i=I(x_i)$for <span class="math">\(i=0,\ldots,N_x\)</span></li>
<li>for <span class="math">\(n=0,1,\ldots,N\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>apply <a href="#equation-diffu:pde1:step4">(4)</a> for all the internal
spatial points <span class="math">\(i=1,\ldots,N_x-1\)</span></li>
<li>set the boundary values
<span class="math">\(u^{n+1}_i=0\)</span> for <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span></li>
</ol>
</div></blockquote>
</div></blockquote>
<p>The algorithm is compactly fully specified in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># mesh points in space</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># mesh points in time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
<span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="c"># Compute u at inner mesh points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

    <span class="c"># Insert boundary conditions</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># Update u_1 before next step</span>
    <span class="n">u_1</span><span class="p">[:]</span><span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
</div>
<div class="section" id="backward-euler-scheme">
<span id="diffu-pde1-be"></span><h2>Backward Euler Scheme<a class="headerlink" href="#backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>We now apply a backward difference in time in <a href="#equation-diffu:pde1:step2">(1)</a>,
but the same central difference in space:</p>
<div class="math" id="equation-diffu:pde1:step3aBE">
<span class="eqno">(5)</span>\[     [D_t^- u = D_xD_x u]^n_i,\]</div>
<p>which written out reads</p>
<div class="math" id="equation-diffu:pde1:step3bBE">
<span class="eqno">(6)</span>\[     \frac{u^{n}_i-u^n-1_i}{\Delta t} = \alpha\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} \thinspace .\]</div>
<p>Now we assume <span class="math">\(u^{n-1}_i\)</span> is computed, but all quantities at the &#8220;new&#8221;
time level <span class="math">\(n\)</span> are unknown. This time it is not possible to solve
with respect to <span class="math">\(u_i^{n}\)</span> because this value couples to its neighbors
in space, <span class="math">\(u^n_{i-1}\)</span> and <span class="math">\(u^n_{i+1}\)</span>, which are also unknown.
Let us examine this fact for the case when <span class="math">\(N_x=3\)</span>. Equation <a href="#equation-diffu:pde1:step3bBE">(6)</a> written for <span class="math">\(i=1,\ldots,Nx-1= 1,2\)</span> becomes</p>
<div class="math">
\[\begin{split}\frac{u^{n}_1-u^{n-1}_1}{\Delta t} &amp;= \alpha\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2}\\
\frac{u^{n}_2-u^{n-1}_2}{\Delta t} &amp;= \alpha\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2}\end{split}\]</div>
<p>The boundary values <span class="math">\(u^n_0\)</span> and <span class="math">\(u^n_3\)</span> are known as zero. Collecting the
unknown new values <span class="math">\(u^n_1\)</span> and <span class="math">\(u^n_2\)</span> on the left-hand side gives</p>
<div class="math">
\[\begin{split}\left(1+  2\alpha\frac{\Delta t}{\Delta x^2}\right) u^{n}_1
- \alpha\frac{\Delta t}{\Delta x^2} u^{n}_{2}  &amp;= u^n-1_1,\\
- \alpha\frac{\Delta t}{\Delta x^2} u^{n}_{2} +
\left(1+  2\alpha\frac{\Delta t}{\Delta x^2}\right) u^{n}_2
  &amp;= u^n-1_2
\thinspace .\end{split}\]</div>
<p>This is a coupled <span class="math">\(2\times 2\)</span> system of algebraic equations for
the unknowns <span class="math">\(u^n_1\)</span> and <span class="math">\(u^n_2\)</span>.
Discretization methods that lead to a coupled system of equations
for the unknown function at a new time level are said to be
<em>implicit methods</em>.
.. index:: implicit discretization methods</p>
<p id="index-0">The counterpart, <em>explicit methods</em>, refers to discretization
methods where there is a simple explicit formula for the values of
the unknown function at each of the spatial mesh points at the new
time level. From an implementational point of view, implicit methods
are more comprehensive to code since they require
the solution of coupled equations, i.e., a matrix system, at each time level.</p>
<p>In the general case, <a href="#equation-diffu:pde1:step3bBE">(6)</a> gives rise to
a coupled <span class="math">\((Nx-1)\times (Nx-1)\)</span> system of algebraic equations for
all the unknown <span class="math">\(u^n_i\)</span> at the interior spatial points <span class="math">\(i=1,\ldots,Nx-1\)</span>.
Collecting the unknowns on the left-hand side, and
introducing the quantity</p>
<div class="math">
\[C = \alpha\frac{\Delta t}{\Delta x^2},\]</div>
<p><a href="#equation-diffu:pde1:step3bBE">(6)</a> can be written</p>
<div class="math" id="equation-diffu:pde1:step4BE">
<span class="eqno">(7)</span>\[     - Cu^n_{i-1} + \left(1+  2C\right) u^{n}_i - Cu^n_{i+1}) = u_{i-1}^n,\]</div>
<p>for <span class="math">\(i=1,\ldots,Nx-1\)</span>.
One can either view these equations as a system for where the
<span class="math">\(u^{n}_i\)</span> values at the internal grid points, <span class="math">\(i=1,\ldots,N_x-1\)</span>, are
unknown, or we may append the boundary values <span class="math">\(u^n_0\)</span> and <span class="math">\(u^n_{N_x}\)</span>
to the system. In the latter case, all <span class="math">\(u^n_i\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span>
are unknown and we must add the boundary equations to
the <span class="math">\(N_x-1\)</span> equations in <a href="#equation-diffu:pde1:step4BE">(7)</a>:</p>
<div class="math">
\[\begin{split}u_0^n &amp;= 0,\\
u_{N_x}^n &amp;= 0\thinspace .\end{split}\]</div>
<p>A coupled system of algebraic equations can be written on matrix form,
and this is important if we want to call up ready-made software for
solving the system.  The equations <a href="#equation-diffu:pde1:step4BE">(7)</a>
and (<em class="xref std std-ref">diffu:pde1:step4BE:BC:0</em>)&#8211;(<em class="xref std std-ref">diffu:pde1:step4BE:BC:L</em>)
correspond to the matrix equation</p>
<div class="math">
\[AU = b\]</div>
<p>where <span class="math">\(U=(u^n_0,\ldots,u^n_{N_x})\)</span>, and
the matrix <span class="math">\(A\)</span> has the following structure:</p>
<div class="math" id="equation-diffu:pde1:matrix:sparsity">
<span class="eqno">(8)</span>\[\begin{split}     A =
     \left(
     \begin{array}{cccccccccc}
     A_{0,0} &amp; A_{0,1} &amp; 0
     &amp;\cdots &amp;
     \cdots &amp; \cdots &amp; \cdots &amp;
     \cdots &amp; 0 \\
     A_{1,0} &amp; A_{1,1} &amp; 0 &amp; \ddots &amp;   &amp; &amp;  &amp; &amp;  \vdots \\
     0 &amp; A_{2,1} &amp; A_{2,2} &amp; A_{2,3} &amp;
     \ddots &amp; &amp;  &amp;  &amp; \vdots \\
     \vdots &amp; \ddots &amp;  &amp; \ddots &amp; \ddots &amp; 0 &amp;  &amp; &amp; \vdots \\
     \vdots &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp; \vdots \\
     \vdots &amp; &amp;  &amp; 0 &amp; A_{i,i-1} &amp; A_{i,i} &amp; A_{i,i+1} &amp; \ddots &amp; \vdots \\
     \vdots &amp; &amp; &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp;\ddots  &amp; 0 \\
     \vdots &amp; &amp; &amp; &amp;  &amp;\ddots  &amp; \ddots &amp;\ddots  &amp; A_{N_x-1,N_x} \\
     0 &amp;\cdots &amp; \cdots &amp;\cdots &amp; \cdots &amp; \cdots  &amp; 0 &amp; A_{N_x,N_x-1} &amp; A_{N_x,N_x}
     \end{array}
     \right)\end{split}\]</div>
<p>The nonzero elements are given by</p>
<div class="math">
\[\begin{split}A_{i,i-1} &amp;= -C\\
A_{i,i} &amp;= 1+ 2C\\
A_{i,i+1} &amp;= -C\end{split}\]</div>
<p>for the equations for internal points, <span class="math">\(i=1,\ldots,N_x-1\)</span>. The equations
for the boundary points correspond to</p>
<div class="math">
\[\begin{split}A_{0,0} &amp;= 1,\\
A_{0,1} &amp;= 0,\\
A_{N_x,N_x-1} &amp;= 0,\\
A_{N_x,N_x} &amp;= 1\thinspace .\end{split}\]</div>
<p>The right-hand side <span class="math">\(b\)</span> is written as</p>
<div class="math">
\[\begin{split}b = \left(\begin{array}{c}
b_0\\
b_1\\
\vdots\\
b_i\\
\vdots\\
b_{N_x}
\end{array}\right)\end{split}\]</div>
<p>with</p>
<div class="math">
\[\begin{split}b_0 &amp;= 0,\\
b_i &amp;= u^{n-1}_i,\quad i=1,\ldots,N_x-1,\\
b_{N_x} &amp;= 0 \thinspace .\end{split}\]</div>
<p>We observe that the matrix <span class="math">\(A\)</span> contains quantities that do not change
in time. Therefore, <span class="math">\(A\)</span> can be formed once and for all before we enter
the recursive formulas for the time evolution.
The right-hand side <span class="math">\(b\)</span>, however, must be updated at each time step.
This leads to the following computational algorithm, here sketched
with Python code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># mesh points in space</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># mesh points in time</span>
<span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Data structures for the linear system</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">C</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">C</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">C</span>
<span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="kn">import</span> <span class="nn">scipy.linalg</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="c"># Compute b and solve linear system</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="c"># Update u_1 before next step</span>
    <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
</div>
<div class="section" id="sparse-matrix-implementation">
<span id="diffu-pde1-impl-sparse"></span><h2>Sparse matrix implementation<a class="headerlink" href="#sparse-matrix-implementation" title="Permalink to this headline">¶</a></h2>
<p>We have seen from <a href="#equation-diffu:pde1:matrix:sparsity">(8)</a> that the matrix <span class="math">\(A\)</span>
is tridiagonal. The code segment above used a full, dense matrix
representation of <span class="math">\(A\)</span>, which stores a lot of values we know are zero
beforehand, and worse, the solution algorithm computes with all these zeros.
With <span class="math">\(N_x+1\)</span> unknowns, the work by the solution algorithm is <span class="math">\(\frac{1}{3}
(N_x+1)^3\)</span> and the storage requirements <span class="math">\((N_x+1)^2\)</span>. By utilizing
the fact that <span class="math">\(A\)</span> is tridiagonal and employing corresponding software
tools, the work and storage demands can be proportional to <span class="math">\(N_x\)</span> only.</p>
<p>The key idea is to apply a data structure for a
tridiagonal or sparse matrix. The <tt class="docutils literal"><span class="pre">scipy.sparse</span></tt> package has
relevant utilities. For example, we can store the nonzero diagonals of
a matrix. The package also has linear system solvers that operate on
sparse matrix data structures. The code below illustrates how we
can store only the main diagonal and the upper and lower diagonals.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Representation of sparse matrix and right-hand side</span>
<span class="n">main</span>  <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">lower</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">upper</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span>     <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Precompute sparse matrix</span>
<span class="n">main</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">C</span>
<span class="n">lower</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">C</span>  <span class="c">#1</span>
<span class="n">upper</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">C</span>  <span class="c">#1</span>
<span class="c"># Insert boundary conditions</span>
<span class="n">main</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">main</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span>
    <span class="n">diagonals</span><span class="o">=</span><span class="p">[</span><span class="n">main</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">],</span>
    <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">format</span><span class="o">=</span><span class="s">&#39;csr&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">A</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>

<span class="c"># Set initial condition</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">u_1</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c"># boundary conditions</span>
    <span class="n">u</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">scipy.sparse.linalg.spsolve</span></tt> function utilizes the sparse storage
structure of <tt class="docutils literal"><span class="pre">A</span></tt> and performs in this case a very efficient Gaussian
elimination solve.</p>
</div>
<div class="section" id="the-rule">
<span id="diffu-pde1-theta"></span><h2>The <span class="math">\(\theta\)</span> Rule<a class="headerlink" href="#the-rule" title="Permalink to this headline">¶</a></h2>
<p>The <span class="math">\(\theta\)</span> rule provides a family of finite difference approximations
in time. Applied to the 1D diffusion problem we have</p>
<div class="math">
\[\frac{u^{n+1}_i-u^n_i}{\Delta t} =
\alpha\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
+ (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)
\thinspace .\]</div>
<p>This scheme also leads to a matrix system with entries <span class="math">\(1+2C\theta\)</span> on
the main diagonal of the matrix, and <span class="math">\(-C\theta\)</span> on the super- and sub-diagonal.
The right-hand side entry <span class="math">\(b_i\)</span> is</p>
<div class="math">
\[b_i = u^n_{i} + C(1-\theta)
\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\thinspace .\]</div>
</div>
<div class="section" id="the-laplace-and-poisson-equation-as-the-steady-state-limit">
<h2>The Laplace and Poisson equation as the steady state limit<a class="headerlink" href="#the-laplace-and-poisson-equation-as-the-steady-state-limit" title="Permalink to this headline">¶</a></h2>
<p>The Laplace equation, <span class="math">\(\nabla^2 u = 0\)</span>, or the Poisson equation,
<span class="math">\(-\nabla^2 u = f\)</span>, occur in numerous applications throughout science and
engineering. We can solve 1D variants of the Laplace equations with the listed
software, because we can interpret <span class="math">\(u_{xx}=0\)</span> as the limiting solution
of <span class="math">\(u_t = \alpha u_{xx}\)</span> when <span class="math">\(u\)</span> reach a steady state limit where
<span class="math">\(u_t=0\)</span>. Technically in a program, we just take one large time step,
or equivalently, set <span class="math">\(\alpha\)</span> to a large value. All we need is to have
<span class="math">\(C\)</span> large. As <span class="math">\(C\rightarrow\infty\)</span>, we can from the schemes see that
we get</p>
<div class="math">
\[\frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2} = 0,\]</div>
<p>which is nothing but the discretization <span class="math">\([D_xD_x u]^{n+1}_i=0\)</span> of
<span class="math">\(u_{xx}=0\)</span>.</p>
<p>The Backward Euler scheme can solve the limit equation directly and
hence produce a solution of the 1D Laplace equation.
With the Forward Euler scheme we must do the time stepping since <span class="math">\(C&gt;1/2\)</span>
is illegal and leads to instability. We may interpret this time stepping
as solving the equation system from <span class="math">\(u_{xx}\)</span> by iterating on a time
pseudo time variable.</p>
</div>
<div class="section" id="extensions">
<h2>Extensions<a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>Variable coefficients</li>
<li>Neumann and Robin conditions</li>
<li>2D and 3D</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="analysis-of-schemes-for-the-diffusion-equation">
<h1>Analysis of schemes for the diffusion equation<a class="headerlink" href="#analysis-of-schemes-for-the-diffusion-equation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="properties-of-the-solution">
<span id="diffu-pde1-analysis-uex"></span><h2>Properties of the solution<a class="headerlink" href="#properties-of-the-solution" title="Permalink to this headline">¶</a></h2>
<p>A particular characteristic of diffusive processes, governed
by an equation like</p>
<div class="math" id="equation-diffu:pde1:eq">
<span class="eqno">(9)</span>\[     u_t = \alpha u_{xx},\]</div>
<p>is that the
initial shape <span class="math">\(u(x,0)=I(x)\)</span> spreads out in space with time,
along with a decaying amplitude. For example, <a href="#equation-diffu:pde1:eq">(9)</a>
admits a solution of the form</p>
<div class="math" id="equation-diffu:pde1:sol1">
<span class="eqno">(10)</span>\[     u(x,t) = Qe^{-at}\sin\left( kx\right),\]\[     \thinspace  .\]</div>
<p>The parameters <span class="math">\(Q\)</span> and <span class="math">\(k\)</span> can be freely chosen, while
inserting <a href="#equation-diffu:pde1:sol1">(10)</a> in <a href="#equation-diffu:pde1:eq">(9)</a> gives the constraint</p>
<div class="math">
\[a = -\alpha k^2
\thinspace .\]</div>
<p>A very important feature is that the initial shape <span class="math">\(I(x)=Q\sin kx\)</span>
undergoes a damping <span class="math">\(\exp{(-\alpha k^2t)}\)</span>, meaning that
rapid oscillations in space, corresponding to large <span class="math">\(k\)</span>, are very much
faster dampened than slow oscillations in space, corresponding to small
<span class="math">\(k\)</span>. This feature leads to a smoothing of the initial condition with time.</p>
<p>The following examples illustrates the damping properties of the
diffusion equation. We consider the problem</p>
<div class="math">
\[\begin{split}u_t &amp;= u_{xx},\quad x\in (0,1),\ t\in (0,T],\\
u(0,t) &amp;= u(1,t) = 0,\quad t\in (0,T],\\
u(x,0) &amp; = \sin (\pi x) + 0.1\sin(100\pi x)
\thinspace .\end{split}\]</div>
<p>The initial condition has been chosen such that adding
two solutions like <a href="#equation-diffu:pde1:sol1">(10)</a> constructs
an analytical solution to the problem:</p>
<div class="math" id="equation-diffu:pde1:sol2">
<span class="eqno">(11)</span>\[     u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)\]\[     \thinspace .\]</div>
<p>Figure <a class="reference internal" href="#diffu-pde1-fig-damping"><em>Evolution of the solution of a diffusion problem: initial condition (upper left), 1/100 reduction of the small waves (upper right), 1/10 reduction of the long wave (lower left), and 1/100 reduction of the long wave (lower right)</em></a> illustrates the rapid damping of
rapid oscillations <span class="math">\(\sin (100\pi x)\)</span> and the very much slower damping of the
slowly varying <span class="math">\(\sin (\pi x)\)</span> term. After about <span class="math">\(t=0.5\cdot10^{-4}\)</span> the rapid
oscillations do not have a visible amplitude, while we have to wait
until <span class="math">\(t\sim 0.5\)</span> before the amplitude of the long wave <span class="math">\(\sin (\pi x)\)</span>
becomes invisible.</p>
<div class="figure" id="diffu-pde1-fig-damping">
<img alt="_images/diffusion_damping.png" src="_images/diffusion_damping.png" style="width: 800px;" />
<p class="caption"><em>Evolution of the solution of a diffusion problem: initial condition (upper left), 1/100 reduction of the small waves (upper right), 1/10 reduction of the long wave (lower left), and 1/100 reduction of the long wave (lower right)</em></p>
</div>
<p>The relevance of studying the behavior of a particular solution of the form
<a href="#equation-diffu:pde1:sol1">(10)</a> is related to a Fourier representation of
the solution. We first express the initial condition as a Fourier series</p>
<div class="math">
\[I(x) \approx \sum_{k\in K} b_k e^{ikx},\]</div>
<p>where <span class="math">\(i=\sqrt{-1}\)</span> and <span class="math">\(K\)</span> is a set of <span class="math">\(k\)</span> values needed to build
<span class="math">\(I(x)\)</span> with sufficient accuracy from basic sinusoidal components
<span class="math">\(e^{ikx}\)</span>.  Instead of using a specific sine or cosine function for
the spatial variation, we use a complex exponential function to ease
the hand calculations later.  Letting <span class="math">\(K\)</span> contain infinitely many <span class="math">\(k\)</span>
values makes the sum converge to <span class="math">\(I(x)\)</span> under reasonable assumptions
on the smoothness of <span class="math">\(I(x)\)</span>.</p>
<p>The corresponding
solution <span class="math">\(u\)</span> can now be expressed as</p>
<div class="math" id="equation-diffu:pde1:u:Fourier">
<span class="eqno">(12)</span>\[     u(x,t) \approx \sum_{k\in K} b_k e^{-\alpha k^2t}e^{ikx},\]\[     \thinspace .\]</div>
<p>Note that <a href="#equation-diffu:pde1:sol2">(11)</a> is a special case of
<a href="#equation-diffu:pde1:u:Fourier">(12)</a> where <span class="math">\(K=\{\pi, 100\pi\}\)</span>, <span class="math">\(b_{\pi}=1\)</span>,
and <span class="math">\(b_{100\pi}=0.1\)</span>.</p>
</div>
<div class="section" id="analysis-of-the-finite-difference-schemes">
<span id="diffu-pde1-analysis"></span><h2>Analysis of the finite difference schemes<a class="headerlink" href="#analysis-of-the-finite-difference-schemes" title="Permalink to this headline">¶</a></h2>
<p>We have seen that a general solution of the diffusion equation
can be built as a linear combination of basic components</p>
<div class="math">
\[e^{-\alpha k^2t}e^{ikx} \thinspace .\]</div>
<p>A fundamental question is whether such components are also solutions of
the finite difference schemes. This is indeed the case, but the
amplitude <span class="math">\(\exp{(-\alpha k^2t)}\)</span> might be modified (which also happens when
solving the ODE counterpart <span class="math">\(u'=-\alpha u\)</span>).
We therefore look for numerical solutions of the form</p>
<div class="math" id="equation-diffu:pde1:analysis:uni">
<span class="eqno">(13)</span>\[     u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx},\]</div>
<p>where <span class="math">\(A\)</span> must be determined by inserting the component into an actual scheme.</p>
<div class="section" id="stability-1">
<h3>Stability  (1)<a class="headerlink" href="#stability-1" title="Permalink to this headline">¶</a></h3>
<p>The exact wave component decays according to <span class="math">\(\exp{(-\alpha k^2t)}\)</span>.
We should therefore require <span class="math">\(|A| &lt; 1\)</span> to have a decaying numerical
solution as well. However, if
<span class="math">\(-1\leq A&lt;0\)</span>, <span class="math">\(A^n\)</span> will change sign from time level to
time level, and we get stable, non-physical oscillations in the numerical
solutions that are not present in the exact solution.</p>
</div>
<div class="section" id="accuracy-1">
<span id="index-1"></span><h3>Accuracy  (1)<a class="headerlink" href="#accuracy-1" title="Permalink to this headline">¶</a></h3>
<p>To determine how accurately a finite difference scheme treats one
wave component <a href="#equation-diffu:pde1:analysis:uni">(13)</a>, we see that the basic
deviation from the exact solution is reflected in how well
<span class="math">\(A^n\)</span> approximates <span class="math">\(\exp{(-\alpha k^2t)}=\exp{(-\alpha k^2 n\Delta t)}\)</span>,
or how well the numerical amplification factor
<span class="math">\(A\)</span> approximates the exact amplification factor
<span class="math">\(A_{\small\mbox{e}} = \exp{(-\alpha k^2 \Delta t)}\)</span>.</p>
</div>
</div>
<div class="section" id="analysis-of-the-forward-euler-scheme">
<span id="diffu-pde1-analysis-fe"></span><h2>Analysis of the Forward Euler scheme<a class="headerlink" href="#analysis-of-the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>The Forward Euler finite difference scheme for <span class="math">\(u_t = \alpha u_{xx}\)</span> can
be written as</p>
<div class="math">
\[[D_t^+ u = \alpha D_xD_x u]^n_q\thinspace .\]</div>
<p>Inserting a wave component <a href="#equation-diffu:pde1:analysis:uni">(13)</a>
in the scheme demands calculating the terms</p>
<div class="math">
\[e^{ikq\Delta x}[D_t^+ A]^n = e^{ikq\Delta x}A^n\frac{A-1}{\Delta t},\]</div>
<p>and</p>
<div class="math">
\[A^nD_xD_x [e^{ikx}]_q = A^n\left( - e^{ikq\Delta x}\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)\right)
\thinspace .\]</div>
<p>Inserting these terms in the discrete equation and
dividing by <span class="math">\(A^n e^{ikq\Delta x}\)</span> leads to</p>
<div class="math">
\[\frac{A-1}{\Delta t} = -\alpha \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),\]</div>
<p>and consequently</p>
<div class="math">
\[A = 1 -4C\sin^2\left(
\frac{k\Delta x}{2}\right),\]</div>
<p>where <span class="math">\(C\)</span> is a constant introduced for convenience:</p>
<div class="math">
\[C = \frac{\alpha\Delta t}{\Delta x^2}
\thinspace .\]</div>
<p>The complete numerical solution is then</p>
<div class="math">
\[u^n_q = \left(1 -4C\sin^2\left(
\frac{k\Delta x}{2}\right)\right)^ne^{ikq\Delta x}
\thinspace .\]</div>
<div class="section" id="stability-2">
<h3>Stability  (2)<a class="headerlink" href="#stability-2" title="Permalink to this headline">¶</a></h3>
<p>We easily see that <span class="math">\(A\leq 1\)</span>, but <span class="math">\(A&lt;-1\)</span> might be a possibility that will lead
to growth of a numerical wave component. The criterion <span class="math">\(A\geq -1\)</span> implies</p>
<div class="math">
\[4C\sin^2 (p/2)\leq 2
\thinspace .\]</div>
<p>The worst case is when <span class="math">\(\sin^2 (p/2)=1\)</span>, so a sufficient criterion for
stability is</p>
<div class="math">
\[C\leq \frac{1}{2},\]</div>
<p>or expressed as a condition on <span class="math">\(\Delta t\)</span>:</p>
<div class="math">
\[\Delta t\leq \frac{\Delta x^2}{2\alpha}\thinspace .\]</div>
<p>Note that halving the spatial mesh size, <span class="math">\(\Delta x \rightarrow \frac{1}{2}
\Delta x\)</span>, requires <span class="math">\(\Delta t\)</span> to be reduced by a factor of <span class="math">\(1/4\)</span>.
The method hence becomes very expensive for fine spatial meshes.</p>
</div>
<div class="section" id="accuracy-2">
<h3>Accuracy  (2)<a class="headerlink" href="#accuracy-2" title="Permalink to this headline">¶</a></h3>
<p>Since <span class="math">\(A\)</span> is expressed in terms of <span class="math">\(C\)</span> and the parameter we now call
<span class="math">\(p=k\Delta x\)</span>, we also express <span class="math">\(A_{\small\mbox{e}}\)</span> by <span class="math">\(C\)</span> and <span class="math">\(p\)</span>:</p>
<div class="math">
\[A_{\small\mbox{e}} = \exp{(-\alpha k^2\Delta t)} = \exp{(-Cp^2)}
\thinspace .\]</div>
<p>Computing
the Taylor series expansion of <span class="math">\(A/A_{\small\mbox{e}}\)</span> in terms of <span class="math">\(C\)</span>
can easily be done with aid of <tt class="docutils literal"><span class="pre">sympy</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">A_exact</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">C</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">A_FE</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">C</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;C p&#39;</span><span class="p">)</span>
<span class="n">A_err_FE</span> <span class="o">=</span> <span class="n">A_FE</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">A_exact</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="k">print</span> <span class="n">A_err_FE</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is</p>
<div class="math">
\[\frac{A}{A_{\small\mbox{e}}} = 1 - 4 C \sin^{2}(p/2) + C p^{2} - 4 C^{2} p^{2} \sin^{2}(p/2) + \frac{1}{2} C^{2} p^{4} + \cdots\]</div>
<p>Recalling that <span class="math">\(C=\alpha\Delta t/\Delta x\)</span>, <span class="math">\(p=k\Delta x\)</span>, and that
<span class="math">\(\sin^2(p/2)\leq 1\)</span>, we
realize that the dominating error terms are at most</p>
<div class="math">
\[1 - 4\alpha \frac{\Delta t}{\Delta x^2} +
\alpha\Delta t - 4\alpha^2\Delta t^2
+ \alpha^2 \Delta t^2\Delta x^2 + \cdots
\thinspace .\]</div>
</div>
</div>
<div class="section" id="analysis-of-the-backward-euler-scheme">
<span id="diffu-pde1-analysis-be"></span><h2>Analysis of the Backward Euler scheme<a class="headerlink" href="#analysis-of-the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>Discretizing <span class="math">\(u_t = \alpha u_{xx}\)</span> by a Backward Euler scheme,</p>
<div class="math">
\[[D_t^- u = \alpha D_xD_x u]^n_q,\]</div>
<p>and inserting a wave component <a href="#equation-diffu:pde1:analysis:uni">(13)</a>,
leads to calculations similar to those arising from the Forward Euler scheme,
but since</p>
<div class="math">
\[e^{ikq\Delta x}[D_t^- A]^n = A^ne^{ikq\Delta x}\frac{1 - A^{-1}}{\Delta t},\]</div>
<p>we get</p>
<div class="math">
\[\frac{1-A^{-1}}{\Delta t} = -\alpha \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),\]</div>
<p>and then</p>
<div class="math" id="equation-diffu:pde1:analysis:BE:A">
<span class="eqno">(14)</span>\[     A = \left(1  + 4C\sin^2(p/2)\right)^{-1}\]\[     \thinspace .\]</div>
<p>The complete numerical solution can be written</p>
<div class="math">
\[u^n_q = \left(1  + 4C\sin^2 (p/2)\right)^{-n}
e^{ikq\Delta x} \thinspace .\]</div>
<div class="section" id="stability-3">
<h3>Stability  (3)<a class="headerlink" href="#stability-3" title="Permalink to this headline">¶</a></h3>
<p>We see from <a href="#equation-diffu:pde1:analysis:BE:A">(14)</a> that <span class="math">\(0&lt;A&lt;1\)</span>, which means
that all numerical wave components are stable and non-oscillatory
for any <span class="math">\(\Delta t &gt;0\)</span>.</p>
</div>
</div>
<div class="section" id="analysis-of-the-crank-nicolson-scheme">
<span id="diffu-pde1-analysis-cn"></span><h2>Analysis of the Crank-Nicolson scheme<a class="headerlink" href="#analysis-of-the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p>The Crank-Nicolson scheme can be written as</p>
<div class="math">
\[[D_t u = \alpha D_xD_x \overline{u}^x]^{n+\frac{1}{2}}_q,\]</div>
<p>or</p>
<div class="math">
\[[D_t u]^{n+\frac{1}{2}}_q = \frac{1}{2}\alpha\left( [D_xD_x u]^{n}_q +
[D_xD_x u]^{n+1}_q\right)
\thinspace .\]</div>
<p>Inserting <a href="#equation-diffu:pde1:analysis:uni">(13)</a> in the time derivative approximation
leads to</p>
<div class="math">
\[[D_t A^n e^{ikq\Delta x}]^{n+\frac{1}{2}} = A^{n+\frac{1}{2}} e^{ikq\Delta x}\frac{A^{\frac{1}{2}}-A^{-\frac{1}{2}}}{\Delta t} = A^ne^{ikq\Delta x}\frac{A-1}{\Delta t}
\thinspace .\]</div>
<p>Inserting <a href="#equation-diffu:pde1:analysis:uni">(13)</a> in the other terms
and dividing by
<span class="math">\(A^ne^{ikq\Delta x}\)</span> gives the relation</p>
<div class="math">
\[\frac{A-1}{\Delta t} = -\frac{1}{2}\alpha\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)
(1 + A),\]</div>
<p>and after some more algebra,</p>
<div class="math">
\[A = \frac{ 1 - 2C\sin^2(p/2)}{1 + 2C\sin^2(p/2)}
\thinspace .\]</div>
<p>The exact numerical solution is hence</p>
<div class="math">
\[u^n_q = \left(\frac{ 1 - 2C\sin^2(p/2)}{1 + 2C\sin^2(p/2)}\right)^ne^{ikp\Delta x}
\thinspace .\]</div>
<div class="section" id="stability-4">
<h3>Stability  (4)<a class="headerlink" href="#stability-4" title="Permalink to this headline">¶</a></h3>
<p>The criteria <span class="math">\(A&gt;-1\)</span> and <span class="math">\(A&lt;1\)</span> are fulfilled for any <span class="math">\(\Delta t &gt;0\)</span>.</p>
</div>
</div>
<div class="section" id="summary-of-accuracy-of-amplification-factors">
<h2>Summary of accuracy of amplification factors<a class="headerlink" href="#summary-of-accuracy-of-amplification-factors" title="Permalink to this headline">¶</a></h2>
<p>We can plot the various amplification factors against <span class="math">\(p=k\Delta x\)</span> for
different choices of the <span class="math">\(C\)</span> parameter. Figures <a class="reference internal" href="#diffu-pde1-fig-a-err-c20"><em>Error in amplification factor for large time steps</em></a>,
<a class="reference internal" href="#diffu-pde1-fig-a-err-c0-5"><em>Error in amplification factor for time steps around the Forward Euler stability limit</em></a>, and <a class="reference internal" href="#diffu-pde1-fig-a-err-c0-1"><em>Error in amplification factor for small time steps</em></a>
show how long and small waves are damped by the various schemes compared
to the exact damping. As long as all schemes are stable, the amplification
factor is positive, except for Crank-Nicolson when <span class="math">\(C&gt;0.5\)</span>.</p>
<div class="figure" id="diffu-pde1-fig-a-err-c20">
<img alt="_images/diffusion_A_C20_C2_FDM.png" src="_images/diffusion_A_C20_C2_FDM.png" style="width: 800px;" />
<p class="caption"><em>Error in amplification factor for large time steps</em></p>
</div>
<div class="figure" id="diffu-pde1-fig-a-err-c0-5">
<img alt="_images/diffusion_A_C05_C025_FDM.png" src="_images/diffusion_A_C05_C025_FDM.png" style="width: 800px;" />
<p class="caption"><em>Error in amplification factor for time steps around the Forward Euler stability limit</em></p>
</div>
<div class="figure" id="diffu-pde1-fig-a-err-c0-1">
<img alt="_images/diffusion_A_C01_C001_FDM.png" src="_images/diffusion_A_C01_C001_FDM.png" style="width: 800px;" />
<p class="caption"><em>Error in amplification factor for small time steps</em></p>
</div>
<p>The effect of negative amplification factors is that <span class="math">\(A^n\)</span> changes sign
from one time level to the next, thereby giving rise to oscillations in
time in an animation of the solution. We see from Figure <a class="reference internal" href="#diffu-pde1-fig-a-err-c20"><em>Error in amplification factor for large time steps</em></a> that for <span class="math">\(C=20\)</span>, waves with <span class="math">\(p\geq \pi/2\)</span> undergo a damping close to
<span class="math">\(-1\)</span>, which means that the amplitude does not decay and that the wave component
jumps up and down in time. For <span class="math">\(C=2\)</span> we have a damping of a factor of 0.5
from one time level to the next, which is very much smaller than the
exact damping. Short waves will therefore fail to be effectively dampened.
These waves will manifest themselves as high frequency
oscillatory noise in the solution.</p>
<p>A value <span class="math">\(p=\pi/2\)</span> corresponds to
four mesh points per wave length of <span class="math">\(e^{ikx}\)</span>, while
<span class="math">\(p=\pi\)</span> implies only two points per wave length, which is the smallest number
of points we can have to represent the wave on the mesh.</p>
<p>To demonstrate the oscillatory behavior of the Crank-Nicolson scheme, we
choose an initial condition that leads to short waves with
significant amplitude. A discontinuous <span class="math">\(I(x)\)</span> will in particular serve
this purpose.</p>
<p>Run <span class="math">\(C=...\)</span>...</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite difference methods for diffusion processes</a></li>
<li><a class="reference internal" href="#a-simple-1d-diffusion-equation">A simple 1D diffusion equation</a><ul>
<li><a class="reference internal" href="#forward-euler-scheme">Forward Euler scheme</a></li>
<li><a class="reference internal" href="#backward-euler-scheme">Backward Euler Scheme</a></li>
<li><a class="reference internal" href="#sparse-matrix-implementation">Sparse matrix implementation</a></li>
<li><a class="reference internal" href="#the-rule">The <span class="math">\(\theta\)</span> Rule</a></li>
<li><a class="reference internal" href="#the-laplace-and-poisson-equation-as-the-steady-state-limit">The Laplace and Poisson equation as the steady state limit</a></li>
<li><a class="reference internal" href="#extensions">Extensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-schemes-for-the-diffusion-equation">Analysis of schemes for the diffusion equation</a><ul>
<li><a class="reference internal" href="#properties-of-the-solution">Properties of the solution</a></li>
<li><a class="reference internal" href="#analysis-of-the-finite-difference-schemes">Analysis of the finite difference schemes</a><ul>
<li><a class="reference internal" href="#stability-1">Stability  (1)</a></li>
<li><a class="reference internal" href="#accuracy-1">Accuracy  (1)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-forward-euler-scheme">Analysis of the Forward Euler scheme</a><ul>
<li><a class="reference internal" href="#stability-2">Stability  (2)</a></li>
<li><a class="reference internal" href="#accuracy-2">Accuracy  (2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-backward-euler-scheme">Analysis of the Backward Euler scheme</a><ul>
<li><a class="reference internal" href="#stability-3">Stability  (3)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-crank-nicolson-scheme">Analysis of the Crank-Nicolson scheme</a><ul>
<li><a class="reference internal" href="#stability-4">Stability  (4)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-accuracy-of-amplification-factors">Summary of accuracy of amplification factors</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Finite difference methods for diffusion processes</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Finite difference methods for diffusion processes"
             >previous</a> |</li>
        <li><a href="index.html">Finite difference methods for diffusion processes 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, H. P. Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>