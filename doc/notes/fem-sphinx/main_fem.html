
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Basic finite element methods &mdash; Basic finite element methods 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Basic finite element methods 1.0 documentation" href="index.html" />
    <link rel="prev" title="Basic finite element methods" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Basic finite element methods"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Basic finite element methods 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="basic-finite-element-methods">
<h1>Basic finite element methods<a class="headerlink" href="#basic-finite-element-methods" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Oct 18, 2012</td>
</tr>
</tbody>
</table>
<p>Note: <strong>QUITE PRELIMINARY VERSION</strong></p>
<p>The finite element method is a powerful tool for solving differential
equations, especially in complicated domains and where higher-order
approximations are desired. Figure <a class="reference internal" href="#fem-motivation-fig-dolfin"><em>Domain for flow around a dolphin</em></a> shows
a two-dimensional domain with a non-trivial geometry. The idea is to
divide the domain into triangles (elements) and seek a polynomial approximations
to the unknown functions on each triangle. The method glues these
piecewise approximations together to find a global solution.
Linear and quadratic polynomials over the triangles are particularly
popular.</p>
<div class="figure" id="fem-motivation-fig-dolfin">
<img alt="_images/dolfin_mesh.png" src="_images/dolfin_mesh.png" style="width: 400px;" />
<p class="caption"><em>Domain for flow around a dolphin</em></p>
</div>
<p>Many successful numerical methods for differential equations,
including the finite element method,
aim at approximating the unknown function by a sum</p>
<div class="math" id="equation-fem:u">
<span class="eqno">(1)</span>\[      u(x) = \sum_{i=0}^N c_i\varphi_i(x),\]</div>
<p>where <span class="math">\(\varphi_i(x)\)</span> are prescribed functions and <span class="math">\(c_i\)</span>, <span class="math">\(i=0,\ldots,N\)</span>,
are unknown coefficients to be determined.
Solution methods for differential equations
utilizing <a href="#equation-fem:u">(1)</a> must
have a <em>principle</em> for constructing <span class="math">\(N+1\)</span> equations to
determine <span class="math">\(c_0,\ldots,c_N\)</span>. Then there is a <em>machinery</em> regarding
the actual constructions of the equations for <span class="math">\(c_0,\ldots,c_N\)</span> in a
particular problem. Finally, there is a <em>solve</em> phase for computing
the solution <span class="math">\(c_0,\ldots,c_N\)</span> of the <span class="math">\(N+1\)</span> equations.</p>
<p>Especially in the finite element method, the machinery for constructing
the discrete equations to be implemented on a computer is quite
comprehensive, with many mathematical and implementational
details entering the scene at the
same time. From an ease-of-learning perspective it can therefore be
wise to introduce the computational machinery for a trivial equation:
<span class="math">\(u=f\)</span>. Solving this equation with <span class="math">\(f\)</span> given and <span class="math">\(u\)</span> on the form
<a href="#equation-fem:u">(1)</a> means that we seek an approximation
<span class="math">\(u\)</span> to <span class="math">\(f\)</span>.
This approximation problem has the advantage of introducing most of the
finite element toolbox, but with postponing demanding topics related to
differential equations (e.g., integration by parts, boundary conditions,
and coordinate mappings).
This is the reason why we shall first become familiar
with finite element <em>approximation</em> before addressing
finite element methods for differential equations.</p>
<p>First, we refresh some linear algebra concepts about approximating
vectors in vector spaces. Second, we extend these concepts to
approximating functions in function spaces, using the same
principles and the same notation.
We present examples on approximating functions by  global basis functions with
support throughout the entire domain.
Third, we introduce the finite element type of local basis functions
and explain the computational algorithms for working with such functions.
Three types of approximation principles are covered: 1) the least squares
method, 2) the Galerkin method, and 3) interpolation or collocation.</p>
</div>
<div class="section" id="approximation-of-vectors">
<span id="fem-approx-vec"></span><h1>Approximation of vectors<a class="headerlink" href="#approximation-of-vectors" title="Permalink to this headline">¶</a></h1>
<p>We shall start with introducing two fundamental methods for
determining the coefficients <span class="math">\(c_i\)</span> in <a href="#equation-fem:u">(1)</a> and illustrate
the methods on approximation of vectors, because vectors in vector
spaces is more intuitive than working with functions in function spaces.
The extension from vectors to functions will be trivial as soon as
the fundamental ideas are understood.</p>
<p>The first method of approximation is called the <em>least squares method</em>
and consists in finding <span class="math">\(c_i\)</span> such that the difference <span class="math">\(u-f\)</span>, measured
in some norm, is minimized. That is, we aim at finding the best
approximation <span class="math">\(u\)</span> to <span class="math">\(f\)</span> (in some norm). The second method is not
as intuitive: we find <span class="math">\(u\)</span> such that the error <span class="math">\(u-f\)</span> is orthogonal to
the space where we seek <span class="math">\(u\)</span>. This is known as a <em>Galerkin method</em>
when the principle is used to solve differential equations, but it
applies to the trivial equation <span class="math">\(u=f\)</span>, i.e., approximation as well.
When approximating vectors and functions, the two methods are
equivalent, but this is no longer the case when working with differential
equations.</p>
<div class="section" id="approximation-of-planar-vectors">
<span id="fem-approx-vec-plane"></span><h2>Approximation of planar vectors<a class="headerlink" href="#approximation-of-planar-vectors" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Suppose we have given a vector <span class="math">\(\pmb{f} = (3,5)\)</span> in the <span class="math">\(xy\)</span> plane
and that we want to approximate this vector by a vector aligned
in the direction of the vector <span class="math">\((a,b)\)</span>. Figure <a class="reference internal" href="#fem-approx-vec-plane-fig"><em>Approximation of a two-dimensional vector by a one-dimensional vector</em></a>
depicts the situation.</p>
<div class="figure" id="fem-approx-vec-plane-fig">
<img alt="_images/vecapprox_plane.png" src="_images/vecapprox_plane.png" style="width: 400px;" />
<p class="caption"><em>Approximation of a two-dimensional vector by a one-dimensional vector</em></p>
</div>
<p>We introduce the vector space <span class="math">\(V\)</span>
spanned by the vector <span class="math">\(\pmb{\varphi}_0=(a,b)\)</span>:</p>
<div class="math">
\[V = \mbox{span}\,\{ \pmb{\varphi}_0\}\thinspace .\]</div>
<p>We say that <span class="math">\(\pmb{\varphi}_0\)</span> is a basis vector in the space <span class="math">\(V\)</span>.
Our aim is to find the vector <span class="math">\(\pmb{u} = c_0\pmb{\varphi}_0\in V\)</span> which best approximates
the given vector <span class="math">\(\pmb{f} = (3,5)\)</span>. A reasonable criterion for a best
approximation could be to minimize the length of the difference between
the approximate <span class="math">\(\pmb{u}\)</span> and the given <span class="math">\(\pmb{f}\)</span>. The difference, or error,
<span class="math">\(\pmb{e} = \pmb{f} -\pmb{u}\)</span> has its length given by the <em>norm</em></p>
<div class="math">
\[||\pmb{e}|| = (\pmb{e},\pmb{e})^{\frac{1}{2}},\]</div>
<p>where <span class="math">\((\pmb{e},\pmb{e})\)</span> is the <em>inner product</em> of <span class="math">\(\pmb{e}\)</span> and itself. The inner
product, also called <em>scalar product</em> or <em>dot product</em>, of two vectors
<span class="math">\(\pmb{u}=(u_0,u_1)\)</span> and <span class="math">\(\pmb{v} =(v_0,v_1)\)</span> is defined as</p>
<div class="math">
\[(\pmb{u}, \pmb{v}) = u_0v_0 + u_1v_1\thinspace .\]</div>
<p><em>Remark.</em> We should point out that we use the notation
<span class="math">\((\cdot,\cdot)\)</span> for two different things:
<span class="math">\((a,b)\)</span> for scalar quantities <span class="math">\(a\)</span> and <span class="math">\(b\)</span> means the vector starting in
the origin and ending in the point <span class="math">\((a,b)\)</span>, while <span class="math">\((\pmb{u},\pmb{v})\)</span> with
vectors <span class="math">\(\pmb{u}\)</span> and <span class="math">\(\pmb{v}\)</span> means the inner product of these vectors.
Since vectors are here written in boldface font there should be no
confusion.
Note that the norm associated with this inner product is the usual Eucledian length
of a vector.</p>
<div class="section" id="the-least-squares-method">
<span id="index-1"></span><h3>The least squares method<a class="headerlink" href="#the-least-squares-method" title="Permalink to this headline">¶</a></h3>
<p>We now want to find <span class="math">\(c_0\)</span> such that it minimizes <span class="math">\(||\pmb{e}||\)</span>. The algebra
is simplified if we minimize the square of the norm, <span class="math">\(||\pmb{e}||^2 = (\pmb{e}, \pmb{e})\)</span>.
Define</p>
<div class="math">
\[E(c_0) = (\pmb{e},\pmb{e}) = (\pmb{f} - c_0\pmb{\varphi}_0, \pmb{f} - c_0\pmb{\varphi}_0)
\thinspace .\]</div>
<p>We can rewrite the expressions of the right-hand side to a more
convenient form for further work:</p>
<div class="math" id="equation-fem:vec:E">
<span class="eqno">(2)</span>\[     E(c_0) = (\pmb{f},\pmb{f}) - 2c_0(\pmb{f},\pmb{\varphi}_0) + c_0^2(\pmb{\varphi}_0,\pmb{\varphi}_0)\thinspace .\]</div>
<p>The rewrite results from using the following fundamental rules for inner
product spacesfootnote{It might be wise to refresh some basic linear algebra
by consulting a textbook.
<em class="xref std std-ref">fem:approx:fe:exer:linalg1</em> and <em class="xref std std-ref">fem:approx:fe:exer:linalg2</em> suggest specific tasks
to regain familiarity with fundamental operations on inner product
vector spaces.}:</p>
<div class="math">
\[(\alpha\pmb{u},\pmb{v})=\alpha(\pmb{u},\pmb{v}),\quad \alpha\in\mathbb{R},\]</div>
<div class="math">
\[(\pmb{u} +\pmb{v},\pmb{w}) = (\pmb{u},\pmb{w}) + (\pmb{v}, \pmb{w}),\]</div>
<div class="math">
\[(\pmb{u}, \pmb{v}) = (\pmb{v}, \pmb{u})\thinspace .\]</div>
<p>Minimizing <span class="math">\(E(c_0)\)</span> implies finding <span class="math">\(c_0\)</span> such that</p>
<div class="math">
\[\frac{\partial E}{\partial c_0} = 0\thinspace .\]</div>
<p>Differentiating <a href="#equation-fem:vec:E">(2)</a> with respect to <span class="math">\(c_0\)</span> gives</p>
<div class="math" id="equation-fem:vec:dEdc0:v1">
<span class="eqno">(3)</span>\[     \frac{\partial E}{\partial c_0} = -2(\pmb{f},\pmb{\varphi}_0) + 2c_0 (\pmb{\varphi}_0,\pmb{\varphi}_0)
     \thinspace .\]</div>
<p>Setting the above expression equal to zero and solving for <span class="math">\(c_0\)</span> gives</p>
<div class="math" id="equation-fem:vec:c0">
<span class="eqno">(4)</span>\[     c_0 = \frac{(\pmb{f},\pmb{\varphi}_0)}{(\pmb{\varphi}_0,\pmb{\varphi}_0)},\]</div>
<p>which in the present case with <span class="math">\(\pmb{\varphi}_0=(a,b)\)</span> results in</p>
<div class="math">
\[c_0 = \frac{3a + 5b}{a^2 + b^2}\thinspace .\]</div>
<p>For later, it is worth mentioning that setting
the key equation <a href="#equation-fem:vec:dEdc0:v1">(3)</a> to zero can be rewritten
as</p>
<div class="math">
\[(\pmb{f}-c0\pmb{\varphi}_0,\pmb{\varphi}_0) = 0,\]</div>
<p>or</p>
<div class="math" id="equation-fem:vec:dEdc0:Galerkin">
<span class="eqno">(5)</span>\[     (\pmb{e}, \pmb{\varphi}_0) = 0
     \thinspace .\]</div>
</div>
<div class="section" id="the-galerkin-method">
<span id="index-2"></span><h3>The Galerkin method<a class="headerlink" href="#the-galerkin-method" title="Permalink to this headline">¶</a></h3>
<p>Minimizing <span class="math">\(||\pmb{e}||^2\)</span> implies that <span class="math">\(\pmb{e}\)</span> is
orthogonal to <em>any</em> vector <span class="math">\(\pmb{v}\)</span> in the space <span class="math">\(V\)</span>. This result is
visually quite clear from Figure <em class="xref std std-ref">fem:vecapprox:fig</em> (think of
other vectors along the line <span class="math">\((a,b)\)</span>: all of them will lead to
a larger distance between the approximation and <span class="math">\(\pmb{f}\)</span>).
To see this result mathematically, we
express any <span class="math">\(\pmb{v}\in V\)</span> as <span class="math">\(\pmb{v}=s\pmb{\varphi}_0\)</span> for any scalar parameter <span class="math">\(s\)</span>,
recall that two vectors are orthogonal when their inner product vanishes,
and calculate the inner product</p>
<div class="math">
\[\begin{split}(\pmb{e}, s\pmb{\varphi}_0) &amp;= (\pmb{f} - c_0\pmb{\varphi}_0, s\pmb{\varphi}_0)\\
&amp;= (\pmb{f},s\pmb{\varphi}_0) - (c_0\pmb{\varphi}_0, s\pmb{\varphi}_0)\\
&amp;= s(\pmb{f},s\pmb{\varphi}_0) - sc_0(\pmb{\varphi}_0, s\pmb{\varphi}_0)\\
&amp;= s(\pmb{f},s\pmb{\varphi}_0) - s\frac{(\pmb{f},\pmb{\varphi}_0)}{(\pmb{\varphi}_0,\pmb{\varphi}_0)}(\pmb{\varphi}_0,\pmb{\varphi}_0)\\
&amp;= s\left( (\pmb{f},s\pmb{\varphi}_0) - (\pmb{f},s\pmb{\varphi}_0)\right)\\
&amp;=0\thinspace .\end{split}\]</div>
<p>Therefore, instead of minimizing the square of the norm, we could
demand that <span class="math">\(\pmb{e}\)</span> is orthogonal to any vector in <span class="math">\(V\)</span>.
This is called Galerkin&#8217;s method and stated mathematically as the
equation</p>
<div class="math" id="equation-fem:vec:Galerkin1">
<span class="eqno">(6)</span>\[     (\pmb{e}, \pmb{v}) = 0,\quad\forall\pmb{v}\in V\thinspace .\]</div>
<p>Since an arbitrary <span class="math">\(\pmb{v}\in V\)</span> can be expressed as
<span class="math">\(s\pmb{\varphi}_0\)</span>, <span class="math">\(s\in\mathbb{R}\)</span>,
<a href="#equation-fem:vec:Galerkin1">(6)</a> implies</p>
<div class="math">
\[(\pmb{e},s\pmb{\varphi}_0) = s(\pmb{e}, \pmb{\varphi}_0) = 0,\]</div>
<p>which means that the error must be orthogonal to the basis vector in
the space <span class="math">\(V\)</span>:</p>
<div class="math">
\[(\pmb{e}, \pmb{\varphi}_0)=0\quad\Leftrightarrow\quad
(\pmb{f} - c_0\pmb{\varphi}_0, \pmb{\varphi}_0)=0
\thinspace .\]</div>
<p>The latter equation gives <a href="#equation-fem:vec:c0">(4)</a> for <span class="math">\(c_0\)</span>.
Furthermore, the latter equation also arose
from least squares computations in
<a href="#equation-fem:vec:dEdc0:Galerkin">(5)</a>.</p>
</div>
</div>
<div class="section" id="approximation-of-general-vectors">
<span id="fem-approx-vec-np1dim"></span><h2>Approximation of general vectors<a class="headerlink" href="#approximation-of-general-vectors" title="Permalink to this headline">¶</a></h2>
<p id="index-3">Let us generalize the vector approximation from the previous section
to vectors in spaces with arbitrary dimension. Given some vector <span class="math">\(\pmb{f}\)</span>,
we want to find the best approximation to this vector in
the space</p>
<div class="math">
\[V = \hbox{span}\,\{\pmb{\varphi}_0,\ldots,\pmb{\varphi}_N\}
\thinspace .\]</div>
<p>We assume that the <em>basis vectors</em> <span class="math">\(\pmb{\varphi}_0,\ldots,\pmb{\varphi}_N\)</span> are
linearly independent so that none of them are redundant and
the space has dimension <span class="math">\(N+1\)</span>.
Any vector <span class="math">\(\pmb{u}\in V\)</span> can be written as a linear combination
of the basis vectors,</p>
<div class="math">
\[\pmb{u} = \sum_{j=0}^Nc_j\pmb{\varphi}_j,\]</div>
<p>where <span class="math">\(c_j\in\mathbb{R}\)</span> are scalar coefficients to be determined.</p>
<div class="section" id="id1">
<h3>The least squares method<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Now we want to find <span class="math">\(c_0,\ldots,c_N\)</span> such that <span class="math">\(\pmb{u}\)</span> is the best
approximation to <span class="math">\(\pmb{f}\)</span> in the sense that the distance, or error,
<span class="math">\(\pmb{e} = \pmb{f} - \pmb{u}\)</span> is minimized. Again, we define
the squared distance as a function of the free parameters
<span class="math">\(c_0,\ldots,c_N\)</span>,</p>
<div class="math" id="equation-fem:vec:genE">
<span class="eqno">(7)</span>\[\begin{split}     E(c_0,\ldots,c_N) &amp;= (\pmb{e},\pmb{e}) = (\pmb{f} -\sum_jc_j\pmb{\varphi}_j,\pmb{f} -\sum_jc_j\pmb{\varphi}_j)
     \nonumber\\
     &amp;= (\pmb{f},\pmb{f}) - 2\sum_{j=0}^Nc_j(\pmb{f},\pmb{\varphi}_j) +
     \sum_{p=0}^N\sum_{q=0}^N c_pc_q(\pmb{\varphi}_p,\pmb{\varphi}_q)\thinspace .\end{split}\]</div>
<p>Minimizing this <span class="math">\(E\)</span> with respect to the independent variables
<span class="math">\(c_0,\ldots,c_N\)</span> is obtained by setting</p>
<div class="math">
\[\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\thinspace .\]</div>
<p>The second term in <a href="#equation-fem:vec:genE">(7)</a> is differentiated as follows:</p>
<div class="math">
\[\frac{\partial}{\partial c_i}
\sum_{j=0}^Nc_j(\pmb{f},\pmb{\varphi}_j) = (\pmb{f},\pmb{\varphi}_i),\]</div>
<p>since the expression to be differentiated is a sum and only one term,
<span class="math">\(c_i(\pmb{f},\pmb{\varphi}_i)\)</span>,
contains <span class="math">\(c_i\)</span> and this term is linear in <span class="math">\(c_i\)</span>.
To understand this differentiation in detail, write out the sum specifically for,
e.g, <span class="math">\(N=3\)</span> and <span class="math">\(i=1\)</span>.</p>
<p>The last term in <a href="#equation-fem:vec:genE">(7)</a>
is more tedious to differentiate. We start with</p>
<div class="math">
\[\begin{split}\frac{\partial}{\partial c_i}
c_pc_q =
\left\lbrace\begin{array}{ll}
0, &amp; \hbox{ if } p\neq i\hbox{ and } q\neq i,\\
c_q, &amp; \hbox{ if } p=i\hbox{ and } q\neq i,\\
c_p, &amp; \hbox{ if } p\neq i\hbox{ and } q=i,\\
2c_i, &amp; \hbox{ if } p=q= i,\\
\end{array}\right.\end{split}\]</div>
<p>Then</p>
<div class="math">
\[\frac{\partial}{\partial c_i}
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\pmb{\varphi}_p,\pmb{\varphi}_q)
= \sum_{p=0, p\neq i}^N c_p(\pmb{\varphi}_p,\pmb{\varphi}_i)
+ \sum_{q=0, q\neq i}^N c_q(\pmb{\varphi}_q,\pmb{\varphi}_i)
+2c_i(\pmb{\varphi}_i,\pmb{\varphi}_i)\thinspace .\]</div>
<p>The last term can be included in the other two sums, resulting in</p>
<div class="math">
\[\frac{\partial}{\partial c_i}
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\pmb{\varphi}_p,\pmb{\varphi}_q)
= 2\sum_{j=0}^N c_i(\pmb{\varphi}_j,\pmb{\varphi}_i)\thinspace .\]</div>
<p>It then follows that setting</p>
<div class="math">
\[\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N,\]</div>
<p>leads to a linear system
for <span class="math">\(c_0,\ldots,c_N\)</span>:</p>
<div class="math" id="equation-fem:approx:vec:Np1dim:eqsys">
<span class="eqno">(8)</span>\[     \sum_{j=0}^N A_{i,j} c_j = b_i, \quad i=0,\ldots,N,\]</div>
<p>where</p>
<div class="math">
\[\begin{split}A_{i,j} &amp;= (\pmb{\varphi}_i,\pmb{\varphi}_j),\\
b_i &amp;= (\pmb{\varphi}_i, \pmb{f})\thinspace .\end{split}\]</div>
<p>(Note that we can change the order of the two vectors in the inner
product as desired.)</p>
</div>
<div class="section" id="id2">
<h3>The Galerkin method<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>In analogy with the &#8220;one-dimensional&#8221; example in
the section <a class="reference internal" href="#fem-approx-vec-plane"><em>Approximation of planar vectors</em></a>, it holds also here in the general
case that minimizing the distance
(error) <span class="math">\(\pmb{e}\)</span> is equivalent to demanding that <span class="math">\(\pmb{e}\)</span> is orthogonal to
all <span class="math">\(\pmb{v}\in V\)</span>:</p>
<div class="math" id="equation-fem:approx:vec:Np1dim:Galerkin">
<span id="index-4"></span><span class="eqno">(9)</span>\[     (\pmb{e},\pmb{v})=0,\quad \forall\pmb{v}\in V\thinspace .\]</div>
<p>Since any <span class="math">\(\pmb{v}\in V\)</span> can be written as <span class="math">\(\pmb{v} =\sum_{i=0}^N c_i\pmb{\varphi}_i\)</span>,
the statement <a href="#equation-fem:approx:vec:Np1dim:Galerkin">(9)</a> is equivalent to
saying that</p>
<div class="math">
\[(\pmb{e}, \sum_{i=0}^N c_i\pmb{\varphi}_i) = 0,\]</div>
<p>for any choice of coefficients <span class="math">\(c_0,\ldots,c_N\in\mathbb{R}\)</span>.
The latter equation can be rewritten as</p>
<div class="math">
\[\sum_{i=0}^Nc_i (\pmb{e},\pmb{\varphi}_i) =0\thinspace .\]</div>
<p>If this is to hold for arbitrary values of <span class="math">\(c_0,\ldots,c_N\)</span>,
we must require that each term in the sum vanishes,</p>
<div class="math" id="equation-fem:approx:vec:Np1dim:Galerkin0">
<span class="eqno">(10)</span>\[     (\pmb{e},\pmb{\varphi}_i)=0,\quad i=0,\ldots,N\thinspace .\]</div>
<p>These <span class="math">\(N+1\)</span> equations result in the same linear system as
<a href="#equation-fem:approx:vec:Np1dim:eqsys">(8)</a>:</p>
<div class="math">
\[(\pmb{f} - \sum_{j=0}^Nc_j\pmb{\varphi}_j, \pmb{\varphi}_i) = (\pmb{f}, \pmb{\varphi}_i) - \sum_{j=0}^N
(\pmb{\varphi}_i,\pmb{\varphi}_j)c_j = 0,\]</div>
<p>and hence</p>
<div class="math">
\[\sum_{j=0}^N (\pmb{\varphi}_i,\pmb{\varphi}_j)c_j = (\pmb{f}, \pmb{\varphi}_i),\quad i=0,\ldots, N
\thinspace .\]</div>
<p>So, instead of differentiating the
<span class="math">\(E(c_0,\ldots,c_N)\)</span> function, we could simply use
<a href="#equation-fem:approx:vec:Np1dim:Galerkin">(9)</a> as the principle for
determining <span class="math">\(c_0,\ldots,c_N\)</span>, resulting in the <span class="math">\(N+1\)</span>
equations <a href="#equation-fem:approx:vec:Np1dim:Galerkin0">(10)</a>.</p>
<p>The names <em>least squares method</em> or <em>least squares approximation</em>
are natural since the calculations consists of
minimizing <span class="math">\(||\pmb{e}||^2\)</span>, and <span class="math">\(||\pmb{e}||^2\)</span> is a sum of squares
of differences between the components in <span class="math">\(\pmb{f}\)</span> and <span class="math">\(\pmb{u}\)</span>.
We find <span class="math">\(\pmb{u}\)</span> such that this sum of squares is minimized.</p>
<p>The principle <a href="#equation-fem:approx:vec:Np1dim:Galerkin">(9)</a>,
or the equivalent form <a href="#equation-fem:approx:vec:Np1dim:Galerkin0">(10)</a>, has its name
after the its inventor, the Russian mathematician <a class="reference external" href="http://en.wikipedia.org/wiki/Boris_Galerkin">Boris Galerkin</a>, who
used the approach to solve differential equations.</p>
</div>
</div>
</div>
<div class="section" id="approximation-of-functions">
<span id="fem-approx-global"></span><h1>Approximation of functions<a class="headerlink" href="#approximation-of-functions" title="Permalink to this headline">¶</a></h1>
<p id="index-5">Let <span class="math">\(V\)</span> be a function space spanned by a set of <em>basis functions</em>
<span class="math">\(\varphi_0,\ldots,\varphi_N\)</span>,</p>
<div class="math">
\[V = \hbox{span}\,\{\varphi_0,\ldots,\varphi_N\},\]</div>
<p>such that any function <span class="math">\(u\in V\)</span> can be written as a linear
combination of the basis functions:</p>
<div class="math" id="equation-fem:basic">
<span class="eqno">(11)</span>\[     u = \sum_{j=0}^N c_j\varphi_j\thinspace .\]</div>
<p>For now, in this introduction, we shall look at functions of a
single variable <span class="math">\(x\)</span>:
<span class="math">\(u=u(x)\)</span>, <span class="math">\(\varphi_i=\varphi_i(x)\)</span>, <span class="math">\(i=0,\ldots,N\)</span>. Later, we will extend
the scope to functions of two- or three-dimensional physical spaces.
The approximation <a href="#equation-fem:basic">(11)</a> is typically used
to discretize a problem in space. Other methods, most notably
finite differences, are common for time discretization (although the
form <a href="#equation-fem:basic">(11)</a> can be used in time too).</p>
<div class="section" id="fem-ls">
<span id="id3"></span><h2>The least squares method<a class="headerlink" href="#fem-ls" title="Permalink to this headline">¶</a></h2>
<p>Given a function <span class="math">\(f(x)\)</span>, how can we determine its best approximation
<span class="math">\(u(x)\in V\)</span>? A natural starting point is to apply the same reasoning
as we did for vectors in the section <a class="reference internal" href="#fem-approx-vec-np1dim"><em>Approximation of general vectors</em></a>. That is,
we minimize the distance between <span class="math">\(u\)</span> and <span class="math">\(f\)</span>. However, this requires
a norm for measuring distances, and a norm is most conveniently
defined through an
inner product. Viewing a function as a vector of infinitely
many point values, one for each value of <span class="math">\(x\)</span>, the inner product could
intuitively be defined as the usual summation of
pairwise components, with summation replaced by integration:</p>
<div class="math">
\[(f,g) = \int f(x)g(x)\, dx
\thinspace .\]</div>
<p>To fix the integration domain, we let <span class="math">\(f(x)\)</span> and <span class="math">\(\varphi_i(x)\)</span>
be defined for a domain <span class="math">\(\Omega\subset\mathbb{R}\)</span>.
The inner product of two functions <span class="math">\(f(x)\)</span> and <span class="math">\(g(x)\)</span> is then</p>
<div class="math">
\[(f,g) = \int_\Omega f(x)g(x)\, dx\thinspace .\]</div>
<p>The distance between <span class="math">\(f\)</span> and any function <span class="math">\(u\in V\)</span> is simply
<span class="math">\(f-u\)</span>, and the squared norm of this distance is</p>
<div class="math" id="equation-fem:LS:E">
<span class="eqno">(12)</span>\[     E = (f(x)-\sum_{j=0}^Nc_j\varphi_j(x), f(x)-\sum_{j=0}^Nc_j\varphi_j(x))\thinspace .\]</div>
<p>Note the analogy with <a href="#equation-fem:vec:genE">(7)</a>: the given function
<span class="math">\(f\)</span> plays the role of the given vector <span class="math">\(\pmb{f}\)</span>, and the basis function
<span class="math">\(\varphi_i\)</span> plays the role of the basis vector <span class="math">\(\pmb{\varphi}_i\)</span>.
We get can rewrite <a href="#equation-fem:LS:E">(12)</a>,
through similar steps as used for the result
<a href="#equation-fem:vec:genE">(7)</a>, leading to</p>
<div class="math">
\[E(c_0,\ldots,c_N) = (f,f) -2\sum_{j=0}^N c_j(f,\varphi_i)
+ \sum_{p=0}^N\sum_{q=0}^N c_pc_q(\varphi_p,\varphi_q)\thinspace .\]</div>
<p>Minimizing this function of <span class="math">\(N+1\)</span> scalar variables
<span class="math">\(c_0,\ldots,c_N\)</span> requires differentiation
with respect to <span class="math">\(c_i\)</span>, for <span class="math">\(i=0,\ldots,N\)</span>. The resulting
equations are very similar to those we had in the vector case,
and we hence end up with a
linear system of the form <a href="#equation-fem:approx:vec:Np1dim:eqsys">(8)</a>, with</p>
<div class="math">
\[\begin{split}A_{i,j} &amp;= (\varphi_i,\varphi_j)
\\
b_i &amp;= (f,\varphi_i)\thinspace .\end{split}\]</div>
</div>
<div class="section" id="id4">
<h2>The Galerkin method<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p id="index-6">As in the section <a class="reference internal" href="#fem-approx-vec-np1dim"><em>Approximation of general vectors</em></a>, the minimization of <span class="math">\((e,e)\)</span>
is equivalent to</p>
<div class="math" id="equation-fem:Galerkin">
<span class="eqno">(13)</span>\[     (e,v)=0,\quad\forall v\in V\thinspace .\]</div>
<p>This is known as the Galerkin method for approximating functions.
Using the same reasoning as
in
<a href="#equation-fem:approx:vec:Np1dim:Galerkin">(9)</a>-<a href="#equation-fem:approx:vec:Np1dim:Galerkin0">(10)</a>,
it follows that <a href="#equation-fem:Galerkin">(13)</a> is equivalent to</p>
<div class="math" id="equation-fem:Galerkin0">
<span class="eqno">(14)</span>\[     (e,\varphi_i)=0,\quad i=0,\ldots,N\thinspace .\]</div>
<p>Inserting <span class="math">\(e=f-u\)</span> in this equation and ordering terms, as in the
multi-dimensional vector case, we end up with a linear
system with a coefficient matrix (<em class="xref std std-ref">fem:Aij</em>) and
right-hand side vector (<em class="xref std std-ref">fem:bi</em>).</p>
<p>Whether we work with vectors in the plane, general vectors, or
functions in function spaces, the least squares principle and
the Galerkin method are equivalent.</p>
</div>
<div class="section" id="example-linear-approximation">
<span id="fem-approx-global-linear"></span><h2>Example: linear approximation<a class="headerlink" href="#example-linear-approximation" title="Permalink to this headline">¶</a></h2>
<p>Let us apply the theory in the previous section to a simple problem:
given a parabola <span class="math">\(f(x)=x^2+x+1\)</span> for <span class="math">\(x\in\Omega=[1,2]\)</span>, find
the best approximation <span class="math">\(u(x)\)</span> in the space of all linear functions:</p>
<div class="math">
\[V = \hbox{span}\,\{1, x\}\thinspace .\]</div>
<p>That is, <span class="math">\(\varphi_0(x)=1\)</span>, <span class="math">\(\varphi_1(x)=x\)</span>, and <span class="math">\(N=1\)</span>.
We seek</p>
<div class="math">
\[u=c_0\varphi_0(x) + c_1\varphi_1(x) = c_0 + c_1x,\]</div>
<p>where
<span class="math">\(c_0\)</span> and <span class="math">\(c_1\)</span> are found by solving a <span class="math">\(2\times 2\)</span> the linear system.
The coefficient matrix has elements</p>
<div class="math">
\[\begin{split}A_{0,0} &amp;= (\varphi_0,\varphi_0) = \int_1^21\cdot 1\, dx = 1,\\
A_{0,1} &amp;= (\varphi_0,\varphi_1) = \int_1^2 1\cdot x\, dx = 3/2,\\
A_{1,0} &amp;= A_{0,1} = 3/2,\\
A_{1,1} &amp;= (\varphi_1,\varphi_1) = \int_1^2 x\cdot x\,dx = 7/3\thinspace .\end{split}\]</div>
<p>The corresponding right-hand side is</p>
<div class="math">
\[\begin{split}b_1 &amp;= (f,\varphi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3,\\
b_2 &amp;= (f,\varphi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3\thinspace .\end{split}\]</div>
<p>Solving the linear system results in</p>
<div class="math">
\[c_0 = -38/3,\quad c_1 = 10,\]</div>
<p>and consequently</p>
<div class="math">
\[u(x) = 10x - \frac{38}{3}\thinspace .\]</div>
<p>Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-linear"><em>Best approximation of a parabola by a straight line</em></a> displays the
parabola and its best approximation in the space of all linear functions.</p>
<div class="figure" id="fem-approx-global-fig-parabola-linear">
<img alt="_images/parabola_ls_linear.png" src="_images/parabola_ls_linear.png" style="width: 400px;" />
<p class="caption"><em>Best approximation of a parabola by a straight line</em></p>
</div>
</div>
<div class="section" id="implementation-of-the-least-squares-method">
<span id="fem-approx-global-ls-code"></span><h2>Implementation of the least squares method<a class="headerlink" href="#implementation-of-the-least-squares-method" title="Permalink to this headline">¶</a></h2>
<p>The linear system can be computed either symbolically or
numerically (a numerical integration rule is needed in the latter case).
Here is a function for symbolic computation of the linear system,
where <span class="math">\(f(x)\)</span> is given as a <tt class="docutils literal"><span class="pre">sympy</span></tt> expression <tt class="docutils literal"><span class="pre">f</span></tt> (involving
the symbol <tt class="docutils literal"><span class="pre">x</span></tt>), <tt class="docutils literal"><span class="pre">phi</span></tt> is a list of <span class="math">\(\varphi_0,\ldots,\varphi_N\)</span>,
and <tt class="docutils literal"><span class="pre">Omega</span></tt> is a 2-tuple/list holding the domain <span class="math">\(\Omega\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>

<span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>Observe that we exploit the symmetry of the coefficient matrix:
only the upper triangular part is computed. Symbolic integration in
<tt class="docutils literal"><span class="pre">sympy</span></tt> is often time consuming, and (roughly) halving the
work has noticeable effect on the waiting time for the function to
finish execution.</p>
<p>Comparing the given <span class="math">\(f(x)\)</span> and the approximate <span class="math">\(u(x)\)</span> visually is
done by the following function, which with the aid of
<cite>sympy</cite>&#8216;s <tt class="docutils literal"><span class="pre">lambdify</span></tt> tool converts a <tt class="docutils literal"><span class="pre">sympy</span></tt>
functional expression to a Python function for numerical
computations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;tmp.pdf&#39;</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&quot;numpy&quot;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">u</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s">&quot;numpy&quot;</span><span class="p">)</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="mi">401</span>  <span class="c"># no of points in plot</span>
    <span class="n">xcoor</span>  <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resolution</span><span class="p">)</span>
    <span class="n">exact</span>  <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xcoor</span><span class="p">)</span>
    <span class="n">approx</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">xcoor</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">xcoor</span><span class="p">,</span> <span class="n">approx</span><span class="p">)</span>
    <span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">xcoor</span><span class="p">,</span> <span class="n">exact</span><span class="p">)</span>
    <span class="n">legend</span><span class="p">([</span><span class="s">&#39;approximation&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
    <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">modules='numpy'</span></tt> argument to <tt class="docutils literal"><span class="pre">lambdify</span></tt> is important
if there are mathematical functions, such as <tt class="docutils literal"><span class="pre">sin</span></tt> or <tt class="docutils literal"><span class="pre">exp</span></tt>
in the symbolic expressions in <tt class="docutils literal"><span class="pre">f</span></tt> or <tt class="docutils literal"><span class="pre">u</span></tt>, and these
mathematical functions are to be used with vector arguments, like
<tt class="docutils literal"><span class="pre">xcoor</span></tt> above.</p>
<p>Both the <tt class="docutils literal"><span class="pre">least_squares</span></tt> and
<tt class="docutils literal"><span class="pre">comparison_plot</span></tt>
are found and coded in the file
<a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/fem/fe_approx1D.py">approx1D.py</a>.
The forthcoming examples on their use appear in
<tt class="docutils literal"><span class="pre">ex_approx1D.py</span></tt>.</p>
</div>
<div class="section" id="perfect-approximation">
<span id="fem-approx-global-exact"></span><h2>Perfect approximation<a class="headerlink" href="#perfect-approximation" title="Permalink to this headline">¶</a></h2>
<p>Let us use the code above to recompute the problem from
the section <a class="reference internal" href="#fem-approx-global-linear"><em>Example: linear approximation</em></a> where we want to approximate
a parabola. What happens if we add an element <span class="math">\(x^2\)</span> to the basis and test what
the best approximation is if <span class="math">\(V\)</span> is the space of all parabolic functions?
The answer is quickly found by running</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">approx1D</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span> <span class="n">Omega</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">u</span>
<span class="go">10*x**2 - 20*x + 9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sm</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">10*x**2 - 20*x + 9</span>
</pre></div>
</div>
<p>Now, what if we use <span class="math">\(\phi_i(x)=x^i\)</span> for <span class="math">\(i=0,\ldots,N=40\)</span>?
The output from <tt class="docutils literal"><span class="pre">least_squares</span></tt> gives <span class="math">\(c_i=0\)</span> for <span class="math">\(i&gt;2\)</span>.
In fact, we have a general result that
if <span class="math">\(f\in V\)</span>, the least squares and Galerkin methods compute
the exact solution <span class="math">\(u=f\)</span>.</p>
<p>The proof is straightforward: if <span class="math">\(f\in V\)</span>, <span class="math">\(f\)</span> can be expanded in
terms of the basis functions, <span class="math">\(f=\sum_{j=0}^Nd_j\varphi_j\)</span>, for
some coefficients <span class="math">\(d_0,\ldots,d_N\)</span>,
and the right-hand side then has entries</p>
<div class="math">
\[b_i = (f,\varphi_i) = \sum_{j=0}^Nd_j(\varphi_j, \varphi_i) = \sum_{j=0}^Nd_jA_{i,j}
\thinspace .\]</div>
<p>The linear system <span class="math">\(\sum_jA_{i,j}c_j = b_i\)</span>, <span class="math">\(i=0,\ldots,N\)</span>, is then</p>
<div class="math">
\[\sum_{j=0}^Nc_jA_{i,j} = \sum_{j=0}^Nd_jA_{i,j},\quad i=0,\ldots,N,\]</div>
<p>which implies that <span class="math">\(c_i=d_i\)</span> for <span class="math">\(i=0,\ldots,N\)</span>.</p>
</div>
<div class="section" id="ill-conditioning">
<span id="fem-approx-global-illconditioning"></span><h2>Ill-conditioning<a class="headerlink" href="#ill-conditioning" title="Permalink to this headline">¶</a></h2>
<p>The computational example in the section <a class="reference internal" href="#fem-approx-global-exact"><em>Perfect approximation</em></a>
applies the <tt class="docutils literal"><span class="pre">least_squares</span></tt> function which invokes symbolic
methods to calculate and solve the linear system. The correct
solution <span class="math">\(c_0=9, c_1=-20, c_2=10, c_i=0\)</span> for <span class="math">\(i\geq 3\)</span> is perfectly
recovered.</p>
<p>Suppose we
convert the matrix and right-hand side to floating-point arrays
and then solve the system using finite-precision arithmetics, which
is what one will (almost) always do in real life. This time we
get astonishing results! Up to about <span class="math">\(N=7\)</span> we get a solution that
is reasonably close to the exact one. Increasing <span class="math">\(N\)</span> shows that
seriously wrong coefficients are computed.
Below is a table showing the solution of the linear system arising from
approximating a parabola
by functions on the form <span class="math">\(u(x)=\sum_{j=0}^Nc_jx^j\)</span>, <span class="math">\(N=10\)</span>.
Analytically, we know that <span class="math">\(c_j=0\)</span> for <span class="math">\(j&gt;2\)</span>, but ill-conditioning
may produce <span class="math">\(c_j\neq 0\)</span> for <span class="math">\(j&gt;2\)</span>.</p>
<p>The exact value of <span class="math">\(c_j\)</span>, <span class="math">\(j=0,\ldots,10\)</span>, appears in the first
column while the other columns correspond to results obtained
by three different methods:</p>
<blockquote>
<div><ul class="simple">
<li>Column 2: The matrix and vector are converted to
the data structure  <tt class="docutils literal"><span class="pre">sympy.mpmath.fp.matrix</span></tt> and the
<tt class="docutils literal"><span class="pre">sympy.mpmath.fp.lu_solve</span></tt> function is used to solve the system.</li>
<li>Column 3: The matrix and vector are converted to
<tt class="docutils literal"><span class="pre">numpy</span></tt> arrays with data type <tt class="docutils literal"><span class="pre">numpy.float32</span></tt>
(single precision floating-point number) and solved by
the <tt class="docutils literal"><span class="pre">numpy.linalg.solve</span></tt> function.</li>
<li>Column 4: As column 3, but the data type is
<tt class="docutils literal"><span class="pre">numpy.float64</span></tt> (double
precision floating-point number).</li>
</ul>
</div></blockquote>
<p>We see from the numbers in the table that
double precision performs much better than single precision.
Nevertheless, when plotting all these solutions the curves cannot be
visually distinguished (!). This means that the approximations look
perfect, despite the partially wrong values of the coefficients.</p>
<p>Increasing <span class="math">\(N\)</span> to 12 makes the numerical solver in <tt class="docutils literal"><span class="pre">sympy</span></tt> report
abort with the message: &#8220;matrix is numerically singular&#8221;.
A matrix has to be non-singular to be invertible, which is a requirement
when solving a linear system. Already when the matrix is close to
singular, it is <em>ill-conditioned</em>, which here implies that
the numerical solution algorithms are sensitive to round-off
errors and may produce (very) inaccurate results.</p>
<p>The reason why the coefficient matrix is nearly singular and
ill-conditioned is that our basis functions <span class="math">\(\varphi_i(x)=x^i\)</span> are
nearly linearly dependent for large <span class="math">\(i\)</span>.  That is, <span class="math">\(x^i\)</span> and <span class="math">\(x^{i+1}\)</span>
are very close for <span class="math">\(i\)</span> not very small. This phenomenon is
illustrated in Figure <a class="reference internal" href="#fem-approx-global-fig-illconditioning"><em>The 15 first basis functions , </em></a>.
There are 15 lines in this figure, but only half of them are
visually distinguishable.
Almost linearly dependent basis functions give rise to an
ill-conditioned and almost singular matrix.  This fact can be
illustrated by computing the determinant, which is indeed very close
to zero (recall that a zero determinant implies a singular and
non-invertible matrix): <span class="math">\(10^{-65}\)</span> for <span class="math">\(N=10\)</span> and <span class="math">\(10^{-92}\)</span> for
<span class="math">\(N=12\)</span>. Already for <span class="math">\(N=28\)</span> the numerical determinant computation
returns a plain zero.</p>
<div class="figure" id="fem-approx-global-fig-illconditioning">
<img alt="_images/ill_conditioning.png" src="_images/ill_conditioning.png" style="width: 600px;" />
<p class="caption">The 15 first basis functions <span class="math">\(x^i\)</span>, <span class="math">\(i=0,\ldots,14\)</span></p>
</div>
<p>On the other hand, the double precision <tt class="docutils literal"><span class="pre">numpy</span></tt> solver do run for
<span class="math">\(N=100\)</span>, resulting in answers that are not significantly worse than
those in the table above, and large powers are
associated with small coefficients (e.g., <span class="math">\(c_j&lt;10^{-2}\)</span> for <span class="math">\(10\leq
j\leq 20\)</span> and <span class="math">\(c&lt;10^{-5}\)</span> for <span class="math">\(j&gt;20\)</span>). Even for <span class="math">\(N=100\)</span> the
approximation lies on top of the exact curve in a plot (!).</p>
<p>The conclusion is that visual inspection of the quality of the approximation
may not uncover fundamental numerical problems with the computations.
However, numerical analysts have studied approximations and ill-conditioning
for decades, and it is well known that the basis <span class="math">\(\{1,x,x^2,x^3,\ldots,\}\)</span>
is a bad basis. The best basis from a matrix conditioning point of view
is to have orthogonal functions such that <span class="math">\((\phi_i,\phi_j)=0\)</span> for
<span class="math">\(i\neq j\)</span>. There are many known sets of orthogonal polynomials.
The functions used in the finite element methods are almost orthogonal,
and this property helps to avoid problems with solving matrix systems.
Almost orthogonal is helpful, but not enough when it comes to
partial differential equations, and ill-conditioning
of the coefficient matrix is a theme when solving large-scale finite
element systems.</p>
</div>
<div class="section" id="fourier-series">
<span id="fem-approx-global-fourier"></span><h2>Fourier series<a class="headerlink" href="#fourier-series" title="Permalink to this headline">¶</a></h2>
<p id="index-7">A set of sine functions is widely used for approximating functions.
Let us take</p>
<div class="math">
\[V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\thinspace .\]</div>
<p>That is,</p>
<div class="math">
\[\varphi_i(x) = \sin ((i+1)\pi x),\quad i=0,\ldots,N\thinspace .\]</div>
<p>An approximation to the <span class="math">\(f(x)\)</span> function from
the section <a class="reference internal" href="#fem-approx-global-linear"><em>Example: linear approximation</em></a> can then be computed by the
<tt class="docutils literal"><span class="pre">least_squares</span></tt> function from the section <a class="reference internal" href="#fem-approx-global-ls-code"><em>Implementation of the least squares method</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">Omega</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="n">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine1"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</em></a> (left) shows the oscillatory approximation
of <span class="math">\(\sum_{j=0}^{N}c_j\sin ((j+1)\pi x)\)</span> when <span class="math">\(N=3\)</span>.
Changing <span class="math">\(N\)</span> to 11 improves the approximation considerably, see
Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine1"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</em></a> (right).</p>
<div class="figure" id="fem-approx-global-fig-parabola-sine1">
<img alt="_images/parabola_ls_sines4_12.png" src="_images/parabola_ls_sines4_12.png" style="width: 800px;" />
<p class="caption"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</em></p>
</div>
<p>There is an error <span class="math">\(f(0)-u(0)=9\)</span> at <span class="math">\(x=0\)</span> in Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine1"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</em></a> regardless of how large <span class="math">\(N\)</span> is, because all <span class="math">\(\varphi_i(0)=0\)</span> and hence
<span class="math">\(u(0)=0\)</span>. We may help the approximation to be correct at <span class="math">\(x=0\)</span> by
seeking</p>
<div class="math">
\[u(x) = f(0) + \sum_{j=0}^N c_j\varphi_j(x)
\thinspace .\]</div>
<p>However, this adjustments introduces a new problem at <span class="math">\(x=1\)</span> since
we now get an error <span class="math">\(f(1)-u(1)=f(1)-0=-1\)</span> at this point. A more
clever adjustment is to replace the <span class="math">\(f(0)\)</span> term by a term that
is <span class="math">\(f(0)\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(f(1)\)</span> at <span class="math">\(x=1\)</span>. A simple linear combination
<span class="math">\(f(0)(1-x) + xf(1)\)</span> does the job:</p>
<div class="math">
\[u(x) = f(0)(1-x) + xf(1) + \sum_{j=0}^N c_j\varphi_j(x)
\thinspace .\]</div>
<p>This adjustment of <span class="math">\(u\)</span> alters the linear system slightly as we get an extra
term <span class="math">\(-(f(0)(1-x) + xf(1),\varphi_i)\)</span> on the right-hand side.
Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine2"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions with a boundary term</em></a> shows the result
of ensuring right boundary values: even 3 sines can now adjust the
<span class="math">\(f(0)(1-x) + xf(1)\)</span> term such that <span class="math">\(u\)</span> approximates the parabola really
well, at least visually.</p>
<div class="figure" id="fem-approx-global-fig-parabola-sine2">
<img alt="_images/parabola_ls_sines4_12_wfterm.png" src="_images/parabola_ls_sines4_12_wfterm.png" style="width: 800px;" />
<p class="caption"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions with a boundary term</em></p>
</div>
</div>
<div class="section" id="orthogonal-basis-functions">
<h2>Orthogonal basis functions<a class="headerlink" href="#orthogonal-basis-functions" title="Permalink to this headline">¶</a></h2>
<p>The choice of sine functions <span class="math">\(\varphi_i(x)=\sin ((i+1)\pi x)\)</span> has a great
computational advantage: on <span class="math">\(\Omega=[0,1]\)</span> these basis functions are
<em>orthogonal</em>, implying that <span class="math">\(A_{i,j}=0\)</span> if <span class="math">\(i\neq j\)</span>. This
result is realized by trying</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integrate</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>in <a class="reference external" href="http://wolframalpha.com">WolframAlpha</a>
(avoid <tt class="docutils literal"><span class="pre">i</span></tt> in the integrand as this symbol means
the imaginary unit <span class="math">\(\sqrt{-1}\)</span>).
Also by asking WolframAlpha
about <span class="math">\(\int_0^1\sin^2 (j\pi x) dx\)</span>, we find it
to equal 1/2.
With a diagonal matrix we can easily solve for the coefficients
by hand:</p>
<div class="math">
\[c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx,\quad i=0,\ldots,N,\]</div>
<p>which is nothing but the classical formula for the coefficients of
the Fourier sine series of <span class="math">\(f(x)\)</span> on <span class="math">\([0,1]\)</span>. In fact, when
<span class="math">\(V\)</span> contains the basic functions used in a Fourier series expansion,
the approximation method derived in the section <a class="reference internal" href="#fem-approx-global"><em>Approximation of functions</em></a>
results in the classical Fourier series for <span class="math">\(f(x)\)</span> (see <a class="reference internal" href="#fem-approx-exer-fourier"><em>Exercise 6: Fourier series as a least squares approximation</em></a>
for details).</p>
<p>For orthogonal basis functions we can make the
<tt class="docutils literal"><span class="pre">least_squares</span></tt> function (much) more efficient since we know that
the matrix is diagonal and only the diagonal elements need to be computed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">least_squares_orth</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">,</span>  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>This function is found in the file <tt class="docutils literal"><span class="pre">approx1D.py</span></tt>.</p>
</div>
<div class="section" id="the-collocation-or-interpolation-method">
<span id="fem-approx-global-interp"></span><h2>The collocation or interpolation method<a class="headerlink" href="#the-collocation-or-interpolation-method" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-8"></span><p id="index-9">The principle of minimizing the distance between <span class="math">\(u\)</span> and <span class="math">\(f\)</span> is
an intuitive way of computing a best approximation <span class="math">\(u\in V\)</span> to <span class="math">\(f\)</span>.
However, there are other attractive approaches as well.
One is to demand that <span class="math">\(u(x_{i}) = f(x_{i})\)</span> at some selected points
<span class="math">\(x_{i}\)</span>, <span class="math">\(i=0,\ldots,N\)</span>:</p>
<div class="math">
\[u(x_{i}) = \sum_{j=0}^N c_j \varphi_j(x_{i}) = f(x_{i}),\quad i=0,\ldots,N\thinspace .\]</div>
<p>This criterion also gives a linear system
with <span class="math">\(N+1\)</span> unknown coefficients <span class="math">\(c_0,\ldots,c_N\)</span>:</p>
<div class="math">
\[\sum_{j=0}^N A_{i,j}c_j = b_i,\quad i=0,\ldots,N,\]</div>
<p>with</p>
<div class="math">
\[\begin{split}A_{i,j} &amp;= \varphi_j(x_{i}),\\
b_i &amp;= f(x_{i})\thinspace .\end{split}\]</div>
<p>This time the coefficient matrix is not symmetric because
<span class="math">\(\varphi_j(x_{i})\neq \varphi_i(x_{j})\)</span> in general.
The method is often referred to as a <em>collocation method</em>
and the <span class="math">\(x_{i}\)</span> points are known as <em>collocation points</em>.
Others view the approach as an <em>interpolation method</em>
since some point values of <span class="math">\(f\)</span> are given (<span class="math">\(f(x_{i})\)</span>) and we
fit a continuous function <span class="math">\(u\)</span> that goes through the <span class="math">\(f(x_{i})\)</span> points.
In that case the <span class="math">\(x_{i}\)</span> points are called <em>interpolation points</em>.</p>
<span class="target" id="index-10"></span><p id="index-11">Given <span class="math">\(f\)</span>  as a <tt class="docutils literal"><span class="pre">sympy</span></tt> symbolic expression <tt class="docutils literal"><span class="pre">f</span></tt>, <span class="math">\(\varphi_0,\ldots,\varphi_N\)</span>
as a list <tt class="docutils literal"><span class="pre">phi</span></tt>, and a set of points <span class="math">\(x_0,\ldots,x_N\)</span>  as a list or array
<tt class="docutils literal"><span class="pre">points</span></tt>, the following Python function sets up and solves the matrix system
for the coefficients <span class="math">\(c_0,\ldots,c_N\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">interpolation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="c"># Turn phi and f into Python functions</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>Note that it is convenient to turn the expressions <tt class="docutils literal"><span class="pre">f</span></tt> and
<tt class="docutils literal"><span class="pre">phi</span></tt> into Python functions which can be called with
elements of <tt class="docutils literal"><span class="pre">points</span></tt> as arguments when building the matrix and
the right-hand side.
The <tt class="docutils literal"><span class="pre">interpolation</span></tt> function is a part of the <tt class="docutils literal"><span class="pre">approx1D</span></tt>
module.</p>
<p>A nice feature of the interpolation or collocation method is that it
avoids computing integrals. However, one has to decide on the location
of the <span class="math">\(x_{i}\)</span> points.  A simple, yet common choice, is to
distribute them uniformly throughout <span class="math">\(\Omega\)</span>.</p>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Let us illustrate the interpolation or collocation method by approximating
our parabola <span class="math">\(f(x)=10(x-1)^2-1\)</span> by a linear function on <span class="math">\(\Omega=[1,2]\)</span>,
using two collocation points <span class="math">\(x_0=1+1/3\)</span> and <span class="math">\(x_1=1+2/3\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
<span class="n">Omega</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">interpolation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="n">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting linear system becomes</p>
<div class="math">
\[\begin{split}\left(\begin{array}{ll}
1 &amp; 4/3\\
1 &amp; 5/3\\
\end{array}\right)
\left(\begin{array}{l}
c_0\\
c_1\\
\end{array}\right)
=
\left(\begin{array}{l}
1/9\\
31/9\\
\end{array}\right)\end{split}\]</div>
<p>with solution <span class="math">\(c_0=-119/9\)</span> and <span class="math">\(c_1=10\)</span>.
Figure <a class="reference internal" href="#fem-approx-global-linear-interp-fig1"><em>Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right)</em></a> (left) shows the resulting
approximation <span class="math">\(u=-119/9 + 10x\)</span>.
We can easily test other interpolation points, say <span class="math">\(x_0=1\)</span> and <span class="math">\(x_1=2\)</span>.
This changes the line quite significantly, see
Figure <a class="reference internal" href="#fem-approx-global-linear-interp-fig1"><em>Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right)</em></a> (right).</p>
<div class="figure" id="fem-approx-global-linear-interp-fig1">
<img alt="_images/parabola_inter.png" src="_images/parabola_inter.png" style="width: 800px;" />
<p class="caption"><em>Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right)</em></p>
</div>
</div>
</div>
<div class="section" id="lagrange-polynomials">
<span id="fem-approx-global-lagrange"></span><h2>Lagrange polynomials<a class="headerlink" href="#lagrange-polynomials" title="Permalink to this headline">¶</a></h2>
<p id="index-12">In the section <a class="reference internal" href="#fem-approx-global-fourier"><em>Fourier series</em></a> we explain the advantage with having
a diagonal matrix: formulas for the coefficients <span class="math">\(c_0,\ldots,c_N\)</span> can
then be derived by hand. For a interpolation or collocation method a
diagonal matrix implies that
<span class="math">\(\varphi_j(x_{i}) = 0\)</span> if <span class="math">\(i\neq j\)</span>. One set of basis functions <span class="math">\(\varphi_i(x)\)</span>
with this property is the <em>Lagrange interpolating polynomials</em>,
or just <em>Lagrange polynomials</em>. (Although the functions are named
after Lagrange, they were first discovered by Waring in 1779,
rediscovered by Euler in 1783, and published by Lagrange in 1795.)
The Lagrange polynomials have the form</p>
<div class="math" id="equation-fem:approx:global:Lagrange:poly">
<span class="eqno">(15)</span>\[     \varphi_i(x) =
     \prod_{j=0,j\neq i}^N
     \frac{x-x_{j}}{x_{i}-x_{j}}
     = \frac{x-x_0}{x_{i}-x_0}\cdots\frac{x-x_{i-1}}{x_{i}-x_{i-1}}\frac{x-x_{i+1}}{x_{i}-x_{i+1}}
     \cdots\frac{x-x_N}{x_{i}-x_N},\]</div>
<p>for <span class="math">\(i=0,\ldots,N\)</span>.
We see from <a href="#equation-fem:approx:global:Lagrange:poly">(15)</a> that all the <span class="math">\(\varphi_i\)</span>
functions are polynomials of degree <span class="math">\(N\)</span> which have the property</p>
<div class="math" id="equation-fem:inter:prop">
<span class="eqno">(16)</span>\[\begin{split}     \varphi_i(x_s) = \left\lbrace\begin{array}{ll}
     1, &amp; i=s,\\
     0, &amp; i\neq s,
     \end{array}\right.\end{split}\]</div>
<p>when <span class="math">\(x_s\)</span> is an interpolation (collocation) point.
This property implies that <span class="math">\(A_{i,j}=0\)</span> for <span class="math">\(i\neq j\)</span> and
<span class="math">\(A_{i,j}=1\)</span> when <span class="math">\(i=j\)</span>. The solution of the linear system is
them simply</p>
<div class="math">
\[c_i = f(x_{i}),\quad i=0,\ldots,N,\]</div>
<p>and</p>
<div class="math">
\[u(x) = \sum_{j=0}^N f(x_{i})\varphi_i(x)\thinspace .\]</div>
<p>The following function computes the Lagrange interpolating polynomial
<span class="math">\(\varphi_i(x)\)</span>, given the interpolation points <span class="math">\(x_{0},\ldots,x_{N}\)</span> in
the list or array <tt class="docutils literal"><span class="pre">points</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Lagrange_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">*=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">p</span>
</pre></div>
</div>
<p>The next function computes a complete basis using equidistant points throughout
<span class="math">\(\Omega\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lagrange_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">phi</span><span class="p">,</span> <span class="n">points</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">x</span></tt> is an <tt class="docutils literal"><span class="pre">sm.Symbol</span></tt> object, we let the
spacing between
the interpolation points, <tt class="docutils literal"><span class="pre">h</span></tt>, be a <tt class="docutils literal"><span class="pre">sympy</span></tt> rational number
for nice end results in the formulas for <span class="math">\(\varphi_i\)</span>.
The other case, when <tt class="docutils literal"><span class="pre">x</span></tt> is a plain Python <tt class="docutils literal"><span class="pre">float</span></tt>,
signifies numerical computing, and then we let <tt class="docutils literal"><span class="pre">h</span></tt> be a floating-point
number.
Observe that the <tt class="docutils literal"><span class="pre">Lagrange_polynomial</span></tt> function works equally well
in the symbolic and numerical case (think of <tt class="docutils literal"><span class="pre">x</span></tt> being an
<tt class="docutils literal"><span class="pre">sm.Symbol</span></tt> object or a Python <tt class="docutils literal"><span class="pre">float</span></tt>).
A little interactive session illustrates the difference between symbolic
and numerical computing of the basis functions and points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="n">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span>
<span class="go">[0, 1/2, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span>
<span class="go">[(1 - x)*(1 - 2*x), 2*x*(2 - 2*x), -x*(1 - 2*x)]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c"># numerical computing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="n">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span>
<span class="go">[0.0, 0.5, 1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span>
<span class="go">[-0.0, 1.0, 0.0]</span>
</pre></div>
</div>
<p>The Lagrange polynomials are very much used in finite element methods
because of their property <a href="#equation-fem:inter:prop">(16)</a>.</p>
<div class="section" id="successful-example">
<h3>Successful example<a class="headerlink" href="#successful-example" title="Permalink to this headline">¶</a></h3>
<p>Trying out the Lagrange polynomial basis for approximating
<span class="math">\(f(x)=\sin 2\pi x\)</span> on <span class="math">\(\Omega =[0,1]\)</span> with the least squares
and the interpolation techniques can be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sm</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">phi</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="n">Lagrange_polynomials_01</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">Omega</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="n">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">interpolation</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="n">comparison_plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#fem-approx-global-lagrange-fig-sine-ls-colloc"><em>Approximation via least squares (left) and interpolation (right) of a sine function by Lagrange interpolating polynomials of degree 4</em></a> shows the results.
There is little difference between the least squares and the interpolation
technique. Increasing <span class="math">\(N\)</span> gives visually better approximations.</p>
<div class="figure" id="fem-approx-global-lagrange-fig-sine-ls-colloc">
<img alt="_images/Lagrange_ls_interp_sin_4.png" src="_images/Lagrange_ls_interp_sin_4.png" style="width: 800px;" />
<p class="caption"><em>Approximation via least squares (left) and interpolation (right) of a sine function by Lagrange interpolating polynomials of degree 4</em></p>
</div>
</div>
<div class="section" id="less-successful-example">
<h3>Less successful example<a class="headerlink" href="#less-successful-example" title="Permalink to this headline">¶</a></h3>
<p>The next example concerns interpolating <span class="math">\(f(x)=|1-2x|\)</span> on
<span class="math">\(\Omega =[0,1]\)</span> using Lagrange polynomials. Figure <a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-unif-7-14"><em>Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right)</em></a> shows a peculiar effect: the approximation starts to oscillate
more and more as <span class="math">\(N\)</span> grows. This numerical artifact is not surprising
when looking at the individual Lagrange polynomials: Figure <a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-unif-osc"><em>Illustration of the oscillatory behavior of two Lagrange polynomials for 12 uniformly spaced points (marked by circles)</em></a> shows two such polynomials of degree 11, and it is clear
that the basis functions oscillate significantly. The reason is simple,
since we force the functions to be 1 at one point and 0 at many other
points. A polynomial of high degree is then forced to oscillate between
these points. The oscillations are particularly severe at the boundary.
The phenomenon is named <em>Runge&#8217;s phenomenon</em> and you can read</p>
<p id="index-13">a more detailed explanation on Wikipedia.</p>
</div>
<div class="section" id="remedy-for-strong-oscillations">
<span id="index-14"></span><h3>Remedy for strong oscillations<a class="headerlink" href="#remedy-for-strong-oscillations" title="Permalink to this headline">¶</a></h3>
<p>The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:</p>
<div class="math">
\[x_{i} = \frac{1}{2} (a+b) + \frac{1}{2}(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N,\]</div>
<p>on the interval <span class="math">\(\Omega = [a,b]\)</span>.
Here is a flexible version of the <tt class="docutils literal"><span class="pre">Lagrange_polynomials_01</span></tt> function above,
valid for any interval <span class="math">\(\Omega =[a,b]\)</span> and with the possibility to generate
both uniformly distributed points and Chebyshev nodes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Lagrange_polynomials</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">point_distribution</span><span class="o">=</span><span class="s">&#39;uniform&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">point_distribution</span> <span class="o">==</span> <span class="s">&#39;uniform&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">point_distribution</span> <span class="o">==</span> <span class="s">&#39;Chebyshev&#39;</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">Chebyshev_nodes</span><span class="p">(</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">Lagrange_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">phi</span><span class="p">,</span> <span class="n">points</span>

<span class="k">def</span> <span class="nf">Chebyshev_nodes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>
    <span class="k">return</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span> \
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>All the functions computing Lagrange polynomials listed
above are found in the module file <tt class="docutils literal"><span class="pre">Lagrange.py</span></tt>.
Figure <a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-cheb-7-14"><em>Interpolation of an absolute value function by Lagrange polynomials and Chebyshev nodes as interpolation points: degree 7 (left) and 14 (right)</em></a> shows the improvement of
using Chebyshev nodes (compared with Figure <a class="reference internal" href="#fem-approx-global-lagrange-fig-abs-lag-unif-7-14"><em>Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right)</em></a>).</p>
<p>Another cure for undesired oscillation of higher-degree interpolating
polynomials is to use lower-degree Lagrange
polynomials on many small patches of the domain, which is the idea
pursued in the finite element method. For instance, linear Lagrange
polynomials on <span class="math">\([0,1/2]\)</span> and <span class="math">\([1/2,1]\)</span> would yield a perfect
approximation to <span class="math">\(f(x)=|1-2x|\)</span> on <span class="math">\(\Omega = [0,1]\)</span>
since <span class="math">\(f\)</span> is piecewise linear.</p>
<div class="figure" id="fem-approx-global-lagrange-fig-abs-lag-unif-7-14">
<img alt="_images/Lagrange_interp_abs_8_15.png" src="_images/Lagrange_interp_abs_8_15.png" style="width: 800px;" />
<p class="caption"><em>Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right)</em></p>
</div>
<div class="figure" id="fem-approx-global-lagrange-fig-abs-lag-unif-osc">
<img alt="_images/Lagrange_basis_12.png" src="_images/Lagrange_basis_12.png" style="width: 400px;" />
<p class="caption"><em>Illustration of the oscillatory behavior of two Lagrange polynomials for 12 uniformly spaced points (marked by circles)</em></p>
</div>
<div class="figure" id="fem-approx-global-lagrange-fig-abs-lag-cheb-7-14">
<img alt="_images/Lagrange_interp_abs_Cheb_8_15.png" src="_images/Lagrange_interp_abs_Cheb_8_15.png" style="width: 800px;" />
<p class="caption"><em>Interpolation of an absolute value function by Lagrange polynomials and Chebyshev nodes as interpolation points: degree 7 (left) and 14 (right)</em></p>
</div>
<p>Unfortunately, <tt class="docutils literal"><span class="pre">sympy</span></tt> has problems integrating the <span class="math">\(f(x)=|1-2x|\)</span>
function times a polynomial. Other choices of <span class="math">\(f(x)\)</span> can also
make the symbolic integration fail. Therefore, we should extend
the <tt class="docutils literal"><span class="pre">least_squares</span></tt> function such that it falls back on
numerical integration if the symbolic integration is unsuccessful.
In the latter case, the returned value from <cite>sympy</cite>&#8216;s
<tt class="docutils literal"><span class="pre">integrate</span></tt> function is an object of type <tt class="docutils literal"><span class="pre">Integral</span></tt>.
We can test on this type and utilize the <tt class="docutils literal"><span class="pre">mpmath</span></tt> module in
<tt class="docutils literal"><span class="pre">sympy</span></tt> to perform numerical integration of high precision.
Here is the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">least_squares</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="c"># Could not integrate symbolically, fallback</span>
                <span class="c"># on numerical integration with mpmath.quad</span>
                <span class="n">integrand</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">f</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">integrand</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="n">Omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="finite-element-basis-functions">
<span id="fem-approx-fe"></span><h1>Finite element basis functions<a class="headerlink" href="#finite-element-basis-functions" title="Permalink to this headline">¶</a></h1>
<p>The specific basis functions exemplified in the section <a class="reference internal" href="#fem-approx-global"><em>Approximation of functions</em></a> are in general nonzero on the entire domain
<span class="math">\(\Omega\)</span>, see Figure{fem:approx:fe:fig:u:sin} for an example. We shall
now turn the attention to basis functions that have <em>compact support</em>,
meaning that they are nonzero on only a small portion of
<span class="math">\(\Omega\)</span>. Moreover, we shall restrict the functions to be <em>piecewise
polynomials</em>. This means that the domain is split into subdomains and
the function is a polynomial on one or more subdomains, see Figure
<em class="xref std std-ref">fem:approx:fe:fig:u:sfe</em> for a sketch involving locally defined
hat functions that make <span class="math">\(u=\sum_jc_j\varphi_j\)</span> piecewise linear. At
the boundaries between subdomains one normally forces continuity of
the function only so that when connecting two polynomials from two
subdomains, the derivative usually becomes discontinuous. These type
of basis functions are fundamental in the <em>finite element method</em>.</p>
<div class="figure" id="fem-approx-fe-fig-u-sin">
<img alt="_images/u_example_sin.png" src="_images/u_example_sin.png" style="width: 600px;" />
<p class="caption"><em>Approximation based on sine basis functions</em></p>
</div>
<div class="figure" id="fem-approx-fe-fig-u-fe">
<img alt="_images/u_example_fe.png" src="_images/u_example_fe.png" style="width: 600px;" />
<p class="caption"><em>Approximation based on local piecewise linear (hat) functions</em></p>
</div>
<p>We first introduce the concepts of elements and nodes in a simplistic fashion
as often met in the literature. Later, we shall generalize the concept
of an element, which is a necessary step to treat a wider class of
approximations within the family of finite element methods.
The generalization is also compatible with
the concepts used in the <a class="reference external" href="http://fenicsproject.org">FEniCS</a> finite
element software.</p>
<div class="section" id="elements-and-nodes">
<span id="fem-approx-fe-def-elements-nodes"></span><h2>Elements and nodes<a class="headerlink" href="#elements-and-nodes" title="Permalink to this headline">¶</a></h2>
<p>Let us divide the interval <span class="math">\(\Omega\)</span> on which <span class="math">\(f\)</span> and <span class="math">\(u\)</span> are defined
into non-overlapping subintervals <span class="math">\(\Omega^{(e)}\)</span>, <span class="math">\(e=0,\ldots,n_e\)</span>:</p>
<div class="math">
\[\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(n_e)}\thinspace .\]</div>
<p>We shall for now
refer to <span class="math">\(\Omega^{(e)}\)</span> as an <em>element</em>, having number <span class="math">\(e\)</span>.
On each element we introduce a set of points called <em>nodes</em>.
For now we assume that the nodes are uniformly spaced throughout the
element and that the boundary points of the elements are also nodes.
The nodes are given numbers both within an element and in the global
domain. These are
referred to as <em>local</em> and <em>global</em> node numbers, respectively.</p>
<p>Nodes and elements uniquely define a <em>finite element mesh</em>, which is our
discrete representation of the domain in the computations.
.. index:: finite element mesh</p>
<p id="index-15">A common special case is that of a <em>uniformly partitioned mesh</em> where
each element has the same length and the distance between nodes is constant.</p>
<div class="section" id="id5">
<h3>Example<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>On <span class="math">\(\Omega =[0,1]\)</span> we may introduce two elements,
<span class="math">\(\Omega^{(0)}=[0,0.4]\)</span> and <span class="math">\(\Omega^{(1)}=[0.4,1]\)</span>. Furthermore,
let us introduce three nodes
per element, equally spaced within each element.
The three nodes in element number 0 are <span class="math">\(x_0=0\)</span>, <span class="math">\(x_1=0.2\)</span>, and <span class="math">\(x_2=0.4\)</span>.
The local and global node numbers are here equal.
In element number 1, we have the local nodes <span class="math">\(x_0=0.4\)</span>, <span class="math">\(x_1=0.7\)</span>, and <span class="math">\(x_2=1\)</span>
and the corresponding
global nodes <span class="math">\(x_2=0.4\)</span>, <span class="math">\(x_3=0.7\)</span>, and <span class="math">\(x_4=1\)</span>. Note that
the global node <span class="math">\(x_2=0.4\)</span> is shared by the two elements.</p>
<p>For the purpose of implementation, we introduce two lists or arrays:
<tt class="docutils literal"><span class="pre">nodes</span></tt> for storing the coordinates of the nodes, with the
global node numbers as indices, and <tt class="docutils literal"><span class="pre">elements</span></tt> for holding
the global node numbers in each element, with the local node numbers
as indices. The <tt class="docutils literal"><span class="pre">nodes</span></tt> and <tt class="docutils literal"><span class="pre">elements</span></tt> lists for the sample mesh
above take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">elements</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>Looking up the coordinate of local node number 2 in element 1
is here done by <tt class="docutils literal"><span class="pre">nodes[elements[1][2]]</span></tt> (recall that nodes and
elements start their numbering at 0).</p>
</div>
</div>
<div class="section" id="the-basis-functions">
<h2>The basis functions<a class="headerlink" href="#the-basis-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="construction-principles">
<h3>Construction principles<a class="headerlink" href="#construction-principles" title="Permalink to this headline">¶</a></h3>
<p>Standard finite element basis functions are now defined as follows.
Let <span class="math">\(i\)</span> be the global node number corresponding to local node <span class="math">\(r\)</span>
in element number <span class="math">\(e\)</span>.</p>
<blockquote>
<div><ul class="simple">
<li>If local node number <span class="math">\(r\)</span> is not on the boundary of the element,
take <span class="math">\(\varphi_i(x)\)</span> to be the Lagrange
polynomial that is 1 at the local node number <span class="math">\(r\)</span> and zero
at all other nodes in the element. On all other elements, <span class="math">\(\varphi_i=0\)</span>.</li>
<li>If local node number <span class="math">\(r\)</span> is on the boundary of the element,
let <span class="math">\(\varphi_i\)</span> be made up of the Lagrange polynomial that is 1 at this node
in element number <span class="math">\(e\)</span> and its neighboring element.
On all other elements, <span class="math">\(\varphi_i=0\)</span>.</li>
</ul>
</div></blockquote>
<p>A visual impression of three such basis functions are given in
Figure <em class="xref std std-ref">fem:approx:fe:fig:P2</em>.
Sometimes we refer to a Lagrange polynomial on an element <span class="math">\(e\)</span>, which
means the basis function <span class="math">\(\varphi_i(x)\)</span> when <span class="math">\(x\in\Omega^{(e)}\)</span>, and
<span class="math">\(\varphi_i(x)=0\)</span> when <span class="math">\(x\notin\Omega^{(e)}\)</span>.</p>
<div class="figure" id="fem-approx-fe-fig-p2">
<img alt="_images/mpl_fe_basis_p2_4e.png" src="_images/mpl_fe_basis_p2_4e.png" style="width: 600px;" />
<p class="caption"><em>Illustration of the piecewise quadratic basis functions associated with nodes in element 1</em></p>
</div>
</div>
<div class="section" id="properties-of">
<h3>Properties of <span class="math">\(\varphi_i\)</span><a class="headerlink" href="#properties-of" title="Permalink to this headline">¶</a></h3>
<p>The construction of basis functions according to the principles above
lead to two important properties of <span class="math">\(\varphi_i(x)\)</span>. First,</p>
<div class="math" id="equation-fem:approx:fe:phi:prop1">
<span class="eqno">(17)</span>\[\begin{split}     \varphi_i(x_{j}) =
     \left\lbrace\begin{array}{ll}
     1, &amp; i=j,\\
     0, &amp; i\neq j,
     \end{array}\right.\end{split}\]</div>
<p>when <span class="math">\(x_{j}\)</span> is a node in the mesh with global node number <span class="math">\(j\)</span>,
because the Lagrange polynomials are constructed to have this property.
The property also implies a convenient interpretation of <span class="math">\(c_i\)</span>
as the value of <span class="math">\(u\)</span> at node <span class="math">\(i\)</span>:</p>
<div class="math">
\[u(x_{i}) = \sum_{j=0}^N c_j \varphi_j (x_{i}) =
c_i \varphi_i (x_{i}) = c_i
\thinspace .\]</div>
<p>Because of this interpretation,
the coefficient <span class="math">\(c_i\)</span> is by many named <span class="math">\(u_i\)</span> or <span class="math">\(U_i\)</span>.</p>
<p>Second,
<span class="math">\(\varphi_i(x)\)</span> is mostly zero throughout the domain:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(\varphi_i(x) \neq 0\)</span> only on those elements that contain global node <span class="math">\(i\)</span>,</li>
<li><span class="math">\(\varphi_i(x)\varphi_j(x) \neq 0\)</span> if and only if <span class="math">\(i\)</span> and <span class="math">\(j\)</span> are global node
numbers in the same element.</li>
</ul>
</div></blockquote>
<p>Since <span class="math">\(A_{i,j}\)</span> is the integral of
<span class="math">\(\varphi_i\varphi_j\)</span> it means that
<em>most of the elements in the coefficient matrix will be zero</em>.
We will come back to these properties and use
them actively in computations.</p>
<p>We let each element have <span class="math">\(d+1\)</span> nodes, resulting in local Lagrange
polynomials of degree <span class="math">\(d\)</span>. It is not a requirement to have the same
<span class="math">\(d\)</span> value in each element, but for now we will assume so.</p>
</div>
<div class="section" id="example-on-quadratic">
<h3>Example on quadratic <span class="math">\(\varphi_i\)</span><a class="headerlink" href="#example-on-quadratic" title="Permalink to this headline">¶</a></h3>
<p>Figure <em class="xref std std-ref">fem:approx:fe:fig:P2</em> illustrates how piecewise
quadratic basis functions can look like (<span class="math">\(d=2\)</span>). We work with the
domain <span class="math">\(\Omega = [0,1]\)</span> divided into four equal-sized elements, each having
three nodes.
The <tt class="docutils literal"><span class="pre">nodes</span></tt> and <tt class="docutils literal"><span class="pre">elements</span></tt> lists in this particular example become</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.375</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.875</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="n">elements</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
</pre></div>
</div>
<p>Nodes are marked with circles on the <span class="math">\(x\)</span> axis in the figure, and
element boundaries are marked with vertical dashed lines.</p>
<div class="figure" id="id6">
<img alt="_images/mpl_fe_basis_p2_4e.png" src="_images/mpl_fe_basis_p2_4e.png" style="width: 600px;" />
<p class="caption"><em>Illustration of the piecewise quadratic basis functions associated with nodes in element 1</em></p>
</div>
<p>Let us explain in detail how the basis functions are constructed
according to the principles.
Consider element number 1 in Figure <em class="xref std std-ref">fem:approx:fe:fig:P2</em>,
<span class="math">\(\Omega^{(1)}=[0.25, 0.5]\)</span>, with local nodes
0, 1, and 2 corresponding to global nodes 2, 3, and 4.
The coordinates of these nodes are
<span class="math">\(0.25\)</span>, <span class="math">\(0.375\)</span>, and <span class="math">\(0.5\)</span>, respectively.
We define three Lagrange
polynomials on this element:</p>
<ol class="arabic simple">
<li>The polynomial that is 1 at local node 1
(<span class="math">\(x=0.375\)</span>, global node 3) makes up the basis function
<span class="math">\(\varphi_3(x)\)</span> over this element,
with <span class="math">\(\varphi_3(x)=0\)</span> outside the element.</li>
<li>The Lagrange polynomial that is 1 at local node 0 is the &#8220;right
part&#8221; of the global basis function
<span class="math">\(\varphi_2(x)\)</span>. The &#8220;left part&#8221; of <span class="math">\(\varphi_2(x)\)</span> consists of
a Lagrange polynomial associated with local node 2 in
the neighboring element <span class="math">\(\Omega^{(0)}=[0, 0.25]\)</span>.</li>
<li>Finally, the polynomial that is 1 at local node 2 (global node 4)
is the &#8220;left part&#8221; of the global basis function <span class="math">\(\varphi_4(x)\)</span>.
The &#8220;right part&#8221; comes from the Lagrange polynomial that is 1 at
local node 0 in the neighboring element <span class="math">\(\Omega^{(2)}=[0.5, 0.75]\)</span>.</li>
</ol>
<p>As mentioned earlier,
any global basis function <span class="math">\(\varphi_i(x)\)</span> is zero on elements that
do not share the node with global node number <span class="math">\(i\)</span>.</p>
<p>The other global functions associated with internal
nodes, <span class="math">\(\varphi_1\)</span>, <span class="math">\(\varphi_5\)</span>, and <span class="math">\(\varphi_7\)</span>, are all of the
same shape as the drawn <span class="math">\(\varphi_3\)</span>, while the global basis functions
associated with shared nodes also have the same shape, provided the
elements are of the same length.</p>
<div class="figure" id="fem-approx-fe-fig-p1">
<img alt="_images/mpl_fe_basis_p1_4e.png" src="_images/mpl_fe_basis_p1_4e.png" style="width: 600px;" />
<p class="caption"><em>Illustration of the piecewise linear basis functions associated with nodes in element 1</em></p>
</div>
</div>
<div class="section" id="example-on-linear">
<h3>Example on linear <span class="math">\(\varphi_i\)</span><a class="headerlink" href="#example-on-linear" title="Permalink to this headline">¶</a></h3>
<p>Figure <a class="reference internal" href="#fem-approx-fe-fig-p1"><em>Illustration of the piecewise linear basis functions associated with nodes in element 1</em></a> shows
piecewise linear basis functions (<span class="math">\(d=1\)</span>). Also here we have four elements on
<span class="math">\(\Omega = [0,1]\)</span>. Consider the element <span class="math">\(\Omega^{(1)}=[0.25,0.5]\)</span>.
Now there are no internal nodes in the elements so that all basis
functions are associated with nodes at the element boundaries and hence
made up of two Lagrange polynomials from neighboring elements.
For example, <span class="math">\(\varphi_1(x)\)</span> results from the Lagrange polynomial in
element 0 that is 1 at local node 1 and 0 at local node 0, combined with
the Lagrange polynomial in
element 1 that is 1 at local node 0 and 0 at local node 1.
The other basis functions are constructed similarly.</p>
<p>Explicit mathematical formulas are needed for <span class="math">\(\varphi_i(x)\)</span> in computations.
In the
piecewise linear case, one can show that</p>
<div class="math" id="equation-fem:approx:fe:phi:1:formula1">
<span class="eqno">(18)</span>\[\begin{split}     \varphi_i(x) = \left\lbrace\begin{array}{ll}
     0, &amp; x &lt; x_{i-1},\\
     (x - x_{i-1})/(x_{i} - x_{i-1}),
     &amp; x_{i-1} \leq x &lt; x_{i},\\
     1 -
     (x - x_{i})/(x_{i+1} - x_{i}),
     &amp; x_{i} \leq x &lt; x_{i+1},\\
     0, &amp; x\geq x_{i+1}\thinspace . \end{array}
     \right.\end{split}\]</div>
<p>Here, <span class="math">\(x_{j}\)</span>, <span class="math">\(j=i-1,i,i+1\)</span>, denotes the coordinate of node <span class="math">\(j\)</span>.
For elements of equal length <span class="math">\(h\)</span> the formulas can be simplified to</p>
<div class="math" id="equation-fem:approx:fe:phi:1:formula2">
<span class="eqno">(19)</span>\[\begin{split}     \varphi_i(x) = \left\lbrace\begin{array}{ll}
     0, &amp; x &lt; x_{i-1},\\
     (x - x_{i-1})/h,
     &amp; x_{i-1} \leq x &lt; x_{i},\\
     1 -
     (x - x_{i})/h,
     &amp; x_{i} \leq x &lt; x_{i+1},\\
     0, &amp; x\geq x_{i+1}
     \end{array}
     \right.\end{split}\]</div>
</div>
<div class="section" id="example-on-cubic">
<h3>Example on cubic <span class="math">\(\varphi_i\)</span><a class="headerlink" href="#example-on-cubic" title="Permalink to this headline">¶</a></h3>
<p>Piecewise cubic basis functions can be defined by introducing four
nodes per element. Figure <a class="reference internal" href="#fem-approx-fe-fig-p3"><em>Illustration of the piecewise cubic basis functions associated with nodes in element 1</em></a> shows
examples on <span class="math">\(\varphi_i(x)\)</span>, <span class="math">\(i=3,4,5,6\)</span>, associated with element number 1.
Note that <span class="math">\(\varphi_4\)</span> and <span class="math">\(\varphi_5\)</span> are nonzero on element number 1,
while
<span class="math">\(\varphi_3\)</span> and <span class="math">\(\varphi_6\)</span> are made up of Lagrange polynomials on two
neighboring elements.</p>
<div class="figure" id="fem-approx-fe-fig-p3">
<img alt="_images/mpl_fe_basis_p3_4e.png" src="_images/mpl_fe_basis_p3_4e.png" style="width: 600px;" />
<p class="caption"><em>Illustration of the piecewise cubic basis functions associated with nodes in element 1</em></p>
</div>
<p>We see that all the piecewise linear basis functions have the same
&#8220;hat&#8221; shape. They are naturally referred to as <em>hat functions</em>,
also called <em>chapau functions</em>.
The piecewise quadratic functions in Figure <em class="xref std std-ref">fem:approx:fe:fig:P2</em>
are seen to be of two types. &#8220;Rounded hats&#8221; associated with internal
nodes in the elements and some more &#8220;sombrero&#8221; shaped hats associated
with element boundary nodes. Higher-order basis functions also have
hat-like shapes, but the functions have pronounced oscillations in addition,
as illustrated in Figure <a class="reference internal" href="#fem-approx-fe-fig-p3"><em>Illustration of the piecewise cubic basis functions associated with nodes in element 1</em></a>.</p>
<span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span><p id="index-19">A common terminology is to speak about <em>linear elements</em> as
elements with two local nodes and where the basis functions are
piecewise linear. Similarly, <em>quadratic elements</em> and
<em>cubic elements</em> refer to piecewise quadratic or cubic functions
over elements with three or four local nodes, respectively.
Alternative names, frequently used later, are P1 elements for linear
elements, P2 for quadratic elements, and so forth (P$d$ signifies
degree <span class="math">\(d\)</span> of the polynomial basis functions).</p>
</div>
</div>
<div class="section" id="calculating-the-linear-system">
<span id="fem-approx-global-linearsystem"></span><h2>Calculating the linear system<a class="headerlink" href="#calculating-the-linear-system" title="Permalink to this headline">¶</a></h2>
<p>The elements in the coefficient matrix and right-hand side, given
by the formulas (<em class="xref std std-ref">fem:Aij</em>) and (<em class="xref std std-ref">fem:bi</em>),
will now be calculated for piecewise polynomial basis
functions. Consider P1 (piecewise linear) elements. Nodes and elements
numbered consecutively from left to right imply the nodes
<span class="math">\(x_i=ih\)</span> and the elements</p>
<div class="math">
\[\Omega^{(i)} = [x_{i},x_{i+1}] = [ih, (i+1)h],\quad i=0,\ldots,N-1\thinspace .\]</div>
<p>We have in this case <span class="math">\(N\)</span> elements and <span class="math">\(N+1\)</span> nodes,
and <span class="math">\(\Omega=[x_{0},x_{N}]\)</span>.
The formula for <span class="math">\(\varphi_i(x)\)</span> is given by
<a href="#equation-fem:approx:fe:phi:1:formula2">(19)</a> and a graphical illustration is
provided in Figure <a class="reference internal" href="#fem-approx-fe-fig-p1"><em>Illustration of the piecewise linear basis functions associated with nodes in element 1</em></a>.  First we clearly see
from Figure <a class="reference internal" href="#fem-approx-fe-fig-p1"><em>Illustration of the piecewise linear basis functions associated with nodes in element 1</em></a> that the important property
<span class="math">\(\varphi_i(x)\varphi_j(x)\neq 0\)</span> if and only if <span class="math">\(j=i-1\)</span>, <span class="math">\(j=i\)</span>, or
<span class="math">\(j=i+1\)</span>, or alternatively expressed, if and only if <span class="math">\(i\)</span> and <span class="math">\(j\)</span> are
nodes in the same element. Otherwise, <span class="math">\(\varphi_i\)</span> and <span class="math">\(\varphi_j\)</span> are
too distant to have an overlap and consequently a nonzero product.</p>
<p>The element <span class="math">\(A_{i,i-1}\)</span> in the coefficient matrix can be calculated as</p>
<div class="math">
\[\int_\Omega \varphi_i\varphi_{i-1}dx = \int_{x_{i-1}}^{x_{i}}
\left(1 - \frac{x - x_{i-1}}{h}\right)\frac{x - x_{i}}{h} dx = \frac{h}{6}\thinspace .\]</div>
<p>It turns out that <span class="math">\(A_{i,i+1} =h/6\)</span> as well and that
<span class="math">\(A_{i,i}=2h/3\)</span>. The numbers are modified for <span class="math">\(i=0\)</span> and <span class="math">\(i=N\)</span>:
<span class="math">\(A_{0,0}=h/3\)</span> and <span class="math">\(A_{N,N}=h/3\)</span>.
The general formula for the right-hand side becomes</p>
<div class="math" id="equation-fem:approx:fe:bi:formula1">
<span class="eqno">(20)</span>\[     b_i = \int_{x_{i-1}}^{x_{i}} \frac{x - x_{i-1}}{h} f(x)dx
     + \int_{x_{i}}^{x_{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)dx\thinspace .\]</div>
<p>With two equal-sized elements in <span class="math">\(\Omega=[0,1]\)</span> and <span class="math">\(f(x)=x(1-x)\)</span>, one gets</p>
<div class="math">
\[\begin{split}A = \frac{h}{6}\left(\begin{array}{ccc}
2 &amp; 1 &amp; 0\\
1 &amp; 4 &amp; 1\\
0 &amp; 1 &amp; 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\
12 - 14h\\
10 -17h
\end{array}\right)\thinspace .\end{split}\]</div>
<p>The solution becomes</p>
<div class="math">
\[c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2\thinspace .\]</div>
<p>The resulting function</p>
<div class="math">
\[u(x)=c_0\varphi_0(x) + c_1\varphi_1(x) + c_2\varphi_2(x)\]</div>
<p>is displayed in Figure <a class="reference internal" href="#fem-approx-fe-fig-ls-p1-2-4"><em>Least squares approximation using 2 (left) and 4 (right) P1 elements</em></a> (left).
Doubling the number of elements to four leads to the improved
approximation in the right part of Figure <a class="reference internal" href="#fem-approx-fe-fig-ls-p1-2-4"><em>Least squares approximation using 2 (left) and 4 (right) P1 elements</em></a>.</p>
<div class="figure" id="fem-approx-fe-fig-ls-p1-2-4">
<img alt="_images/fe_p1_x2_2e_4e.png" src="_images/fe_p1_x2_2e_4e.png" style="width: 800px;" />
<p class="caption"><em>Least squares approximation using 2 (left) and 4 (right) P1 elements</em></p>
</div>
</div>
<div class="section" id="assembly-of-elementwise-computations">
<span id="fem-approx-fe-elementwise"></span><h2>Assembly of elementwise computations<a class="headerlink" href="#assembly-of-elementwise-computations" title="Permalink to this headline">¶</a></h2>
<p>The integrals are naturally split into integrals over individual elements
since the formulas change with the elements. This idea of splitting the
integral is fundamental in all practical implementations of the finite
element method.</p>
<p>Let us split the integral over <span class="math">\(\Omega\)</span> into a sum of contributions from
each element:</p>
<div class="math" id="equation-fem:approx:fe:elementwise:Asplit">
<span class="eqno">(21)</span>\[     A_{i,j} = \int_\Omega\varphi_i\varphi_jdx = \sum_{e} A^{(e)}_{i,j},\quad
     A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \varphi_i\varphi_jdx\thinspace .\]</div>
<p>Now, <span class="math">\(A^{(e)}_{i,j}\neq 0\)</span> if and only if <span class="math">\(i\)</span> and <span class="math">\(j\)</span> are nodes in element
<span class="math">\(e\)</span>. Introduce <span class="math">\(i=q(e,r)\)</span> as the mapping of local node number <span class="math">\(r\)</span> in element
<span class="math">\(e\)</span> to the global node number <span class="math">\(i\)</span>. This is just a short mathematical notation
for the expression <tt class="docutils literal"><span class="pre">i=elements[e][r]</span></tt> in a program.
Let <span class="math">\(r\)</span> and <span class="math">\(s\)</span> be the local node numbers corresponding to the global
node numbers <span class="math">\(i=q(e,r)\)</span> and
<span class="math">\(j=q(e,s)\)</span>. With <span class="math">\(d\)</span> nodes per element, all the nonzero elements
in <span class="math">\(A^{(e)}_{i,j}\)</span> arise from the integrals involving basis functions with
indices corresponding to the global node numbers in element number <span class="math">\(e\)</span>:</p>
<div class="math" id="index-20">
\[\int_{\Omega^{(e)}}\varphi_{q(e,r)}\varphi_{q(e,s)}dx,\quad r,s=0,\ldots, d\thinspace .\]</div>
<p>These contributions can be collected in a <span class="math">\((d+1)\times (d+1)\)</span> matrix known as
the <em>element matrix</em>.
We introduce the notation</p>
<div class="math">
\[\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad r,s=0,\ldots,d,\]</div>
<p>for the element matrix. For the case <span class="math">\(d=2\)</span> we have</p>
<div class="math">
\[\begin{split}\tilde A^{(e)} = \left\lbrack\begin{array}{lllll}
\tilde A^{(e)}_{0,0} &amp; \tilde A^{(e)}_{0,1} &amp; \tilde A^{(e)}_{0,2}\\
\tilde A^{(e)}_{1,0} &amp; \tilde A^{(e)}_{1,1} &amp; \tilde A^{(e)}_{1,2}\\
\tilde A^{(e)}_{2,0} &amp; \tilde A^{(e)}_{2,1} &amp; \tilde A^{(e)}_{2,2}
\end{array}\right\rbrack
\thinspace .\end{split}\]</div>
<p>Given the numbers <span class="math">\(\tilde A^{(e)}_{r,s}\)</span>,
we should according to <a href="#equation-fem:approx:fe:elementwise:Asplit">(21)</a>
add the contributions to the global coefficient matrix by</p>
<div class="math">
\[ A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s=0,\ldots,d\thinspace .\]</div>
<p>This process of adding in elementwise contributions to the global matrix
is called <em>finite element assembly</em> or simply <em>assembly</em>.
.. index:: assembly</p>
<p>Figure <a class="reference internal" href="#fem-approx-fe-fig-assembly"><em>Illustration of matrix assembly</em></a> illustrates how element matrices
for elements with two nodes are added into the global matrix.
More specifically, the figure shows how the element matrix associated with
elements 2 and 3 assembled, assuming that global nodes are numbered
from left to right in the domain.</p>
<div class="figure" id="fem-approx-fe-fig-assembly">
<img alt="_images/matrix-assembly.png" src="_images/matrix-assembly.png" style="width: 600px;" />
<p class="caption"><em>Illustration of matrix assembly</em></p>
</div>
<p>The right-hand side of the linear system is also computed elementwise:</p>
<div class="math">
\[b_i = \int_\Omega\varphi_i\varphi_jdx = \sum_{e} b^{(e)}_{i},\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\varphi_i(x)dx\thinspace .\]</div>
<p>We observe that
<span class="math">\(b_i^{(e)}\neq 0\)</span> if and only if global node <span class="math">\(i\)</span> is a node in element <span class="math">\(e\)</span>.
With <span class="math">\(d\)</span> nodes per element we can collect the <span class="math">\(d+1\)</span> nonzero contributions
<span class="math">\(b_i^{(e)}\)</span>, for <span class="math">\(i=q(e,r)\)</span>, <span class="math">\(r=0,\ldots,d\)</span>, in an <em>element vector</em></p>
<div class="math">
\[\tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\},\quad r=0,\ldots,d\thinspace .\]</div>
<p>These contributions are added to the
global right-hand side by an assembly process similar to that for the
element matrices:</p>
<div class="math">
\[b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r,s=0,\ldots,d\thinspace .\]</div>
</div>
<div class="section" id="mapping-to-a-reference-element">
<span id="fem-approx-fe-mapping"></span><h2>Mapping to a reference element<a class="headerlink" href="#mapping-to-a-reference-element" title="Permalink to this headline">¶</a></h2>
<p id="index-21">Instead of computing the integrals</p>
<div class="math">
\[\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\varphi_{q(e,r)}(x)\varphi_{q(e,s)}(x)dx\]</div>
<p>over some element
<span class="math">\(\Omega^{(e)} = [x_L, x_R]\)</span>,
it is convenient to map the element domain <span class="math">\([x_L, x_R]\)</span>
to a standardized reference element domain <span class="math">\([-1,1]\)</span>.
(We have now introduced
<span class="math">\(x_L\)</span> and <span class="math">\(x_R\)</span> as the left and right boundary points of an arbitrary element.
With a natural numbering of nodes and elements from left to right
through the domain, <span class="math">\(x_L=x_{e}\)</span> and <span class="math">\(x_R=x_{e+1}\)</span>.)
Let <span class="math">\(X\)</span> be the coordinate
in the reference element. A linear or <em>affine mapping</em> from <span class="math">\(X\)</span> to <span class="math">\(x\)</span> reads</p>
<div class="math" id="equation-fem:approx:fe:affine:mapping">
<span class="eqno">(22)</span>\[     x = \frac{1}{2} (x_L + x_R) + \frac{1}{2} (x_R - x_L)X\thinspace .\]</div>
<p>This relation can alternatively be expressed by</p>
<div class="math" id="equation-fem:approx:fe:affine:mapping2">
<span class="eqno">(23)</span>\[     x = x_m + \frac{1}{2}hX,\]</div>
<p>where we have introduced the element midpoint <span class="math">\(x_m=(x_L+x_R)/2\)</span> and
the element length <span class="math">\(h=x_R-x_L\)</span>.</p>
<p>Integrating on
the reference element is a matter of just changing the integration
variable from <span class="math">\(x\)</span> to <span class="math">\(X\)</span>. Let</p>
<div class="math">
\[\tilde\varphi_r(X) = \varphi_{q(e,r)}(x(X))\]</div>
<p>be the basis function associated with local node number <span class="math">\(r\)</span> in the
reference element. The integral transformation reads</p>
<div class="math">
\[\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\varphi_{q(e,r)}(x)\varphi_{q(e,s)}(x)dx
= \int_{-1}^1 \tilde\varphi_r(X)\tilde\varphi_s(X)\frac{dx}{dX}dX\thinspace .\]</div>
<p>The stretch factor <span class="math">\(dx/dX\)</span> between the <span class="math">\(x\)</span> and <span class="math">\(X\)</span> coordinates
becomes the determinant of the Jacobian matrix of the mapping
between the coordinate systems in 2D and 3D. To obtain a uniform
notation for 1D, 2D, and 3D problems we therefore replace
<span class="math">\(dx/dX\)</span> by <span class="math">\(\det J\)</span> already now. In 1D, <span class="math">\(\det J = dx/dX = h/2\)</span>.
The integration over the reference element is then written as</p>
<div class="math" id="equation-fem:approx:fe:mapping:Ae">
<span class="eqno">(24)</span>\[     \tilde A^{(e)}_{r,s}
     = \int_{-1}^1 \tilde\varphi_r(X)\tilde\varphi_s(X)\det J\,dX\]\[     \thinspace .\]</div>
<p>The corresponding formula for the element vector entries becomes</p>
<div class="math" id="equation-fem:approx:fe:mapping:be">
<span class="eqno">(25)</span>\[     \tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\varphi_{q(e,r)}(x)dx
     = \int_{-1}^1 f(x(X))\tilde\varphi_r(X)\det J\,dX\]\[     \thinspace .\]</div>
<p>Since we from now on will work in the reference
element, we need explicit mathematical formulas for the basis
functions <span class="math">\(\varphi_i(x)\)</span> in the reference element only, i.e., we only need
to specify formulas for <span class="math">\(\tilde\varphi_r(X)\)</span>.
This is a very convenient simplification compared to specifying
piecewise polynomials in the physical domain.</p>
<p>The <span class="math">\(\tilde\varphi_r(x)\)</span> functions are simply the Lagrange
polynomials defined through the local nodes in the reference element.
For <span class="math">\(d=1\)</span> and two nodes per element, we have the linear Lagrange
polynomials</p>
<div class="math">
\[\begin{split}\tilde\varphi_0(X) &amp;= \frac{1}{2} (1 - X)
\\
\tilde\varphi_1(X) &amp;= \frac{1}{2} (1 + X)\end{split}\]</div>
<p>Quadratic polynomials, <span class="math">\(d=2\)</span>, have the formulas</p>
<div class="math">
\[\begin{split}\tilde\varphi_0(X) &amp;= \frac{1}{2} (X-1)X\\
\tilde\varphi_1(X) &amp;= 1 - X^2\\
\tilde\varphi_2(X) &amp;= \frac{1}{2} (X+1)X\end{split}\]</div>
<p>In general,</p>
<div class="math">
\[\tilde\varphi_r(x) = \prod_{s=0,s\neq r}^d \frac{X-X_{(s)}}{X_{(r)}-X_{(s)}},\]</div>
<p>where <span class="math">\(X_{(0)},\ldots,X_{(d)}\)</span> are the coordinates of the local nodes in
the reference element.
These are normally uniformly spaced: <span class="math">\(X_{(r)} = -1 + 2r/d\)</span>,
<span class="math">\(r=0,\ldots,d\)</span>.</p>
</div>
<div class="section" id="integration-over-a-reference-element">
<span id="fem-approx-fe-intg-ref"></span><h2>Integration over a reference element<a class="headerlink" href="#integration-over-a-reference-element" title="Permalink to this headline">¶</a></h2>
<p>To illustrate the concepts from the previous section in a specific
example, we now
consider calculation of the element matrix and vector for a specific choice of
<span class="math">\(d\)</span> and <span class="math">\(f(x)\)</span>. A simple choice is <span class="math">\(d=1\)</span> and <span class="math">\(f(x)=x(1-x)\)</span>
on <span class="math">\(\Omega =[0,1]\)</span>. We have the general expressions
<a href="#equation-fem:approx:fe:mapping:Ae">(24)</a> and <a href="#equation-fem:approx:fe:mapping:be">(25)</a>
for <span class="math">\(\tilde A^{(e)}_{r,s}\)</span> and <span class="math">\(\tilde b^{(e)}_{r}\)</span>.
Writing these out for the choices (<em class="xref std std-ref">fem:approx:fe:mapping:P1:phi0</em>)
and (<em class="xref std std-ref">fem:approx:fe:mapping:P1:phi1</em>), and using that <span class="math">\(\det J = h/2\)</span>,
we get</p>
<div class="math">
\[\begin{split}\tilde A^{(e)}_{0,0}
&amp;= \int_{-1}^1 \tilde\varphi_0(X)\tilde\varphi_0(X)\frac{h}{2} dX\nonumber\\
&amp;=\int_{-1}^1 \frac{1}{2}(1-X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3},\\
\tilde A^{(e)}_{1,0}
&amp;= \int_{-1}^1 \tilde\varphi_1(X)\tilde\varphi_0(X)\frac{h}{2} dX\nonumber\\
&amp;=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6},\\
\tilde A^{(e)}_{0,1} &amp;= \tilde A^{(e)}_{1,0},\\
\tilde A^{(e)}_{1,1}
&amp;= \int_{-1}^1 \tilde\varphi_1(X)\tilde\varphi_1(X)\frac{h}{2} dX\nonumber\\
&amp;=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\thinspace .\end{split}\]</div>
<div class="math">
\[\begin{split}\tilde b^{(e)}_{0}
&amp;= \int_{-1}^1 f(x(X))\tilde\varphi_0(X)\frac{h}{2} dX\nonumber\\
&amp;= \int_{-1}^1 (x_m + \frac{1}{2} hX)(1-(x_m + \frac{1}{2} hX))
\frac{1}{2}(1-X)\frac{h}{2} dX \nonumber\\
&amp;= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\tilde b^{(e)}_{1}\\
&amp;= \int_{-1}^1 f(x(X))\tilde\varphi_0(X)\frac{h}{2} dX\nonumber\\
&amp;= \int_{-1}^1 (x_m + \frac{1}{2} hX)(1-(x_m + \frac{1}{2} hX))
\frac{1}{2}(1+X)\frac{h}{2} dX \nonumber\\
&amp;= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\thinspace .\end{split}\]</div>
<p>In the last two expressions we have used the element midpoint <span class="math">\(x_m\)</span>.</p>
<p>Integration of lower-degree polynomials above is tedious,
and higher-degree polynomials that very much more algebra, but <tt class="docutils literal"><span class="pre">sympy</span></tt>
may help. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">x_m</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x x_m h X&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">X</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">h/3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">X</span><span class="p">),</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">h/6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x_m</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_0</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">X</span><span class="p">),</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">b_0</span>
<span class="go">-h**3/24 + h**2*x_m/6 - h**2/12 - h*x_m**2/2 + h*x_m/2</span>
</pre></div>
</div>
<p>For inclusion of formulas in documents 9like the present one), <tt class="docutils literal"><span class="pre">sympy</span></tt> can print
expressions in LaTeX format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sm</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">b_0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;plain&#39;</span><span class="p">)</span>
<span class="go">- \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m}</span>
<span class="go">- \frac{1}{12} h^{2} - \frac{1}{2} h x_{m}^{2}</span>
<span class="go">+ \frac{1}{2} h x_{m}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="implementation">
<h1>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<p>Based on the experience from the previous example, it makes
sense to write some code to automate the integration process
for any choice of finite element basis functions. In addition,
we can automate the assembly process and linear system
solution. Appropriate
functions for this purpose document all details of all
steps in the finite element computations and can found in the module file
<a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/fem/fe_approx1D.py">fe_approx1D.py</a>. Some of the functions are explained below.</p>
<div class="section" id="integration">
<h2>Integration<a class="headerlink" href="#integration" title="Permalink to this headline">¶</a></h2>
<p>First we need a Python function for
defining <span class="math">\(\tilde\varphi_r(X)\)</span> in terms of a Lagrange polynomial
of degree <tt class="docutils literal"><span class="pre">d</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">phi_r</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>  <span class="c"># node spacing</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># assume X is numeric: use floats for nodes</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Lagrange_polynomial</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Lagrange_polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">*=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">p</span>
</pre></div>
</div>
<p>Observe how we construct the <tt class="docutils literal"><span class="pre">phi_r</span></tt> function to be
a symbolic expression for <span class="math">\(\tilde\varphi_r(X)\)</span> if <tt class="docutils literal"><span class="pre">X</span></tt> is a
<tt class="docutils literal"><span class="pre">Symbol</span></tt> object from <tt class="docutils literal"><span class="pre">sympy</span></tt>. Otherwise, we assume that <tt class="docutils literal"><span class="pre">X</span></tt>
is a <tt class="docutils literal"><span class="pre">float</span></tt> object and compute the corresponding
floating-point value of <span class="math">\(\tilde\varphi_r(X)\)</span>. The
<tt class="docutils literal"><span class="pre">Lagrange_polynomial</span></tt> function, copied here
from the section <a class="reference internal" href="#fem-approx-global-fourier"><em>Fourier series</em></a>,
works with both symbolic and
numeric <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">points</span></tt> variables.</p>
<p>The complete basis <span class="math">\(\tilde\varphi_0(X),\ldots,\tilde\varphi_d(X)\)</span>
on the reference element is constructed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="n">phi_r</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">phi</span>
</pre></div>
</div>
<p>Now we are in a position to write the function for computing
the element matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">element_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">A_e</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;h&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">detJ</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span>  <span class="c"># dx/dX</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="n">detJ</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">A_e</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">A_e</span>
</pre></div>
</div>
<p>In the symbolic case (<tt class="docutils literal"><span class="pre">symbolic</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt>),
we introduce the element length as a symbol
<tt class="docutils literal"><span class="pre">h</span></tt> in the computations. Otherwise, the real numerical value
of the element interval <tt class="docutils literal"><span class="pre">Omega_e</span></tt>
is used and the final matrix elements are numbers,
not symbols.
This functionality can be demonstrated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fe_approx1D</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span>
<span class="go">[1/2 - X/2, 1/2 + X/2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[h/3, h/6]</span>
<span class="go">[h/6, h/3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">element_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[0.0333333333333333, 0.0166666666666667]</span>
<span class="go">[0.0166666666666667, 0.0333333333333333]</span>
</pre></div>
</div>
<p>The computation of the element vector is done by a similar
procedure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">element_vector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">b_e</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c"># Make f a function of X</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;h&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">X</span>  <span class="c"># mapping</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  <span class="c"># substitute mapping formula for x</span>
    <span class="n">detJ</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span>  <span class="c"># dx/dX</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">detJ</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">b_e</span>
</pre></div>
</div>
<p>Here we need to replace the symbol <tt class="docutils literal"><span class="pre">x</span></tt> in the expression for <tt class="docutils literal"><span class="pre">f</span></tt>
by the mapping formula such that <tt class="docutils literal"><span class="pre">f</span></tt> contains the variable <tt class="docutils literal"><span class="pre">X</span></tt>.</p>
<p>The integration in the element matrix function involves only products
of polynomials, which <tt class="docutils literal"><span class="pre">sympy</span></tt> can easily deal with, but for the
right-hand side <tt class="docutils literal"><span class="pre">sympy</span></tt> may face difficulties with certain types of
expressions <tt class="docutils literal"><span class="pre">f</span></tt>. The result of the integral is then an <tt class="docutils literal"><span class="pre">Integral</span></tt>
object and not a number as when symbolic integration is successful.
It may therefore be wise to introduce a fallback on numerical
integration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">element_vector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">detJ</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sm</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Omega_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># Ensure h is numerical</span>
            <span class="n">detJ</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">integrand</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">X</span><span class="p">],</span> <span class="n">f</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">detJ</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">mpmath</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Successful numerical integration requires that the symbolic
integrand is converted
to a plain Python function (<tt class="docutils literal"><span class="pre">integrand</span></tt>) and that
the element length <tt class="docutils literal"><span class="pre">h</span></tt> is a real number.</p>
</div>
<div class="section" id="linear-system-assembly-and-solution">
<h2>Linear system assembly and solution<a class="headerlink" href="#linear-system-assembly-and-solution" title="Permalink to this headline">¶</a></h2>
<p>The complete algorithm
for computing and assembling the elementwise contributions
takes the following form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">assemble</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">n_n</span><span class="p">,</span> <span class="n">n_e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
    <span class="n">zeros</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">zeros</span> <span class="k">if</span> <span class="n">symbolic</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">n_n</span><span class="p">,</span> <span class="n">n_n</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">n_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_e</span><span class="p">):</span>
        <span class="n">Omega_e</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span>

        <span class="n">A_e</span> <span class="o">=</span> <span class="n">element_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="p">)</span>
        <span class="n">b_e</span> <span class="o">=</span> <span class="n">element_vector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">Omega_e</span><span class="p">,</span> <span class="n">symbolic</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">])):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">])):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">],</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">s</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
            <span class="n">b</span><span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">nodes</span></tt> and <tt class="docutils literal"><span class="pre">elements</span></tt> variables represent the finite
element mesh as explained earlier.</p>
<p>Given the coefficient matrix <tt class="docutils literal"><span class="pre">A</span></tt> and the right-hand side <tt class="docutils literal"><span class="pre">b</span></tt>,
we can compute the coefficients <span class="math">\(c_0,\ldots,c_N\)</span> in the expansion
<span class="math">\(u(x)=\sum_jc_j\varphi_j\)</span> as the solution vector <tt class="docutils literal"><span class="pre">c</span></tt> of the linear
system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">symbolic</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are <tt class="docutils literal"><span class="pre">sympy</span></tt> arrays,
solution procedure implied by <tt class="docutils literal"><span class="pre">A.LUsolve</span></tt> is symbolic,
otherwise, when <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays, a standard
numerical solver is called.
The symbolic version is suited for small problems only
(small <span class="math">\(N\)</span> values) since the calculation time becomes prohibitively large
otherwise. Normally, the symbolic integration will be more time
consuming in small problems than the symbolic solution of the linear system.</p>
</div>
<div class="section" id="example-on-computing-approximations">
<h2>Example on computing approximations<a class="headerlink" href="#example-on-computing-approximations" title="Permalink to this headline">¶</a></h2>
<p>We can exemplify the use of <tt class="docutils literal"><span class="pre">assemble</span></tt> on the computational
case from the section <a class="reference internal" href="#fem-approx-global-linearsystem"><em>Calculating the linear system</em></a> with
two P1 elements (linear basis functions) on the domain <span class="math">\(\Omega=[0,1]\)</span>.
Let us first work with a symbolic element length:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;h x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elements</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[h/3,   h/6,   0]</span>
<span class="go">[h/6, 2*h/3, h/6]</span>
<span class="go">[  0,   h/6, h/3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">[     h**2/6 - h**3/12]</span>
<span class="go">[      h**2 - 7*h**3/6]</span>
<span class="go">[5*h**2/6 - 17*h**3/12]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">[                           h**2/6]</span>
<span class="go">[12*(7*h**2/12 - 35*h**3/72)/(7*h)]</span>
<span class="go">[  7*(4*h**2/7 - 23*h**3/21)/(2*h)]</span>
</pre></div>
</div>
<p>We may, for comparison, compute the <tt class="docutils literal"><span class="pre">c</span></tt> vector for an interpolation or
collocation method, taking the nodes as collocation points.
This is carried out by evaluating <tt class="docutils literal"><span class="pre">f</span></tt> numerically at the nodes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fn</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span> <span class="k">for</span> <span class="n">xc</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">[0, h*(1 - h), 2*h*(1 - 2*h)]</span>
</pre></div>
</div>
<p>The corresponding numerical computations, as done by <tt class="docutils literal"><span class="pre">sympy</span></tt> and
still based on symbolic integration, goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elements</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[ 0.166666666666667, 0.0833333333333333,                  0]</span>
<span class="go">[0.0833333333333333,  0.333333333333333, 0.0833333333333333]</span>
<span class="go">[                 0, 0.0833333333333333,  0.166666666666667]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">[          0.03125]</span>
<span class="go">[0.104166666666667]</span>
<span class="go">[          0.03125]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">[0.0416666666666666]</span>
<span class="go">[ 0.291666666666667]</span>
<span class="go">[0.0416666666666666]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">fe_approx1D</span></tt> module contains functions for generating the
<tt class="docutils literal"><span class="pre">nodes</span></tt> and <tt class="docutils literal"><span class="pre">elements</span></tt> lists for equal-sized elements with
any number of nodes per element. The coordinates in <tt class="docutils literal"><span class="pre">nodes</span></tt>
can be expressed either through the element length symbol <tt class="docutils literal"><span class="pre">h</span></tt>
or by real numbers. There is also a function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">approximate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_e</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;tmp.pdf&#39;</span><span class="p">):</span>
</pre></div>
</div>
<p>which computes a mesh with <tt class="docutils literal"><span class="pre">n_e</span></tt> elements, basis functions of
degree <tt class="docutils literal"><span class="pre">d</span></tt>, and approximates a given symbolic expression
<tt class="docutils literal"><span class="pre">f</span></tt> by a finite element expansion <span class="math">\(u(x) = \sum_jc_j\varphi_j(x)\)</span>.
When <tt class="docutils literal"><span class="pre">symbolic</span></tt> is <tt class="docutils literal"><span class="pre">False</span></tt>, <span class="math">\(u(x)\)</span> can be computed at a (large)
number of points and plotted together with <span class="math">\(f(x)\)</span>. The construction
of <span class="math">\(u\)</span> points from the solution vector <tt class="docutils literal"><span class="pre">c</span></tt> is done
elementwise by evaluating <span class="math">\(\sum_rc_r\tilde\varphi_r(X)\)</span> at a (large)
number of points in each element, and the discrete <span class="math">\((x,u)\)</span> values on
each elements are stored in arrays that are finally
concatenated to form global arrays
with the <span class="math">\(x\)</span> and <span class="math">\(u\)</span> coordinates for plotting. The details are
found in the <tt class="docutils literal"><span class="pre">u_glob</span></tt> function in
<tt class="docutils literal"><span class="pre">fe_approx1D.py</span></tt>.</p>
</div>
<div class="section" id="the-structure-of-the-coefficient-matrix">
<span id="fem-approx-fe-a-structure"></span><h2>The structure of the coefficient matrix<a class="headerlink" href="#the-structure-of-the-coefficient-matrix" title="Permalink to this headline">¶</a></h2>
<p>Let us first see how the global matrix looks like if we assemble
symbolic element matrices, expressed in terms of <tt class="docutils literal"><span class="pre">h</span></tt>, from
several elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">n_e</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span> <span class="n">Omega</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># 8 linear elements on [0,1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">mesh_symbolic</span><span class="p">(</span><span class="n">n_e</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">Omega</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">[h/3,   h/6,     0,     0,     0,     0,     0,     0,   0]</span>
<span class="go">[h/6, 2*h/3,   h/6,     0,     0,     0,     0,     0,   0]</span>
<span class="go">[  0,   h/6, 2*h/3,   h/6,     0,     0,     0,     0,   0]</span>
<span class="go">[  0,     0,   h/6, 2*h/3,   h/6,     0,     0,     0,   0]</span>
<span class="go">[  0,     0,     0,   h/6, 2*h/3,   h/6,     0,     0,   0]</span>
<span class="go">[  0,     0,     0,     0,   h/6, 2*h/3,   h/6,     0,   0]</span>
<span class="go">[  0,     0,     0,     0,     0,   h/6, 2*h/3,   h/6,   0]</span>
<span class="go">[  0,     0,     0,     0,     0,     0,   h/6, 2*h/3, h/6]</span>
<span class="go">[  0,     0,     0,     0,     0,     0,     0,   h/6, h/3]</span>
</pre></div>
</div>
<p>(The reader is encouraged to assemble the element matrices by hand and verify
this result, as this exercise will give a hands-on understanding of
what the assembly is about.) In general we have a coefficient matrix that is
tridiagonal:</p>
<div class="math">
\[\begin{split}A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 &amp; 1 &amp; 0
&amp;\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0 \\
1 &amp; 4 &amp; 1 &amp; \ddots &amp;   &amp; &amp;  &amp; &amp;  \vdots \\
0 &amp; 1 &amp; 4 &amp; 1 &amp;
\ddots &amp; &amp;  &amp;  &amp; \vdots \\
\vdots &amp; \ddots &amp;  &amp; \ddots &amp; \ddots &amp; 0 &amp;  &amp; &amp; \vdots \\
\vdots &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp; \vdots \\
\vdots &amp; &amp;  &amp; 0 &amp; 1 &amp; 4 &amp; 1 &amp; \ddots &amp; \vdots \\
\vdots &amp; &amp; &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp;\ddots  &amp; 0 \\
\vdots &amp; &amp; &amp; &amp;  &amp;\ddots  &amp; 1  &amp; 4  &amp; 1 \\
0 &amp;\cdots &amp; \cdots &amp;\cdots &amp; \cdots &amp; \cdots  &amp; 0 &amp; 1 &amp; 2
\end{array}
\right)\end{split}\]</div>
<p>The structure of the right-hand side is more difficult to reveal since
it involves an assembly of elementwise integrals of
<span class="math">\(f(x(X))\tilde\varphi_r(X)h/2\)</span>, which obviously depend on the
particular choice of <span class="math">\(f(x)\)</span>.
It is easier to look at the integration in <span class="math">\(x\)</span> coordinates, which
gives the general formula <a href="#equation-fem:approx:fe:bi:formula1">(20)</a>.
For equal-sized elements of length <span class="math">\(h\)</span>, we can apply the
Trapezoidal rule at the global node points to arrive at a somewhat more specific
expression than <a href="#equation-fem:approx:fe:bi:formula1">(20)</a>:</p>
<div class="math">
\[\begin{split}b_i &amp;= h\left( \frac{1}{2} \phi_i(x_{0})f(x_{0}) +
\frac{1}{2} \phi_i(x_{N})f(x_{N}) + \sum_{j=1}^{N-1}
\phi_i(x_{i})f(x_{i})\right)\\
&amp; =
\left\lbrace\begin{array}{ll}
\frac{1}{2} hf(x_i),&amp; i=0\hbox{ or }i=N,\\
h f(x_i), &amp; 1 \leq i \leq N-1
\end{array}\right.\end{split}\]</div>
<p>The reason for this simple formula is simply that <span class="math">\(\phi_i\)</span> is either
0 or 1 at the nodes and 0 at all but one of them.</p>
<p>Going to P2 elements (<tt class="docutils literal"><span class="pre">d=2</span></tt>) leads
to the element matrix</p>
<div class="math">
\[\begin{split}A^{(e)} = \frac{h}{30}
\left(\begin{array}{ccc}
4 &amp; 2 &amp; -1\\
2 &amp; 16 &amp; 2\\
-1 &amp; 2 &amp; 4
\end{array}\right)\end{split}\]</div>
<p>and the following global assembled matrix from four elements:</p>
<div class="math">
\[\begin{split}A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 &amp; 2 &amp; - 1 &amp; 0
  &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
  2 &amp; 16 &amp; 2
  &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\- 1 &amp; 2 &amp;
  8 &amp; 2 &amp; - 1 &amp; 0 &amp; 0 &amp; 0 &amp;
  0\\0 &amp; 0 &amp; 2 &amp; 16 &amp; 2 &amp; 0 &amp; 0
  &amp; 0 &amp; 0\\0 &amp; 0 &amp; - 1 &amp; 2 &amp; 8
  &amp; 2 &amp; - 1 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 0 &amp;
  2 &amp; 16 &amp; 2 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 0
  &amp; 0 &amp; - 1 &amp; 2 &amp; 8 &amp;
  2 &amp; - 1\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp;
  2 &amp; 16 &amp; 2\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
  &amp; 0 &amp; - 1 &amp; 2 &amp; 4
\end{array}
\right)\end{split}\]</div>
<p>In general, for <span class="math">\(i\)</span> odd we have the nonzeroes</p>
<div class="math">
\[A_{i,i-2} = -1,\quad A_{i-1,i}=2,\quad A_{i,i} = 8,\quad A_{i+1,i}=2,
\quad A_{i+2,i}=-1,\]</div>
<p>multiplied by <span class="math">\(h/30\)</span>, and for <span class="math">\(i\)</span> even we have the nonzeros</p>
<div class="math">
\[A_{i-1,i}=2,\quad A_{i,i} = 16,\quad A_{i+1,i}=2,\]</div>
<p>multiplied by <span class="math">\(h/30\)</span>. The rows with odd numbers correspond to
nodes at the element boundaries and get contributions from two
neighboring elements in the assembly process,
while the even numbered rows correspond to
internal nodes in the elements where the only one element contributes
to the values in the global matrix.</p>
</div>
<div class="section" id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h2>
<p>With the aid of the <tt class="docutils literal"><span class="pre">approximate</span></tt> function in the <tt class="docutils literal"><span class="pre">fe_approx1D</span></tt>
module we can easily investigate the quality of various finite element
approximations to some given functions. Figure <a class="reference internal" href="#fem-approx-fe-x9-sin"><em>Comparison of the finite element approximations: 4 P1 elements with 5 nodes (upper left), 2 P2 elements with 5 nodes (upper right), 8 P1 elements with 9 nodes (lower left), and 4 P2 elements with 9 nodes (lower right)</em></a>
shows how linear and quadratic elements approximates the polynomial
<span class="math">\(f(x)=x(1-x)^8\)</span> on <span class="math">\(\Omega =[0,1]\)</span>, using equal-sized elements.
The results arise from the program</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">fe_approx1D</span> <span class="kn">import</span> <span class="n">approximate</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>

<span class="n">approximate</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_e</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">approximate</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_e</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">approximate</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_e</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">approximate</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_e</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>The quadratic functions are seen to be better than the linear ones for the same
value of <span class="math">\(N\)</span>, as we increase <span class="math">\(N\)</span>. This observation has some generality:
higher degree is not necessarily better on a coarse mesh, but it is as
we refined the mesh.</p>
<div class="figure" id="fem-approx-fe-x9-sin">
<img alt="_images/fe_p1_p2_x9_248e.png" src="_images/fe_p1_p2_x9_248e.png" style="width: 800px;" />
<p class="caption"><em>Comparison of the finite element approximations: 4 P1 elements with 5 nodes (upper left), 2 P2 elements with 5 nodes (upper right), 8 P1 elements with 9 nodes (lower left), and 4 P2 elements with 9 nodes (lower right)</em></p>
</div>
</div>
<div class="section" id="sparse-matrix-storage-and-solution">
<h2>Sparse matrix storage and solution<a class="headerlink" href="#sparse-matrix-storage-and-solution" title="Permalink to this headline">¶</a></h2>
<p>Some of the examples in the preceding section took several minutes to
compute, even on small meshes consisting of up to eight elements.
The main explanation for slow computations is unsuccessful
symbolic integration: <tt class="docutils literal"><span class="pre">sympy</span></tt> may use a lot of energy on
integrals like <span class="math">\(\int f(x(X))\tilde\varphi_r(X)h/2 dx\)</span> before
giving up, and the program resorts to numerical integration.
Codes that can deal with a large number of basis functions and
accept flexible choices of <span class="math">\(f(x)\)</span> should compute all integrals
numerically and replace the matrix objects from <tt class="docutils literal"><span class="pre">sympy</span></tt> by
the far more efficient array objects from <tt class="docutils literal"><span class="pre">numpy</span></tt>.</p>
<p>A matrix whose majority of entries are zeros, are known as a <em>sparse</em>
matrix. We know beforehand that matrices from finite element
approximations are sparse.  The sparsity should be utilized in
software as it dramatically decreases the storage demands and the
CPU-time needed to compute the solution of the linear system. This
optimization is not critical in 1D problems where modern computers can
afford computing with all the zeros in the complete square matrix, but
in 2D and especially in 3D, sparse matrices are fundamental for
feasible finite element computations.</p>
<p>For one-dimensional finite element approximation problems, using a
numbering of nodes and elements from left to right over the domain,
the assembled coefficient matrix has only a few diagonals different
from zero. More precisely, <span class="math">\(2d+1\)</span> diagonals are different from
zero. With a different numbering of global nodes, say a random
ordering, the diagonal structure is lost, but the number of
nonzero elements is unaltered. Figures <a class="reference internal" href="#fem-approx-fe-sparsity-p1"><em>Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P1 elements</em></a>
and <a class="reference internal" href="#fem-approx-fe-sparsity-p3"><em>Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P3 elements</em></a> exemplifies sparsity patterns.</p>
<div class="figure" id="fem-approx-fe-sparsity-p1">
<img alt="_images/sparsity_pattern_1D_30.png" src="_images/sparsity_pattern_1D_30.png" style="width: 800px;" />
<p class="caption"><em>Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P1 elements</em></p>
</div>
<div class="figure" id="fem-approx-fe-sparsity-p3">
<img alt="_images/sparsity_pattern_1DP3_30.png" src="_images/sparsity_pattern_1DP3_30.png" style="width: 800px;" />
<p class="caption"><em>Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P3 elements</em></p>
</div>
<p>The <tt class="docutils literal"><span class="pre">scipy.sparse</span></tt> library supports creation of sparse matrices
and linear system solution.</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">scipy.sparse.diags</span></tt> for matrix defined via diagonals</li>
<li><tt class="docutils literal"><span class="pre">scipy.sparse.lil_matrix</span></tt> for creation via setting elements</li>
<li><tt class="docutils literal"><span class="pre">scipy.sparse.dok_matrix</span></tt> for creation via setting elements</li>
</ul>
</div></blockquote>
<p>Examples to come....</p>
</div>
</div>
<div class="section" id="a-generalized-element-concept">
<h1>A generalized element concept<a class="headerlink" href="#a-generalized-element-concept" title="Permalink to this headline">¶</a></h1>
<p>So far, finite element computing has employed the <tt class="docutils literal"><span class="pre">nodes</span></tt> and
<tt class="docutils literal"><span class="pre">element</span></tt> lists together with the definition of the basis functions
in the reference element. Suppose we want to introduce a piecewise
constant approximation with one basis function <span class="math">\(\tilde\varphi_0(x)=1\)</span> in
the reference element. Although we could associate the function value
with a node in the middle of the elements, there are no nodes at the
ends, and the previous code snippets will not work because we
cannot find the element boundaries from the <tt class="docutils literal"><span class="pre">nodes</span></tt> list.</p>
<div class="section" id="cells-vertices-and-degrees-of-freedom">
<h2>Cells, vertices, and degrees of freedom<a class="headerlink" href="#cells-vertices-and-degrees-of-freedom" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-22"></span><span class="target" id="index-23"></span><span class="target" id="index-24"></span><p id="index-25">We now introduce <em>cells</em> as the subdomains <span class="math">\(\Omega^{(e)}\)</span> previously
referred as elements. The cell boundaries are denoted as <em>vertices</em>.
The reason for this name is that cells are recognized by their vertices
in 2D and 3D. Then we define a set of <em>degrees of freedom</em>, which are
the quantities we aim to compute. The most common type of degree
of freedom is the value of the unknown function <span class="math">\(u\)</span> at some point.
For example, we can introduce nodes as before and say the degrees of
freedom are the values of <span class="math">\(u\)</span> at the nodes. The basis functions are
constructed so that they equal unity for one particular degree of
freedom and zero for the rest. This property ensures that when
we evaluate <span class="math">\(u=\sum_j c_j\varphi_j\)</span> for degree of freedom number <span class="math">\(i\)</span>,
we get <span class="math">\(u=c_i\)</span>. Integrals are performed over cells, usually by
mapping the cell of interest to a <em>reference cell</em>.</p>
<p>With the concepts of cells, vertices, and degrees of freedom we increase
the decoupling the geometry (cell, vertices) from the space of
basis functions. We can associate different sets of basis functions
with a cell. In 1D, all cells are intervals, while in 2D we can have
cells that are triangles with straight sides, or any polygon, or in fact
any two-dimensional geometry. Triangles and quadrilaterals are most
common, though. The popular cell types in 3D are tetrahedra and hexahedra.</p>
</div>
<div class="section" id="extended-finite-element-concept">
<h2>Extended finite element concept<a class="headerlink" href="#extended-finite-element-concept" title="Permalink to this headline">¶</a></h2>
<p id="index-26">The concept of a <em>finite element</em> is now</p>
<blockquote>
<div><ul class="simple">
<li>a <em>reference cell</em> in a local reference coordinate system;</li>
<li>a set of <em>basis functions</em> <span class="math">\(\tilde\varphi_i\)</span> defined on the cell;</li>
<li>a set of <em>degrees of freedom</em> that uniquely determine
the basis functions such that <span class="math">\(\tilde\varphi_i=1\)</span> for degree of freedom
number <span class="math">\(i\)</span> and <span class="math">\(\tilde\varphi_i=0\)</span> for all other degrees of freedom;</li>
<li>a mapping between local and global degree of freedom numbers;</li>
<li>a <em>mapping</em> of the reference cell onto to cell in the physical
domain.</li>
</ul>
</div></blockquote>
<p>There must be a geometric description of a cell. This is trivial in 1D
since the cell is an interval and is described by the interval limits,
here called vertices. If the cell is <span class="math">\(\Omega^{(e)}=[x_L,x_R]\)</span>,
vertex 0 is <span class="math">\(x_L\)</span> and vertex 1 is <span class="math">\(x_R\)</span>. The reference cell in 1D
is <span class="math">\([-1,1]\)</span> in the reference coordinate system <span class="math">\(X\)</span>.</p>
<p>Our previous P1, P2, etc., elements are defined by introducing <span class="math">\(d+1\)</span>
equally spaced nodes in the reference cell and saying that the degrees
of freedom are the <span class="math">\(d+1\)</span> function values at these nodes.  The basis
functions must be 1 at one node and 0 at the others, and the Lagrange
polynomials have exactly this property.  The nodes can be numbered
from left to right with associated degrees of freedom that are
numbered in the same way.  The degree of freedom mapping becomes what
was previously represented by the <tt class="docutils literal"><span class="pre">elements</span></tt> lists.  The cell mapping
is the same affine mapping <a href="#equation-fem:approx:fe:affine:mapping">(22)</a> as
before.</p>
</div>
<div class="section" id="id7">
<h2>Implementation<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-27"></span><span class="target" id="index-28"></span><p id="index-29">Implementationwise,</p>
<blockquote>
<div><ul class="simple">
<li>we replace <tt class="docutils literal"><span class="pre">nodes</span></tt> by <tt class="docutils literal"><span class="pre">vertices</span></tt>;</li>
<li>we introduce <tt class="docutils literal"><span class="pre">cells</span></tt> such that <tt class="docutils literal"><span class="pre">cell[e][r]</span></tt> gives the mapping
from local vertex <tt class="docutils literal"><span class="pre">r</span></tt> in cell <tt class="docutils literal"><span class="pre">e</span></tt> to the global vertex number
in <tt class="docutils literal"><span class="pre">vertices</span></tt>;</li>
<li>we replace <tt class="docutils literal"><span class="pre">elements</span></tt> by <tt class="docutils literal"><span class="pre">dof_map</span></tt> (the contents are the same).</li>
</ul>
</div></blockquote>
<p>Consider the example from the section <a class="reference internal" href="#fem-approx-fe-def-elements-nodes"><em>Elements and nodes</em></a>
where <span class="math">\(\Omega =[0,1]\)</span> is divided into two cells,
<span class="math">\(\Omega^{(0)}=[0,0.4]\)</span> and <span class="math">\(\Omega^{(1)}=[0.4,1]\)</span>.
The vertices are <span class="math">\([0,0.4,1]\)</span>. Local vertex 0 and 1 are
<span class="math">\(0\)</span> and <span class="math">\(0.4\)</span> in cell 0 and <span class="math">\(0.4\)</span> and <span class="math">\(1\)</span> in cell 1.
A P2 element means that the degrees of freedom are
the value of <span class="math">\(u\)</span> at three equally spaced points (nodes) in each
cell. The data structures become</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">cells</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="n">dof_map</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>If we would approximate <span class="math">\(f\)</span> by piecewise constants, we simply
introduce one point or node in an element, preferably <span class="math">\(X=0\)</span>,
and choose <span class="math">\(\tilde\varphi_0(X)=1\)</span>. Only the <tt class="docutils literal"><span class="pre">dof_map</span></tt> is altered:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dof_map</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
<p>We use the <tt class="docutils literal"><span class="pre">cells</span></tt> and <tt class="docutils literal"><span class="pre">vertices</span></tt> lists to retrieve information
on the geometry of a cell, while <tt class="docutils literal"><span class="pre">dof_map</span></tt> is used in the
assembly of element matrices and vectors.
For example, the <tt class="docutils literal"><span class="pre">Omega_e</span></tt> variable (representing the cell interval)
in previous code snippets must now be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Omega_e</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">cells</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The assembly is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">[</span><span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">],</span> <span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">s</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">A_e</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
<span class="n">b</span><span class="p">[</span><span class="n">dof_map</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">r</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">b_e</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
</pre></div>
</div>
<p>We will hereafter work with <tt class="docutils literal"><span class="pre">cells</span></tt>, <tt class="docutils literal"><span class="pre">vertices</span></tt>, and <tt class="docutils literal"><span class="pre">dof_map</span></tt>.</p>
</div>
<div class="section" id="cubic-hermite-polynomials">
<h2>Cubic Hermite polynomials<a class="headerlink" href="#cubic-hermite-polynomials" title="Permalink to this headline">¶</a></h2>
<p>The finite elements considered so far represent <span class="math">\(u\)</span> as piecewise
polynomials with discontinuous derivatives at the cell boundaries.
Sometimes it is desired to have continuous derivatives. A primary
examples is the solution of differential equations with fourth-order
derivatives where standard finite element formulations lead to
a need for basis functions with continuous first-order derivatives.
The most common type of such basis functions in 1D is the
cubic Hermite polynomials.</p>
<p>There are ready-made formulas for the cubic Hermite polynomials, but
it is instructive to apply the principles for constructing basis
functions in detail.
Given a reference cell <span class="math">\([-1,1]\)</span>, we seek cubic polynomials
with the values of the function its first-order derivative at
<span class="math">\(X=-1\)</span> and <span class="math">\(X=1\)</span> as the four degrees of freedom. Let us number
the degrees of freedom as</p>
<blockquote>
<div><ul class="simple">
<li>0: value of function at <span class="math">\(X=-1\)</span></li>
<li>1: value of first derivative at <span class="math">\(X=-1\)</span></li>
<li>2: value of function at <span class="math">\(X=1\)</span></li>
<li>3: value of first derivative at <span class="math">\(X=1\)</span></li>
</ul>
</div></blockquote>
<p>The four basis functions can be written in a general form</p>
<div class="math">
\[\tilde\varphi_i (X) = \sum_{j=0}^3 C_{ij}X^j,\]</div>
<p>with four coefficients <span class="math">\(C_{ij}\)</span>, <span class="math">\(j=0,1,2,3\)</span>, to be determined for
each <span class="math">\(i\)</span>. The constraints
that basis function number <span class="math">\(i\)</span> must be 1 for degree of
freedom number <span class="math">\(i\)</span> and zero for the other three degrees of freedom
gives four equations to determine <span class="math">\(C_{ij}\)</span> for each <span class="math">\(i\)</span>. In mathematical
detail,</p>
<div class="math">
\[\begin{split}\tilde\varphi_0 (-1) &amp;= 1,\quad \tilde\varphi_0 (1)=\tilde\varphi_0'(-1)=\tilde\varphi_i' (1)=0,\\
\tilde\varphi_1' (-1) &amp;= 1,\quad \tilde\varphi_1 (-1)=\tilde\varphi_1(1)=\tilde\varphi_1' (1)=0,\\
\tilde\varphi_2 (1) &amp;= 1,\quad \tilde\varphi_2 (-1)=\tilde\varphi_2'(-1)=\tilde\varphi_2' (1)=0,\\
\tilde\varphi_3' (1) &amp;= 1,\quad \tilde\varphi_3 (-1)=\tilde\varphi_3'(-1)=\tilde\varphi_3 (1)=0
\thinspace .\end{split}\]</div>
<p>The 4 <span class="math">\(4\times 4\)</span> linear equations can be solved, yielding these formulas
for the cubic basis functions:</p>
<div class="math">
\[\begin{split}       \tilde\varphi_0(X) &amp;= \\
       \tilde\varphi_1(X) &amp;= \\
       \tilde\varphi_2(X) &amp;= \\
       \tilde\varphi_3(X) &amp;= \\\end{split}\]\[* Global numbering of the dofs\]\[* ``dof_map``\]\[* 4x4 element matrix\]</div>
</div>
</div>
<div class="section" id="numerical-integration">
<h1>Numerical integration<a class="headerlink" href="#numerical-integration" title="Permalink to this headline">¶</a></h1>
<p>Finite element codes usually apply numerical approximations to
integrals. Since the integrands in the coefficient matrix often
are (lower-order) polynomials, integration rules that can
integrate polynomials exactly are popular.</p>
<p>The numerical integration rules can be expressed in a common form,</p>
<div class="math">
\[\int_{-1}^{1} g(X)dX \approx \sum_{j=0}^M w_j\bar X_j,\]</div>
<p>where <span class="math">\(\bar X_j\)</span> are <em>integration points</em> and <span class="math">\(w_j\)</span> are
<em>integration weights</em>, <span class="math">\(j=0,\ldots,M\)</span>.
Different rules correspond to different choices of points and weights.</p>
<div class="section" id="basic-integration-rules-with-uniform-point-distribution">
<h2>Basic integration rules with uniform point distribution<a class="headerlink" href="#basic-integration-rules-with-uniform-point-distribution" title="Permalink to this headline">¶</a></h2>
<p>Three well-known rules are the <em>Midpoint</em> rule,</p>
<div class="math">
\[\int_{-1}^{1} g(X)dX \approx 2g(0),\quad \bar X_0=0,\ w_0=2,\]</div>
<p>the <em>Trapezoidal rule</em>,</p>
<div class="math">
\[\int_{-1}^{1} g(X)dX \approx g(-1) + g(1),\quad \bar X_0=-1,\ \bar X_1=1,\ w_0=w_1=1,\]</div>
<p>and <em>Simpson&#8217;s rule</em>,</p>
<div class="math">
\[\int_{-1}^{1} g(X)dX \approx \frac{1}{3}\left(g(-1) + 4g(0)
+ g(1)\right),\]</div>
<p>where</p>
<div class="math">
\[\bar X_0=-1,\ \bar X_1=0,\ \bar X_2=1,\ w_0=w_2=\frac{1}{3},\ w_1=\frac{4}{3}\thinspace .\]</div>
<p>For higher accuracy one can divide the reference cell into a set of
subintervals and use the rules above on each subinterval. This approach
results in <em>composite</em> rules, well-known from basic introductions
to numerical integration of <span class="math">\(\int_{a}^{b}f(x)dx\)</span>.</p>
</div>
<div class="section" id="gauss-legendre-rules-with-optimized-points">
<h2>Gauss-Legendre rules with optimized points<a class="headerlink" href="#gauss-legendre-rules-with-optimized-points" title="Permalink to this headline">¶</a></h2>
<p>All these rules apply equally spaced points. More accurate rules, for a given
<span class="math">\(M\)</span>, arise if the location of the points are optimized for polynomial
integrands.
The <em>Gauss-Legendre rules</em> (also known as
<em>Gauss-Legendre quadrature</em>) constitute one such class of
integration methods. Two widely applied Gauss-Legendre rules in this family
have the choice</p>
<div class="math">
\[\begin{split}M=1&amp;:\quad \bar X_0=-\frac{1}{\sqrt{3}},\
\bar X_1=\frac{1}{\sqrt{3}},\ w_0=w_1=1\\
M=2&amp;:\quad \bar X_0=-\sqrt{\frac{3}{{5}}},\ \bar X_0=0,\
\bar X_2= \sqrt{\frac{3}{{5}}},\ w_0=w_2=\frac{5}{9},\ w_1=\frac{8}{9}\thinspace .\end{split}\]</div>
<p>These rules integrate 3rd and 5th degree polynomials exactly.
In general, an <span class="math">\(M\)</span>-point Gauss-Legendre rule integrates a polynomial
of degree <span class="math">\(2M+1\)</span> exactly.</p>
</div>
<div class="section" id="summary-of-a-finite-element">
<h2>Summary of a finite element<a class="headerlink" href="#summary-of-a-finite-element" title="Permalink to this headline">¶</a></h2>
<p>The concept of a finite element contains four key components, which we
now formulate in a more abstract sense suitable for later use.
A finite element is defined by</p>
<p>Property 3 ensures that a finite element function <span class="math">\(u\)</span> can be written as</p>
<div class="math">
\[u(x) = \sum_{j=0}^Nc_j\tilde\varphi_j(x),\]</div>
<p>where <span class="math">\(c_j\)</span> is the value of degree of freedom number <span class="math">\(j\)</span> of <span class="math">\(u\)</span>.
The most common example of a degree of freedom is the function value
at a point. With a mapping between local degrees of freedom and
global degrees of freedom, one can relate the expansion of <span class="math">\(u\)</span> on an
element to its expansion in the global physical domain.</p>
<p>The elements seen so far are all one-dimensional with Lagrange polynomials
as basis functions, based on uniformly distributed nodes in the
reference element <span class="math">\([-1,1]\)</span>.
The degrees
of freedom are then the function values at <span class="math">\(d+1\)</span> nodes.
A linear mapping is used to map <span class="math">\([-1,1]\)</span> onto the particular element
<span class="math">\(\Omega^{(e)}\)</span> in the physical coordinate system.
.. All these ingredients can be changed: we may have non-uniformly distributed</p>
<p>We shall see that the above characteristics of an element generalize to
higher dimensions and to much more complicated elements.
The concept of degrees of freedom is important: we may choose other
parameters than the function values at points as the interpretation of the
coefficients
<span class="math">\(c_j\)</span>. Here is one example. Suppose we want an approximation to
<span class="math">\(f\)</span> based on piecewise <em>constant</em> functions. Then we can construct
an element with one local basis function, <span class="math">\(\tilde\varphi_0(X)=1\)</span>.
The associated degree of freedom can be taken as the function value at
a node in the middle of the element. In this case the element will have
only one node and no nodes on the boundary. Alternatively, we can omit
the concept of nodes and say the degree of freedom is the <em>mean value</em>
of a function rather than a point value. That is, <span class="math">\(c_0\)</span> is the mean
value of <span class="math">\(u\)</span> over the element. To get a mean value (degree of freedom
value) of 1 for <span class="math">\(\tilde\varphi_0(x)\)</span> over <span class="math">\([-1,1]\)</span>, we must have
<span class="math">\(\tilde\varphi_0(X)=1/2\)</span>. A global basis functions is associated with one
element, typically <span class="math">\(\varphi_i\)</span> equals <span class="math">\(1/h_i\)</span>, where <span class="math">\(h_i\)</span> is the
length of element <span class="math">\(i\)</span>. Then <span class="math">\(\int_{\Omega^{(i)}}\varphi_idx=1\)</span>.
The mapping from local degrees of freedom to global degrees of freedom
is simple: local degree of freedom 0 in element <span class="math">\(e\)</span> maps to
global degree of freedom <span class="math">\(e\)</span>.</p>
</div>
<div class="section" id="accuracy-of-piecewise-polynomial-approximations">
<h2>Accuracy of piecewise polynomial approximations<a class="headerlink" href="#accuracy-of-piecewise-polynomial-approximations" title="Permalink to this headline">¶</a></h2>
<p>Experimental. State theory. Make exercise</p>
</div>
<div class="section" id="approximation-of-vector-valued-functions">
<h2>Approximation of vector-valued functions<a class="headerlink" href="#approximation-of-vector-valued-functions" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="approximation-of-functions-in-2d">
<h1>Approximation of functions in 2D<a class="headerlink" href="#approximation-of-functions-in-2d" title="Permalink to this headline">¶</a></h1>
<div class="figure" id="fem-approx-fe-2d-fig-rectp1">
<img alt="_images/mesh2D_rect_P1.png" src="_images/mesh2D_rect_P1.png" style="width: 800px;" />
<p class="caption"><em>Examples on 2D P1 elements</em></p>
</div>
<div class="figure" id="fem-approx-fe-2d-fig-circp1">
<img alt="_images/mesh2D_quarter_circle.png" src="_images/mesh2D_quarter_circle.png" style="width: 400px;" />
<p class="caption"><em>Examples on 2D P1 elements in a deformed geometry</em></p>
</div>
<div class="figure" id="fem-approx-fe-2d-fig-rectq1">
<img alt="_images/mesh2D_rect_Q1.png" src="_images/mesh2D_rect_Q1.png" style="width: 400px;" />
<p class="caption"><em>Examples on 2D Q1 elements</em></p>
</div>
<div class="figure" id="fem-approx-fe-2d-fig-p12d">
<img alt="_images/P1_2d.png" src="_images/P1_2d.png" style="width: 100px;" />
<p class="caption"><em>2D P1 element</em></p>
</div>
<div class="figure" id="id8">
<img alt="_images/P2_2d.png" src="_images/P2_2d.png" style="width: 100px;" />
<p class="caption"><em>2D P2 element</em></p>
</div>
<div class="figure" id="fem-approx-fe-2d-fig-p162d">
<img alt="_images/P1-6_2d.png" src="_images/P1-6_2d.png" style="width: 400px;" />
<p class="caption"><em>2D P1, P2, P3, P4, P5, and P6 elements</em></p>
</div>
<div class="figure" id="fem-approx-fe-2d-fig-p1-123d">
<img alt="_images/P1-1d2d3d.png" src="_images/P1-1d2d3d.png" style="width: 400px;" />
<p class="caption"><em>P1 elements in 1D, 2D, and 3D</em></p>
</div>
<div class="figure" id="fem-approx-fe-2d-fig-p2-123d">
<img alt="_images/P2-1d2d3d.png" src="_images/P2-1d2d3d.png" style="width: 400px;" />
<p class="caption"><em>P2 elements in 1D, 2D, and 3D</em></p>
</div>
</div>
<div class="section" id="exercises">
<h1>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-1-linear-algebra-refresher-i">
<span id="fem-approx-exer-linalg1"></span><h2>Exercise 1: Linear algebra refresher I<a class="headerlink" href="#exercise-1-linear-algebra-refresher-i" title="Permalink to this headline">¶</a></h2>
<p>Look up the topic of <em>vector space</em> in your favorite linear algebra
book or search for the term at Wikipedia.
Prove that vectors in the plane (<span class="math">\(a,b\)</span>) form a vector space
by showing that all the axioms of a vector space
are satisfied. Similarly,
prove that all linear functions of the form <span class="math">\(ax+b\)</span> constitute a vector space.
Filename: <tt class="docutils literal"><span class="pre">vec111_approx1.py</span></tt>.</p>
</div>
<div class="section" id="exercise-2-linear-algebra-refresher-ii">
<span id="fem-approx-exer-linalg2"></span><h2>Exercise 2: Linear algebra refresher II<a class="headerlink" href="#exercise-2-linear-algebra-refresher-ii" title="Permalink to this headline">¶</a></h2>
<p>As an extension of <a class="reference internal" href="#fem-approx-exer-linalg1"><em>Exercise 1: Linear algebra refresher I</em></a>, check out
the topic of <em>inner vector spaces</em>. Show that both examples
of spaces in <a class="reference internal" href="#fem-approx-exer-linalg1"><em>Exercise 1: Linear algebra refresher I</em></a> can be equipped with an
inner product and show that the choice of inner product satisfied the
general requirements of an inner product in a vector space.
Filename: <tt class="docutils literal"><span class="pre">vec111_approx1.py</span></tt>.</p>
</div>
<div class="section" id="exercise-3-approximate-a-three-dimensional-vector-in-a-plane">
<span id="fem-approx-exer-vec-3dby2d"></span><h2>Exercise 3: Approximate a three-dimensional vector in a plane<a class="headerlink" href="#exercise-3-approximate-a-three-dimensional-vector-in-a-plane" title="Permalink to this headline">¶</a></h2>
<p>Given <span class="math">\(\pmb{f} = (1,1,1)\)</span> in <span class="math">\(\mathbb{R}^3\)</span>, find the best approximation vector
<span class="math">\(\pmb{u}\)</span> in the plane spanned by the unit vectors <span class="math">\((1,0)\)</span> and <span class="math">\((0,1)\)</span>.
Repeat the calculations using the vectors <span class="math">\((2,1)\)</span> and <span class="math">\((1,2)\)</span>.
Filename: <tt class="docutils literal"><span class="pre">vec111_approx.py</span></tt>.</p>
</div>
<div class="section" id="exercise-4-approximate-the-exponential-function-by-power-functions">
<span id="fem-approx-exer-exp-powers"></span><h2>Exercise 4: Approximate the exponential function by power functions<a class="headerlink" href="#exercise-4-approximate-the-exponential-function-by-power-functions" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math">\(V\)</span> be a function space with basis functions
<span class="math">\(x^k\)</span>, <span class="math">\(k=0,1,\ldots,N\)</span>.
Find the best approximation to <span class="math">\(f(x)=e^x\)</span> among all functions in <span class="math">\(V\)</span>,
using <span class="math">\(N=8\)</span> and the <tt class="docutils literal"><span class="pre">least_squares</span></tt> function from
the section <a class="reference internal" href="#fem-approx-global"><em>Approximation of functions</em></a>.
Filename: <tt class="docutils literal"><span class="pre">exp_by_powers.py</span></tt>.</p>
</div>
<div class="section" id="exercise-5-approximate-a-high-frequency-sine-function-by-lower-frequency-sines">
<span id="fem-approx-exer-sine-hibylow"></span><h2>Exercise 5: Approximate a high frequency sine function by lower frequency sines<a class="headerlink" href="#exercise-5-approximate-a-high-frequency-sine-function-by-lower-frequency-sines" title="Permalink to this headline">¶</a></h2>
<p>Find the best approximation of <span class="math">\(f(x) = \sin (20x)\)</span> on <span class="math">\([0, 2\pi]\)</span> in
the space <span class="math">\(V\)</span> with basis</p>
<div class="math">
\[\{ \sin x,\ \sin 2x, \sin 3x \},\]</div>
<p>using the <tt class="docutils literal"><span class="pre">least_squares_orth</span></tt> function from
the section <a class="reference internal" href="#fem-approx-global-fourier"><em>Fourier series</em></a>. Plot <span class="math">\(f(x)\)</span> and its approximation.
Filename: <tt class="docutils literal"><span class="pre">hilow_sine_approx.py</span></tt>.</p>
</div>
<div class="section" id="exercise-6-fourier-series-as-a-least-squares-approximation">
<span id="fem-approx-exer-fourier"></span><h2>Exercise 6: Fourier series as a least squares approximation<a class="headerlink" href="#exercise-6-fourier-series-as-a-least-squares-approximation" title="Permalink to this headline">¶</a></h2>
<p>Given a function <span class="math">\(f(x)\)</span> on an interval <span class="math">\([0,L]\)</span>, find the formula
for the coefficients of the Fourier series of <span class="math">\(f\)</span>:</p>
<div class="math">
\[f(x) = a_0 + \sum_{j=1}^\infty a_j\cos \left(j\frac{\pi x}{L}\right)
+ \sum_{j=1}^\infty b_j\sin \left(j\frac{\pi x}{L}\right)\thinspace .\]</div>
<p>Let an infinite-dimensional vector space <span class="math">\(V\)</span> have the basis functions
<span class="math">\(\cos j\frac{\pi x}{L}\)</span> for <span class="math">\(j=0,1,\dots,\infty\)</span> and :math:<a href="#id9"><span class="problematic" id="id10">`</span></a>sin jfrac{pi</p>
<blockquote>
<div>x}{L}` for <span class="math">\(j=1,\dots,\infty\)</span>.  Show that the least squares</div></blockquote>
<p>approximation method from the section <a class="reference internal" href="#fem-approx-global"><em>Approximation of functions</em></a> leads to a
linear system whose solution coincides with the standard formulas for
the coefficients in a Fourier series of <span class="math">\(f(x)\)</span> (see also
the section <a class="reference internal" href="#fem-approx-global-fourier"><em>Fourier series</em></a>). You may choose</p>
<div class="math">
\[\varphi_{2i} = \cos\left( i\frac{\pi}{L}x\right),\quad
\varphi_{2i+1} = \sin\left( i\frac{\pi}{L}x\right),\]</div>
<p>for <span class="math">\(i=0,1,\ldots,N\rightarrow\infty\)</span>.</p>
<p>Choose a specific function
<span class="math">\(f(x)\)</span>, calculate the coefficients in the Fourier expansion by
solving the linear system, arising from the least squares
method, by hand. Plot
some truncated versions of the series together with <span class="math">\(f(x)\)</span> to show how
the series expansion converges.
Filename: <tt class="docutils literal"><span class="pre">tanh_approx.py</span></tt>.</p>
</div>
<div class="section" id="exercise-7-approximate-a-function-by-lagrange-polynomials">
<span id="fem-approx-exer-tanh"></span><h2>Exercise 7: Approximate a <span class="math">\(\tanh\)</span> function by Lagrange polynomials<a class="headerlink" href="#exercise-7-approximate-a-function-by-lagrange-polynomials" title="Permalink to this headline">¶</a></h2>
<p>Use interpolation (or collocation) with uniformly distributed
points and Chebychev nodes to approximate</p>
<div class="math">
\[f(x) = \tanh(s(x-\frac{1}{2}))\]</div>
<p>by Lagrange polynomials for <span class="math">\(s=10,100\)</span> and <span class="math">\(N=3,6,9,11\)</span>.
Filename: <tt class="docutils literal"><span class="pre">tanh_approx.py</span></tt>.</p>
</div>
<div class="section" id="exercise-8-improve-an-approximation-by-sines">
<span id="fem-approx-exer-parabolabysine"></span><h2>Exercise 8: Improve an approximation by sines<a class="headerlink" href="#exercise-8-improve-an-approximation-by-sines" title="Permalink to this headline">¶</a></h2>
<p>Consider the approximations of a parabola by a sum of sine functions
in the section <a class="reference internal" href="#fem-approx-global-fourier"><em>Fourier series</em></a>. Since we always have that <span class="math">\(u(0)=0\)</span>
the approximation at <span class="math">\(x=0\)</span> always have an error <span class="math">\(f(0)\)</span> at this point.
Try a remedy:</p>
<div class="math">
\[u(x) = f(0) + \sum_{j=0}^N\sin((i+1)\pi x)\thinspace .\]</div>
<p>Now <span class="math">\(u(0)=f(0)\)</span>.
Plot the approximations for <span class="math">\(N=4\)</span> and <span class="math">\(N=12\)</span> together with <span class="math">\(f\)</span>.
Is the approximation better than the ones in Figure <a class="reference internal" href="#fem-approx-global-fig-parabola-sine1"><em>Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions</em></a>?
Filename: <tt class="docutils literal"><span class="pre">parabola_by_sines.py</span></tt>.</p>
</div>
<div class="section" id="exercise-9-define-finite-element-meshes">
<span id="fem-approx-fe-exer-defmesh"></span><h2>Exercise 9: Define finite element meshes<a class="headerlink" href="#exercise-9-define-finite-element-meshes" title="Permalink to this headline">¶</a></h2>
<p>Consider a domain <span class="math">\(\Omega =[0,2]\)</span> divided into the three elements
<span class="math">\([0,1]\)</span>, <span class="math">\([1,1.2]\)</span>, and <span class="math">\([1.2,2]\)</span>.
Suggest three different element numberings and global node numberings
for this mesh and set up the corresponding <tt class="docutils literal"><span class="pre">nodes</span></tt> and <tt class="docutils literal"><span class="pre">elements</span></tt>
lists in each case.
Then subdivide the element <span class="math">\([1.2,2]\)</span> into two new equal-sized elements
and explain how you can extend the <tt class="docutils literal"><span class="pre">nodes</span></tt> and <tt class="docutils literal"><span class="pre">elements</span></tt>
data structures to incorporate the new elements and nodes.
<tt class="docutils literal"><span class="pre">fe_numberings.py</span></tt>.</p>
</div>
<div class="section" id="exercise-10-approximate-a-step-function-by-finite-elements">
<span id="fem-approx-fe-exer-heaviside"></span><h2>Exercise 10: Approximate a step function by finite elements<a class="headerlink" href="#exercise-10-approximate-a-step-function-by-finite-elements" title="Permalink to this headline">¶</a></h2>
<p>Approximate the step function</p>
<div class="math">
\[\begin{split}f(x) = \left\lbrace\begin{array}{ll}
1 &amp; x &lt; {1/2},\\
2 &amp; x \geq {1/2}
\end{array}\right.\end{split}\]</div>
<p>This <span class="math">\(f\)</span> can also be expressed in terms of the Heaviside function <span class="math">\(H(x)\)</span>:
<span class="math">\(f(x) = H(x-{1/2})\)</span>. Use 2, 4, and 8 P1 and P2 elements, and compare
approximations visually.
Filename: <tt class="docutils literal"><span class="pre">`Heaviside_approx_P1P2.py</span></tt>.`.</p>
<p><em>Hint.</em> <span class="math">\(f\)</span> can be defined by <tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">sm.Heaviside(x</span> <span class="pre">-</span>&nbsp; <span class="pre">sm.Rational(1,2))</span></tt>,
making the <tt class="docutils literal"><span class="pre">approximate</span></tt> function in the
<tt class="docutils literal"><span class="pre">fe_approx1D.py</span></tt> module an obvious candidate to solve the
problem. However, <tt class="docutils literal"><span class="pre">sympy</span></tt> does not handle symbolic integration
with the integrands and the <tt class="docutils literal"><span class="pre">approximate</span></tt> function faces a problem
when converting <tt class="docutils literal"><span class="pre">f</span></tt> to a Python function (for plotting) since
<tt class="docutils literal"><span class="pre">Heaviside</span></tt> is not an available function in <tt class="docutils literal"><span class="pre">numpy</span></tt>. Make
special-purpose code for this case instead, or perform all
caluclations by hand.</p>
</div>
<div class="section" id="exercise-11-perform-symbolic-finite-element-computations">
<span id="fem-approx-fe-exer-asinwt-symbolic"></span><h2>Exercise 11: Perform symbolic finite element computations<a class="headerlink" href="#exercise-11-perform-symbolic-finite-element-computations" title="Permalink to this headline">¶</a></h2>
<p>Find the coefficient matrix and right-hand side
for approximating <span class="math">\(f(x) = A\sin (\omega x)\)</span> on
<span class="math">\(\Omega=[0, 2\pi/\omega]\)</span> by P1 elements of size <span class="math">\(h\)</span>.
Perform the calculations in software.
Solve the system in case of two elements.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">Asinwt_approx_P1.py</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Basic finite element methods</a></li>
<li><a class="reference internal" href="#approximation-of-vectors">Approximation of vectors</a><ul>
<li><a class="reference internal" href="#approximation-of-planar-vectors">Approximation of planar vectors</a><ul>
<li><a class="reference internal" href="#the-least-squares-method">The least squares method</a></li>
<li><a class="reference internal" href="#the-galerkin-method">The Galerkin method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#approximation-of-general-vectors">Approximation of general vectors</a><ul>
<li><a class="reference internal" href="#id1">The least squares method</a></li>
<li><a class="reference internal" href="#id2">The Galerkin method</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#approximation-of-functions">Approximation of functions</a><ul>
<li><a class="reference internal" href="#fem-ls">The least squares method</a></li>
<li><a class="reference internal" href="#id4">The Galerkin method</a></li>
<li><a class="reference internal" href="#example-linear-approximation">Example: linear approximation</a></li>
<li><a class="reference internal" href="#implementation-of-the-least-squares-method">Implementation of the least squares method</a></li>
<li><a class="reference internal" href="#perfect-approximation">Perfect approximation</a></li>
<li><a class="reference internal" href="#ill-conditioning">Ill-conditioning</a></li>
<li><a class="reference internal" href="#fourier-series">Fourier series</a></li>
<li><a class="reference internal" href="#orthogonal-basis-functions">Orthogonal basis functions</a></li>
<li><a class="reference internal" href="#the-collocation-or-interpolation-method">The collocation or interpolation method</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lagrange-polynomials">Lagrange polynomials</a><ul>
<li><a class="reference internal" href="#successful-example">Successful example</a></li>
<li><a class="reference internal" href="#less-successful-example">Less successful example</a></li>
<li><a class="reference internal" href="#remedy-for-strong-oscillations">Remedy for strong oscillations</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#finite-element-basis-functions">Finite element basis functions</a><ul>
<li><a class="reference internal" href="#elements-and-nodes">Elements and nodes</a><ul>
<li><a class="reference internal" href="#id5">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-basis-functions">The basis functions</a><ul>
<li><a class="reference internal" href="#construction-principles">Construction principles</a></li>
<li><a class="reference internal" href="#properties-of">Properties of <span class="math">\(\varphi_i\)</span></a></li>
<li><a class="reference internal" href="#example-on-quadratic">Example on quadratic <span class="math">\(\varphi_i\)</span></a></li>
<li><a class="reference internal" href="#example-on-linear">Example on linear <span class="math">\(\varphi_i\)</span></a></li>
<li><a class="reference internal" href="#example-on-cubic">Example on cubic <span class="math">\(\varphi_i\)</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#calculating-the-linear-system">Calculating the linear system</a></li>
<li><a class="reference internal" href="#assembly-of-elementwise-computations">Assembly of elementwise computations</a></li>
<li><a class="reference internal" href="#mapping-to-a-reference-element">Mapping to a reference element</a></li>
<li><a class="reference internal" href="#integration-over-a-reference-element">Integration over a reference element</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a><ul>
<li><a class="reference internal" href="#integration">Integration</a></li>
<li><a class="reference internal" href="#linear-system-assembly-and-solution">Linear system assembly and solution</a></li>
<li><a class="reference internal" href="#example-on-computing-approximations">Example on computing approximations</a></li>
<li><a class="reference internal" href="#the-structure-of-the-coefficient-matrix">The structure of the coefficient matrix</a></li>
<li><a class="reference internal" href="#applications">Applications</a></li>
<li><a class="reference internal" href="#sparse-matrix-storage-and-solution">Sparse matrix storage and solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-generalized-element-concept">A generalized element concept</a><ul>
<li><a class="reference internal" href="#cells-vertices-and-degrees-of-freedom">Cells, vertices, and degrees of freedom</a></li>
<li><a class="reference internal" href="#extended-finite-element-concept">Extended finite element concept</a></li>
<li><a class="reference internal" href="#id7">Implementation</a></li>
<li><a class="reference internal" href="#cubic-hermite-polynomials">Cubic Hermite polynomials</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numerical-integration">Numerical integration</a><ul>
<li><a class="reference internal" href="#basic-integration-rules-with-uniform-point-distribution">Basic integration rules with uniform point distribution</a></li>
<li><a class="reference internal" href="#gauss-legendre-rules-with-optimized-points">Gauss-Legendre rules with optimized points</a></li>
<li><a class="reference internal" href="#summary-of-a-finite-element">Summary of a finite element</a></li>
<li><a class="reference internal" href="#accuracy-of-piecewise-polynomial-approximations">Accuracy of piecewise polynomial approximations</a></li>
<li><a class="reference internal" href="#approximation-of-vector-valued-functions">Approximation of vector-valued functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#approximation-of-functions-in-2d">Approximation of functions in 2D</a></li>
<li><a class="reference internal" href="#exercises">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-1-linear-algebra-refresher-i">Exercise 1: Linear algebra refresher I</a></li>
<li><a class="reference internal" href="#exercise-2-linear-algebra-refresher-ii">Exercise 2: Linear algebra refresher II</a></li>
<li><a class="reference internal" href="#exercise-3-approximate-a-three-dimensional-vector-in-a-plane">Exercise 3: Approximate a three-dimensional vector in a plane</a></li>
<li><a class="reference internal" href="#exercise-4-approximate-the-exponential-function-by-power-functions">Exercise 4: Approximate the exponential function by power functions</a></li>
<li><a class="reference internal" href="#exercise-5-approximate-a-high-frequency-sine-function-by-lower-frequency-sines">Exercise 5: Approximate a high frequency sine function by lower frequency sines</a></li>
<li><a class="reference internal" href="#exercise-6-fourier-series-as-a-least-squares-approximation">Exercise 6: Fourier series as a least squares approximation</a></li>
<li><a class="reference internal" href="#exercise-7-approximate-a-function-by-lagrange-polynomials">Exercise 7: Approximate a <span class="math">\(\tanh\)</span> function by Lagrange polynomials</a></li>
<li><a class="reference internal" href="#exercise-8-improve-an-approximation-by-sines">Exercise 8: Improve an approximation by sines</a></li>
<li><a class="reference internal" href="#exercise-9-define-finite-element-meshes">Exercise 9: Define finite element meshes</a></li>
<li><a class="reference internal" href="#exercise-10-approximate-a-step-function-by-finite-elements">Exercise 10: Approximate a step function by finite elements</a></li>
<li><a class="reference internal" href="#exercise-11-perform-symbolic-finite-element-computations">Exercise 11: Perform symbolic finite element computations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Basic finite element methods</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Basic finite element methods"
             >previous</a> |</li>
        <li><a href="index.html">Basic finite element methods 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, H. P. Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>