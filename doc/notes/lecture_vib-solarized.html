<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(http://code.google.com/p/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: http://code.google.com/p/doconce/" />
<meta name="description" content="INF5620 Lecture: Vibration ODEs">
<meta name="keywords" content="period (of oscillations),frequency (of oscillations),Hz (unit),stability criterion">



<style type="text/css">
    body {
      margin:5;
      padding:0;
      border:0;	/* Remove the border around the viewport in old versions of IE */
      width:100%;
      background: #fdf6e3;
      min-width:600px;	/* Minimum width of layout - remove if not required */
      font-family: Verdana, Helvetica, Arial, sans-serif;
      font-size: 1.0em;
      line-height: 1.3em;
      color: #657b83;
    }
    a { color: #657b83; text-decoration:none; }
    a:hover { color: #b58900; background: #eee8d5; text-decoration:none; }
    h1, h2, h3 { margin:.8em 0 .2em 0; padding:0; line-height: 125%; }
    h2 { font-variant: small-caps; }
    pre {
      background: #fdf6e3;
      -webkit-box-shadow: inset 0 0 2px #000000;
      -moz-box-shadow: inset 0 0 2px #000000;
      box-shadow: inset 0 0 2px #000000;
      color: #586e75;
      margin-left: 0px;
      font-family: 'Droid Sans Mono', monospace;
      padding: 2px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      -moz-background-clip: padding;
      -webkit-background-clip: padding-box;
      background-clip: padding-box;
    }
    tt { font-family: "Courier New", Courier; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p { text-indent: 0px; }
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' A simple vibration problem ', 1, None, '___sec0'),
              (' A centered finite difference scheme ',
               2,
               'vib:model1:fdm',
               'vib:model1:fdm'),
              (' The discretization ', 3, None, '___sec2'),
              (' Computing the first step ', 3, None, '___sec3'),
              (' The computational algorithm ', 3, None, '___sec4'),
              (' Operator notation ', 3, None, '___sec5'),
              (" Computing $u'$ ", 3, None, '___sec6'),
              (' Implementation ', 2, None, '___sec7'),
              (' Verification ', 2, None, '___sec8'),
              (' Manual calculation ', 3, None, '___sec9'),
              (' Testing very simple solutions ', 3, None, '___sec10'),
              (' Checking convergence rates ', 3, None, '___sec11'),
              (' Long-time simulations ',
               2,
               'vib:model1:longseries',
               'vib:model1:longseries'),
              (' Using a moving plot window ', 3, None, '___sec13'),
              (' Analysis of the numerical scheme ',
               2,
               'vib:model1:analysis',
               'vib:model1:analysis'),
              (' Deriving an exact numerical solution ', 3, None, '___sec15'),
              (' Exact discrete solution ', 3, None, '___sec16'),
              (' Stability ', 3, None, '___sec17'),
              (' Alternative schemes based on 1st-order equations ',
               1,
               'vib:model2',
               'vib:model2'),
              (' Standard methods for 1st-order ODE systems ',
               2,
               None,
               '___sec19'),
              (' The Forward Euler scheme ', 3, None, '___sec20'),
              (' The Backward Euler scheme ', 3, None, '___sec21'),
              (' The Crank-Nicolson scheme ', 3, None, '___sec22'),
              (' Comparison of schemes ', 3, None, '___sec23'),
              (' The Euler-Cromer method ',
               2,
               'vib:model2:EulerCromer',
               'vib:model2:EulerCromer'),
              (' Forward-backward discretization ', 3, None, '___sec25'),
              (' Equivalence with the scheme for the second-order ODE ',
               3,
               None,
               '___sec26')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{u_{\small\mbox{e}}}
\newcommand{\Aex}{A_{\small\mbox{e}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{{\cal O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{{\cal I}_x}
\newcommand{\Iy}{{\cal I}_y}
\newcommand{\Iz}{{\cal I}_z}
\newcommand{\It}{{\cal I}_t}
\newcommand{\setb}[1]{{#1}^0}    % set begin
\newcommand{\sete}[1]{{#1}^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{{#1}^-}
\newcommand{\setr}[1]{{#1}^+}
\newcommand{\seti}[1]{{#1}^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- ------------------- main content ---------------------- -->


<title>INF5620 Lecture: Vibration ODEs</title>

<center><h1>INF5620 Lecture: Vibration ODEs</h1></center>  <!-- document title -->

<p>
<center><h4>September 13, 2012</h4></center> <!-- date -->

<h2>Table of contents</h2>

<p>
<a href="#___sec0"> A simple vibration problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model1:fdm"> A centered finite difference scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec2"> The discretization </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec3"> Computing the first step </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec4"> The computational algorithm </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec5"> Operator notation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec6"> Computing \( u' \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> Verification </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec9"> Manual calculation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec10"> Testing very simple solutions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec11"> Checking convergence rates </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model1:longseries"> Long-time simulations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec13"> Using a moving plot window </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model1:analysis"> Analysis of the numerical scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec15"> Deriving an exact numerical solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec16"> Exact discrete solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec17"> Stability </a><br>
<a href="#vib:model2"> Alternative schemes based on 1st-order equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Standard methods for 1st-order ODE systems </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec20"> The Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec21"> The Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec22"> The Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec23"> Comparison of schemes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model2:EulerCromer"> The Euler-Cromer method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec25"> Forward-backward discretization </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec26"> Equivalence with the scheme for the second-order ODE </a><br>

<h2>A simple vibration problem  <a name="___sec0"></a></h2>

<p>
$$
\begin{equation}
u''t) + \omega^2u = 0,\quad u(0)=I,\ u'(0)=0,\ t\in (0,T]
\thinspace .
\label{vib:model1}
\end{equation}
$$


<p>
Exact solution:

<p>
$$
\begin{equation}
u(t) = I\cos (\omega t)
\thinspace .
\label{vib:model1:uex}
\end{equation}
$$

\( u(t) \) oscillates with constant amplitude \( I \) and
(angular) frequency \( \omega \).
Period: \( P=2\pi/\omega \).

<h3>A centered finite difference scheme <a name="vib:model1:fdm"></a></h3>

<p>
Strategy: follow the <a href="http://hplgit.github.com/INF5620/doc/notes/decay-sphinx/main_decay.html#the-forward-euler-scheme">four steps</a> (cf. the discretization of the exponential decay model).

<h4>The discretization  <a name="___sec2"></a></h4>

<p>
Step 1: Introduce a time mesh, here uniform on \( [0,T] \).

<p>
Step 2: Let the ODE be satisfied at each mesh point:

<p>
$$
\begin{equation}
u''(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
\thinspace .
\label{vib:model1:step2}
\end{equation}
$$


<p>
Step 3: Approximate derivative(s) by finite
difference approximation(s).

<p>
Very common (standard!) formula:

<p>
$$
\begin{equation}
u''(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
\label{vib:model1:step3}
\end{equation}
$$


<p>
Inserting \eqref{vib:model1:step3} in \eqref{vib:model1:step2}
yields

<p>
$$
\begin{equation}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
\thinspace .
\label{vib:model1:step4a}
\end{equation}
$$


<p>
Step 4: Formulate the computational algorithm.

<p>
Assume \( u^{n-1} \) and \( u^n \) are known, solve for unknown \( u^{n+1} \):

<p>
$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \omega^2 u^n
\thinspace .
\label{vib:model1:step4}
\end{equation}
$$


<p>
Nick names for this scheme: Stormer's method or <a href="http://en.wikipedia.org/wiki/Velocity_Verlet">Verlet integration</a>.

<h4>Computing the first step  <a name="___sec3"></a></h4>

<p>

<ul>
  <p><li> The formula breaks down for \( u^1 \) because \( u^{-1} \) is unknown and
    outside the mesh!</li>
  <p><li> And: we have not used the initial condition \( u'(0)=0 \).</li>
</ul>

Discretize \( u'(0) \) by a centered difference
$$
\begin{equation}
\frac{u^1-u^{-1}}{2\Delta t} = 0\quad\Rightarrow\quad u^{-1} = u^1
\thinspace .
\end{equation}
$$


<p>
Inserted in \eqref{vib:model1:step4} for \( n=0 \) gives

<p>
$$
\begin{equation}
u^1 = u^0 - \half \Delta t^2 \omega^2 u^0
\thinspace .
\label{vib:model1:step4b}
\end{equation}
$$

<h4>The computational algorithm  <a name="___sec4"></a></h4>

<p>

<ol>
 <p><li> \( u^0=I \)</li>
 <p><li> compute \( u^1 \) from \eqref{vib:model1:step4b}</li>
 <p><li> for \( n=1,2,\ldots,N_t-1 \):</li>

<ol>
   <p><li> compute \( u^{n+1} \) from \eqref{vib:model1:step4}</li>
</ol>

</ol>

More precisly expressed in Python:

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">t = linspace(0, T, Nt+1)  # mesh points in time
dt = t[1] - t[0]          # constant time step.
u = zeros(Nt+1)           # solution

u[0] = I
u[1] = u[0] - 0.5*dt**2*w**2*u[0]
for n in range(1, Nt):
    u[n+1] = 2*u[n] - u[n-1] - dt**2*w**2*u[n]
</pre></div>
</td></tr></table><p>
Note: I (consistently) use <code>w</code> for \( \omega \) in code.
(Later: <code>a</code> for \( \alpha \) - increases readability.)

<h4>Operator notation  <a name="___sec5"></a></h4>

<p>
With \( [D_tD_t u]^n \) as the finite difference approximation to
\( u''(t_n) \) we can write

<p>
$$
\begin{equation}
[D_tD_t u  + \omega^2 u = 0]^n
\thinspace .
\label{vib:model1:step4:op}
\end{equation}
$$


<p>
\( [D_tD_t u]^n \) means applying a central difference with step \( \Delta t/2 \) twice:

<p>
$$ [D_t(D_t u)]^n = \frac{[D_t u]^{n+1/2} - [D_t u]^{n-1/2}}{\Delta t}$$

which is written out as
$$
\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
$$


<p>
Initial conditions:
$$
\begin{equation}
[u = I]^0,\quad [D_{2t} u = 0]^0,
\end{equation}
$$

where \( [D_{2t} u]^n \) is defined as
$$
\begin{equation}
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
\thinspace .
\end{equation}
$$

<h4>Computing \( u' \)  <a name="___sec6"></a></h4>

<p>
After \( u \) (displacement/position)
is computed, we can use a difference to find \( u' \) (velocity):
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
\thinspace .
\end{equation}
$$

<h3>Implementation  <a name="___sec7"></a></h3>

<p>
Core algorithm:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, w, dt, T):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span style="color: #CD5555">    by a central finite difference method with time step dt.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    u = zeros(Nt+<span style="color: #B452CD">1</span>)
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)

    u[<span style="color: #B452CD">0</span>] = I
    u[<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>] - <span style="color: #B452CD">0.5</span>*dt**<span style="color: #B452CD">2</span>*w**<span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        u[n+<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">2</span>*u[n] - u[n-<span style="color: #B452CD">1</span>] - dt**<span style="color: #B452CD">2</span>*w**<span style="color: #B452CD">2</span>*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
</td></tr></table><p>
Plotting:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t, I, w):
    <span style="color: #8B008B; font-weight: bold">return</span> I*cos(w*t)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">visualize</span>(u, t, I, w):
    plot(t, u, <span style="color: #CD5555">&#39;r--o&#39;</span>)
    t_fine = linspace(<span style="color: #B452CD">0</span>, t[-<span style="color: #B452CD">1</span>], <span style="color: #B452CD">1001</span>)  <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = exact_solution(t_fine, I, w)
    hold(<span style="color: #CD5555">&#39;on&#39;</span>)
    plot(t_fine, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
    legend([<span style="color: #CD5555">&#39;numerical&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>], loc=<span style="color: #CD5555">&#39;upper left&#39;</span>)
    xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
    title(<span style="color: #CD5555">&#39;dt=%g&#39;</span> % dt)
    umin = <span style="color: #B452CD">1.2</span>*u.min();  umax = -umin
    axis([t[<span style="color: #B452CD">0</span>], t[-<span style="color: #B452CD">1</span>], umin, umax])
    savefig(<span style="color: #CD5555">&#39;vib1.png&#39;</span>)
    savefig(<span style="color: #CD5555">&#39;vib1.pdf&#39;</span>)
    savefig(<span style="color: #CD5555">&#39;vib1.eps&#39;</span>)
</pre></div>
</td></tr></table><p>
Main program:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">I = <span style="color: #B452CD">1</span>
w = <span style="color: #B452CD">2</span>*pi
dt = <span style="color: #B452CD">0.05</span>
num_periods = <span style="color: #B452CD">5</span>
P = <span style="color: #B452CD">2</span>*pi/w    <span style="color: #228B22">#  one period</span>
T = P*num_periods
u, t = solver(I, w, dt, T)
visualize(u, t, I, w, dt)
</pre></div>
</td></tr></table><p>
User interface (command line):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
parser = argparse.ArgumentParser()
parser.add_argument(<span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>)
parser.add_argument(<span style="color: #CD5555">&#39;--w&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">2</span>*pi)
parser.add_argument(<span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">0.05</span>)
parser.add_argument(<span style="color: #CD5555">&#39;--num_periods&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">int</span>, default=<span style="color: #B452CD">5</span>)
a = parser.parse_args()
I, w, dt, num_periods = a.I, a.w, a.dt, a.num_periods
</pre></div>
</td></tr></table><h3>Verification  <a name="___sec8"></a></h3>

<h4>Manual calculation  <a name="___sec9"></a></h4>

<p>

<ul>
 <p><li> Calculate \( u^1 \) and \( u^2 \) by hand.</li>
 <p><li> Compare with program.</li>
</ul>

<h4>Testing very simple solutions  <a name="___sec10"></a></h4>

<p>

<ul>
 <p><li> \( u=\hbox{const} \) or \( u=ct + d \) do not apply here (without a force
   term in the equation: \( u'' + \omega^2u = f \)).</li>
</ul>

<h4>Checking convergence rates  <a name="___sec11"></a></h4>

<p>
The function below

<p>

<ul>
 <p><li> performs \( m \) simulations with halved time steps: \( 2^{-k}\Delta t \), \( k=0,\ldots,m-1 \),</li>
 <p><li> computes the \( L_2 \) norm of the error,
   \( E = \sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-\uex(t_n))^2} \) in each case,</li>
 <p><li> estimates the rates \( r_i \) from two consecutive
   experiments \( (\Delta t_{i-1}, E_{i-1}) \) and \( (\Delta t_{i}, E_{i}) \),
   assuming \( E_i=C\Delta t_i^{r_i} \) and \( E_{i-1}=C\Delta t_{i-1}^{r_i} \):</li>
</ul>

Implementational details:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">convergence_rates</span>(m, num_periods=<span style="color: #B452CD">8</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Return m-1 empirical estimates of the convergence rate</span>
<span style="color: #CD5555">    based on m simulations, where the time step is halved</span>
<span style="color: #CD5555">    for each simulation.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    w = <span style="color: #B452CD">0.35</span>; I = <span style="color: #B452CD">0.3</span>
    dt = <span style="color: #B452CD">2</span>*pi/w/<span style="color: #B452CD">30</span>  <span style="color: #228B22"># 30 time step per period 2*pi/w</span>
    T = <span style="color: #B452CD">2</span>*pi/w*num_periods
    dt_values = []
    E_values = []
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(m):
        u, t = solver(I, w, dt, T)
        u_e = exact_solution(t, I, w)
        E = sqrt(dt*<span style="color: #658b00">sum</span>((u_e-u)**<span style="color: #B452CD">2</span>))
        dt_values.append(dt)
        E_values.append(E)
        dt = dt/<span style="color: #B452CD">2</span>

    r = [log(E_values[i-<span style="color: #B452CD">1</span>]/E_values[i])/
         log(dt_values[i-<span style="color: #B452CD">1</span>]/dt_values[i])
         <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, m, <span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> r
</pre></div>
</td></tr></table><p>
Result: <code>r</code> contains values equal to 2.00 - as expected!

<p>
Use final <code>r[-1]</code> in a unit test:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_convergence_rates</span>():
    r = convergence_rates(m=<span style="color: #B452CD">5</span>, num_periods=<span style="color: #B452CD">8</span>)
    <span style="color: #228B22"># Accept rate to 1 decimal place</span>
    nt.assert_almost_equal(r[-<span style="color: #B452CD">1</span>], <span style="color: #B452CD">2.0</span>, places=<span style="color: #B452CD">1</span>)
</pre></div>
</td></tr></table><p>
Complete code in <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/vib/vib_undamped.py"><tt>vib_undamped.py</tt></a>.

<h3>Long-time simulations <a name="vib:model1:longseries"></a></h3>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Effect of halving the time step. <a name="vib:model1:2dt"></a> </p></center>
<p><img src="fig-vib/vib_phase_err1.png" align="bottom" width=800,></p>
</center>

<p>
Observations:

<p>

<ul>
 <p><li> The numerical solution seems to have right amplitude.</li>
 <p><li> There is a phase error which is reduced by reducing the time step.</li>
 <p><li> The total phase error seems to grow with time.</li>
</ul>

<h4>Using a moving plot window  <a name="___sec13"></a></h4>

<p>

<ul>
 <p><li> In long time simulations we need a plot window that follows
   the "front" of the solution.</li>
 <p><li> Method 1: <code>scitools.MovingPlotWindow</code>.</li>
 <p><li> Method 2: <code>scitools.avplotter</code> (ASCII vertical plotter).</li>
</ul>

Example:
<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
</td></tr></table><p>
<a href="mov-vib/vib_undamped_dt0.05/index.html">Movie of the moving plot window</a>.

<h3>Analysis of the numerical scheme <a name="vib:model1:analysis"></a></h3>

<h4>Deriving an exact numerical solution  <a name="___sec15"></a></h4>

<p>

<ul>
  <p><li> Linear, homogeneous, difference equation for \( u^n \).</li>
  <p><li> Has solutions \( u^n \sim A^n \), where \( A \) is unknown number.</li>
  <p><li> Here: \( \uex(t) =I\cos(\omega t) \sim I\exp{(i\omega t)} = I(\exp{(i\omega\Delta t)}^n \)</li>
  <p><li> Trick for simplifying the algebra: \( A=\exp{(i\tilde\omega\Delta t)} \)</li>
  <p><li> \( \tilde\omega \): unknown <em>numerical frequency</em> (easier to calculate than \( A \))</li>
  <p><li> \( \omega - \tilde\omega \) is the <em>phase error</em></li>
  <p><li> Use the real part as the physical relevant part of a complex expression</li>
</ul>

Calculate:
$$
A^n = \exp{(\tilde\omega \Delta t\, n)}=\exp{(\tilde\omega t)} =
\cos (\tilde\omega t) + i\sin(\tilde \omega t)
\thinspace .
$$


<p>
$$
\begin{align*}
[D_tD_t u]^n &= \frac{\exp{(i\tilde\omega(t+\Delta t))} - 2\exp{(i\tilde\omega t)} + \exp{(i\tilde\omega(t-\Delta t))}}{\Delta t^2}\\
&= \exp{(i\tilde\omega t)}\frac{1}{\Delta t^2}\left(\exp{(i\tilde\omega(\Delta t))} + \exp{(i\tilde\omega(-\Delta t))} - 2\right)\\
&= \exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\
&= \exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\
&= -\exp{(i\tilde\omega t)}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
\end{align*}
$$


<p>
The scheme \eqref{vib:model1:step4}
with \( u^n=\exp{(i\omega\tilde\Delta t\, n)} \) inserted gives

<p>
$$
\begin{equation}
-\exp{(i\tilde\omega t)}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
+ \omega^2 \exp{(i\tilde\omega t)} = 0,
\end{equation}
$$

which after dividing by \( \exp{(i\tilde\omega t)} \) results in
$$
\begin{equation}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
\thinspace .
\end{equation}
$$

Solve for \( \tilde\omega \):
$$ \sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
\thinspace .
$$

Now: take square root, apply \( \sin^{-1} \), and multiply by \( 2/\Delta t \):
$$
\begin{equation}
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\thinspace .
\label{vib:model1:tildeomega}
\end{equation}
$$


<p>

<ul>
 <p><li> Phase error because \( \tilde\omega \neq \omega \).</li>
 <p><li> But how good is the approximation \( \tilde\omega \) to \( \omega \)?</li>
</ul>

Taylor series expansion
for small \( \Delta t \) gives a formula that is easier to understand:

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; dt, w = symbols(&#39;dt w&#39;)
&gt;&gt;&gt; w_tilde = asin(w*dt/2).series(dt, 0, 4)*2/dt
&gt;&gt;&gt; print w_tilde
(dt*w + dt**3*w**3/24 + O(dt**4))/dt
</pre></div>
</td></tr></table><p>
In mathematical notation:
$$
\begin{equation}
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right) + {\cal O}(\Delta t^3)
\thinspace .
\label{vib:model1:tildeomega:series}
\end{equation}
$$


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Exact discrete frequency and its second-order series expansion. <a name="vib:model1:tildeomega:plot"></a> </p></center>
<p><img src="fig-vib/discrete_freq.png" align="bottom" width=600></p>
</center>

<h4>Exact discrete solution  <a name="___sec16"></a></h4>

<p>
$$
\begin{equation}
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\thinspace .
\label{vib:model1:un:exact}
\end{equation}
$$


<p>
Ideal for verification and analysis!

<h4>Stability  <a name="___sec17"></a></h4>

<p>

<ul>
 <p><li> We have observed constant amplitude (desired!), but phase error.</li>
 <p><li> Constant amplitude: \( \sin \) is real-valued \( \Rightarrow\quad \tilde\omega \)
   is real-valued.</li>
 <p><li> What if \( \tilde\omega \) is complex?</li>
 <p><li> \( \sin^{-1}(x) \) is complex if \( |x|>1 \).</li>
 <p><li> Complex \( \tilde\omega = \tilde\omega_r + i\tilde\omega_i \).</li>
 <p><li> Since \( \sin^{-1}(x) \) has a <em>negative</em> imaginary part for
   \( x>1 \), it means that
   \( \exp{(i\omega\tilde t)}=\exp{(-\tilde\omega_i t)}\exp{(i\tilde\omega_r t)} \)
   will lead to exponential growth in time because \( \tilde\omega_i <0 \) and hence
   \( -\tilde\omega_i t > 0 \).</li>
</ul>

Cannot tolerate growth and must therefore demand a <em>stability criterion</em>
$$
\begin{equation}
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
\Delta t \leq \frac{2}{\omega}
\thinspace .
\end{equation}
$$


<p>
Figure <a href="#vib:model1:dt:unstable">3</a>
displays what happens when \( \Delta t =\pi^{-1} + 9.01\cdot
10^{-5} \) (\( \pi^{-1} \) is the stability limit).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Growing, unstable solution because of a time step slightly beyond the stability limit. <a name="vib:model1:dt:unstable"></a> </p></center>
<p><img src="fig-vib/vib_unstable.png" align="bottom" width=400></p>
</center>

<p>
From the analysis we can draw three important conclusions:

<p>

<ol>
<p><li> The key parameter in the formulas is \( p=\omega\Delta t \).
   The period of oscillations is \( P=2\pi/\omega \), and the
   number of time steps per period is \( N_P=P/\Delta t \).
   Therefore, \( p=\omega\Delta t = 2\pi N_P \), showing that the
   critical parameter is the number of time steps per period.
   The smallest possible \( N_P \) is 2, showing that \( p\in (0,\pi] \).</li>
<p><li> Provided \( p\leq 2 \), the amplitude if the numerical solution is
   constant.</li>
<p><li> The numerical solution exhibits a relative phase error
   \( \tilde\omega/\omega \approx 1 + \frac{1}{24}p^2 \).
   This error leads to wrongly displaced peaks of the numerical
   solution, and the error in peak location grows linearly with time.</li>
</ol>

<h2>Alternative schemes based on 1st-order equations <a name="vib:model2"></a></h2>

<p>
Standard technique for \( u'' + ... \) (and any higher-order ODE):
<em>rewrite as first-order system</em>.

<p>
Here:

<p>
$$
\begin{align}
u' &= v,
\label{vib:model2:ueq}\\
v' &= -\omega^2 u
\label{vib:model2:veq}
\thinspace .
\end{align}
$$


<p>
Initial conditions: \( u(0)=I \) and \( v(0)=0 \).

<h3>Standard methods for 1st-order ODE systems  <a name="___sec19"></a></h3>

<h4>The Forward Euler scheme  <a name="___sec20"></a></h4>

<p>
$$ [D_t^+ u = v]^n,$$


<p>
$$ [D_t^+ v = -\omega^2 u]^n,$$

or written out,

<p>
$$
\begin{align}
u^{n+1} &= u^n + \Delta t v^n,\\
v^{n+1} &= v^n -\Delta t \omega^2 u^n
\thinspace .
\end{align}
$$

<h4>The Backward Euler scheme  <a name="___sec21"></a></h4>

<p>
$$ [D_t^- u = v]^{n+1},$$


<p>
$$ [D_t^- v = -\omega u]^{n+1} \thinspace . $$

Written out:
$$
\begin{align}
u^{n+1} - \Delta t v^{n+1} = u^{n},\\
v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}
\thinspace .
\end{align}
$$

This is a <em>coupled</em> \( 2\times 2 \) system for the new values!

<h4>The Crank-Nicolson scheme  <a name="___sec22"></a></h4>

<p>
$$
[D_t u = \overline{v}^t]^{n+\frac{1}{2}},$$


<p>
$$
[D_t v = -\omega \overline{u}^t]^{n+\frac{1}{2}}$$

Also a coupled system:

<p>
$$
\begin{align}
u^{n+1} - \frac{1}{2}\Delta t v^{n+1} &= u^{n} + \frac{1}{2}\Delta t v^{n},\\
v^{n+1} + \frac{1}{2}\Delta t \omega^2 u^{n+1} &= v^{n}
- \frac{1}{2}\Delta t \omega^2 u^{n}
\thinspace .
\end{align}
$$

<h4>Comparison of schemes  <a name="___sec23"></a></h4>

<p>
Can use
<a href="https://github.com/hplgit/odespy">Odespy</a> to compare many methods
for first-order schemes:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">odespy</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(u, t, w=<span style="color: #B452CD">1</span>):
    <span style="color: #228B22"># u is array of length 2 holding our [u, v]</span>
    u, v = u
    <span style="color: #8B008B; font-weight: bold">return</span> [v, -w**<span style="color: #B452CD">2</span>*u]

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">run_solvers_and_plot</span>(solvers, timesteps_per_period=<span style="color: #B452CD">20</span>,
                         num_periods=<span style="color: #B452CD">1</span>, I=<span style="color: #B452CD">1</span>, w=<span style="color: #B452CD">2</span>*np.pi):
    P = <span style="color: #B452CD">2</span>*np.pi/w  <span style="color: #228B22"># one period</span>
    dt = P/timesteps_per_period
    Nt = num_periods*timesteps_per_period
    T = Nt*dt
    t_mesh = np.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)

    legends = []
    <span style="color: #8B008B; font-weight: bold">for</span> solver <span style="color: #8B008B">in</span> solvers:
        solver.set(f_kwargs={<span style="color: #CD5555">&#39;w&#39;</span>: w})
        solver.set_initial_condition([I, <span style="color: #B452CD">0</span>])
        u, t = solver.solve(t_mesh)
</pre></div>
</td></tr></table><p>
Forward Euler, Backward Euler, and
Crank-Nicolson (<code>MidpointImplicit</code> in Odespy) are first out:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">solvers = [
    odespy.ForwardEuler(f),
    <span style="color: #228B22"># Implicit methods must use Newton solver to converge</span>
    odespy.BackwardEuler   (f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>),
    odespy.MidpointImplicit(f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>),
    ]
</pre></div>
</td></tr></table><p>
Two plot types:

<p>

<ul>
  <p><li> \( u(t) \)</li>
  <p><li> Parameterized curve \( (u(t), v(t)) \) in <em>phase space</em> (exact: \( (I\cos\omega t, -\omega I\sin\omega t) \) = ellipse)</li>
  <p><li> Note: The curve \( (u(t), v(t)) \) is closed and periodic (\( P=2\pi/\omega \))</li>
</ul>

<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Comparison of classical schemes in the phase plane. <a name="vib:model1:1st:odespy:theta:phaseplane"></a> </p></center>
<p><img src="fig-vib/vib_theta_1_pp.png" align="bottom" width=800,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Comparison of classical schemes. <a name="vib:model1:1st:odespy:theta"></a> </p></center>
<p><img src="fig-vib/vib_theta_1_u.png" align="bottom" width=800,></p>
</center>

<p>
Observations:

<p>

<ul>
  <p><li> Forward Euler has growing amplitude and outward \( (u,v) \) spiral - pumps
    energy into the system.</li>
  <p><li> Backward Euler is opposite: decreasing amplitude, inward sprial,
    extracts energy.</li>
  <p><li> <b>Forward and Backward Euler are useless for vibrations.</b></li>
  <p><li> Crank-Nicolson (MidpointImplicit) looks much better.</li>
</ul>

<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Comparison of Runge-Kutta schemes in the phase plane. <a name="vib:model1:1st:odespy:RK:phaseplane"></a> </p></center>
<p><img src="fig-vib/vib_RK_1_pp.png" align="bottom" width=800,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Comparison of Runge-Kutta schemes. <a name="vib:model1:1st:odespy:RK"></a> </p></center>
<p><img src="fig-vib/vib_RK_1_u.png" align="bottom" width=800,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Long-time behavior of Runge-Kutta schemes in the phase plane. <a name="vib:model1:1st:odespy:RK:long:phaseplane"></a> </p></center>
<p><img src="fig-vib/vib_RK_10_pp.png" align="bottom" width=800,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Long-time behavior of Runge-Kutta schemes. <a name="vib:model1:1st:odespy:RK:long"></a> </p></center>
<p><img src="fig-vib/vib_RK_10_u.png" align="bottom" width=800,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Long-time behavior of the Crank-Nicolson scheme in the phase plane. <a name="vib:model1:1st:odespy:CN:long:phaseplane"></a> </p></center>
<p><img src="fig-vib/vib_CN_10_pp.png" align="bottom" width=800,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  Long-time behavior of the Crank-Nicolson scheme. <a name="vib:model1:1st:odespy:CN:long"></a> </p></center>
<p><img src="fig-vib/vib_CN_10_u.png" align="bottom" width=800,></p>
</center>

<p>
Observations:

<p>

<ul>
  <p><li> 4th-order Runge-Kutta is very accurate, also for large \( \Delta t \).</li>
  <p><li> 2th-order Runge-Kutta has almost as big problems as Forward and Backward
    Euler.</li>
  <p><li> Crank-Nicolson is accurate, but the amplitude is not as accurate
    as Stormer/Verlet.</li>
</ul>

<h3>The Euler-Cromer method <a name="vib:model2:EulerCromer"></a></h3>

<h4>Forward-backward discretization  <a name="___sec25"></a></h4>

<p>

<ul>
  <p><li> Update \( u \) with Forward Euler</li>
  <p><li> Update \( v \) with Backward Euler, using latest \( u \)</li>
</ul>

$$ [D_t^+u = v]^n,$$


<p>
$$ [D_t^-v = -\omega u]^{n+1}
\thinspace .
$$


<p>
Written out:
$$
\begin{align}
u^{n+1} &= u^n + \Delta t v^n,
\label{vib:model2:EulerCromer:ueq1}\\
v^{n+1} &= v^n -\Delta t \omega^2u^{n+1}
\label{vib:model2:EulerCromer:veq1}
\thinspace .
\end{align}
$$


<p>
Names: Forward-backward scheme, <a href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">Semi-implicit Euler method</a>, symplectic
Euler, semi-explicit Euler, Newton-Stormer-Verlet, and Euler-Cromer.

<p>
Forward Euler and Backward Euler are both \( {\cal O}(\Delta t) \)
approximations. What about the overall scheme? Expect \( {\cal O}(\Delta t) \)...

<h4>Equivalence with the scheme for the second-order ODE  <a name="___sec26"></a></h4>

<p>
Eliminate \( v^n \):

<p>
From \eqref{vib:model2:EulerCromer:veq1}:
$$ v^n = v^{n-1} - \Delta t \omega^2u^{n},
$$

which can be inserted in \eqref{vib:model2:EulerCromer:ueq1} to yield
$$
\begin{equation}
u^{n+1} = u^n + \Delta t v^{n-1} - \Delta t^2 \omega^2u^{n} .
\label{vib:model2:EulerCromer:elim1}
\end{equation}
$$

Using \eqref{vib:model2:EulerCromer:ueq1},
$$ v^{n-1} = \frac{u^n - u^{n-1}}{\Delta t},
$$

and when this is inserted in \eqref{vib:model2:EulerCromer:elim1} we get
$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},
\end{equation}
$$

<b>which is nothing but the centered scheme</b> \eqref{vib:model1:step4}!
<b>The previous analysis of this scheme then also applies to the Euler-Cromer
method!</b>

<p>
The initial condition \( u'=0 \):

<p>
$$ u'=v=0\quad\Rightarrow\quad v^0=0,$$

and
\eqref{vib:model2:EulerCromer:ueq1} implies \( u^1=u^0 \), while
\eqref{vib:model2:EulerCromer:veq1} says \( v^1=-\omega^2 u^0 \).

<p>
This \( u^1=u^0 \) approximation
corresponds to a first-order Forward Euler discretization
of \( u'(0)=0 \): \( [D_t^+ u = 0]^0 \).

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

