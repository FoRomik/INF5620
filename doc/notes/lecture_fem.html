<?xml version="1.0" encoding="utf-8" ?>
<!--
Automatically generated HTML file from Doconce source
(http://code.google.com/p/doconce/)
-->

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: http://code.google.com/p/doconce/" />

<!--
Color definitions:  http://www.december.com/html/spec/color0.html
CSS examples:       http://www.w3schools.com/css/css_examples.asp
-->

<style type="text/css">
    body {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #000000;
    }
    h1 { font-size: 1.8em; color: #1e36ce; }
    h2 { font-size: 1.5em; color: #1e36ce; }
    h3 { color: #1e36ce; }
    a { color: #1e36ce; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    pre { background: #ededed; color: #000; padding: 15px;}
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}

</style>

<!-- Use MathJax to render mathematics -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">

</head>

<body>
    
<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{u_{\small\mbox{e}}}
\newcommand{\Aex}{A_{\small\mbox{e}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}

\newcommand{\xpoint}{\pmb{x}}
\newcommand{\normalvec}{\pmb{n}}

\newcommand{\x}{\pmb{x}}
\newcommand{\X}{\pmb{X}}
\renewcommand{\u}{\pmb{u}}
\renewcommand{\v}{\pmb{v}}
\newcommand{\w}{\pmb{w}}
\renewcommand{\u}{\pmb{u}}
\newcommand{\e}{\pmb{e}}
\newcommand{\f}{\pmb{f}}
\newcommand{\F}{\pmb{F}}
\newcommand{\stress}{\pmb{\sigma}}
\newcommand{\strain}{\pmb{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\pmb{I}}
\newcommand{\T}{\pmb{T}}

% Unit vectors
\newcommand{\ii}{\pmb{i}}
\newcommand{\jj}{\pmb{j}}
\newcommand{\kk}{\pmb{k}}
\newcommand{\ir}{\pmb{i}_r}
\newcommand{\ith}{\pmb{i}_{\theta}}
\newcommand{\iz}{\pmb{i}_z}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\phib}{\pmb{\varphi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\pmb{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$



<!-- ------------------- main content ------------------------>

<title>INF5620 Lecture: Basic finite element methods</title>

<center><h1>INF5620 Lecture: Basic finite element methods</h1></center>  <! -- document title -->

<center><h4>Nov 8, 2012</h4></center> <!-- date -->
<p>

<title>Basic finite element methods</title>

<center><h1>Basic finite element methods</h1></center>  <! -- document title -->

<p>

<h2>Why finite elements?  <a name="___sec0"></a></h2>
<p>

<ul>
 <p><li> Can with ease solve PDEs in domains with <em>complex geometry</em>
 <p><li> Can with ease provide higher-order approximations
 <p><li> Has (in simpler problems) a rigorus mathematical analysis framework
   (not much considered here - not powerful enough to uncover the
   serious limitations of the method in time-dependent problems
   and the necessary adjustments)
</ul>

<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Domain for flow around a dolphin. <a name="fem:motivation:fig:dolfin:mesh"></a> </p></center>
<p><img src="fig-fem/dolfin_mesh.png" align="bottom" width=400,></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  The flow. <a name="fem:motivation:fig:dolfin:flow"></a> </p></center>
<p><img src="fig-fem/dolfin_flow.gif" align="bottom" width=400,></p>
</center>

<p>

<p>

<p>

<h3>Basic ingredients  <a name="___sec1"></a></h3>
<p>

<ul>
 <p><li> Transform the PDE problem to a <em>variational form</em>
 <p><li> Define function approximation over <em>finite elements</em>
 <p><li> Use a machinery to derive <em>linear systems</em>
 <p><li> Solve linear systems
</ul>

<h3>Learning strategy  <a name="___sec2"></a></h3>
<p>

<ul>
 <p><li> Start with approximation of functions
 <p><li> Introduce finite element <em>approximations</em>
 <p><li> See how this is applied to PDEs
</ul>

Reason: the finite element method has many concepts and a jungle of details.
This strategy minimizes the mixing of ideas, concepts, and technical details.

<p>

<h2>Approximation set-up  <a name="___sec3"></a></h2>
<p>
General idea of approximation:

<p>
$$
\begin{equation}
 u(x) = \sum_{i=0}^N c_i\basphi_i(x),
\label{fem:u}
\end{equation}
$$
where

<p>

<ul>
 <p><li> \( \basphi_i(x) \) are prescribed functions
 <p><li> \( c_i \), \( i=0,\ldots,N \) are unknown coefficients to be determined
</ul>

How to determine \( c_i \):

<p>

<ul>
 <p><li> least squares method
 <p><li> projection or Galerkin method
 <p><li> interpolation (or collocation) method
</ul>

Our mathematical framework for doing this is phrased in a way such
that it becomes easy to understand and use the <a href="http://fenicsproject.org">FEniCS</a> software package for finite element computing.

<p>

<h3>Approximation of planar vectors <a name="fem:approx:vec:plane"></a></h3>
<p>

<h4>Problem  <a name="___sec5"></a></h4>
<p>
Given a two-dimensional vector \( \f = (3,5) \), find an approximation
to \( \f \) directed along a given line.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Approximation of a two-dimensional vector by a one-dimensional vector. <a name="fem:approx:vec:plane:fig"></a> </p></center>
<p><img src="fig-fem/vecapprox_plane.png" align="bottom" width=400></p>
</center>

<p>

<p>
In vector space terminology: given a vector in a two-dimensional vector
space, find an approximation in a one-dimensional vector space

<p>
$$
\begin{equation}
V = \mbox{span}\,\{ \phib_0\}\thinspace . \end{equation}
$$

<p>

<ul>
 <p><li> \( \phib_0 \) is a basis vector in the space \( V \)
 <p><li> Seek \( \u = c_0\phib_0\in V \)
 <p><li> Determine \( c_0 \) such that \( \u \) is the "best" approximation to \( \f \)
 <p><li> Visually, "best" is obvious
 <p><li> For PDEs, "best" is not so obvious
 <p><li> Define the error \( \e = \f - \u \)
 <p><li> Define the (Eucledian) scalar product of two vectors: \( (\u,\v) \)
 <p><li> Define the norm of \( \e \): \( ||\e|| = \sqrt{(\e, \e)} \)
</ul>

<h4>The least squares method  <a name="___sec6"></a></h4>
<p>

<ul>
 <p><li> Idea: find \( c_0 \) such that \( ||\e|| \) is minimized
 <p><li> Actually, we always minimize \( E=||\e||^2 \)
</ul>

$$
\begin{equation*}
\frac{\partial E}{\partial c_0} = 0
\thinspace . \end{equation*}
$$

<p>

<p>
Detailed mathematics:

<p>
$$
\begin{equation}
E(c_0) = (\e,\e) = (\f,\f) - 2c_0(\f,\phib_0) + c_0^2(\phib_0,\phib_0)
\end{equation}
$$

<p>
$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\phib_0) + 2c_0 (\phib_0,\phib_0) = 0
\thinspace .
\label{fem:vec:dEdc0:v1}
\end{equation}
$$

<p>
$$
\begin{equation}
c_0 = \frac{(\f,\phib_0)}{(\phib_0,\phib_0)},
\label{fem:vec:c0}
\end{equation}
$$

<p>
$$
\begin{equation}
c_0 = \frac{3a + 5b}{a^2 + b^2}\thinspace . \end{equation}
$$

<p>
For later, we note that setting \eqref{fem:vec:dEdc0:v1} to zero
can be alternatively written as

<p>
$$
\begin{equation}
(\e, \phib_0) = 0
\thinspace .
\label{fem:vec:dEdc0:Galerkin}
\end{equation}
$$

<p>

<h4>The Galerkin or projection method  <a name="___sec7"></a></h4>
<p>

<ul>
 <p><li> Backgrund: minimizing \( ||\e||^2 \) implies that \( \e \) is
   orthogonal to <em>any</em> vector \( \v \) in the space \( V \)
   (visually clear, but can easily be computed too)
 <p><li> Alternative idea: demand \( (\e, \v) = 0,\quad\forall\v\in V \)
 <p><li> Equivalent statement: \( (\e, \phib_0)=0 \) (see notes for why)
 <p><li> Insert \( \e = \f - c_0\phib_0 \) and solve for \( c_0 \)
 <p><li> Same equation for \( c_0 \) and hence same solution
</ul>

<h3>Approximation of general vectors <a name="fem:approx:vec:Np1dim"></a></h3>
<p>
Given some vector \( \f \), seek an approximation \( \u \) in a vector space \( V \)
of dimension \( N+1 \):

<p>
$$
\begin{equation*}
V = \hbox{span}\,\{\phib_0,\ldots,\phib_N\}
\thinspace .
\end{equation*}
$$

<p>

<ul>
 <p><li> We have a set of linearly independent basis vectors
   \( \phib_0,\ldots,\phib_N \)
 <p><li> Any \( \u\in V \) can then be written as \( \u = \sum_{j=0}^Nc_j\phib_j \)
</ul>

<h4>The least squares method  <a name="___sec9"></a></h4>
<p>
Idea: find \( c_0,\ldots,c_N \) such that \( E= ||\e||^2 \) is minimized, \( \e=\f-\u \).

<p>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\phib_j,\f -\sum_jc_j\phib_j)
\nonumber\\
&= (\f,\f) - 2\sum_{j=0}^Nc_j(\f,\phib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\phib_p,\phib_q)\thinspace .
\end{align*}
$$

<p>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\thinspace .
\end{equation*}
$$

<p>
After a bit tedious and technical work with sums, we get
a <em>linear system</em> \( Ac=b \) or

<p>
$$
\sum_{j=0}^N A_{i,j}c_j = b_i,\quad i=0,\ldots,N,
$$
where

<p>
$$
\begin{align}
A_{i,j} &= (\phib_i,\phib_j),\\
b_i &= (\phib_i, \f)\thinspace . \end{align}
$$

<p>

<h4>The Galerkin or projection method  <a name="___sec10"></a></h4>
<p>
Can be shown that minimizing \( ||\e|| \) implies that
\( \e \) is orthogonal to all \( \v\in V \):

<p>

<p>
$$
(\e,\v)=0,\quad \forall\v\in V,
$$
which implies that \( \e \) most be orthogonal to each basis vector (see notes):

<p>
$$
\begin{equation}
(\e,\phib_i)=0,\quad i=0,\ldots,N\thinspace .
\label{fem:approx:vec:Np1dim:Galerkin0}
\end{equation}
$$

<p>
Inserting for \( \e \) and ordering terms gives the same linear system
as that in the least squares method, implying that the methods are
equivalent. However, the linear system will
not be the same when apply these principles to solve PDEs.

<p>

<h2>Approximation of functions <a name="fem:approx:global"></a></h2>
<p>
Let \( V \) be a <em>function space</em> spanned by a set of <em>basis functions</em>
\( \basphi_0,\ldots,\basphi_N \),

<p>
$$
\begin{equation*} V = \hbox{span}\,\{\basphi_0,\ldots,\basphi_N\},\end{equation*}
$$

<p>
Any function \( u\in V \) can be written as a linear
combination of the basis functions:

<p>
$$
\begin{equation}
u = \sum_{j=0}^N c_j\basphi_j\thinspace .
\label{fem:approx:ufem}
\end{equation}
$$
For now, we shall look at functions of a single variable \( x \):
\( u=u(x) \), \( \basphi_i=\basphi_i(x) \), \( i=0,\ldots,N \). Easy go generalize.

<p>

<h3>The least squares method <a name="fem:approx:LS"></a></h3>
<p>
Try to extend the ideas from the vector case: compute error
and minimize error norm.

<p>
What norm?

<p>
$$
\begin{equation}
(f,g) = \int_\Omega f(x)g(x)\, dx\thinspace . \end{equation}
$$

<p>
Restrict attention to some domain \( \Omega \).

<p>
The error: \( e = f - u \).

<p>
The squared norm of the error:

<p>
$$
\begin{equation}
E = (e,e) = (f-u,f-u) = (f(x)-\sum_{j=0}^Nc_j\basphi_j(x), f(x)-\sum_{j=0}^Nc_j\basphi_j(x))
\thinspace .
\label{fem:approx:LS:E}
\end{equation}
$$

<p>
$$
\begin{equation}
E(c_0,\ldots,c_N) = (f,f) -2\sum_{j=0}^N c_j(f,\basphi_i)
+ \sum_{p=0}^N\sum_{q=0}^N c_pc_q(\basphi_p,\basphi_q)\thinspace . \end{equation}
$$

<p>
Minimizing \( E \) implies

<p>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\thinspace .
\end{equation*}
$$

<p>
After computations identical to the vector case, we get a <em>linear system</em>

<p>
$$
\begin{equation}
\sum_{j=0}^N A_{i,j}c_j = b_i,\quad i=0,\ldots,N,
\label{fem:approx:vec:Np1dim:eqsys}
\end{equation}
$$
where

<p>
$$
\begin{align}
A_{i,j} &= (\basphi_i,\basphi_j)
\label{fem:approx:Aij}\\
b_i &= (f,\basphi_i)\thinspace .
\label{fem:approx:bi}
\end{align}
$$

<p>

<h3>The Galerkin or projection method  <a name="___sec13"></a></h3>
<p>
As before, minimizing \( (e,e) \) is equivalent to

<p>
$$
\begin{equation}
(e,v)=0,\quad\forall v\in V,
\label{fem:approx:Galerkin}
\end{equation}
$$
which means (as before)

<p>
$$
\begin{equation}
(e,\basphi_i)=0,\quad i=0,\ldots,N\thinspace .
\label{fem:approx:Galerkin0}
\end{equation}
$$

<p>
With the same algebra as in the multi-dimensional vector case,
we get the same linear system as arose from the least squares method.

<p>
That is, the least squares and Galerkin/projection methods are again equivalent.

<p>

<h3>Example: linear approximation <a name="fem:approx:global:linear"></a></h3>
<p>
Problem: approximate a parabola by a straight line.

<p>
$$
\begin{equation*} V = \hbox{span}\,\{1, x\}\thinspace . \end{equation*}
$$
That is, \( \basphi_0(x)=1 \), \( \basphi_1(x)=x \), and \( N=1 \).
We seek

<p>
$$
\begin{equation*} u=c_0\basphi_0(x) + c_1\basphi_1(x) = c_0 + c_1x,\end{equation*}
$$

<p>
$$
\begin{align}
A_{0,0} &= (\basphi_0,\basphi_0) = \int_1^21\cdot 1\, dx = 1,\\
A_{0,1} &= (\basphi_0,\basphi_1) = \int_1^2 1\cdot x\, dx = 3/2,\\
A_{1,0} &= A_{0,1} = 3/2,\\
A_{1,1} &= (\basphi_1,\basphi_1) = \int_1^2 x\cdot x\,dx = 7/3\thinspace . \end{align}
$$

<p>
$$
\begin{align}
b_1 &= (f,\basphi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3,\\
b_2 &= (f,\basphi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3\thinspace . \end{align}
$$
Solution of 2x2 linear system:

<p>
$$
\begin{equation}
c_0 = -38/3,\quad c_1 = 10,
\end{equation}
$$

<p>
$$
\begin{equation}
u(x) = 10x - \frac{38}{3}\thinspace . \end{equation}
$$

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Best approximation of a parabola by a straight line.  <a name="fem:approx:global:fig:parabola:linear"></a> </p></center>
<p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p>
</center>

<p>

<p>

<h3>Implementation of the least squares method <a name="fem:approx:global:LS:code"></a></h3>
<p>
Consider symbolic computation of the linear system,
where

<p>

<ul>
 <p><li> \( f(x) \) is given as a <tt>sympy</tt> expression <tt>f</tt> (involving
   the symbol <tt>x</tt>),
 <p><li> <tt>phi</tt> is a list of \( \basphi_0,\ldots,\basphi_N \),
 <p><li> <tt>Omega</tt> is a 2-tuple/list holding the domain \( \Omega \)
</ul>

<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sm</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">least_squares</span>(f, phi, Omega):
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">len</span>(phi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;x&#39;</span>)
    <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #AA22FF; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(i, N<span style="color: #666666">+1</span>):
            A[i,j] <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(phi[i]<span style="color: #666666">*</span>phi[j],
                                  (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
            A[j,i] <span style="color: #666666">=</span> A[i,j]
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(phi[i]<span style="color: #666666">*</span>f, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(phi)):
        u <span style="color: #666666">+=</span> c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>phi[i]
    <span style="color: #AA22FF; font-weight: bold">return</span> u
</pre></div>
<p>
Observe: symmetric coefficient matrix.

<p>
Compare \( f \) and \( u \) visually:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">comparison_plot</span>(f, u, Omega, filename<span style="color: #666666">=</span><span style="color: #BB4444">&#39;tmp.pdf&#39;</span>):
    x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;x&#39;</span>)
    f <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>lambdify([x], f, modules<span style="color: #666666">=</span><span style="color: #BB4444">&quot;numpy&quot;</span>)
    u <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>lambdify([x], u, modules<span style="color: #666666">=</span><span style="color: #BB4444">&quot;numpy&quot;</span>)
    resolution <span style="color: #666666">=</span> <span style="color: #666666">401</span>  <span style="color: #008800; font-style: italic"># no of points in plot</span>
    xcoor  <span style="color: #666666">=</span> linspace(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], resolution)
    exact  <span style="color: #666666">=</span> f(xcoor)
    approx <span style="color: #666666">=</span> u(xcoor)
    plot(xcoor, approx)
    hold(<span style="color: #BB4444">&#39;on&#39;</span>)
    plot(xcoor, exact)
    legend([<span style="color: #BB4444">&#39;approximation&#39;</span>, <span style="color: #BB4444">&#39;exact&#39;</span>])
    savefig(filename)
</pre></div>
<p>

<p>

<h3>Perfect approximation <a name="fem:approx:global:exact"></a></h3>
<p>
What if we add \( \basphi_2=x^2 \) to the space \( V \)?
That is, approximating a parabola by any parabola?
(Hopefully we get the exact parabola!)

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2-1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> least_squares(f<span style="color: #666666">=</span>f, phi<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, x, x<span style="color: #666666">**2</span>], Omega<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #AA22FF; font-weight: bold">print</span> u
<span style="color: #666666">10*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x <span style="color: #666666">+</span> <span style="color: #666666">9</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #AA22FF; font-weight: bold">print</span> sm<span style="color: #666666">.</span>expand(f)
<span style="color: #666666">10*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x <span style="color: #666666">+</span> <span style="color: #666666">9</span>
</pre></div>
<p>
Yes!

<p>
What if we use \( \phi_i(x)=x^i \)
for \( i=0,\ldots,N=40 \)?

<p>
The output from <tt>least_squares</tt> is \( c_i=0 \) for \( i>2 \).

<p>
General result: if \( f\in V \), least squares and Galerkin/projection gives \( u=f \).

<p>
Proof: if \( f\in V \), \( f \) can be expanded in
terms of the basis functions, \( f=\sum_{j=0}^Nd_j\basphi_j \), for
some coefficients \( d_0,\ldots,d_N \),
and the right-hand side then has entries

<p>
$$
\begin{equation*} b_i = (f,\basphi_i) = \sum_{j=0}^Nd_j(\basphi_j, \basphi_i) = \sum_{j=0}^Nd_jA_{i,j}
\thinspace . \end{equation*}
$$
The linear system \( \sum_jA_{i,j}c_j = b_i \), \( i=0,\ldots,N \), is then

<p>
$$
\begin{equation*} \sum_{j=0}^Nc_jA_{i,j} = \sum_{j=0}^Nd_jA_{i,j},\quad i=0,\ldots,N,\end{equation*}
$$
which implies that \( c_i=d_i \) for \( i=0,\ldots,N \).

<p>

<h3>Ill-conditioning <a name="fem:approx:global:illconditioning"></a></h3>
<p>
The previous computations were symbolic. What if we do numerical
computing with <tt>numpy</tt> arrays?

<p>
<table border="1">
<tr><td align="center"><b>   exact   </b></td> <td align="center"><b>  <tt>sympy</tt>  </b></td> <td align="center"><b> <tt>numpy32</tt> </b></td> <td align="center"><b> <tt>numpy64</tt> </b></td> </tr>
<tr><td align="right">   9            </td> <td align="right">   9.62         </td> <td align="right">   5.57         </td> <td align="right">   8.98         </td> </tr>
<tr><td align="right">   -20          </td> <td align="right">   -23.39       </td> <td align="right">   -7.65        </td> <td align="right">   -19.93       </td> </tr>
<tr><td align="right">   10           </td> <td align="right">   17.74        </td> <td align="right">   -4.50        </td> <td align="right">   9.96         </td> </tr>
<tr><td align="right">   0            </td> <td align="right">   -9.19        </td> <td align="right">   4.13         </td> <td align="right">   -0.26        </td> </tr>
<tr><td align="right">   0            </td> <td align="right">   5.25         </td> <td align="right">   2.99         </td> <td align="right">   0.72         </td> </tr>
<tr><td align="right">   0            </td> <td align="right">   0.18         </td> <td align="right">   -1.21        </td> <td align="right">   -0.93        </td> </tr>
<tr><td align="right">   0            </td> <td align="right">   -2.48        </td> <td align="right">   -0.41        </td> <td align="right">   0.73         </td> </tr>
<tr><td align="right">   0            </td> <td align="right">   1.81         </td> <td align="right">   -0.013       </td> <td align="right">   -0.36        </td> </tr>
<tr><td align="right">   0            </td> <td align="right">   -0.66        </td> <td align="right">   0.08         </td> <td align="right">   0.11         </td> </tr>
<tr><td align="right">   0            </td> <td align="right">   0.12         </td> <td align="right">   0.04         </td> <td align="right">   -0.02        </td> </tr>
<tr><td align="right">   0            </td> <td align="right">   -0.001       </td> <td align="right">   -0.02        </td> <td align="right">   0.002        </td> </tr>
</table>
<p>

<ul>
  <p><li> Column 2: The matrix and vector are converted to
    the <tt>sympy.mpmath.fp.matrix</tt> data structure and the
    <tt>sympy.mpmath.fp.lu_solve</tt> function is used to solve the system.
  <p><li> Column 3: The matrix and vector are converted to
    <tt>numpy</tt> arrays with data type <tt>numpy.float32</tt>
    (single precision floating-point number) and solved by
    the <tt>numpy.linalg.solve</tt> function.
  <p><li> Column 4: As column 3, but the data type is
    <tt>numpy.float64</tt> (double
    precision floating-point number).
</ul>

Observations:

<p>

<ul>
 <p><li> Significant round-off errors in the numerical computations (!)
 <p><li> But now visually appearant in a plot (!)
</ul>

Reasons: The basis functions \( x^i \) become almost linearly dependent for
large \( N \).

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  The 15 first basis functions \( x^i \), \( i=0,\ldots,14 \). <a name="fem:approx:global:fig:illconditioning"></a> </p></center>
<p><img src="fig-fem/ill_conditioning.png" align="bottom" width=600></p>
</center>

<p>

<p>
Almost linearly dependent basis functions give almost singular matrices.
Such matrices are said to be <em>ill conditioned</em>, and Gaussian elimination
is then prone to round-off errors.

<p>
The basis \( 1, x, x^2, x^3, x^4, \ldots \) is a bad basis. Polynomials
are fine as basis, but more orthogonal they are,
\( (\basphi_i,\basphi_j)\approx 0 \), the better.

<p>

<h3>Fourier series <a name="fem:approx:global:Fourier"></a></h3>
<p>
Consider

<p>
$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\thinspace . \end{equation*}
$$

<p>
$$
\begin{equation*} \basphi_i(x) = \sin ((i+1)\pi x),\quad i=0,\ldots,N\thinspace . \end{equation*}
$$

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">N <span style="color: #666666">=</span> <span style="color: #666666">3</span>
<span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #AA22FF; font-weight: bold">import</span> sin, pi
phi <span style="color: #666666">=</span> [sin(pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x) <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(N<span style="color: #666666">+1</span>)]
f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">1</span>
Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]
u <span style="color: #666666">=</span> least_squares(f, phi, Omega)
comparison_plot(f, u, Omega)
</pre></div>
<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions.  <a name="fem:approx:global:fig:parabola:sine1"></a> </p></center>
<p><img src="fig-fem/parabola_ls_sines4_12.png" align="bottom" width=800,></p>
</center>

<p>

<p>
Considerably improvement by \( N=11 \).

<p>
However, always discrepancy of \( f(0)-u(0)=9 \) at \( x=0 \), because all the
\( \basphi_i(0)=0 \) and hence \( u(0)=0 \). Possible remedy:

<p>
$$
\begin{equation}
u(x) = f(0)(1-x) + xf(1) + \sum_{j=0}^N c_j\basphi_j(x)
\thinspace .
\end{equation}
$$
The extra term is a strikingly good help to get a good
approximation.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions with a boundary term.  <a name="fem:approx:global:fig:parabola:sine2"></a> </p></center>
<p><img src="fig-fem/parabola_ls_sines4_12_wfterm.png" align="bottom" width=800,></p>
</center>

<p>

<p>

<p>

<p>

<p>

<h3>Orthogonal basis functions  <a name="___sec19"></a></h3>
<p>
This choice of sine functions as basis functions is popular because

<p>

<ul>
 <p><li> the basis functions are orthogonal: \( (\basphi_i,\basphi_j)=0 \)
 <p><li> implying that \( A_{i,j} \) is a diagonal matrix
 <p><li> implying that \( c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx \)
</ul>

In general for an orthogonal basis, \( A_{i,j} \) is diagonal and we can solve
for \( c_i \):

<p>
$$
c_i = \frac{b_i}{A_{i,i}} = \frac{(f,\basphi_i)}{(\basphi_i,\basphi_i)}
\thinspace .
$$

<p>

<h3>The collocation or interpolation method <a name="fem:approx:global:interp"></a></h3>
<p>

<p>
Here is another idea: force \( u(\xno{i}) = f(\xno{i}) \) at some selected points
\( \xno{i} \), \( i=0,\ldots,N \). Then \( u \) interpolates \( f \).
Also known as the collocation method and \( \xno{i} \) as collocation points.

<p>
$$
\begin{equation}
u(\xno{i}) = \sum_{j=0}^N c_j \basphi_j(\xno{i}) = f(\xno{i}),\quad i=0,\ldots,N\thinspace . \end{equation}
$$

<p>
This is a linear system,

<p>
$$
\begin{equation}
\sum_{j=0}^N A_{i,j}c_j = b_i,\quad i=0,\ldots,N,
\end{equation}
$$
with

<p>
$$
\begin{align}
A_{i,j} &= \basphi_j(\xno{i}),\\
b_i &= f(\xno{i})\thinspace . \end{align}
$$

<p>
No symmetric matrix: \( \basphi_j(\xno{i})\neq \basphi_i(\xno{j}) \) (in general).

<p>
With <tt>points</tt> as the collocation/interpolation points we can program
the symbolic computations:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">interpolation</span>(f, phi, points):
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">len</span>(phi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;x&#39;</span>)
    <span style="color: #008800; font-style: italic"># Turn phi and f into Python functions</span>
    phi <span style="color: #666666">=</span> [sm<span style="color: #666666">.</span>lambdify([x], phi[i]) <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(N<span style="color: #666666">+1</span>)]
    f <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>lambdify([x], f)
    <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #AA22FF; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(N<span style="color: #666666">+1</span>):
            A[i,j] <span style="color: #666666">=</span> phi[j](points[i])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> f(points[i])
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(phi)):
        u <span style="color: #666666">+=</span> c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>phi[i](x)
    <span style="color: #AA22FF; font-weight: bold">return</span> u
</pre></div>
<p>

<p>
Features:

<p>

<ul>
 <p><li> +: no computation of integrals
 <p><li> -: how to choose \( \xno{i} \)?
</ul>

<h4>Example  <a name="___sec21"></a></h4>
<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right).  <a name="fem:approx:global:linear:interp:fig1"></a> </p></center>
<p><img src="fig-fem/parabola_inter.png" align="bottom" width=800,></p>
</center>

<p>

<p>

<h3>Lagrange polynomials <a name="fem:approx:global:Lagrange"></a></h3>
<p>
Motivation:

<p>

<ul>
 <p><li> the interpolation/collocation method avoids integration
 <p><li> with a diagonal matrix \( A_{i,j} = \basphi_j(\xno{i}) \) we
   can solve the linear system by hand
</ul>

The <em>Lagrange interpolating polynomials</em> \( \basphi_j \) have the property that
\( \basphi_j(\xno{i})=0 \) for \( i\neq 1 \) and \( \basphi_i(\xno{i})=1 \), so that
\( c_i = f(x_i) \) and hence

<p>
$$
\begin{equation}
u(x) = \sum_{j=0}^N f(\xno{i})\basphi_i(x)\thinspace . \end{equation}
$$

<p>
Formula:

<p>
$$
\begin{equation}
\basphi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N},
\label{fem:approx:global:Lagrange:poly}
\end{equation}
$$

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">Lagrange_polynomial</span>(x, i, points):
    p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(points)):
        <span style="color: #AA22FF; font-weight: bold">if</span> k <span style="color: #666666">!=</span> i:
            p <span style="color: #666666">*=</span> (x <span style="color: #666666">-</span> points[k])<span style="color: #666666">/</span>(points[i] <span style="color: #666666">-</span> points[k])
    <span style="color: #AA22FF; font-weight: bold">return</span> p
</pre></div>
<p>

<p>
These basis functions are very much used in finite element methods.

<p>

<h4>Successful example  <a name="___sec23"></a></h4>
<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Approximation via least squares (left) and interpolation (right) of a sine function by Lagrange interpolating polynomials of degree 4. <a name="fem:approx:global:Lagrange:fig:sine:ls:colloc"></a> </p></center>
<p><img src="fig-fem/Lagrange_ls_interp_sin_4.png" align="bottom" width=800,></p>
</center>

<p>

<p>

<h4>Less successful example  <a name="___sec24"></a></h4>
<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right).  <a name="fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14"></a> </p></center>
<p><img src="fig-fem/Lagrange_interp_abs_8_15.png" align="bottom" width=800,></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  Illustration of the oscillatory behavior of two Lagrange polynomials for 12 uniformly spaced points (marked by circles).  <a name="fem:approx:global:Lagrange:fig:abs:Lag:unif:osc"></a> </p></center>
<p><img src="fig-fem/Lagrange_basis_12.png" align="bottom" width=400></p>
</center>

<p>

<p>
Problem: strong oscillations near the boundaries for larger \( N \) values.

<p>

<h4>Remedy for strong oscillations  <a name="___sec25"></a></h4>
<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

<p>
$$
\begin{equation}
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N,
\end{equation}
$$
on an interval \( [a,b] \).

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 12:  Interpolation of an absolute value function by Lagrange polynomials and Chebyshev nodes as interpolation points: degree 7 (left) and 14 (right).  <a name="fem:approx:global:Lagrange:fig:abs:Lag:Cheb:7:14"></a> </p></center>
<p><img src="fig-fem/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800,></p>
</center>

<p>

<p>

<p>

<h2>Finite element basis functions <a name="fem:approx:fe"></a></h2>
<p>

<p>

<p>
So far: basis functions have been <em>global</em>:
\( \basphi_i(x) \neq 0 \) for most \( x\in\Omega \).

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 13:  Approximation based on sine basis functions. <a name="fem:approx:fe:fig:u:sin"></a> </p></center>
<p><img src="fig-fem/u_example_sin.png" align="bottom" width=600></p>
</center>

<p>

<p>
In the finite element method, basis functions are <em>piecewise
polynomials</em> with <em>local support</em> (\( \basphi_i(x) \neq 0 \) for \( x \) in a
small subdomain of \( \Omega \)), typically hat-like functions.  This
makes \( u=\sum_j c_j\basphi_j \) a polynomial over (small) subdomains.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 14:  Approximation based on local piecewise linear (hat) functions. <a name="fem:approx:fe:fig:u:fe"></a> </p></center>
<p><img src="fig-fem/u_example_fe.png" align="bottom" width=600></p>
</center>

<p>

<p>

<h3>Elements and nodes <a name="fem:approx:fe:def:elements:nodes"></a></h3>
<p>
Split \( \Omega \) into non-overlapping subdomains called <em>elements</em>:

<p>
$$
\begin{equation}
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(n_e)}\thinspace . \end{equation}
$$

<p>
On each element, introduce points called <em>nodes</em>. Below: nodes at the
end point of elements.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 15:  Vertical dashed lines mark element boundaries and nodes. <a name="fem:approx:fe:fig:u:fe2"></a> </p></center>
<p><img src="fig-fem/u_example_fe2.png" align="bottom" width=600></p>
</center>

<p>

<p>

<ul>
 <p><li> \( \basphi_i=1 \) at node \( i \) and 0 at all other nodes
 <p><li> \( \basphi_i \) is a Lagrange polynomial on each element
 <p><li> For nodes at the boundary between two elements, \( \basphi_i \) is made
   up of a Lagrange polynomial from each element
</ul>

<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 16:  Illustration of the piecewise quadratic basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P2"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 17:  Illustration of the piecewise cubic basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P3"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600,></p>
</center>

<p>

<p>
Important property: \( c_i \)
is the value of \( u \) at node \( i \), \( \xno{i} \):

<p>
$$
\begin{equation}
u(\xno{i}) = \sum_{j=0}^N c_j\basphi_j(\xno{i}) =
c_i\basphi_i(\xno{i}) = c_i
\label{fem:approx:fe:phi:prop1}
\thinspace .
\end{equation}
$$

<p>
\( \basphi_i(x) \) is mostly zero throughout the domain:

<p>

<ul>
 <p><li> \( \basphi_i(x) \neq 0 \) only on those elements that contain global node \( i \),
 <p><li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) if and only if \( i \) and \( j \) are global node
   numbers in the same element.
</ul>

Since \( A_{i,j} \) is the integral of
\( \basphi_i\basphi_j \) it means that
<em>most of the elements in the coefficient matrix will be zero</em>
(important for implementation!).

<p>

<h3>Example on quadratic \( \basphi_i \)  <a name="___sec28"></a></h3>
<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 18:  Finite element mesh: nodes are circles and vertical lines denote element boundaries (piecewise quadratic basis functions).  <a name="fem:approx:fe:fig:P2:v2"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p>
</center>

<p>

<p>
Introduce <tt>nodes</tt> and <tt>elements</tt> lists:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.125</span>, <span style="color: #666666">0.25</span>, <span style="color: #666666">0.375</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0.625</span>, <span style="color: #666666">0.75</span>, <span style="color: #666666">0.875</span>, <span style="color: #666666">1.0</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>, <span style="color: #666666">6</span>], [<span style="color: #666666">6</span>, <span style="color: #666666">7</span>, <span style="color: #666666">8</span>]]
</pre></div>
<p>

<p>

<ol>
<p><li> The polynomial that is 1 at local node 1
   (\( x=0.375 \), global node 3) makes up the basis function
   \( \basphi_3(x) \) over this element,
   with \( \basphi_3(x)=0 \) outside the element.
<p><li> The Lagrange polynomial that is 1 at local node 0 is the "right
   part" of the global basis function
   \( \basphi_2(x) \). The "left part" of \( \basphi_2(x) \) consists of
   a Lagrange polynomial associated with local node 2 in
   the neighboring element \( \Omega^{(0)}=[0, 0.25] \).
<p><li> Finally, the polynomial that is 1 at local node 2 (global node 4)
   is the "left part" of the global basis function \( \basphi_4(x) \).
   The "right part" comes from the Lagrange polynomial that is 1 at
   local node 0 in the neighboring element \( \Omega^{(2)}=[0.5, 0.75] \).
</ol>

<h3>Example on linear \( \basphi_i \)  <a name="___sec29"></a></h3>
<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 19:  Illustration of the piecewise linear basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P1"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=600></p>
</center>

<p>

<p>
$$
\begin{equation}
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\
(x - \xno{i-1})/h,
& \xno{i-1} \leq x < \xno{i},\\
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1},\\
0, & x\geq \xno{i+1}
\end{array}
\right.
\label{fem:approx:fe:phi:1:formula2}
\end{equation}
$$

<p>

<h3>Example on cubic \( \basphi_i \)  <a name="___sec30"></a></h3>
<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 20:  Illustration of the piecewise cubic basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P3"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600,></p>
</center>

<p>

<p>

<h3>Terminology  <a name="___sec31"></a></h3>
<p>

<ul>
 <p><li> P1 element: piecewise linear \( \basphi_i \) (piecewise linear \( u \))
 <p><li> P2 element: piecewise quadratic \( \basphi_i \) (piecewise quadratic \( u \))
 <p><li> P3 element: piecewise cubic \( \basphi_i \) (piecewise cubic \( u \))
 <p><li> Pd element: piecewise polynom of degree \( d \)
</ul>

<h3>Back to approximating \( u \): calculating the linear system <a name="fem:approx:global:linearsystem"></a></h3>
<p>
Assume uniform element length and P1 elements:

<p>
$$ \Omega^{(i)} = [\xno{i},\xno{i+1}] = [ih, (i+1)h],\quad i=0,\ldots,N-1$$

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 21:  Piecewise linear basis functions \( \basphi_1 \) and \( \basphi_2 \).  <a name="fem:approx:fe:fig:P1:v2"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=600></p>
</center>

<p>

<p>
$$
\begin{equation*}
A_{i,i-1} = \int_\Omega \basphi_i\basphi_{i-1}dx = \int_{\xno{i-1}}^{\xno{i}}
\left(1 - \frac{x - \xno{i-1}}{h}\right)\frac{x - x_{i}}{h} dx = \frac{h}{6}\thinspace .
\end{equation*}
$$

<p>
Can show that \( A_{i,i+1} =h/6 \), \( A_{i,i}=2h/3 \), but modifications
at the boundary of \( \Omega \): \( A_{0,0}=h/3 \) and \( A_{N,N}=h/3 \).

<p>
$$
\begin{equation}
b_i = \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)dx\thinspace .
\label{fem:approx:fe:bi:formula1}
\end{equation}
$$

<p>
With two equal-sized elements in \( \Omega=[0,1] \) and \( f(x)=x(1-x) \):

<p>
$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\
1 & 4 & 1\\
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\
12 - 14h\\
10 -17h
\end{array}\right)\thinspace .
\end{equation*}
$$

<p>
$$
\begin{equation*} c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2\thinspace . \end{equation*}
$$

<p>
$$
\begin{equation*} u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)\end{equation*}
$$

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 22:  Least squares approximation using 2 (left) and 4 (right) P1 elements. <a name="fem:approx:fe:fig:ls:P1:2:4"></a> </p></center>
<p><img src="fig-fem/fe_p1_x2_2e_4e.png" align="bottom" width=800,></p>
</center>

<p>

<p>

<h3>Assembly of elementwise computations <a name="fem:approx:fe:elementwise"></a></h3>
<p>
Split the integral over \( \Omega \) into elementwise integrals:
each element:

<p>
$$
\begin{equation}
A_{i,j} = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} A^{(e)}_{i,j},\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_jdx\thinspace .
\label{fem:approx:fe:elementwise:Asplit}
\end{equation}
$$

<p>
Important:

<p>

<ul>
 <p><li> \( A^{(e)}_{i,j}\neq 0 \) if and only if \( i \) and \( j \) are nodes in element
   \( e \) (otherwise no overlap between the basis functions)
 <p><li> all the nonzero elements in \( A^{(e)}_{i,j} \) are collected in an
   <em>element matrix</em>
</ul>

$$
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad r,s=0,\ldots,d,
$$

<p>
$$
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)}dx,\quad r,s=0,\ldots,d.
$$

<p>

<ul>
 <p><li> \( r,s \) run over <em>local node numbers</em> within an element, while \( i,j \) run
   over <em>global node numbers</em>.
 <p><li> \( i=q(e,r) \): mapping of local node number \( r \) in element
   \( e \) to the global node number \( i \). Math equivalent to <tt>i=elements[e][r]</tt>.
 <p><li> Add contribution from an element into the global coefficient matrix
   (<em>assembly</em>):
</ul>

$$
\begin{equation}
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s=0,\ldots,d\thinspace . \end{equation}
$$

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 23:  Illustration of matrix assembly.  <a name="fem:approx:fe:fig:assembly"></a> </p></center>
<p><img src="fig-fem/matrix-assembly.png" align="bottom" width=600></p>
</center>

<p>

<p>
Can also compute the right-hand side of the linear system from
elementwise contributions:

<p>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} b^{(e)}_{i},\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)dx\thinspace . \end{equation}
$$

<p>
Important:

<p>

<ul>
  <p><li> \( b_i^{(e)}\neq 0 \) if and only if global node \( i \) is a node in element \( e \)
    (otherwise \( \basphi_i=0 \))
  <p><li> The \( d+1 \) nonzero \( b_i^{(e)} \) can be collected in an <em>element vector</em>
</ul>

$$
\begin{equation*} \tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\},\quad r=0,\ldots,d\thinspace . \end{equation*}
$$

<p>
Assembly:

<p>
$$
\begin{equation}
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r,s=0,\ldots,d\thinspace . \end{equation}
$$

<p>

<h3>Mapping to a reference element <a name="fem:approx:fe:mapping"></a></h3>
<p>
Instead of computing

<p>
$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx\end{equation*}
$$
over some element
\( \Omega^{(e)} = [x_L, x_R] \),
we now map \( [x_L, x_R] \) to
a standardized reference element domain \( [-1,1] \) with local coordinate \( X \).

<p>
Affine mapping:

<p>
$$
\begin{equation}
x = \half (x_L + x_R) + \half (x_R - x_L)X\thinspace .
\label{fem:approx:fe:affine:mapping}
\end{equation}
$$
or rewritten as
$$
\begin{equation}
x = x_m + \frac{1}{2}hX, \qquad x_m=(x_L+x_R)/2
\label{fem:approx:fe:affine:mapping2}
\end{equation}
$$

<p>
Integrating on
the reference element is a matter of just changing the integration
variable from \( x \) to \( X \). Let

<p>
$$
\begin{equation}
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
\end{equation}
$$
be the basis function associated with local node number \( r \) in the
reference element. The integral transformation reads

<p>
$$
\begin{equation}
\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\frac{dx}{dX}dX\thinspace . \end{equation}
$$

<p>
Introduce the notation
\( \det J = dx/dX = h/2 \), because in 2D and 3D we get \( \det J \)
instead of \( dx/dX \).

<p>
$$
\begin{equation}
\tilde A^{(e)}_{r,s}
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
\label{fem:approx:fe:mapping:Ae}
\thinspace .
\end{equation}
$$

<p>
$$
\begin{equation}
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
\label{fem:approx:fe:mapping:be}
\thinspace .
\end{equation}
$$

<p>
Advantages:

<p>

<ul>
  <p><li> Always the same domain for integration: \( [-1,1] \)
  <p><li> We only need formulas for \( \refphi_r(X) \) on the reference elements
    (no need for piecewise polynomial definition)
</ul>

P1 elements:

<p>
$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\label{fem:approx:fe:mapping:P1:phi0}\\
\refphi_1(X) &= \half (1 + X)
\label{fem:approx:fe:mapping:P1:phi1}
\end{align}
$$

<p>
P2 elements:

<p>
$$
\begin{align}
\refphi_0(X) &= \half (X-1)X\\
\refphi_1(X) &= 1 - X^2\\
\refphi_2(X) &= \half (X+1)X
\end{align}
$$

<p>

<h3>Integration over a reference element <a name="fem:approx:fe:intg:ref"></a></h3>
<p>
P1 elements and \( f(x)=x(1-x) \).

<p>
$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\
&=\int_{-1}^1 \frac{1}{2}(1-X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3},\\
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6},\\
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0},\\
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\thinspace .
\end{align}
$$

<p>
$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1-X)\frac{h}{2} dX \nonumber\\
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\tilde b^{(e)}_{1}\\
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1+X)\frac{h}{2} dX \nonumber\\
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\thinspace .
\end{align}
$$
\( x_m \): element midpoint.

<p>
Tedious calculations! Let's use symbolic software:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sm</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x, x_m, h, X <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>symbols(<span style="color: #BB4444">&#39;x x_m h X&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> sm<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/8*</span>(<span style="color: #666666">1-</span>X)<span style="color: #666666">**2</span>, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
h<span style="color: #666666">/3</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sm<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/8*</span>(<span style="color: #666666">1+</span>X)<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>X), (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
h<span style="color: #666666">/6</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> x_m <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>X
<span style="color: #666666">&gt;&gt;&gt;</span> b_0 <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/4*</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>X), (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #AA22FF; font-weight: bold">print</span> b_0
<span style="color: #666666">-</span>h<span style="color: #666666">**3/24</span> <span style="color: #666666">+</span> h<span style="color: #666666">**2*</span>x_m<span style="color: #666666">/6</span> <span style="color: #666666">-</span> h<span style="color: #666666">**2/12</span> <span style="color: #666666">-</span> h<span style="color: #666666">*</span>x_m<span style="color: #666666">**2/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">*</span>x_m<span style="color: #666666">/2</span>
</pre></div>
<p>

<p>
Can printe out in LaTeX too (convenient for copying into reports):

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #AA22FF; font-weight: bold">print</span> sm<span style="color: #666666">.</span>latex(b_0, mode<span style="color: #666666">=</span><span style="color: #BB4444">&#39;plain&#39;</span>)
<span style="color: #666666">-</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">24</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">3</span>} <span style="color: #666666">+</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">6</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">2</span>} x_{m}
<span style="color: #666666">-</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">12</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">2</span>} <span style="color: #666666">-</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">2</span>} h x_{m}<span style="color: #666666">^</span>{<span style="color: #666666">2</span>}
<span style="color: #666666">+</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">2</span>} h x_{m}
</pre></div>
<p>

<p>

<h2>Implementation  <a name="___sec36"></a></h2>
<p>

<ul>
 <p><li> Coming functions appear in <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/fem/fe_approx1D.py"><tt>fe_approx1D.py</tt></a>
 <p><li> Functions can operate in symbolic or numeric mode
 <p><li> The code documents all steps in finite element calculations
</ul>

<h3>Integration  <a name="___sec37"></a></h3>
<p>
Compute \( \refphi_r(X) \) as a Lagrange polynomial of degree <tt>d</tt>:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sm</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">phi_r</span>(r, X, d):
    <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">isinstance</span>(X, sm<span style="color: #666666">.</span>Symbol):
        h <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>, d)  <span style="color: #008800; font-style: italic"># node spacing</span>
        nodes <span style="color: #666666">=</span> [<span style="color: #666666">2*</span>i<span style="color: #666666">*</span>h <span style="color: #666666">-</span> <span style="color: #666666">1</span> <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(d<span style="color: #666666">+1</span>)]
    <span style="color: #AA22FF; font-weight: bold">else</span>:
        <span style="color: #008800; font-style: italic"># assume X is numeric: use floats for nodes</span>
        nodes <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, d<span style="color: #666666">+1</span>)
    <span style="color: #AA22FF; font-weight: bold">return</span> Lagrange_polynomial(X, r, nodes)

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">Lagrange_polynomial</span>(x, i, points):
    p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(points)):
        <span style="color: #AA22FF; font-weight: bold">if</span> k <span style="color: #666666">!=</span> i:
            p <span style="color: #666666">*=</span> (x <span style="color: #666666">-</span> points[k])<span style="color: #666666">/</span>(points[i] <span style="color: #666666">-</span> points[k])
    <span style="color: #AA22FF; font-weight: bold">return</span> p
</pre></div>
<p>

<p>
The complete basis:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">basis</span>(d<span style="color: #666666">=1</span>):
    X <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;X&#39;</span>)
    phi <span style="color: #666666">=</span> [phi_r(r, X, d) <span style="color: #AA22FF; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(d<span style="color: #666666">+1</span>)]
    <span style="color: #AA22FF; font-weight: bold">return</span> phi
</pre></div>
<p>

<p>
Element matrix:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">element_matrix</span>(phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
    n <span style="color: #666666">=</span> <span style="color: #AA22FF">len</span>(phi)
    A_e <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((n, n))
    X <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;X&#39;</span>)
    <span style="color: #AA22FF; font-weight: bold">if</span> symbolic:
        h <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;h&#39;</span>)
    <span style="color: #AA22FF; font-weight: bold">else</span>:
        h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>  <span style="color: #008800; font-style: italic"># dx/dX</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
        <span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(r, n):
            A_e[r,s] <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(phi[r]<span style="color: #666666">*</span>phi[s]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
            A_e[s,r] <span style="color: #666666">=</span> A_e[r,s]
    <span style="color: #AA22FF; font-weight: bold">return</span> A_e
</pre></div>
<p>

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> phi
[<span style="color: #666666">1/2</span> <span style="color: #666666">-</span> X<span style="color: #666666">/2</span>, <span style="color: #666666">1/2</span> <span style="color: #666666">+</span> X<span style="color: #666666">/2</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> element_matrix(phi, Omega_e<span style="color: #666666">=</span>[<span style="color: #666666">0.1</span>, <span style="color: #666666">0.2</span>], symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>)
[h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> element_matrix(phi, Omega_e<span style="color: #666666">=</span>[<span style="color: #666666">0.1</span>, <span style="color: #666666">0.2</span>], symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">False</span>)
[<span style="color: #666666">0.0333333333333333</span>, <span style="color: #666666">0.0166666666666667</span>]
[<span style="color: #666666">0.0166666666666667</span>, <span style="color: #666666">0.0333333333333333</span>]
</pre></div>
<p>

<p>
Element vector:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">element_vector</span>(f, phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
    n <span style="color: #666666">=</span> <span style="color: #AA22FF">len</span>(phi)
    b_e <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((n, <span style="color: #666666">1</span>))
    <span style="color: #008800; font-style: italic"># Make f a function of X</span>
    X <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;X&#39;</span>)
    <span style="color: #AA22FF; font-weight: bold">if</span> symbolic:
        h <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;h&#39;</span>)
    <span style="color: #AA22FF; font-weight: bold">else</span>:
        h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    x <span style="color: #666666">=</span> (Omega_e[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> Omega_e[<span style="color: #666666">1</span>])<span style="color: #666666">/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>X  <span style="color: #008800; font-style: italic"># mapping</span>
    f <span style="color: #666666">=</span> f<span style="color: #666666">.</span>subs(<span style="color: #BB4444">&#39;x&#39;</span>, x)  <span style="color: #008800; font-style: italic"># substitute mapping formula for x</span>
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>  <span style="color: #008800; font-style: italic"># dx/dX</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
        b_e[r] <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
    <span style="color: #AA22FF; font-weight: bold">return</span> b_e
</pre></div>
<p>
Note: need to replace the symbol <tt>x</tt> in the expression for <tt>f</tt>
by the mapping formula such that <tt>f</tt> contains the variable <tt>X</tt>.

<p>
Not all \( f(x) \) can be integrated by <tt>sympy</tt> so let us fall back on
numerical integration:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">element_vector</span>(f, phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
        <span style="color: #666666">...</span>
        I <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
        <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">isinstance</span>(I, sm<span style="color: #666666">.</span>Integral):
            h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]  <span style="color: #008800; font-style: italic"># Ensure h is numerical</span>
            detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>
            integrand <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>lambdify([X], f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ)
            I <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>])
        b_e[r] <span style="color: #666666">=</span> I
        <span style="color: #666666">...</span>
</pre></div>
<p>

<p>

<h3>Linear system assembly and solution  <a name="___sec38"></a></h3>
<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">assemble</span>(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
    n_n, n_e <span style="color: #666666">=</span> <span style="color: #AA22FF">len</span>(nodes), <span style="color: #AA22FF">len</span>(elements)
    zeros <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros <span style="color: #AA22FF; font-weight: bold">if</span> symbolic <span style="color: #AA22FF; font-weight: bold">else</span> np<span style="color: #666666">.</span>zeros
    A <span style="color: #666666">=</span> zeros((n_n, n_n))
    b <span style="color: #666666">=</span> zeros((n_n, <span style="color: #666666">1</span>))
    <span style="color: #AA22FF; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n_e):
        Omega_e <span style="color: #666666">=</span> [nodes[elements[e][<span style="color: #666666">0</span>]], nodes[elements[e][<span style="color: #666666">-1</span>]]]

        A_e <span style="color: #666666">=</span> element_matrix(phi, Omega_e, symbolic)
        b_e <span style="color: #666666">=</span> element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #AA22FF; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(elements[e])):
            <span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] <span style="color: #666666">+=</span> A_e[r,s]
            b[elements[e][r]] <span style="color: #666666">+=</span> b_e[r]
    <span style="color: #AA22FF; font-weight: bold">return</span> A, b
</pre></div>
<p>

<p>
Linear system solution:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">if</span> symbolic:
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)           <span style="color: #008800; font-style: italic"># sympy arrays, symbolic Gaussian elim.</span>
<span style="color: #AA22FF; font-weight: bold">else</span>:
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)  <span style="color: #008800; font-style: italic"># numpy arrays, numerical solve</span>
</pre></div>
<p>

<p>

<h3>Example on computing approximations  <a name="___sec39"></a></h3>
<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> h, x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>symbols(<span style="color: #BB4444">&#39;h x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, h, <span style="color: #666666">2*</span>h]
<span style="color: #666666">&gt;&gt;&gt;</span> elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,   <span style="color: #666666">0</span>]
[h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[  <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> b
[     h<span style="color: #666666">**2/6</span> <span style="color: #666666">-</span> h<span style="color: #666666">**3/12</span>]
[      h<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">7*</span>h<span style="color: #666666">**3/6</span>]
[<span style="color: #666666">5*</span>h<span style="color: #666666">**2/6</span> <span style="color: #666666">-</span> <span style="color: #666666">17*</span>h<span style="color: #666666">**3/12</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
<span style="color: #666666">&gt;&gt;&gt;</span> c
[                           h<span style="color: #666666">**2/6</span>]
[<span style="color: #666666">12*</span>(<span style="color: #666666">7*</span>h<span style="color: #666666">**2/12</span> <span style="color: #666666">-</span> <span style="color: #666666">35*</span>h<span style="color: #666666">**3/72</span>)<span style="color: #666666">/</span>(<span style="color: #666666">7*</span>h)]
[  <span style="color: #666666">7*</span>(<span style="color: #666666">4*</span>h<span style="color: #666666">**2/7</span> <span style="color: #666666">-</span> <span style="color: #666666">23*</span>h<span style="color: #666666">**3/21</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>h)]
</pre></div>
<p>

<p>
Numerical computations:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">False</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[ <span style="color: #666666">0.166666666666667</span>, <span style="color: #666666">0.0833333333333333</span>,                  <span style="color: #666666">0</span>]
[<span style="color: #666666">0.0833333333333333</span>,  <span style="color: #666666">0.333333333333333</span>, <span style="color: #666666">0.0833333333333333</span>]
[                 <span style="color: #666666">0</span>, <span style="color: #666666">0.0833333333333333</span>,  <span style="color: #666666">0.166666666666667</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> b
[          <span style="color: #666666">0.03125</span>]
[<span style="color: #666666">0.104166666666667</span>]
[          <span style="color: #666666">0.03125</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
<span style="color: #666666">&gt;&gt;&gt;</span> c
[<span style="color: #666666">0.0416666666666666</span>]
[ <span style="color: #666666">0.291666666666667</span>]
[<span style="color: #666666">0.0416666666666666</span>]
</pre></div>
<p>

<p>

<h3>The structure of the coefficient matrix <a name="fem:approx:fe:A:structure"></a></h3>
<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> d<span style="color: #666666">=1</span>; n_e<span style="color: #666666">=8</span>; Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]  <span style="color: #008800; font-style: italic"># 8 linear elements on [0,1]</span>
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> nodes, elements <span style="color: #666666">=</span> mesh_symbolic(n_e, d, Omega)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
</pre></div>
<p>

<p>
Note: do this by hand to understand what is going on!

<p>
The coefficient matrix is sparse (means mostly zeros):

<p>
$$
\begin{equation}
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
\end{equation}
$$

<p>
For P2 elements:

<p>
$$
\begin{equation}
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 &
  0\\0 & 0 & 2 & 16 & 2 & 0 & 0
  & 0 & 0\\0 & 0 & - 1 & 2 & 8
  & 2 & - 1 & 0 & 0\\0 & 0 & 0 & 0 &
  2 & 16 & 2 & 0 & 0\\0 & 0 & 0
  & 0 & - 1 & 2 & 8 &
  2 & - 1\\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
\end{equation}
$$

<p>
Exploiting the sparse structure is important for efficient computations.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 24:  Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P1 elements. <a name="fem:approx:fe:sparsity:P1"></a> </p></center>
<p><img src="fig-fem/sparsity_pattern_1D_30.png" align="bottom" width=800></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 25:  Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P3 elements. <a name="fem:approx:fe:sparsity:P3"></a> </p></center>
<p><img src="fig-fem/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p>
</center>

<p>

<p>

<p>

<h3>Sparse matrix storage and solution <a name="fem:approx:fe:impl:sparse"></a></h3>
<p>

<p>
We have observed that \( \basphi_i\basphi_j\neq 0 \) only when \( i \) and \( j \)
are nodes in the same element. This means that \( A_{i,j}=0 \) for most
\( i \) and \( j \), and the coefficient matrix is then <em>sparse</em>.

<p>

<ul>
 <p><li> P1 elements: only 3 nonzero entires per row
 <p><li> P2 elements: only 5 nonzero entires per row
 <p><li> P2 elements: only 7 nonzero entires per row
 <p><li> It is important to utilize sparse storage and sparse solvers
 <p><li> In Python: <tt>scipy.sparse</tt> package
</ul>

<h3>Applications  <a name="___sec42"></a></h3>
<p>
Compute a mesh with <tt>n_e</tt> elements, basis functions of
degree <tt>d</tt>, and approximate a given symbolic expression
<tt>f</tt> by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \):

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">approximate</span>(f, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">False</span>, d<span style="color: #666666">=1</span>, n_e<span style="color: #666666">=4</span>, filename<span style="color: #666666">=</span><span style="color: #BB4444">&#39;tmp.pdf&#39;</span>):
</pre></div>
<p>

<p>
Tests:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sm</span>
<span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D</span> <span style="color: #AA22FF; font-weight: bold">import</span> approximate
x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BB4444">&#39;x&#39;</span>)

approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">False</span>, d<span style="color: #666666">=1</span>, n_e<span style="color: #666666">=4</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">False</span>, d<span style="color: #666666">=2</span>, n_e<span style="color: #666666">=2</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">False</span>, d<span style="color: #666666">=1</span>, n_e<span style="color: #666666">=8</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #AA22FF">False</span>, d<span style="color: #666666">=2</span>, n_e<span style="color: #666666">=4</span>)
</pre></div>
<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 26:  Comparison of the finite element approximations: 4 P1 elements with 5 nodes (upper left), 2 P2 elements with 5 nodes (upper right), 8 P1 elements with 9 nodes (lower left), and 4 P2 elements with 9 nodes (lower right).  <a name="fem:appro:fe:x9:sin"></a> </p></center>
<p><img src="fig-fem/fe_p1_p2_x9_248e.png" align="bottom" width=800,></p>
</center>

<p>

<p>

<h2>Comparison of finite element and finite difference approximation <a name="fem:approx:fe:fd"></a></h2>
<p>

<ul>
 <p><li> Finite difference approximation of a function \( f(x) \): simply
   choose \( u_i = f(x_i) \) (interpolation).
 <p><li> Galerkin/projection and least squares method:
   must derive and solve a linear system.
 <p><li> What is really the difference?
</ul>

<h3>Collocation (interpolation)  <a name="___sec44"></a></h3>
<p>
Let \( \xno{i} \), \( i=0,\ldots,N \), be the nodes in the mesh.
Collocation means

<p>
$$
\begin{equation}
u(\xno{i})=f(\xno{i}),\quad i=0,\ldots,N,
\end{equation}
$$
which translates to

<p>
$$ \sum_{j=0}^N c_j \basphi_j(\xno{i}) = f(\xno{i}),$$
but \( \basphi_j(\xno{i})=0 \) if \( i\neq j \) so the sum collapses to one
term \( c_i\basphi_i(\xno{i}) = c_i \), and we have the result

<p>
$$
\begin{equation}
c_i = f(\xno{i})
\thinspace .
\end{equation}
$$

<p>

<ul>
 <p><li> This yields the same result as the standard finite difference approach
 <p><li> \( u \) <em>interpolates</em> \( f \) at the node points
 <p><li> \( u \) has a variation between the node points dictated by the \( \basphi_i \)
   functions
 <p><li> Collocation (interpolation) is not much used when solving
   differential equation, except for approximating initial conditions
   (like here)
</ul>

<h3>Finite difference interpretation of a finite element approximation  <a name="___sec45"></a></h3>
<p>

<ul>
 <p><li> Scope: work with P1 elements (most similar to finite differences)
 <p><li> Use Galerkin/project or least squares (equivalent)
 <p><li> Interpret the resulting linear system as finite difference equations
</ul>

General formula for computing the linear system:

<p>
$$
\sum_{j=0}^N c_j (\basphi_i,\basphi_j) = (f,\basphi_i),\quad i=0,\ldots,N
\thinspace .
$$

<p>
The P1 finite element machinery results in a linear system where
equation no \( i \) is

<p>
$$
\begin{equation}
\frac{h}{6}(u_{i-1} + 4u_i + u_{i+1}) = (f,\basphi_i)
\thinspace .
\label{fem:deq:1D:approx:deq:massmat:diffeq2}
\end{equation}
$$

<p>
Note:

<p>

<ul>
  <p><li> We have used \( u_i \) for \( c_i \) to simplify notation with
    finite differences.
  <p><li> The finite difference counterpart is just \( u_i=f_i \).
</ul>

Rewrite:

<p>
$$
\begin{equation}
h(u_i - \frac{1}{6}(-u_{i-1} + 2u_i - u_{i+1}))
\thinspace .
\end{equation}
$$
This looks like a finite difference approximation of

<p>
$$ h(u - \frac{h^2}{6}u''),$$
That is, the matrix arises from

<p>
$$ [h(u - \frac{h^2}{6}D_x D_x u]_i$$

<p>
The right-hand side is more complicated:

<p>
$$ (f,\basphi_i) = \int_{\xno{i-1}}^{\xno{i}} f(x)\frac{1}{h} (x - \xno{i-1}) dx
+ \int_{\xno{i}}^{\xno{i+1}} f(x)\frac{1}{h}(1 - (x - x_{i})) dx
\thinspace .
$$
Can't to much unless we specialize \( f \) or use <em>numerical integration</em>.

<p>
Apply the Trapezoidal rule using all the nodes:

<p>
$$ (f,\basphi_i) = \int_\Omega f\basphi_i dx\approx h\frac{1}{2}(
f(\xno{0})\basphi_i(\xno{0}) + f(\xno{N})\basphi_i(\xno{N}))
+ h\sum_{j=1}^{N-1} f(\xno{j})\basphi_i(\xno{j})
\thinspace .
$$
Since \( \basphi_i \) is zero at all these points, except at \( \xno{i} \), the
Trapezoidal rule collapses to one term:

<p>
$$
\begin{equation}
(f,\basphi_i) \approx hf(\xno{i}),\quad i=1,\ldots,N-1\thinspace.
\end{equation}
$$
This is the same result as in collocation (interpolation)
and the finite difference method!

<p>
Simpson's rule:

<p>
$$ \int_\Omega f(x)dx \approx \frac{\tilde h}{3}\left( f(x_0) +
2\sum_{j=2,4,6,\ldots} f(x_j)
+ 4\sum_{j=1,3,5,\ldots} f(x_j) + f(x_{2N})\right),
$$
Here \( f \) is sampled at midpoints and endpoints of the elements.
The sums collapse because \( \basphi_i=0 \) at most of these points.

<p>
Result:

<p>
$$
\begin{equation}
(f,\basphi_i) \approx \frac{h}{3}(f(\xno{i}-\frac{1}{2}h)
+ f(\xno{i}) + f(\xno{i}+\frac{1}{2}h)
\thinspace .
\end{equation}
$$
In a finite difference context we would typically express this formula as

<p>
$$ \frac{h}{3}(f_{i-\frac{1}{2}} + f_i + f_{i+\frac{1}{2}})
\thinspace .
$$

<p>
Conclusions:

<p>

<ul>
  <p><li> While the finite difference method just samples \( f \) at \( x_i \),
    the finite element method applies an average of \( f \) around \( x_i \).
  <p><li> On the left-hand side we have a term \( \sim hu'' \), and \( u'' \)
    also contribute to smoothing.
  <p><li> There are some inherent smoothing elements in the finite element
    method.
</ul>

With Trapezoidal integration of \( (f,\basphi_i) \) we essentially solve

<p>
$$
\begin{equation}
u + \frac{h^2}{6} u'' = f,\quad u'(0)=u'(L)=0,
\end{equation}
$$
expressed with operator notation as

<p>
$$
\begin{equation}
[u + \frac{h^2}{6} D_x D_x u = f]_i\thinspace . \end{equation}
$$

<p>
With Simpson integration of \( (f,\basphi_i) \) we essentially solve

<p>
$$
\begin{equation}
[u + \frac{h^2}{6} D_x D_x u = \bar f]_i,
\end{equation}
$$
where
$$ \bar f_i = \frac{1}{3}(f_{i-1/2} + f_i + f_{i+1/2}) $$

<p>
Note:

<p>

<ul>
  <p><li> As \( h\rightarrow 0 \), \( hu''\rightarrow 0 \) and \( \bar f_i\rightarrow f_i \),
    and all approaches yield the same result.
</ul>

<h3>Making finite elements behave as finite differences  <a name="___sec46"></a></h3>
<p>

<ul>
 <p><li> Can we adjust the finite element method so that we do not
   get the extra \( hu'' \) smoothing term and averaging of \( f \)?
 <p><li> This is important in time-dependent problems to incorporate good
   properties of finite differences into finite elements.
</ul>

Result:

<p>

<ul>
 <p><li> By computing all integrals by the Trapezoidal method, P1 elements
   recovers the same formulas as in the finite difference method (\( u_i=f_i \)).
 <p><li> Specifically: the coefficient matrix becomes diagonal ("lumped")
 <p><li> Loss of accuracy? The Trapezoidal rule has error \( {\cal O}(h^2) \),
   the same as the approximation error in P1 elements (integrated exactly).
</ul>

Reason:

<p>

<ul>
 <p><li> Integration rules sample the integrand in nodes will sample
   \( \basphi_i \) at points where it is 0. A lot of terms vanish.
</ul>

<h2>A generalized element concept <a name="fem:approx:fe:element"></a></h2>
<p>
So far,

<p>

<ul>
 <p><li> <em>Nodes</em>: points for defining \( \basphi_i \) and compute \( u \) values
 <p><li> <em>Elements</em>: subdomain (containing some nodes)
 <p><li> This is a common notion of nodes and elements.
</ul>

An extended and generalized element concept:

<p>

<ul>
 <p><li> An <em>element</em> is the collection of the subdomain (previous "element"),
   points where we seek function values, basis functions, numberings,
   mappings, etc.
 <p><li> We introduce <em>cell</em> for the subdomain that we up to now called element.
 <p><li> A cell has <em>vertices</em> (interval end points).
 <p><li> <em>Nodes</em> are, almost as before,
   points where we want to compute unknown functions.
 <p><li> <em>Degrees of freedom</em> is what the \( c_j \) represent (usually function values
   at nodes).
</ul>

<h4>The concept of a finite element  <a name="___sec48"></a></h4>
<p>

<ul>
  <p><li> a <em>reference cell</em> in a local reference coordinate system;
  <p><li> a set of <em>basis functions</em> \( \refphi_i \) defined on the cell;
  <p><li> a set of <em>degrees of freedom</em> that uniquely determine
    the basis functions such that \( \refphi_i=1 \) for degree of freedom
    number \( i \) and \( \refphi_i=0 \) for all other degrees of freedom;
  <p><li> a mapping between local and global degree of freedom numbers;
  <p><li> a <em>mapping</em> of the reference cell onto to cell in the physical
    domain.
</ul>

<h3>Implementation <a name="fem:approx:fe:element:impl"></a></h3>
<p>

<p>

<ul>
  <p><li> We replace <tt>nodes</tt> by <tt>vertices</tt>.
  <p><li> We introduce <tt>cells</tt> such that <tt>cell[e][r]</tt> gives the mapping
    from local vertex <tt>r</tt> in cell <tt>e</tt> to the global vertex number
    in <tt>vertices</tt>.
  <p><li> We replace <tt>elements</tt> by <tt>dof_map</tt> (the contents are the same).
</ul>

Example: \( \Omega =[0,1] \) is divided into two cells,
\( \Omega^{(0)}=[0,0.4] \) and \( \Omega^{(1)}=[0.4,1] \).
Define P2 elements in each cell.

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">vertices <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.4</span>, <span style="color: #666666">1</span>]
cells <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
dof_map <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>]]
</pre></div>
<p>

<p>
Example: \( u \) is piecewise constant in each cell (P0 element).
Same <tt>vertices</tt> and <tt>cells</tt>, but

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">dof_map <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>], [<span style="color: #666666">1</span>], [<span style="color: #666666">2</span>]]
</pre></div>
<p>
May think of nodes in the middle of each element.

<p>
The assembly process must now use the <tt>dof_map</tt> (no <tt>elements</tt> data
structure anymore):

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A[dof_map[e][r], dof_map[e][s]] <span style="color: #666666">+=</span> A_e[r,s]
b[dof_map[e][r]] <span style="color: #666666">+=</span> b_e[r]
</pre></div>
<p>

<p>
We will hereafter work with <tt>cells</tt>, <tt>vertices</tt>, and <tt>dof_map</tt>.

<p>

<h3>Cubic Hermite polynomials  <a name="___sec50"></a></h3>
<p>

<ul>
 <p><li> Can we construct \( \basphi_i(x) \) with continuous derivatives?
 <p><li> Yes!
</ul>

Consider a reference cell \( [-1,1] \). We introduce two nodes, \( X=-1 \) and \( X=1 \).
The degrees of freedom are

<p>

<ul>
  <p><li> 0: value of function at \( X=-1 \)
  <p><li> 1: value of first derivative at \( X=-1 \)
  <p><li> 2: value of function at \( X=1 \)
  <p><li> 3: value of first derivative at \( X=1 \)
</ul>

Derivatives as unknowns ensure the same \( \basphi_i'(x) \) value at nodes!

<p>
$$
\begin{align}
\refphi_0(X) &= 1 - \frac{3}{4}(X+1)^2 + \frac{1}{4}(X+1)^3\\
\refphi_1(X) &= -(X+1)(1 - \frac{1}{2}(X+1))^2\\
\refphi_2(X) &= \frac{3}{4}(X+1)^2 - \frac{1}{2}(X+1)^3\\
\refphi_3(X) &= -\frac{1}{2}(X+1)(\frac{1}{2}(X+1)^2 - (X+1))\\
\end{align}
$$

<p>

<h2>Numerical integration  <a name="___sec51"></a></h2>
<p>
\( \int_\Omega f\basphi_idx \) must in general be computed by numerical integration.

<p>
Common form:

<p>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx \sum_{j=0}^M w_j\bar X_j,
\end{equation}
$$
where

<p>

<ul>
 <p><li> \( \bar X_j \) are <em>integration points</em>
 <p><li> \( w_j \) are <em>integration weights</em>
 <p><li> Different rules correspond to different choices of points and weights
</ul>

Simplest possibility: the Midpoint rule,

<p>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx 2g(0),\quad \bar X_0=0,\ w_0=2,
\end{equation}
$$

<p>

<h3>Newton-Cotes rules <a name="fem:approx:fe:numint1"></a></h3>
<p>

<p>
Idea: use a fixed, uniformly distributed set of points.
The points usually coincides with nodes (in higher-order elements).
Very useful for making \( \basphi_i\basphi_j=0 \) and get diagonal
(mass) matrices ("lumping").

<p>

<p>
The Trapezoidal rule:

<p>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx g(-1) + g(1),\quad \bar X_0=-1,\ \bar X_1=1,\ w_0=w_1=1,
 \label{fem:approx:fe:numint1:trapez}
\end{equation}
$$

<p>
Simpson's rule:

<p>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx \frac{1}{3}\left(g(-1) + 4g(0)
+ g(1)\right),
\end{equation}
$$
where

<p>
$$
\begin{equation}
\bar X_0=-1,\ \bar X_1=0,\ \bar X_2=1,\ w_0=w_2=\frac{1}{3},\ w_1=\frac{4}{3}\thinspace . \end{equation}
$$

<p>

<h3>Gauss-Legendre rules with optimized points  <a name="___sec53"></a></h3>
<p>

<p>

<ul>
 <p><li> Do not fix points, e.g., uniform distribution
 <p><li> Optimize the location of points
 <p><li> Gauss-Legendre rules (quadrature) adjust points and weights to
   integrate polynomials exactly
</ul>

$$
\begin{align}
M=1&:\quad \bar X_0=-\frac{1}{\sqrt{3}},\
\bar X_1=\frac{1}{\sqrt{3}},\ w_0=w_1=1\\
M=2&:\quad \bar X_0=-\sqrt{\frac{3}{{5}}},\ \bar X_0=0,\
\bar X_2= \sqrt{\frac{3}{{5}}},\ w_0=w_2=\frac{5}{9},\ w_1=\frac{8}{9}\thinspace . \end{align}
$$

<p>

<ul>
 <p><li> \( M=1 \): integrates 3rd degree polynomials exactly
 <p><li> \( M=2 \): integrates 5th degree polynomials exactly
 <p><li> In general, \( M \)-point rule integrates a polynomial
   of degree \( 2M+1 \) exactly.
</ul>

See <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/fem/numint.py"><tt>numint.py</tt></a> for a large collection of Gauss-Legendre rules.

<p>

<p>

<p>

<h2>Approximation of functions in 2D <a name="fem:approx:2D"></a></h2>
<p>
<b>All the concepts and algorithms developed for approximation of 1D functions
\( f(x) \) can readily be extended to 2D functions \( f(x,y) \) and 3D functions
\( f(x,y,z) \).</b> Key formulas stay the same.

<p>
Inner product in 2D:

<p>
$$
\begin{equation}
(f,g) = \int_\Omega f(x,y)g(x,y) dx dy
\end{equation}
$$

<p>

<h4>Constructing 2D basis functions from 1D functions  <a name="___sec55"></a></h4>
<p>
Given 1D basis functions

<p>
$$ \{ \hat\basphi_0(x),\ldots,\hat\basphi_{N_x}(x)\},
$$
we can combine these two form 2D basis functions:
\( \hat\basphi_p(x)\hat\basphi_q(y) \) (tensor-product definition).

<p>
Either double index \( (p,q) \),

<p>
$$ u = \sum_{p=0}^{N_y}\sum_{q=0}^{N_x} c_{p,q}\basphi_{p,q}(x,y),
\quad \basphi_{p,q}(x,y) = \hat\basphi_p(x)\hat\basphi_q(y),
$$
or we may transform the double index \( (p,q) \) to a single index \( i \),
using \( i=pN_y + q \) or \( i=qN_x + p \).

<p>
Simple example:

<p>
$$ \{ 1, x \} $$

<p>
$$ \basphi_{0,0}=1,\quad \basphi_{1,0}=x, \quad \basphi_{0,1}=y,
\quad \basphi_{1,1}=xy,
$$
or with a single index:

<p>
$$ \basphi_0=1,\quad \basphi_1=x, \quad \basphi_2=y,\quad\basphi_3 =xy
\thinspace .
$$

<p>
See notes for details of a hand-calculation.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 27:  Approximation of a 2D quadratic function (left) by a 2D bilinear function (right) using the Galerkin or least squares method. <a name="fem:approx:fe:2D:fig:ubilinear"></a> </p></center>
<p><img src="fig-fem/approx2D_bilinear.png" align="bottom" width=800></p>
</center>

<p>

<p>

<h2>Finite elements in 2D and 3D  <a name="___sec56"></a></h2>
<p>
The two great advantages of the finite element method:

<p>

<ul>
  <p><li> Can handle complex-shaped domains in 2D and 3D
  <p><li> Can easily provide higher-order polynomials in the approximation
</ul>

Typical cell types: triangles and quadrilaterals in 2D,
tetrahetra and hexahedra in 3D.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 28:  Examples on 2D P1 elements. <a name="fem:approx:fe:2D:fig:rectP1"></a> </p></center>
<p><img src="fig-fem/mesh2D_rect_P1.png" align="bottom" width=800></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 29:  Examples on 2D P1 elements in a deformed geometry. <a name="fem:approx:fe:2D:fig:circP1"></a> </p></center>
<p><img src="fig-fem/mesh2D_quarter_circle.png" align="bottom" width=400></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 30:  Examples on 2D Q1 elements. <a name="fem:approx:fe:2D:fig:rectQ1"></a> </p></center>
<p><img src="fig-fem/mesh2D_rect_Q1.png" align="bottom" width=400></p>
</center>

<p>

<p>

<h3>Basis functions over triangles in the physical domain  <a name="___sec57"></a></h3>
<p>
The P1 triangular 2D element: \( u \) is linear \( ax + by + c \) over each
triangular cell.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 31:  Example on piecewise linear 2D functions defined on triangles. <a name="fem:approx:fe:2D:fig:femfunc"></a> </p></center>
<p><img src="fig-fem/demo2D_4x3r.png" align="bottom" width=400></p>
</center>

<p>

<p>

<ul>
 <p><li> Cells: triangles
 <p><li> Vertices: corners of the cells
 <p><li> Nodes = vertices
 <p><li> Degrees of freedom: function values at the nodes
 <p><li> Linear mapping of reference element onto general triangular cell
 <p><li> \( \basphi_i \): pyramid shape, composed of planes.
 <p><li> \( \basphi_i=1 \) at vertex (node) \( i \), 0 at all other vertices (nodes).
</ul>

<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 32:  Example on a piecewise linear 2D basis function over a patch of triangles. <a name="fem:approx:fe:2D:fig:basphi"></a> </p></center>
<p><img src="fig-fem/demo2D_basisfunc.png" align="bottom" width=400></p>
</center>

<p>

<p>

<h4>Element matrices and vectors  <a name="___sec58"></a></h4>
<p>
\( \basphi_i\basphi_j\neq 0 \) only if \( i \) and \( j \) are degrees of freedom
(vertices/nodes) in the same element. Element matrix: \( 3\times 3 \).

<p>

<h3>Basis functions over triangles in the reference cell  <a name="___sec59"></a></h3>
<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 33:  2D P1 element. <a name="fem:approx:fe:2D:fig:P12D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P1_2d.png" align="bottom" width=100></p>
</center>

<p>

<p>
$$
\begin{align}
\refphi_0(X,Y) &= 1 - X - Y,\\
\refphi_1(X,Y) &= X,\\
\refphi_2(X,Y) &= Y
\end{align}
$$

<p>
Higher-order elements introduce more nodes. Degrees of freedom are the
function values at the nodes.

<p>
Higher-order means higher-degree polynomials.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 34:  2D P2 element. <a name="fem:approx:fe:2D:fig:P22D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P2_2d.png" align="bottom" width=100></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 35:  2D P1, P2, P3, P4, P5, and P6 elements. <a name="fem:approx:fe:2D:fig:P162D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P1-6_2d.png" align="bottom" width=400></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 36:  P1 elements in 1D, 2D, and 3D. <a name="fem:approx:fe:2D:fig:P1:123D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P1-1d2d3d.png" align="bottom" width=400></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 37:  P2 elements in 1D, 2D, and 3D. <a name="fem:approx:fe:2D:fig:P2:123D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P2-1d2d3d.png" align="bottom" width=400></p>
</center>

<p>

<p>

<p>

<ul>
 <p><li> Interval, triangle, tetrahedron: <em>simplex</em> element
 <p><li> Plural quick-form: <em>simplices</em>
 <p><li> Side of the cell is called <em>face</em>
 <p><li> Thetrahedron has also <em>edges</em>
</ul>

<h3>Affine mapping of the reference cell  <a name="___sec60"></a></h3>
<p>
Mapping of local \( (X,Y) \) coordinates in the reference cell to
global, physical \( (x,y) \) coordinates:

<p>
$$
\begin{equation}
\x = \sum_{r} \refphi_r^{(1)}(\X)\xdno{q(e,r)},
\label{fem:approx:fe:affine:map}
\end{equation}
$$
where

<p>

<ul>
  <p><li> \( r \) runs over the local vertex numbers in the cell
  <p><li> \( \xdno{i} \) are the \( (x,y) \) coordinates of vertex \( i \)
  <p><li> \( \refphi_r^{(1)} \) are P1 basis functions
</ul>

This mapping preserves the straight/planar faces and edges.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 38:  Affine mapping of a P1 element. <a name="fem:approx:fe:map:fig:2DP1"></a> </p></center>
<p><img src="fig-fem/ElmT3n2D_map.png" align="bottom" width=400></p>
</center>

<p>

<p>

<h3>Isoparametric mapping of the reference cell  <a name="___sec61"></a></h3>
<p>

<p>
Idea: Use the basis functions of the element to map the element

<p>
$$
\begin{equation}
\x = \sum_{r} \refphi_r(\X)\xdno{q(e,r)},
\label{fem:approx:fe:isop:map}
\end{equation}
$$
Advantage: higher-order polynomial basis functions now maps the
reference cell to a <em>curved</em> triangle or tetrahedron.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 39:  Isoparametric mapping of a P2 element. <a name="fem:approx:fe:map:fig:2DP2"></a> </p></center>
<p><img src="fig-fem/ElmT6n2D_map.png" align="bottom" width=400></p>
</center>

<p>

<p>

<h3>Computing integrals  <a name="___sec62"></a></h3>
<p>

<p>

<p>

<p>

<h3>Differential equation models <a name="fem:deq:1D:models"></a></h3>
<p>
Abstract differential equation:
$$
\begin{equation}
{\cal L}(u) = 0,\quad x\in\Omega\thinspace . \end{equation}
$$

<p>
Examples:

<p>
$$
\begin{align}
{\cal L}(u) &= \frac{d^2u}{dx^2} - f(x),
\label{fem:deq:1D:L1}\\
{\cal L}(u) &= \frac{d}{dx}\left(a(x)\frac{du}{dx}\right) + f(x),
\label{fem:deq:1D:L2}\\
{\cal L}(u) &= \frac{d}{dx}\left(a(u)\frac{du}{dx}\right) - \alpha u + f(x),
\label{fem:deq:1D:L3}\\
{\cal L}(u) &= \frac{d}{dx}\left(a(u)\frac{du}{dx}\right) + f(u,x)
\label{fem:deq:1D:L4}
\thinspace .
\end{align}
$$

<p>
$$
\begin{equation}
{\cal B}_0(u)=0,\ x=0,\quad {\cal B}_1(u)=0,\ x=L
\end{equation}
$$

<p>
There are three common choices of boundary conditions:
$$
\begin{align}
{\cal B}_i(u) &= u - g,\quad \hbox{(Dirichlet condition)},\\
{\cal B}_i(u) &= -a \frac{du}{dx} - g,\quad \hbox{(Neumann condition)},\\
{\cal B}_i(u) &= -a \frac{du}{dx} - a(u-g),\quad \hbox{(Robin condition)}
\thinspace .
\end{align}
$$

<p>
From now on we shall use \( \uex(x) \) as symbol for the <em>exact</em> solution,
fulfilling

<p>
$$
\begin{equation}
{\cal L}(\uex)=0,\quad x\in\Omega,
\end{equation}
$$
while \( u(x) \) denotes an <em>approximate</em> solution of the differential
equation.

<p>

<h3>Residual-minimizing principles <a name="fem:deq:1D:residual:min"></a></h3>
<p>
The fundamental idea is to seek an approximate solution
\( u \) in some space \( V \) with basis

<p>
$$
\begin{equation*} \{ \basphi_0(x),\ldots,\basphi_N(x)\},\end{equation*}
$$
which means that \( u \) can always be expressed as

<p>
$$
\begin{equation*} u(x) = \sum_{j=0}^N c_j\basphi_j(x),\end{equation*}
$$
for some unknown coefficients \( c_0,\ldots,c_N \).

<p>
Inserting this \( u \) in the equation gives a nonzero <em>residual</em> \( R \):

<p>
$$
\begin{equation}
R = {\cal L}(u) = {\cal L}(\sum_j c_j \basphi_j),
\end{equation}
$$

<p>

<ul>
 <p><li> \( R \) measures how well \( u \) fulfills the differential equation, but says
   nothing about the <em>error</em> \( \uex - u \)
 <p><li> We cannot know \( \uex - u \)
 <p><li> Therefore, we aim to minimize \( R \)
 <p><li> Find \( c_0,\ldots,c_N \) such that \( R(x; c_0,\ldots,c_N) \) is small
</ul>

<h4>The least squares method  <a name="___sec65"></a></h4>
<p>
Idea: minimize

<p>
$$
\begin{equation}
\int_{\Omega} R^2 dx
\end{equation}
$$

<p>
With the inner product

<p>
$$
\begin{equation}
(f,g) = \int_{\Omega} f(x)g(x) dx,
\end{equation}
$$

<p>
the least-squares method can be defined as

<p>
$$
\begin{equation}
\min_{c_0,\ldots,c_N} E = (R,R)\thinspace . \end{equation}
$$
Differentiating with respect to the free parameters \( c_0,\ldots,c_N \)
gives the \( N+1 \) equations

<p>
$$
\begin{equation}
\int_{\Omega} 2R\frac{\partial R}{\partial c_i} dx = 0\quad
\Leftrightarrow\quad (R,\frac{\partial R}{\partial c_i})=0,\quad
i=0,\ldots,N\thinspace .
\label{fem:deq:1D:LS:eq1}
\end{equation}
$$

<p>

<h4>The Galerkin method  <a name="___sec66"></a></h4>
<p>
Idea: make \( R \) orthogonal to \( V \),

<p>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in V\thinspace .
\label{fem:deq:1D:Galerkin0}
\end{equation}
$$

<p>
Equivalent statement:

<p>
$$
\begin{equation}
(R,\basphi_i)=0,\quad i=0,\ldots,N,
\label{fem:deq:1D:Galerkin}
\end{equation}
$$
This statement generates \( N+1 \) equations for \( c_0,\ldots,c_N \).

<p>

<h4>The Method of Weighted Residuals  <a name="___sec67"></a></h4>
<p>
Generalization of the Galerkin method: demand \( R \)
orthogonal to some space \( W \), possibly \( W\neq V \):

<p>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in W\thinspace .
\label{fem:deq:1D:WRM0}
\end{equation}
$$
If \( \{w_0,\ldots,w_N\} \) is a basis for \( W \), we can equivalently
express the method of weighted residuals as

<p>
$$
\begin{equation}
(R,w_i)=0,\quad i=0,\ldots,N\thinspace .
\label{fem:deq:1D:WRM}
\end{equation}
$$
This gives \( N+1 \) equations for \( c_0,\ldots,c_N \).

<p>
Note: The least-squares method can also be viewed as a weighted residual
method with \( w_i = \partial R/\partial c_i \).

<p>

<p>

<h4>Test and Trial Functions  <a name="___sec68"></a></h4>
<p>

<ul>
 <p><li> \( \basphi_j \) used in \( \sum_jc_j\basphi_j \): <em>trial function</em>
 <p><li> \( \basphi_i \) or \( w_i \) used as weight in Galerkin's method: <em>test function</em>
</ul>

<h4>The collocation method  <a name="___sec69"></a></h4>
<p>
Idea: demand \( R=0 \) at \( N+1 \) points.

<p>
$$
\begin{equation}
R(\xno{i}; c_0,\ldots,c_N)=0,\quad i=0,\ldots,N\thinspace .
\label{fem:deq:1D:collocation}
\end{equation}
$$

<p>
Note: The collocation method is a weighted residual method with
delta functions as weights.

<p>
$$
\begin{equation}
\int_{\Omega} f(x)\delta (x-\xno{i}) dx = f(\xno{i}),\quad \xno{i}\in\Omega\thinspace .
\label{fem:deq:1D:Dirac}
\end{equation}
$$

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 40:  Approximation of delta functions by narrow Gaussian functions. <a name="fem:deq:1D:fig:Dirac"></a> </p></center>
<p><img src="fig-fem/delta_func_weight.png" align="bottom" width=400></p>
</center>

<p>

<p>

<h3>Examples on using the principles <a name="fem:deq:1D:ex:sines"></a></h3>
<p>

<h4>The model problem  <a name="___sec71"></a></h4>
<p>
$$
\begin{equation}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=0
\thinspace .
\label{fem:deq:1D:model1}
\end{equation}
$$

<p>

<h4>Basis functions  <a name="___sec72"></a></h4>
<p>
$$
\begin{equation}
\basphi_i(x) = \sinL{i},\quad i=0,\ldots,N\thinspace .
\label{fem:deq:1D:ex:sines:phi}
\end{equation}
$$

<p>
Note: \( \basphi_i(0)=\basphi_i(L)=0 \), which ensures that \( u \)
fulfills the boundary conditions:

<p>
$$ u(0) = \sum_jc_j\basphi_j(0) = 0,\quad u(L) = \sum_jc_j\basphi_j(L)
\thinspace .$$

<p>
Another useful property is the orthogonality on \( \Omega \):

<p>
$$
\begin{equation}
\int\limits_0^L \sinL{i}\sinL{j}\, dx = \left\lbrace
\begin{array}{ll} \half L & i=j  \\ 0, & i\neq j
\end{array}\right.
\end{equation}
$$

<p>
That is, the coefficient matrix becomes diagonal (\( \basphi_i\basphi_j=0 \)).

<p>

<p>

<h4>The residual  <a name="___sec73"></a></h4>
<p>
$$
\begin{align}
R(x;c_0,\ldots,c_N) &= u''(x) + f(x),\nonumber\\
&= \frac{d^2}{dx^2}\left(\sum_{j=0}^N c_j\basphi_j(x)\right)
+ f(x),\nonumber\\
&= -\sum_{j=0}^N c_j\basphi_j''(x) + f(x)\thinspace .
\label{fem:deq:1D:ex:sines:res}
\end{align}
$$

<p>

<h4>The least squares method  <a name="___sec74"></a></h4>
<p>
$$
(R,\frac{\partial R}{\partial c_i}) = 0,\quad i=0,\ldots,N\thinspace .
$$

<p>
We need an expression for
\( \partial R/\partial c_i \):

<p>
$$
\begin{equation}
\frac{\partial R}{\partial c_i} =
\frac{\partial}{\partial c_i}
\left(\sum_{j=0}^N c_j\basphi_j''(x) + f(x)\right)
= \basphi_i''(x)\thinspace . \end{equation}
$$
Because:
$$
\frac{\partial}{\partial c_i}\left(c_0\basphi_0'' + c_1\basphi_1'' + \cdots +
c_{i-1}\basphi_{i-1}'' + c_i\basphi_{i}'' + c_{i+1}\basphi_{i+1}''
+ \cdots + c_N\basphi_N'' \right) = \basphi_{i}''
$$

<p>
The governing equations for \( c_0,\ldots,c_N \) are then

<p>
$$
\begin{equation}
(\sum_j c_j \basphi_j'' + f,\basphi_i'')=0,\quad i=0,\ldots,N,
\end{equation}
$$
which can be rearranged as

<p>
$$
\begin{equation}
\sum_{j=0}^N(\basphi_i'',\basphi_j'')c_j = -(f,\basphi_i''),\quad i=0,\ldots,N\thinspace . \end{equation}
$$
This is nothing but a linear system

<p>
$$
\begin{equation*} \sum_{j=0}^NA_{i,j}c_j = b_i,\quad i=0,\ldots,N,
\end{equation*}
$$
with

<p>
$$
\begin{align}
A_{i,j} &= (\basphi_i'',\basphi_j'')\nonumber\\
& = \pi^4(i+1)^2(j+1)^2L^{-4}\int_0^L \sinL{i}\sinL{j}\, dx\nonumber\\
&= \left\lbrace
\begin{array}{ll} {1\over2}L^{-3}\pi^4(i+1)^4 & i=j  \\ 0, & i\neq j
\end{array}\right.
\\
b_i &= -(f,\basphi_i'') = (i+1)^2\pi^2L^{-2}\int_0^Lf(x)\sinL{i}\, dx
\end{align}
$$
Since the coefficient matrix is diagonal we can easily solve for

<p>
$$
\begin{equation}
c_i = \frac{2L}{\pi^2(i+1)^2}\int_0^Lf(x)\sinL{i}\, dx\thinspace .
\label{fem:deq:1D:ex:sines:solution}
\end{equation}
$$
With the special choice of \( f(x)=2 \) the integral becomes

<p>
$$
\begin{equation*} \frac{L\cos(\pi i) + L}{\pi (i+1)},\end{equation*}
$$

<p>
The solution becomes:

<p>
$$
\begin{equation}
u(x) = \sum_{k=0}^{N/2} \frac{8L^2}{\pi^3(2k+1)^3}\sinL{2k}\thinspace . \end{equation}
$$

<p>
The coefficients decay very fast: \( c_2 = c_0/27 \), \( c_4=c_0/125 \).
The first term therefore suffices:

<p>
$$
\begin{equation*} u(x) \approx \frac{8L^2}{\pi^3}\sin\left(\pi\frac{x}{L}\right)\thinspace . \end{equation*}
$$

<p>

<p>

<p>

<h4>The Galerkin method  <a name="___sec75"></a></h4>
<p>
$$
\begin{equation*}
(u''+f,v)=0,\quad \forall v\in V,
\end{equation*}
$$
or

<p>
$$
\begin{equation}
(u'',v) = -(f,v),\quad\forall v\in V\thinspace . \end{equation}
$$

<p>
This is called a <em>variational formulation</em>.

<p>
\( \forall v\in V \) means for all basis functions:

<p>
$$
\begin{equation}
(\sum_{j=0}^N c_j\basphi_j'', \basphi_i)=-(f,\basphi_i),\quad i=0,\ldots,N\thinspace . \end{equation}
$$

<p>
For the particular choice of the sine basis functions, we
get in fact the same linear system
as in the least squares method
(because \( \basphi''= -(i+1)^2\pi^2L^{-2}\basphi \)).

<p>

<h4>The collocation method  <a name="___sec76"></a></h4>
<p>
Residual must vanish at selected points, or equivalently, the
differential equation with approximation \( u \) inserted, must be
fulfilled at selected points:

<p>
$$
\begin{equation}
-\sum_{j=0}^N c_j\basphi_j''(\xno{i}) = f(\xno{i}),\quad i=0,\ldots,N
\thinspace .
\end{equation}
$$
This is a linear system with entries

<p>
$$
\begin{equation*} A_{i,j}=-\basphi_j''(\xno{i})=
(j+1)^2\pi^2L^{-2}\sin\left((j+1)\pi \frac{x_i}{L}\right),\end{equation*}
$$
and \( b_i=2 \).

<p>
Special case: \( N=0 \), \( x_0=L/2 \)
$$ c_0=2L^2/\pi^2 $$

<p>

<p>

<h4>Comparison  <a name="___sec77"></a></h4>
<p>

<ul>
 <p><li> Exact solution: \( u(x)=x(L-x) \)
 <p><li> Galerkin or least squares (\( N=0 \)): \( u(x)=8L^2\pi^{-3}\sin (\pi x/L) \)
 <p><li> Collocation method (\( N=0 \)): \( u(x)=2L^2\pi^{-2}\sin (\pi x/L) \).
 <p><li> Max error in Galerkin/least sq.: \( -0.008L^2 \)
 <p><li> Max error in collocation: \( 0.047L^2 \)
</ul>

<h3>Integration by parts <a name="fem:deq:1D:varform"></a></h3>
<p>

<p>

<ul>
 <p><li> Let's use finite elements!
 <p><li> Problem: \( \basphi_i' \) is discontinuous (at cell boundaries)
   and we need \( \basphi_i'' \) in the Galerkin or least squares methods
 <p><li> Remedy: integrate by parts - then we only need \( \basphi_i' \)
</ul>

Given
$$
\begin{equation*} -(u'',v) = (f,v)\quad\forall v\in V\thinspace . \end{equation*}
$$
Integrate by parts:

<p>
$$
\begin{align}
\int_0^L u''(x)v(x) dx &= - \int_0^Lu'(x)v'(x)dx
+ [vu']_0^L\nonumber\\
&= - \int_0^Lu'(x)v'(x) dx
+ u'(L)v(L) - u'(0)v(0)\thinspace .
\label{fem:deq:1D:intbyparts}
\end{align}
$$

<p>
Recall that \( v(0)=v(L)=0 \), i.e.,
\( \basphi_i(0)=\basphi_i(L)=0 \) because we demand so where we have
Dirichlet conditions.

<p>
Advantageous features of integration by parts:

<p>

<ul>
  <p><li> Only first-order derivatives
  <p><li> Symmatric coefficient matrix
  <p><li> Incorporation of \( u' \) boundary conditions (later)
</ul>

<h3>Boundary function  <a name="___sec79"></a></h3>
<a name="fem:deq:1D:essBC:Bfunc"></a>

<p>

<ul>
 <p><li> What about nonzero Dirichlet conditions?
 <p><li> E.g. \( u(L)=D \)
 <p><li> Problem: \( u(L) = \sum_j c_j\basphi_j(L)=0 \) - always
 <p><li> Remedy: \( u(x) = B(x) + \sum_j c_j\basphi_j(x) \)
 <p><li> \( u(0)=B(0) \), \( u(L)=B(L) \)
 <p><li> \( B(x) \) must fulfill the Dirichlet conditions on \( u \)
 <p><li> No restrictions of how \( B(x) \) varies in the interior
</ul>

<h4>Example  <a name="___sec80"></a></h4>
<p>
\( u(0)=0 \) and \( u(L)=D \). Choose

<p>
$$ B(x) = \frac{D}{L}x:\qquad B(0)=0,\ B(L)=D \thinspace .$$

<p>
$$
\begin{equation}
u(x) = \frac{x}{L}D + \sum_{j=0}^N c_j\basphi_j(x),
\label{fem:deq:1D:essBC:Bfunc:u1}
\end{equation}
$$

<p>
$$ u(0) = 0,\quad u(L) = 0\thinspace . $$

<p>

<h3>Abstract notation for variational formulations <a name="fem:deq:1D:varform:abstract"></a></h3>
<p>
The finite element literature (and much FEniCS documentation)
applies an abstract notation for the variational formulation:
*Find \( u-B\in V \) such that
$$ a(u,v) = L(v)\quad \forall v\in V\thinspace .$$

<p>

<h4>Example  <a name="___sec82"></a></h4>
<p>
Given a variational formulation for \( -u''=f \):

<p>
$$ \int_{\Omega} u' v'dx = \int_{\Omega} fvdx\quad\hbox{or}\quad (u',v') = (f,v)
\quad\forall v\in V$$
we identify

<p>
$$ a(u,v) = (u',v'),\quad L(v) = (f,v)\thinspace . $$

<p>
Then we can write
$$ a(u,v) = L(v)\quad \forall v\in V,$$
if

<p>

<h4>Bilinear and linear forms  <a name="___sec83"></a></h4>
<p>
\( a(u,v) \) is a <em>bilinear form</em> and \( L(v) \) is a <em>linear form</em>.

<p>
Linearity:
$$ L(\alpha_1 v_1 + \alpha_2 v_2) =\alpha_1 L(v_1) + \alpha_2 L(v_2)$$
$$
a(\alpha_1 u_1 + \alpha_2 u_2, v) = \alpha_1 u(u_1,v) + \alpha_2 a(u_2, v),
\quad
a(u, \alpha_1 v_1 + \alpha_2 v_2) = \alpha_1 u(u,v_1) + \alpha_2 a(u, v_2)
\thinspace .
$$

<p>
In nonlinear problems the abstract form is \( F(u;v)=0 \) $\forall v\in V$.

<p>
The abstract form \( a(u,v)=L(v) \) is equivalent with a linear system

<p>
$$ \sum_{j=0}^N A_{i,j}c_j=b_i,\quad i=0,\ldots,N$$
with
$$
\begin{align*}
A_{i,j} &= a(\basphi_j,\basphi_i),\\
b_i &= L(\basphi_i) \thinspace .
\end{align*}
$$

<p>

<h3>More examples on variational formulations <a name="fem:deq:1D:varform:ex"></a></h3>
<p>

<h4>Variable coefficient  <a name="___sec85"></a></h4>
<p>
Consider the problem

<p>
$$
\begin{equation}
-\frac{d}{dx}\left( a(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\
u(0)=C,\ u(L)=D\thinspace .
\end{equation}
$$

<p>
Two new features:

<p>

<ul>
 <p><li> a variable coefficient \( a(x) \)
 <p><li> nonzero Dirichlet conditions at \( x=0 \) <em>and</em> \( x=L \)
</ul>

A boundary function handles nonzero Dirichlet conditions:

<p>
$$
u(x) = B(x) + \sum_{j=0}^N c_j\basphi_i(x),\quad \basphi_i(0)=\basphi_i(L)=0
$$

<p>
One possible choice of \( B \) is:

<p>
$$ B(x) = C + \frac{1}{L}(D-C)x
\thinspace .
$$

<p>
The residual:

<p>
$$ R = -\frac{d}{dx}\left( a\frac{du}{dx}\right) -f\thinspace .$$

<p>
Galerkin's method:

<p>
$$
(R, v) = 0,\quad \forall v\in V,
$$

<p>
Written in terms of integrals:

<p>
$$
\int_{\Omega} \left(\frac{d}{dx}\left( a\frac{du}{dx}\right) -f\right)v dx = 0,\quad \forall v\in V \thinspace .
$$

<p>
Integration by parts:

<p>
$$ -\int_{\Omega} \frac{d}{dx}\left( a(x)\frac{du}{dx}\right) vdx
= \int_{\Omega} a(x)\frac{du}{dx}\frac{dv}{dx}dx -
\left[a\frac{du}{dx}v\right]_0^L
\thinspace .
$$
Must have \( v=0 \) where we have Dirichlet conditions: boundary terms vanish.

<p>
The final variational formulation:

<p>
$$
\int_{\Omega} a(x)\frac{du}{dx}\frac{dv}{dx}dx = \int_{\Omega} f(x)vdx,\quad
\forall v\in V,
$$

<p>
Can alternatively express this imore compactly as

<p>
$$
(a u',v') = (f,v),\quad \forall v\in V
\thinspace .
$$

<p>
The abstract notation is

<p>
$$ a(u,v)=L(v)\quad\forall v\in V,$$
with
$$ a(u,v)= (au',v'),\quad L(v)=(f,v) \thinspace . $$
Do not mix the \( a \) in \( a(\cdot,\cdot) \) (notation) and \( a(x) \) (function
name).

<p>

<p>
Can derive linear system by inserting \( u=B + \sum_jc_j\basphi_j \) and
\( v=\basphi_i \):

<p>
$$ \sum_{j=0}^N (a\basphi_j', \basphi_i)c_j  =
(f,\basphi_i) + (CL^{-1},\basphi_i'),
\quad i=0,\ldots,N,
$$
or \( \sum_j A_{i,j}c_j=b_i \) with

<p>
$$
\begin{align*}
A_{i,j} &= (a\basphi_j', \basphi_i) = \int_{\Omega} a(x)\basphi_j'(x),
\basphi_i(x)dx,\\
b_i &= (f,\basphi_i) + (CL^{-1},\basphi_i')=
\int_{\Omega} \left(f(x)\basphi_i(x) + \frac{C}{L}\basphi_i'(x)\right)dx
\thinspace .
\end{align*}
$$

<p>

<h4>First-order derivative in the equation and boundary condition  <a name="___sec86"></a></h4>
<p>
Model:

<p>
$$
\begin{equation}
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\
u(0)=C,\ u'(L)=E\thinspace .
\end{equation}
$$

<p>
New features:

<p>

<ul>
 <p><li> first-order derivative \( u' \) in the equation
 <p><li> boundary condition with \( u' \): \( u'(L)=E \)
</ul>

Initial steps:

<p>

<ul>
 <p><li> Must force \( \basphi_i(0)=0 \) (Dirichlet condition at \( x=0 \))
 <p><li> Boundary function: \( B(x)=C(L-x)/L \)
 <p><li> No requirements on \( \basphi_i(L) \) (no Dirichlet condition at \( x=L \))
</ul>

$$ u = \frac{C}{L}(L-x) + \sum_{j=0}^N c_j \basphi_i(x)
\thinspace .
$$

<p>
Galerkin's method: multiply by \( v \), integrate over \( \Omega \), integrate
by parts.

<p>
$$  (-u'' + bu' - f, v) = 0,\quad\forall v\in V$$

<p>
$$ (u' + bu',v') = (f,v) + [u' v]_0^L, \quad\forall v\in V \thinspace .$$

<p>
$$ (u' + bu',v') = (f,v) + Ev(L), \quad\forall v\in V,$$
because \( [u' v]_0^L = u'(L)v(L) = E v(L) \) because
\( v(0)=0 \) and \( u'(L)=E \).

<p>
Important:

<p>

<ul>
  <p><li> The boundary term can be used to implement Neumann conditions!
  <p><li> Forgetting the boundary term implies the condition \( u'=0 \)!
  <p><li> Such conditions are called <em>natural boundary conditions</em>
</ul>

Abstract notation:

<p>
$$ a(u,v)=L(v)\quad\forall v\in V,$$
with the particular formulas
$$ a(u,v)=(u',v') + (bu',v),\quad L(v)= (f+C,v) + E v(L)\thinspace .$$

<p>
Linear system: insert \( u=B+\sum_jc_j\basphi_j \) and \( v=\basphi_i \),

<p>
$$ \sum_{j=0}^N \underbrace{((\basphi_j',\basphi_i') + (b\basphi_j',\basphi_i))}_{A_{i,j}} c_j = \underbrace{(f,\basphi_i) + (C/L,\basphi_i') + E \basphi_i(L)}_{b_i}
\thinspace .
$$

<p>
Observation: \( A_{i,j} \) is not symmetric because of the term

<p>
$$
(b\basphi_j',\basphi_i)=\int_{\Omega} b\basphi_j'\basphi_i dx
 \neq \int_{\Omega} b \basphi_i' \basphi_jdx = (\basphi_i',b\basphi_j)
\thinspace .
$$

<p>

<h3>Example on handling Dirichlet and Neumann conditions  <a name="___sec87"></a></h3>
<p>
Let us solve

<p>
$$
\begin{equation*} -u''(x)=f(x),\quad x\in \Omega=[0,1],\quad u'(0)=C,\ u(1)=D,\end{equation*}
$$

<p>

<ul>
 <p><li> Use a <em>global</em> polynomial basis \( \basphi_i\sim x^i \) on \( [0,1] \)
 <p><li> Because of \( u(1)=D \): \( \basphi_i(1)=0 \)
 <p><li> Basis: \( \basphi_i(x)=(1-x)^{i+1} \), \( i=0,\ldots,N \)
 <p><li> \( B(x)=Dx/L \)
</ul>

The linear system becomes

<p>
$$
\begin{align*}
A_{i,j} &= (\basphi_j,\basphi_i) = \int_{0}^1 \basphi_i'(x)\basphi_j'(x)dx
= \int_0^1 (i+1)(j+1)(1-x)^{i+j}dx,\\
b_i &= (2,\basphi_i) - (D,\basphi_i') -C\basphi_i(0)
= \int_{0^1\left( 2\basphi_i(x) - D\basphi_i'(x)\right)dx -C\basphi_i(0)
= \int_0^1 \left( 2(1-x)^{i+1} - D(i+1)(1-x)^i\right)dx  -C\basphi_i(0)
\end{align*}
$$

<p>
With \( N=1 \):

<p>
$$
\begin{equation*}
\left(\begin{array}{cc}
1 & 1\\
1 & 4/3
\end{array}\right)
\left(\begin{array}{c}
c_0\\
c_1
\end{array}\right)
=
\left(\begin{array}{c}
-C+D+1\\
2/3 -C + D
\end{array}\right)
\end{equation*}
$$

<p>
$$ c_0=-C+D+2, \quad c_1=-1,$$

<p>
$$ u(x) = 1 -x^2 + D + C(x-1) \thinspace . $$
This is also the exact solution (as expected when \( V \) contains second-degree
polynomials).

<p>
<!-- [[[ corrected so far -->

<p>

<h3>Variational problems and optimization of functionals <a name="fem:deq:1D:optimization"></a></h3>
<p>
If \( a(u,v)=a(v,u) \), it can be shown that the variational statement
\( a(u,v)=L(v) \) $\forall v\in V$ is equivalent to minimizing the functional

<p>
$$ F(v) = \frac{1}{2}a(v,v) - L(v) $$
That is, find \( u \) such that

<p>
$$ F(u)\leq F(v)\quad\forall v\in V\thinspace .$$

<p>
Traditional use of finite elements often starts with \( F(v) \) and
then derives \( a(u,v)=L(v) \).

<p>

<p>

<h4>Nonlinear terms  <a name="___sec89"></a></h4>
<p>
The techniques used to derive variational
forms also apply in nonlinear cases.

<p>
Consider
$$
\begin{equation}
-(a(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
\thinspace .
\end{equation}
$$

<p>
Using the Galerkin principle, we multiply by \( v\in V \) and integrate,

<p>
$$ -\int_0^L \frac{d}{dx}\left(a(u)\frac{du}{dx}\right)vdx =
\int_0^L f(u)vdx\quad\forall v\in V
\thinspace .
$$
Integration by parts is not affected by \( a(u) \):

<p>
$$ \int_0^L a(u)\frac{du}{dx}\frac{dv}{dx}vdx =
\int_0^L f(u)vdx + [vu']_0^L\quad\forall v\in V
\thinspace .
$$
\( v(0)=0 \) since \( u(0) \) is known. \( v(L)u'(L)=v(L)E \).

<p>
$$ (a(u)u', v') = (f(u),v) + vE\quad\forall v\in V
\thinspace .
$$

<p>
Since the problem is nonlinear, we cannot identify \( a(u,v) \) and \( L(v) \).
An abstract notation is typically <em>find \( u \) such that</em>

<p>
$$ F(u;v) = 0\quad\forall v\in V,$$
with
$$ F(u;v) = (a(u)u', v') - (f(u),v) - vE
\thinspace .
$$

<p>
By inserting \( u=\sum_j c_j\basphi_j \) we get a <em>nonlinear system of
algebraic equations</em> for the unknowns \( c_0,\ldots,c_N \). Such systems must
be solved by constructing a sequence of linear systems whose solutions
converge to the solution of the nonlinear system. Frequently applied
methods are Picard iteration and Newton's method.

<p>

<h2>Computing with finite elements <a name="fem:deq:1D:fem1"></a></h2>
<p>
The purpose of this section is to demonstrate in detail how
the finite method can the be applied to the model problem

<p>
$$ -u''(x) = 2,\quad x\in (0,L),\ u(0)=u(L)=0,$$
with variational formulation

<p>
$$ (u',v') = (2,v)\quad\forall v\in V\thinspace . $$

<p>
Exclude \( c_0 \) and \( c_N \) from the unknowns since we know \( c_0=c_N=0 \):

<p>
Since \( u \) is known to be zero
at the end points of the interval, we can utilize a sum over
the basis functions associated with internal nodes only:

<p>
$$
\begin{equation*}
u(x) = \sum_{j=1}^{N-1}c_j\basphi_j(x)\thinspace .
\end{equation*}
$$

<p>

<ul>
 <p><li> Uniformly spaced nodes
 <p><li> P1 elements
</ul>

<h3>Computation in the global physical domain  <a name="___sec91"></a></h3>
<p>
We are to compute

<p>
$$
\begin{equation*}
A_{i,j}=\int_0^L\basphi_i'(x)\basphi_j'(x) dx,\quad
b_i=\int_0^L2\basphi_i(x) dx
\thinspace . \end{equation*}
$$

<p>
Need \( \basphi_i'(x) \) in the formulas:

<p>
$$
\begin{equation}
\basphi_i'(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\
h^{-1},
& \xno{i-1} \leq x < \xno{i},\\
-h^{-1},
& \xno{i} \leq x < \xno{i+1},\\
0, & x\geq \xno{i+1}
\end{array}
\right.
\label{fem:approx:fe:Dphi:1:formula2}
\end{equation}
$$

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 41:  Illustration of the derivative of piecewise linear basis functions associated with nodes in cell 1.  <a name="fem:approx:fe:fig:dP1"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_dbasis_p1_4e_lab.png" align="bottom" width=600></p>
</center>

<p>

<p>
We realize that \( \basphi_i' \) and \( \basphi_j' \) has no overlap, and hence their
product vanishes, unless \( i \) and \( j \) are nodes belonging to the same
element. The only nonzero contributions to the coefficient matrix are
therefore

<p>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
2 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 2
\end{array}
\right)
\left(
\begin{array}{c}
c_1 \\
\vdots\\
\vdots\\
\vdots \\
\vdots \\
\vdots \\
\vdots \\
\vdots\\
c_{N-1}
\end{array}
\right)
=
\left(
\begin{array}{c}
2h \\
\vdots\\
\vdots\\
\vdots \\
\vdots \\
\vdots \\
\vdots \\
\vdots\\
2h
\end{array}
\right)
\label{fem:deq:1D:ex1:Ab:glob}
\end{equation}
$$

<p>
$c_j=u(\xno{j}) so we introduce \( c_j=u_j \) to easily compare with
the finite difference method. The equation corresponding to row \( i \):

<p>
$$
\begin{equation}
-\frac{1}{h}u_{i-1} + \frac{2}{h}u_{i} - \frac{1}{h}u_{i+1} = 2h\thinspace .
\label{fem:deq:1D:fem:ex1}
\end{equation}
$$

<p>
Standard finite difference approximation of \( -u''(x)=2 \), with
\( u''(x_i)\approx [D_x D_x u]_i \) and \( \Delta x = h \),
yields

<p>
$$
\begin{equation}
-\frac{u_{i-1} + 2u_{i} - u_{i+1}}{h^2} = 2,
\end{equation}
$$

<p>

<ul>
 <p><li> The finite element and the finite difference method give the
   same equation (in this example)
</ul>

<h3>Elementwise computations  <a name="___sec92"></a></h3>
<p>
We follow the same elementwise set-up as for approximating \( f \) by \( u \).

<p>
Present element matrix:

<p>
$$
\begin{equation*}
A_{i,j}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) dx
= \int_{-1}^1 \frac{d}{dx}\refphi_r(X)\frac{d}{dx}\refphi_s(X)
\frac{h}{2} dX,\quad i=q(e,r),\ j=q(e,s),\ r,s=1,2
\thinspace .
\end{equation*}
$$

<p>
\( \refphi_r(X) \) are known as functions of \( X \), but
we need \( d\refphi_r(X)/dx \)!

<p>
Given

<p>
$$
\begin{equation*} \refphi_0(X)=\half(1-X),\quad\refphi_1(X)=\half(1+X),\end{equation*}
$$
we can easily compute \( d\refphi_r/ dX \):

<p>
$$
\begin{equation*}\frac{d\refphi_0}{dX} = -\half,\quad  \frac{d\refphi_1}{dX} = \half\thinspace . \end{equation*}
$$
From the chain rule,

<p>
$$
\begin{equation}
\frac{d\refphi_r}{dx} = \frac{d\refphi_r}{dX}\frac{dX}{dx}
= \frac{2}{h}\frac{d\refphi_r}{dX}\thinspace . \end{equation}
$$
The transformed integral is then:

<p>
$$
\begin{equation*}
A_{i,j}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) dx
= \int_{-1}^1 \frac{2}{h}\frac{d\refphi_r}{dX}\frac{2}{h}\frac{d\refphi_s}{dX}
\frac{h}{2} dX
\thinspace .
\end{equation*}
$$

<p>

<p>

<p>
The right-hand side is transformed according to

<p>
$$
\begin{equation*} b_i^{(e)} = \int_{\Omega^{(e)}} 2\basphi_i(x) dx =
\int_{-1}^12\refphi_r(X)\frac{h}{2} dX,\quad i=q(e,r),\ r=1,2
\thinspace .
\end{equation*}
$$

<p>
We have to compute the matrix entries one by one...

<p>
$$
\begin{align*}
\tilde A_{0,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\frac{1}{2}\right)
\frac{2}{h}\left(-\frac{1}{2}\right)\frac{2}{h} dX = \frac{1}{h}\\
\tilde A_{0,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\frac{1}{2}\right)
\frac{2}{h}\left(\frac{1}{2}\right)\frac{2}{h} dX = -\frac{1}{h}\\
\tilde A_{1,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\frac{1}{2}\right)
\frac{2}{h}\left(-\frac{1}{2}\right)\frac{2}{h} dX = -\frac{1}{h}\\
\tilde A_{1,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\frac{1}{2}\right)
\frac{2}{h}\left(\frac{1}{2}\right)\frac{2}{h} dX = \frac{1}{h}
\end{align*}
$$
The element vector entries become
$$
\begin{align*}
\tilde b_0^{(e)} &= \int_{-1}^12\half(1-X)\frac{h}{2} dX = h\\
\tilde b_1^{(e)} &= \int_{-1}^12\half(1+X)\frac{h}{2} dX = h\thinspace .
\end{align*}
$$

<p>
In matrix/vector notation:

<p>
$$
\begin{equation}
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{cc}
1 & -1\\
-1 & 1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1\\
1
\end{array}\right)\thinspace .
\label{fem:deq:1D:ex1:Ab:elm}
\end{equation}
$$

<p>
Must assemble - but first see how to incorporate boundary conditions.

<p>

<h2>Boundary conditions: specified value <a name="fem:deq:1D:essBC"></a></h2>
<p>

<h3>General construction of a boundary function <a name="fem:deq:1D:essBC:Bfunc"></a></h3>
<p>

<ul>
  <p><li> \( B(x) \) is not always easy to construct (extend to the interior of \( \Omega \)),
    at least not in 2D and 3D
  <p><li> With finite element \( \basphi_i \), \( B(x) \) can be constructed in
    a completely general way
</ul>

$$
\begin{equation}
B(x) = U_0\basphi_0(x) + U_N\basphi_N(x)\thinspace . \end{equation}
$$

<p>
Unknowns: \( c_1,\ldots,c_{N-1} \),

<p>
$$
\begin{equation}
u(x) = U_0\basphi_0(x) + U_N\basphi_N(x) + \sum_{j=1}^{N-1} c_j\basphi_j(x)\thinspace . \end{equation}
$$

<p>

<h4>Example  <a name="___sec95"></a></h4>
<p>
$$ -u''=2, \quad u(0)=0$,\ u(L)=D\thinspace . $$

<p>
The expansion for \( u(x) \) reads

<p>
$$
u(x) = 0\cdot\basphi_0(x) + D\basphi_N(x) +
\sum_{j=1}^{N-1} c_j\basphi_j(x)
\thinspace .
$$
Inserting this expression in \( -(u'',\basphi_i)=(f,\basphi_i) \) and
integrating by parts results in a linear system with

<p>
$$
A_{i,j} = \int_0^L \basphi_i'(x)\basphi_j'(x) dx,\quad
b_i = \int_0^L (f(x) - D\basphi_N'(x))\basphi_i(x) dx,
$$
for \( i,j = 1,\ldots,N-1 \).

<p>

<h3>Modification of the linear system <a name="fem:deq:1D:essBC:Bfunc:modsys"></a></h3>
<p>

<ul>
 <p><li> \( B(x) \) and a reduced set of unknowns (e.g., \( c_1,\ldots,c_{N-1} \))
   are not so convenient in implementations
 <p><li> We shall look at a less strict mathematical procedure that
   gives simpler impelementation
 <p><li> Step 1: compute everything as there were no Dirichlet conditions
 <p><li> Step 2: modify the linear system such that known \( c_j \) get
   their right boundary values
</ul>

Linear system from \( -u''=f \) without taking Dirichlet conditions into
account (\( u=\sum_{j=0}^Nc_j\basphi_j \)):

<p>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\
\vdots\\
\vdots\\
\vdots \\
\vdots \\
\vdots \\
\vdots \\
\vdots\\
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
h \\
2h\\
\vdots\\
\vdots \\
\vdots \\
\vdots \\
\vdots \\
2h\vdots\\
h
\end{array}
\right)
\label{fem:deq:1D:ex1:Ab:glob2}
\end{equation}
$$

<p>
Actions:

<p>

<ul>
 <p><li> General: replace row \( i \) by \( c_i=K \) if \( u(\xno^{i})=K \) is a prescribed
   Dirichlet condition
 <p><li> Here: replace the first and last row by \( c_0=0 \) and \( c_N=D \)
</ul>

$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\
\vdots\\
\vdots\\
\vdots \\
\vdots \\
\vdots \\
\vdots \\
\vdots\\
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\
2h\\
\vdots\\
\vdots \\
\vdots \\
\vdots \\
\vdots \\
2h\\
D
\end{array}
\right)
\label{fem:deq:1D:ex1:Ab:glob3}
\end{equation}
$$

<p>

<h3>Symmetric modification of the linear system  <a name="___sec97"></a></h3>
<p>

<ul>
 <p><li> The modification above destroys symmetry of the matrix
 <p><li> Symmetry is often important in 2D and 3D (faster computations)
 <p><li> A more complex modification preserves symmetry
</ul>

Algorithm for incorporating \( c_i=K \):

<p>

<ol>
<p><li> Subtract column \( i \) times \( K \) from the right-hand side
<p><li> Zero out column and row no \( i \)
<p><li> Place 1 on the diagonal
<p><li> Set \( b_i=K \)
</ol>

$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\
0 & 2 & -1 & \ddots &   & &  & &  \vdots \\
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\
\vdots & & & &  &\ddots  & \ddots &\ddots  & 0 \\
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\
\vdots\\
\vdots\\
\vdots \\
\vdots \\
\vdots \\
\vdots \\
\vdots\\
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\
2h\\
\vdots\\
\vdots \\
\vdots \\
\vdots \\
\vdots \\
2h +D/h\\
D
\end{array}
\right)
\label{fem:deq:1D:ex1:Ab:glob3:symm}
\end{equation}
$$

<p>

<h3>Modification of the element matrix and vector  <a name="___sec98"></a></h3>
<p>

<ul>
 <p><li> Modification of the linear system can be done in the
   the element matrix and vector instead
 <p><li> Exactly the same procedure
</ul>

Last degree of freedom in the last element is prescribed:

<p>
$$
\begin{equation}
\tilde A^{(N-1)} =
A = \frac{1}{h}\left(\begin{array}{cc}
1 & -1\\
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h\\
D
\end{array}\right)\thinspace .
\label{fem:deq:1D:ex1:Ab:elm:bc:N}
\end{equation}
$$

<p>
Or symmetric modification:

<p>
$$
\begin{equation}
\tilde A^{(N-1)} =
A = \frac{1}{h}\left(\begin{array}{cc}
1 & 0\\
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h + D/h\\
D
\end{array}\right)\thinspace .
\label{fem:deq:1D:ex1:Ab:elm:bc:N:symm}
\end{equation}
$$

<p>

<h2>Boundary conditions: specified derivative <a name="fem:deq:1D:BC:nat"></a></h2>
<p>
Current focus: how to incorporate \( u'(0)=C \) with finite elements.

<p>

<h3>The variational formulation  <a name="___sec100"></a></h3>
<p>
Start with the Galerkin method:

<p>
$$
\begin{equation*} \int_0^L(u''(x)+f(x))\basphi_i(x) dx = 0,\quad i=0,\ldots,N,\end{equation*}
$$

<p>
Integration of \( u''\basphi_i \) by parts:

<p>
$$
\begin{equation*} \int_0^Lu'(x)'\basphi_i'(x) dx -(u'(L)\basphi_i(L) - u'(0)\basphi_i(0)) =
\int_0^L f(x)\basphi_i(x) dx
\thinspace .
\end{equation*}
$$

<p>

<ul>
 <p><li> Since \( \basphi_i(L)=0 \), \( u'(L)\basphi_i(L)=0 \)
 <p><li> \( u'(0)\basphi_i(0) = C\basphi_i(0) \) since \( u'(0)=C \)
</ul>

$$
\begin{equation*} \int_0^Lu'(x)\basphi_i'(x) dx + E\basphi_i(0) =
\int_0^L f(x)\basphi_i(x) dx,\quad i=0,\ldots,N\thinspace . \end{equation*}
$$
Inserting

<p>
$$
\begin{equation*} u(x) = B(x) + \sum_{j=0}^{N-1} c_j\basphi_j(x),
\quad B(x) = D\basphi_N(x),
\end{equation*}
$$
<!-- \frac{x}{L}D -->
leads to the linear system

<p>
$$
\begin{equation}
\sum_{j=0}^{N-1}\left(
\int_0^L \basphi_i'(x)\basphi_j'(x) dx \right)c_j =
\int_0^L\left(f(x)\basphi_i(x) -D\basphi_N'(x)\basphi_i(x)\right) dx
 - E\basphi_i(0),
\label{fem:deq:1D:natBC}
\end{equation}
$$
for \( i=0,\ldots,N-1 \).

<p>
Alternatively, we may just work with

<p>
$$
\begin{equation*} u(x) = \sum_{j=0}^{N} c_j\basphi_j(x),
\end{equation*}
$$
and modify the last equation to \( c_N=D \) in the linear system.

<p>
The extra term with \( E \) affects only the element vector from the
first element:

<p>
$$
\begin{equation}
\tilde A^{(0)} =
A = \frac{1}{h}\left(\begin{array}{cc}
1 & 1\\
-1 & 1
\end{array}\right),\quad
\tilde b^{(0)} = \left(\begin{array}{c}
h - E\\
h
\end{array}\right)\thinspace .
\label{fem:deq:1D:ex1:Ab:elm:bc:nat}
\end{equation}
$$

<p>

<h2>The finite element algorithm  <a name="___sec101"></a></h2>
<p>
The problem at hand determines the integrals in the variational
formulation.

<p>
Request these functions from the user:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">integrand_lhs(phi, r, s, x)
boundary_lhs(phi, r, s, x)
integrand_rhs(phi, r, x)
boundary_rhs(phi, r, x)
</pre></div>
<p>

<p>
Given a mesh in terms of <tt>vertices</tt>, <tt>cells</tt>, and <tt>dof_map</tt>,
the rest is (almost) automatic.

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&lt;</span>Declare <span style="color: #AA22FF; font-weight: bold">global</span> matrix <span style="color: #AA22FF; font-weight: bold">and</span> rhs: A, b<span style="color: #666666">&gt;</span>

<span style="color: #AA22FF; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(cells)):

    <span style="color: #008800; font-style: italic"># Compute element matrix and vector</span>
    n <span style="color: #666666">=</span> <span style="color: #AA22FF">len</span>(dof_map[e])  <span style="color: #008800; font-style: italic"># no of dofs in this element</span>
    h <span style="color: #666666">=</span> vertices[cells[e][<span style="color: #666666">1</span>]] <span style="color: #666666">-</span> vertices[cells[e][<span style="color: #666666">1</span>]]
    <span style="color: #666666">&lt;</span>Declare element matrix <span style="color: #AA22FF; font-weight: bold">and</span> vector: A_e, b_e<span style="color: #666666">&gt;</span>

    <span style="color: #008800; font-style: italic"># Integrate over the reference cell</span>
    points, weights <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>numerical integration rule<span style="color: #666666">&gt;</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> X, w <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">zip</span>(points, weights):
        phi <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>basis functions <span style="color: #AA22FF; font-weight: bold">and</span> derivatives at X<span style="color: #666666">&gt;</span>
        detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>
        x <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>affine mapping <span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">X</span>&gt;
        <span style="color: #AA22FF; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
            <span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
                A_e[r,s] <span style="color: #666666">+=</span> integrand_lhs(phi, r, s, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w
            b_e[r] <span style="color: #666666">+=</span> integrand_rhs(phi, r, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w

    <span style="color: #008800; font-style: italic"># Add boundary terms</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
        <span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
            A_e[r,s] <span style="color: #666666">+=</span> boundary_lhs(phi, r, s, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w
        b_e[r] <span style="color: #666666">+=</span> boundary_rhs(phi, r, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w

    <span style="color: #008800; font-style: italic"># Incorporate essential boundary conditions</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
        global_dof <span style="color: #666666">=</span> dof_map[e][r]
        <span style="color: #AA22FF; font-weight: bold">if</span> global_dof <span style="color: #AA22FF; font-weight: bold">in</span> essbc_dofs:
            <span style="color: #008800; font-style: italic"># dof r is subject to an essential condition</span>
            value <span style="color: #666666">=</span> essbc_docs[global_dof]
            <span style="color: #008800; font-style: italic"># Symmetric modification</span>
            b_e <span style="color: #666666">-=</span> value<span style="color: #666666">*</span>A_e[:,r]
            A_e[r,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            A_e[:,r] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            A_e[r,r] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
            b_e[r] <span style="color: #666666">=</span> value

    <span style="color: #008800; font-style: italic"># Assemble</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
        <span style="color: #AA22FF; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(n):
            A[dof_map[e][r], dof_map[e][r]] <span style="color: #666666">+=</span> A_e[r,s]
        b[dof_map[e][r] <span style="color: #666666">+=</span> b_e[r]

<span style="color: #666666">&lt;</span>solve linear system<span style="color: #666666">&gt;</span>
</pre></div>
<p>

<p>

<h2>Variational formulations in 2D and 3D <a name="fem:deq:2D:varform"></a></h2>
<p>
How to do integration by parts is the major difference when moving to
2D and 3D.

<p>
Consider

<p>
$$ \nabla^2 u \quad\hbox{or}\quad \nabla\left( a(\x)\nabla u\right)
\thinspace .
$$
with explicit 2D expressions
$$ \nabla^2 u = \nabla\cdot\nabla u =
\frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2},
$$
and
$$
\nabla\left( a(\x)\nabla u\right) =
\frac{\partial}{\partial x}\left( a(x,y)\frac{\partial u}{\partial x}\right) +
\frac{\partial}{\partial y}\left( a(x,y)\frac{\partial u}{\partial y}\right)
\thinspace .
$$

<p>
The general rule for integrating by parts is

<p>
$$
\begin{equation}
-\int_{\Omega} \nabla\cdot (a(\x)\nabla u) v\dx =
\int_{\Omega} a(\x)\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} a\frac{\partial u}{\partial n} v \ds,
\label{fem:deq:2D:int:by:parts}
\end{equation}
$$

<p>
Let us divide the boundary into two parts:

<p>

<ul>
 <p><li> \( \partial\Omega_N \), where we have Neumann conditions
   \( -a\frac{\partial u}{\partial n} = g \), and
 <p><li> \( \partial\Omega_D \), where we have Dirichlet conditions
   \( u = u_0 \).
</ul>

The test functions \( v \) are required to vanish on \( \partial\Omega_D \).

<p>

<p>

<h4>Example  <a name="___sec103"></a></h4>
<p>
A general and widely appearing PDE problem:

<p>
$$
\begin{align}
\v\cdot\nabla u + \alpha u &= \nabla\left( a\nabla u\right) + f,
\quad\x\in\Omega,\\
u &= u_0,\quad\x\in\partial\Omega_D,\\
-a\frac{\partial u}{\partial n} &= g,\quad\x\in\partial\Omega_N
\thinspace .
\end{align}
$$

<p>

<ul>
 <p><li> Known: \( a \), \( \alpha \), \( f \), \( u_0 \), and \( g \).
 <p><li> Second-order PDE: must have <em>exactly one boundary condition at each
   point of the boundary</em>
 <p><li> \( \partial\Omega_N\cup\partial\Omega_D \) = entire boundary
</ul>

The unknown function can be expanded as

<p>
$$ u = u_0 + \sum_{j=0}^N c_j\basphi_j \thinspace .$$

<p>
Galerkin's method: multiply by \( v\in V \) and integrate over \( \Omega \),

<p>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
\int_{\Omega} (\nabla\left( a\nabla u\right)\dx + fv \dx
\thinspace .
$$
Integrate second-order term by parts,

<p>
$$
\int_{\Omega} (\nabla\left( a\nabla u\right)\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds,
$$
resulting in

<p>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
+ \int_{\Omega} fv \dx
\thinspace .
$$
Note: \( v\neq 0 \) only on \( \partial\Omega_N \):
$$ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
= \int_{\partial\Omega_N} a\frac{\partial u}{\partial n} v\ds,
$$
Insert flux condition \( a\frac{\partial u}{\partial n}=-g \) on \( \partial\Omega_N \):
$$
-\int_{\partial\Omega_N} gv\ds\thinspace .
$$
The final variational form:

<p>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v \dx
- \int_{\partial\Omega} g v\ds
+ \int_{\Omega} fv \dx
\thinspace .
$$

<p>
With inner product notation:

<p>
$$
(\v\cdot\nabla u, v) + (\alpha u,v) =
- (a\nabla u,\nabla v) - (g,v)_{N} + (f,v)
\thinspace .
$$
\( (g,v)_{N} \): line or surface integral over \( \partial\Omega_N \).

<p>
Inserting the \( u \) expansion results in
a linear system with

<p>
$$
A_{i,j} = (\v\cdot\nabla \basphi_j, \basphi_i) + (\alpha \basphi_j ,\basphi_i) + (a\nabla \basphi_j,\nabla \basphi_i)
$$

<p>
$$
b_i = (g,\basphi_i)_{N} + (f,\basphi_i) -
(\v\cdot\nabla u_0, \basphi_i) + (\alpha u_0 ,\basphi_i) +
(a\nabla u_0,\nabla \basphi_i),
$$

<p>

<h3>Transformation to a reference cell in 2D and 3D  <a name="___sec104"></a></h3>
<p>
We consider an integral of the type

<p>
$$
\begin{equation}
\int_{{\Omega}^{(e)}} a(\x)\nabla\basphi_i\cdot\nabla\basphi_j\dx
\end{equation}
$$
in the physical domain.

<p>
Goal: integrate this term over the reference cell.

<p>
Mapping from reference to physical coordinates:

<p>
$$ \x(\X), $$
with Jacobian, \( J \), given by
$$ J_{i,j}=\frac{\partial x_j}{\partial X_i}\thinspace .$$

<p>

<ul>
 <p><li> Step 1: \( \dx \rightarrow \det J\dX \).
 <p><li> Step 2: express \( \nabla\basphi_i \) by an expression with \( \refphi_r \) (\( i=q(e,r) \))
 <p><li> We want \( \nabla_{\x}\refphi_r(\X) \) (derivatives wrt \( \x \))
 <p><li> What we readily have: \( \nabla_{\X}\refphi_r(\X) \) (derivative wrt \( \X \))
 <p><li> Need to transform \( \nabla_{\X}\refphi_r(\X) \) to \( \nabla_{\x}\refphi_r(\X) \)
</ul>

Can derive

<p>
$$
\begin{align*}
\nabla_{\X}\refphi_r &= J\cdot\nabla_{\x}\basphi_i,\\
\nabla_{\x}\basphi_i &= J^{-1}\cdot\nabla_{\X}\refphi_r\thinspace .
\end{align*}
$$

<p>
Integral transformation from physical to reference coordinates:

<p>
$$
\begin{equation}
\int_{\Omega}^{(e)} a(\x)\nabla_{\x}\basphi_i\cdot\nabla_{\x}\basphi_j\dx
\int_{\tilde\Omega^r} a(\x(\X))(J^{-1}\cdot\nabla_{\X}\refphi_r)\cdot
(J^{-1}\cdot\nabla\refphi_s)\det J\dX
\end{equation}
$$

<p>

<p>

<p>

<!-- ------------------- end of main content ----------------->
</body>
</html>
    

