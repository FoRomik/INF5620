<?xml version="1.0" encoding="utf-8" ?>
<!--
Automatically generated HTML file from Doconce source
(http://code.google.com/p/doconce/)
-->

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: http://code.google.com/p/doconce/" />

<!--
Color definitions:  http://www.december.com/html/spec/color0.html
CSS examples:       http://www.w3schools.com/css/css_examples.asp
-->

<style type="text/css">
    body {
      margin:5;
      padding:0;
      border:0;	/* Remove the border around the viewport in old versions of IE */
      width:100%;
      background: #fdf6e3;
      min-width:600px;	/* Minimum width of layout - remove if not required */
      font-family: Verdana, Helvetica, Arial, sans-serif;
      font-size: 1.0em;
      line-height: 1.3em;
      color: #657b83;
    }
    a { color: #657b83; text-decoration:none; }
    a:hover { color: #b58900; background: #eee8d5; text-decoration:none; }
    h1, h2, h3 { margin:.8em 0 .2em 0; padding:0; }
    h2 { font-variant: small-caps; }
    pre {
      background: #fdf6e3;
      -webkit-box-shadow: inset 0 0 2px #000000;
      -moz-box-shadow: inset 0 0 2px #000000;
      box-shadow: inset 0 0 2px #000000;
      color: #586e75;
      margin-left: 0px;
      font-family: 'Droid Sans Mono', monospace;
      padding: 2px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      -moz-background-clip: padding;
      -webkit-background-clip: padding-box;
      background-clip: padding-box;
    }
    tt { font-family: "Courier New", Courier; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p { text-indent: 0px; }
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}

</style>

<!-- Use MathJax to render mathematics -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">

</head>

<body>
    
<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{u_{\small\mbox{e}}}
\newcommand{\Aex}{A_{\small\mbox{e}}}
\newcommand{\half}{\frac{1}{2}}
$$



<!-- ------------------- main content ------------------------>

<title>Discretizing first-order ODEs by finite difference methods</title>

<center><h1>Discretizing first-order ODEs by finite difference methods</h1></center>  <! -- document title -->

<! -- author(s) -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>


<center><h4>Sep 13, 2012</h4></center> <!-- date -->
<p>
Note: <b>VERY PRELIMINARY VERSION!</b> (Still lots of typos!)

<p>

<p>
<h2>Table of contents</h2>

<p>

<p>
<a href="#decay:basics"> Finite difference methods for an ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:model"> Exponential decay </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:sec:FE"> The Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec3"> Step 1: Discretizing the domain </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec4"> Step 2: Fulfilling the equation at discrete time points </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec5"> Step 3: Replacing derivatives by finite differences </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec6"> Step 4: Formulating a recursive algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:sec:BE"> The Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:sec:CN"> The Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:sec:theta"> The unifying \( \theta \)-rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> Constant time step </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:sec:fdop"> Compact operator notation for finite differences </a><br>
<a href="#decay:impl1"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:py1"> Making a program </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec14"> Function for computing the numerical solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec15"> Integer division </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec16"> Doc strings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec17"> Formatting of numbers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec18"> Running the program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Verifying the implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec20"> Running a few algorithmic steps by hand </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec21"> Comparison with an exact discrete solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:computing:error"> Computing the numerical error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> Plotting solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Plotting with SciTools </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Creating user interfaces </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec26"> Reading a sequence of command-line arguments </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec27"> Working with an argument parser </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:convergence:rate"> Computing convergence rates </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec29"> Estimating \( r \) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#decay:impl1"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec31"> Debugging via convergence rates </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec32"> Memory-saving implementation </a><br>
<a href="#___sec33"> Software engineering </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> Making a module </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec35"> Prefixing imported functions by the module name </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec36"> Doctests </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec37"> Unit testing with nose </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec38"> Basic use of nose </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec39"> Demonstrating nose </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec40"> Installation of nose </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Classical unit testing with unittest </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec42"> Basic use of unittest </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec43"> Demonstration of unittest </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec44"> Implementing simple problem and solver classes </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec45"> The problem class </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec46"> The solver class </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec47"> The visualizer class </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec48"> Combing the objects </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> Implementing more advanced problem and solver classes </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec50"> A generic class for parameters </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec51"> The problem class </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec52"> The solver class </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec53"> The visualizer class </a><br>
<a href="#decay:experiments"> Performing scientific experiments </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec55"> Interpreting output from other programs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exper:report"> Making a report </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec57"> Plain HTML </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec58"> HTML with MathJax </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec59"> LaTeX </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec60"> Sphinx </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec61"> Markdown </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec62"> Wiki formats </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec63"> Doconce </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exper:github"> Publishing a complete project </a><br>
<a href="#___sec65"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:intdiv"> Exercise 1: Experiment with integer division </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:decay1err"> Exercise 2: Experiment with wrong computations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:FEBECN"> Exercise 3: Implement specialized functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:plot:error"> Exercise 4: Plot the error function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:plot:dtconst"> Exercise 5: Compare methods for a give time mesh </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:inexact:output"> Exercise 6: Change formatting of numbers and debug </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:doctest1"> Exercise 7: Write a doctest </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:nosetest1"> Exercise 8: Write a nose test </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:module1"> Exercise 9: Make a module </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:dc_class:exper"> Exercise 10: Make use of a class implementation </a><br>
<a href="#decay:analysis"> Analysis of the \( \theta \)-rule for a decay ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec77"> Discouraging numerical solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec78"> Experimental investigation of oscillatory solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec79"> Exact numerical solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec80"> Stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec81"> Comparing Amplification Factors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec82"> Series Expansion of Amplification Factors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec83"> Local error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec84"> Analytical comparison of schemes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec85"> The real (global) error at a point </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec86"> Integrated errors </a><br>
<a href="#___sec87"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:analysis:exer:growth"> Exercise 11: Explore the \( \theta \)-rule for exponential growth </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:analysis:exer:growth:report"> Exercise 12: Summarize investigations in a report </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:analysis:exer:growth:A"> Exercise 13: Plot amplification factors for exponential growth </a><br>
<a href="#___sec91"> Model extensions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec92"> Extension to a variable coefficient </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:source"> Extension to a source term </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec94"> Schemes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:general"> Implementation of the generalized model problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec96"> Deriving the \( \theta \)-rule formula </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec97"> The Python code </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec98"> Implementations of variable coefficients </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:verify:trivial"> Verification via trivial solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:MMS"> Verification via manufactured solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec101"> Extension to systems of ODEs </a><br>
<a href="#___sec102"> General first-order ODEs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec103"> Generic form </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec104"> The Odespy software </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec105"> Example: Runge-Kutta methods  </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec106"> Remark about using the \( \theta \)-rule in Odespy </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec107"> Example: Adaptive Runge-Kutta methods  </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec108"> Other schemes </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec109"> Implicit 2-step backward scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec110"> The Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec111"> The filtered Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec112"> 2nd-order Runge-Kutta scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec113"> 2nd-order Adams-Bashforth scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec114"> 3rd-order Adams-Bashforth scheme </a><br>
<a href="#___sec115"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:exer:bw2"> Exercise 14: Implement the 2-step backward scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:exer:leapfrog1"> Exercise 15: Implement the Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:exer:leapfrog2"> Exercise 16: Experiment with the Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:exer:leapfrog3"> Exercise 17: Analyze the Leapfrog scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:exer:AB2"> Exercise 18: Implement the 2nd-order Adams-Bashforth scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:exer:AB3"> Exercise 19: Implement the 3rd-order Adams-Bashforth scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:dc_class2"> Exercise 20: Generalize a class implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:exer:dc_class3"> Exercise 21: Generalize an advanced class implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:fd2:exer:uni"> Exercise 22: Make a unified implementation of many schemes </a><br>
<a href="#decay:app"> Applications of exponential decay models </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:pop"> Evolution of a population </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:interest"> Compound interest and inflation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec128"> Radioactive Decay </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec129"> Newton's law of cooling </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:atm"> Decay of atmospheric pressure with altitude </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec131"> Multiple atmospheric layers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec132"> Simplification: \( L=0 \) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec133"> Simplification: one-layer model </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:drag"> Vertical motion of a body in a viscous fluid </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec135"> Overview of forces </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec136"> Equation of motion </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec137"> Terminal velocity </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec138"> A Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec139"> Physical data </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec140"> Verification </a><br>
<a href="#___sec141"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:atm1"> Exercise 23: Simulate the pressure drop in the atmosphere </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:drag:prog"> Exercise 24: Make a program for vertical motion in a fluid </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:drag:prog:viz"> Exercise 25: Plot forces acting in vertical motion in a fluid </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:drag:parachute1"> Exercise 26: Simulate a free fall of a parachute jumper </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:drag:parachute2"> Exercise 27: Simulate a complete parachute jump </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:drag:rising"> Exercise 28: Simulate a rising ball in water </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:radio:C14"> Exercise 29: Radioactive decay of Carbon-14 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:radio:twosubst"> Exercise 30: Radioactive decay of two substances </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:cooling:pizza"> Exercise 31: Find time of murder from body temperature </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:cooling:osc"> Exercise 32: Simulate an oscillating cooling process </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:signum"> Exercise 33: Compute \( y=|x| \) by solving an ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:interest"> Exercise 34: Simulate growth of a fortune with random interest rate </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:pop:at"> Exercise 35: Simulate sudden environmental changes for a population </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:pop:osc"> Exercise 36: Simulate oscillating environment for a population </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:pop:logistic1"> Exercise 37: Simulate logistic growth </a><br>
&nbsp; &nbsp; &nbsp; <a href="#decay:app:exer:interest:derive"> Exercise 38: Rederive the equation for continuous compound interest </a><br>

<p>
<p>

<p>

<p>

<p>

<p>

<p>

<p>
Finite difference methods for partial differential equations (PDEs)
employ a range of concepts and tools that can be introduced and
illustrated in the context of simple ordinary differential equation
(ODE) examples.  By first working with ODEs, we keep the mathematical
problems to be solved as simple as possible (but no simpler), thereby
allowing full focus on understanding the concepts and tools that will
be reused and further extended when addressing finite difference
methods for time-dependent PDEs. The
forthcoming treatment of ODEs is therefore solely dominated by
reasoning and methods that directly carry over to numerical
methods for PDEs.

<p>
We study two model problems: an ODE for a decaying phenomena, which will
be relevant for PDEs of diffusive nature, and an ODE for oscillating
phenomena, which will be relevant for PDEs of wave nature.
Both problems are linear with known analytical solutions such that we can
easily assess the quality of various numerical methods and analyze
their behavior.

<p>

<p>

<h2>Finite difference methods for an ODE <a name="decay:basics"></a></h2>
<p>

<p>

<p>
The purpose of this module is to explain finite difference methods
in detail for a simple ordinary differential equation (ODE).
Emphasis is put on the reasoning when discretizing the problem,
various ways of programming the methods, how to verify that
the implementation is correct, experimental investigations of
the numerical behavior of the methods, and theoretical analysis
of the methods to explain the observations.

<p>

<h3>Exponential decay <a name="decay:model"></a></h3>
<p>

<p>

<p>
Our model problem is perhaps the simplest ODE:

<p>
$$
\begin{equation*}
u'(t) = -au(t),
\end{equation*}
$$
Here, \( a>0 \) is a constant and \( u'(t) \) means differentiation with respect
to time \( t \). This type of equation arises in a number of widely different
phenomena where some quantity \( u \) undergoes exponential
reduction. Examples include radioactive decay, population decay,
investment decay,
cooling of an object,
pressure decay in the atmosphere,
and retarded motion in fluids (for some of these models, \( a \) can be
negative as well).
Studying numerical solution methods for this simple ODE
gives important insight that can be reused for diffusion PDEs.

<p>
The analytical solution of the ODE is found by the method of
separation of variables, resulting in

<p>
$$
\begin{equation*} u(t) = Ce^{-at},\end{equation*}
$$
for any arbitrary constant \( C \).
To formulate a mathematical problem for which there
is a unique solution, we need a condition to fix the value of \( C \).
This condition is known as the <em>initial condition</em> and stated as
\( u(0)=I \). That is, we know the
value \( I \) of \( u \) when the process starts at \( t=0 \). The exact solution
is then \( u(t)=I\exp{(-at)} \).

<p>
We seek the solution \( u(t) \) of the ODE for \( t\in (0,T] \). The point \( t=0 \) is not
included since we know \( u \) here and assume that the equation governs
\( u \) for \( t>0 \). The complete ODE problem then reads: find \( u(t) \)
such that

<p>
$$
\begin{equation}
u' = -au,\ t\in (0,T], \quad u(0)=I\thinspace .  \label{decay:problem}
\end{equation}
$$
This is known as a <em>continuous problem</em> because the parameter \( t \)
varies continuously from \( 0 \) to \( T \). For each \( t \) we have a corresponding
\( u(t) \). There are hence infinitely many values of \( t \) and \( u(t) \).
The purpose of a numerical method is to formulate a corresponding
<em>discrete</em> problem whose solution is characterized by a finite number of values,
which can be computed in a finite number of steps on a computer.

<p>

<p>

<p>

<h3>The Forward Euler scheme <a name="decay:sec:FE"></a></h3>
<p>

<p>
Solving an ODE like \eqref{decay:problem} by a finite difference method
consists of the following four steps:

<p>

<ol>
<li> discretizing the domain,
<li> fulfilling the equation at discrete time points,
<li> replacing derivatives by finite differences,
<li> formulating a recursive algorithm.
</ol>

<h4>Step 1: Discretizing the domain  <a name="___sec3"></a></h4>
<p>
The time domain \( [0,T] \) is represented by a finite number of
\( N+1 \) points

<p>
$$
\begin{equation}
0 = t_0 < t_1 < t_2 < \cdots < t_{N-1} < t_N = T\thinspace .
\end{equation}
$$
The collection of points \( t_0,t_1,\ldots,t_N \) constitutes a <em>mesh</em>
or <em>grid</em>. Often the mesh points will be uniformly spaced in
the domain \( [0,T] \), which means that the spacing \( t_{n+1}-t_n \) is
the same for all \( n \). This spacing is then often denoted by \( \Delta t \),
in this case \( t_n=n\Delta t \).

<p>
We seek the solution \( u \) at the mesh points:
\( u(t_n) \), \( n=1,2,\ldots,N \) (note that \( u^0 \) is already known as \( I \)).
A notational short-form for \( u(t_n) \),
which will be used extensively, is \( u^{n} \). More precisely, we let
\( u^n \) be the <em>numerical approximation</em> to the exact solution
at \( t=t_n \), \( u(t_n) \). When we need to clearly distinguish the numerical
and the exact solution, we often place a subscript e on the exact
solution, as in \( {\uex}(t_n) \). Figure <a href="#decay:fdu:e">1</a> shows the
\( t_n \) and \( u_n \) points for \( n=0,1,\ldots,N=7 \) as well as \( \uex(t) \)
as the dashed line.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Time mesh with discrete solution values. <a name="decay:fdu:e"></a> </p></center>
<p><img src="fig-decay/fdm_u_ue.png" align="bottom" width=600></p>
</center>

<p>

<p>
Since finite difference methods produce solutions at the mesh
points only, it is an open question what the solution is between
the mesh points. One can use methods for interpolation to
compute the value of \( u \) between mesh points. The simplest
(and most widely used) interpolation method is to assume that
\( u \) varies linearly between the mesh points, see
Figure <a href="#decay:fdu:ei">2</a>. Given \( u^{n} \)
and \( u^{n+1} \), the value of \( u \) at some \( t\in [t_{n}, t_{n+1}] \)
is by linear interpolation

<p>
$$
\begin{equation}
u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n)\thinspace .
\end{equation}
$$

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Linear interpolation between the discrete solution values (dashed curve is exact solution). <a name="decay:fdu:ei"></a> </p></center>
<p><img src="fig-decay/fdm_u_uei.png" align="bottom" width=600></p>
</center>

<p>

<p>

<p>

<h4>Step 2: Fulfilling the equation at discrete time points  <a name="___sec4"></a></h4>
<p>
The ODE is supposed to hold for all \( t\in (0,T] \), i.e., at an infinite
number of points. Now we relax that requirement and require that
the ODE is fulfilled at a finite set of discrete points in time.
The mesh points \( t_1,t_2,\ldots,t_N \) are a natural choice of points.
The original ODE is then reduced to  the following \( N \) equations:

<p>
$$
\begin{equation}
u'(t_n) = -au(t_n),\quad n=1,\ldots,N\thinspace .
\label{decay:step2}
\end{equation}
$$

<p>

<h4>Step 3: Replacing derivatives by finite differences  <a name="___sec5"></a></h4>
<p>
The next and most essential step of the method is to replace the
derivative \( u' \) by a finite difference approximation. Let us first
try a one-sided difference approximation (see Figure <a href="#decay:sketch:FE">3</a>),

<p>
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}\thinspace .
\label{decay:FEdiff}
\end{equation}
$$
Inserting this approximation in \eqref{decay:step2} results in

<p>
$$
\begin{equation}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N-1\thinspace .
\label{decay:step3}
\end{equation}
$$
This equation is the discrete counterpart to the original ODE problem
\eqref{decay:problem}, and often known as a <em>finite difference scheme</em>,
which yields a straightforward way to compute the solution at
the mesh points (\( u(t_n) \), \( n=1,2,\ldots,N \)) as shown next.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Illustration of a forward difference. <a name="decay:sketch:FE"></a> </p></center>
<p><img src="fig-decay/fd_forward.png" align="bottom" width=600,></p>
</center>

<p>

<p>

<h4>Step 4: Formulating a recursive algorithm  <a name="___sec6"></a></h4>
<p>

<p>
The final step is to identify the computational algorithm to be implemented
in a program. The key observation here is to realize that
\eqref{decay:step3} can be used to compute \( u^{n+1} \) if \( u^n \) is known.
Starting with \( n=0 \), \( u^0 \) is known since \( u^0=u(0)=I \), and
\eqref{decay:step3} gives an equation for \( u^1 \). Knowing \( u^1 \),
\( u^2 \) can be found from \eqref{decay:step3}. In general, \( u^n \)
in \eqref{decay:step3} can be assumed known, and then we can easily solve for
the unknown \( u^{n+1} \):

<p>
$$
\begin{equation}
u^{n+1} = u^n - a(t_{n+1} -t_n)u^n\thinspace .
\label{decay:FE}
\end{equation}
$$
We shall refer to \eqref{decay:FE} as the Forward Euler (FE) scheme
for our model problem. From a mathematical point of view,
equations of the form \eqref{decay:FE} are known as
<em>difference equations</em> since they express how differences in
\( u \), like \( u^{n+1}-u^n \), evolve with \( n \).
The finite difference method can be viewed as a method for turning
a differential equation into a difference equation.

<p>
Computation with \eqref{decay:FE} is straightforward:

<p>
$$
\begin{align*}
u_0 &= I,\\
u_1 & = u^0 - a(t_{1} -t_0)u^0 = I(1-a(t_1-t_0)),\\
u_2 & = u^1 - a(t_{2} -t_1)u^1 = I(1-a(t_1-t_0))(1 - a(t_2-t_1)),\\
u^3 &= u^2 - a(t_{3} -t_2)u^2 = I(1-a(t_1-t_0))(1 - a(t_2-t_1))(1 - a(t_3-t_2)),
\end{align*}
$$
and so on until we reach \( u^N \).
In the case \( t_{n+1}-t_n \) is a constant, denoted by \( \Delta t \),
we realize from the above calculations that

<p>
$$
\begin{align*}
u_0 &= I,\\
u_1 & = I(1-a\Delta t),\\
u_2 & = I(1-a\Delta t)^2,\\
u^3 &= I(1-a\Delta t)^3,\\
&\vdots\\
u^N &= I(1-a\Delta t)^N\thinspace .
\end{align*}
$$
This means that we have found a closed formula for \( u^n \), and there is
no need to let a computer generate the sequence \( u^1, u^2, u^3, \ldots \).
However, finding such a formula for \( u^n \) is possible only for a few very
simple problems.

<p>
As the next sections will show, the scheme \eqref{decay:FE} is just one
out of many alternative finite difference (and other) schemes for
the model problem \eqref{decay:problem}.

<p>

<h3>The Backward Euler scheme <a name="decay:sec:BE"></a></h3>
<p>

<p>
There are many choices of difference approximations in step 3 of
the finite difference method as presented in the previous section.
Another alternative is

<p>
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}\thinspace .
\label{decay:BEdiff}
\end{equation}
$$
Since this difference is based on going backward in time (\( t_{n-1} \))
for information, it is known as the Backward Euler difference.
Figure <a href="#decay:sketch:BE">5</a> explains the idea.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Illustration of a backward difference. <a name="decay:sketch:BE"></a> </p></center>
<p><img src="fig-decay/fd_backward.png" align="bottom" width=600,></p>
</center>

<p>

<p>

<p>
Inserting \eqref{decay:BEdiff} in \eqref{decay:step2} yields
the Backward Euler (BE) scheme:

<p>
$$
\begin{equation}
\frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n\thinspace .
\label{decay:BE0}
\end{equation}
$$
We assume, as explained under step 4 in the section <a href="#decay:sec:FE">The Forward Euler scheme</a>,
that we have computed \( u^0, u^1, \ldots, u^{n-1} \) such that
\eqref{decay:BE0} can be used to compute \( u^n \).
For direct similarity with the Forward Euler scheme \eqref{decay:FE}
we replace \( n \) by \( n+1 \) in \eqref{decay:BE0} and solve for the
unknown value \( u^{n+1} \):

<p>
$$
\begin{equation}
u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n\thinspace .
\label{decay:BE}
\end{equation}
$$

<p>

<h3>The Crank-Nicolson scheme <a name="decay:sec:CN"></a></h3>
<p>

<p>

<p>
The finite difference approximations used to derive the schemes
\eqref{decay:FE} and \eqref{decay:BE} are both one-sided differences,
known to be less accurate than central (or midpoint)
differences. We shall now construct
a central difference at \( t_{n+1/2}=\frac{1}{2} (t_n + t_{n+1}) \), or
\( t_{n+1/2}=(n+\frac{1}{2})\Delta t \) if the mesh spacing is uniform in time.
The approximation reads

<p>
$$
\begin{equation}
u'(t_{n+\frac{1}{2}}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}\thinspace .
\label{decay:CNdiff}
\end{equation}
$$
Note that the fraction on the right-hand side is the same as for the
Forward Euler approximation \eqref{decay:FEdiff} and
the Backward Euler approximation \eqref{decay:BEdiff} (with
\( n \) replaced by \( n+1 \)). The accuracy of this fraction as an approximation
to the derivative of \( u \) depends on <em>where</em> we seek the derivative:
in the center of the interval \( [t_{n+1},t_n] \) or at the end points.

<p>
With the formula \eqref{decay:CNdiff}, where \( u' \) is evaluated at
\( t_{n+1/2} \), it is natural to demand the
ODE to be fulfilled at the time points between the mesh points:

<p>
$$
\begin{equation}
u'(t_{n+\frac{1}{2}}) = -au(t_{n+\frac{1}{2}}),\quad n=0,\ldots,N-1\thinspace .
\label{decay:step2m}
\end{equation}
$$
Using \eqref{decay:CNdiff} in \eqref{decay:step2m} results in

<p>
$$
\begin{equation}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -au^{n+\frac{1}{2}},
\label{decay:CN0}
\end{equation}
$$
where \( u^{n+\frac{1}{2}} \) is a short form for \( u(t_{n+\frac{1}{2}}) \).
The problem is that we aim to compute \( u^n \) for integer \( n \), implying that
\( u^{n+\frac{1}{2}} \) is not a quantity computed by our method. It must be
expressed by the quantities that we actually produce, i.e., \( u \) at the
mesh points. One possibility is to approximate \( u^{n+\frac{1}{2}} \)
as an average of the \( u \) values at the neighboring mesh points:

<p>
$$
\begin{equation}
u^{n+\frac{1}{2}} \approx \frac{1}{2} (u^n + u^{n+1})\thinspace .
\label{decay:uhalfavg}
\end{equation}
$$
Using \eqref{decay:uhalfavg} in \eqref{decay:CN0} results in

<p>
$$
\begin{equation}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\frac{1}{2} (u^n + u^{n+1})\thinspace .
\label{decay:CN1}
\end{equation}
$$
Figure <a href="#decay:sketch:BE">5</a> sketches the geometric interpretation of
such a centered difference.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Illustration of a centered difference. <a name="decay:sketch:BE"></a> </p></center>
<p><img src="fig-decay/fd_backward.png" align="bottom" width=600,></p>
</center>

<p>

<p>
We assume that \( u^n \) is already computed so that \( u^{n+1} \) is the
unknown, which we can solve for:

<p>
$$
\begin{equation}
u^{n+1} = \frac{1-\frac{1}{2} a(t_{n+1}-t_n)}{1 + \frac{1}{2} a(t_{n+1}-t_n)}u^n\thinspace .
\label{decay:CN}
\end{equation}
$$
The finite difference scheme \eqref{decay:CN} is known as
the midpoint scheme or the Crank-Nicolson (CN) scheme. We shall use the latter
name.

<p>

<p>

<h3>The unifying \( \theta \)-rule <a name="decay:sec:theta"></a></h3>
<p>

<p>

<p>
Let us reconsider the derivation of the Forward Euler, Backward Euler,
and Crank-Nicolson schemes. In all the mentioned schemes we replace \( u' \) by the
fraction

<p>
$$
\begin{equation*} \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n},\end{equation*}
$$
and the difference between the methods lies in which point this
fraction approximates the derivative; i.e., in which point we
sample the ODE. So far this has been the
end points or the midpoint of \( [t_n,t_{n+1}] \). However, we may choose any point
\( \tilde t \in [t_n,t_{n+1}] \).
The difficulty
is that evaluating the right-hand side \( -au \) at an arbitrary point
faces the same problem as in
the section <a href="#decay:sec:CN">The Crank-Nicolson scheme</a>: the point value must be expressed
by the discrete \( u \) quantities that we compute by the scheme, i.e.,
\( u^n \) and \( u^{n+1} \). Following the averaging idea from
the section <a href="#decay:sec:CN">The Crank-Nicolson scheme</a>,
the value of \( u \) at an arbitrary point \( \tilde t \) can be
calculated as a <em>weighted average</em>, which generalizes the arithmetic average
\( \frac{1}{2}u^n + \frac{1}{2}u^{n+1} \).
If we express \( \tilde t \) as a weighted average
$$ t_{n+\theta} = \theta t_{n+1} + (1-\theta) t_{n},$$
where \( \theta\in [0,1] \) is the weighting factor, we can write

<p>
$$
\begin{equation}
u(\tilde t) = u(\theta t_{n+1} + (1-\theta) t_{n}) \approx
\theta u^{n+1} + (1-\theta) u^{n}\thinspace .
\label{decay:thetaavg}
\end{equation}
$$

<p>

<p>
We can now let the ODE hold at the point
\( \tilde t\in [t_n,t_{n+1}] \), approximate \( u' \) by the fraction
\( (u^{n+1}-u^{n})/(t_{n+1}-t_n) \), and approximate the right-hand
side \( -au \) by the weighted average \eqref{decay:thetaavg}.
The result is

<p>
$$
\begin{equation}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})
\label{decay:th0}
\thinspace .
\end{equation}
$$
This is a generalized scheme for our model problem:
\( \theta =0 \) gives the Forward Euler scheme, \( \theta =1 \) gives the
Backward Euler scheme, and \( \theta =1/2 \) gives the Crank-Nicolson
scheme. In addition, we may choose any other value of \( \theta \) in \( [0,1] \).

<p>
As before, \( u^n \) is considered known and \( u^{n+1} \) unknown, so
we solve for the latter:

<p>
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}\thinspace .
\label{decay:th}
\end{equation}
$$
This scheme is known as the \( \theta \)-rule, or alternatively written as
the "theta-rule".

<p>

<p>

<h3>Constant time step  <a name="___sec10"></a></h3>
<p>
All schemes up to now have been formulated for a general non-uniform
mesh in time: \( t_0,t_1,\ldots,t_N \). Non-uniform meshes are highly relevant
since one can use many points in regions where \( u \) varies rapidly, and
save points in regions where \( u \) is slowly varying. This is the key idea
of <em>adaptive</em> methods where the spacing of the mesh points
are determined as the computations proceed.

<p>
However, a uniformly distributed set of mesh points is very common and
sufficient for many applications. It therefore makes sense to
present the finite difference schemes for a uniform point distribution
\( t_n=n\Delta t \), where \( \Delta t \) is the constant spacing between
the mesh points, also referred to as the <em>time step</em>.
The resulting formulas look simpler and are perhaps more
well known:

<p>
$$
\begin{align}
u^{n+1} &= (1 - a\Delta t )u^n  \quad (\hbox{FE})
\label{decay:FE:u}\\
u^{n+1} &= \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})
\label{decay:BE:u}\\
u^{n+1} &= \frac{1-\frac{1}{2} a\Delta t}{1 + \frac{1}{2} a\Delta t} u^n \quad \quad (\hbox{CN})
\label{decay:CN:u}\\
u^{n+1} &= \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})
\label{decay:th:u}
\end{align}
$$

<p>
Not surprisingly, we present alternative schemes
because they have different pros and cons, both for the simple ODE
in question (which can easily be solved as accurately as desired), and for
more advanced differential equation problems.

<p>

<h3>Compact operator notation for finite differences <a name="decay:sec:fdop"></a></h3>
<p>

<p>

<p>
Finite difference formulas can be tedious to write and read,
especially for differential equations with many terms and many
derivatives. To save space and help the reader of the scheme to quickly
see the nature of the difference approximations, we introduce a
compact notation. A forward difference approximation is denoted
by the \( D_t^+ \) operator:

<p>
$$
\begin{equation}
[D_t^+u]^n = \frac{u^{n+1} - u^{n}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \label{fd:D:f}
\thinspace .
\end{equation}
$$
The notation consists of an operator that approximates
differentiation with respect to an independent variable, here \( t \).
The operator is built of the symbol \( D \), with the variable as subscript
and a superscript denoting the type of difference. The superscript \( {}^+ \)
indicates a forward difference.
We place square brackets around the operator and the function it operates
on and specify the mesh point, where the operator is acting, by
a superscript.

<p>
The corresponding operator notation for a centered difference and
a backward difference reads

<p>
$$
\begin{equation}
[D_tu]^n = \frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t}
\approx \frac{d}{dt} u(t_n), \label{fd:D:c}
\end{equation}
$$
and
$$
\begin{equation}
[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \label{fd:D:b}
\thinspace .
\end{equation}
$$
Note that the superscript \( {}^- \) denotes the backward
difference, while no superscript implies a central difference.

<p>
An averaging operator is also convenient to have:

<p>
$$
\begin{equation}
[\overline{u}^{t}]^n = \frac{1}{2} (u^{n-\frac{1}{2}} + u^{n+\frac{1}{2}} )
\approx u(t_n) \label{fd:mean:a}
\end{equation}
$$
The superscript \( t \) indicates that the average is taken along the time
coordinate. The common average \( (u^n + u^{n+1})/2 \) can now be
expressed as \( [\overline{u}^{t}]^{n+1/2} \).

<p>

<p>
The Backward Euler finite difference approximation to \( u'=-au \) can be written
as follows utilizing the compact notation:

<p>
$$
\begin{equation*}
[D_t^-u]^n = -au^n \thinspace .
\end{equation*}
$$
In difference equations we often place the square brackets around
the whole equation, to indicate at which mesh point the equation applies,
since each term is supposed to be approximated at the same point:

<p>
$$
\begin{equation}
[D_t^- u  = -au]^n \thinspace .
\end{equation}
$$
The Forward Euler scheme takes the form

<p>
$$
\begin{equation}
[D_t^+ u  = -au]^n,
\end{equation}
$$
while the Crank-Nicolson scheme is written as

<p>
$$
\begin{equation}
[D_t u = -a\overline{u}^t]^{n+\frac{1}{2}}\thinspace .
\label{fd:compact:ex:CN}
\end{equation}
$$
Just apply \eqref{fd:D:c} and \eqref{fd:mean:a} and write out the
expressions to see that \eqref{fd:compact:ex:CN} is indeed the
Crank-Nicolson scheme.

<p>

<p>
The \( \theta \)-rule can be specified by

<p>
$$
\begin{equation}
[\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta},
\label{decay:fd1:op:theta}
\end{equation}
$$
if we define a new time difference and a <em>weighted averaging operator</em>:

<p>
$$
\begin{equation}
[\bar D_t u]^{n+\theta} = \frac{u^{n+1}-u^n}{t^{n+1}-t^n},
\label{decay:fd1:Du:theta}
\end{equation}
\begin{equation}
[\overline{u}^{t,\theta}]^{n+\theta} = (1-\theta)u^{n} + \theta u^{n+1}
\approx u(t_{n+\theta}),
\label{decay:fd1:wmean:a}
\end{equation}
$$
where \( \theta\in [0,1] \). Note that for \( \theta =1/2 \) we recover
the standard centered difference and the standard arithmetic average.
The idea in \eqref{decay:fd1:op:theta} is to sample the equation at
\( t_{n+\theta} \), use a skew difference at that
point \( [\bar D_t u]^{n+\theta} \), and a shifted mean value.
An alternative notation is
$$ [D_t u]^{n+1/2} = \theta [-au]^{n+1} + (1-\theta)[-au]^{n}\thinspace .$$

<p>
Looking at the various examples above and comparing them with the
underlying differential equations, we see immediately which difference
approximations that have been used and at which point they
apply. Therefore, the compact notation efficiently communicates the
reasoning behind turning a differential equation into a difference
equation.

<p>

<p>

<p>

<h2>Implementation <a name="decay:impl1"></a></h2>
<p>

<p>
The purpose now is to make a computer program for solving
$$
u'(t) = -au(t),\quad t\in (0,T], \quad u(0)=I,
$$
and display the solution on the screen, preferably together with the
exact solution. We shall also be concerned with how we can test
that the implementation is correct.

<p>
All programs referred to in this section are found in the
<a href="https://github.com/hplgit/INF5620/tree/gh-pages/src/decay"><tt>src/decay</tt></a> directory.

<p>
<b>Mathematical problem.</b> We want to explore the Forward Euler scheme, the
Backward Euler, and the Crank-Nicolson schemes applied to our model problem.
From an implementational points of view, it is advantageous to
implement the \( \theta \)-rule
$$
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
$$
since it can generate the three other schemes by various of
choices of \( \theta \): \( \theta=0 \) for Forward Euler, \( \theta =1 \) for
Backward Euler, and \( \theta =1/2 \) for Crank-Nicolson.
Given \( a \), \( u^0=I \), \( T \), and \( \Delta t \),
our task is to use the \( \theta \)-rule to
compute \( u^1, u^2,\ldots,u^N \), where \( t_N=N\Delta t \), and
\( N \) the closest integer to \( T/\Delta t \).

<p>
<b>Computer Language: Python.</b> Any programming language can be used to generate the \( u^{n+1} \) values from
the formula above. However, in this document we shall mainly make use of
Python of several reasons:

<p>

<ul>
  <li> Python has a very clean, readable syntax (often known as
    "executable pseudo-code").
  <li> Python code is very similar to MATLAB code (and MATLAB has a
    particularly widespread use for scientific computing).
  <li> Python is similar to, but much simpler to work with and
    results in more reliable code than C++.
  <li> Python is a full-fledged, very powerful programming language.
  <li> Python has a rich set of modules for scientific computing, and its
    popularity in scientific computing is rapidly growing.
  <li> Python was made for being combined with compiled languages
    (C, C++, Fortran) to reuse existing numerical software and to
    reach high computational performance of new implementations.
  <li> Python has extensive support for administrative task
    needed when doing large-scale computational investigations.
  <li> Python has extensive support for graphics (visualization,
    user interfaces, web applications).
  <li> FEniCS, a very powerful tool for solving PDEs by
    the finite element method, is most human-efficient to operate
    from Python.
</ul>

Learning Python is easy. Many newcomers to the language will probably
learn enough from the examples to perform their own computer
experiments. The examples start with simple Python code and gradually
make use of more powerful constructs as we proceed. As long as it is
not inconvenient for the problem at hand, our Python code is made as
close as possible to MATLAB code for easy transition between the two
languages.

<p>

<h3>Making a program <a name="decay:py1"></a></h3>
<p>

<p>
We choose to have an array <tt>u</tt> for storing the \( u^n \) values, \( n=0,1,\ldots,N \).
The algorithmic steps are

<p>

<ol>
 <li> initialize \( u^0 \)
 <li> for \( t=t_n \), \( n=1,2,\ldots,N \): compute \( u_n \) using
    the \( \theta \)-rule formula
</ol>

<h4>Function for computing the numerical solution  <a name="___sec14"></a></h4>
<p>
The following Python function takes the input data of the problem
(\( I \), \( a \), \( T \), \( \Delta t \), \( \theta \)) as arguments and returns two arrays with
the solution \( u^0,\ldots,u^N \) and the mesh points \( t_0,\ldots,t_N \),
respectively:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solver</span>(I, a, T, dt, theta):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(T<span style="color: #666666">/</span>dt)            <span style="color: #008800; font-style: italic"># no of time intervals</span>
    T <span style="color: #666666">=</span> N<span style="color: #666666">*</span>dt                 <span style="color: #008800; font-style: italic"># adjust T to fit time step dt</span>
    u <span style="color: #666666">=</span> zeros(N<span style="color: #666666">+1</span>)           <span style="color: #008800; font-style: italic"># array of u[n] values</span>
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)  <span style="color: #008800; font-style: italic"># time mesh</span>

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I                 <span style="color: #008800; font-style: italic"># assign initial condition</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #666666">0</span>, N):    <span style="color: #008800; font-style: italic"># n=0,1,...,N-1</span>
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[n]
    <span style="color: #AA22FF; font-weight: bold">return</span> u, t
</pre></div>
<p>

<p>
The <tt>numpy</tt> library contains a lot of functions for array computing. Most
of the function names are similar to what is found
in the alternative scientific computing language MATLAB. Here
we make use of

<p>

<ul>
 <li> <tt>zeros(N+1)</tt> for creating an array of a size <tt>N+1</tt>
   and initializing the elements to zero
 <li> <tt>linspace(0, T, N+1)</tt> for creating an array with <tt>N+1</tt> coordinates uniformly
   distributed between <tt>0</tt> and <tt>T</tt>
</ul>

The <tt>for</tt> loop deserves a comment, especially for newcomers to Python.
The construction <tt>range(0, N, s)</tt> generates all integers from <tt>0</tt> to <tt>N</tt>
in steps of <tt>s</tt>, <em>but not including</em> <tt>N</tt>. Omitting <tt>s</tt> means <tt>s=1</tt>.
For example, <tt>range(0, 6, 3)</tt>
gives <tt>0</tt> and <tt>3</tt>, while <tt>range(0, N)</tt> generates <tt>0</tt>, <tt>1</tt>, ..., <tt>N-1</tt>.
In our loop, <tt>n</tt> takes on the values generated by <tt>range(0, N)</tt>,
implying the following assignments <tt>u[n+1]</tt>: <tt>u[1]</tt>, <tt>u[2]</tt>, ...,
<tt>u[N]</tt>, which is what we want since <tt>u</tt> has length <tt>N+1</tt>.
The first index in Python arrays or lists is <em>always</em> <tt>0</tt> and the
last is then <tt>len(u)-1</tt>.

<p>
To compute with the <tt>solver</tt> function, we need to <em>call</em> it. Here
is a sample call:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=2</span>, T<span style="color: #666666">=8</span>, dt<span style="color: #666666">=0.8</span>, theta<span style="color: #666666">=1</span>)
</pre></div>
<p>

<p>

<h4>Integer division  <a name="___sec15"></a></h4>
<p>
The shown implementation of the <tt>solver</tt> may face problems and
wrong results if <tt>T</tt>, <tt>a</tt>, <tt>dt</tt>, and <tt>theta</tt> are given as integers,
see <a href="#decay:exer:intdiv">Exercise 1: Experiment with integer division</a> and <a href="#decay:exer:decay1err">Exercise 2: Experiment with wrong computations</a>.
The problem is related to <em>integer division</em> in Python (as well as
in Fortran, C, and C++): <tt>1/2</tt> becomes <tt>0</tt>,
while <tt>1.0/2</tt>, <tt>1/2.0</tt>, or <tt>1.0/2.0</tt> all become are <tt>0.5</tt>. It is enough
that at least the nominator or the denominator is a real number
(i.e., a <tt>float</tt> object)
to ensure correct mathematical division. Inserting
a conversion <tt>dt = float(dt)</tt>
guarantees that <tt>dt</tt> is
<tt>float</tt> and avoids problems in <a href="#decay:exer:decay1err">Exercise 2: Experiment with wrong computations</a>.

<p>
Another problem with computing \( N=T/\Delta t \) is that we should
round \( N \) to the nearest integer. With <tt>N = int(T/dt)</tt> the <tt>int</tt>
operation picks the largest integer smaller than <tt>T/dt</tt>. Correct
rounding is obtained by
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(<span style="color: #AA22FF">round</span>(T<span style="color: #666666">/</span>dt))
</pre></div>
<p>
The complete version of our improved, safer <tt>solver</tt> function then becomes

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solver</span>(I, a, T, dt, theta):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(dt)           <span style="color: #008800; font-style: italic"># avoid integer division</span>
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(<span style="color: #AA22FF">round</span>(T<span style="color: #666666">/</span>dt))     <span style="color: #008800; font-style: italic"># no of time intervals</span>
    T <span style="color: #666666">=</span> N<span style="color: #666666">*</span>dt                 <span style="color: #008800; font-style: italic"># adjust T to fit time step dt</span>
    u <span style="color: #666666">=</span> zeros(N<span style="color: #666666">+1</span>)           <span style="color: #008800; font-style: italic"># array of u[n] values</span>
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)  <span style="color: #008800; font-style: italic"># time mesh</span>

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I                 <span style="color: #008800; font-style: italic"># assign initial condition</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #666666">0</span>, N):    <span style="color: #008800; font-style: italic"># n=0,1,...,N-1</span>
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[n]
    <span style="color: #AA22FF; font-weight: bold">return</span> u, t
</pre></div>
<p>

<p>

<p>

<h4>Doc strings  <a name="___sec16"></a></h4>
<p>

<p>
Right below the header line in the <tt>solver</tt> function there is a
Python string enclosed in triple double quotes <tt>"""</tt>.
The purpose of this string object is to document what the function
does and what the arguments are. In this case the necessary
documentation do not span more than one line, but with triple double
quoted strings the text may span several lines:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solver</span>(I, a, T, dt, theta):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Solve</span>

<span style="color: #BB4444; font-style: italic">        u&#39;(t) = -a*u(t),</span>

<span style="color: #BB4444; font-style: italic">    with initial condition u(0)=I, for t in the time interval</span>
<span style="color: #BB4444; font-style: italic">    (0,T]. The time interval is divided into time steps of</span>
<span style="color: #BB4444; font-style: italic">    length dt.</span>

<span style="color: #BB4444; font-style: italic">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span style="color: #BB4444; font-style: italic">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span style="color: #BB4444; font-style: italic">    Nicolson method.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #666666">...</span>
</pre></div>
<p>
Such documentation strings appearing right after the header of
a function are called <em>doc strings</em>. There are tools that can automatically
produce nicely formatted documentation by extracting the definition of
functions and the contents of doc strings.

<p>
It is strongly recommended to equip any function whose purpose
is not obvious with a doc string. Nevertheless, the forthcoming
text deviates from this rule if the function is explained in the text.

<p>

<p>

<h4>Formatting of numbers  <a name="___sec17"></a></h4>
<p>
Having computed the discrete solution <tt>u</tt>, it is natural to look at
the numbers:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800; font-style: italic"># Write out a table of t and u values:</span>
<span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(t)):
    <span style="color: #AA22FF; font-weight: bold">print</span> t[i], u[i]
</pre></div>
<p>
This compact <tt>print</tt> statement gives unfortunately quite ugly output
because the <tt>t</tt> and <tt>u</tt> values are not aligned in nicely formatted columns.
To fix this problem, we recommend to use the <em>printf format</em>, supported most
programming languages inherited from C. Another choice is
Python's recent <em>format string syntax</em>.

<p>

<p>
Writing <tt>t[i]</tt> and <tt>u[i]</tt> in two nicely formatted columns is done like
this with the printf format:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%6.3f</span><span style="color: #BB4444"> u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> (t[i], u[i])
</pre></div>
<p>
The percentage signs signify "slots" in the text where the variables
listed at the end of the statement are inserted. For each "slot" one
must specify a format for how the variable is going to appear in the
string: <tt>s</tt> for pure text, <tt>d</tt> for an integer, <tt>g</tt> for a real number
written as compactly as possible, <tt>9.3E</tt> for scientific notation with
three decimals in a field of width 9 characters (e.g., <tt>-1.351E-2</tt>),
or <tt>.2f</tt> for a standard decimal notation, here with two decimals,
formatted with minimum width. The printf syntax provides a quick way
of formatting tabular output of numbers with full control of the
layout.

<p>

<p>
The alternative <em>format string syntax</em> looks like
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;t={t:6.3f} u={u:g}&#39;</span><span style="color: #666666">.</span>format(t<span style="color: #666666">=</span>t[i], u<span style="color: #666666">=</span>u[i])
</pre></div>
<p>
As seen, this format allows logical names in the "slots" where
<tt>t[i]</tt> and <tt>u[i]</tt> are to be inserted. The "slots" are surrounded
by curly braces, and the logical name is followed by a colon and
then the printf-like specification of how to format real numbers,
integers, or strings.

<p>

<h4>Running the program  <a name="___sec18"></a></h4>
<p>
The function and main program shown above must be placed in a file,
say with name <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_v1.py"><tt>dc_v1.py</tt></a>.  Make sure you
write the code with a suitable text editor (Gedit, Emacs, Vim,
Notepad++, or similar).  The program is run by executing the file this
way:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_v1.py
</pre></div>
<p>
The text <tt>Terminal></tt> just signifies a prompt in a
Unix/Linux or DOS terminal window. After this prompt (which will look
different in your terminal window, depending on the terminal application
and how it is set up), commands like <tt>python dc_v1.py</tt> can be issued.
These commands are interpreted by the operating system.

<p>
We strongly recommend to run Python programs within the IPython shell.
First start IPython by typing <tt>ipython</tt> in the terminal window.
Inside the IPython shell, our program <tt>dc_v1.py</tt> is run by the command
<tt>run dc_v1.py</tt>.
The advantage of running programs in IPython are many: previous commands
are easily recalled, <tt>%pdb</tt> turns on debugging so that
variables can be examined if the program
aborts due to an exception, output of commands are stored in variables,
programs and statements can be profiled,
any operating system command can be executed, modules can be loaded
automatically and other customizations can be performed when starting
IPython -- to mention a few of the most
useful features.

<p>
Although running programs in IPython is strongly recommended, most
execution examples in the forthcoming text use the standard
Python shell with prompt <tt>>>></tt> and run programs through
a typesetting like
<tt>Terminal> python programname</tt>. The reason is that such typesetting
makes the text more compact in the vertical direction
than showing sessions with IPython syntax.

<p>
<!-- Explain running programs in IPython -->
<!-- Prompt: maybe just something with Unix to promote virtual Ubuntu -->

<p>

<h3>Verifying the implementation  <a name="___sec19"></a></h3>
<p>
It is easy to make mistakes while deriving and implementing numerical
algorithms, so we should never believe in the printed \( u \) values before
they have been thoroughly verified. The most obvious idea is to compare
the computed solution with the exact solution, when that exists,
but there will always be a discrepancy between these two solutions
because of the numerical approximations. The challenging question is whether
we have the mathematically correct discrepancy or if we have another,
maybe small, discrepancy due to both an approximation error
and an error in the implementation.

<p>
The purpose of <em>verifying</em> a program is to bring evidence for the
fact that there are no errors in the implementation. To avoid
mixing unavoidable approximation errors and undesired
implementation errors, we should
try to make tests where we have some exact computation of the
discrete solution or at least parts of it.

<p>

<h4>Running a few algorithmic steps by hand  <a name="___sec20"></a></h4>
<p>
The simplest approach to produce a correct reference for the discrete
solution \( u \) of finite difference equations is to compute a few
steps of the algorithm by hand. Then we can compare the hand
calculations with numbers produced by the program.

<p>
A straightforward approach is to use a calculator and
compute \( u^1 \), \( u^2 \), and \( u^3 \). However, the chosen values of \( I \) and \( \theta \)
given in the execution example above are not good, because the
numbers 0 and 1 can easily
simplify formulas too much for test purposes. For example, with
\( \theta =1 \) the nominator in the formula for \( u^n \) will be the same for
all \( a \) and \( \Delta t \) values. One should therefore choose more
"arbitrary" values, say \( \theta =0.8 \) and \( I=0.1 \). Hand calculations
with the aid of a calculator gives

<p>
$$ A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035$$
$$
\begin{align*}
u^1 &= AI=0.0298245614035,\\
u^2 &= Au^1= 0.00889504462912,\\
u^3 &=Au^2= 0.00265290804728
\end{align*}
$$

<p>
Comparison of these manual calculations with the result of the
<tt>solver</tt> function is carried out in the function

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">verify_three_steps</span>():
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;Compare three steps with known manual computations.&quot;&quot;&quot;</span>
    theta <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>; a <span style="color: #666666">=</span> <span style="color: #666666">2</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
    u_by_hand <span style="color: #666666">=</span> array([I,
                       <span style="color: #666666">0.0298245614035</span>,
                       <span style="color: #666666">0.00889504462912</span>,
                       <span style="color: #666666">0.00265290804728</span>])

    N <span style="color: #666666">=</span> <span style="color: #666666">3</span>  <span style="color: #008800; font-style: italic"># number of time steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, T<span style="color: #666666">=</span>N<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)

    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>  <span style="color: #008800; font-style: italic"># tolerance for comparing floats</span>
    difference <span style="color: #666666">=</span> <span style="color: #AA22FF">abs</span>(u <span style="color: #666666">-</span> u_by_hand)<span style="color: #666666">.</span>max()
    success <span style="color: #666666">=</span> difference <span style="color: #666666">&lt;=</span> tol
    <span style="color: #AA22FF; font-weight: bold">return</span> success
</pre></div>
<p>

<p>
The main program, where we call the <tt>solver</tt> function and print <tt>u</tt>,
is now put in a separate function <tt>main</tt>:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">main</span>():
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=2</span>, T<span style="color: #666666">=8</span>, dt<span style="color: #666666">=0.8</span>, theta<span style="color: #666666">=1</span>)
    <span style="color: #008800; font-style: italic"># Write out a table of t and u values:</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(t)):
        <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%6.3f</span><span style="color: #BB4444"> u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> (t[i], u[i])
        <span style="color: #008800; font-style: italic"># or print &#39;t={t:6.3f} u={u:g}&#39;.format(t=t[i], u=u[i])</span>
</pre></div>
<p>

<p>
The main program in the file may now first run the verification test
and then go on with the real simulation (<tt>main()</tt>) only if the test is passed:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">if</span> verify_three_steps():
    main()
<span style="color: #AA22FF; font-weight: bold">else</span>:
    <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Bug in the implementation!&#39;</span>
</pre></div>
<p>

<p>
Since the verification test is always done, future errors introduced
accidentally in the program have a good chance of being detected.

<p>
It is essential that verification tests can be automatically run
at <em>any</em> time. For this purpose,
there are test frameworks and corresponding programming
rules that allow us to request running through a suite of test cases,
but in this very early stage of program development we just implement
and run the verification in our own code so that every detail is
visible and understood.

<p>
The complete program including the <tt>verify_three_steps*</tt> functions is
found in the file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_verf1.py"><tt>dc_verf1.py</tt></a>.

<p>

<h4>Comparison with an exact discrete solution  <a name="___sec21"></a></h4>
<p>
Sometimes it is possible to find a closed-form
<em>exact discrete solution</em> that fulfills the discrete finite
difference equations. The implementation can then be verified against
the exact discrete solution. This is usually the best technique for
verification.

<p>
<!-- Not so limited, will later guess that linear functions and MMS can -->
<!-- be used in the discrete eqs as well! -->

<p>
Define
$$ A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}\thinspace . $$
Manual computations with the \( \theta \)-rule results in
$$
\begin{align*}
u^0 &= I,\\
u^1 &= Au^0 = AI,\\
u^2 &= Au^1 = A^2I,\\
&\vdots\\
u^n &= A^nu^{n-1} = A^nI \thinspace .
\end{align*}
$$
We have then established the exact discrete solution as
$$
\begin{equation}
u^n = IA^n
\label{decay:un:exact}
\thinspace .
\end{equation}
$$
One should be conscious about the different meanings of the notation
on the left- and right-hand side
of this equation: on the left, \( n \) is a superscript reflecting a counter
of mesh points, while on the right, \( n \) is the power in an exponentiation.

<p>
Comparison of the exact discrete solution and the computed
solution is done in the following function:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">verify_exact_discrete_solution</span>():

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_discrete_solution</span>(n, I, a, theta, dt):
        factor <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)
        <span style="color: #AA22FF; font-weight: bold">return</span> I<span style="color: #666666">*</span>factor<span style="color: #666666">**</span>n

    theta <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>; a <span style="color: #666666">=</span> <span style="color: #666666">2</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(<span style="color: #666666">8/</span>dt)  <span style="color: #008800; font-style: italic"># no of steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, T<span style="color: #666666">=</span>N<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    u_de <span style="color: #666666">=</span> array([exact_discrete_solution(n, I, a, theta, dt)
                  <span style="color: #AA22FF; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(N<span style="color: #666666">+1</span>)])
    difference <span style="color: #666666">=</span> <span style="color: #AA22FF">abs</span>(u_de <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()  <span style="color: #008800; font-style: italic"># max deviation</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>  <span style="color: #008800; font-style: italic"># tolerance for comparing floats</span>
    success <span style="color: #666666">=</span> difference <span style="color: #666666">&lt;=</span> tol
    <span style="color: #AA22FF; font-weight: bold">return</span> success
</pre></div>
<p>
Note that one can define a function inside another function (but such
a function is invisible outside the function in which it is defined).
The complete program is found in the file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_verf2.py"><tt>dc_verf2.py</tt></a>.

<p>

<p>

<h3>Computing the numerical error <a name="decay:computing:error"></a></h3>
<p>

<p>
Now that we have evidence for a correct implementation, we are in a
position to compare the computed \( u^n \) values in the <tt>u</tt> array with
the exact \( u \) values at the mesh points, in order to study the error
in the numerical solution.

<p>
Let us first make a function for the analytical solution \( \uex(t)=Ie^{-at} \)
of the model problem:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_solution</span>(t, I, a):
    <span style="color: #AA22FF; font-weight: bold">return</span> I<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)
</pre></div>
<p>

<p>
A natural way to compare the exact and discrete solutions is to
calculate their difference at the mesh points:

<p>
$$
\begin{equation}
e_n = \uex(t_n) - u^n,\quad n=0,1,\ldots,N \thinspace .
\end{equation}
$$
These numbers are conveniently computed by

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u, t <span style="color: #666666">=</span> solver(I, a, T, dt, theta)  <span style="color: #008800; font-style: italic"># Numerical solution</span>
u_e <span style="color: #666666">=</span> exact_solution(t, I, a)
e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
</pre></div>
<p>
The last two statements make use of array arithmetics: <tt>t</tt> is an
array of mesh points that we pass to <tt>exact_solution</tt>. This function
evaluates <tt>-a*t</tt>, which is a scalar times an array, meaning that
the scalar is multiplied with each array element.
The result is an array, let us call it <tt>tmp1</tt>. Then
<tt>exp(tmp1)</tt> means applying the exponential function to each element in
<tt>tmp</tt>, resulting an array, say <tt>tmp2</tt>. Finally, <tt>I*tmp2</tt> is computed
(scalar times array) and <tt>u_e</tt> refers to this array returned from
<tt>exact_solution</tt>. The expression <tt>u_e - u</tt> is the difference between
two arrays, resulting in a new array referred to by <tt>e</tt>.

<p>
The array <tt>e</tt> is the current problem's discrete <em>error function</em>. Very
often we want to work with just one number reflecting the size of the
error. A common choice is to integrate \( e_n^2 \) over the mesh and take
the square root.  Assuming the exact and discrete solution to vary
linearly between the mesh points, the integral is given exactly by the
Trapezoidal rule:

<p>
$$ \hat E^2 = \Delta t\left(\frac{1}{2}e_0^2 + \frac{1}{2}e_N^2
+ \sum_{n=1}^{N-1} e_n^2\right) $$
A common approximation of this expression, for convenience, is

<p>
$$ \hat E^2 \approx E^2 = \Delta t\sum_{n=0}^{N} e_n^2 $$
The error in this approximation is not much of a concern: it means that
the error measure is not exactly the Trapezoidal rule of an integral, but
a slightly different measure. We could equally well have chosen other
error messages, but the choice is not important as long as we use the
same error measure consistently in all experiments
when investigating the error.

<p>
The error measure \( \hat E \) or \( E \) is referred to as the
\( L_2 \) norm of the discrete error function.
The formula for \( E \) will be frequently used:
$$
\begin{equation}
E = \sqrt{\Delta t\sum_{n=0}^N e_n^2}
\label{decay:E}
\end{equation}
$$
The corresponding Python code, using array arithmetics, reads

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span><span style="color: #AA22FF">sum</span>(e<span style="color: #666666">**2</span>))
</pre></div>
<p>
The <tt>sum</tt> function comes from <tt>numpy</tt> and computes the sum of the elements
of an array. Also the <tt>sqrt</tt> function is from <tt>numpy</tt> and computes the
square root of each element in the array argument.

<p>
Instead of doing array computing we can compute with
one element at a time:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">m <span style="color: #666666">=</span> <span style="color: #AA22FF">len</span>(u)     <span style="color: #008800; font-style: italic"># length of u array (alt: u.size)</span>
u_e <span style="color: #666666">=</span> zeros(m)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(m):
    u_e[i] <span style="color: #666666">=</span> exact_solution(t, a, I)
    t <span style="color: #666666">=</span> t <span style="color: #666666">+</span> dt
e <span style="color: #666666">=</span> zeros(m)
<span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(m):
    e[i] <span style="color: #666666">=</span> u_e[i] <span style="color: #666666">-</span> u[i]
s <span style="color: #666666">=</span> <span style="color: #666666">0</span>  <span style="color: #008800; font-style: italic"># summation variable</span>
<span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(m):
    s <span style="color: #666666">=</span> s <span style="color: #666666">+</span> e[i]<span style="color: #666666">**2</span>
error <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span>s)
</pre></div>
<p>
Such element-wise computing, often called <em>scalar</em> computing, takes
more code, is less readable, and runs much slower than array computing.

<p>

<p>

<h3>Plotting solutions  <a name="___sec23"></a></h3>
<p>
Having the <tt>t</tt> and <tt>u</tt> arrays, the approximate solution <tt>u</tt> is visualized
by <tt>plot(t, u)</tt>:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>
plot(t, u)
show()
</pre></div>
<p>
It will be illustrative to also plot \( \uex(t) \) for comparison. Doing a
<tt>plot(t, u_e)</tt> is not exactly what we want: the <tt>plot</tt> function draws
straight lines between the discrete points <tt>(t[n], u_e[n])</tt> while
\( \uex(t) \) varies as an exponential function between the mesh points.
The technique for showing the "exact" variation of \( \uex(t) \) between
the mesh points is to introduce a very fine mesh for \( \uex(t) \):

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)      <span style="color: #008800; font-style: italic"># fine mesh</span>
u_e <span style="color: #666666">=</span> exact_solution(t_e, I, a)
plot(t,   u,   <span style="color: #BB4444">&#39;r-&#39;</span>)            <span style="color: #008800; font-style: italic"># red  line for u</span>
plot(t_e, u_e, <span style="color: #BB4444">&#39;b-&#39;</span>)            <span style="color: #008800; font-style: italic"># blue line for u_e</span>
</pre></div>
<p>

<p>
With more than one curve in the plot we need to associate each curve
with a legend. We also want appropriate names on the axis, a title,
and a file containing the plot as an image for inclusion in reports.
The Matplotlib package (<tt>matplotlib.pyplot</tt>) contains functions for
this purpose. The names of the functions are similar to the plotting
functions known from MATLAB.  A complete plot session then becomes

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>

figure()                          <span style="color: #008800; font-style: italic"># create new plot</span>
t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)        <span style="color: #008800; font-style: italic"># fine mesh for u_e</span>
u_e <span style="color: #666666">=</span> exact_solution(t_e, I, a)
plot(t,   u,   <span style="color: #BB4444">&#39;r--o&#39;</span>)            <span style="color: #008800; font-style: italic"># red dashes w/circles</span>
plot(t_e, u_e, <span style="color: #BB4444">&#39;b-&#39;</span>)              <span style="color: #008800; font-style: italic"># blue line for exact sol.</span>
legend([<span style="color: #BB4444">&#39;numerical&#39;</span>, <span style="color: #BB4444">&#39;exact&#39;</span>])
xlabel(<span style="color: #BB4444">&#39;t&#39;</span>)
ylabel(<span style="color: #BB4444">&#39;u&#39;</span>)
title(<span style="color: #BB4444">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> (theta, dt))
savefig(<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">.png&#39;</span> <span style="color: #666666">%</span> (theta, dt))
show()
</pre></div>
<p>
Note that <tt>savefig</tt> here creates a PNG file whose name reflects the
values of \( \theta \) and \( \Delta t \) so that we can easily distinguish
files from different runs with \( \theta \) and \( \Delta t \).

<p>
A bit more sophisticated and easy-to-read filename can be generated
by mapping the \( \theta \) value to acronyms for the three common
schemes: FE (Forward Euler, \( \theta=0 \)), BE (Backward Euler, \( \theta=1 \)),
CN (Crank-Nicolson, \( \theta=0.5 \)). A Python dictionary is ideal for such
a mapping from numbers to strings:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">theta2name <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #BB4444">&#39;FE&#39;</span>, <span style="color: #666666">1</span>: <span style="color: #BB4444">&#39;BE&#39;</span>, <span style="color: #666666">0.5</span>: <span style="color: #BB4444">&#39;CN&#39;</span>}
savefig(<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
</pre></div>
<p>

<p>
Let us wrap up the computation of the error measure and all the
plotting statements in a function <tt>explore</tt>. This function
can be called for various \( \theta \) and \( \Delta t \) values
to see how the error varies with the method and the mesh resolution:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">explore</span>(I, a, T, dt, theta<span style="color: #666666">=0.5</span>, makeplot<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Run a case with the solver, compute error measure,</span>
<span style="color: #BB4444; font-style: italic">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    u, t <span style="color: #666666">=</span> solver(I, a, T, dt, theta)  <span style="color: #008800; font-style: italic"># Numerical solution</span>
    u_e <span style="color: #666666">=</span> exact_solution(t, I, a)
    e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
    E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span><span style="color: #AA22FF">sum</span>(e<span style="color: #666666">**2</span>))
    <span style="color: #AA22FF; font-weight: bold">if</span> makeplot:
        figure()                         <span style="color: #008800; font-style: italic"># create new plot</span>
        t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)       <span style="color: #008800; font-style: italic"># fine mesh for u_e</span>
        u_e <span style="color: #666666">=</span> exact_solution(t_e, I, a)
        plot(t,   u,   <span style="color: #BB4444">&#39;r--o&#39;</span>)           <span style="color: #008800; font-style: italic"># red dashes w/circles</span>
        plot(t_e, u_e, <span style="color: #BB4444">&#39;b-&#39;</span>)             <span style="color: #008800; font-style: italic"># blue line for exact sol.</span>
        legend([<span style="color: #BB4444">&#39;numerical&#39;</span>, <span style="color: #BB4444">&#39;exact&#39;</span>])
        xlabel(<span style="color: #BB4444">&#39;t&#39;</span>)
        ylabel(<span style="color: #BB4444">&#39;u&#39;</span>)
        title(<span style="color: #BB4444">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> (theta, dt))
        theta2name <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #BB4444">&#39;FE&#39;</span>, <span style="color: #666666">1</span>: <span style="color: #BB4444">&#39;BE&#39;</span>, <span style="color: #666666">0.5</span>: <span style="color: #BB4444">&#39;CN&#39;</span>}
        savefig(<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
        savefig(<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">.pdf&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
        savefig(<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">.eps&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
        show()
    <span style="color: #AA22FF; font-weight: bold">return</span> E
</pre></div>
<p>

<p>
The <tt>figure()</tt> call is key here: without it, a new <tt>plot</tt> command will
draw the new pair of curves in the same plot window, while we want
the different pairs to appear in separate windows and files.
Calling <tt>figure()</tt> ensures this.

<p>
The complete code resides in the file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_mpl.py"><tt>dc_plot_mpl.py</tt></a>.
Running this program results in
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_plot_mpl.py
0.0   0.40:    2.105E-01
0.0   0.04:    1.449E-02
0.5   0.40:    3.362E-02
0.5   0.04:    1.887E-04
1.0   0.40:    1.030E-01
1.0   0.04:    1.382E-02
</pre></div>
<p>
We observe that reducing \( \Delta t \) by a factor of 10 increases the
accuracy for all three methods (\( \theta \) values). We also see that
the combination of \( \theta=0.5 \) and a small time step \( \Delta t =0.04 \)
gives a much more accurate solution, and that \( \theta=0 \) and \( \theta=0 \)
with \( \Delta t = 0.4 \) result in the least accurate solutions.

<p>
Figure <a href="#decay:fig:FE1">6</a> demonstrates that the numerical solution for
\( \Delta t=0.4 \) clearly lies below the exact curve, but that the
accuracy improves considerably by using 1/10 of this time step.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  The Forward Euler scheme for two values of the time step. <a name="decay:fig:FE1"></a> </p></center>
<p><img src="fig-decay/FE1.png" align="bottom" width=600,></p>
</center>

<p>

<p>
Mounting two PNG files, as done in the figure, is easily done by the
<a href="http://www.imagemagick.org/script/montage.php"><tt>montage</tt></a> program
from the ImageMagick suite:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; montage -background white -geometry 100% -tile 2x1 <span style="color: #BB6622; font-weight: bold">\</span>
          FE_0.4.png FE_0.04.png FE1.png
</pre></div>
<p>
The <tt>-geometry</tt> argument is used to specify the size of the image, and here
we preserve the individual sizes of the images. The <tt>-tile HxV</tt> option
specifies <tt>H</tt> images in the horizontal direction and <tt>V</tt> images in
the vertical direction. A series of image files to be combined are then listed,
with the name of the resulting combined image, here <tt>FE1.png</tt> at the end.

<p>
For \LaTeX{} reports it is not recommended to use <tt>montage</tt> and PNG files
as the result has too low resolution. Instead, plots should be made
in the PDF format and combined using the <tt>pdftk</tt> and <tt>pdfnup</tt> tools
(on Linux/Unix):

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; pdftk FE_0.4.png FE_0.04.png output tmp.pdf
Terminal&gt; pdfnup --nup 2x1 tmp.pdf  <span style="color: #008800; font-style: italic"># output in tmp-nup.pdf</span>
Terminal&gt; mv tmp-nup.pdf FE1.png
</pre></div>
<p>

<p>
The behavior of the two other schemes is shown in Figures <a href="#decay:fig:BE1">7</a>
and <a href="#decay:fig:CN1">8</a>. Crank-Nicolson is obviously the most accurate
scheme from this visual point of view.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  The Backward Euler scheme for two values of the time step. <a name="decay:fig:BE1"></a> </p></center>
<p><img src="fig-decay/BE1.png" align="bottom" width=600></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  The Crank-Nicolson scheme for two values of the time step. <a name="decay:fig:CN1"></a> </p></center>
<p><img src="fig-decay/CN1.png" align="bottom" width=600></p>
</center>

<p>

<p>

<p>

<h3>Plotting with SciTools  <a name="___sec24"></a></h3>
<p>
The <a href="http://code.google.com/p/scitools">SciTools package</a> provides a
unified plotting interface, called Easyviz, to many different plotting
packages, including Matplotlib. The syntax is very similar to that of
Matplotlib and MATLAB. In fact, the plotting commands shown above look
the same in SciTool's Easyviz interface, apart from the import
statement, which reads

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre></div>
<p>
This statement performs a <tt>from numpy import *</tt> as well as an import
of the most common pieces of the Easyviz (<tt>scitools.easyviz</tt>) package,
along with some additional numerical functionality.

<p>
With Easyviz one can, using an extended <tt>plot</tt> command,
merge several plotting commands into one,
using keyword arguments:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(t,   u,   <span style="color: #BB4444">&#39;r--o&#39;</span>,           <span style="color: #008800; font-style: italic"># red dashes w/circles</span>
     t_e, u_e, <span style="color: #BB4444">&#39;b-&#39;</span>,             <span style="color: #008800; font-style: italic"># blue line for exact sol.</span>
     legend<span style="color: #666666">=</span>[<span style="color: #BB4444">&#39;numerical&#39;</span>, <span style="color: #BB4444">&#39;exact&#39;</span>],
     xlabel<span style="color: #666666">=</span><span style="color: #BB4444">&#39;t&#39;</span>,
     ylabel<span style="color: #666666">=</span><span style="color: #BB4444">&#39;u&#39;</span>,
     title<span style="color: #666666">=</span><span style="color: #BB4444">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> (theta, dt),
     savefig<span style="color: #666666">=</span><span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt),
     show<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>)
</pre></div>
<p>
The <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_st.py"><tt>dc_plot_st.py</tt></a> file
contains such a demo.

<p>
By default, Easyviz employs Matplotlib for plotting, but <a href="http://www.gnuplot.info/">Gnuplot</a> and <a href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a> are viable alternatives:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_plot_st.py --SCITOOLS_easyviz_backend gnuplot
Terminal&gt; python dc_plot_st.py --SCITOOLS_easyviz_backend grace
</pre></div>
<p>
The backend used for creating plots (and numerous other options)
can be permanently set in SciTool's configuration file.

<p>
All the Gnuplot windows are launched without any need to kill one before
the next one pops up (as is the case with Matplotlib) and one can
press the key 'q' anywhere in a plot window to kill it.
Another advantage of Gnuplot is the automatic choice of sensible
and distinguishable line types in black-and-white PostScript
files (produced by <tt>savefig('myplot.eps')</tt>).

<p>
Regarding functionality for annotating plots with title, labels on the
axis, legends, etc., we refer to the documentation of Matplotlib and
SciTools for more detailed information on the syntax. The hope is that
the programming syntax explained so far suffices for understanding the
code and learning more from a combination of the forthcoming examples
and other resources such as books and web pages.

<p>

<h3>Creating user interfaces  <a name="___sec25"></a></h3>
<p>

<p>
It is good programming practice to let programs read input from the user
rather than require the user to edit the source code when trying out
new values of input parameters.
Reading input from the command line is a simple and flexible way of interacting
with the user. Python stores all the command-line arguments in
the list <tt>sys.argv</tt>, and there are, in principle, two ways of programming with
command-line arguments in Python:

<p>

<ul>
 <li> Decide upon a sequence of parameters on the command line and read
   their values directly from the <tt>sys.argv</tt> list (<tt>sys.argv[0]</tt> is
   the just program name).
 <li> Use option-value pairs (<tt>--option value</tt>) on
   the command line to override default values of input parameters,
   and use the <tt>argparse.ArgumentParser</tt> tool to interact with the command line.
</ul>

Both strategies will be illustrated next.

<p>

<h4>Reading a sequence of command-line arguments  <a name="___sec26"></a></h4>
<p>

<p>
The <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_mpl.py"><tt>dc_plot_mpl.py</tt></a>
program needs the following input data: \( I \), \( a \), \( T \), an option to
turn the plot on or off (<tt>makeplot</tt>), and a list of \( \Delta t \) values.

<p>
The simplest way of reading this input from the command line is to say
that the first four command-line arguments correspond to the first
four points in the list above, in that order, and that the rest of the
command-line arguments are the \( \Delta t \) values.  The input given for
<tt>makeplot</tt> can be a string among <tt>'on'</tt>, <tt>'off'</tt>, <tt>'True'</tt>, and
<tt>'False'</tt>. The code for reading this input is most conveniently put in
a function:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">read_command_line</span>():
    <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">len</span>(sys<span style="color: #666666">.</span>argv) <span style="color: #666666">&lt;</span> <span style="color: #666666">6</span>:
        <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Usage: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444"> I a T on/off dt1 dt2 dt3 ...&#39;</span> <span style="color: #666666">%</span> \ 
              sys<span style="color: #666666">.</span>argv[<span style="color: #666666">0</span>]; sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)  <span style="color: #008800; font-style: italic"># abort</span>

    I <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
    a <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">2</span>])
    T <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">3</span>])
    makeplot <span style="color: #666666">=</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">4</span>] <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #BB4444">&#39;on&#39;</span>, <span style="color: #BB4444">&#39;True&#39;</span>)
    dt_values <span style="color: #666666">=</span> [<span style="color: #AA22FF">float</span>(arg) <span style="color: #AA22FF; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">5</span>:]]

    <span style="color: #AA22FF; font-weight: bold">return</span> I, a, T, makeplot, dt_values
</pre></div>
<p>

<p>

<p>
One should note the following about the constructions in the program above:

<p>

<ul>
  <li> Everything on the command line ends up in a <em>string</em> in
    the list <tt>sys.argv</tt>. Explicit conversion to, e.g., a <tt>float</tt> object is
    required if the string as a number we want to compute with.
  <li> The value of <tt>makeplot</tt> is determined from a boolean expression,
    which becomes <tt>True</tt> if the command-line argument is either <tt>'on'</tt> or
    <tt>'True'</tt>, and <tt>False</tt> otherwise.
  <li> It is easy to build the list of \( \Delta t \) values: we simply run through
    the rest of the list, <tt>sys.argv</tt>, convert each command-line argument
    to <tt>float</tt>, and collect these <tt>float</tt> objects in a list, using the
    compact and convenient <em>list comprehension</em> syntax in Python.
</ul>

The loops over \( \theta \) and \( \Delta t \) values can be coded in a <tt>main</tt> function:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">main</span>():
    I, a, T, makeplot, dt_values <span style="color: #666666">=</span> read_command_line()
    <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>:
        <span style="color: #AA22FF; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values:
            E <span style="color: #666666">=</span> explore(I, a, T, dt, theta, makeplot)
            <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%3.1f</span><span style="color: #BB4444"> </span><span style="color: #BB6688; font-weight: bold">%6.2f</span><span style="color: #BB4444">: </span><span style="color: #BB6688; font-weight: bold">%12.3E</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> (theta, dt, E)
</pre></div>
<p>

<p>
The complete program can be found in <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_cml.py"><tt>dc_cml.py</tt></a>.

<p>

<h4>Working with an argument parser  <a name="___sec27"></a></h4>
<p>

<p>
Python's <tt>ArgumentParser</tt> tool in the <tt>argparse</tt> module makes it
easy to create a professional command-line interface to any
program. The <a href="http://docs.python.org/library/argparse.html">documentation of `ArgumentParser`</a> demonstrates its
versatile applications, so we shall here just list an example
containing the most used features.  On the command line we want to
specify option value pairs for \( I \), \( a \), and \( T \), e.g., <tt>--a 3.5 --I 2
--T 2</tt>. Including <tt>--makeplot</tt> turns the plot on and excluding this
option turns the plot off.  The \( \Delta t \) values can be given as
<tt>--dt 1 0.5 0.25 0.1 0.01</tt>.  Each parameter must have a sensible
default value so that we specify the option on the command line only
when the default value is not suitable.

<p>
We introduce a function for defining the mentioned command-line options:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">define_command_line_options</span>():
    <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">argparse</span>
    parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser()
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BB4444">&#39;--I&#39;</span>, <span style="color: #BB4444">&#39;--initial_condition&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>,
                        default<span style="color: #666666">=1.0</span>, help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;initial condition, u(0)&#39;</span>,
                        metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;I&#39;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BB4444">&#39;--a&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>,
                        default<span style="color: #666666">=1.0</span>, help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;coefficient in ODE&#39;</span>,
                        metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;a&#39;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BB4444">&#39;--T&#39;</span>, <span style="color: #BB4444">&#39;--stop_time&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>,
                        default<span style="color: #666666">=1.0</span>, help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;end time of simulation&#39;</span>,
                        metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;T&#39;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BB4444">&#39;--makeplot&#39;</span>, action<span style="color: #666666">=</span><span style="color: #BB4444">&#39;store_true&#39;</span>,
                        help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;display plot or not&#39;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BB4444">&#39;--dt&#39;</span>, <span style="color: #BB4444">&#39;--time_step_values&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>,
                        default<span style="color: #666666">=</span>[<span style="color: #666666">1.0</span>], help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;time step values&#39;</span>,
                        metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;dt&#39;</span>, nargs<span style="color: #666666">=</span><span style="color: #BB4444">&#39;+&#39;</span>, dest<span style="color: #666666">=</span><span style="color: #BB4444">&#39;dt_values&#39;</span>)
    <span style="color: #AA22FF; font-weight: bold">return</span> parser
</pre></div>
<p>

<p>
Each command-line option is defined through the <tt>parser.add_argument</tt>
method. Alternative options, like the short <tt>--I</tt> and the more
explaining version <tt>--initial_condition</tt> can be defined. Other arguments
are <tt>type</tt> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <tt>-h</tt> or <tt>--help</tt> is
included. The <tt>metavar</tt> argument specifies the value associated with
the option when the help string is printed. For example, the option for
\( I \) has this help output:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_argparse.py -h
  ...
  --I I, --initial_condition I
                        initial condition, u<span style="color: #666666">(</span>0<span style="color: #666666">)</span>
  ...
</pre></div>
<p>
The structure of this output is

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  --I metavar, --initial_condition metavar
                        help-string
</pre></div>
<p>

<p>
The <tt>--makeplot</tt> option is a pure flag without any value, implying a
true value if the flag is present and otherwise a false value. The
<tt>action='store_true'</tt> makes an option for such a flag.

<p>
Finally, the <tt>--dt</tt> option demonstrates how to allow for more than one
value (separated by blanks) through the <tt>nargs='+'</tt> keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the <tt>dist</tt> keyword argument, which for the <tt>--dt</tt> option reads
<tt>dt_values</tt>. Without the <tt>dest</tt> argument, the value of option <tt>--opt</tt>
is stored as the attribute <tt>opt</tt>.

<p>
The code below demonstrates how to read the command line and extract
the values for each option:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">read_command_line</span>():
    parser <span style="color: #666666">=</span> define_command_line_options()
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args()
    <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;I={}, a={}, T={}, makeplot={}, dt_values={}&#39;</span><span style="color: #666666">.</span>format(
        args<span style="color: #666666">.</span>I, args<span style="color: #666666">.</span>a, args<span style="color: #666666">.</span>T, args<span style="color: #666666">.</span>makeplot, args<span style="color: #666666">.</span>dt_values)
    <span style="color: #AA22FF; font-weight: bold">return</span> args<span style="color: #666666">.</span>I, args<span style="color: #666666">.</span>a, args<span style="color: #666666">.</span>T, args<span style="color: #666666">.</span>makeplot, args<span style="color: #666666">.</span>dt_values
</pre></div>
<p>

<p>
The <tt>main</tt> function remains the same as in the <tt>dc_cml.py</tt> code based
on reading from <tt>sys.argv</tt> directly. A complete program using the
demo above of <tt>ArgumentParser</tt> appears in the file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_argparse.py"><tt>dc_argparse.py</tt></a>.

<p>

<p>

<h3>Computing convergence rates <a name="decay:convergence:rate"></a></h3>
<p>

<p>

<p>
We normally expect that the error \( E \) in the numerical solution is
reduced if the mesh size \( \Delta t \) is decreased. More specifically,
many numerical methods obey a power-law relation between \( E \) and
\( \Delta t \):

<p>
$$
\begin{equation}
E = C\Delta t^r,
\label{decay:E:dt}
\end{equation}
$$
where \( C \) and \( r \) are (usually unknown) constants independent of \( \Delta t \).
The formula \eqref{decay:E:dt} is viewed as an asymptotic model valid for
sufficiently small \( \Delta t \). How small is normally hard to estimate
without doing numerical estimations of \( r \).

<p>
The parameter \( r \) is known as the <em>convergence rate</em>. For example,
if the convergence rate is 2, halving \( \Delta t \) reduces the error by
a factor of 4. Diminishing \( \Delta t \) then has a greater impact on
the error compared with methods that have \( r=1 \). For a given value of \( r \),
we refer to the method as of \( r \)-th order. First- and second-order
methods are most common in scientific computing.

<p>

<h4>Estimating \( r \)  <a name="___sec29"></a></h4>
<p>
There are two ways of estimating \( C \) and \( r \) based on a set of
\( m \) simulations with corresponding pairs \( (\Delta t_i, E_i) \), \( i=0,\ldots,m-1 \),
and \( \Delta t_{i} < \Delta t_{i-1} \) (i.e., decreasing cell size).

<p>

<ol>
 <li> Take the logarithm of \eqref{decay:E:dt}, \( \ln E = r\ln \Delta t + \ln C \),
    and fit a straight line to the data points \( (\Delta t_i, E_i) \),
    \( i=0,\ldots,m-1 \).
 <li> Consider two consecutive experiments, \( (\Delta t_i, E_i) \) and
    \( (\Delta t_{i-1}, E_{i-1}) \). Dividing the equation
    \( E_{i-1}=C\Delta t_{i-1}^r \) by \( E_{i}=C\Delta t_{i}^r \) and solving
    for \( r \) yields
</ol>

$$
\begin{equation}
r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}
\label{decay:conv:rate}
\end{equation}
$$
for \( i=1,=\ldots,m-1 \).

<p>
The disadvantage of method 1 is that \eqref{decay:E:dt} might not be valid
for the coarsest meshes (largest \( \Delta t \) values), and fitting a line
to all the data points is then misleading.  Method 2 computes
convergence rates for pairs of experiments and allows us to see
if the sequence \( r_i \) converges to some value as \( i\rightarrow m-2 \).
The final \( r_{m-2} \) can then be taken as the convergence rate.
If the coarsest meshes have a differing rate, the corresponding
time steps are probably too large for \eqref{decay:E:dt} to be valid.
That is, those time steps lie outside the asymptotic range of
\( \Delta t \) values where the error behave like \eqref{decay:E:dt}.

<p>

<p>

<h4>Implementation <a name="decay:impl1"></a></h4>
<p>
It is straightforward to extend the <tt>main</tt> function in the program
<tt>dc_argparse.py</tt> with statements for computing \( r_0, r_1, \ldots, r_{m-2} \)
from \eqref{decay:E:dt}:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #AA22FF; font-weight: bold">import</span> log

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">main</span>():
    I, a, T, makeplot, dt_values <span style="color: #666666">=</span> read_command_line()
    r <span style="color: #666666">=</span> {}  <span style="color: #008800; font-style: italic"># estimated convergence rates</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>:
        E_values <span style="color: #666666">=</span> []
        <span style="color: #AA22FF; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values:
            E <span style="color: #666666">=</span> explore(I, a, T, dt, theta, makeplot<span style="color: #666666">=</span><span style="color: #AA22FF">False</span>)
            E_values<span style="color: #666666">.</span>append(E)

        <span style="color: #008800; font-style: italic"># Compute convergence rates</span>
        m <span style="color: #666666">=</span> <span style="color: #AA22FF">len</span>(dt_values)
        r[theta] <span style="color: #666666">=</span> [log(E_values[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>E_values[i])<span style="color: #666666">/</span>
                    log(dt_values[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>dt_values[i])
                    <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #666666">1</span>, m, <span style="color: #666666">1</span>)]

    <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> r:
        <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BB4444">Pairwise convergence rates for theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">:&#39;</span> <span style="color: #666666">%</span> theta
        <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39; &#39;</span><span style="color: #666666">.</span>join([<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> r_ <span style="color: #AA22FF; font-weight: bold">for</span> r_ <span style="color: #AA22FF; font-weight: bold">in</span> r[theta]])
    <span style="color: #AA22FF; font-weight: bold">return</span> r
</pre></div>
<p>
The program is called <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_convrate.py"><tt>dc_convrate.py</tt></a>.

<p>

<p>
The <tt>r</tt> object is a <em>dictionary of lists</em>. The keys in this
dictionary are the \( \theta \) values. For example,
<tt>r[1]</tt> holds the list of the \( r_i \) values corresponding to
\( \theta=1 \). In the loop <tt>for theta in r</tt>, the loop variable <tt>theta</tt>
takes on the values of the keys in the dictionary <tt>r</tt> (in an
undetermined ordering). We could simply do a <tt>print r[theta]</tt>
inside the loop, but this would typically yield output of
the convergence rates with 16 decimals:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[1.331919482274763, 1.1488178494691532, ...]
</pre></div>
<p>

<p>
Instead, we format each number with 2 decimals, using a list
comprehension to turn the list of numbers, <tt>r[theta]</tt>, into
a list of formatted strings. Then we join these strings
with a space in between to get a sequence of rates on one line
in the terminal window. More generally, <tt>d.join(list)</tt> joins the
strings in the list <tt>list</tt> to one string, with <tt>d</tt>
as delimiter between <tt>list[0]</tt>, <tt>list[1]</tt>, etc.

<p>
Here is an example on the outcome of the convergence rate computations:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_convrate.py --dt 0.5 0.25 0.1 0.05 0.025 0.01
...
Pairwise convergence rates <span style="color: #AA22FF; font-weight: bold">for </span><span style="color: #B8860B">theta</span><span style="color: #666666">=</span>0:
1.33 1.15 1.07 1.03 1.02

Pairwise convergence rates <span style="color: #AA22FF; font-weight: bold">for </span><span style="color: #B8860B">theta</span><span style="color: #666666">=</span>0.5:
2.14 2.07 2.03 2.01 2.01

Pairwise convergence rates <span style="color: #AA22FF; font-weight: bold">for </span><span style="color: #B8860B">theta</span><span style="color: #666666">=</span>1:
0.98 0.99 0.99 1.00 1.00
</pre></div>
<p>
The Forward and Backward Euler methods seem to have an \( r \) value which
stabilizes at 1, while the Crank-Nicolson seems to be a second-order
method with \( r=2 \).

<p>

<p>
Very often, we have some theory that predicts what \( r \) is for a numerical
method. Various theoretical error measures for the \( \theta \)-rule point to
\( r=2 \) for \( \theta =0.5 \) and \( r=1 \) otherwise. The computed estimates of \( r \) are
in very good agreement with these theoretical values.

<p>
The strong practical application of computing convergence rates is for
verification: wrong convergence rates point to errors in the code, and
correct convergence rates brings evidence that the implementation is
correct. Experience shows that bugs in the code easily destroys the
expected convergence rate.

<p>

<h4>Debugging via convergence rates  <a name="___sec31"></a></h4>
<p>
Let us experiment with bugs and see the implication on the convergence
rate. We may, for instance, forget to multiply by <tt>a</tt> in the denominator
in the updating formula for <tt>u[n+1]</tt>:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt)<span style="color: #666666">*</span>u[n]
</pre></div>
<p>
Running the same <tt>dc_convrate.py</tt> command as above gives the expected
convergence rates (!). Why? The reason is that we just specified
the \( \Delta t \) values are relied on default values for other
parameters. The default value of \( a \) is 1. Forgetting the factor
<tt>a</tt> has then no effect. This example shows how importance it is to
avoid parameters that are 1 or 0 when verifying implementations.
Running the code <tt>dc_v0.py</tt> with \( a=2.1 \) and \( I=0.1 \) yields

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_convrate.py --a 2.1 --I 0.1  <span style="color: #BB6622; font-weight: bold">\</span>
          --dt 0.5 0.25 0.1 0.05 0.025 0.01
...
Pairwise convergence rates <span style="color: #AA22FF; font-weight: bold">for </span><span style="color: #B8860B">theta</span><span style="color: #666666">=</span>0:
1.49 1.18 1.07 1.04 1.02

Pairwise convergence rates <span style="color: #AA22FF; font-weight: bold">for </span><span style="color: #B8860B">theta</span><span style="color: #666666">=</span>0.5:
-1.42 -0.22 -0.07 -0.03 -0.01

Pairwise convergence rates <span style="color: #AA22FF; font-weight: bold">for </span><span style="color: #B8860B">theta</span><span style="color: #666666">=</span>1:
0.21 0.12 0.06 0.03 0.01
</pre></div>
<p>
This time we see that the expected convergence rates for the Crank-Nicolson and
Backward Euler methods are not obtained, while \( r=1 \) for the Forward Euler
method. The reason for correct rate in the latter case is that \( \theta=0 \)
and the wrong <tt>theta*dt</tt> term in the denominator vanishes anyway.

<p>
The error

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[n]
</pre></div>
<p>
manifests itself through wrong rates \( r\approx 0 \) for all three methods.
About the same results arise from an erroneous initial condition, <tt>u[0] = 1</tt>,
or wrong loop limits, <tt>range(1,N)</tt>. It seems that in this simple
problem, most bugs we can think of are detected by the convergence rate
test, provided the values of the input data do not hide the bug.

<p>
A <tt>verify_convergence_rate</tt> function could compute the dictionary of
list via <tt>main</tt> and check if the final rate estimates (\( r_{m-2} \))
are sufficiently close to the expected ones. A tolerance of 0.1
seems appropriate, given the uncertainty in estimating \( r \):

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">verify_convergence_rate</span>():
    r <span style="color: #666666">=</span> main()
    tol <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    expected_rates <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #666666">1</span>, <span style="color: #666666">1</span>: <span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>: <span style="color: #666666">2</span>}
    <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> r:
        r_final <span style="color: #666666">=</span> r[theta][<span style="color: #666666">-1</span>]
        diff <span style="color: #666666">=</span> <span style="color: #AA22FF">abs</span>(expected_rates[theta] <span style="color: #666666">-</span> r_final)
        <span style="color: #AA22FF; font-weight: bold">if</span> diff <span style="color: #666666">&gt;</span> tol:
            <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF">False</span>
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF">True</span>  <span style="color: #008800; font-style: italic"># all tests passed</span>
</pre></div>
<p>
We remark that <tt>r[theta]</tt> is a list and the last element in any list
can be extracted by the index <tt>-1</tt>.

<p>

<p>

<p>

<h3>Memory-saving implementation  <a name="___sec32"></a></h3>
<p>
The memory storage requirements of our implementations so far consists
mainly of the <tt>u</tt> and <tt>t</tt> arrays, both of length \( N+1 \), plus some other
temporary arrays that Python needs for intermediate results if we do
array arithmetics in our program (e.g., <tt>I*exp(-a*t)</tt> needs to store
<tt>a*t</tt> before <tt>-</tt> can be applied to it and then <tt>exp</tt>).  The
extremely modest storage requirements of simple ODE problems put no
restrictions on the formulations of the algorithm and implementation.
Nevertheless, when the methods for ODEs used here are applied to
three-dimensional partial differential equation (PDE) problems,
memory storage requirements
suddenly become an issue.

<p>
The PDE counterpart to our model problem
\( u'=-a \) is a diffusion equation \( u_t = a\nabla^2 u \) posed on a
space-time domain. The discrete representation of this domain may in
3D be a spatial mesh of \( M^3 \) points and a time mesh of \( N \) points. A
typical desired value for \( M \) is 100 in many applications, or even
\( 1000 \).  Storing all the computed \( u \) values, like we have done in the
programs so far, demands storage of some arrays of size \( M^3N \), giving
a factor of \( M^3 \) larger storage demands compared to our ODE
programs. Each real number in the array for \( u \) requires 8 bytes of
storage, resulting in a demand for 8 Gb of memory for only one array.
In such cases one needs good ideas on how to lower the storage
requirements. Fortunately, we can usually get rid of the \( M^3 \)
factor. Below we explain how this is done, and the technique is almost
always applied in implementations of PDE problems.

<p>
<!-- Fortunately, the methods we use to solve ODEs -->
<!-- and PDEs were mostly developed in a time where the size of a computer's -->
<!-- memory was very small compared to today's standards, and researchers -->
<!-- were therefore forced to always minimize the memory usage. As a result of -->
<!-- these circumstances, there is still a very strong focus on reducing -->
<!-- memory requirements in scientific computing algorithms. -->

<p>
Let us critically evaluate how much we really need to store in the
computer's memory in our implementation of the \( \theta \) method. To
compute a new \( u^{n+1} \), all we need is \( u^n \). This implies that the
previous \( u^{n-1},u^{n-2},\dots,u^0 \) values do not need to be stored
in an array, although this is convenient for plotting and data
analysis in the program.  Instead of the <tt>u</tt> array we can work with
two variables for real numbers, <tt>u</tt> and <tt>u_1</tt>, representing
\( u^{n+1} \) and \( u^n \) in the algorithm, respectively.  At each time
level, we update <tt>u</tt> from <tt>u_1</tt> and then set <tt>u_1 = u</tt> so that the
computed \( u^{n+1} \) value becomes the "previous" value \( u^n \) at the
next time level. The downside is that we cannot plot the solution
after the simulation is done since only the last two numbers are
available.  The remedy is to store computed values in a file and use
the file for visualizing the solution later.

<p>
We have implemented this memory saving idea in the file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_memsave.py"><tt>dc_memsave.py</tt></a>, which is a
merge of the <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_mpl.py"><tt>dc_plot_mpl.py</tt></a> and
<a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_argparse.py"><tt>dc_argparse.py</tt></a>
programs, using module prefixes <tt>np</tt> for <tt>numpy</tt> and <tt>plt</tt> for
<tt>matplotlib.pyplot</tt>.

<p>
The following function implements the ideas above regarding minimizing
memory usage and storing the solution on file:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solver_memsave</span>(I, a, T, dt, theta, filename<span style="color: #666666">=</span><span style="color: #BB4444">&#39;sol.dat&#39;</span>):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span style="color: #BB4444; font-style: italic">    Minimum use of memory. The solution is store on file</span>
<span style="color: #BB4444; font-style: italic">    (with name filename) for later plotting.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(dt)        <span style="color: #008800; font-style: italic"># avoid integer division</span>
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(<span style="color: #AA22FF">round</span>(T<span style="color: #666666">/</span>dt))  <span style="color: #008800; font-style: italic"># no of intervals</span>

    outfile <span style="color: #666666">=</span> <span style="color: #AA22FF">open</span>(filename, <span style="color: #BB4444">&#39;w&#39;</span>)
    <span style="color: #008800; font-style: italic"># u: time level n+1, u_1: time level n</span>
    t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u_1 <span style="color: #666666">=</span> I
    outfile<span style="color: #666666">.</span>write(<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%.16E</span><span style="color: #BB4444">  </span><span style="color: #BB6688; font-weight: bold">%.16E</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> (t, u_1))
    <span style="color: #AA22FF; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #666666">1</span>, N<span style="color: #666666">+1</span>):
        u <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u_1
        u_1 <span style="color: #666666">=</span> u
        t <span style="color: #666666">+=</span> dt
        outfile<span style="color: #666666">.</span>write(<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%.16E</span><span style="color: #BB4444">  </span><span style="color: #BB6688; font-weight: bold">%.16E</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> (t, u))
    outfile<span style="color: #666666">.</span>close()
    <span style="color: #AA22FF; font-weight: bold">return</span> u, t
</pre></div>
<p>
This code snippet serves as a quick introduction to file writing in Python.
Reading the data in the file into arrays <tt>t</tt> and <tt>u</tt> are done by the
function

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">read_file</span>(filename<span style="color: #666666">=</span><span style="color: #BB4444">&#39;sol.dat&#39;</span>):
    infile <span style="color: #666666">=</span> <span style="color: #AA22FF">open</span>(filename, <span style="color: #BB4444">&#39;r&#39;</span>)
    u <span style="color: #666666">=</span> [];  t <span style="color: #666666">=</span> []
    <span style="color: #AA22FF; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
        <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">len</span>(words) <span style="color: #666666">!=</span> <span style="color: #666666">2</span>:
            <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Found more than two numbers on a line!&#39;</span>, words
            sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)  <span style="color: #008800; font-style: italic"># abort</span>
        t<span style="color: #666666">.</span>append(<span style="color: #AA22FF">float</span>(words[<span style="color: #666666">0</span>]))
        u<span style="color: #666666">.</span>append(<span style="color: #AA22FF">float</span>(words[<span style="color: #666666">1</span>]))
    <span style="color: #AA22FF; font-weight: bold">return</span> np<span style="color: #666666">.</span>array(t), np<span style="color: #666666">.</span>array(u)
</pre></div>
<p>

<p>
This type of file with numbers in rows and columns is very common, and <tt>numpy</tt>
has a function <tt>loadtxt</tt> which loads such tabular data into a two-dimensional
array, say <tt>data</tt>. The number in row <tt>i</tt> and column <tt>j</tt> is then <tt>data[i,j]</tt>.
The whole column number <tt>j</tt> can be extracted by <tt>data[:,j]</tt>.
A version of <tt>read_file</tt> using <tt>np.loadtxt</tt> reads

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">read_file_numpy</span>(filename<span style="color: #666666">=</span><span style="color: #BB4444">&#39;sol.dat&#39;</span>):
    data <span style="color: #666666">=</span> np<span style="color: #666666">.</span>loadtxt(filename)
    t <span style="color: #666666">=</span> data[:,<span style="color: #666666">0</span>]
    u <span style="color: #666666">=</span> data[:,<span style="color: #666666">1</span>]
    <span style="color: #AA22FF; font-weight: bold">return</span> t, u
</pre></div>
<p>

<p>
The present counterpart to the <tt>explore</tt> function from
<a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_mpl.py"><tt>dc_plot_mpl.py</tt></a> must run
<tt>solver_memsave</tt> and then load data from file before we can compute
the error measure and make the plot:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">explore</span>(I, a, T, dt, theta<span style="color: #666666">=0.5</span>, makeplot<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
    filename <span style="color: #666666">=</span> <span style="color: #BB4444">&#39;u.dat&#39;</span>
    u, t <span style="color: #666666">=</span> solver_memsave(I, a, T, dt, theta, filename)

    t, u <span style="color: #666666">=</span> read_file(filename)
    u_e <span style="color: #666666">=</span> exact_solution(t, I, a)
    e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
    E <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(dt<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sum(e<span style="color: #666666">**2</span>))
    <span style="color: #AA22FF; font-weight: bold">if</span> makeplot:
        plt<span style="color: #666666">.</span>figure()
        <span style="color: #666666">...</span>
</pre></div>
<p>

<p>
The <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_memsave.py"><tt>dc_memsave.py</tt></a>
file also includes command-line options <tt>--I</tt>, <tt>--a</tt>, <tt>--T</tt>, <tt>--dt</tt>,
<tt>--theta</tt>, and <tt>--makeplot</tt> for controlling input parameters and
making a single run.  For example,

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_memsave.py --T 10 --theta 1 --dt 2
<span style="color: #B8860B">I</span><span style="color: #666666">=</span>1.0, <span style="color: #B8860B">a</span><span style="color: #666666">=</span>1.0, <span style="color: #B8860B">T</span><span style="color: #666666">=</span>10.0, <span style="color: #B8860B">makeplot</span><span style="color: #666666">=</span>True, <span style="color: #B8860B">theta</span><span style="color: #666666">=</span>1.0, <span style="color: #B8860B">dt</span><span style="color: #666666">=</span>2.0
<span style="color: #B8860B">theta</span><span style="color: #666666">=</span>1.0 <span style="color: #B8860B">dt</span><span style="color: #666666">=</span>2 <span style="color: #B8860B">Error</span><span style="color: #666666">=</span>3.136E-01
</pre></div>
<p>

<p>

<p>

<p>

<p>

<h2>Software engineering  <a name="___sec33"></a></h2>
<p>
Efficient use of differential equation models requires software that is easy to
test and flexible for setting up extensive numerical experiments.
This section introduces three important concepts and their applications
to the exponential decay model:

<p>

<ul>
  <li> Modules
  <li> Testing frameworks
  <li> Implementation with classes
</ul>

<h3>Making a module  <a name="___sec34"></a></h3>
<p>

<p>
The previous sections has outlined numerous different programs, all of
them having their own copy of the <tt>solver</tt> function.  Such copies
of the same piece of code is against the important <em>Don't Repeat
Yourself</em> (DRY) principle in programming.  If we want to change the
<tt>solver</tt> function there should be one and only one place where the
change needs to be performed.

<p>
To clean up the repetitive code snippets scattered among the
<tt>dc_*.py</tt> files, we start by collecting the
various functions we want to keep for the future in one file,
now called <a href="http://github.hplgit.com/INF5620/src/decay/dc_mod.py"><tt>dc_mod.py</tt></a>.
The following functions are copied to this file:

<p>

<ul>
 <li> <tt>solver</tt>
 <li> <tt>verify_three_steps</tt>
 <li> <tt>verify_discrete_solution</tt>
 <li> <tt>explore</tt>
 <li> <tt>define_command_line_options</tt>
 <li> <tt>read_command_line</tt> extended to work both with <tt>sys.argv</tt> directly
   and with an <tt>ArgumentParser</tt> object
 <li> <tt>main</tt> (with convergence rates estimation as in <tt>dc_convrate.py</tt>)
 <li> <tt>verify_convergence_rate</tt>
</ul>

We use Matplotlib for plotting. A sketch of the <tt>dc_mod.py</tt>
file, with complete versions of the modified functions, looks as follows:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solver</span>(I, a, T, dt, theta):
    <span style="color: #666666">...</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">verify_three_steps</span>():
    <span style="color: #666666">...</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">verify_exact_discrete_solution</span>():
    <span style="color: #666666">...</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_solution</span>(t, I, a):
    <span style="color: #666666">...</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">explore</span>(I, a, T, dt, theta<span style="color: #666666">=0.5</span>, makeplot<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
    <span style="color: #666666">...</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">define_command_line_options</span>():
    <span style="color: #666666">...</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">read_command_line</span>(use_argparse<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
    <span style="color: #AA22FF; font-weight: bold">if</span> use_argparse:
        parser <span style="color: #666666">=</span> define_command_line_options()
        args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args()
        <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;I={}, a={}, makeplot={}, dt_values={}&#39;</span><span style="color: #666666">.</span>format(
            args<span style="color: #666666">.</span>I, args<span style="color: #666666">.</span>a, args<span style="color: #666666">.</span>makeplot, args<span style="color: #666666">.</span>dt_values)
        <span style="color: #AA22FF; font-weight: bold">return</span> args<span style="color: #666666">.</span>I, args<span style="color: #666666">.</span>a, args<span style="color: #666666">.</span>makeplot, args<span style="color: #666666">.</span>dt_values
    <span style="color: #AA22FF; font-weight: bold">else</span>:
        <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">len</span>(sys<span style="color: #666666">.</span>argv) <span style="color: #666666">&lt;</span> <span style="color: #666666">6</span>:
            <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Usage: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444"> I a on/off dt1 dt2 dt3 ...&#39;</span> <span style="color: #666666">%</span> \
                  sys<span style="color: #666666">.</span>argv[<span style="color: #666666">0</span>]; sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)

        I <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
        a <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">2</span>])
        T <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">3</span>])
        makeplot <span style="color: #666666">=</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">4</span>] <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #BB4444">&#39;on&#39;</span>, <span style="color: #BB4444">&#39;True&#39;</span>)
        dt_values <span style="color: #666666">=</span> [<span style="color: #AA22FF">float</span>(arg) <span style="color: #AA22FF; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">5</span>:]]

        <span style="color: #AA22FF; font-weight: bold">return</span> I, a, makeplot, dt_values

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">main</span>():
    <span style="color: #666666">...</span>
</pre></div>
<p>

<p>
This <tt>dc_mod.py</tt> file is already a module such that we can import
desired in functions in other programs. For example,

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay_theta</span> <span style="color: #AA22FF; font-weight: bold">import</span> solver
u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1.0</span>, a<span style="color: #666666">=3.0</span>, T<span style="color: #666666">=3</span>, dt<span style="color: #666666">=0.01</span>, theta<span style="color: #666666">=0.5</span>)
</pre></div>
<p>

<p>

<p>
However, it should also be possible to both use <tt>dc_mod.py</tt> as
a module <em>and</em> execute the file as a program that runs <tt>main()</tt>. This is
accomplished by ending the file with a <em>test block</em>:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BB4444">&#39;__main__&#39;</span>:
    main()
</pre></div>
<p>
When <tt>dc_mod.py</tt> is used as a module, <tt>__name__</tt> equals the module
name <tt>decay_theta</tt>, while <tt>__name__</tt> equals <tt>'__main__'</tt> when the
file is run as a program.
Optionally, we could run the verification tests if the word <tt>verify</tt>
is present on the command line and <tt>verify_convergence_rate</tt> could
be tested if <tt>verify_rates</tt> is found on the command line. The
<tt>verify_rates</tt> argument must be removed before we read parameter values from
the command line, other wise <tt>read_command_line</tt> (called by <tt>main</tt>)
will not work properly.

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BB4444">&#39;__main__&#39;</span>:
    <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #BB4444">&#39;verify&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv:
        <span style="color: #AA22FF; font-weight: bold">if</span> verify_three_steps() <span style="color: #AA22FF; font-weight: bold">and</span> verify_discrete_solution():
            <span style="color: #AA22FF; font-weight: bold">pass</span> <span style="color: #008800; font-style: italic"># ok</span>
        <span style="color: #AA22FF; font-weight: bold">else</span>:
            <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Bug in the implementation!&#39;</span>
    <span style="color: #AA22FF; font-weight: bold">elif</span> <span style="color: #BB4444">&#39;verify_rates&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv:
        sys<span style="color: #666666">.</span>argv<span style="color: #666666">.</span>remove(<span style="color: #BB4444">&#39;verify_rates&#39;</span>)
        <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #BB4444">&#39;--dt&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv:
            <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Must assign several dt values&#39;</span>
            sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)  <span style="color: #008800; font-style: italic"># abort</span>
        <span style="color: #AA22FF; font-weight: bold">if</span> verify_convergence_rate():
            <span style="color: #AA22FF; font-weight: bold">pass</span>
        <span style="color: #AA22FF; font-weight: bold">else</span>:
            <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Bug in the implementation!&#39;</span>
    <span style="color: #AA22FF; font-weight: bold">else</span>:
        <span style="color: #008800; font-style: italic"># Perform simulations</span>
        main()
</pre></div>
<p>

<p>

<h3>Prefixing imported functions by the module name  <a name="___sec35"></a></h3>
<p>

<p>
Import statements of the form <tt>from module import *</tt> imports
functions and variables in <tt>module.py</tt> into the current file.
For example, when doing

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre></div>
<p>
we get mathematical functions like <tt>sin</tt> and <tt>exp</tt>
as well as MATLAB-style functions like <tt>linspace</tt> and <tt>plot</tt>,
which can be called by these well-known names.
However, it sometimes becomes confusing to
know where a particular function comes from. Is it from <tt>numpy</tt>? Or
<tt>matplotlib.pyplot</tt>?
Or is it our own function?

<p>
An alternative import is

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span>
</pre></div>
<p>
and such imports require functions to be prefixed by the module name, e.g.,

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t <span style="color: #666666">=</span> numpy<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)
u_e <span style="color: #666666">=</span> I<span style="color: #666666">*</span>numpy<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)
matplotlib<span style="color: #666666">.</span>pyplot<span style="color: #666666">.</span>plot(t, u_e)
</pre></div>
<p>
This is normally regarded as a better habit because it is explicitly stated
from which module a function comes from.

<p>
The modules <tt>numpy</tt> and <tt>matplotlib.pyplot</tt> are so frequently used,
and their full names quite tedious to write, so two standard abbreviations
have evolved in the Python scientific computing community:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)
u_e <span style="color: #666666">=</span> I<span style="color: #666666">*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)
plt<span style="color: #666666">.</span>plot(t, u_e)
</pre></div>
<p>
A version of the <tt>decay_theta</tt> module where we use the <tt>np</tt> and <tt>plt</tt>
prefixes is found in the file
<a href="http://github.hplgit.com/INF5620/src/decay/decay_theta_v2.py"><tt>decay_theta_v2.py</tt></a>.

<p>
The downside of prefixing functions by the module name is that
mathematical expressions like \( e^{-at}\sin(2\pi t) \) gets
cluttered with module names,
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">numpy<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>numpy<span style="color: #666666">.</span>sin(<span style="color: #666666">2</span>(numpy<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>t)
<span style="color: #008800; font-style: italic"># or</span>
np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(<span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>t)
</pre></div>
<p>
Such an expression looks like <tt>exp(-a*t)*sin(2*pi*t)</tt> in most
other programming languages. Similarly,
<tt>np.linspace</tt> and <tt>plt.plot</tt> look less familiar to people who are
used to MATLAB and who have not adopted Python's prefix style.
Whether to do <tt>from module import *</tt> or <tt>import module</tt> depends
on personal taste and the problem at hand. In these writings we use
<tt>from module import</tt> in shorter programs where similarity with
MATLAB could be an advantage, and where a one-to-one correspondence between
mathematical formulas and Python expressions is important.
The style <tt>import module</tt> is preferred inside Python modules (see
<a href="#decay:exer:module1">Exercise 9: Make a module</a> for a demonstration).

<p>

<p>

<h3>Doctests  <a name="___sec36"></a></h3>
<p>

<p>
We have emphasized how important it is to be able to run tests in the
program at any time. This was solved by calling various <tt>verify*</tt>
functions in the previous examples. However, there exists
well-established procedures and corresponding tools for automating
checking of tests. We shall briefly demonstrate two important
techniques: <em>doctest</em> and <em>unit testing</em>. The corresponding files are
the modules <a href="http://github.hplgit.com/INF5620/src/decay/dc_mod_doctest.py"><tt>dc_mod_doctest.py</tt></a>
and <a href="http://github.hplgit.com/INF5620/src/decay/dc_mod_unittest.py"><tt>dc_mod_unittest.py</tt></a>.

<p>

<p>
Doc strings (the first string after the function header) are used to
document the purpose of functions and their arguments. Very often it
is instructive to include an example on how to use the function.
Interactive examples in the Python shell are most illustrative as
we can see the output resulting from function calls. For example,
we can in the <tt>solver</tt> function include an example on calling
this function and printing the computed <tt>u</tt> and <tt>t</tt> arrays:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solver</span>(I, a, T, dt, theta):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>


<span style="color: #BB4444; font-style: italic">    &gt;&gt;&gt; u, t = solver(I=0.8, a=1.2, T=4, dt=0.5, theta=0.5)</span>
<span style="color: #BB4444; font-style: italic">    &gt;&gt;&gt; for t_n, u_n in zip(t, u):</span>
<span style="color: #BB4444; font-style: italic">    ...     print &#39;t=%.1f, u=%.14f&#39; % (t_n, u_n)</span>
<span style="color: #BB4444; font-style: italic">    t=0.0, u=0.80000000000000</span>
<span style="color: #BB4444; font-style: italic">    t=0.5, u=0.43076923076923</span>
<span style="color: #BB4444; font-style: italic">    t=1.0, u=0.23195266272189</span>
<span style="color: #BB4444; font-style: italic">    t=1.5, u=0.12489758761948</span>
<span style="color: #BB4444; font-style: italic">    t=2.0, u=0.06725254717972</span>
<span style="color: #BB4444; font-style: italic">    t=2.5, u=0.03621291001985</span>
<span style="color: #BB4444; font-style: italic">    t=3.0, u=0.01949925924146</span>
<span style="color: #BB4444; font-style: italic">    t=3.5, u=0.01049960113002</span>
<span style="color: #BB4444; font-style: italic">    t=4.0, u=0.00565363137770</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #666666">...</span>
</pre></div>
<p>

<p>
When such interactive demonstrations are inserted in doc strings,
Python's <tt>doctest</tt> module can be used to automate running all commands
in interactive sessions and compare new output with the output
appearing in the doc string.  All we have to do in the current example
is to write

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal<span style="color: #666666">&gt;</span> python <span style="color: #666666">-</span>m doctest dc_mod_doctest<span style="color: #666666">.</span>py
</pre></div>
<p>
This command imports the <tt>doctest</tt> module, which runs all tests.
No additional command-line argument is allowed when running doctest.
If any test fails, the problem is reported, e.g.,

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python -m doctest dc_mod_doctest.py
********************************************************
File <span style="color: #BB4444">&quot;dc_mod_doctest.py&quot;</span>, line 12, in dc_mod_doctest....
Failed example:
    <span style="color: #AA22FF; font-weight: bold">for </span>t_n, u_n in zip<span style="color: #666666">(</span>t, u<span style="color: #666666">)</span>:
        print <span style="color: #BB4444">&#39;t=%.1f, u=%.14f&#39;</span> % <span style="color: #666666">(</span>t_n, u_n<span style="color: #666666">)</span>
Expected:
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>0.0, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.80000000000000
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>0.5, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.43076923076923
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>1.0, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.23195266272189
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>1.5, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.12489758761948
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>2.0, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.06725254717972
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>2.5, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.03621291001985
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>3.0, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.01949925924146
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>3.5, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.01049960113002
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>4.0, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.00565363137770
Got:
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>0.0, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.80000000000000
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>0.5, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.43076923076923
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>1.0, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.23195266272189
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>1.5, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.12489758761948
    <span style="color: #B8860B">t</span><span style="color: #666666">=</span>2.0, <span style="color: #B8860B">u</span><span style="color: #666666">=</span>0.06725254717972
********************************************************
1 items had failures:
   1 of   2 in dc_mod_doctest.solver
***Test Failed*** 1 failures.
</pre></div>
<p>

<p>
Note that in the output of <tt>t</tt> and <tt>u</tt> we write <tt>u</tt> with 14 digits.
Writing all 16 digits is not a good idea: if the tests are run on
different hardware, round-off errors might be different, and
the <tt>doctest</tt> module detects numbers are not precisely the same
and reports failures. In the present application, where \( 0 < u(t) \leq 0.8 \),
we expect round-off errors to be of size \( 10^{-16} \), so comparing 15
digits would probably be reliable, but we compare 14 to be on the
safe side.

<p>
Doctests are highly encouraged as they do two things: 1) demonstrate
how a function is used and 2) test that the function works.

<p>
Here is an example on a doctest in the <tt>explore</tt> function:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">explore</span>(I, a, T, dt, theta<span style="color: #666666">=0.5</span>, makeplot<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Run a case with the solver, compute error measure,</span>
<span style="color: #BB4444; font-style: italic">    and plot the numerical and exact solutions (if makeplot=True).</span>

<span style="color: #BB4444; font-style: italic">    &gt;&gt;&gt; for theta in 0, 0.5, 1:</span>
<span style="color: #BB4444; font-style: italic">    ...    E = explore(I=1.9, a=2.1, T=5, dt=0.1, theta=theta,</span>
<span style="color: #BB4444; font-style: italic">    ...                makeplot=False)</span>
<span style="color: #BB4444; font-style: italic">    ...    print &#39;%.10E&#39; % E</span>
<span style="color: #BB4444; font-style: italic">    ...</span>
<span style="color: #BB4444; font-style: italic">    7.3565079236E-02</span>
<span style="color: #BB4444; font-style: italic">    2.4183893110E-03</span>
<span style="color: #BB4444; font-style: italic">    6.5013039886E-02</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #666666">...</span>
</pre></div>
<p>
This time we limit the output to 10 digits.

<p>
We remark that doctests are not straightforward to construct for
functions that rely on command-line input and that print results to
the terminal window.

<p>

<h3>Unit testing with nose  <a name="___sec37"></a></h3>
<p>

<p>
The unit testing technique consists of identifying small units
of code, usually functions (or classes), and write one or more tests for
each unit. One test should, ideally, not depend on the outcome of
other tests. For example, the doctest in function <tt>solver</tt> is a
unit test, and the doctest in function <tt>explore</tt> as well, but the
latter depends on a working <tt>solver</tt>. Putting the error computation
and plotting in <tt>explore</tt> in two separate functions would allow
independent unit tests. In this way, the design of unit tests impacts
the design of functions. The recommended practice is actually to
design and write the unit tests first and <em>then</em> implement the functions!

<p>
In scientific computing it is still not obvious how to best perform
unit testing. The units is naturally larger than in non-scientific
software. Very often the solution procedure of a mathematical problem
identifies a unit.

<p>

<h4>Basic use of nose  <a name="___sec38"></a></h4>
<p>
The <tt>nose</tt> package is a versatile tool for implementing unit tests
in Python. Here is a recommended way of structuring tests:

<p>

<ol>
 <li> Implement tests in functions with names starting with <tt>test_</tt>.
 <li> Test functions perform assertions on computed results
    using <tt>assert</tt> functions from the <tt>nose.tools</tt> module.
 <li> Test functions can be in the source code files or be
    collected in separate files, usually with names starting with <tt>test_</tt>.
</ol>

Here comes a very simple illustration of the three points.
Assume that we have this function in a module <tt>mymod</tt>:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">double</span>(n):
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">2*</span>n
</pre></div>
<p>

<p>
Either in this file or in a separate file <tt>test_mymod.py</tt>, we
implement a test function whose purpose is
to test that the function <tt>double</tt> works as intended:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">nose.tools</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">nt</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_double</span>():
    result <span style="color: #666666">=</span> mymod<span style="color: #666666">.</span>double(<span style="color: #666666">4</span>)
    nt<span style="color: #666666">.</span>assert_equal(result, <span style="color: #666666">8</span>)
</pre></div>
<p>
We need to do an <tt>import mymod</tt> if this test is in a separate file, and
Python needs to be able to find <tt>mymod</tt>.

<p>
Running

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; nosetests
</pre></div>
<p>
makes the <tt>nose</tt> tool look for Python files with <tt>test_*()</tt>
functions and run these functions. If the <tt>nt.assert_equal</tt> function
finds that the two arguments are equal, the test is a success, otherwise
it is a failure and an exception of type <tt>AssertionError</tt> is raised.
Instead of calling the convenience function <tt>nt.assert_equal</tt>, we
can use Python's <tt>assert</tt> statement, which tests if a boolean
expression is true and raises an <tt>AssertionError</tt> if the expression is
false. Here, the statement is <tt>assert result == 8</tt>.
A completely manual alternative is to write

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">if</span> result <span style="color: #666666">!=</span> <span style="color: #666666">8</span>:
    <span style="color: #AA22FF; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">AssertionError</span>()
</pre></div>
<p>

<p>

<p>
The number of failed tests and their details are
reported, or an <tt>OK</tt> is printed if all tests passed.
Imports like <tt>import mymod</tt> in <tt>test_*.py</tt> files works even if <tt>mymod.py</tt>
is not located in the same directory as the test file (<tt>nose</tt> will
find it without any need for manipulating <tt>PYTHONPATH</tt> or <tt>sys.path</tt>).

<p>
The advantage with the <tt>nose</tt> is two-fold: 1) tests are written and collected
in a structured way, and 2) large collections of tests, scattered
throughout a tree of folders, can be executed with one command (<tt>nosetests</tt>).

<p>

<h4>Demonstrating nose  <a name="___sec39"></a></h4>
<p>
Let us illustrate how to use the <tt>nose</tt> tool for testing key functions
in the <tt>decay_theta</tt> module. Or more precisely, the module is called
<tt>decay_theta_unittest</tt> with all the <tt>verify*</tt> functions removed
as these now are outdated by the unit tests.

<p>
We design three unit tests:

<p>

<ol>
 <li> A comparison between the computed \( u^n \) values and the
    exact discrete solution.
 <li> A comparison between the computed \( u^n \) values and precomputed,
    verified reference values.
 <li> A comparison between observed and expected convergence rates.
</ol>

These tests follow very closely the code in the previously shown
<tt>verify*</tt> functions. We start with comparing \( u^n \), as computed by
the function <tt>solver</tt>, to the formula
for the exact discrete solution:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">nose.tools</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">nt</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
sys<span style="color: #666666">.</span>path<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, os<span style="color: #666666">.</span>pardir)
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">dc_mod_unittest</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">dc_mod</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_discrete_solution</span>(n, I, a, theta, dt):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;Return exact discrete solution of the theta scheme.&quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(dt)  <span style="color: #008800; font-style: italic"># avoid integer division</span>
    factor <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)
    <span style="color: #AA22FF; font-weight: bold">return</span> I<span style="color: #666666">*</span>factor<span style="color: #666666">**</span>n

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_against_discrete_solution</span>():
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Compare result from solver against</span>
<span style="color: #BB4444; font-style: italic">    formula for the discrete solution.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    theta <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>; a <span style="color: #666666">=</span> <span style="color: #666666">2</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(<span style="color: #666666">8/</span>dt)  <span style="color: #008800; font-style: italic"># no of steps</span>
    u, t <span style="color: #666666">=</span> dc_mod<span style="color: #666666">.</span>solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, T<span style="color: #666666">=</span>N<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    u_de <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([exact_discrete_solution(n, I, a, theta, dt)
                     <span style="color: #AA22FF; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(N<span style="color: #666666">+1</span>)])
    diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_de <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    nt<span style="color: #666666">.</span>assert_almost_equal(diff, <span style="color: #666666">0</span>, delta<span style="color: #666666">=1E-14</span>)
</pre></div>
<p>

<p>
The <tt>nt.assert_almost_equal</tt> is the relevant function for comparing two
real numbers. The <tt>delta</tt> argument specifies a tolerance for the
comparison. Alternatively, one can specify a <tt>places</tt> argument
for the number of decimal places to enter the comparison.

<p>
When we at some point have carefully verified the implementation, we may
store correctly computed numbers in the test program or in files for
use in future tests. Here is an example on how the outcome from the
<tt>solver</tt> function can be compared to what is considered to be
correct results:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_solver</span>():
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Compare result from solver against</span>
<span style="color: #BB4444; font-style: italic">    precomputed arrays for theta=0, 0.5, 1.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    I<span style="color: #666666">=0.8</span>; a<span style="color: #666666">=1.2</span>; T<span style="color: #666666">=4</span>; dt<span style="color: #666666">=0.5</span>  <span style="color: #008800; font-style: italic"># fixed parameters</span>
    precomputed <span style="color: #666666">=</span> {
        <span style="color: #BB4444">&#39;t&#39;</span>: np<span style="color: #666666">.</span>array([ <span style="color: #666666">0.</span> ,  <span style="color: #666666">0.5</span>,  <span style="color: #666666">1.</span> ,  <span style="color: #666666">1.5</span>,  <span style="color: #666666">2.</span> ,  <span style="color: #666666">2.5</span>,
                        <span style="color: #666666">3.</span> ,  <span style="color: #666666">3.5</span>,  <span style="color: #666666">4.</span> ]),
        <span style="color: #666666">0.5</span>: np<span style="color: #666666">.</span>array(
            [ <span style="color: #666666">0.8</span>       ,  <span style="color: #666666">0.43076923</span>,  <span style="color: #666666">0.23195266</span>, <span style="color: #666666">0.12489759</span>,
              <span style="color: #666666">0.06725255</span>,  <span style="color: #666666">0.03621291</span>,  <span style="color: #666666">0.01949926</span>, <span style="color: #666666">0.0104996</span> ,
              <span style="color: #666666">0.00565363</span>]),
        <span style="color: #666666">0</span>: np<span style="color: #666666">.</span>array(
            [  <span style="color: #666666">8.00000000e-01</span>,   <span style="color: #666666">3.20000000e-01</span>,
               <span style="color: #666666">1.28000000e-01</span>,   <span style="color: #666666">5.12000000e-02</span>,
               <span style="color: #666666">2.04800000e-02</span>,   <span style="color: #666666">8.19200000e-03</span>,
               <span style="color: #666666">3.27680000e-03</span>,   <span style="color: #666666">1.31072000e-03</span>,
               <span style="color: #666666">5.24288000e-04</span>]),
        <span style="color: #666666">1</span>: np<span style="color: #666666">.</span>array(
            [ <span style="color: #666666">0.8</span>       ,  <span style="color: #666666">0.5</span>       ,  <span style="color: #666666">0.3125</span>    ,  <span style="color: #666666">0.1953125</span> ,
              <span style="color: #666666">0.12207031</span>,  <span style="color: #666666">0.07629395</span>,  <span style="color: #666666">0.04768372</span>,  <span style="color: #666666">0.02980232</span>,
              <span style="color: #666666">0.01862645</span>]),
        }
    <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>:
        u, t <span style="color: #666666">=</span> dc_mod<span style="color: #666666">.</span>solver(I, a, T, dt, theta<span style="color: #666666">=</span>theta)
        diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u <span style="color: #666666">-</span> precomputed[theta])<span style="color: #666666">.</span>max()
        <span style="color: #008800; font-style: italic"># Precomputed numbers are known to 8 decimal places</span>
        nt<span style="color: #666666">.</span>assert_almost_equal(diff, <span style="color: #666666">0</span>, places<span style="color: #666666">=8</span>,
                               msg<span style="color: #666666">=</span><span style="color: #BB4444">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> theta)
</pre></div>
<p>
The <tt>precomputed</tt> object is a dictionary with four keys: <tt>'t'</tt> for the
time mesh, and three \( \theta \) values for \( u^n \) solutions corresponding
to the \( \theta=0,0.5,1 \).

<p>
Testing for special type of input data that may cause trouble constitutes
a common way of constructing unit tests. The updating formula for
\( u^{n+1} \) may be incorrectly evaluated because of unintended integer
divisions. For example, with
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">theta <span style="color: #666666">=</span> <span style="color: #666666">1</span>; a <span style="color: #666666">=</span> <span style="color: #666666">1</span>; I <span style="color: #666666">=</span> <span style="color: #666666">1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">2</span>
</pre></div>
<p>
the nominator and denominator in the updating expression,
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">(<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)
(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)
</pre></div>
<p>
evaluate to 1 and 3, respectively, and the fraction <tt>1/3</tt> will
call up integer division and consequently lead to <tt>u[n+1]=0</tt>.
We construct a unit test to make sure <tt>solver</tt> is smart
enough to avoid this problem:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_potential_integer_division</span>():
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;Choose variables that can trigger integer division.&quot;&quot;&quot;</span>
    theta <span style="color: #666666">=</span> <span style="color: #666666">1</span>; a <span style="color: #666666">=</span> <span style="color: #666666">1</span>; I <span style="color: #666666">=</span> <span style="color: #666666">1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    N <span style="color: #666666">=</span> <span style="color: #666666">4</span>
    u, t <span style="color: #666666">=</span> dc_mod<span style="color: #666666">.</span>solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, T<span style="color: #666666">=</span>N<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    u_de <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([exact_discrete_solution(n, I, a, theta, dt)
                     <span style="color: #AA22FF; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(N<span style="color: #666666">+1</span>)])
    diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_de <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    nt<span style="color: #666666">.</span>assert_almost_equal(diff, <span style="color: #666666">0</span>, delta<span style="color: #666666">=1E-14</span>)
</pre></div>
<p>

<p>
The final test is to see if \( \theta=0,1 \) has convergence rate 1 and
\( \theta=0.5 \) has convergence rate 2:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_convergence_rates</span>():
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;Compare empirical convergence rates to exact ones.&quot;&quot;&quot;</span>
    <span style="color: #008800; font-style: italic"># Set command-line arguments directly in sys.argv</span>
    sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> <span style="color: #BB4444">&#39;--I 0.8 --a 2.1 --T 5 &#39;</span>\ 
                   <span style="color: #BB4444">&#39;--dt 0.4 0.2 0.1 0.05 0.025&#39;</span><span style="color: #666666">.</span>split()
    <span style="color: #008800; font-style: italic"># Suppress output from dc_mod.main()</span>
    stdout <span style="color: #666666">=</span> sys<span style="color: #666666">.</span>stdout  <span style="color: #008800; font-style: italic"># save standard output for later use</span>
    scratchfile <span style="color: #666666">=</span> <span style="color: #AA22FF">open</span>(<span style="color: #BB4444">&#39;.tmp&#39;</span>, <span style="color: #BB4444">&#39;w&#39;</span>)  <span style="color: #008800; font-style: italic"># fake standard output</span>
    sys<span style="color: #666666">.</span>stdout <span style="color: #666666">=</span> scratchfile

    r <span style="color: #666666">=</span> dc_mod<span style="color: #666666">.</span>main()
    <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> r:
        nt<span style="color: #666666">.</span>assert_true(r[theta])  <span style="color: #008800; font-style: italic"># check for non-empty list</span>

    scratchfile<span style="color: #666666">.</span>close()
    sys<span style="color: #666666">.</span>stdout <span style="color: #666666">=</span> stdout  <span style="color: #008800; font-style: italic"># restore standard output</span>

    expected_rates <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #666666">1</span>, <span style="color: #666666">1</span>: <span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>: <span style="color: #666666">2</span>}
    <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> r:
        r_final <span style="color: #666666">=</span> r[theta][<span style="color: #666666">-1</span>]
        <span style="color: #008800; font-style: italic"># Compare to 1 decimal place</span>
        nt<span style="color: #666666">.</span>assert_almost_equal(expected_rates[theta], r_final,
                               places<span style="color: #666666">=1</span>, msg<span style="color: #666666">=</span><span style="color: #BB4444">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> theta)

<span style="color: #008800; font-style: italic"># no need for any main</span>
</pre></div>
<p>

<p>
Nothing more is needed in the <a href="http://github.hplgit.com/INF5620/src/decay/test/test_dc_nose.py"><tt>test_dc_nose.py</tt></a>.
file. Running <tt>nosetests</tt> will report <tt>Ran 3 tests</tt> and an <tt>OK</tt> for
success.  Everytime we modify the <tt>decay_theta_unittest</tt> module we can
run <tt>nosetests</tt> to quickly see if the edits have any impact on the
test collection.

<p>

<h4>Installation of nose  <a name="___sec40"></a></h4>
<p>
The <tt>nose</tt> does not come with a standard Python distribution and must
therefore be installed separately. The procedure is standard and
described on <a href="http://nose.readthedocs.org/en/latest/">Nose's web pages</a>.  On Debian-based Linux
systems the command is <tt>sudo apt-get install python-nose</tt>, and
with MacPorts you run <tt>sudo port install py27-nose</tt>.

<p>

<h3>Classical unit testing with unittest  <a name="___sec41"></a></h3>
<p>

<p>
The classical way of implementing unit tests derives from the JUnit
tool in Java where all tests are methods in a class for testing.
Python comes with a module <tt>unittest</tt> for doing this type of unit tests.
While <tt>nose</tt> allows simple functions for unit tests, <tt>unittest</tt>
requires deriving a class <tt>Test*</tt> from <tt>unittest.TestCase</tt> and
implementing each test as methods with names <tt>test_*</tt> in that class.

<p>

<h4>Basic use of unittest  <a name="___sec42"></a></h4>
<p>

<p>
Using the <tt>double</tt> function in the <tt>mymod</tt> module introduced in the
previous section, unit testing with the aid of the <tt>unittest</tt> module
consists of writing a file <tt>test_mymod.py</tt> with the content

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">unittest</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">mymod</span>

<span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">TestMyCode</span>(unittest<span style="color: #666666">.</span>TestCase):
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_double</span>(<span style="color: #AA22FF">self</span>):
        result <span style="color: #666666">=</span> mymod<span style="color: #666666">.</span>double(<span style="color: #666666">4</span>)
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>assertEqual(result, <span style="color: #666666">8</span>)

<span style="color: #AA22FF; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BB4444">&#39;__main__&#39;</span>:
    unittest<span style="color: #666666">.</span>main()
</pre></div>
<p>
The test is run by executing the test file <tt>test_mymod.py</tt> as a standard
Python program. There is no support in <tt>unittest</tt> for automatically
locating and running all tests in all test files in a folder tree.

<p>
Those who have experience with object-oriented programming will see that
the difference between using <tt>unittest</tt> and <tt>nose</tt> is minor.
Programmers with no or little knowledge of classes will certainly
prefer <tt>nose</tt>.

<p>

<h4>Demonstration of unittest  <a name="___sec43"></a></h4>
<p>
The same tests as shown for the nose framework are reimplemented
with the <tt>TestCase</tt> classes in the file <a href="http://github.hplgit.com/INF5620/src/decay/test/test_dc_nose.py"><tt>test_dc_unittest.py</tt></a>.
The tests are identical, the only difference being that with
<tt>unittest</tt> we must write the tests as methods in
a class and the assert functions have
slightly different syntax.

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">unittest</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">dc_mod_unittest</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">decay</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_discrete_solution</span>(n, I, a, theta, dt):
    factor <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)
    <span style="color: #AA22FF; font-weight: bold">return</span> I<span style="color: #666666">*</span>factor<span style="color: #666666">**</span>n

<span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">TestDecay</span>(unittest<span style="color: #666666">.</span>TestCase):

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_against_discrete_solution</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #666666">...</span>
        diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u_de <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>assertAlmostEqual(diff, <span style="color: #666666">0</span>, delta<span style="color: #666666">=1E-14</span>)

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_solver</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #666666">...</span>
        <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>:
            <span style="color: #666666">...</span>
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>assertAlmostEqual(diff, <span style="color: #666666">0</span>, places<span style="color: #666666">=8</span>,
                                   msg<span style="color: #666666">=</span><span style="color: #BB4444">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> theta)

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_potential_integer_division</span>():
        <span style="color: #666666">...</span>
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>assertAlmostEqual(diff, <span style="color: #666666">0</span>, delta<span style="color: #666666">=1E-14</span>)

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_convergence_rates</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #666666">...</span>
        <span style="color: #AA22FF; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> r:
            <span style="color: #666666">...</span>
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>assertAlmostEqual(<span style="color: #666666">...</span>)

<span style="color: #AA22FF; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BB4444">&#39;__main__&#39;</span>:
    unittest<span style="color: #666666">.</span>main()
</pre></div>
<p>

<p>
<!-- @@@CODE src-decay/test/test_dc_unittest.py fromto: def test_conv@ -->

<p>

<p>

<p>

<h3>Implementing simple problem and solver classes  <a name="___sec44"></a></h3>
<p>
The \( \theta \)-rule was compactly and conveniently implemented in
a function <tt>solver</tt>. In more complicated problems it might
be beneficial to use classes and introduce a class <tt>Problem</tt> to
hold the definition of the physical problem, a class <tt>Solver</tt>
to hold the data and methods needed to numerically solve the problem,
and a class <tt>Visualizer</tt> to make plots.
This idea will now be illustrated, resulting in code that represents
an alternative to the <tt>solver</tt> and <tt>explore</tt> functions found
in the <tt>dc_mod</tt> module.

<p>
Explaining the details of class programming in Python
is considered beyond the scope of this text.
Readers who are unfamiliar with Python class programming
should first consult one of the many electronic Python tutorials
or textbooks to come up to speed with concepts and syntax of
Python classes before reading on.

<p>

<h4>The problem class  <a name="___sec45"></a></h4>
<p>

<p>
The purpose of the problem class is to store all information about
the mathematical model. This usually means all the physical parameters
in the problem. In the current example with exponential decay we may
also add the exact solution of the ODE to the problem class.
The simplest form of a problem class is therefore

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">import</span> exp

<span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Problem</span>:
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__init__</span>(<span style="color: #AA22FF">self</span>, I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=10</span>):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>T, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>I, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a <span style="color: #666666">=</span> I, <span style="color: #AA22FF">float</span>(a), T

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_solution</span>(<span style="color: #AA22FF">self</span>, t):
        I, a <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>I, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a
        <span style="color: #AA22FF; font-weight: bold">return</span> I<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)
</pre></div>
<p>
We could in the <tt>exact_solution</tt> method have written
<tt>self.I*exp(-self.a*t)</tt>, but using local variables <tt>I</tt> and <tt>a</tt> allows
a formula <tt>I*exp(-a*t)</tt> which looks closer to the mathematical
expression \( Ie^{-at} \).  This is not an important issue with the
current compact formula, but is beneficial in more complicated
problems with longer formulas. We will therefore often "strip off"
<tt>self</tt> in variables in forthcoming examples.

<p>
The class data can be set either as arguments in the constructor or
at any time later, e.g.,

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">problem <span style="color: #666666">=</span> Problem(T<span style="color: #666666">=5</span>)
problem<span style="color: #666666">.</span>T <span style="color: #666666">=</span> <span style="color: #666666">8</span>
problem<span style="color: #666666">.</span>dt <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>
</pre></div>
<p>
However, it would be convenient if class <tt>Problem</tt> could also initialize
the data from the command line. To this end, we add a method for
defining a set of command-line options and a method that sets the
local attributes equal to what was found on the command line.
The default values associated with the command-line options are taken
as the values provided to the constructor. Class <tt>Problem</tt> now becomes

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Problem</span>:
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__init__</span>(<span style="color: #AA22FF">self</span>, I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=10</span>):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>T, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>I, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a <span style="color: #666666">=</span> I, <span style="color: #AA22FF">float</span>(a), T

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">define_command_line_options</span>(<span style="color: #AA22FF">self</span>, parser<span style="color: #666666">=</span><span style="color: #AA22FF">None</span>):
        <span style="color: #AA22FF; font-weight: bold">if</span> parser <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF">None</span>:
            <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">argparse</span>
            parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser()

        parser<span style="color: #666666">.</span>add_argument(
            <span style="color: #BB4444">&#39;--I&#39;</span>, <span style="color: #BB4444">&#39;--initial_condition&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>,
            default<span style="color: #666666">=</span><span style="color: #AA22FF">self</span><span style="color: #666666">.</span>I, help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;initial condition, u(0)&#39;</span>,
            metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;I&#39;</span>)
        parser<span style="color: #666666">.</span>add_argument(
            <span style="color: #BB4444">&#39;--a&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>, default<span style="color: #666666">=</span><span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a,
            help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;coefficient in ODE&#39;</span>, metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;a&#39;</span>)
        parser<span style="color: #666666">.</span>add_argument(
            <span style="color: #BB4444">&#39;--T&#39;</span>, <span style="color: #BB4444">&#39;--stop_time&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>, default<span style="color: #666666">=</span><span style="color: #AA22FF">self</span><span style="color: #666666">.</span>T,
            help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;end time of simulation&#39;</span>, metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;T&#39;</span>)
        <span style="color: #AA22FF; font-weight: bold">return</span> parser

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">init_from_command_line</span>(<span style="color: #AA22FF">self</span>, args):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>I, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>T <span style="color: #666666">=</span> args<span style="color: #666666">.</span>I, args<span style="color: #666666">.</span>a, args<span style="color: #666666">.</span>T

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_solution</span>(<span style="color: #AA22FF">self</span>, t):
        I, a <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>I, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a
        <span style="color: #AA22FF; font-weight: bold">return</span> I<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)
</pre></div>
<p>
Observe that if the user already has an <tt>ArgumentParser</tt> object it can be
supplied, but if we do not have, class <tt>Problem</tt> makes one for us.
Python's <tt>None</tt> object is used to indicate that a variable is not
initialized with a value.

<p>

<h4>The solver class  <a name="___sec46"></a></h4>
<p>

<p>
The solver class stores data related to the numerical solution method
and provides a function <tt>solve</tt> for solving the problem.
A problem object must be given to the constructor so that the solver
can easily look up physical data. In the present example, the
data related to the numerical solution method consist of \( \Delta t \)
and \( \theta \). We add, as in the problem class, functionality for
reading \( \Delta t \) and \( \theta \) from the command line:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Solver</span>:
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__init__</span>(<span style="color: #AA22FF">self</span>, problem, dt<span style="color: #666666">=0.1</span>, theta<span style="color: #666666">=0.5</span>):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem <span style="color: #666666">=</span> problem
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>dt, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>theta <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(dt), theta

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">define_command_line_options</span>(<span style="color: #AA22FF">self</span>, parser):
        parser<span style="color: #666666">.</span>add_argument(
            <span style="color: #BB4444">&#39;--dt&#39;</span>, <span style="color: #BB4444">&#39;--time_step_value&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>,
            default<span style="color: #666666">=0.5</span>, help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;time step value&#39;</span>, metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;dt&#39;</span>)
        parser<span style="color: #666666">.</span>add_argument(
            <span style="color: #BB4444">&#39;--theta&#39;</span>, <span style="color: #AA22FF">type</span><span style="color: #666666">=</span><span style="color: #AA22FF">float</span>, default<span style="color: #666666">=0.5</span>,
            help<span style="color: #666666">=</span><span style="color: #BB4444">&#39;time discretization parameter&#39;</span>, metavar<span style="color: #666666">=</span><span style="color: #BB4444">&#39;dt&#39;</span>)
        <span style="color: #AA22FF; font-weight: bold">return</span> parser

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">init_from_command_line</span>(<span style="color: #AA22FF">self</span>, args):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>dt, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>theta <span style="color: #666666">=</span> args<span style="color: #666666">.</span>dt, args<span style="color: #666666">.</span>theta

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solve</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dc_mod</span> <span style="color: #AA22FF; font-weight: bold">import</span> solver
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>u, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>t <span style="color: #666666">=</span> solver(
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>I, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>a, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>T,
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>dt, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>theta)

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">error</span>(<span style="color: #AA22FF">self</span>):
        u_e <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>exact_solution(<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>t)
        e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>u
        E <span style="color: #666666">=</span> sqrt(<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>dt<span style="color: #666666">*</span><span style="color: #AA22FF">sum</span>(e<span style="color: #666666">**2</span>))
        <span style="color: #AA22FF; font-weight: bold">return</span> E
</pre></div>
<p>
Note that we here simply reuse the implementation of the numerical method
from the <tt>dc_mod</tt> module.

<p>

<h4>The visualizer class  <a name="___sec47"></a></h4>
<p>

<p>
The purpose of the visualizer class is to plot the numerical solution
stored in class <tt>Solver</tt>. We also add the possibility to plot the
exact solution. Access to the problem and solver objects is required
when making plots so the constructor must store these objects:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Visualizer</span>:
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__init__</span>(<span style="color: #AA22FF">self</span>, problem, solver):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>solver <span style="color: #666666">=</span> problem, solver

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">plot</span>(<span style="color: #AA22FF">self</span>, include_exact<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>, plt<span style="color: #666666">=</span><span style="color: #AA22FF">None</span>):
        <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">        Add solver.u curve to scitools plotting object plt,</span>
<span style="color: #BB4444; font-style: italic">        and include the exact solution if include_exact is True.</span>
<span style="color: #BB4444; font-style: italic">        This plot function can be called several times (if</span>
<span style="color: #BB4444; font-style: italic">        the solver object has computed new solutions).</span>
<span style="color: #BB4444; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #AA22FF; font-weight: bold">if</span> plt <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF">None</span>:
            <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span>
            plt <span style="color: #666666">=</span> scitools<span style="color: #666666">.</span>std

        plt<span style="color: #666666">.</span>plot(<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>solver<span style="color: #666666">.</span>t, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>solver<span style="color: #666666">.</span>u, <span style="color: #BB4444">&#39;--o&#39;</span>)
        plt<span style="color: #666666">.</span>hold(<span style="color: #BB4444">&#39;on&#39;</span>)
        theta2name <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #BB4444">&#39;FE&#39;</span>, <span style="color: #666666">1</span>: <span style="color: #BB4444">&#39;BE&#39;</span>, <span style="color: #666666">0.5</span>: <span style="color: #BB4444">&#39;CN&#39;</span>}
        name <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>solver<span style="color: #666666">.</span>theta2name<span style="color: #666666">.</span>get(<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>solver<span style="color: #666666">.</span>theta, <span style="color: #BB4444">&#39;&#39;</span>)
        plt<span style="color: #666666">.</span>legend(<span style="color: #BB4444">&#39;numerical </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> name)
        <span style="color: #AA22FF; font-weight: bold">if</span> include_exact:
            t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>T, <span style="color: #666666">1001</span>)
            u_e <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>exact_solution(t_e)
            plt<span style="color: #666666">.</span>plot(t_e, u_e, <span style="color: #BB4444">&#39;b-&#39;</span>)
            plt<span style="color: #666666">.</span>legend(<span style="color: #BB4444">&#39;exact&#39;</span>)
        plt<span style="color: #666666">.</span>xlabel(<span style="color: #BB4444">&#39;t&#39;</span>)
        plt<span style="color: #666666">.</span>ylabel(<span style="color: #BB4444">&#39;u&#39;</span>)
        plt<span style="color: #666666">.</span>title(<span style="color: #BB4444">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span>
                  (<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>solver<span style="color: #666666">.</span>theta, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>solver<span style="color: #666666">.</span>dt))
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">.png&#39;</span> <span style="color: #666666">%</span> (name, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>solver<span style="color: #666666">.</span>dt))
        <span style="color: #AA22FF; font-weight: bold">return</span> plt
</pre></div>
<p>

<p>
The <tt>plt</tt> object in the <tt>plot</tt> method is worth a comment. The idea is
that <tt>plot</tt> can add a numerical solution curve to an existing
plot. Calling <tt>plot</tt> with a <tt>plt</tt> object, which has to be a
<tt>scitools.std</tt> object in this implementation, will just add the curve
<tt>self.solver.u</tt> as a dashed line with circles at the mesh points
(leaving the color of the curve up to the plotting tool). This
functionality allows plots with several solutions: just make a loop
where new data is set in the problem and/or solver classes, the
solver's <tt>solve()</tt> method is called, the most recent numerical
solution is plotted by the <tt>plot(plt)</tt> method in the visualizer object
(<a href="#decay:exer:dc_class:exper">Exercise 10: Make use of a class implementation</a> describes a problem setting
where this functionality is explored).

<p>

<h4>Combing the objects  <a name="___sec48"></a></h4>
<p>
Eventually we need to show how the classes <tt>Problem</tt>, <tt>Solver</tt>, and
<tt>Visualizer</tt> play together:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">main</span>():
    problem <span style="color: #666666">=</span> Problem()
    solver <span style="color: #666666">=</span> Solver(problem)
    viz <span style="color: #666666">=</span> Visualizer(problem, solver)

    <span style="color: #008800; font-style: italic"># Read input from the command line</span>
    parser <span style="color: #666666">=</span> problem<span style="color: #666666">.</span>define_command_line_options()
    parser <span style="color: #666666">=</span> solver<span style="color: #666666">.</span> define_command_line_options(parser)
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args()
    problem<span style="color: #666666">.</span>init_from_command_line(args)
    solver<span style="color: #666666">.</span> init_from_command_line(args)

    <span style="color: #008800; font-style: italic"># Solve and plot</span>
    solver<span style="color: #666666">.</span>solve()
    plt <span style="color: #666666">=</span> viz<span style="color: #666666">.</span>plot()
    E <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>error()
    <span style="color: #AA22FF; font-weight: bold">if</span> E <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #AA22FF">None</span>:
        <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Error: </span><span style="color: #BB6688; font-weight: bold">%.4E</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> E
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>

<p>
The file <a href="http://github.hplgit.com/INF5620/src/decay/dc_class.py"><tt>dc_class.py</tt></a>
constitutes a module with the three classes and the <tt>main</tt> function.

<p>

<p>

<h3>Implementing more advanced problem and solver classes  <a name="___sec49"></a></h3>
<p>
The previous <tt>Problem</tt> and <tt>Solver</tt> classes containing parameters
soon get much repetitive code when the number of parameters increases.
Much of this code can be parameterized and be made more compact.
For this purpose, we decide to collect all parameters in a dictionary,
<tt>self.prms</tt>, with two associated dictionaries <tt>self.types</tt> and
<tt>self.help</tt> for holding associated object types and help strings.
Provided a problem, solver, or visualizer class defines these three
dictionaries in the constructor, using default or user-supplied values
of the parameters, we can create a super class <tt>Parameters</tt> with general code
for defining command-line options and reading them as well as
methods for setting and getting a parameter. A <tt>Problem</tt> or <tt>Solver</tt> class will
then inherit command-line functionality and the set/get methods from
the <tt>Parameters</tt> class.

<p>

<h4>A generic class for parameters  <a name="___sec50"></a></h4>
<p>
A simplified version of the parameter class looks as follows:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Parameters</span>:
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">set</span>(<span style="color: #AA22FF">self</span>, <span style="color: #666666">**</span>parameters):
        <span style="color: #AA22FF; font-weight: bold">for</span> name <span style="color: #AA22FF; font-weight: bold">in</span> parameters:
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>prms[name] <span style="color: #666666">=</span> parameters[name]

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">get</span>(<span style="color: #AA22FF">self</span>, name):
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>prms[name]

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">define_command_line_options</span>(<span style="color: #AA22FF">self</span>, parser<span style="color: #666666">=</span><span style="color: #AA22FF">None</span>):
        <span style="color: #AA22FF; font-weight: bold">if</span> parser <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF">None</span>:
            <span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">argparse</span>
            parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser()

        <span style="color: #AA22FF; font-weight: bold">for</span> name <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>prms:
            tp <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>types[name] <span style="color: #AA22FF; font-weight: bold">if</span> name <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>types <span style="color: #AA22FF; font-weight: bold">else</span> <span style="color: #AA22FF">str</span>
            help <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>help[name] <span style="color: #AA22FF; font-weight: bold">if</span> name <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>help <span style="color: #AA22FF; font-weight: bold">else</span> <span style="color: #AA22FF">None</span>
            parser<span style="color: #666666">.</span>add_argument(
                <span style="color: #BB4444">&#39;--&#39;</span> <span style="color: #666666">+</span> name, default<span style="color: #666666">=</span><span style="color: #AA22FF">self</span><span style="color: #666666">.</span>get(name), metavar<span style="color: #666666">=</span>name,
                <span style="color: #AA22FF">type</span><span style="color: #666666">=</span>tp, help<span style="color: #666666">=</span>help)

        <span style="color: #AA22FF; font-weight: bold">return</span> parser

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">init_from_command_line</span>(<span style="color: #AA22FF">self</span>, args):
        <span style="color: #AA22FF; font-weight: bold">for</span> name <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>prms:
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>prms[name] <span style="color: #666666">=</span> <span style="color: #AA22FF">getattr</span>(args, name)
</pre></div>
<p>
The file <a href="http://github.hplgit.com/INF5620/src/decay/class_dc_verf1.py"><tt>class_dc_verf1.py</tt></a> contains
a slightly more advanced version of class <tt>Parameters</tt> where we
in the <tt>set</tt> and <tt>get</tt> functions test for valid parameter names and
raise exceptions with informative messages if any name is not registered.

<p>

<h4>The problem class  <a name="___sec45"></a></h4>
<p>

<p>
A class <tt>Problem</tt> for the exponential decay ODE with parameters \( a \), \( I \), and
\( T \) can now be coded as

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Problem</span>(Parameters):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Physical parameters for the problem u&#39;=-a*u, u(0)=I,</span>
<span style="color: #BB4444; font-style: italic">    with t in [0,T].</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__init__</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>prms <span style="color: #666666">=</span> <span style="color: #AA22FF">dict</span>(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=10</span>)
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>types <span style="color: #666666">=</span> <span style="color: #AA22FF">dict</span>(I<span style="color: #666666">=</span><span style="color: #AA22FF">float</span>, a<span style="color: #666666">=</span><span style="color: #AA22FF">float</span>, T<span style="color: #666666">=</span><span style="color: #AA22FF">float</span>)
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>help <span style="color: #666666">=</span> <span style="color: #AA22FF">dict</span>(I<span style="color: #666666">=</span><span style="color: #BB4444">&#39;initial condition, u(0)&#39;</span>,
                         a<span style="color: #666666">=</span><span style="color: #BB4444">&#39;coefficient in ODE&#39;</span>,
                         T<span style="color: #666666">=</span><span style="color: #BB4444">&#39;end time of simulation&#39;</span>)

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_solution</span>(<span style="color: #AA22FF">self</span>, t):
        I, a <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>get(<span style="color: #BB4444">&#39;I&#39;</span>), <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>get(<span style="color: #BB4444">&#39;a&#39;</span>)
        <span style="color: #AA22FF; font-weight: bold">return</span> I<span style="color: #666666">*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)
</pre></div>
<p>

<p>

<h4>The solver class  <a name="___sec46"></a></h4>
<p>

<p>
Also the solver class is derived from class <tt>Parameters</tt> and works with
the <tt>prms</tt>, <tt>types</tt>, and <tt>help</tt> dictionaries in the same way as class
<tt>Problem</tt>. Otherwise, the code is very similar to class <tt>Solver</tt> in
the <tt>decay_class.py</tt> file:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">Solver</span>(Parameters):
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__init__</span>(<span style="color: #AA22FF">self</span>, problem):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem <span style="color: #666666">=</span> problem
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>prms <span style="color: #666666">=</span> <span style="color: #AA22FF">dict</span>(dt<span style="color: #666666">=0.5</span>, theta<span style="color: #666666">=0.5</span>)
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>types <span style="color: #666666">=</span> <span style="color: #AA22FF">dict</span>(dt<span style="color: #666666">=</span><span style="color: #AA22FF">float</span>, theta<span style="color: #666666">=</span><span style="color: #AA22FF">float</span>)
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>help <span style="color: #666666">=</span> <span style="color: #AA22FF">dict</span>(dt<span style="color: #666666">=</span><span style="color: #BB4444">&#39;time step value&#39;</span>,
                         theta<span style="color: #666666">=</span><span style="color: #BB4444">&#39;time discretization parameter&#39;</span>)

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solve</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #008800; font-style: italic">#from dc_mod import solver</span>
        <span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay_theta</span> <span style="color: #AA22FF; font-weight: bold">import</span> solver
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>u, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>t <span style="color: #666666">=</span> solver(
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>get(<span style="color: #BB4444">&#39;I&#39;</span>),
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>get(<span style="color: #BB4444">&#39;a&#39;</span>),
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>get(<span style="color: #BB4444">&#39;T&#39;</span>),
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>get(<span style="color: #BB4444">&#39;dt&#39;</span>),
            <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>get(<span style="color: #BB4444">&#39;theta&#39;</span>))

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">error</span>(<span style="color: #AA22FF">self</span>):
        <span style="color: #AA22FF; font-weight: bold">try</span>:
            u_e <span style="color: #666666">=</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>problem<span style="color: #666666">.</span>exact_solution(<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>t)
            e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>u
            E <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #AA22FF">self</span><span style="color: #666666">.</span>get(<span style="color: #BB4444">&#39;dt&#39;</span>)<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sum(e<span style="color: #666666">**2</span>))
        <span style="color: #AA22FF; font-weight: bold">except</span> <span style="color: #D2413A; font-weight: bold">AttributeError</span>:
            E <span style="color: #666666">=</span> <span style="color: #AA22FF">None</span>
        <span style="color: #AA22FF; font-weight: bold">return</span> E
</pre></div>
<p>

<p>

<h4>The visualizer class  <a name="___sec47"></a></h4>
<p>

<p>
Class <tt>Visualizer</tt> can be identical to the one in the <tt>decay_class.py</tt> file
since the class does not need any parameters. However, a few
adjustments in the <tt>plot</tt> method is necessary since parameters are
accessed as, e.g., <tt>problem.get('T')</tt> rather than <tt>problem.T</tt>.
The details are found in the file <a href="http://github.hplgit.com/INF5620/src/decay/class_dc_verf1.py"><tt>class_dc_verf1.py</tt></a>.

<p>
Finally, we need a function that solves a real problem using the
classes <tt>Problem</tt>, <tt>Solver</tt>, and <tt>Visualizer</tt>. This function can
be just like <tt>main</tt> in the <tt>class_dc_v1.py</tt> file.

<p>
The advantage with the <tt>Parameters</tt> class is that it scales to problems
with a large number of physical and numerical parameters:
as long as the parameters are defined once via a dictionary,
the compact code in class <tt>Parameters</tt> can handle any collection of
parameters of any size.

<p>

<p>

<h2>Performing scientific experiments <a name="decay:experiments"></a></h2>
<p>

<p>

<p>
The goal of this section is to explore the behavior of a numerical
method for a differential equation and show how scientific experiments
can be set up and reported. We address the ODE problem

<p>
$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I,\quad 0<t\leq T,
\label{decay:experiments:model}
\end{equation}
$$
numerically discretized by the \( \theta \)-rule:

<p>
$$
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
\quad u^0=I\thinspace .
$$
Our aim is to plot \( u^n \) against the exact solution \( \uex = Ie^{-at} \)
for various choices of the parameters in this numerical problem:
\( I \), \( a \), \( \Delta t \), and \( \theta \). In particular, we are interested
in how the discrete solution compares with the exact solution
when the \( \Delta t \) parameter is varied and \( \theta \) takes on the three values
corresponding to the Forward Euler, Backward Euler, and Crank-Nicolson
schemes (\( \theta=0,1,0.5 \), respectively).

<p>
A verified implementation for computing \( u^n \) and plotting \( u^n \) together
with \( \uex \) is found in the file
<a href="http://github.hplgit.com/INF5620/src/decay/dc_mod.py"><tt>dc_mod.py</tt></a>.
This program admits command-line arguments to specify a series of
\( \Delta t \) values and will run a loop over these values and
\( \theta=0,0.5,1 \). We make a slight edit of how the plots are
designed: the numerical solution is specified with line type <tt>'r--o'</tt>
(dashed red lines with dots at the mesh points), and the <tt>show()</tt>
command is removed to avoid a lot of plot windows popping up on
the computer screen (but hardcopies of the plot are still stored
in files via <tt>savefig</tt>). The slightly
modified program has the name
<a href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_mod.py"><tt>experiments/dc_mod.py</tt></a>.
All files associated with the scientific investigation are collected
in a subfolder <tt>experiments</tt>.

<p>
Running the experiments is easy since the <tt>dc_mod.py</tt> program
already has the loops over \( \theta \) and \( \Delta t \) implemented:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_mod.py --I 1 --a 2 --makeplot <span style="color: #BB6622; font-weight: bold">\</span>
          --T 5 --dt 0.5 0.25 0.1 0.05
</pre></div>
<p>

<p>
The <tt>dc_mod.py</tt> program generates a lot of image files, e.g.,
<tt>FE_*.png</tt>, <tt>BE_*.png</tt>, and <tt>CN_*.png</tt>.
We want to combine all the <tt>FE_*.png</tt> files in a table
fashion in one file, with two images in each row,
starting with the largest \( \Delta t \) in the upper
left corner and decreasing the value as we go to the right and down.
This can be done using the <a href="http://www.imagemagick.org/script/montage.php"><tt>montage</tt></a> program.

<p>
Also plot files in the PDF format with names <tt>FE_*.pdf</tt>, <tt>BE_*.pdf</tt>,
and <tt>CN_*.pdf</tt> are generated and these should be combined using other
tools: <tt>pdftk</tt> to combine individual plots into one file with one plot
per page, and <tt>pdfnup</tt> to combine the pages into a table with multiple
plots per page. The code snippets below contains all details about the
usage of <tt>montage</tt>, <tt>pdftk</tt>, and <tt>pdfnup</tt>.

<p>

<p>

<p>
Running manual commands is boring, and errors may easily
sneak in. Both for automating manual work and documenting the
operating system commands we actually issued in the experiment,
we should write a <em>script</em> (little program). The script takes
a list of \( \Delta t \) values on the command line as input and
makes three combined images, one for each \( \theta \) value,
displaying the quality of the numerical solution as \( \Delta t \)
varies. For example,
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python dc_exper0.py 0.5 0.25 0.1 0.05
</pre></div>
<p>
results in images <tt>FE.png</tt>, <tt>CN.png</tt>, <tt>BE.png</tt>,
<tt>FE.pdf</tt>, <tt>CN.pdf</tt>, and <tt>BE.pdf</tt>,
each with four plots corresponding to the four \( \Delta t \) values.
Each plot compares the numerical solution with the exact one.
The latter image is shown in Figure <a href="#decay:experiments:fig:BE4a">9</a>.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Illustration of the Backward Euler method for four time step values. <a name="decay:experiments:fig:BE4a"></a> </p></center>
<p><img src="fig-decay/BE4a.png" align="bottom" width=600,></p>
</center>

<p>

<p>
Ideally, the script should be scalable in the sense that it works for
any number of \( \Delta t \) values, which is the case for this particular
implementation:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">os</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">sys</span>

<span style="color: #008800; font-style: italic"># The command line must contain dt values</span>
<span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">len</span>(sys<span style="color: #666666">.</span>argv) <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span>:
    dt_values <span style="color: #666666">=</span> [<span style="color: #AA22FF">float</span>(arg) <span style="color: #AA22FF; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>:]]
<span style="color: #AA22FF; font-weight: bold">else</span>:
    <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Usage: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444"> dt1 dt2 dt3 ...&#39;</span>;  sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)  <span style="color: #008800; font-style: italic"># abort</span>

<span style="color: #008800; font-style: italic"># Fixed physical parameters</span>
I <span style="color: #666666">=</span> <span style="color: #666666">1</span>
a <span style="color: #666666">=</span> <span style="color: #666666">2</span>
T <span style="color: #666666">=</span> <span style="color: #666666">5</span>

<span style="color: #008800; font-style: italic"># Run module file as a stand-alone application</span>
cmd <span style="color: #666666">=</span> <span style="color: #BB4444">&#39;python dc_mod.py --I </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444"> --a </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444"> --makeplot --T </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> \
      (I, a, T)
dt_values_str <span style="color: #666666">=</span> <span style="color: #BB4444">&#39; &#39;</span><span style="color: #666666">.</span>join([<span style="color: #AA22FF">str</span>(v) <span style="color: #AA22FF; font-weight: bold">for</span> v <span style="color: #AA22FF; font-weight: bold">in</span> dt_values])
cmd <span style="color: #666666">+=</span> <span style="color: #BB4444">&#39; --dt </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> dt_values_str
<span style="color: #AA22FF; font-weight: bold">print</span> cmd
failure <span style="color: #666666">=</span> os<span style="color: #666666">.</span>system(cmd)
<span style="color: #AA22FF; font-weight: bold">if</span> failure:
    <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Command failed:&#39;</span>, cmd; sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)

<span style="color: #008800; font-style: italic"># Combine images into rows with 2 plots in each row</span>
combine_image_commands <span style="color: #666666">=</span> []
<span style="color: #AA22FF; font-weight: bold">for</span> method <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BB4444">&#39;BE&#39;</span>, <span style="color: #BB4444">&#39;CN&#39;</span>, <span style="color: #BB4444">&#39;FE&#39;</span>:
    imagefiles <span style="color: #666666">=</span> <span style="color: #BB4444">&#39; &#39;</span><span style="color: #666666">.</span>join([<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">.pdf&#39;</span> <span style="color: #666666">%</span> (method, dt)
                           <span style="color: #AA22FF; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values])
    combine_image_commands<span style="color: #666666">.</span>append(
        <span style="color: #BB4444">&#39;montage -background white -geometry 100%&#39;</span> <span style="color: #666666">+</span> \
        <span style="color: #BB4444">&#39; -tile 2x </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444"> </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">.png&#39;</span> <span style="color: #666666">%</span> (imagefiles, method))
    combine_image_commands<span style="color: #666666">.</span>append(
        <span style="color: #BB4444">&#39;pdftk </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444"> output tmp.pdf&#39;</span> <span style="color: #666666">%</span> imagefiles)
    num_rows <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(<span style="color: #AA22FF">round</span>(<span style="color: #AA22FF">len</span>(dt_values)<span style="color: #666666">/2.0</span>))
    combine_image_commands<span style="color: #666666">.</span>append(
        <span style="color: #BB4444">&#39;pdfnup --nup 2x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BB4444"> tmp.pdf&#39;</span> <span style="color: #666666">%</span> num_rows)
    combine_image_commands<span style="color: #666666">.</span>append(
        <span style="color: #BB4444">&#39;mv -f tmp-nup.pdf </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">.pdf&#39;</span> <span style="color: #666666">%</span> method)
    imagefiles <span style="color: #666666">=</span> <span style="color: #BB4444">&#39; &#39;</span><span style="color: #666666">.</span>join([<span style="color: #BB4444">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">.png&#39;</span> <span style="color: #666666">%</span> (method, dt)
                           <span style="color: #AA22FF; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values])

<span style="color: #AA22FF; font-weight: bold">for</span> cmd <span style="color: #AA22FF; font-weight: bold">in</span> combine_image_commands:
    <span style="color: #AA22FF; font-weight: bold">print</span> cmd
    failure <span style="color: #666666">=</span> os<span style="color: #666666">.</span>system(cmd)
    <span style="color: #AA22FF; font-weight: bold">if</span> failure:
        <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Command failed:&#39;</span>, cmd; sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)

<span style="color: #008800; font-style: italic"># Remove the files generated by dc_mod.py</span>
<span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">glob</span> <span style="color: #AA22FF; font-weight: bold">import</span> glob
filenames <span style="color: #666666">=</span> glob(<span style="color: #BB4444">&#39;*_*.png&#39;</span>) <span style="color: #666666">+</span> glob(<span style="color: #BB4444">&#39;*_*.pdf&#39;</span>) <span style="color: #666666">+</span> glob(<span style="color: #BB4444">&#39;*_*.eps&#39;</span>)  <span style="color: #666666">+</span>\
            glob(<span style="color: #BB4444">&#39;tmp*.pdf&#39;</span>)
<span style="color: #AA22FF; font-weight: bold">for</span> filename <span style="color: #AA22FF; font-weight: bold">in</span> filenames:
    os<span style="color: #666666">.</span>remove(filename)
</pre></div>
<p>
This file is available as <a href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_exper0.py"><tt>experiments/dc_exper0.py</tt></a>.

<p>

<p>
We may comment upon many useful constructs in this script:

<p>

<ul>
 <li> <tt>[float(arg) for arg in sys.argv]</tt> builds a list of real numbers
   from all the command-line arguments.
 <li> <tt>failure = os.system(cmd)</tt> runs an operating system command, e.g.,
   another program. The execution successful only if <tt>failure</tt> is zero.
 <li> Unsuccessful execution usually makes it meaningless to continue
   the program, and therefore we abort the program with <tt>sys.exit(1)</tt>.
   Any argument different from 0 signifies that our program stopped
   with a failure.
 <li> <tt>['%s_%s.png' % (method, dt) for dt in dt_values]</tt> builds a list of
   filenames from a list of numbers (<tt>dt_values</tt>).
 <li> All <tt>montage</tt>, <tt>pdftk</tt>, <tt>pdfnup</tt>, and <tt>mv</tt> commands for creating
   composite figures are stored in a
   list and thereafter executed in a loop.
 <li> <tt>glob('*_*.png')</tt> returns a list of the names of all files in the
   current folder where the filename matches the <em>Unix wildcard notation</em>
   <tt>*_*.png</tt> (meaning "any text, underscore, any text, and then `.png`").
 <li> <tt>os.remove(filename)</tt> removes the file with name <tt>filename</tt>.
</ul>

<h3>Interpreting output from other programs  <a name="___sec55"></a></h3>
<p>
Programs that run other programs, like <tt>dc_exper0.py</tt> does, will often
need to interpret output from the other programs. Let us demonstrate how
this is done in Python by extracting the relations between \( \theta \),
\( \Delta t \), and the error \( E \) as written to the terminal window
by the <tt>dc_mod.py</tt> program, which is being executed by
<tt>dc_exper0.py</tt>. We will

<p>

<ul>
  <li> read the output from the <tt>dc_mod.py</tt> program
  <li> interpret this output and store the \( E \) values in arrays for each
    \( \theta \) value
  <li> plot \( E \) versus \( \Delta t \), for each \( \theta \), in a log-log plot
</ul>

The simple <tt>os.system(cmd)</tt> call does not allow us to read the
output from running <tt>cmd</tt>. Instead we need to invoke a bit more
involved procedure:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">subprocess</span> <span style="color: #AA22FF; font-weight: bold">import</span> Popen, PIPE, STDOUT
p <span style="color: #666666">=</span> Popen(cmd, shell<span style="color: #666666">=</span><span style="color: #AA22FF">True</span>, stdout<span style="color: #666666">=</span>PIPE, stderr<span style="color: #666666">=</span>STDOUT)
output, dummy <span style="color: #666666">=</span> p<span style="color: #666666">.</span>communicate()
failure <span style="color: #666666">=</span> p<span style="color: #666666">.</span>returncode
<span style="color: #AA22FF; font-weight: bold">if</span> failure:
    <span style="color: #AA22FF; font-weight: bold">print</span> <span style="color: #BB4444">&#39;Command failed:&#39;</span>, cmd; sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)
</pre></div>
<p>
The command stored in <tt>cmd</tt> is run and all text that is written to
the standard output <em>and</em> the standard error is available in the
string <tt>output</tt>. The text in <tt>output</tt> is what appeared in the
terminal window while running <tt>cmd</tt>.

<p>
Our next task is to run through the <tt>output</tt> string, line by line,
and if the current line prints \( \theta \), \( \Delta t \), and \( E \),
we split the line into these three pieces and store the data.
The chosen storage structure is a dictionary <tt>errors</tt> with keys <tt>dt</tt>
to hold the \( \Delta t \) values, and three \( \theta \) keys to hold
the corresponding \( E \) values. The relevant code lines are

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">errors <span style="color: #666666">=</span> {<span style="color: #BB4444">&#39;dt&#39;</span>: dt_values, <span style="color: #666666">1</span>: [], <span style="color: #666666">0</span>: [], <span style="color: #666666">0.5</span>: []}
<span style="color: #AA22FF; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> output<span style="color: #666666">.</span>splitlines():
    words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
    <span style="color: #AA22FF; font-weight: bold">if</span> words[<span style="color: #666666">0</span>] <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #BB4444">&#39;0.0&#39;</span>, <span style="color: #BB4444">&#39;0.5&#39;</span>, <span style="color: #BB4444">&#39;1.0&#39;</span>):  <span style="color: #008800; font-style: italic"># line with E?</span>
        <span style="color: #008800; font-style: italic"># typical line: 0.0   1.25:    7.463E+00</span>
        theta <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(words[<span style="color: #666666">0</span>])
        E <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(words[<span style="color: #666666">2</span>])
        errors[theta]<span style="color: #666666">.</span>append(E)
</pre></div>
<p>
Note that we do not bother to store the \( \Delta t \) values as we
read them from <tt>output</tt>, because we already have these values in
the <tt>dt_values</tt> list.

<p>
We are now ready to plot \( E \) versus \( \Delta t \) for \( \theta=0,0.5,1 \):

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008800; font-style: italic">#import scitools.std as plt</span>
plt<span style="color: #666666">.</span>loglog(errors[<span style="color: #BB4444">&#39;dt&#39;</span>], errors[<span style="color: #666666">0</span>], <span style="color: #BB4444">&#39;ro-&#39;</span>)
plt<span style="color: #666666">.</span>hold(<span style="color: #BB4444">&#39;on&#39;</span>)  <span style="color: #008800; font-style: italic"># MATLAB style...</span>
plt<span style="color: #666666">.</span>loglog(errors[<span style="color: #BB4444">&#39;dt&#39;</span>], errors[<span style="color: #666666">0.5</span>], <span style="color: #BB4444">&#39;b+-&#39;</span>)
plt<span style="color: #666666">.</span>loglog(errors[<span style="color: #BB4444">&#39;dt&#39;</span>], errors[<span style="color: #666666">1</span>], <span style="color: #BB4444">&#39;gx-&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BB4444">&#39;FE&#39;</span>, <span style="color: #BB4444">&#39;CN&#39;</span>, <span style="color: #BB4444">&#39;BE&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BB4444">&#39;upper left&#39;</span>)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BB4444">&#39;log(time step)&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BB4444">&#39;log(error)&#39;</span>)
plt<span style="color: #666666">.</span>title(<span style="color: #BB4444">&#39;Error vs time step&#39;</span>)
plt<span style="color: #666666">.</span>savefig(<span style="color: #BB4444">&#39;error_BE_CN_FE.png&#39;</span>)
plt<span style="color: #666666">.</span>savefig(<span style="color: #BB4444">&#39;error_BE_CN_FE.pdf&#39;</span>)
</pre></div>
<p>
Plots occasionally need some manual adjustments. Here, the axis of
the log-log plot look nicer if we adapt them strictly to the data,
see Figure <a href="#decay:exper:Evsdt">10</a>.
To this end, we need to compute \( \min E \) and \( \max E \), and later
specify the extent of the axes:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">errors <span style="color: #666666">=</span> {<span style="color: #BB4444">&#39;dt&#39;</span>: dt_values, <span style="color: #666666">1</span>: [], <span style="color: #666666">0</span>: [], <span style="color: #666666">0.5</span>: []}
min_E <span style="color: #666666">=</span> <span style="color: #666666">1E+20</span>; max_E <span style="color: #666666">=</span> <span style="color: #666666">-</span>min_E  <span style="color: #008800; font-style: italic"># keep track of min/max E for axis</span>
<span style="color: #AA22FF; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> output<span style="color: #666666">.</span>splitlines():
    <span style="color: #666666">...</span>
        <span style="color: #666666">...</span>
        min_E <span style="color: #666666">=</span> <span style="color: #AA22FF">min</span>(min_E, E);  max_E <span style="color: #666666">=</span> <span style="color: #AA22FF">max</span>(max_E, E)

<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
plt<span style="color: #666666">.</span>loglog(errors[<span style="color: #BB4444">&#39;dt&#39;</span>], errors[<span style="color: #666666">0</span>], <span style="color: #BB4444">&#39;ro-&#39;</span>)
<span style="color: #666666">...</span>
plt<span style="color: #666666">.</span>axis([<span style="color: #AA22FF">min</span>(dt_values), <span style="color: #AA22FF">max</span>(dt_values), min_E, max_E])
<span style="color: #666666">...</span>
</pre></div>
<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Default plot (left) and manually adjusted plot (right). <a name="decay:exper:Evsdt"></a> </p></center>
<p><img src="fig-decay/error_plot_improvement.png" align="bottom" width=800,></p>
</center>

<p>

<p>
The complete program, incorporating the code snippets above, is found
in <a href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_exper1.py"><tt>experiments/dc_exper1.py</tt></a>.
This program can hopefully be reused in a number of other occasions
where one needs to run experiments, extract data from the output
of programs, make plots, and combine several plots in a figure file.

<p>

<h3>Making a report <a name="decay:exper:report"></a></h3>
<p>

<p>
The results of running computer experiments are best documented in a
little report containing the problem to be solved, key code segments,
and the plots from a series of experiments. At least the part of the
report containing the plots should be automatically generated by the
script that performs the set of experiments, because in that script we
know exactly which input data that were used to generate a specific
plot, thereby ensuring that each figure is connected to the
right data. Take a look at an
<a href="http://hplgit.github.com/INF5620/doc/writing_reports/sphinx-cloud/">example</a>  to see what we have in
mind.

<p>

<h4>Plain HTML  <a name="___sec57"></a></h4>
<p>
Scientific reports can be written in a variety of formats. Here we
begin with the <a href="http://en.wikipedia.org/wiki/HTML">HTML</a> format
which allows efficient browsing of all the experiments in any web
browser. An extended version of the <tt>dc_exper1.py</tt> from the last
section, called <a href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_exper1_html.py"><tt>dc_exper1_html.py</tt></a>,
adds code at the end for creating an HTML file with a summary, a
section on the mathematical problem, a section on the numerical
method, a section on the <tt>solver</tt> function implementing the
method, and a section with subsections containing figures that shows
the results of experiments where \( \Delta t \) is varied for
\( \theta=0,0.5,1 \). The mentioned
Python file contains all the details for writing
this <a href="http://hplgit.github.com/INF5620/doc/writing_reports/report_html.html">HTML report</a>.

<p>

<h4>HTML with MathJax  <a name="___sec58"></a></h4>
<p>
Scientific reports usually need mathematical formulas and hence
mathematical typesetting. In plain HTML, as used in the
<tt>dc_exper1_html.py</tt> file, we have to use just the keyboard
characters to write mathematics. However, there is an extension to
HTML, called <a href="http://www.mathjax.org/">MathJax</a>, that allows
formulas and equations to be typeset with LaTeX syntax and nicely
rendered in web browsers.  A relatively small subset of LaTeX
environments is supported, but the syntax for formulas is quite
rich. Inline formulas are look like <tt>\( u'=-au \)</tt> while equations are
surrounded by <tt>$$</tt> signs.  Inside such signs, one can use <tt>\[ u'=-au
\]</tt> for unnumbered equations, or <tt>\begin{equation}</tt> and
<tt>\end{equation}</tt> surrounding <tt>u'=-au</tt> for numbered equations, or <tt>\begin{align}</tt>
and <tt>\end{align}</tt> for multiple aligned equations, with (<tt>align</tt>) or
without (<tt>align*</tt>) numbers and labels.

<p>
The file <a href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_exper1_html.py"><tt>dc_exper1_mathjax.py</tt></a>
contains all the details for turning the previous plain HTML report
into <a href="http://hplgit.github.com/INF5620/doc/writing_reports/report_html_mathjax.html">web pages with nicely typeset mathematics</a>.

<p>

<h4>LaTeX  <a name="___sec59"></a></h4>
<p>
<!-- "http://en.wikibooks.org/wiki/LaTeX" -->

<p>
The <em>de facto</em> language for mathematical typesetting and scientific
report writing is <a href="http://en.wikipedia.org/wiki/LaTeX">LaTeX</a>.  A
number of very sophisticated packages have been added to the language
over a period of three decades, allowing very fine-tuned layout and
typesetting. For output in the <a href="http://hplgit.github.com/INF5620/doc/writing_reports/report.pdf">PDF format</a>, LaTeX is
the definite choice when it comes to quality. The LaTeX language used
to write the reports has typically a lot of commands involving
<a href="http://hplgit.github.com/INF5620/doc/writing_reports/report.tex.html">backslashes and braces</a>.
For output on
the web, using HTML (and not the PDF directly in the browser window),
LaTeX struggles with delivering high quality typesetting. Other tools,
especially Sphinx, gives better results and can also produce
nice-looking PDFs.

<p>

<p>

<h4>Sphinx  <a name="___sec60"></a></h4>
<p>
<!-- give pointers to source pages -->

<p>
<a href="http://sphinx.pocoo.org/">Sphinx</a> is a typesetting language with
similarities to HTML and LaTeX, but with much less tagging. It has
recently become very popular for software documentation and
mathematical reports. Sphinx can utilize MathJax or LaTeX for
mathematical formulas and equations, but has limitations compared to
both tools. The Sphinx <a href="http://hplgit.github.com/INF5620/doc/writing_reports/report_sphinx.rst.html">syntax</a>
is an extension of the reStructuredText language, and comes with rich
support for <a href="http://hplgit.github.com/INF5620/doc/writing_reports/sphinx-cloud/index.html">fancy layout of web pages</a>. In
particular, Sphinx can easily be combined with various layout <em>themes</em>
that give a certain look and feel to the web site and that offers
table of contents, navigation, search facilities, etc.

<p>

<p>

<h4>Markdown  <a name="___sec61"></a></h4>
<p>
A recently popular format for easy writing of web pages is
<a href="http://daringfireball.net/projects/markdown/">Markdown</a>.
Text is written very much like one would do in email, using
spacing and special characters to naturally format the code
instead of heavily tagging the text as in LaTeX and HTML.
With the tool <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> one
can go from Markdown to a variety of formats.
HTML is a common output format, but LaTeX, epub, XML,
OpenOffice, MediaWiki, and MS Word are some other possibilities.

<p>

<h4>Wiki formats  <a name="___sec62"></a></h4>
<p>
A range of wiki formats are popular for creating notes on the web,
especially documents which allow groups of people to edit and evolve
the content. Apart from <a href="http://www.mediawiki.org/wiki/MediaWiki">MediaWiki</a> (the wiki format used for
Wikipedia), wiki formats have no support for mathematical typesetting
and also limited tools for displaying computer code in nice ways.
Wiki formats are therefore less suitable for scientific reports compared
to the other formats mentioned here.

<p>

<h4>Doconce  <a name="___sec63"></a></h4>
<p>
Since it is difficult to choose the right tool or format for writing
a scientific report, it is advantageous to write the content in a
format that easily can be translated to LaTeX, HTML, Sphinx, Markdown,
and wikis. <a href="http://code.google.com/p/doconce">Doconce</a> is such
a tool. It is similar to Pandoc, but offers some special convenient
features for writing about mathematics and programming.
The tagging is modest, <a href="http://hplgit.github.com/INF5620/doc/writing_reports/report.do.txt.html">somewhere between LaTeX and Markdown</a>.

<p>
The HTML, LaTeX PDF, Sphinx, and Doconce formats for the scientific
report whose content is outlined above, are exemplified
with source codes and results at the <a href="http://hplgit.github.com/INF5620/doc/writing_reports/">web pages associated with this
teaching material</a>.

<p>
<!-- project with exploring instability (help with matplotlib contour plots, and maybe show such a plot) -->

<p>

<h3>Publishing a complete project <a name="decay:exper:github"></a></h3>
<p>

<p>
A report documenting scientific investigations should be accompanied by
all the software and data used for the investigations so that others
have a possibility to redo the work and assess the qualify of the results.
This possibility is important for <em>reproducible research</em> and
hence reaching reliable scientific conclusions.

<p>
One way of documenting a complete project is to make a folder tree
with all relevant files. Preferably, the tree is published at
some project hosting site like <a href="http://hplgit.github.com/teamods/bitgit/html/">Bitbucket, GitHub, or Googlecode</a> so that others can download it
as a tarfile, zipfile, or clone the files directly using a version control
system like Mercurial or Git.
For the investigations outlined in the section <a href="#decay:exper:report">Making a report</a>,
we can create a folder tree with files
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">src/dc_exper1_mathjax.py
doc/report.html
doc/run.sh
</pre></div>
<p>
The <tt>run.sh</tt> file is a simple Bash script listing the <tt>python</tt> command
we used to generate the experiments that are documented in <tt>report.html</tt>.

<p>
<!-- Point to Doconce version -->

<p>
<!-- Big project on instability -->

<p>

<h2>Exercises  <a name="___sec65"></a></h2>
<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 1: Experiment with integer division <a name="decay:exer:intdiv"></a></h3>
<p>

<p>
Explain what happens in the following computations, where
some are (mathematically) unexpected:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; dt = 3
&gt;&gt;&gt; T = 8
&gt;&gt;&gt; N = T/dt
&gt;&gt;&gt; N
2
&gt;&gt;&gt; theta = 1; a = 1
&gt;&gt;&gt; (1 - (1-theta)*a*dt)/(1 + theta*dt*a)
0
</pre></div>
<p>
Filename: <tt>pyproblems.txt</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 2: Experiment with wrong computations <a name="decay:exer:decay1err"></a></h3>
<p>

<p>
Consider the <tt>solver</tt> function in the <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_v1.py"><tt>dc_v1.py</tt></a>
and the following call:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=7</span>, dt<span style="color: #666666">=2</span>, theta<span style="color: #666666">=1</span>)
</pre></div>
<p>
The output becomes
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t= 0.000 u=1
t= 2.000 u=0
t= 4.000 u=0
t= 6.000 u=0
</pre></div>
<p>
Print out the result of all intermediate computations and use
<tt>type(v)</tt> to see the object type of the result stored in <tt>v</tt>.
Examine the intermediate calculations and explain
why <tt>u</tt> is wrong and why we compute up to \( t=6 \) only even though we
specified \( T=7 \).
Filename: <tt>dc_v1_err.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 3: Implement specialized functions <a name="decay:exer:FEBECN"></a></h3>
<p>

<p>
Implement a specialized Python function <tt>ForwardEuler</tt> that solves
the problem \( u'=-au \), \( u(0)=I \), using the Forward Euler method.
Do not reimplement the solution algorithm, but let the <tt>ForwardEuler</tt>
function call the <tt>solver</tt> function. Import this latter function
from the module <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_mod.py"><tt>dc_mod</tt></a>.
Also make similar functions <tt>BackwardEuler</tt> and <tt>CrankNicolson</tt>.
Filename: <tt>dc_FE_BE_CN.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 4: Plot the error function <a name="decay:exer:plot:error"></a></h3>
<p>

<p>
Solve the problem \( u'=-au \), \( u(0)=I \), using the Forward Euler, Backward
Euler, and Crank-Nicolson schemes. For each scheme, plot the error function
\( e_n = \uex(t_n)-u^n \) for \( \Delta t \), \( \frac{1}{4}\Delta t \), and
\( \frac{1}{8}\Delta t \), where \( \uex \) is the exact solution of the ODE and
\( u^n \) is the numerical solution at mesh point \( t_n \).
Filename: <tt>decay_plot_error.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 5: Compare methods for a give time mesh <a name="decay:exer:plot:dtconst"></a></h3>
<p>

<p>
Make a program that imports the <tt>solver</tt> function from the
<tt>dc_mod</tt> module and offers a function <tt>compare(dt, I, a)</tt> for
comparing, in a plot, the methods corresponding to \( \theta=0,0.5,1 \)
and the exact solution.  This plot shows the accuracy of the methods
for a given time mesh. Read input data for the problem from the
command line using appropriate functions in the <tt>dc_mod</tt> module
(the <tt>--dt</tt> option for giving several time step values can be reused:
just use the first time step value for the computations).
Filename: <tt>decay_compare_theta.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 6: Change formatting of numbers and debug <a name="decay:exer:inexact:output"></a></h3>
<p>

<p>
The <a href="http://github.hplgit.com/INF5620/src/decay/dc_memsave.py"><tt>dc_memsave.py</tt></a> program
writes the time values and solution values to a file which looks
like
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">0.0000000000000000E+00  1.0000000000000000E+00
2.0000000000000001E-01  8.3333333333333337E-01
4.0000000000000002E-01  6.9444444444444453E-01
6.0000000000000009E-01  5.7870370370370383E-01
8.0000000000000004E-01  4.8225308641975323E-01
1.0000000000000000E+00  4.0187757201646102E-01
1.2000000000000000E+00  3.3489797668038418E-01
1.3999999999999999E+00  2.7908164723365347E-01
</pre></div>
<p>
Modify the file output such that it looks like
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">0.000  1.00000
0.200  0.83333
0.400  0.69444
0.600  0.57870
0.800  0.48225
1.000  0.40188
1.200  0.33490
1.400  0.27908
</pre></div>
<p>
Run
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay8_v2.py --T 10 --theta 1 --dt 0.2 --makeplot
</pre></div>
<p>
The program just prints <tt>Bug in the implementation!</tt> and does not
show the plot. What went wrong?
Filename: <tt>dc_memsave_v2.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 7: Write a doctest <a name="decay:exer:doctest1"></a></h3>
<p>

<p>
Type in the following program and equip the <tt>roots</tt> function with a doctest:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>
<span style="color: #008800; font-style: italic"># This sqrt(x) returns real if x&gt;0 and complex if x&lt;0</span>
<span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy.lib.scimath</span> <span style="color: #AA22FF; font-weight: bold">import</span> sqrt

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">roots</span>(a, b, c):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Return the roots of the quadratic polynomial</span>
<span style="color: #BB4444; font-style: italic">    p(x) = a*x**2 + b*x + c.</span>

<span style="color: #BB4444; font-style: italic">    The roots are real or complex objects.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    q <span style="color: #666666">=</span> b<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">4*</span>a<span style="color: #666666">*</span>c
    r1 <span style="color: #666666">=</span> (<span style="color: #666666">-</span>b <span style="color: #666666">+</span> sqrt(q))<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>a)
    r2 <span style="color: #666666">=</span> (<span style="color: #666666">-</span>b <span style="color: #666666">-</span> sqrt(q))<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>a)
    <span style="color: #AA22FF; font-weight: bold">return</span> r1, r2

a, b, c <span style="color: #666666">=</span> [<span style="color: #AA22FF">float</span>(arg) <span style="color: #AA22FF; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>:]]
<span style="color: #AA22FF; font-weight: bold">print</span> roots(a, b, c)
</pre></div>
<p>
Make sure to test both real and complex roots.
Write out numbers with 14 digits or less.
Filename: <tt>doctest_roots.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 8: Write a nose test <a name="decay:exer:nosetest1"></a></h3>
<p>

<p>
Make a nose test for the <tt>roots</tt> function in <a href="#decay:exer:doctest1">Exercise 7: Write a doctest</a>.
Filename: <tt>test_roots.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 9: Make a module <a name="decay:exer:module1"></a></h3>
<p>

<p>
Let
$$ q(t) = \frac{RAe^{at}}{R + A(e^{at} - 1)}
\thinspace .
$$
Make a Python module <tt>q_module</tt> containing two functions <tt>q(t)</tt> and
<tt>dqdt(t)</tt> for computing \( q(t) \) and \( q'(t) \), respectively. Perform a
<tt>from numpy import *</tt> in this module. Import <tt>q</tt> and <tt>dqdt</tt> in another
file using the "star import" construction <tt>from q_module import
*</tt>. All objects available in this file is given by <tt>dir()</tt>. Print
<tt>dir()</tt> and <tt>len(dir())</tt>.  Then change the import of <tt>numpy</tt> in
<tt>q_module.py</tt> to <tt>import numpy as np</tt>. What is the effect of this
import on the number of objects in <tt>dir()</tt> in a file that does <tt>from
q_module import *</tt>?

<p>
<!-- \frac{du}{dt}=au\left(1-\frac{u}{R}\right),\quad u(0)=A, -->
Filename: <tt>q_module.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 10: Make use of a class implementation <a name="decay:exer:dc_class:exper"></a></h3>
<p>

<p>
We want to solve the exponential decay problem \( u'=-au \), \( u(0)=I \),
for several \( \Delta t \) values and \( \theta=0,0.5,1 \).
For each \( \Delta t \) value, we want to make a plot where the
three solutions corresponding to \( \theta=0,0.5,1 \) appear along with
the exact solution.
Write a function <tt>experiment</tt> to accomplish this. The function should
import the classes <tt>Problem</tt>, <tt>Solver</tt>, and <tt>Visualizer</tt> from the
<a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_class.py"><tt>decay_class1</tt></a>
module and make use of these. A new command-line option <tt>--dt_values</tt>
must be added to allow the user to specify the \( \Delta t \) values on
the command line (the options <tt>--dt</tt> and <tt>--theta</tt> have then no effect
when running the <tt>experiment</tt> function).
Note that the classes in the <tt>decay_class1</tt> module should <em>not</em> be
modified.
Filename: <tt>dc_class_exper.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<h2>Analysis of the \( \theta \)-rule for a decay ODE <a name="decay:analysis"></a></h2>
<p>

<p>
We address the ODE for exponential decay,
$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I,
\end{equation}
$$
where \( a \) and \( I \) are given constants. This problem is solved
by the \( \theta \)-rule finite difference scheme, resulting in
the recursive equations
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n
\label{decay:analysis:scheme}
\end{equation}
$$
for the numerical solution \( u^{n+1} \), which approximates the exact
solution \( \uex \) at time point \( t_{n+1} \). For constant mesh spacing,
which we assume here, \( t_{n+1}=(n+1)\Delta t \).

<p>

<p>

<h3>Discouraging numerical solutions  <a name="___sec77"></a></h3>
<p>
Choosing \( I=1 \), \( a=2 \), and running experiments with \( \theta =1,0.5, 0 \)
for \( \Delta t=1.25, 0.75, 0.5, 0.1 \), gives the results in
Figures <a href="#decay:analysis:BE4c">11</a>, <a href="#decay:analysis:CN4c">12</a>, and
<a href="#decay:analysis:FE4c">13</a>.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  Backward Euler. <a name="decay:analysis:BE4c"></a> </p></center>
<p><img src="fig-decay/BE4c.png" align="bottom" width=600,></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 12:  Crank-Nicolson. <a name="decay:analysis:CN4c"></a> </p></center>
<p><img src="fig-decay/CN4c.png" align="bottom" width=600,></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 13:  Forward Euler. <a name="decay:analysis:FE4c"></a> </p></center>
<p><img src="fig-decay/FE4c.png" align="bottom" width=600,></p>
</center>

<p>

<p>
The characteristics of the displayed curves can be summarized as follows:

<p>

<ul>
  <li> The Backward Euler scheme always give a monotone solution, lying above
    the exact curve.
  <li> The Crank-Nicolson scheme gives the most accurate results, but for
    \( \Delta t=1.25 \) the solution oscillates.
  <li> The Forward Euler scheme gives a growing, oscillating solution for
    \( \Delta t=1.25 \); a decaying, oscillating solution for \( \Delta t=0.75 \);
    a strange solution \( u^n=0 \) for \( n\geq 1 \) when \( \Delta t=0.5 \); and
    a solution seemingly as accurate as the one by the Backward Euler
    scheme for \( \Delta t = 0.1 \), but the curve lies below the exact
    solution.
</ul>

Since the exact solution of our model problem is a monotone function,
\( u(t)=Ie^{-at} \), some of these qualitatively wrong results are indeed alarming!

<p>

<h3>Experimental investigation of oscillatory solutions  <a name="___sec78"></a></h3>
<p>
We may ask the question: Under what circumstances, i.e., values of
the input data \( I \), \( a \), and \( \Delta t \) will the Forward Euler and
Crank-Nicolson schemes result in undesired oscillatory solutions?

<p>
We may set up an experiment where we loop over values of \( I \), \( a \),
and \( \Delta t \). For each experiment, we flag the solution as
oscillatory if
$$ u^{n} > u^{n-1},$$
for some value of \( n \),
since we expect \( u^n \) to decay with \( n \), but oscillations make
\( u \) increase over a time step. We will quickly see that
oscillations are independent of \( I \), but do depend on \( a \) and
\( \Delta t \). Therefore, we introduce a two-dimensional
function \( B(a,\Delta t) \) which is 1 if oscillations occur
and 0 otherwise. We can visualize \( B \) as a contour plot
(lines for which \( B=\hbox{const} \)). The contour \( B=0.5 \) will
correspond to the borderline between oscillatory regions with \( B=1 \)
and monotone regions with \( B=0 \) in the \( a-\Delta t \) plane.

<p>
The \( B \) function is defined at discrete \( a \) and \( \Delta t \) values.
Say we have given \( P \) $a$ values, \( a_0,\ldots,a_{P-1} \), and
\( Q \) $\Delta t$ values, \( \Delta t_0,\ldots,\Delta t_{Q-1} \).
These \( a_i \) and \( \Delta t_j \) values, \( i=0,\ldots,P-1 \),
\( j=0,\ldots,Q-1 \), form a rectangular mesh of \( P\times Q \) points
in the plane. At each point \( (a_i, \Delta t_j) \), we associate
the corresponding value of \( B(a_i,\Delta t_j) \), denoted \( B_{ij} \).
The \( B_{ij} \) values are naturally stored in a two-dimensional
array. Both Matplotlib and SciTools can create a plot of the
contour line \( B_{ij}=0.5 \) dividing the oscillatory and monotone
regions. The file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_osc_regions.py"><tt>dc_osc_regions.py</tt></a> contains all nuts and
bolts to produce the \( B=0.5 \) line in Figures <a href="#decay:analysis:B:FE">14</a>
and <a href="#decay:analysis:B:CN">15</a>. The oscillatory region is above this line.

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">dc_mod</span> <span style="color: #AA22FF; font-weight: bold">import</span> solver
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">st</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">non_physical_behavior</span>(I, a, T, dt, theta):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Given lists/arrays a and dt, and numbers I, dt, and theta,</span>
<span style="color: #BB4444; font-style: italic">    make a two-dimensional contour line B=0.5, where B=1&gt;0.5</span>
<span style="color: #BB4444; font-style: italic">    means oscillatory (unstable) solution, and B=0&lt;0.5 means</span>
<span style="color: #BB4444; font-style: italic">    monotone solution of u&#39;=-au.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(a); dt <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(dt)  <span style="color: #008800; font-style: italic"># must be arrays</span>
    B <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #AA22FF">len</span>(a), <span style="color: #AA22FF">len</span>(dt)))         <span style="color: #008800; font-style: italic"># results</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(a)):
        <span style="color: #AA22FF; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #AA22FF">len</span>(dt)):
            u, t <span style="color: #666666">=</span> solver(I, a[i], T, dt[j], theta)
            <span style="color: #008800; font-style: italic"># Does u have the right monotone decay properties?</span>
            correct_qualitative_behavior <span style="color: #666666">=</span> <span style="color: #AA22FF">True</span>
            <span style="color: #AA22FF; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #666666">1</span>, <span style="color: #AA22FF">len</span>(u)):
                <span style="color: #AA22FF; font-weight: bold">if</span> u[n] <span style="color: #666666">&gt;</span> u[n<span style="color: #666666">-1</span>]:  <span style="color: #008800; font-style: italic"># Not decaying?</span>
                    correct_qualitative_behavior <span style="color: #666666">=</span> <span style="color: #AA22FF">False</span>
                    <span style="color: #AA22FF; font-weight: bold">break</span>  <span style="color: #008800; font-style: italic"># Jump out of loop</span>
            B[i,j] <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(correct_qualitative_behavior)
    a_, dt_ <span style="color: #666666">=</span> st<span style="color: #666666">.</span>ndgrid(a, dt)  <span style="color: #008800; font-style: italic"># make mesh of a and dt values</span>
    st<span style="color: #666666">.</span>contour(a_, dt_, B, <span style="color: #666666">1</span>)
    st<span style="color: #666666">.</span>grid(<span style="color: #BB4444">&#39;on&#39;</span>)
    st<span style="color: #666666">.</span>title(<span style="color: #BB4444">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> theta)
    st<span style="color: #666666">.</span>xlabel(<span style="color: #BB4444">&#39;a&#39;</span>); st<span style="color: #666666">.</span>ylabel(<span style="color: #BB4444">&#39;dt&#39;</span>)
    st<span style="color: #666666">.</span>savefig(<span style="color: #BB4444">&#39;osc_region_theta_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">.png&#39;</span> <span style="color: #666666">%</span> theta)
    st<span style="color: #666666">.</span>savefig(<span style="color: #BB4444">&#39;osc_region_theta_</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BB4444">.eps&#39;</span> <span style="color: #666666">%</span> theta)

non_physical_behavior(
    I<span style="color: #666666">=1</span>,
    a<span style="color: #666666">=</span>np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.01</span>, <span style="color: #666666">4</span>, <span style="color: #666666">22</span>),
    dt<span style="color: #666666">=</span>np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.01</span>, <span style="color: #666666">4</span>, <span style="color: #666666">22</span>),
    T<span style="color: #666666">=6</span>,
    theta<span style="color: #666666">=0.5</span>)
</pre></div>
<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 14:  Forward Euler scheme: oscillatory solutions occur for points above the curve. <a name="decay:analysis:B:FE"></a> </p></center>
<p><img src="fig-decay/osc_region_FE.png" align="bottom" width=500></p>
</center>

<p>

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 15:  Crank-Nicolson scheme: oscillatory solutions occur for points above the curve. <a name="decay:analysis:B:CN"></a> </p></center>
<p><img src="fig-decay/osc_region_CN.png" align="bottom" width=500></p>
</center>

<p>

<p>
By looking at the curves in the figures one may guess that \( a\Delta t \)
must be less than a critical limit to avoid the undesired
oscillations.  This limit seems to be about 2 for Crank-Nicolson and 1
for Forward Euler.  We shall now establish a mathematical analysis of
the discrete model that can explain the observations in our numerical
experiments.

<p>

<h3>Exact numerical solution  <a name="___sec79"></a></h3>
<p>
Starting with \( u^0=I \), the simple recursion \eqref{decay:analysis:scheme}
can be applied repeatedly \( n \) times, with the result that
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n\thinspace .
\label{decay:analysis:unex}
\end{equation}
$$

<p>
Difference equations where all terms are linear in
\( u^{n+1} \), \( u^n \), and maybe \( u^{n-1} \), \( u^{n-2} \), etc., are
called <em>homogeneous, linear</em> difference equations, and their solutions
are generally of the form \( u^n=A^n \). Inserting this expression
and dividing by \( A^{n+1} \) gives
a polynomial equation in \( A \). In the present case we get
$$ A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}\thinspace .$$
This is a solution technique of wider applicability than repeated use of
the recursion \eqref{decay:analysis:scheme}.

<p>
Regardless of the solution approach, we have obtained a formula for
\( u^n \).  This formula can explain everything what we see in the figures
above, but it also gives us a more general insight into accuracy and
stability properties of the three schemes.

<p>

<h3>Stability  <a name="___sec80"></a></h3>
<p>

<p>
Since \( u^n \) is a factor

<p>
$$
\begin{equation}
A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}
\end{equation}
$$
raised to an integer power (\( n \)), we realize that \( A<0 \)
will for odd powers imply \( u^n<0 \) and for even power result in \( u^n>0 \),
i.e., a solution that oscillates between the mesh points.
We have that \( A<0 \) when

<p>
$$
\begin{equation}
(1-\theta)a\Delta t > 1 \thinspace .
\label{decay:th:stability}
\end{equation}
$$
Since \( A>0 \) is a requirement for having a numerical solution with the
same basic property (monotonicity) as the exact solution, we may say
that \( A>0 \) is a <em>stability criterion</em>. Expressed in terms of \( \Delta t \)
the stability criterion reads

<p>
$$
\begin{equation}
\Delta t \leq \frac{1}{(1-\theta)a}\thinspace .
\end{equation}
$$

<p>
The Backward
Euler scheme is always stable (since \( A<0 \) is impossible), while
non-oscillating solutions for Forward Euler and Crank-Nicolson
demand \( \Delta t\leq 1/a \) and \( \Delta t\leq 2/a \), respectively.
The relation between \( \Delta t \) and \( a \) look reasonable: a smaller
\( a \) means faster decay and hence a need for smaller time steps.

<p>
Looking at Figure <a href="#decay:analysis:FE4c">13</a>, we see that with \( a\Delta
t= 2\cdot 1.25=2.5 \), \( A=-1.5 \), and the solution \( u^n=(-1.5)^n \)
oscillates <em>and</em> grows. With \( a\Delta t = 2\cdot 0.75=1.5 \), \( A=-0.5 \),
\( u^n=(-0.5)^n \) decays but oscillates. The peculiar case \( \Delta t =
0.5 \), where the Forward Euler scheme produces a solution that is stuck
on the \( t \) axis, corresponds to \( A=0 \) and therefore \( u^0=I=1 \) and
\( u^n=0 \) for \( n\geq 1 \).  The decaying oscillations in the Crank-Nicolson scheme
for \( \Delta t=1.25 \) is easily explained by \( A=-0.25 \).

<p>

<p>
The factor \( A \) is called <em>amplification factor</em> since the solution at
a new time level is \( A \) times the solution at the previous time level. For
a decay process, we must obviously have \( |A|\leq 1 \) for all \( \Delta
t \), which is fulfilled for \( \theta \geq 1/2 \). Arbitrarily large values
of \( u \) can be generated when \( |A|>1 \) and \( n \) is large enough. The
numerical solution is in such cases totally irrelevant to an ODE modeling decay
processes.

<p>

<p>

<h3>Comparing Amplification Factors  <a name="___sec81"></a></h3>
<p>
After establishing how \( A \) impacts the qualitative features of the
solution, we shall now look more into how well the numerical amplification
factor approximates the exact one. The exact solution reads
\( u(t)=Ie^{-at} \), which can be rewritten as
$$
\begin{equation}
{\uex}(t_n) = Ie^{-a n\Delta t} = I(e^{-a\Delta t})^n \thinspace .
\end{equation}
$$
From this formula we see that the exact amplification factor is
$$
\begin{equation}
\Aex = e^{-a\Delta t} \thinspace .
\end{equation}
$$

<p>
We realize that the exact and numerical amplification factors depend
on \( a \) and \( \Delta t \) through the product \( a\Delta t \). Therefore, it
is convenient to introduce a symbol for this product, \( p=a\Delta t \),
and view \( A \) and \( \Aex \) as functions of \( p \). Figure
<a href="#decay:analysis:fig:A">16</a> shows these functions. Crank-Nicolson is
clearly closest to the exact amplification factor, but that method has
the unfortunate oscillatory behavior when \( p>2 \).

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 16:  Comparison of amplification factors. <a name="decay:analysis:fig:A"></a> </p></center>
<p><img src="fig-decay/A_factors.png" align="bottom" width=500></p>
</center>

<p>

<p>

<p>

<h3>Series Expansion of Amplification Factors  <a name="___sec82"></a></h3>
<p>
As an alternative to the visual understanding
inherent in Figure <a href="#decay:analysis:fig:A">16</a>, there
is a strong tradition in numerical analysis to investigate
approximation errors when the discretization parameter, here \( \Delta t \),
becomes small. In the present case we let \( p \) be our small
discretization parameter, and it makes sense to simplify the
expressions for \( A \) and \( \Aex \) by using Taylor polynomials around \( p=0 \).
The Taylor polynomials are accurate for small \( p \) and greatly simplifies
the comparison of the analytical expressions since we then can compare
polynomials, term by term.

<p>
Calculating the Taylor series for \( \Aex \) is easily done by hand, but
the three versions of \( A \) for \( \theta=0,1,\frac{1}{2} \) lead to more
cumbersome calculations.
Nowadays, analytical computations can benefit greatly by
symbolic computer algebra software. The Python package <tt>sympy</tt>
represents a powerful computer algebra system, not as sophisticated as
the famous Maple and Mathematica systems, but free and
very easy to integrate with our numerical computations in Python.

<p>
When using <tt>sympy</tt>, it is convenient to enter the interactive Python
mode where we can write expressions and statements and immediately see
the results.  Here is a simple example. We strongly recommend to use
<tt>isympy</tt> (or <tt>ipython</tt>) for such interactive sessions, although our
typesetting will apply the different prompt <tt>>>></tt> (associated with the
primitive Python shell that results from writing <tt>python</tt> in a
terminal window).

<p>
Let us enter <tt>sympy</tt> in a Python shell and show how
we can find the Taylor series for \( e^{-p} \):
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; p = Symbol(&#39;p&#39;)  # all variables must be declared as Symbols
&gt;&gt;&gt; A_e = exp(-p)
&gt;&gt;&gt;
&gt;&gt;&gt; # First 6 terms of the Taylor series of A_e
&gt;&gt;&gt; A_e.series(p, 6)
1 + (1/2)*p**2 - p - 1/6*p**3 - 1/120*p**5 + (1/24)*p**4 + O(p**6)
</pre></div>
<p>
Lines with <tt>>>></tt> represent input lines and lines without
this prompt represents the result of computations.
Apart from the order of the powers, the computed formula is easily
recognized as the beginning of the Taylor series for \( e^{-p} \).

<p>
Let us define the numerical amplification factor where \( p \) and \( \theta \)
enter the formula as symbols:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; theta = Symbol(&#39;theta&#39;)
&gt;&gt;&gt; A = (1-(1-theta)*p)/(1+theta*p)
</pre></div>
<p>
To work with the factor for the Backward Euler scheme we
can substitute the value 1 for <tt>theta</tt>:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; A.subs(theta, 1)
1/(1 + p)
</pre></div>
<p>
Similarly, we can substitute <tt>theta</tt> by 1/2 for Crank-Nicolson,
preferably using an exact rational representation of 1/2 in <tt>sympy</tt>:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; half = Rational(1,2)
&gt;&gt;&gt; A.subs(theta, half)
1/(1 + (1/2)*p)*(1 - 1/2*p)
</pre></div>
<p>

<p>
The Taylor series of the amplification factor for the Crank-Nicolson
scheme can be computed as
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; A.subs(theta, half).series(p, 4)
1 + (1/2)*p**2 - p - 1/4*p**3 + O(p**4)
</pre></div>
<p>
We are now in a position to compare Taylor series:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; FE = A_e.series(p, 4) - A.subs(theta, 0).series(p, 4)
&gt;&gt;&gt; BE = A_e.series(p, 4) - A.subs(theta, 1).series(p, 4)
&gt;&gt;&gt; CN = A_e.series(p, 4) - A.subs(theta, half).series(p, 4)
&gt;&gt;&gt; FE
(1/2)*p**2 - 1/6*p**3 + O(p**4)
&gt;&gt;&gt; BE
-1/2*p**2 + (5/6)*p**3 + O(p**4)
&gt;&gt;&gt; CN
(1/12)*p**3 + O(p**4)
</pre></div>
<p>
From these expressions we see that the error \( A-\Aex\sim {\cal O}(p^2) \)
for the Forward and Backward Euler schemes, while
\( A-\Aex\sim {\cal O}(p^3) \) for the Crank-Nicolson scheme.
It is the <em>leading order term</em>,
i.e., the term of the lowest order (degree),
that is of interest, because as \( p\rightarrow 0 \), this term is
(much) bigger than the higher-order terms.

<p>
Now, \( a \) is a given parameter in the problem, while \( \Delta t \) is
what we can vary. One therefore usually writes the error expressions in
terms \( \Delta t \). When then have
$$
\begin{equation}
A-\Aex = \left\lbrace\begin{array}{ll}
{\cal O}(\Delta t^2), & \hbox{Forward and Backward Euler},\\
{\cal O}(\Delta t^3), & \hbox{Crank-Nicolson}
\end{array}\right.
\end{equation}
$$
What is the significance of this result? If we halve \( \Delta t \),
the error in amplification factor at a time level will be reduced
by a factor of 4 in the Forward and Backward Euler schemes, and by
a factor of 8 in the Crank-Nicolson scheme. That is, as we
reduce \( \Delta t \) to obtain more accurate results, the Crank-Nicolson
scheme reduces the error more efficiently than the other schemes.

<p>

<h3>Local error  <a name="___sec83"></a></h3>
<p>
(max/infinity norm etc).
Both errors can be investigated analytically.]

<p>

<h3>Analytical comparison of schemes  <a name="___sec84"></a></h3>
<p>
An alternative comparison of the schemes is to look at the
ratio \( A/\Aex \), or the error \( 1-A/\Aex \) in this ratio:
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; FE = 1 - (A.subs(theta, 0)/A_e).series(p, 4)
&gt;&gt;&gt; BE = 1 - (A.subs(theta, 1)/A_e).series(p, 4)
&gt;&gt;&gt; CN = 1 - (A.subs(theta, half)/A_e).series(p, 4)
&gt;&gt;&gt; FE
(1/2)*p**2 + (1/3)*p**3 + O(p**4)
&gt;&gt;&gt; BE
-1/2*p**2 + (1/3)*p**3 + O(p**4)
&gt;&gt;&gt; CN
(1/12)*p**3 + O(p**4)
</pre></div>
<p>
The leading-order terms have the same powers as
in the analysis of \( A-\Aex \).

<p>

<h3>The real (global) error at a point  <a name="___sec85"></a></h3>
<p>
The error in the amplification factor reflects the error when
progressing from time level \( t_n \) to \( t_{n-1} \).
To investigate the real error at a point, known as the <em>global error</em>,
we look at \( u^n-\uex(t_n) \) for some \( n \) and Taylor expand the
mathematical expressions as functions of \( p=a\Delta t \):
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; n = Symbol(&#39;n&#39;)
&gt;&gt;&gt; u_e = exp(-p*n)
&gt;&gt;&gt; u_n = A**n
&gt;&gt;&gt; FE = u_e.series(p, 4) - u_n.subs(theta, 0).series(p, 4)
&gt;&gt;&gt; BE = u_e.series(p, 4) - u_n.subs(theta, 1).series(p, 4)
&gt;&gt;&gt; CN = u_e.series(p, 4) - u_n.subs(theta, half).series(p, 4)
&gt;&gt;&gt; FE
(1/2)*n*p**2 - 1/2*n**2*p**3 + (1/3)*n*p**3 + O(p**4)
&gt;&gt;&gt; BE
(1/2)*n**2*p**3 - 1/2*n*p**2 + (1/3)*n*p**3 + O(p**4)
&gt;&gt;&gt; CN
(1/12)*n*p**3 + O(p**4)
</pre></div>
<p>
For a fixed time \( t \), the parameter \( n \) in these expressions increases
as \( p\rightarrow 0 \) since \( t=n\Delta t \). That is, \( n=t/\Delta t \), and
the leading-order error terms therefore become \( \frac{1}{2}na^2\Delta
t^2 = \frac{1}{2}ta^2t\Delta t \) for the Forward and Backward Euler
scheme, and \( \frac{1}{12}na^3\Delta t^3 = \frac{1}{12}ta^3\Delta t^2 \)
for the Crank-Nicolson scheme.  The global error is therefore of
second order in \( \Delta t \) for the latter scheme and first order for
the former schemes.

<p>

<h3>Integrated errors  <a name="___sec86"></a></h3>
<p>
The formulas for various error measures have so far measured the
error at one time point. Many prefer to use the error
integrated over the whole time interval of interest: \( [0,T] \).
An immediate practical problem arises, however, since the
numerical solution is only known at the mesh points, while an
integration will need this solution also at the points between
the mesh points. Let \( \tilde u \) be a continuous representation
of the numerical solution, usually obtained by drawing straight
lines between the values at the mesh points. Then
a common measure of the global error is the so-called \( L^2 \) error:
$$
\begin{equation}
E_2 = \sqrt{\int_0^T ({\uex}(t) - \tilde u(t))^2dt} \thinspace .
\end{equation}
$$
A family of such measures is the \( L^p \) errors, defined as
$$
\begin{equation}
E_p = \left(\int_0^T ({\uex}(t) - \tilde u(t))^pdt\right)^{1/p} \thinspace .
\end{equation}
$$
For \( p=1 \) we just take the absolute value of the integrand.

<p>
Strictly speaking, it is questionable in a finite difference method
to introduce an additional approximation in the error measure,
namely how \( \tilde u \) varies
between the mesh points. Some may argue and say that the numerical
solution is defined at the mesh points only and that we should
approximate the integrals above by numerical methods involving
the integrand at just the mesh points. The numerical integration
method also represents an approximation, but a discrete integration
procedure is consistent with having only discrete values of the integrand.

<p>
For uniformly distributed mesh points we have the well-known Trapezoidal
rule,
$$
\begin{equation}
E_2 \approx \left(\Delta t\left( \half ({\uex}(0) - u^0)^2
+ \half ({\uex}(T) - u^N)^2  + \sum_{k=1}^{N-1} ({\uex}(k\Delta t) - u^k)^2 \right)
\right)^{1/2} \thinspace .
\label{decay:E2:Tr}
\end{equation}
$$
In case the mesh points are arbitrarily spaced, we have an immediate
generalization in terms of the sum of the various trapezoids:
$$
\begin{equation}
E_2 \approx \left(\half\sum_{k=0}^{N-1}(t_{k+1} - t_k)
\left( ({\uex}(k\Delta t) - u^k)^2 + ({\uex}((k+1)\Delta t) - u^{k+1})^2\right)
\right)^{1/2} \thinspace .
\label{decay:E2:Trg}
\end{equation}
$$
A simpler approximation is to use rectangles whose heights are determined
by the left (or right) value in each interval:
$$
\begin{equation}
E_2 \approx \left(\sum_{k=0}^{N-1}(t_{k+1} - t_k)({\uex}(k\Delta t) - u^k)^2
\right)^{1/2} \thinspace .
\label{decay:E2:Reg1}
\end{equation}
$$
With uniformly distributed mesh points we get the simplification
$$
\begin{equation}
E_2 \approx \left(\Delta t\sum_{k=0}^{N-1}({\uex}(k\Delta t) - u^k)^2
\right)^{1/2} \thinspace .
\label{decay:E2:Reg}
\end{equation}
$$

<p>
Suppose that in a program the \( u^k \) values are available as elements
in the array <tt>u</tt>, while the \( {\uex}(k\Delta t) \) values are available
as elements in the array <tt>u_e</tt>. The formula \eqref{decay:E2:Reg} can
then be calculated as follows by array arithmetics in Python:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">E2 = sqrt(dt*sum((u_e - u)**2))
</pre></div>
<p>
This is exactly the "array formula" that popped up in
the section <a href="#decay:computing:error">Computing the numerical error</a>.

<p>
Integrated error measures sum up the contributions from each mesh point,
so we must expect the global error to be larger than
the local error. Roughly speaking, if \( |\uex(t_n) - u^n|\sim ta^{r+1}\Delta t^r \), we have
$$ E \approx \sqrt{\Delta t\sum_{i=0}^N i^2a^{2(r+1)}\Delta t^{2r+1}} =
\sqrt{a^{2(r+1)}\Delta t^{2r+2} \sum_i i^2} \approx
a^{r+1}\Delta t^{r+1} N^{3/2} = a^{r+1}\Delta t^{r-1/2} T^{3/2} ,$$
since \( t=i\Delta t \), \( \sum_{i=0}^N i^2\approx \frac{1}{3}N^3 \), and
\( N=T/Delta t \).

<p>

<p>

<h2>Exercises  <a name="___sec65"></a></h2>
<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 11: Explore the \( \theta \)-rule for exponential growth <a name="decay:analysis:exer:growth"></a></h3>
<p>

<p>
Solve the ODE \( u'=-au \) with \( a<0 \) such that the ODE models
exponential growth. Run experiments with \( \theta \) and \( \Delta t \) using
the <tt>dc_exper1.py</tt> code modified to your needs.
Are there any numerical artifacts?
Filename: <tt>growth_exper1.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 12: Summarize investigations in a report <a name="decay:analysis:exer:growth:report"></a></h3>
<p>

<p>
Write a scientific report about the findings in
<a href="#decay:analysis:exer:growth">Exercise 11: Explore the \( \theta \)-rule for exponential growth</a>.
You can use examples from the section <a href="#decay:exper:report">Making a report</a> to
see how various formats can be used for scientific reports.
Filename: <tt>growth_analysis.pdf</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 13: Plot amplification factors for exponential growth <a name="decay:analysis:exer:growth:A"></a></h3>
<p>

<p>
Modify the <tt>dc_ampf_plot.py</tt> code to visualize the
amplification factors for \( \theta =0, 0.5, 1 \) and the exact
amplification factor in case of exponential growth as in
<a href="#decay:analysis:exer:growth">Exercise 11: Explore the \( \theta \)-rule for exponential growth</a>.  Explain the
artifacts seen in <a href="#decay:analysis:exer:growth">Exercise 11: Explore the \( \theta \)-rule for exponential growth</a>.
Filename: <tt>growth_ampf_plot.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<h2>Model extensions  <a name="___sec91"></a></h2>
<p>
It is time to consider generalizations of the simple decay model
\( u=-au \), where \( a \) is constant, and also to look at other numerical
solution methods.

<p>

<h3>Extension to a variable coefficient  <a name="___sec92"></a></h3>
<p>
In the ODE for decay, \( u'=-au \), we now consider the case where \( a \)
depends on time:

<p>
$$
\begin{equation}
u'(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I \thinspace .
\label{decay:problem:a}
\end{equation}
$$

<p>
A Forward Euler scheme consist of evaluating \eqref{decay:problem:a}
at \( t=t_n \) and approximating the derivative with a forward
difference \( [D^+_t u]^n \):

<p>
$$
\begin{equation}
\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
\thinspace .
\end{equation}
$$
The Backward Euler scheme becomes
$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
\thinspace .
\end{equation}
$$
The Crank-Nicolson method builds on sampling the ODE at
\( t_{n+\frac{1}{2}} \). We can evaluate \( a \) at \( t_{n+\frac{1}{2}} \)
and use an average for \( u \) at
times \( t_n \) and \( t_{n+1} \):
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\frac{1}{2}})\frac{1}{2}(u^n + u^{n+1})
\thinspace .
\end{equation}
$$
Alternatively, we can use an average for the product \( au \):

<p>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -\frac{1}{2}(a(t_n)u^n + a(t_{n+1})u^{n+1})
\thinspace .
\end{equation}
$$
The \( \theta \)-rule unifies the three mentioned schemes,

<p>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
\thinspace .
\end{equation}
$$
or,
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
\thinspace .
\end{equation}
$$

<p>
With the finite difference operator notation the Forward Euler and Backward
Euler schemes can be summarized as

<p>
$$
\begin{align}
\lbrack D^+_t u &= -au\rbrack^n,\\
\lbrack D^-_t u &= -au\rbrack^n
\thinspace .
\end{align}
$$
The Crank-Nicolson and \( \theta \) schemes depend on whether we evaluate
\( a \) at the sample point for the ODE or if we use an average. The
various versions are written as

<p>
$$
\begin{align}
\lbrack D_t u &= -a\overline{u}^t\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u &= -\overline{au}^t\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u &= -a\overline{u}^{t,\theta}\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u &= -\overline{au}^{t,\theta}\rbrack^{n+\frac{1}{2}}
\thinspace .
\end{align}
$$

<p>

<p>

<h3>Extension to a source term <a name="decay:source"></a></h3>
<p>

<p>
A further extension of the model ODE is to include a source term \( b(t) \):

<p>
$$
\begin{equation}
u'(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
\thinspace .
\label{decay:problem:ab}
\end{equation}
$$

<p>

<h4>Schemes  <a name="___sec94"></a></h4>
<p>
The time point where we sample the ODE determines where \( b(t) \) is
evaluated. For the Crank-Nicolson scheme and the \( \theta \)-rule we
have a choice of whether to evaluate \( a(t) \) and \( b(t) \) at the
correct point or use an average. The chosen strategy becomes
particularly clear if we write up the schemes in the operator notation:

<p>
$$
\begin{align}
\lbrack D^+_t u &= -au + b\rbrack^n,\\
\lbrack D^-_t u &= -au + b\rbrack^n,\\
\lbrack D_t u   &= -a\overline{u}^t + b\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u   &= \overline{-au+b}^t\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u   &= -a\overline{u}^{t,\theta} + b\rbrack^{n+\theta},\\
\lbrack D_t u   &= \overline{-au+b}^{t,\theta}\rbrack^{n+\theta}
\thinspace .
\end{align}
$$

<p>

<h3>Implementation of the generalized model problem <a name="decay:general"></a></h3>
<p>

<p>

<h4>Deriving the \( \theta \)-rule formula  <a name="___sec96"></a></h4>
<p>
Writing out the latter \( \theta \)-rule, using \eqref{decay:fd1:Du:theta}
and \eqref{decay:fd1:wmean:a}, we get
$$\frac{u^{n+1}-u^n}{\Delta t} = \theta(-a^{n+1}u^{n+1} + b^{n+1}))
+ (1-\theta)(-a^nu^{n} + b^n)),$$
where \( a^n \) means evaluating \( a \) at \( t=t_n \) and similar for
\( a^{n+1} \), \( b^n \), and \( b^{n+1} \).
We solve for \( u^{n+1} \):
$$
\begin{equation}
u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
\thinspace .
\end{equation}
$$

<p>

<h4>The Python code  <a name="___sec97"></a></h4>
<p>
A suitable implementation where \( a(t) \) and \( b(t) \) are given as
Python functions is given next.

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">solver</span>(I, a, b, T, dt, theta):
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Solve u&#39;=-a(t)*u + b(t), u(0)=I,</span>
<span style="color: #BB4444; font-style: italic">    for t in (0,T] with steps of dt.</span>
<span style="color: #BB4444; font-style: italic">    a and b are Python functions of t.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(dt)           <span style="color: #008800; font-style: italic"># avoid integer division</span>
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(<span style="color: #AA22FF">round</span>(T<span style="color: #666666">/</span>dt))     <span style="color: #008800; font-style: italic"># no of time intervals</span>
    T <span style="color: #666666">=</span> N<span style="color: #666666">*</span>dt                 <span style="color: #008800; font-style: italic"># adjust T to fit time step dt</span>
    u <span style="color: #666666">=</span> zeros(N<span style="color: #666666">+1</span>)           <span style="color: #008800; font-style: italic"># array of u[n] values</span>
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)  <span style="color: #008800; font-style: italic"># time mesh</span>

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I                 <span style="color: #008800; font-style: italic"># assign initial condition</span>
    <span style="color: #AA22FF; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #AA22FF">range</span>(<span style="color: #666666">0</span>, N):    <span style="color: #008800; font-style: italic"># n=0,1,...,N-1</span>
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a(t[n]))<span style="color: #666666">*</span>u[n] <span style="color: #666666">+</span> \ 
                  dt<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>b(t[n<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>b(t[n])))<span style="color: #666666">/</span>\ 
                  (<span style="color: #666666">1</span> <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>theta<span style="color: #666666">*</span>a(t[n<span style="color: #666666">+1</span>]))
    <span style="color: #AA22FF; font-weight: bold">return</span> u, t
</pre></div>
<p>
This function is found in the file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_vc.py"><tt>dc_vc.py</tt></a>.

<p>

<h4>Implementations of variable coefficients  <a name="___sec98"></a></h4>
<p>
The <tt>solver</tt> function shown above demands the arguments <tt>a</tt> and <tt>b</tt> to
be implemented as functions of <tt>t</tt>, say

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">a</span>(t):
    <span style="color: #AA22FF; font-weight: bold">return</span> a_0 <span style="color: #AA22FF; font-weight: bold">if</span> t <span style="color: #666666">&lt;</span> tp <span style="color: #AA22FF; font-weight: bold">else</span> k<span style="color: #666666">*</span>a_0

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">b</span>(t):
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">1</span>
</pre></div>
<p>
Here, <tt>a(t)</tt> has three parameters <tt>a0</tt>, <tt>tp</tt>, and <tt>k</tt>,
which must be global variables.
A better implementation is to represent <tt>a</tt> by a class where the
parameters are attributes and a <em>special method</em> <tt>__call__</tt> evaluates \( a(t) \):

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">class</span> <span style="color: #0000FF">A</span>:
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__init__</span>(<span style="color: #AA22FF">self</span>, a0<span style="color: #666666">=1</span>, k<span style="color: #666666">=2</span>):
        <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a0, <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>k <span style="color: #666666">=</span> a0, k

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">__call__</span>(<span style="color: #AA22FF">self</span>, t):
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a0 <span style="color: #AA22FF; font-weight: bold">if</span> t <span style="color: #666666">&lt;</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>tp <span style="color: #AA22FF; font-weight: bold">else</span> <span style="color: #AA22FF">self</span><span style="color: #666666">.</span>k<span style="color: #666666">*</span><span style="color: #AA22FF">self</span><span style="color: #666666">.</span>a0

a <span style="color: #666666">=</span> A(a0<span style="color: #666666">=2</span>, k<span style="color: #666666">=1</span>)  <span style="color: #008800; font-style: italic"># a behaves as a function a(t)</span>
</pre></div>
<p>

<p>

<p>
For quick tests it is cumbersome to write a complete function or a class.
The <em>lambda function</em> construction in Python is then convenient. For example,
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">lambda</span> t: a_0 <span style="color: #AA22FF; font-weight: bold">if</span> t <span style="color: #666666">&lt;</span> tp <span style="color: #AA22FF; font-weight: bold">else</span> k<span style="color: #666666">*</span>a_0
</pre></div>
<p>
is equivalent to the <tt>def a(t):</tt> definition above. In general,
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">lambda</span> arg1, arg2, <span style="color: #666666">...</span>: expressin
</pre></div>
<p>
is equivalent to
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">f</span>(arg1, arg2, <span style="color: #666666">...</span>):
    <span style="color: #AA22FF; font-weight: bold">return</span> expression
</pre></div>
<p>
One can use lambda functions directly in calls. Say we want to
solve \( u'=-u+1 \), \( u(0)=1 \):
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u, t <span style="color: #666666">=</span> solver(<span style="color: #666666">1</span>, <span style="color: #AA22FF; font-weight: bold">lambda</span> t: <span style="color: #666666">1</span>, <span style="color: #AA22FF; font-weight: bold">lambda</span> t: <span style="color: #666666">1</span>, T, dt, theta)
</pre></div>
<p>
A lambda function can appear anywhere where a variable can appear.

<p>

<h3>Verification via trivial solutions <a name="decay:verify:trivial"></a></h3>
<p>

<p>
A very useful partial verification method is to construct a test
problem with a very simple solution, usually \( u=\hbox{const} \).
Especially the initial debugging of a program code can benefit greatly
from such tests, because 1) all relevant numerical methods will
exactly reproduce a constant solution, and 2) many of the intermediate
calculations are easy to control for a constant \( u \).

<p>
The only constant solution for the problem \( u'=-au \)
is \( u=0 \), but too many bugs can escape from that trivial solution.
It is much better to search for a problem where \( u=C=\hbox{const}\neq 0 \).
Then \( u'=-a(t)u + b(t) \) is more appropriate. With \( u=C \)
we can choose any \( a(t) \) and set \( b=a(t)C \) and
\( I=C \). An appropriate nose test is

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">nose.tools</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">nt</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_constant_solution</span>():
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Test problem where u=u_const is the exact solution, to be</span>
<span style="color: #BB4444; font-style: italic">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_solution</span>(t):
        <span style="color: #AA22FF; font-weight: bold">return</span> u_const

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">a</span>(t):
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">2.5*</span>(<span style="color: #666666">1+</span>t<span style="color: #666666">**2</span>)  <span style="color: #008800; font-style: italic"># can be arbitrary</span>

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">b</span>(t):
        <span style="color: #AA22FF; font-weight: bold">return</span> a(t)<span style="color: #666666">*</span>u_const

    u_const <span style="color: #666666">=</span> <span style="color: #666666">2.15</span>
    theta <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>; I <span style="color: #666666">=</span> u_const; dt <span style="color: #666666">=</span> <span style="color: #666666">4</span>
    N <span style="color: #666666">=</span> <span style="color: #666666">4</span>  <span style="color: #008800; font-style: italic"># enough with a few steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, b<span style="color: #666666">=</span>b, T<span style="color: #666666">=</span>N<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    <span style="color: #AA22FF; font-weight: bold">print</span> u
    u_e <span style="color: #666666">=</span> exact_solution(t)
    difference <span style="color: #666666">=</span> <span style="color: #AA22FF">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()  <span style="color: #008800; font-style: italic"># max deviation</span>
    nt<span style="color: #666666">.</span>assert_almost_equal(difference, <span style="color: #666666">0</span>, places<span style="color: #666666">=14</span>)
</pre></div>
<p>

<p>
An interesting question is what type of bugs that will make the
computed \( u^n \) to deviate from the exact solution \( C \).
Fortunately, the updating formula and the initial condition must
be absolutely correct for the test to pass! Any attempt to make
a wrong indexing in terms like <tt>a(t[n])</tt> or any attempt to
introduce an erroneous factor in the formula creates a solution
that is different from \( C \).

<p>

<p>

<h3>Verification via manufactured solutions <a name="decay:MMS"></a></h3>
<p>

<p>

<p>
Following the idea of the previous section, we can choose any formula
as the exact solution, insert the formula in the ODE problem and fit
\( a(t) \), \( b(t) \), and I to make the formula fulfill the equation. This
powerful technique for generating exact solutions is very useful for
verification purposes and known as the <em>method of manufactured
solutions</em>, often abbreviated MMS.

<p>
One common choice of solution is a linear function in the independent
variable(s). The rationale behind such a simple variation is that
almost any relevant numerical solution method for differential
equation problems is able to reproduce the linear function exactly (to
machine precision). The linear solution also makes some stronger
demands to the numerical method and the implementation than the
constant solution used in the section <a href="#decay:verify:trivial">Verification via trivial solutions</a>, at least
in more complicated applications. However,
the constant solution is often ideal for initial debugging before
proceeding with a linear solution.

<p>
Let \( u(t) = ct + d \). We must then have \( d=I \) from the initial condition.
Inserting this \( u \) in the ODE results in
$$ c = -a(t)u + b(t) \thinspace . $$
Any function \( u=ct+I \) is then a correct solution if we choose
$$ b(t) = c + a(t)(ct + I) \thinspace . $$
Note that there are no restrictions on \( a(t) \) and \( c \).

<p>
The following function offers an implementation of the verification
test based on a linear exact solution:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">test_linear_solution</span>():
    <span style="color: #BB4444; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BB4444; font-style: italic">    Test problem where u=c*t+I is the exact solution, to be</span>
<span style="color: #BB4444; font-style: italic">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #BB4444; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_solution</span>(t):
        <span style="color: #AA22FF; font-weight: bold">return</span> c<span style="color: #666666">*</span>t <span style="color: #666666">+</span> I

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">a</span>(t):
        <span style="color: #AA22FF; font-weight: bold">return</span> t<span style="color: #666666">**0.5</span>  <span style="color: #008800; font-style: italic"># can be arbitrary</span>

    <span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">b</span>(t):
        <span style="color: #AA22FF; font-weight: bold">return</span> c <span style="color: #666666">+</span> a(t)<span style="color: #666666">*</span>exact_solution(t)

    theta <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; c <span style="color: #666666">=</span> <span style="color: #666666">-0.5</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">4</span>
    N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(T<span style="color: #666666">/</span>dt)  <span style="color: #008800; font-style: italic"># no of steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, b<span style="color: #666666">=</span>b, T<span style="color: #666666">=</span>N<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    u_e <span style="color: #666666">=</span> exact_solution(t)
    difference <span style="color: #666666">=</span> <span style="color: #AA22FF">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()  <span style="color: #008800; font-style: italic"># max deviation</span>
    nt<span style="color: #666666">.</span>assert_almost_equal(difference, <span style="color: #666666">0</span>, places<span style="color: #666666">=14</span>)
</pre></div>
<p>
As in the section <a href="#decay:verify:trivial">Verification via trivial solutions</a>, any error in the updating
formula makes this test fail.

<p>
Choosing more complicated formulas as the exact solution, say
\( \cos(t) \), will not make the numerical and exact solution
coincide to machine precision. In such cases, the verification procedure
must be based on measuring the convergence rates as exemplified in
the section <a href="#decay:convergence:rate">Computing convergence rates</a>. This is possible since one has
an exact solution of a problem that the solver can be tested on.

<p>

<p>

<h3>Extension to systems of ODEs  <a name="___sec101"></a></h3>
<p>
Many ODE models involves more than one unknown function and more
than one equation. Here is an example of two unknown functions \( u(t) \)
and \( v(t) \) (modeling, e.g., the radioactive decay of two substances):

<p>
$$
\begin{align}
u' &= -a_u u + a_vv,\\
v' &= -a_vv + a_uu,
\end{align}
$$
for constants \( a_u, a_v>0 \).
Applying the Forward Euler method to each equation results in simple
updating formula
$$
\begin{align}
u^{n+1} &= u^n + \Delta t (-a_u u^n + a_vv^n),\\
v^{n+1} &= u^n + \Delta t (-a_vv^n + a_uu^n)
\thinspace .
\end{align}
$$
However, the Crank-Nicolson or Backward Euler schemes result in a
\( 2\times 2 \) linear system for the new unknowns. The latter schemes gives
$$
\begin{align}
u^{n+1} &= u^n + \Delta t (-a_u u^{n+1} + a_vv^{n+1}),\\
v^{n+1} &= v^n + \Delta t (-a_vv^{n+1} + a_uu^{n+1}),
\end{align}
$$
and bringing \( u^{n+1} \) as well as \( v^{n+1} \) on the left-hand side results
in
$$
\begin{align}
(1 + \Delta t a_u)u^{n+1} + a_vv^{n+1}) &= u^n ,\\
a_uu^{n+1} + (1 + \Delta t a_v) v^{n+1} &= v^n ,
\end{align}
$$
which is a system of two coupled, linear, algebraic equations in two
unknowns.

<p>

<p>

<h2>General first-order ODEs  <a name="___sec102"></a></h2>
<p>
We now turn the attention to general, nonlinear ODEs and systems of such ODEs.
Many schemes that are occasionally reused for PDEs are listed. We also
demonstrate a Python interface to a range of different software for
general first-order ODE systems.

<p>

<h3>Generic form  <a name="___sec103"></a></h3>
<p>
ODEs are commonly written in a generic form

<p>
$$
\begin{equation}
u' = f(u,t),\quad u(0)=I,
\label{decay:ode:general}
\end{equation}
$$
where \( f(u,t) \)  is a prescribed function.
As an example, our most
general exponential decay model \eqref{decay:problem:ab} has
\( f(u,t)=-a(t)u(t) + b(t) \).

<p>
The unknown \( u \) in \eqref{decay:ode:general} may either be
a scalar function of time \( t \), or a vector valued function of \( t \) in
case of a <em>system of ODEs</em>:
$$ u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t)) \thinspace . $$
In that case, the right-hand side is vector-valued function with \( m \)
components,
$$
\begin{align*}
f(u, t) = ( & f^{(0)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\
            & f^{(1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\
            & \vdots,\\
            & f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
\thinspace .
\end{align*}
$$

<p>
Actually, any system of ODEs can
be written in the form \eqref{decay:ode:general}, but higher-order
ODEs then need auxiliary unknown functions.

<p>

<h3>The Odespy software  <a name="___sec104"></a></h3>
<p>
A wide range of methods and software exist for solving \eqref{decay:ode:general}.
Many of methods are accessible through a unified Python interface offered
by the <a href="https://github.com/hplgit/odespy">Odespy</a> package.
Odespy features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a href="https://computation.llnl.gov/casc/odepack/odepack_home.html">ODEPACK</a>, <a href="https://computation.llnl.gov/casc/odepack/odepack_home.html">Vode</a>,
<a href="http://www.netlib.org/ode/rkc.f">rkc.f</a>, "rkf45.f": http://www.netlib.org/ode/rkf45.f", "Radau5": "http://www.unige.ch/~hairer/software.html, as well
as the ODE solvers in <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html">SciPy</a>, <a href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html">SymPy</a>, and <a href="http://olivierverdier.github.com/odelab/">odelab</a>.

<p>
The usage of Odespy follows this setup for the ODE \( u'=-au \) solved
by the famous 4th-order Runge-Kutta method:

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">def f(u, t):
    return -a*u

import odespy
import numpy as np

I = 1; a = 2; T = 6; dt = 1
solver = odespy.RK4(f)
solver.set_initial_condition(I)
t_mesh = np.linspace(0, T, N+1)
u, t = solver.solve(t_mesh)
</pre></div>
<p>

<p>

<h3>Example: Runge-Kutta methods   <a name="___sec105"></a></h3>
<p>
Since all solvers have the same interface, modulo different set of
parameters to the solvers' constructors, one can easily make a list of
solver objects and run a loop for comparing (a lot of) solvers. The
code below, found in complete form in <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_odespy.py"><tt>dc_odespy.py</tt></a>
compares the famous Runge-Kutta methods of orders 2, 3, and 4 with the
Backward Euler scheme and the exact solution of the decay equation
\( u'=-au \). Figure <a href="#decay:odespy:fig1">17</a> shows the results.

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">f</span>(u, t):
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">-</span>a<span style="color: #666666">*</span>u

I <span style="color: #666666">=</span> <span style="color: #666666">1</span>; a <span style="color: #666666">=</span> <span style="color: #666666">2</span>; T <span style="color: #666666">=</span> <span style="color: #666666">6</span>
dt <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>]) <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">len</span>(sys<span style="color: #666666">.</span>argv) <span style="color: #666666">&gt;=</span> <span style="color: #666666">2</span> <span style="color: #AA22FF; font-weight: bold">else</span> <span style="color: #666666">0.75</span>
N <span style="color: #666666">=</span> <span style="color: #AA22FF">int</span>(<span style="color: #AA22FF">round</span>(T<span style="color: #666666">/</span>dt))
t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, N<span style="color: #666666">*</span>dt, N<span style="color: #666666">+1</span>)

solvers <span style="color: #666666">=</span> [odespy<span style="color: #666666">.</span>RK2(f),
           odespy<span style="color: #666666">.</span>RK3(f),
           odespy<span style="color: #666666">.</span>RK4(f),
           odespy<span style="color: #666666">.</span>BackwardEuler(f, nonlinear_solver<span style="color: #666666">=</span><span style="color: #BB4444">&#39;Newton&#39;</span>)]

legends <span style="color: #666666">=</span> []
<span style="color: #AA22FF; font-weight: bold">for</span> solver <span style="color: #AA22FF; font-weight: bold">in</span> solvers:
    solver<span style="color: #666666">.</span>set_initial_condition(I)
    u, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(t)

    plt<span style="color: #666666">.</span>plot(t, u)
    plt<span style="color: #666666">.</span>hold(<span style="color: #BB4444">&#39;on&#39;</span>)
    legends<span style="color: #666666">.</span>append(solver<span style="color: #666666">.</span>__class__<span style="color: #666666">.</span>__name__)

<span style="color: #008800; font-style: italic"># Compare with exact solution plotted on a very fine mesh</span>
t_fine <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">10001</span>)
u_e <span style="color: #666666">=</span> I<span style="color: #666666">*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t_fine)
plt<span style="color: #666666">.</span>plot(t_fine, u_e, <span style="color: #BB4444">&#39;-&#39;</span>) <span style="color: #008800; font-style: italic"># avoid markers by specifying line type</span>
legends<span style="color: #666666">.</span>append(<span style="color: #BB4444">&#39;exact&#39;</span>)

plt<span style="color: #666666">.</span>legend(legends)
plt<span style="color: #666666">.</span>title(<span style="color: #BB4444">&#39;Time step: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> dt)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
This code might deserve a couple of comments. We use SciTools for
plotting, because with the Matplotlib and Gnuplot backends, curves are
automatically given colors <em>and</em> markers, the latter being important
when PNG plots are printed in reports in black and white. (The default
Matplotlib and Gnuplot behavior gives colored lines, which are
difficult to distinguish. However, Gnuplot automatically introduces
different line styles if output in the Encapsulated PostScript format
is specified via <tt>savefig</tt>).  The automatic adding of markers is not
suitable for a very finely resolved line, like the one for <tt>u_e</tt> in
this case, and then we specify the line type as a solid line (<tt>-</tt>),
leaving the color up to the backend used for plotting.  The legends
are based on the class names of the solvers, and in Python the name of
a the class type (as a string) of an object <tt>obj</tt> is obtained by
<tt>obj.__class__.__name__</tt>.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 17:  Behavior of different schemes for the decay equation. <a name="decay:odespy:fig1"></a> </p></center>
<p><img src="fig-decay/decay_odespy1_png.png" align="bottom" width=600></p>
</center>

<p>

<p>
Since we have quite long time steps, we have included the only
relevant \( \theta \)-rule for large time steps, the BackwardEuler scheme
(\( \theta=1 \)), as well in Figure <a href="#decay:odespy:fig1">17</a>.  These and
other experiments reveal that

<p>

<ul>
  <li> The 2-nd order Runge-Kutta method (<tt>RK2</tt>) is unstable for \( \Delta t>1 \)
    and decays slower than the Backward Euler scheme, which is known to
    decay slower than the Crank-Nicolson and Forward Euler schemes.
    However, for fine \( \Delta t = 0.25 \) the 2-nd order Runge-Kutta method
    decays faster than the Backward Euler scheme and lies closer to the
    exact curve. This means that the 2-nd order Runge-Kutta method
    approaches the exact solution faster than the Backward Euler scheme,
    although it is less accurate for large \( \Delta t \) values.
  <li> The 3-rd order Runge-Kutta method (<tt>RK3</tt>) is oscillating for
    \( \Delta t = 1.05 \) and lies partly above and below the exact curve for
    \( \Delta t = 0.75 \). This behavior is much like what one observes for
    the Crank-Nicolson scheme. For finer \( \Delta t \),
    the 3-rd order Runge-Kutta method converges quickly to the exact
    solution.
  <li> The 4-th order Runge-Kutta method (<tt>RK4</tt>) is slightly inferior
    to the Backward Euler scheme on the coarsest mesh, but is then
    clearly superior to all the other schemes. It is definitely the
    method of choise for all the tested schemes.
</ul>

<h4>Remark about using the \( \theta \)-rule in Odespy  <a name="___sec106"></a></h4>
<p>
The Odespy package assumes that the ODE is written as \( u'=f(u,t) \) with
an \( f \) that is possibly nonlinear in \( u \). The \( \theta \)-rule for
\( u'=f(u,t) \) leads to
$$ u^{n+1} = u^{n} + \Delta t\left(\theta f(u^{n+1}, t_{n+1})
+ (1-\theta) f(u^{n}, t_{n})\right),$$
which is a <em>nonlinear equation</em> in \( u^{n+1} \). Odespy's implementation
of the \( \theta \)-rule (<tt>ThetaRule</tt>) and the specialized Backward Euler
and Crank-Nicolson schemes (called <tt>BackwardEuler</tt> and
<tt>MidpointImplicit</tt>, respectively) must invoke iterative methods for
solving the nonlinear equation in \( u^{n+1} \). This is done even when
\( f \) is linear in \( u \), as in the model problem \( u'=-au \), where we can
easily solve for \( u^{n+1} \).  In the present example, we need to use
Newton's method to ensure that Odespy is capable of solving the
equation for \( u^{n+1} \) for large \( \Delta t \). (The reason is that the
Forward Euler method is used to compute the initial guess for the
nonlinear iteration method, and this Forward Euler may give very wrong
values for large \( \Delta t \).  The Newton method is not sensitive to a
bad initial guess in linear problems.)

<p>

<p>

<h3>Example: Adaptive Runge-Kutta methods   <a name="___sec107"></a></h3>
<p>
Odespy offers solution methods that can adapt the size of \( \Delta t \)
with time to match a desired accuracy in solution. Intuitively,
small time steps will be chosen in areas where the solution is changing
rapidly, while larger time steps can be used where the solution
is slowly varying. Some kind of <em>error estimator</em> is used to
adjust the next time step at each time level.

<p>
A very popular adaptive method for solving ODEs is the Dormand-Prince
Runge-Kutta method of order 4 and 5. The 5th-order method is used as a
reference solution and the difference between the 4th- and 5th-order
methods is used as an indicator of the error in the numerical
solution.  The Dormand-Prince method is the default choice in MATLAB's
famous <tt>ode45</tt> routine.

<p>
We can easily set up Odespy to use the Dormand-Prince method and
see how it selects the optimal time steps. To this end, we request
only one time step from \( t=0 \) to \( t=T \) and ask the method to
compute the necessary non-uniform time mesh to meet a certain
error tolerance. The code goes like

<p>
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">odespy</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">dc_mod</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>
<span style="color: #008800; font-style: italic">#import matplotlib.pyplot as plt</span>
<span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #AA22FF; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">f</span>(u, t):
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #666666">-</span>a<span style="color: #666666">*</span>u

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">exact_solution</span>(t):
    <span style="color: #AA22FF; font-weight: bold">return</span> I<span style="color: #666666">*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)

I <span style="color: #666666">=</span> <span style="color: #666666">1</span>; a <span style="color: #666666">=</span> <span style="color: #666666">2</span>; T <span style="color: #666666">=</span> <span style="color: #666666">5</span>
tol <span style="color: #666666">=</span> <span style="color: #AA22FF">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
solver <span style="color: #666666">=</span> odespy<span style="color: #666666">.</span>DormandPrince(f, atol<span style="color: #666666">=</span>tol, rtol<span style="color: #666666">=0.1*</span>tol)

N <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #008800; font-style: italic"># just one step - let the scheme find its intermediate points</span>
t_mesh <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)
t_fine <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">10001</span>)

solver<span style="color: #666666">.</span>set_initial_condition(I)
u, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(t_mesh)

<span style="color: #008800; font-style: italic"># u and t will only consist of [I, u^N] and [0,T]</span>
<span style="color: #008800; font-style: italic"># solver.u_all and solver.t_all contains all computed points</span>
plt<span style="color: #666666">.</span>plot(solver<span style="color: #666666">.</span>t_all, solver<span style="color: #666666">.</span>u_all, <span style="color: #BB4444">&#39;ko&#39;</span>)
plt<span style="color: #666666">.</span>hold(<span style="color: #BB4444">&#39;on&#39;</span>)
plt<span style="color: #666666">.</span>plot(t_fine, exact_solution(t_fine), <span style="color: #BB4444">&#39;b-&#39;</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BB4444">&#39;tol=</span><span style="color: #BB6688; font-weight: bold">%.0E</span><span style="color: #BB4444">&#39;</span> <span style="color: #666666">%</span> tol, <span style="color: #BB4444">&#39;exact&#39;</span>])
plt<span style="color: #666666">.</span>savefig(<span style="color: #BB4444">&#39;tmp_odespy_adaptive.png&#39;</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>

<p>
Running four cases with tolerances \( 10^{-1} \), \( 10^{-3} \), \( 10^{-5} \),
and \( 10^{-7} \), gives the results in Figure <a href="#decay:odespy:fig2">18</a>.
Intuitively, one would expect denser points in the beginning of
the decay and larger time steps when the solution flattens out.

<p>

<p>
<center> <! -- figure -->
<hr class="figure">
<center><p class="caption">Figure 18:  Choice of adaptive time mesh by the Dormand-Prince method for different tolerances. <a name="decay:odespy:fig2"></a> </p></center>
<p><img src="fig-decay/decay_DormandPrince_adaptivity.png" align="bottom" width=800></p>
</center>

<p>

<p>

<p>

<h3>Other schemes  <a name="___sec108"></a></h3>
<p>
Next we list some well-known methods for \( u'=f(u,t) \), valid both for
a single ODE (scalar \( u \)) and systems of ODEs (vector \( u \)).

<p>

<p>

<h4>Implicit 2-step backward scheme  <a name="___sec109"></a></h4>
<p>
The implicit backward method with 2 steps applies a
three-level backward difference as approximation to \( u'(t) \),
$$ u'(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t},$$
which is an approximation of order \( \Delta t^2 \) to the first derivative.
The resulting scheme for \( u'=f(u,t) \) reads
$$ u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} +
\frac{2}{3}\Delta t f(u^{n+1}, t_{n+1})
\thinspace .
\label{decay:fd2:bw:2step}
$$
Higher-order versions of the scheme \eqref{decay:fd2:bw:2step} can
be constructed by including more time levels. These schemes are known
as the Backward Differentiation Formulas (BDF), and the particular
version \eqref{decay:fd2:bw:2step} is often referred to as BDF2.
The family of BDF schemes are available in the solvers <tt>odespy.Vode</tt>,
<tt>odespy.Lsode</tt>, <tt>odespy.Lsoda</tt>, and <tt>odespy.lsoda_scipy</tt>.

<p>
Note that the scheme \eqref{decay:fd2:bw:2step} is implicit and requires
solution of nonlinear equations when \( f \) is nonlinear in \( u \).  The
standard 1st-order Backward Euler method or the Crank-Nicolson scheme
can be used for the first step.

<p>

<p>

<h4>The Leapfrog scheme  <a name="___sec110"></a></h4>
<p>
The derivative of \( u \) at some point \( t_n \) can be approximated by
a central difference over two time steps,

<p>
$$
\begin{equation}
u'(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t},
\end{equation}
$$
which is an approximation of second order in \( \Delta t \).
This approximation gives the scheme

<p>
$$
\begin{equation}
u^{n+1} = u^{n-1} + \Delta t f(u^n, t_n)
\thinspace .
\label{decay:fd2:leapfrog}
\end{equation}
$$
Some other scheme must be used as starter to compute \( u^1 \).
Observe that \eqref{decay:fd2:leapfrog} is an explicit scheme, and that
a nonlinear \( f \) (in \( u \)) is trivial to handle.

<p>

<p>

<h4>The filtered Leapfrog scheme  <a name="___sec111"></a></h4>
<p>
Unfortunately, the Leapfrog scheme \eqref{decay:fd2:leapfrog}
will develop growing oscillations with time (see <a href="#decay:fd2:exer:leapfrog1">Exercise 15: Implement the Leapfrog scheme</a>, {decay:fd2:exer:leapfrog2}, and
{decay:fd2:exer:leapfrog3}). A remedy for such undesired oscillations
is to introduce a <em>filtering technique</em>. First, a standard Leapfrog
step is taken, according to \eqref{decay:fd2:leapfrog}, and then
the previous \( u^n \) value is adjusted according to
$$
\begin{equation}
u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})
\label{decay:fd2:leapfrog:filtered}
\thinspace .
\end{equation}
$$
The \( \gamma \)-terms will effectively damp oscillations in the solution,
especially those with short wavelength (point-to-point oscillations in
particular). A common choice of \( \gamma \) is 0.6 (a value used in the
famous NCAR Climate Model).

<p>

<p>

<h4>2nd-order Runge-Kutta scheme  <a name="___sec112"></a></h4>
<p>
The two-step scheme

<p>
$$
\begin{align}
u^* &= u^n + \Delta t f(u^n, t_n),
\label{decay:fd2:RK2:s1}\\
u^{n+1} &= u^n + \Delta t \frac{1}{2} \left( f(u^n, t_n) + f(u^*, t_{n+1})
\right),
\label{decay:fd2:RK2:s2}
\end{align}
$$
essentially applies a Crank-Nicolson method to the ODE, but replaces
the term \( f(u^{n+1}, t_{n+1}) \) by a prediction
\( f(u^{*}, t_{n+1}) \) based on a Forward Euler step.
The scheme \eqref{decay:fd2:RK2:s1}-\eqref{decay:fd2:RK2:s2} is
known as Huen's method, but is also a 2nd-order Runge-Kutta method.
The scheme is explicit, and the error is expected to behave as \( \Delta t^2 \).

<p>

<p>

<p>

<h4>2nd-order Adams-Bashforth scheme  <a name="___sec113"></a></h4>
<p>
The following method is known as the 2nd-order Adams-Bashforth scheme:

<p>
$$
\begin{equation}
u^{n+1} = u^n + \frac{1}{2}\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
\right)
\thinspace .
\label{decay:fd2:AB2}
\end{equation}
$$
The scheme is explicit and requires another one-step scheme to compute
\( u^1 \) (the Forward Euler scheme or Heun's method, for instance).
As the name implies, the scheme is of order \( \Delta t^2 \).

<p>

<p>

<p>

<h4>3rd-order Adams-Bashforth scheme  <a name="___sec114"></a></h4>
<p>
Another explicit scheme, involving four time levels, is the
3rd-order Adams-Bashforth scheme

<p>
$$
\begin{equation}
u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
+ 5f(u^{n-2}, t_{n-2})\right)
\thinspace .
\label{decay:fd2:AB3}
\end{equation}
$$
The numerical error is of order \( \Delta t^3 \), and the scheme needs
some method for computing \( u^1 \) and \( u^2 \).

<p>
<!--  -->
<!-- === 2nd-order Runge-Kutta scheme  <a name="___sec112"></a>=== -->

<p>

<p>

<h2>Exercises  <a name="___sec65"></a></h2>
<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 14: Implement the 2-step backward scheme <a name="decay:fd2:exer:bw2"></a></h3>
<p>

<p>
Implement the 2-step backward method \eqref{decay:fd2:bw:2step}
for the model \( u'(t) = -a(t)u(t) + b(t) \), \( u(0)=I \).
Allow the first step to be computed by either the Backward Euler
scheme or the Crank-Nicolson scheme. Verify the implementing by choosing
\( a(t) \) and \( b(t) \) such that the exact solution is linear in \( t \)
(see the section <a href="#decay:MMS">Verification via manufactured solutions</a>).

<p>
Compute convergence rates (see the section <a href="#decay:convergence:rate">Computing convergence rates</a>) in
a test case \( a=\hbox{const} \) and \( b=0 \), where we easily have an exact
solution, and determine if the choice of
a first-order scheme (Backward Euler) has any impact on the overall
accuracy of this scheme. The expected error goes like \( {\cal O}(\Delta t^2) \).
Filename: <tt>dc_backward2step.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 15: Implement the Leapfrog scheme <a name="decay:fd2:exer:leapfrog1"></a></h3>
<p>

<p>
Implement the Leapfrog scheme \eqref{decay:fd2:leapfrog}
for the model \( u'(t) = -a(t)u(t) + b(t) \),
\( u(0)=I \). Since the Leapfrog scheme is explicit in time, it is most
convenient to use the explicit Forward Euler scheme for computing \( u^1 \).

<p>
Verify the implementation by choosing \( a(t) \) and \( b(t) \) such that
the exact solution is linear in \( t \) (see the section <a href="#decay:MMS">Verification via manufactured solutions</a>).
Also run the case \( u'=-u + 1 \), \( u(0)=0 \), and compare the numerical
and exact solutions in a plot (\( \uex(t)=1-e^{-t} \) for this case).

<p>
Compute convergence rates (see the section <a href="#decay:convergence:rate">Computing convergence rates</a>)
to determine if the choice of a first-order scheme (Forward Euler) for
the first time step has any impact on the overall accuracy of the
Leapfrog scheme, which is expected to be of second order in \( \Delta t \).
Filename: <tt>dc_leapfrog.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 16: Experiment with the Leapfrog scheme <a name="decay:fd2:exer:leapfrog2"></a></h3>
<p>

<p>
Set up a set of experiments to demonstrate that the Leapfrog scheme
\eqref{decay:fd2:leapfrog} as implemented in <a href="#decay:fd2:exer:leapfrog1">Exercise 15: Implement the Leapfrog scheme</a> is associated with numerical artifacts
(instabilities).
Filename: <tt>dc_leapfrog_exper.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 17: Analyze the Leapfrog scheme <a name="decay:fd2:exer:leapfrog3"></a></h3>
<p>

<p>
The purpose of this exercise is to analyze and explain
instabilities of the Leapfrog scheme \eqref{decay:fd2:leapfrog}.
Consider the case where \( a \) is constant and \( b=0 \).
Assume that an exact solution of the discrete equations has
the form \( u^n=A^n \), where \( A \) is an amplification factor to
be determined. Use <tt>sympy</tt> to compute \( A \). Since the governing
polynomial for \( A \) has two roots, \( A_1 \) and \( A_2 \),
\( u^n \) is a linear combination \( u^n=C_1A_1^n + C_2A_2^n \).
Filename: <tt>dc_leapfrog_anaysis.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 18: Implement the 2nd-order Adams-Bashforth scheme <a name="decay:fd2:exer:AB2"></a></h3>
<p>

<p>
Implement the 2nd-order Adams-Bashforth method \eqref{decay:fd2:AB2}
for the decay problem \( u'=-a(t)u + b(t) \), \( u(0)=I \), \( t\in (0, T] \).
Use the Forward Euler method for the first step such that the overall
scheme is explicit. Verify the implementation using an exact
solution that is linear in time.
Analyze the scheme by searching for solutions \( u^n=A^n \) when \( a=\hbox{const} \)
and \( b=0 \). Compare this second-order secheme to the Crank-Nicolson scheme.
Filename: <tt>dc_AdamBashforth2.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 19: Implement the 3rd-order Adams-Bashforth scheme <a name="decay:fd2:exer:AB3"></a></h3>
<p>

<p>
Implement the 3rd-order Adams-Bashforth method \eqref{decay:fd2:AB3}
for the decay problem \( u'=-a(t)u + b(t) \), \( u(0)=I \), \( t\in (0, T] \).
Since the scheme is explicit, allow it to be started by two steps with
the Forward Euler method.  Investigate experimentally the case where
\( b=0 \) and \( a \) is a constant: Can we have oscillatory solutions for
large \( \Delta t \)?
Filename: <tt>dc_AdamBashforth3.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 20: Generalize a class implementation <a name="decay:exer:dc_class2"></a></h3>
<p>

<p>
Consider the file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_class.py"><tt>dc_class.py</tt></a>
where the exponential decay problem \( u'=-au \), \( u(0)=I \), is implemented
via three classes <tt>Problem</tt>, <tt>Solver</tt>, and <tt>Visualizer</tt>.
Extend the classes to handle the more general problem
$$ u'(t) = -a(t)u(t) + b(t),\quad u(0)=I,\ t\in (0,T],$$
using the \( \theta \)-rule for discretization.

<p>
In the case with arbitrary functions \( a(t) \) and \( b(t) \) the problem class
is no longer guaranteed to provide an exact solution. Let
the <tt>exact_solution</tt> in class <tt>Problem</tt> return <tt>None</tt> if the exact
solution for the particular problem is not available. Modify classes
<tt>Solver</tt> and <tt>Visualizer</tt> accordingly.

<p>
Add test functions <tt>test_*()</tt> for the nose testing tool in the module.
Also add a demo example for a rough model of a parachute jumper where
\( b(t)=g \) (acceleration of gravity) and
$$ a(t) =\left\lbrace\begin{array}{ll}
a_0, & 0\leq t\leq t_p,\\
ka_0, & t> t_p,\end{array}\right.
$$
where \( t_p \) is the point of time the parachute is released and \( k \) is
the factor of increased air resistance. Scale the model using the
terminal velocity of the free fall, \( v=\sqrt{g/a_0} \), as velocity scale.
Make a demo of the scaled model with \( k=50 \).
Filename: <tt>dc_class2.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 21: Generalize an advanced class implementation <a name="decay:exer:dc_class3"></a></h3>
<p>

<p>
Solve <a href="#decay:exer:dc_class2">Exercise 20: Generalize a class implementation</a> by utilizing the
class implementations in
<a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_class_oo.py"><tt>dc_class_oo.py</tt></a>.
Filename: <tt>dc_class3.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 22: Make a unified implementation of many schemes <a name="decay:fd2:exer:uni"></a></h3>
<p>

<p>
Consider the linear ODE problem \( u'(t)=-a(t)u(t) + b(t) \), \( u(0)=I \).
Many solution schemes for this problem can be written in the (explicit) form
$$
\begin{equation}
u^{n+1} = \sum_{j=0}^m c_ju^{n-j},
\label{decay:analysis:exer:sumcj}
\end{equation}
$$
for some choice of \( c_0,\ldots,c_m \).
Find thhe \( c_j \) coefficients for the
\( \theta \)-rule, the three-level backward scheme,
the Leapfrog scheme, the 2nd-order Runge-Kutta method,
and the 3rd-order Adams-Bashforth scheme.

<p>
Make a class <tt>ExpDecay</tt> that implements \eqref{decay:analysis:exer:sumcj},
with subclasses specifying lists \( c_0,\ldots,c_m \) for the various methods.
The subclasses also need extra lists for methods needed to start
schemes with \( m>0 \).
Verify the implementation by testing with a linear solution (\( \uex(t)=ct+d \)).
Filename: <tt>decay_schemes_oo.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<h2>Applications of exponential decay models <a name="decay:app"></a></h2>
<p>

<p>
This section presents many mathematical models that all
end up with ODEs of the type \( u'=-au+b \), where the solution exhibits
exponential growth or decay.  The applications are taken from biology,
finance, and physics, and cover population growth or decay, compound
interest and inflation, radioactive decay, cooling of bodies, pressure
variations in the atmosphere, and air resistance on falling or rising
bodies.

<p>

<p>

<p>

<h3>Evolution of a population <a name="decay:app:pop"></a></h3>
<p>

<p>

<p>
Let \( N \) be the number of individuals in a population occupying some
spatial domain.
Despite \( N \) being an integer we shall compute with \( N \) as a real number
and view \( N(t) \) as a continuous function of time.
The basic model assumption is that in a time interval \( \Delta t \) the number of
newcomers to the populations (newborns) is proportional to
\( N \), with proportionality constant \( \bar b \). The amount of
newcomers will increase the population and result in
to
$$ N(t+\Delta t) = N(t) + \bar bN(t)\thinspace . $$
It is obvious that a long time interval \( \Delta t \) will result in
more newcomers and hence a larger \( \bar b \). Therefore, we introduce
\( b=\bar b/\Delta t \): the number of newcomers per unit time and per
individual. We must then multiply \( b \) by the length of the time
interval considered and by the population size to get the
total number of new individuals, \( b\Delta t N \).

<p>
If the number of removals from the population (deaths) is also
proportional to \( N \), with proportionality constant \( d\Delta t \),
the population evolves according to
$$ N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t)\thinspace . $$
Dividing by \( \Delta t \) and letting \( \Delta t \rightarrow 0 \),
we get the ODE

<p>
$$
\begin{equation}
N' = (b-d)N\thinspace .
\end{equation}
$$
In a population where the death rate (\( d \)) is larger than
then newborn rate (\( b \)), \( a>0 \), and the population experiences
exponential decay rather than exponential growth.

<p>
In some populations there is an immigration of individuals into the
spatial domain. With \( I \) individuals coming in per time unit,
the equation for the population change becomes

<p>
$$ N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t) + \Delta t I\thinspace . $$
The corresponding ODE reads
$$
\begin{equation}
N' = (b-d)N + I,\quad N(0)=N_0
\thinspace .
\end{equation}
$$

<p>
Some simplification arises if we introduce a fractional measure
of the population: \( u=N/N_0 \) and set \( r=b-d \). The ODE problem
now becomes
$$
\begin{equation}
u' = ru + f,\quad u(0)=1,
\label{decay:app:pop:ueq}
\end{equation}
$$
where \( f=I/N_0 \) measures the net immigration per time unit as
the fraction of the initial population.

<p>

<p>
The growth rate \( r \) of a population decreases if the environment
has limited resources. Suppose the environment can sustain at
most \( N_{\max} \) individuals. We may then assume that the growth rate
approaches zero as \( N \) approaches \( N_{\max} \), i.e., as \( u \) approaches
\( M=N_{\max}/N_0 \). The simplest possible evolution of \( r \) is then a
linear function: \( r(t)=r_0(1-u(t)/M) \), where \( r_0 \)
is the initial growth rate when the population is small relative to the
maximum size and there is enough resources. Using this \( r(t) \) in
\eqref{decay:app:pop:ueq} results in the <em>logistic model</em> for the
evolution of a population:
$$
\begin{equation}
u' = r_0(1-u/M)u,\quad u(0)=1
\thinspace .
\label{decay:app:pop:logistic}
\end{equation}
$$
Initially, \( u \) will grow at rate \( r_0 \), but the growth will decay
as \( u \) approaches \( M \), and then there is no more change in \( u \), causing
the limit \( u\rightarrow M \) as \( t\rightarrow\infty \).
Note that the logistic equation \( u'=r_0(1-u/M)u \) is <em>nonlinear</em> because
of the quadratic term \( -u^2r_0/M \).

<p>

<h3>Compound interest and inflation <a name="decay:app:interest"></a></h3>
<p>

<p>
Say the annual interest rate is \( r \) percent and that the bank
adds the interest once a year to your investment.
If \( u^n \) is the investment in year \( n \), the investment in year \( u^{n+1} \)
grows to

<p>
$$ u^{n+1} = u^n + \frac{r}{100}u^n
\thinspace . $$
In reality, the interest rate is added every day. We therefore introduce
a parameter \( m \) for the number of periods per year when the interest
is added. If \( n \) counts the periods, we have the fundamental model
for compound interest:
$$
\begin{equation}
u^{n+1} = u^n + \frac{r}{100 m}u^n
\thinspace .
\label{decay:app:interest:eq1}
\end{equation}
$$
This model is a <em>difference equation</em>, but it can be transformed to a
continuous differential equation through a limit process.
The first step is to derive a formula for the growth of the investment
over a time \( t \).
Starting with an investment \( u^0 \), and assuming that \( r \) is constant in time,
we get
$$
\begin{align*}
u^{n+1} &= \left(1 + \frac{r}{100 m}\right)u^{n}\\
&= \left(1 + \frac{r}{100 m}\right)^2u^{n-1}\\
&\ \ \vdots\\
&= \left(1 +\frac{r}{100 m}\right)^{n+1}u^{0}
\end{align*}
$$
Introducing time \( t \), which here is a real-numbered counter for years,
we have that \( n=mt \), so we can write

<p>
$$ u^{mt} = \left(1 + \frac{r}{100 m}\right)^{mt} u^0\thinspace . $$
The second step is to assume <em>continuous compounding</em>, meaning that the
interest is added continuously. This implies \( m\rightarrow\infty \), and
in the limit one gets the formula
$$
\begin{equation}
u(t) = u_0e^{rt/100},
\end{equation}
$$
which is nothing but the solution of the ODE problem
$$
\begin{equation}
u' = \frac{r}{100}u,\quad u(0)=u_0
\thinspace .
\label{decay:app:interest:eq2}
\end{equation}
$$
This is then taken as the ODE model for compound interest if \( r>0 \).
However, the reasoning applies equally well to inflation, which is
just the case \( r<0 \). One may also take the \( r \) in \eqref{decay:app:interest:eq2}
as the net growth of an investemt, where \( r \) takes both compound interest
and inflation into account. Note that for real applications we must
use a time-dependent \( r \) in \eqref{decay:app:interest:eq2}.

<p>

<p>
Introducing \( a=\frac{r}{100} \), continuous inflation of an initial
fortune \( I \) is then
a process exhibiting exponential decay according to
$$ u' = -au,\quad u(0)=I\thinspace . $$

<p>

<p>

<h3>Radioactive Decay  <a name="___sec129"></a></h3>
<p>

<p>
An atomic nucleus of an unstable atom may lose energy by emitting
ionizing particles and thereby be transformed to a nucleus with a
different number of protons and neutrons.  This process is known as
<a href="http://en.wikipedia.org/wiki/Radioactive_decay">radioactive decay</a>.
Actually, the process is stochastic when viewed for a single atom,
because it is impossible to predict exactly when a particular atom
emits a particle. Nevertheless, with a large number of atoms, \( N \), one may
view the process as deterministic and compute the mean behavior
of the decay.

<p>
Suppose at time \( t \), the number of the original atom type is \( N(t) \).
A basic model assumption is that the transformation of the atoms of the original
type in a small time interval \( \Delta t \) is proportional to
\( N \), so that
$$ N(t+\Delta t) = N(t) - a\Delta t N(t),$$
where \( a \) is a constant. Introducing \( u=N(t)/N(0) \), dividing by
\( \Delta t \) and letting \( \Delta t\rightarrow 0 \) gives the
following ODE:

<p>
$$
\begin{equation}
u' = -au,\quad u(0)=1
\thinspace .
\end{equation}
$$
The parameter \( a \) can for a given nucleus be expressed through the
<em>half-life</em> \( t_{1/2} \), which is the time taken for the decay to reduce the
initial amount by one half, i.e., \( u(t_{1/2}) = 0.5 \).
With \( u(t)=e^{-at} \), we get \( t_{1/2}=a^{-1}\ln 2 \) or \( a=\ln 2/t_{1/2} \).

<p>

<p>
<!-- http://en.wikipedia.org/wiki/Exponential_decay -->

<p>
<!-- Go from stochastic emission of particles (or taxis emptying a queue) -->
<!-- and derive the decay equation. -->

<p>

<p>

<h3>Newton's law of cooling  <a name="___sec130"></a></h3>
<p>
<!-- http://web.bham.ac.uk/winterhs/Newton.htm -->
<!-- I. Newton, Scala Graduum Caloris, Philosophical Transactions of the Royal Society of London, 1701 -->
<!-- explanation: http://www.madsci.org/posts/archives/2000-11/973522810.Ph.r.html -->

<p>
When a body at some temperature is placed in a cooling environment,
experience shows that the temperature falls rapidly in the beginning,
and then the changes in temperature levels off until the body's
temperature equals that of the surroundings. Newton carried out some
experiments on cooling hot iron and found that the temperature
evolved as a "geometric progression at times in arithmetic progression",
meaning that the temperature decayed exponentially.
Later, this result was formulated as a differential equation:
the rate of change of the temperature in a body is proportional to
the temperature difference between the body and its surroundings.
This statement is known as <em>Newton's law of cooling</em>, which
can be mathematically expressed as
$$
\begin{equation}
{dT\over dt} = -k(T-T_s),
\label{decay:Newton:cooling}
\end{equation}
$$
where \( T \) is the temperature of the body, \( T_s \) is the temperature
of the surroundings, \( t \) is time, and \( k \) is a positive constant.
Equation \eqref{decay:Newton:cooling} is primarily viewed as an
empirical law, valid when heat is efficiently convected away
from the surface of the body by a flowing fluid such as air
at constant temperature \( T_s \).
The constant \( k \) reflects the transfer of heat from the body to
the surroundings and must be determined from physical experiments.

<p>

<p>

<h3>Decay of atmospheric pressure with altitude <a name="decay:app:atm"></a></h3>
<p>

<p>
<!-- The Barometric Formula -->
<!-- http://en.wikipedia.org/wiki/Barometric_formula -->

<p>
Vertical equilibrium of air in the atmosphere is governed by
the equation

<p>
$$
\begin{equation}
\frac{dp}{dz} = -\varrho g
\thinspace .
\label{decay:app:atm:dpdz}
\end{equation}
$$
Here, \( p(z) \) is the air pressure, \( \varrho \) is the density of
air, and \( g=9.807\hbox{ m/s}^2 \) is a standard value of
the acceleration of gravity.
(Equation \eqref{decay:app:atm:dpdz} follows directly from the general
Navier-Stokes equations for fluid motion, with
the assumption that the air does not move.)

<p>
The pressure is related to density and temperature through the ideal gas law

<p>
$$
\begin{equation}
\varrho = \frac{Mp}{R^*T}, \label{decay:app:atm:rho}
\end{equation}
$$
where \( M \) is the molar mass of Earth's air (0.029 kg/mol),
\( R^* \) is the universal
gas constant (\( 8.314 \) Nm/(mol K)), and \( T \) is the temperature.
All variables \( p \), \( \varrho \), and \( T \) vary with the height \( z \).
Inserting \eqref{decay:app:atm:rho} in \eqref{decay:app:atm:dpdz} results
in an ODE for with a variable coefficient:

<p>
$$
\begin{equation}
\frac{dp}{dz} = -\frac{Mg}{R^*T(z)} p
\label{decay:app:atm:ode}
\thinspace  .
\end{equation}
$$

<p>

<h4>Multiple atmospheric layers  <a name="___sec132"></a></h4>
<p>
The atmosphere can be approximately modeled by seven layers.
In each layer, \eqref{decay:app:atm:ode} is applied with
a linear temperature of the form

<p>
$$ T(z) = \bar T_i + L_i(z-h_i),$$
where \( z=h_i \) denotes the bottom of layer number \( i \),
having temperature \( \bar T_i \),
and \( L_i \) is a constant in layer number \( i \). The table below
lists \( h_i \) (m), \( \bar T_i \) (K), and \( L_i \) (K/m) for the layers
\( i=0,\ldots,6 \).

<p>
<table border="1">
<tr><td align="center"><b>   \( i \)    </b></td> <td align="center"><b>  \( h_i \)   </b></td> <td align="center"><b>\( \bar T_i \)</b></td> <td align="center"><b>  \( L_i \)   </b></td> </tr>
<tr><td align="left">   0                 </td> <td align="right">   0                 </td> <td align="right">   288               </td> <td align="right">   -0.0065           </td> </tr>
<tr><td align="left">   1                 </td> <td align="right">   11,000            </td> <td align="right">   216               </td> <td align="right">   0.0               </td> </tr>
<tr><td align="left">   2                 </td> <td align="right">   20,000            </td> <td align="right">   216               </td> <td align="right">   0.001             </td> </tr>
<tr><td align="left">   3                 </td> <td align="right">   32,000            </td> <td align="right">   228               </td> <td align="right">   0.0028            </td> </tr>
<tr><td align="left">   4                 </td> <td align="right">   47,000            </td> <td align="right">   270               </td> <td align="right">   0.0               </td> </tr>
<tr><td align="left">   5                 </td> <td align="right">   51,000            </td> <td align="right">   270               </td> <td align="right">   -0.0028           </td> </tr>
<tr><td align="left">   6                 </td> <td align="right">   71,000            </td> <td align="right">   214               </td> <td align="right">   -0.002            </td> </tr>
</table>
<p>
For implementation it might be convenient to write \eqref{decay:app:atm:ode}
on the form
$$
\begin{equation}
\frac{dp}{dz} = -\frac{Mg}{R^*(\bar T(z) + L(z)(z-h(z)))} p,
\end{equation}
$$
where \( \bar T(z) \), \( L(z) \), and \( h(z) \) are piecewise constant
functions with values given in the table.
The value of the pressure at the ground \( z=0 \) is \( 101325 \) Pa.

<p>

<h4>Simplification: \( L=0 \)  <a name="___sec133"></a></h4>
<p>
One commonly used simplification is to assume that the temperature is
constant within each layer. This means that \( L=0 \).

<p>

<h4>Simplification: one-layer model  <a name="___sec134"></a></h4>
<p>
Another commonly used approximation is to work with one layer instead of
seven. This <a href="http://en.wikipedia.org/wiki/Density_of_air">one-layer model</a>
is based on \( T(z)=T_0 - Lz \), with
sea level standard temperature \( T_0=288 \) K and
temperature lapse rate \( L=0.0065 \) K/m.
Furthermore, \( p_0 \) is the sea level atmospheric pressure \( 1\cdot 10^5 \) Pa.

<p>

<p>

<h3>Vertical motion of a body in a viscous fluid <a name="decay:app:drag"></a></h3>
<p>

<p>

<p>
A body moving vertically through a fluid (liquid or gas) is subject to
three different types of forces: the gravity force, <a href="http://en.wikipedia.org/wiki/Drag_(physics)">the drag force</a>,
and the buoyancy force.

<p>

<h4>Overview of forces  <a name="___sec136"></a></h4>
<p>
The gravity force is \( F_g= -mg \), where \( m \) is the mass of the body and
\( g \) is the acceleration of gravity.
The uplift or buoyancy force ("Archimedes force") \( F_b = \varrho gV \),
where \( \varrho \) is the density of the fluid and
\( V \) is the volume of the body.
Forces and other quantities are taken as positive in the upward
direction.

<p>
The drag force is of two types, depending on the Reynolds number
$$
\begin{equation}
\hbox{Re} = \frac{\varrho dv}{\mu},
\end{equation}
$$
where \( d \) is the diameter of the body in
the direction perpendicular to the flow, \( v \) is the velocity of the
body, and \( \mu \) is the dynamic viscosity of the fluid.
When \( \hbox{Re} < 1 \), the drag force is fairly well modeled by
the so-called Stokes' drag,
which for a spherical body of diameter \( d \) reads
$$
\begin{equation}
F_d^{(S)} = - 3\pi d\mu v
\thinspace .
\end{equation}
$$
For large Re, typically \( \hbox{Re} > 10^3 \), the drag force is quadratic
in the velocity:
$$
\begin{equation}
F_d^{(q)} = -{1\over2}C_D\varrho A|v|v,
\end{equation}
$$
where \( C_D \) is a dimensionless drag coefficient depending on the body's shape,
\( A \) is the cross-sectional area as
produced by a cut plane, perpendicular to the motion, through the thickest
part of the body. The superscripts \( {}^q \) and \( {}^S \) in
\( F_d^{(S)} \) and \( F_d^{(q)} \) indicates Stokes drag and quadratic drag,
respectively.

<p>

<h4>Equation of motion  <a name="___sec137"></a></h4>
<p>
All the mentioned forces act in the vertical direction.
Newton's second law of motion applied to the body says that the sum of
these forces must equal the mass of the body times its acceleration
\( a \) in the vertical direction.

<p>
$$
\begin{equation*} ma = F_g + F_d^{(S)} + F_b ,\end{equation*}
$$
if we choose to work with the Stokes drag.
Inserting the expressions for the forces yields

<p>
$$  ma = -mg - 3\pi d\mu v + \varrho gV
\thinspace .
$$
The unknowns here are \( v \) and \( a \), i.e., we have two unknowns but only
one equation. From kinematics in physics we know that
the acceleration is the time derivative of the velocity: \( a = dv/dt \).
This is our second equation.
We can easily eliminate \( a \) and get a single differential equation for \( v \):

<p>
$$ m{dv\over dt} = -mg - 3\pi d\mu v + \varrho gV
\thinspace .
$$
A small rewrite of this equation is handy: We express \( m \) as \( \varrho_bV \),
where \( \varrho_b \) is the density of the body, and we divide by
the mass to get

<p>
$$
\begin{equation}
v'(t) = - \frac{3\pi d\mu}{\varrho_b V} v + g\left(\frac{\varrho}{\varrho_b} -1\right)
\label{decay:app:fallingbody:model:S}
\thinspace .
\end{equation}
$$
We may introduce the constants
$$
\begin{equation}
a = \frac{3\pi d\mu}{\varrho_b V},\quad
b = g\left(\frac{\varrho}{\varrho_b} -1\right),
\end{equation}
$$
so that the structure of the differential equation becomes evident:

<p>
$$
\begin{equation}
v'(t) = -av(t) + b
\label{decay:app:fallingbody:gmodel:S}
\thinspace .
\end{equation}
$$
The corresponding initial condition is \( v(0)=v_0 \) for some prescribed
starting velocity \( v_0 \).

<p>
This derivation can be repeated with the quadratic drag force
\( F_d^{(q)} \), yielding

<p>
$$
\begin{equation}
v'(t) =
-{1\over2}C_D{\varrho A\over\varrho_b V}|v|v +
g\left({\varrho\over\varrho_b} - 1\right)
\thinspace .
\label{decay:app:fallingbody:model:q}
\end{equation}
$$
Defining

<p>
$$
\begin{equation}
a = {1\over2}C_D{\varrho A\over\varrho_b V},
\end{equation}
$$
and \( b \) as above, we can write \eqref{decay:app:fallingbody:model:q} as
$$
\begin{equation}
v'(t) = -a|v|v + b
\thinspace .
\label{decay:app:fallingbody:gmodel:q}
\end{equation}
$$

<p>

<p>

<h4>Terminal velocity  <a name="___sec138"></a></h4>
<p>
An interesting aspect of \eqref{decay:app:fallingbody:gmodel:S} and
\eqref{decay:app:fallingbody:gmodel:q} is whether we can approach
a constant, so-called <em>terminal velocity</em> \( v_T \), as \( t\rightarrow\infty \). The
existence of \( v_T \) assumes that
\( v'(t)\rightarrow 0 \) as \( t\rightarrow\infty \) and therefore

<p>
$$0 = -av_T + b$$
and
$$ 0 = -a|v_T|v_T + b
\thinspace .
$$
The former equation implies \( v_T = b/a \), while the latter has solutions
\( v_T =-\sqrt{|b|/a} \) for a falling body (\( v_T<0 \)) and
\( v_T = \sqrt{b/a} \) for a rising body (\( v_T>0 \)).

<p>

<h4>A Crank-Nicolson scheme  <a name="___sec139"></a></h4>
<p>
Both governing equations, the Stokes' drag model
\eqref{decay:app:fallingbody:gmodel:S} and the quadratic drag model
\eqref{decay:app:fallingbody:gmodel:q}, can be readily solved
by the Forward Euler scheme. The Crank-Nicolson method gives
a nonlinear equation in \( v \) when applied to
\eqref{decay:app:fallingbody:gmodel:q}:

<p>
$$
\begin{equation}
\frac{v^{n+1}-v^n}{\Delta t}
= -a^{n+\frac{1}{2}}\frac{1}{2}(|v^{n+1}|v^{n+1} + a^n|v^n|v^n) + b^{n+\frac{1}{2}}
\thinspace .
\end{equation}
$$
However, instead of approximating the term \( -|v|v \) by an arithmetic
average, we can use a <em>geometric average</em>:

<p>
$$
\begin{equation}
|v|v^{n+\frac{1}{2}} \approx |v|^nv^{n+1}
\thinspace .
\end{equation}
$$
The error is of second order in \( \Delta t \), just as for the arithmetic
average. Now,

<p>
$$
\frac{v^{n+1}-v^n}{\Delta t} = - a^{n+\frac{1}{2}}|v^{n}|v^{n+1} + b^{n+\frac{1}{2}}
$$
becomes a linear equation in \( v^{n+1} \), and we can easily solve for \( v^{n+1} \):
$$
\begin{equation}
v^{n+1} = \frac{v_n + \Delta t b^{n+\frac{1}{2}}}{1 + \Delta t a^{n+\frac{1}{2}}|v^{n}|}
\label{decay:app:fallingbody:gmodel:q:CN}
\end{equation}
$$

<p>

<h4>Physical data  <a name="___sec140"></a></h4>
<p>
Suitable values of \( \mu \) are \( 1.8\cdot 10^{-5}\hbox{ Pa}\, \hbox{s} \) for air
and \( 8.9\cdot 10^{-4}\hbox{ Pa}\, \hbox{s} \) for water.
Densities can be taken as \( 1.2\hbox{ kg/m}^3 \) for air and as
\( 1.0\cdot 10^3\hbox{ kg/m}^3 \) for water. For considerable vertical
displacement in the atmosphere one should take into account that
the density of air varies with height, see the section <a href="#decay:app:atm">Decay of atmospheric pressure with altitude</a>.
One possible density variation arises from the one-layer model
in the section <a href="#decay:app:atm">Decay of atmospheric pressure with altitude</a>.

<p>
The <a href="http://en.wikipedia.org/wiki/Drag_coefficient">drag coefficient</a> \( C_D \) depends heavily
on the shape of the body.  Some values are: 0.45 for a sphere, 0.42
for a semi-sphere, 1.05 for a cube, 0.82 for a long cylinder (with the
length along the vertical direction), 0.75 for a rocket,
1.0-1.3 for a man in upright position, 1.3 for a flat plate perpendicular
to the flow, and
0.04 for a streamlined (droplet-like) body.

<p>

<h4>Verification  <a name="___sec141"></a></h4>
<p>
To verify the program, one may assume a heavy body in air such that the \( F_b \)
force can be neglected, and assume a small velocity such that the
air resistance \( F_d \) can also be neglected. Setting \( \varrho =0 \)
removes both these terms from the equation. The motion then leads to
the velocity
\( v(t)=v_0 - gt \), which is linear in \( t \) and therefore should be
reproduced to machine precision (say tolerance \( 10^{-15} \)) by any
implementation based on the Crank-Nicolson or Forward Euler schemes.

<p>
Another verification, but not as powerful as the one above,
can be based on computing the terminal velocity and comparing with
the exact expressions.

<p>

<p>

<p>

<h2>Exercises  <a name="___sec65"></a></h2>
<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 23: Simulate the pressure drop in the atmosphere <a name="decay:app:exer:atm1"></a></h3>
<p>

<p>
We consider the models for atmospheric pressure in
the section <a href="#decay:app:atm">Decay of atmospheric pressure with altitude</a>.
Make a program with three functions,

<p>

<ul>
 <li> one computing the pressure \( p(z) \) using a seven-layer model
   and varying \( L \),
 <li> one computing \( p(z) \) using a seven-layer model,
   but with constant temperature in each layer, and
 <li> one computing \( p(z) \) based on the
   one-layer model.
</ul>

How can these implementations be verified? Should ease of verification
impact how you code the functions?
Compare the three models in a plot.
Filename: <tt>atmospheric_pressure.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 24: Make a program for vertical motion in a fluid <a name="decay:app:exer:drag:prog"></a></h3>
<p>

<p>
Implement the Stokes' drag model \eqref{decay:app:fallingbody:model:S}
and the quadratic drag model \eqref{decay:app:fallingbody:model:q} from
the section <a href="#decay:app:drag">Vertical motion of a body in a viscous fluid</a> in a program, using the Crank-Nicolson
scheme as explained. At each time level, compute the Reynolds number
Re and choose the Stokes' drag model if \( \hbox{Re} < 1 \) and the
quadratic drag model otherwise.  Include nose tests (in the file) that
runs the two suggested verification tests in the section <a href="#decay:app:drag">Vertical motion of a body in a viscous fluid</a>.
Filename: <tt>vertical_motion.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 25: Plot forces acting in vertical motion in a fluid <a name="decay:app:exer:drag:prog:viz"></a></h3>
<p>

<p>
Extend the program from <a href="#decay:app:exer:drag:prog">Exercise 24: Make a program for vertical motion in a fluid</a> to compute
the forces \( F_d^{(q)} \), \( F_d^{(S)} \), \( F_g \), and \( F_b \).
Plot the latter two and the relevant drag force, depending on
the value of the Reynolds number.
Filename: <tt>vertical_motion_force_plot.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 26: Simulate a free fall of a parachute jumper <a name="decay:app:exer:drag:parachute1"></a></h3>
<p>

<p>
Apply the program from <a href="#decay:app:exer:drag:prog">Exercise 24: Make a program for vertical motion in a fluid</a> to
a parachute jumper in free fall before the parachute opens.
Set the density of the human body
as \( \varrho_b = 1003 \hbox{ kg}/\hbox{m}^3 \)
and the mass as \( m=80 \) kg, implying \( V=m/\varrho_b = 0.08\hbox{ m}^3 \).
One can base
the cross-sectional area \( A \) the assumption of a circular cross section
of diameter 50 cm,
giving \( A= \pi R^2 = 0.9\hbox{ m}^2 \).
The density of air decreases with height, but for a free fall
we may use the approximation
\( \varrho = 0.79 \hbox{ kg/m}^3 \) which is relevant for about 5000 m height.
The \( C_D \) coefficient can be set to 1.2. Start with \( v_0=0 \).
Filename: <tt>parachute_jumper1.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 27: Simulate a complete parachute jump <a name="decay:app:exer:drag:parachute2"></a></h3>
<p>

<p>
A parachute jumper moves a vertical distance of about 5000 m where
\( A \) and \( C_D \) change dramatically when the parachute is released.
Moreover, the density of air changes with altitude.
Add a differential equation for the altitude \( z \),

<p>
$$
\begin{equation}
z'(t) = v(t),
\end{equation}
$$
and a differential equation for the air density, based on
the information for the one-layer atmospheric model in
the section <a href="#decay:app:atm">Decay of atmospheric pressure with altitude</a>:

<p>
$$
\begin{align}
p'(z) &= -\frac{Mg}{R^*(T_0+Lz)} p,\\
\varrho &= p \frac{M}{R^*T}
\thinspace .
\end{align}
$$

<p>
Extend the program from <a href="#decay:app:exer:drag:prog">Exercise 24: Make a program for vertical motion in a fluid</a> to
handle three coupled differential equations. With the Crank-Nicolson
method, one must solve a \( 3\times 3 \) system of equations at each time
level, since \( p \) depends on \( z \), which depends on \( v \), which depends
on \( \varrho \), which depends on \( p \).  Switching to the Forward Euler
method avoids the need to solve coupled equations, but demands smaller
\( \Delta t \) for accuracy. Make sure \( A \) and \( C_D \) can be changed at
some time \( t_p \) when the parachute is released.
Make nose tests of this program based on the
same verification cases as outlined in <a href="#decay:app:exer:drag:prog">Exercise 24: Make a program for vertical motion in a fluid</a>.

<p>
Use the program to simulate a jump from \( z=5000 \) m to the ground \( z=0 \).
Filename: <tt>parachute_jumper2.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 28: Simulate a rising ball in water <a name="decay:app:exer:drag:rising"></a></h3>
<p>

<p>
A ball with the size of a soccer ball is placed in somewhat deep
water, and we seek to model its motion upwards.  The buoyancy force
\( F_b \) is now the driving force.
Set \( A=\pi a^2 \) with \( a=11 \) cm, the mass of the ball is 0.43
kg, the density of water is \( 1000\hbox{ kg/m}^3 \), and \( C_D \) is 0.45.
Start with \( v_0=0 \) and see how the ball rises.
Filename: <tt>rising_ball.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 29: Radioactive decay of Carbon-14 <a name="decay:app:exer:radio:C14"></a></h3>
<p>

<p>
The <a href="http://en.wikipedia.org/wiki/Carbon-14">Carbon-14</a> isotope,
whose radioactive decay is used extensively in dating organic material
that is tens of thousands of years old, has a half-life of \( 5,730 \)
years.  Determine the age of an organic material that contains 8.4\%
of its initial amount of Carbon-14.  Use a time unit of 1 year in the
computations.  The uncertainty in the half time of Carbon-14 is \( \pm
40 \) years.  What is the corresponding uncertainty in the estimate of
the age?  (Use simulations, not the exact solution.)
Filename: <tt>carbon14.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 30: Radioactive decay of two substances <a name="decay:app:exer:radio:twosubst"></a></h3>
<p>

<p>
Consider two radioactive substances A and B. The nuclei in substance A
decay to form nuclei of type B with a half-life \( A_{1/2} \), while
substance B decay to form type A nuclei with a half-life \( B_{1/2} \).
Letting \( u_A \) and \( u_B \) be the fractions of the initial amount of
material in substance A and B, respectively, the following system of
ODEs governs the evolution of \( u_A(t) \) and \( u_B(t) \):
$$
\begin{align}
\frac{1}{\ln 2} u_A' &= u_B/B_{1/2} - u_A/A_{1/2},\\
\frac{1}{\ln 2} u_B' &= u_A/A_{1/2} - u_B/B_{1/2},
\end{align}
$$
with \( u_A(0)=u_B(0)=1 \).

<p>
Make a simulation program that solves for \( u_A(t) \) and \( u_B(t) \).
Verify the implementation by computing analytically
the limiting values of
\( u_A \) and \( u_B \) as \( t\rightarrow \infty \) (assume \( u_A',u_B'\rightarrow 0 \))
and comparing these with those obtained numerically.

<p>
Run the program for the case of \( A_{1/2}=10 \) minutes and \( B_{1/2}=50 \) minutes.
Use a time unit of 1 minute. Plot \( u_A \) and \( u_B \) versus time in the same
plot.
Filename: <tt>radioactive_decay_2subst.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 31: Find time of murder from body temperature <a name="decay:app:exer:cooling:pizza"></a></h3>
<p>

<p>
<!-- http://www.biology.arizona.edu/BioMath/tutorials/Applications/Cooling.html -->

<p>
A detective measures the temperature of a dead body to be
26.7 C at 2 pm. One hour later
the temperature is 25.8 C. The question is when
death occurred.

<p>
Assume that Newton's law of cooling \eqref{decay:Newton:cooling}
is an appropriate mathematical
model for the evolution of the temperature in the body.
First, determine \( k \) in \eqref{decay:Newton:cooling} by
formulating a Forward Euler approximation with one time steep
from time 2 am to time 3 am, where knowing the two temperatures
allows for finding \( k \). Thereafter, simulate the temperature evolution
from the time of murder, taken as \( t=0 \), when \( T=37\hbox{ C} \),
until the temperature
reaches 26.7 C. The corresponding time allows for answering when
death occurred.
Filename: <tt>detective.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 32: Simulate an oscillating cooling process <a name="decay:app:exer:cooling:osc"></a></h3>
<p>

<p>
The surrounding temperature \( T_s \) in Newton's law of cooling
\eqref{decay:Newton:cooling} may vary in time. Assume that the
variations are periodic with period \( P \) and amplitude \( a \) around
a constant mean temperature \( T_m \):
$$
\begin{equation}
T_s(t) = T_m + a\sin\left(\frac{2\pi}{P}t\right)
\thinspace .
\end{equation}
$$
Simulate a process with the following data: \( k=20 \hbox{ min}^{-1} \),
\( T(0)=5 \) C, \( T_m=25 \) C, \( a=2.5 \) C, and \( P=1 \) h. Also experiment with
\( P=10 \) min and \( P=3 \) h. Plot \( T \) and \( T_s \) in the same plot.
Filename: <tt>osc_cooling.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 33: Compute \( y=|x| \) by solving an ODE <a name="decay:app:exer:signum"></a></h3>
<p>

<p>
Consider the ODE problem
$$
y'(x) = \left\lbrace\begin{array}{ll}
-1, & x < 0,\\
1, & x \geq 0
\end{array}\right.\quad x\in (-1, 1],
\quad y(1-)=1,
$$
which has the solution \( y(x)=|x| \).
Using a mesh \( x_0=-1 \), \( x_1=0 \), and \( x_2=1 \), calculate by hand
\( y_1 \) and \( y_2 \) from the Forward Euler, Backward Euler, Crank-Nicolson,
and Leapfrog methods. Use all of the former three methods for computing
the \( y_1 \) value to be used in the Leapfrog calculation of \( y_2 \).
Thereafter, visualize how these schemes perform for a uniformly partitioned
mesh with \( N=10 \) and \( N=11 \) points.
Filename: <tt>signum.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 34: Simulate growth of a fortune with random interest rate <a name="decay:app:exer:interest"></a></h3>
<p>

<p>
The goal of this exercise is to compute the value of a fortune subject
to inflation and a random interest rate.
Suppose that the inflation is constant at \( i \) percent per year and that the
annual interest rate, \( p \), changes randomly at each time step,
starting at some value \( p_0 \) at \( t=0 \).
The random change is from a value \( p^n \) at \( t=t_n \) to
\( p_n +\Delta p \) with probability 0.25 and \( p_n -\Delta p \) with probability 0.25.
No change occurs with probability 0.5. There is also no change if
\( p^{n+1} \) exceeds 15 or becomes below 1.
Use a time step of one month, \( p_0=i \), initial fortune scaled to 1,
and simulate 1000 scenarios of
length 20 years. Compute the mean evolution of one unit of money and the
corresponding
standard deviation. Plot these two curves along with the \( p^n-i \) curve.
Filename: <tt>random_interest.py</tt>.

<p>
<b>Hint 1.</b> The following code snippet computes \( p^{n+1} \):
<p>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">random</span>

<span style="color: #AA22FF; font-weight: bold">def</span> <span style="color: #00A000">new_interest_rate</span>(p_n, dp<span style="color: #666666">=0.5</span>):
    r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>random()  <span style="color: #008800; font-style: italic"># uniformly distr. random number in [0,1)</span>
    <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> r <span style="color: #666666">&lt;</span> <span style="color: #666666">0.25</span>:
        p_np1 <span style="color: #666666">=</span> p_n <span style="color: #666666">+</span> dp
    <span style="color: #AA22FF; font-weight: bold">elif</span> <span style="color: #666666">0.25</span> <span style="color: #666666">&lt;=</span> r <span style="color: #666666">&lt;</span> <span style="color: #666666">0.5</span>:
        p_np1 <span style="color: #666666">=</span> p_n <span style="color: #666666">-</span> dp
    <span style="color: #AA22FF; font-weight: bold">else</span>:
        p_np1 <span style="color: #666666">=</span> p_n
    <span style="color: #AA22FF; font-weight: bold">return</span> (p_np1 <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #666666">1</span> <span style="color: #666666">&lt;=</span> p_np1 <span style="color: #666666">&lt;=</span> <span style="color: #666666">15</span> <span style="color: #AA22FF; font-weight: bold">else</span> p_n)
</pre></div>
<p>

<p>
<b>Hint 2.</b> If \( u_i(t) \) is the value of the fortune in experiment number \( i \),
\( i=0,\ldots,N-1 \),
the mean evolution of the fortune is
$$ \bar u(t)= \frac{1}{N}\sum_{i=0}^{N-1} u_i(t),
$$
and the standard deviation is
$$ s(t) = \sqrt{\frac{1}{N-1}\left(- (\bar u(t))^2 +
                \sum_{i=0}^{N-1} (u_i(t))^2\right)}
\thinspace .
$$
Suppose \( u_i(t) \) is stored in an array <tt>u</tt>.
The mean and the standard deviation of the fortune
is most efficiently computed by
using to accumulation arrays, <tt>sum_u</tt> and <tt>sum_u2</tt>, and
performing <tt>sum_u += u</tt> and <tt>sum_u2 += u**2</tt> after every experiment.
This technique avoids storing all the \( u_i(t) \) time series for
computing the statistics.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 35: Simulate sudden environmental changes for a population <a name="decay:app:exer:pop:at"></a></h3>
<p>

<p>
We shall study a population modeled by \eqref{decay:app:pop:ueq} where
the environment, represented by \( r \) and \( f \), undergoes changes with time.
Assume that there is a sudden drop (increase) in the birth (death)
rate at time \( t=t_r \),
because of limited nutrition or food supply:
$$ a(t) =\left\lbrace\begin{array}{ll}
r_0, & t< t_r,\\
r_0 - A, & t\geq t_r,\end{array}\right.
$$
This drop in population growth is compensated by a sudden net immigration
at time \( t_f>t_r \):
$$ f(t) =\left\lbrace\begin{array}{ll}
0, & t< t_f,\\
f_0, & t\geq t_a,\end{array}\right.
$$
Start with \( r_0 \) and make \( A>r_0 \). Experiment these and other parameters to
illustrate the interplay of growth and decay in such a problem.
Filename: <tt>population_drop.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 36: Simulate oscillating environment for a population <a name="decay:app:exer:pop:osc"></a></h3>
<p>

<p>
This exercise is a variant of <a href="#decay:app:exer:pop:at">Exercise 35: Simulate sudden environmental changes for a population</a>.
Now we assume that the environmental conditions changes periodically with
time so that we may take
$$ r(t) = r_0 + A\sin\left(\frac{2\pi}{P}t\right)
\thinspace .
$$
That is, the combined birth and death rate oscillates around \( r_0 \) with
a maximum change of \( \pm A \) repeating over a period of length \( P \) in time.
Set \( f=0 \) and experiment with the other parameters to illustrate typical
features of the solution.
Filename: <tt>population_osc.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 37: Simulate logistic growth <a name="decay:app:exer:pop:logistic1"></a></h3>
<p>

<p>
Solve the logistic ODE
\eqref{decay:app:pop:logistic} using a Crank-Nicolson scheme where
\( (u^{n+1/2})^2 \) is approximated by a <em>geometric mean</em>:
$$ (u^{n+1/2})^2 \approx u^{n+1}u^n
\thinspace .
$$
This trick makes the discrete equation linear in \( u^{n+1} \).
Filename: <tt>logistic_growth.py</tt>.

<p>
<!-- --- end of exercise -->

<p>

<p>

<p>

<p>
<!-- --- begin exercise -->

<p>

<h3>Exercise 38: Rederive the equation for continuous compound interest <a name="decay:app:exer:interest:derive"></a></h3>
<p>

<p>
The ODE model \eqref{decay:app:interest:eq2} was derived under the assumption
that \( r \) was constant. Perform an alternative derivation without
this assumption: 1) start with \eqref{decay:app:interest:eq1};
2) introduce a time step \( \Delta t \) instead of \( m \): \( \Delta t = 1/m \) if
\( t \) is measured in years; 3) divide by \( \Delta t \) and take the
limit \( \Delta t\rightarrow 0 \). Simulate a case where the inflation is
at a constant level \( I \) percent per year and the interest rate oscillates
around \( I/2 + r_0\sin(2\pi t) \), giving \( r=-I/2 + r_0\sin(2\pi t) \).
Compare solutions for \( r_0=I, 3I/2, 2I \).
Filename: <tt>interest_modeling.py</tt>.

<p>
<!-- --- end of exercise -->

<!-- ------------------- end of main content ----------------->
</body>
</html>
    

