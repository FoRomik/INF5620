
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Discretizing first-order ODEs by finite difference methods &mdash; Preliminary notes for INF5620 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Preliminary notes for INF5620 1.0 documentation" href="index.html" />
    <link rel="prev" title="Preliminary notes for INF5620" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Preliminary notes for INF5620"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Preliminary notes for INF5620 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="discretizing-first-order-odes-by-finite-difference-methods">
<h1>Discretizing first-order ODEs by finite difference methods<a class="headerlink" href="#discretizing-first-order-odes-by-finite-difference-methods" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Sep 13, 2012</td>
</tr>
</tbody>
</table>
<p>Note: <strong>VERY PRELIMINARY VERSION!</strong> (Still lots of typos!)</p>
<p>Finite difference methods for partial differential equations (PDEs)
employ a range of concepts and tools that can be introduced and
illustrated in the context of simple ordinary differential equation
(ODE) examples.  By first working with ODEs, we keep the mathematical
problems to be solved as simple as possible (but no simpler), thereby
allowing full focus on understanding the concepts and tools that will
be reused and further extended when addressing finite difference
methods for time-dependent PDEs. The
forthcoming treatment of ODEs is therefore solely dominated by
reasoning and methods that directly carry over to numerical
methods for PDEs.</p>
<p>We study two model problems: an ODE for a decaying phenomena, which will
be relevant for PDEs of diffusive nature, and an ODE for oscillating
phenomena, which will be relevant for PDEs of wave nature.
Both problems are linear with known analytical solutions such that we can
easily assess the quality of various numerical methods and analyze
their behavior.</p>
</div>
<div class="section" id="finite-difference-methods-for-an-ode">
<span id="decay-basics"></span><h1>Finite difference methods for an ODE<a class="headerlink" href="#finite-difference-methods-for-an-ode" title="Permalink to this headline">¶</a></h1>
<p>The purpose of this module is to explain finite difference methods
in detail for a simple ordinary differential equation (ODE).
Emphasis is put on the reasoning when discretizing the problem,
various ways of programming the methods, how to verify that
the implementation is correct, experimental investigations of
the numerical behavior of the methods, and theoretical analysis
of the methods to explain the observations.</p>
<div class="section" id="exponential-decay">
<span id="decay-model"></span><h2>Exponential decay<a class="headerlink" href="#exponential-decay" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><p id="index-1">Our model problem is perhaps the simplest ODE:</p>
<div class="math">
\[u'(t) = -au(t),\]</div>
<p>Here, <span class="math">\(a&gt;0\)</span> is a constant and <span class="math">\(u'(t)\)</span> means differentiation with respect
to time <span class="math">\(t\)</span>. This type of equation arises in a number of widely different
phenomena where some quantity <span class="math">\(u\)</span> undergoes exponential
reduction. Examples include radioactive decay, population decay,
investment decay,
cooling of an object,
pressure decay in the atmosphere,
and retarded motion in fluids (for some of these models, <span class="math">\(a\)</span> can be
negative as well).
Studying numerical solution methods for this simple ODE
gives important insight that can be reused for diffusion PDEs.</p>
<p>The analytical solution of the ODE is found by the method of
separation of variables, resulting in</p>
<div class="math">
\[u(t) = Ce^{-at},\]</div>
<p>for any arbitrary constant <span class="math">\(C\)</span>.
To formulate a mathematical problem for which there
is a unique solution, we need a condition to fix the value of <span class="math">\(C\)</span>.
This condition is known as the <em>initial condition</em> and stated as
<span class="math">\(u(0)=I\)</span>. That is, we know the
value <span class="math">\(I\)</span> of <span class="math">\(u\)</span> when the process starts at <span class="math">\(t=0\)</span>. The exact solution
is then <span class="math">\(u(t)=I\exp{(-at)}\)</span>.</p>
<p>We seek the solution <span class="math">\(u(t)\)</span> of the ODE for <span class="math">\(t\in (0,T]\)</span>. The point <span class="math">\(t=0\)</span> is not
included since we know <span class="math">\(u\)</span> here and assume that the equation governs
<span class="math">\(u\)</span> for <span class="math">\(t&gt;0\)</span>. The complete ODE problem then reads: find <span class="math">\(u(t)\)</span>
such that</p>
<div class="math" id="equation-decay:problem">
<span class="eqno">(1)</span>\[     u' = -au,\ t\in (0,T], \quad u(0)=I\thinspace .\]</div>
<p>This is known as a <em>continuous problem</em> because the parameter <span class="math">\(t\)</span>
varies continuously from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>. For each <span class="math">\(t\)</span> we have a corresponding
<span class="math">\(u(t)\)</span>. There are hence infinitely many values of <span class="math">\(t\)</span> and <span class="math">\(u(t)\)</span>.
The purpose of a numerical method is to formulate a corresponding
<em>discrete</em> problem whose solution is characterized by a finite number of values,
which can be computed in a finite number of steps on a computer.</p>
</div>
<div class="section" id="the-forward-euler-scheme">
<span id="decay-sec-fe"></span><h2>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>Solving an ODE like <a href="#equation-decay:problem">(1)</a> by a finite difference method
consists of the following four steps:</p>
<ol class="arabic simple">
<li>discretizing the domain,</li>
<li>fulfilling the equation at discrete time points,</li>
<li>replacing derivatives by finite differences,</li>
<li>formulating a recursive algorithm.</li>
</ol>
<div class="section" id="step-1-discretizing-the-domain">
<span id="index-2"></span><h3>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The time domain <span class="math">\([0,T]\)</span> is represented by a finite number of
<span class="math">\(N+1\)</span> points</p>
<div class="math">
\[\begin{split}0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N-1} &lt; t_N = T\thinspace .\end{split}\]</div>
<p>The collection of points <span class="math">\(t_0,t_1,\ldots,t_N\)</span> constitutes a <em>mesh</em>
or <em>grid</em>. Often the mesh points will be uniformly spaced in
the domain <span class="math">\([0,T]\)</span>, which means that the spacing <span class="math">\(t_{n+1}-t_n\)</span> is
the same for all <span class="math">\(n\)</span>. This spacing is then often denoted by <span class="math">\(\Delta t\)</span>,
in this case <span class="math">\(t_n=n\Delta t\)</span>.</p>
<p>We seek the solution <span class="math">\(u\)</span> at the mesh points:
<span class="math">\(u(t_n)\)</span>, <span class="math">\(n=1,2,\ldots,N\)</span> (note that <span class="math">\(u^0\)</span> is already known as <span class="math">\(I\)</span>).
A notational short-form for <span class="math">\(u(t_n)\)</span>,
which will be used extensively, is <span class="math">\(u^{n}\)</span>. More precisely, we let
<span class="math">\(u^n\)</span> be the <em>numerical approximation</em> to the exact solution
at <span class="math">\(t=t_n\)</span>, <span class="math">\(u(t_n)\)</span>. When we need to clearly distinguish the numerical
and the exact solution, we often place a subscript e on the exact
solution, as in <span class="math">\({u_{\small\mbox{e}}}(t_n)\)</span>. Figure <a class="reference internal" href="#decay-fdu-e"><em>Time mesh with discrete solution values</em></a> shows the
<span class="math">\(t_n\)</span> and <span class="math">\(u_n\)</span> points for <span class="math">\(n=0,1,\ldots,N=7\)</span> as well as <span class="math">\(u_{\small\mbox{e}}(t)\)</span>
as the dashed line.</p>
<div class="figure" id="decay-fdu-e">
<img alt="_images/fdm_u_ue.png" src="_images/fdm_u_ue.png" style="width: 600px;" />
<p class="caption"><em>Time mesh with discrete solution values</em></p>
</div>
<p>Since finite difference methods produce solutions at the mesh
points only, it is an open question what the solution is between
the mesh points. One can use methods for interpolation to
compute the value of <span class="math">\(u\)</span> between mesh points. The simplest
(and most widely used) interpolation method is to assume that
<span class="math">\(u\)</span> varies linearly between the mesh points, see
Figure <a class="reference internal" href="#decay-fdu-ei"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></a>. Given <span class="math">\(u^{n}\)</span>
and <span class="math">\(u^{n+1}\)</span>, the value of <span class="math">\(u\)</span> at some <span class="math">\(t\in [t_{n}, t_{n+1}]\)</span>
is by linear interpolation</p>
<div class="math">
\[u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n)\thinspace .\]</div>
<div class="figure" id="decay-fdu-ei">
<img alt="_images/fdm_u_uei.png" src="_images/fdm_u_uei.png" style="width: 600px;" />
<p class="caption"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></p>
</div>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h3>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h3>
<p>The ODE is supposed to hold for all <span class="math">\(t\in (0,T]\)</span>, i.e., at an infinite
number of points. Now we relax that requirement and require that
the ODE is fulfilled at a finite set of discrete points in time.
The mesh points <span class="math">\(t_1,t_2,\ldots,t_N\)</span> are a natural choice of points.
The original ODE is then reduced to  the following <span class="math">\(N\)</span> equations:</p>
<div class="math" id="equation-decay:step2">
<span class="eqno">(2)</span>\[     u'(t_n) = -au(t_n),\quad n=1,\ldots,N\thinspace .\]</div>
</div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<h3>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The next and most essential step of the method is to replace the
derivative <span class="math">\(u'\)</span> by a finite difference approximation. Let us first
try a one-sided difference approximation (see Figure <a class="reference internal" href="#decay-sketch-fe"><em>Illustration of a forward difference</em></a>),</p>
<div class="math" id="equation-decay:FEdiff">
<span class="eqno">(3)</span>\[     u'(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}\thinspace .\]</div>
<p>Inserting this approximation in <a href="#equation-decay:step2">(2)</a> results in</p>
<div class="math" id="equation-decay:step3">
<span class="eqno">(4)</span>\[     \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N-1\thinspace .\]</div>
<p>This equation is the discrete counterpart to the original ODE problem
<a href="#equation-decay:problem">(1)</a>, and often known as a <em>finite difference scheme</em>,
which yields a straightforward way to compute the solution at
the mesh points (<span class="math">\(u(t_n)\)</span>, <span class="math">\(n=1,2,\ldots,N\)</span>) as shown next.</p>
<div class="figure" id="decay-sketch-fe">
<img alt="_images/fd_forward.png" src="_images/fd_forward.png" style="width: 600px;" />
<p class="caption"><em>Illustration of a forward difference</em></p>
</div>
</div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<h3>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-3"></span><p id="index-4">The final step is to identify the computational algorithm to be implemented
in a program. The key observation here is to realize that
<a href="#equation-decay:step3">(4)</a> can be used to compute <span class="math">\(u^{n+1}\)</span> if <span class="math">\(u^n\)</span> is known.
Starting with <span class="math">\(n=0\)</span>, <span class="math">\(u^0\)</span> is known since <span class="math">\(u^0=u(0)=I\)</span>, and
<a href="#equation-decay:step3">(4)</a> gives an equation for <span class="math">\(u^1\)</span>. Knowing <span class="math">\(u^1\)</span>,
<span class="math">\(u^2\)</span> can be found from <a href="#equation-decay:step3">(4)</a>. In general, <span class="math">\(u^n\)</span>
in <a href="#equation-decay:step3">(4)</a> can be assumed known, and then we can easily solve for
the unknown <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:FE">
<span class="eqno">(5)</span>\[     u^{n+1} = u^n - a(t_{n+1} -t_n)u^n\thinspace .\]</div>
<p>We shall refer to <a href="#equation-decay:FE">(5)</a> as the Forward Euler (FE) scheme
for our model problem. From a mathematical point of view,
equations of the form <a href="#equation-decay:FE">(5)</a> are known as
<em>difference equations</em> since they express how differences in
<span class="math">\(u\)</span>, like <span class="math">\(u^{n+1}-u^n\)</span>, evolve with <span class="math">\(n\)</span>.
The finite difference method can be viewed as a method for turning
a differential equation into a difference equation.</p>
<p>Computation with <a href="#equation-decay:FE">(5)</a> is straightforward:</p>
<div class="math">
\[\begin{split}u_0 &amp;= I,\\
u_1 &amp; = u^0 - a(t_{1} -t_0)u^0 = I(1-a(t_1-t_0)),\\
u_2 &amp; = u^1 - a(t_{2} -t_1)u^1 = I(1-a(t_1-t_0))(1 - a(t_2-t_1)),\\
u^3 &amp;= u^2 - a(t_{3} -t_2)u^2 = I(1-a(t_1-t_0))(1 - a(t_2-t_1))(1 - a(t_3-t_2)),\end{split}\]</div>
<p>and so on until we reach <span class="math">\(u^N\)</span>.
In the case <span class="math">\(t_{n+1}-t_n\)</span> is a constant, denoted by <span class="math">\(\Delta t\)</span>,
we realize from the above calculations that</p>
<div class="math">
\[\begin{split}u_0 &amp;= I,\\
u_1 &amp; = I(1-a\Delta t),\\
u_2 &amp; = I(1-a\Delta t)^2,\\
u^3 &amp;= I(1-a\Delta t)^3,\\
&amp;\vdots\\
u^N &amp;= I(1-a\Delta t)^N\thinspace .\end{split}\]</div>
<p>This means that we have found a closed formula for <span class="math">\(u^n\)</span>, and there is
no need to let a computer generate the sequence <span class="math">\(u^1, u^2, u^3, \ldots\)</span>.
However, finding such a formula for <span class="math">\(u^n\)</span> is possible only for a few very
simple problems.</p>
<p>As the next sections will show, the scheme <a href="#equation-decay:FE">(5)</a> is just one
out of many alternative finite difference (and other) schemes for
the model problem <a href="#equation-decay:problem">(1)</a>.</p>
</div>
</div>
<div class="section" id="the-backward-euler-scheme">
<span id="decay-sec-be"></span><h2>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>There are many choices of difference approximations in step 3 of
the finite difference method as presented in the previous section.
Another alternative is</p>
<div class="math" id="equation-decay:BEdiff">
<span class="eqno">(6)</span>\[     u'(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}\thinspace .\]</div>
<p>Since this difference is based on going backward in time (<span class="math">\(t_{n-1}\)</span>)
for information, it is known as the Backward Euler difference.
Figure <em class="xref std std-ref">decay:sketch:BE</em> explains the idea.</p>
<div class="figure" id="decay-sketch-be">
<img alt="_images/fd_backward.png" src="_images/fd_backward.png" style="width: 600px;" />
<p class="caption"><em>Illustration of a backward difference</em></p>
</div>
<span class="target" id="index-5"></span><p id="index-6">Inserting <a href="#equation-decay:BEdiff">(6)</a> in <a href="#equation-decay:step2">(2)</a> yields
the Backward Euler (BE) scheme:</p>
<div class="math" id="equation-decay:BE0">
<span class="eqno">(7)</span>\[     \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n\thinspace .\]</div>
<p>We assume, as explained under step 4 in the section <a class="reference internal" href="#decay-sec-fe"><em>The Forward Euler scheme</em></a>,
that we have computed <span class="math">\(u^0, u^1, \ldots, u^{n-1}\)</span> such that
<a href="#equation-decay:BE0">(7)</a> can be used to compute <span class="math">\(u^n\)</span>.
For direct similarity with the Forward Euler scheme <a href="#equation-decay:FE">(5)</a>
we replace <span class="math">\(n\)</span> by <span class="math">\(n+1\)</span> in <a href="#equation-decay:BE0">(7)</a> and solve for the
unknown value <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:BE">
<span class="eqno">(8)</span>\[     u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n\thinspace .\]</div>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<span id="decay-sec-cn"></span><h2>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p id="index-7">The finite difference approximations used to derive the schemes
<a href="#equation-decay:FE">(5)</a> and <a href="#equation-decay:BE">(8)</a> are both one-sided differences,
known to be less accurate than central (or midpoint)
differences. We shall now construct
a central difference at <span class="math">\(t_{n+1/2}=\frac{1}{2} (t_n + t_{n+1})\)</span>, or
<span class="math">\(t_{n+1/2}=(n+\frac{1}{2})\Delta t\)</span> if the mesh spacing is uniform in time.
The approximation reads</p>
<div class="math" id="equation-decay:CNdiff">
<span class="eqno">(9)</span>\[     u'(t_{n+\frac{1}{2}}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}\thinspace .\]</div>
<p>Note that the fraction on the right-hand side is the same as for the
Forward Euler approximation <a href="#equation-decay:FEdiff">(3)</a> and
the Backward Euler approximation <a href="#equation-decay:BEdiff">(6)</a> (with
<span class="math">\(n\)</span> replaced by <span class="math">\(n+1\)</span>). The accuracy of this fraction as an approximation
to the derivative of <span class="math">\(u\)</span> depends on <em>where</em> we seek the derivative:
in the center of the interval <span class="math">\([t_{n+1},t_n]\)</span> or at the end points.</p>
<p>With the formula <a href="#equation-decay:CNdiff">(9)</a>, where <span class="math">\(u'\)</span> is evaluated at
<span class="math">\(t_{n+1/2}\)</span>, it is natural to demand the
ODE to be fulfilled at the time points between the mesh points:</p>
<div class="math" id="equation-decay:step2m">
<span class="eqno">(10)</span>\[     u'(t_{n+\frac{1}{2}}) = -au(t_{n+\frac{1}{2}}),\quad n=0,\ldots,N-1\thinspace .\]</div>
<p>Using <a href="#equation-decay:CNdiff">(9)</a> in <a href="#equation-decay:step2m">(10)</a> results in</p>
<div class="math" id="equation-decay:CN0">
<span class="eqno">(11)</span>\[     \frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -au^{n+\frac{1}{2}},\]</div>
<p>where <span class="math">\(u^{n+\frac{1}{2}}\)</span> is a short form for <span class="math">\(u(t_{n+\frac{1}{2}})\)</span>.
The problem is that we aim to compute <span class="math">\(u^n\)</span> for integer <span class="math">\(n\)</span>, implying that
<span class="math">\(u^{n+\frac{1}{2}}\)</span> is not a quantity computed by our method. It must be
expressed by the quantities that we actually produce, i.e., <span class="math">\(u\)</span> at the
mesh points. One possibility is to approximate <span class="math">\(u^{n+\frac{1}{2}}\)</span>
as an average of the <span class="math">\(u\)</span> values at the neighboring mesh points:</p>
<div class="math" id="equation-decay:uhalfavg">
<span class="eqno">(12)</span>\[     u^{n+\frac{1}{2}} \approx \frac{1}{2} (u^n + u^{n+1})\thinspace .\]</div>
<p>Using <a href="#equation-decay:uhalfavg">(12)</a> in <a href="#equation-decay:CN0">(11)</a> results in</p>
<div class="math" id="equation-decay:CN1">
<span class="eqno">(13)</span>\[     \frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\frac{1}{2} (u^n + u^{n+1})\thinspace .\]</div>
<p>Figure <em class="xref std std-ref">decay:sketch:BE</em> sketches the geometric interpretation of
such a centered difference.</p>
<div class="figure" id="id1">
<img alt="_images/fd_backward.png" src="_images/fd_backward.png" style="width: 600px;" />
<p class="caption"><em>Illustration of a centered difference</em></p>
</div>
<p>We assume that <span class="math">\(u^n\)</span> is already computed so that <span class="math">\(u^{n+1}\)</span> is the
unknown, which we can solve for:</p>
<div class="math" id="equation-decay:CN">
<span class="eqno">(14)</span>\[     u^{n+1} = \frac{1-\frac{1}{2} a(t_{n+1}-t_n)}{1 + \frac{1}{2} a(t_{n+1}-t_n)}u^n\thinspace .\]</div>
<p>The finite difference scheme <a href="#equation-decay:CN">(14)</a> is known as
the midpoint scheme or the Crank-Nicolson (CN) scheme. We shall use the latter
name.</p>
</div>
<div class="section" id="the-unifying-rule">
<span id="decay-sec-theta"></span><h2>The unifying <span class="math">\(\theta\)</span>-rule<a class="headerlink" href="#the-unifying-rule" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-8"></span><p id="index-9">Let us reconsider the derivation of the Forward Euler, Backward Euler,
and Crank-Nicolson schemes. In all the mentioned schemes we replace <span class="math">\(u'\)</span> by the
fraction</p>
<div class="math">
\[\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n},\]</div>
<p>and the difference between the methods lies in which point this
fraction approximates the derivative; i.e., in which point we
sample the ODE. So far this has been the
end points or the midpoint of <span class="math">\([t_n,t_{n+1}]\)</span>. However, we may choose any point
<span class="math">\(\tilde t \in [t_n,t_{n+1}]\)</span>.
The difficulty
is that evaluating the right-hand side <span class="math">\(-au\)</span> at an arbitrary point
faces the same problem as in
the section <a class="reference internal" href="#decay-sec-cn"><em>The Crank-Nicolson scheme</em></a>: the point value must be expressed
by the discrete <span class="math">\(u\)</span> quantities that we compute by the scheme, i.e.,
<span class="math">\(u^n\)</span> and <span class="math">\(u^{n+1}\)</span>. Following the averaging idea from
the section <a class="reference internal" href="#decay-sec-cn"><em>The Crank-Nicolson scheme</em></a>,
the value of <span class="math">\(u\)</span> at an arbitrary point <span class="math">\(\tilde t\)</span> can be
calculated as a <em>weighted average</em>, which generalizes the arithmetic average
<span class="math">\(\frac{1}{2}u^n + \frac{1}{2}u^{n+1}\)</span>.
If we express <span class="math">\(\tilde t\)</span> as a weighted average</p>
<div class="math">
\[t_{n+\theta} = \theta t_{n+1} + (1-\theta) t_{n},\]</div>
<p>where <span class="math">\(\theta\in [0,1]\)</span> is the weighting factor, we can write</p>
<div class="math" id="equation-decay:thetaavg">
<span class="eqno">(15)</span>\[     u(\tilde t) = u(\theta t_{n+1} + (1-\theta) t_{n}) \approx
     \theta u^{n+1} + (1-\theta) u^{n}\thinspace .\]</div>
<p id="index-10">We can now let the ODE hold at the point
<span class="math">\(\tilde t\in [t_n,t_{n+1}]\)</span>, approximate <span class="math">\(u'\)</span> by the fraction
<span class="math">\((u^{n+1}-u^{n})/(t_{n+1}-t_n)\)</span>, and approximate the right-hand
side <span class="math">\(-au\)</span> by the weighted average <a href="#equation-decay:thetaavg">(15)</a>.
The result is</p>
<div class="math" id="equation-decay:th0">
<span class="eqno">(16)</span>\[     \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})\]\[     \thinspace .\]</div>
<p>This is a generalized scheme for our model problem:
<span class="math">\(\theta =0\)</span> gives the Forward Euler scheme, <span class="math">\(\theta =1\)</span> gives the
Backward Euler scheme, and <span class="math">\(\theta =1/2\)</span> gives the Crank-Nicolson
scheme. In addition, we may choose any other value of <span class="math">\(\theta\)</span> in <span class="math">\([0,1]\)</span>.</p>
<p>As before, <span class="math">\(u^n\)</span> is considered known and <span class="math">\(u^{n+1}\)</span> unknown, so
we solve for the latter:</p>
<div class="math" id="equation-decay:th">
<span class="eqno">(17)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}\thinspace .\]</div>
<p>This scheme is known as the <span class="math">\(\theta\)</span>-rule, or alternatively written as
the &#8220;theta-rule&#8221;.</p>
</div>
<div class="section" id="constant-time-step">
<h2>Constant time step<a class="headerlink" href="#constant-time-step" title="Permalink to this headline">¶</a></h2>
<p>All schemes up to now have been formulated for a general non-uniform
mesh in time: <span class="math">\(t_0,t_1,\ldots,t_N\)</span>. Non-uniform meshes are highly relevant
since one can use many points in regions where <span class="math">\(u\)</span> varies rapidly, and
save points in regions where <span class="math">\(u\)</span> is slowly varying. This is the key idea
of <em>adaptive</em> methods where the spacing of the mesh points
are determined as the computations proceed.</p>
<p>However, a uniformly distributed set of mesh points is very common and
sufficient for many applications. It therefore makes sense to
present the finite difference schemes for a uniform point distribution
<span class="math">\(t_n=n\Delta t\)</span>, where <span class="math">\(\Delta t\)</span> is the constant spacing between
the mesh points, also referred to as the <em>time step</em>.
The resulting formulas look simpler and are perhaps more
well known:</p>
<div class="math">
\[\begin{split}u^{n+1} &amp;= (1 - a\Delta t )u^n  \quad (\hbox{FE})
\\
u^{n+1} &amp;= \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})
\\
u^{n+1} &amp;= \frac{1-\frac{1}{2} a\Delta t}{1 + \frac{1}{2} a\Delta t} u^n \quad \quad (\hbox{CN})
\\
u^{n+1} &amp;= \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})\end{split}\]</div>
<p>Not surprisingly, we present alternative schemes
because they have different pros and cons, both for the simple ODE
in question (which can easily be solved as accurately as desired), and for
more advanced differential equation problems.</p>
</div>
<div class="section" id="compact-operator-notation-for-finite-differences">
<span id="decay-sec-fdop"></span><h2>Compact operator notation for finite differences<a class="headerlink" href="#compact-operator-notation-for-finite-differences" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-11"></span><p id="index-12">Finite difference formulas can be tedious to write and read,
especially for differential equations with many terms and many
derivatives. To save space and help the reader of the scheme to quickly
see the nature of the difference approximations, we introduce a
compact notation. A forward difference approximation is denoted
by the <span class="math">\(D_t^+\)</span> operator:</p>
<div class="math" id="equation-fd:D:f">
<span class="eqno">(18)</span>\[     [D_t^+u]^n = \frac{u^{n+1} - u^{n}}{\Delta t}
     \approx \frac{d}{dt} u(t_n)
     \thinspace .\]</div>
<p>The notation consists of an operator that approximates
differentiation with respect to an independent variable, here <span class="math">\(t\)</span>.
The operator is built of the symbol <span class="math">\(D\)</span>, with the variable as subscript
and a superscript denoting the type of difference. The superscript <span class="math">\({}^+\)</span>
indicates a forward difference.
We place square brackets around the operator and the function it operates
on and specify the mesh point, where the operator is acting, by
a superscript.</p>
<p>The corresponding operator notation for a centered difference and
a backward difference reads</p>
<div class="math" id="equation-fd:D:c">
<span class="eqno">(19)</span>\[     [D_tu]^n = \frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t}
     \approx \frac{d}{dt} u(t_n),\]</div>
<p>and</p>
<div class="math" id="equation-fd:D:b">
<span class="eqno">(20)</span>\[     [D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}
     \approx \frac{d}{dt} u(t_n)
     \thinspace .\]</div>
<p>Note that the superscript <span class="math">\({}^-\)</span> denotes the backward
difference, while no superscript implies a central difference.</p>
<p>An averaging operator is also convenient to have:</p>
<div class="math" id="equation-fd:mean:a">
<span class="eqno">(21)</span>\[     [\overline{u}^{t}]^n = \frac{1}{2} (u^{n-\frac{1}{2}} + u^{n+\frac{1}{2}} )
     \approx u(t_n)\]</div>
<p>The superscript <span class="math">\(t\)</span> indicates that the average is taken along the time
coordinate. The common average <span class="math">\((u^n + u^{n+1})/2\)</span> can now be
expressed as <span class="math">\([\overline{u}^{t}]^{n+1/2}\)</span>.</p>
<p>The Backward Euler finite difference approximation to <span class="math">\(u'=-au\)</span> can be written
as follows utilizing the compact notation:</p>
<div class="math">
\[[D_t^-u]^n = -au^n \thinspace .\]</div>
<p>In difference equations we often place the square brackets around
the whole equation, to indicate at which mesh point the equation applies,
since each term is supposed to be approximated at the same point:</p>
<div class="math">
\[[D_t^- u  = -au]^n \thinspace .\]</div>
<p>The Forward Euler scheme takes the form</p>
<div class="math">
\[[D_t^+ u  = -au]^n,\]</div>
<p>while the Crank-Nicolson scheme is written as</p>
<div class="math" id="equation-fd:compact:ex:CN">
<span class="eqno">(22)</span>\[     [D_t u = -a\overline{u}^t]^{n+\frac{1}{2}}\thinspace .\]</div>
<p>Just apply <a href="#equation-fd:D:c">(19)</a> and <a href="#equation-fd:mean:a">(21)</a> and write out the
expressions to see that <a href="#equation-fd:compact:ex:CN">(22)</a> is indeed the
Crank-Nicolson scheme.</p>
<p>The <span class="math">\(\theta\)</span>-rule can be specified by</p>
<div class="math" id="equation-decay:fd1:op:theta">
<span class="eqno">(23)</span>\[     [\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta},\]</div>
<p>if we define a new time difference and a <em>weighted averaging operator</em>:</p>
<div class="math">
\[[\bar D_t u]^{n+\theta} = \frac{u^{n+1}-u^n}{t^{n+1}-t^n},\]\[[\overline{u}^{t,\theta}]^{n+\theta} = (1-\theta)u^{n} + \theta u^{n+1}
\approx u(t_{n+\theta}),\]</div>
<p>where <span class="math">\(\theta\in [0,1]\)</span>. Note that for <span class="math">\(\theta =1/2\)</span> we recover
the standard centered difference and the standard arithmetic average.
The idea in <a href="#equation-decay:fd1:op:theta">(23)</a> is to sample the equation at
<span class="math">\(t_{n+\theta}\)</span>, use a skew difference at that
point <span class="math">\([\bar D_t u]^{n+\theta}\)</span>, and a shifted mean value.
An alternative notation is</p>
<div class="math">
\[[D_t u]^{n+1/2} = \theta [-au]^{n+1} + (1-\theta)[-au]^{n}\thinspace .\]</div>
<p>Looking at the various examples above and comparing them with the
underlying differential equations, we see immediately which difference
approximations that have been used and at which point they
apply. Therefore, the compact notation efficiently communicates the
reasoning behind turning a differential equation into a difference
equation.</p>
</div>
</div>
<div class="section" id="implementation">
<span id="decay-impl1"></span><h1>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<p>The purpose now is to make a computer program for solving</p>
<div class="math">
\[u'(t) = -au(t),\quad t\in (0,T], \quad u(0)=I,\]</div>
<p>and display the solution on the screen, preferably together with the
exact solution. We shall also be concerned with how we can test
that the implementation is correct.</p>
<p>All programs referred to in this section are found in the
<a class="reference external" href="https://github.com/hplgit/INF5620/tree/gh-pages/src/decay">src/decay</a> directory.</p>
<p><em>Mathematical problem.</em> We want to explore the Forward Euler scheme, the
Backward Euler, and the Crank-Nicolson schemes applied to our model problem.
From an implementational points of view, it is advantageous to
implement the <span class="math">\(\theta\)</span>-rule</p>
<div class="math">
\[u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,\]</div>
<p>since it can generate the three other schemes by various of
choices of <span class="math">\(\theta\)</span>: <span class="math">\(\theta=0\)</span> for Forward Euler, <span class="math">\(\theta =1\)</span> for
Backward Euler, and <span class="math">\(\theta =1/2\)</span> for Crank-Nicolson.
Given <span class="math">\(a\)</span>, <span class="math">\(u^0=I\)</span>, <span class="math">\(T\)</span>, and <span class="math">\(\Delta t\)</span>,
our task is to use the <span class="math">\(\theta\)</span>-rule to
compute <span class="math">\(u^1, u^2,\ldots,u^N\)</span>, where <span class="math">\(t_N=N\Delta t\)</span>, and
<span class="math">\(N\)</span> the closest integer to <span class="math">\(T/\Delta t\)</span>.</p>
<p><em>Computer Language: Python.</em> Any programming language can be used to generate the <span class="math">\(u^{n+1}\)</span> values from
the formula above. However, in this document we shall mainly make use of
Python of several reasons:</p>
<blockquote>
<div><ul class="simple">
<li>Python has a very clean, readable syntax (often known as
&#8220;executable pseudo-code&#8221;).</li>
<li>Python code is very similar to MATLAB code (and MATLAB has a
particularly widespread use for scientific computing).</li>
<li>Python is similar to, but much simpler to work with and
results in more reliable code than C++.</li>
<li>Python is a full-fledged, very powerful programming language.</li>
<li>Python has a rich set of modules for scientific computing, and its
popularity in scientific computing is rapidly growing.</li>
<li>Python was made for being combined with compiled languages
(C, C++, Fortran) to reuse existing numerical software and to
reach high computational performance of new implementations.</li>
<li>Python has extensive support for administrative task
needed when doing large-scale computational investigations.</li>
<li>Python has extensive support for graphics (visualization,
user interfaces, web applications).</li>
<li>FEniCS, a very powerful tool for solving PDEs by
the finite element method, is most human-efficient to operate
from Python.</li>
</ul>
</div></blockquote>
<p>Learning Python is easy. Many newcomers to the language will probably
learn enough from the examples to perform their own computer
experiments. The examples start with simple Python code and gradually
make use of more powerful constructs as we proceed. As long as it is
not inconvenient for the problem at hand, our Python code is made as
close as possible to MATLAB code for easy transition between the two
languages.</p>
<div class="section" id="making-a-program">
<span id="decay-py1"></span><h2>Making a program<a class="headerlink" href="#making-a-program" title="Permalink to this headline">¶</a></h2>
<p>We choose to have an array <tt class="docutils literal"><span class="pre">u</span></tt> for storing the <span class="math">\(u^n\)</span> values, <span class="math">\(n=0,1,\ldots,N\)</span>.
The algorithmic steps are</p>
<blockquote>
<div><ol class="arabic simple">
<li>initialize <span class="math">\(u^0\)</span></li>
<li>for <span class="math">\(t=t_n\)</span>, <span class="math">\(n=1,2,\ldots,N\)</span>: compute <span class="math">\(u_n\)</span> using
the <span class="math">\(\theta\)</span>-rule formula</li>
</ol>
</div></blockquote>
<div class="section" id="function-for-computing-the-numerical-solution">
<h3>Function for computing the numerical solution<a class="headerlink" href="#function-for-computing-the-numerical-solution" title="Permalink to this headline">¶</a></h3>
<p>The following Python function takes the input data of the problem
(<span class="math">\(I\)</span>, <span class="math">\(a\)</span>, <span class="math">\(T\)</span>, <span class="math">\(\Delta t\)</span>, <span class="math">\(\theta\)</span>) as arguments and returns two arrays with
the solution <span class="math">\(u^0,\ldots,u^N\)</span> and the mesh points <span class="math">\(t_0,\ldots,t_N\)</span>,
respectively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>            <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                 <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>    <span class="c"># n=0,1,...,N-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">numpy</span></tt> library contains a lot of functions for array computing. Most
of the function names are similar to what is found
in the alternative scientific computing language MATLAB. Here
we make use of</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">zeros(N+1)</span></tt> for creating an array of a size <tt class="docutils literal"><span class="pre">N+1</span></tt>
and initializing the elements to zero</li>
<li><tt class="docutils literal"><span class="pre">linspace(0,</span> <span class="pre">T,</span> <span class="pre">N+1)</span></tt> for creating an array with <tt class="docutils literal"><span class="pre">N+1</span></tt> coordinates uniformly
distributed between <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt></li>
</ul>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">for</span></tt> loop deserves a comment, especially for newcomers to Python.
The construction <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">N,</span> <span class="pre">s)</span></tt> generates all integers from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">N</span></tt>
in steps of <tt class="docutils literal"><span class="pre">s</span></tt>, <em>but not including</em> <tt class="docutils literal"><span class="pre">N</span></tt>. Omitting <tt class="docutils literal"><span class="pre">s</span></tt> means <tt class="docutils literal"><span class="pre">s=1</span></tt>.
For example, <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">6,</span> <span class="pre">3)</span></tt>
gives <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt>, while <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">N)</span></tt> generates <tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">1</span></tt>, ..., <tt class="docutils literal"><span class="pre">N-1</span></tt>.
In our loop, <tt class="docutils literal"><span class="pre">n</span></tt> takes on the values generated by <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">N)</span></tt>,
implying the following assignments <tt class="docutils literal"><span class="pre">u[n+1]</span></tt>: <tt class="docutils literal"><span class="pre">u[1]</span></tt>, <tt class="docutils literal"><span class="pre">u[2]</span></tt>, ...,
<tt class="docutils literal"><span class="pre">u[N]</span></tt>, which is what we want since <tt class="docutils literal"><span class="pre">u</span></tt> has length <tt class="docutils literal"><span class="pre">N+1</span></tt>.
The first index in Python arrays or lists is <em>always</em> <tt class="docutils literal"><span class="pre">0</span></tt> and the
last is then <tt class="docutils literal"><span class="pre">len(u)-1</span></tt>.</p>
<p>To compute with the <tt class="docutils literal"><span class="pre">solver</span></tt> function, we need to <em>call</em> it. Here
is a sample call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="integer-division">
<h3>Integer division<a class="headerlink" href="#integer-division" title="Permalink to this headline">¶</a></h3>
<p>The shown implementation of the <tt class="docutils literal"><span class="pre">solver</span></tt> may face problems and
wrong results if <tt class="docutils literal"><span class="pre">T</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">dt</span></tt>, and <tt class="docutils literal"><span class="pre">theta</span></tt> are given as integers,
see <a class="reference internal" href="#decay-exer-intdiv"><em>Exercise 1: Experiment with integer division</em></a> and <a class="reference internal" href="#decay-exer-decay1err"><em>Exercise 2: Experiment with wrong computations</em></a>.
The problem is related to <em>integer division</em> in Python (as well as
in Fortran, C, and C++): <tt class="docutils literal"><span class="pre">1/2</span></tt> becomes <tt class="docutils literal"><span class="pre">0</span></tt>,
while <tt class="docutils literal"><span class="pre">1.0/2</span></tt>, <tt class="docutils literal"><span class="pre">1/2.0</span></tt>, or <tt class="docutils literal"><span class="pre">1.0/2.0</span></tt> all become are <tt class="docutils literal"><span class="pre">0.5</span></tt>. It is enough
that at least the nominator or the denominator is a real number
(i.e., a <tt class="docutils literal"><span class="pre">float</span></tt> object)
to ensure correct mathematical division. Inserting
a conversion <tt class="docutils literal"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">float(dt)</span></tt>
guarantees that <tt class="docutils literal"><span class="pre">dt</span></tt> is
<tt class="docutils literal"><span class="pre">float</span></tt> and avoids problems in <a class="reference internal" href="#decay-exer-decay1err"><em>Exercise 2: Experiment with wrong computations</em></a>.</p>
<p>Another problem with computing <span class="math">\(N=T/\Delta t\)</span> is that we should
round <span class="math">\(N\)</span> to the nearest integer. With <tt class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">int(T/dt)</span></tt> the <tt class="docutils literal"><span class="pre">int</span></tt>
operation picks the largest integer smaller than <tt class="docutils literal"><span class="pre">T/dt</span></tt>. Correct
rounding is obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete version of our improved, safer <tt class="docutils literal"><span class="pre">solver</span></tt> function then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>           <span class="c"># avoid integer division</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>     <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                 <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>    <span class="c"># n=0,1,...,N-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
<div class="section" id="doc-strings">
<h3>Doc strings<a class="headerlink" href="#doc-strings" title="Permalink to this headline">¶</a></h3>
<p id="index-13">Right below the header line in the <tt class="docutils literal"><span class="pre">solver</span></tt> function there is a
Python string enclosed in triple double quotes <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt>.
The purpose of this string object is to document what the function
does and what the arguments are. In this case the necessary
documentation do not span more than one line, but with triple double
quoted strings the text may span several lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve</span>

<span class="sd">        u&#39;(t) = -a*u(t),</span>

<span class="sd">    with initial condition u(0)=I, for t in the time interval</span>
<span class="sd">    (0,T]. The time interval is divided into time steps of</span>
<span class="sd">    length dt.</span>

<span class="sd">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span class="sd">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span class="sd">    Nicolson method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Such documentation strings appearing right after the header of
a function are called <em>doc strings</em>. There are tools that can automatically
produce nicely formatted documentation by extracting the definition of
functions and the contents of doc strings.</p>
<p>It is strongly recommended to equip any function whose purpose
is not obvious with a doc string. Nevertheless, the forthcoming
text deviates from this rule if the function is explained in the text.</p>
</div>
<div class="section" id="formatting-of-numbers">
<h3>Formatting of numbers<a class="headerlink" href="#formatting-of-numbers" title="Permalink to this headline">¶</a></h3>
<p>Having computed the discrete solution <tt class="docutils literal"><span class="pre">u</span></tt>, it is natural to look at
the numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Write out a table of t and u values:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>This compact <tt class="docutils literal"><span class="pre">print</span></tt> statement gives unfortunately quite ugly output
because the <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> values are not aligned in nicely formatted columns.
To fix this problem, we recommend to use the <em>printf format</em>, supported most
programming languages inherited from C. Another choice is
Python&#8217;s recent <em>format string syntax</em>.</p>
<p id="index-14">Writing <tt class="docutils literal"><span class="pre">t[i]</span></tt> and <tt class="docutils literal"><span class="pre">u[i]</span></tt> in two nicely formatted columns is done like
this with the printf format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s"> u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>The percentage signs signify &#8220;slots&#8221; in the text where the variables
listed at the end of the statement are inserted. For each &#8220;slot&#8221; one
must specify a format for how the variable is going to appear in the
string: <tt class="docutils literal"><span class="pre">s</span></tt> for pure text, <tt class="docutils literal"><span class="pre">d</span></tt> for an integer, <tt class="docutils literal"><span class="pre">g</span></tt> for a real number
written as compactly as possible, <tt class="docutils literal"><span class="pre">9.3E</span></tt> for scientific notation with
three decimals in a field of width 9 characters (e.g., <tt class="docutils literal"><span class="pre">-1.351E-2</span></tt>),
or <tt class="docutils literal"><span class="pre">.2f</span></tt> for a standard decimal notation, here with two decimals,
formatted with minimum width. The printf syntax provides a quick way
of formatting tabular output of numbers with full control of the
layout.</p>
<p id="index-15">The alternative <em>format string syntax</em> looks like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;t={t:6.3f} u={u:g}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>As seen, this format allows logical names in the &#8220;slots&#8221; where
<tt class="docutils literal"><span class="pre">t[i]</span></tt> and <tt class="docutils literal"><span class="pre">u[i]</span></tt> are to be inserted. The &#8220;slots&#8221; are surrounded
by curly braces, and the logical name is followed by a colon and
then the printf-like specification of how to format real numbers,
integers, or strings.</p>
</div>
<div class="section" id="running-the-program">
<h3>Running the program<a class="headerlink" href="#running-the-program" title="Permalink to this headline">¶</a></h3>
<p>The function and main program shown above must be placed in a file,
say with name <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_v1.py">dc_v1.py</a>.  Make sure you
write the code with a suitable text editor (Gedit, Emacs, Vim,
Notepad++, or similar).  The program is run by executing the file this
way:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_v1.py</span>
</pre></div>
</div>
<p>The text <tt class="docutils literal"><span class="pre">Terminal&gt;</span></tt> just signifies a prompt in a
Unix/Linux or DOS terminal window. After this prompt (which will look
different in your terminal window, depending on the terminal application
and how it is set up), commands like <tt class="docutils literal"><span class="pre">python</span> <span class="pre">dc_v1.py</span></tt> can be issued.
These commands are interpreted by the operating system.</p>
<p>We strongly recommend to run Python programs within the IPython shell.
First start IPython by typing <tt class="docutils literal"><span class="pre">ipython</span></tt> in the terminal window.
Inside the IPython shell, our program <tt class="docutils literal"><span class="pre">dc_v1.py</span></tt> is run by the command
<tt class="docutils literal"><span class="pre">run</span> <span class="pre">dc_v1.py</span></tt>.
The advantage of running programs in IPython are many: previous commands
are easily recalled, <tt class="docutils literal"><span class="pre">%pdb</span></tt> turns on debugging so that
variables can be examined if the program
aborts due to an exception, output of commands are stored in variables,
programs and statements can be profiled,
any operating system command can be executed, modules can be loaded
automatically and other customizations can be performed when starting
IPython &#8211; to mention a few of the most
useful features.</p>
<p>Although running programs in IPython is strongly recommended, most
execution examples in the forthcoming text use the standard
Python shell with prompt <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> and run programs through
a typesetting like
<tt class="docutils literal"><span class="pre">Terminal&gt;</span> <span class="pre">python</span> <span class="pre">programname</span></tt>. The reason is that such typesetting
makes the text more compact in the vertical direction
than showing sessions with IPython syntax.</p>
</div>
</div>
<div class="section" id="verifying-the-implementation">
<h2>Verifying the implementation<a class="headerlink" href="#verifying-the-implementation" title="Permalink to this headline">¶</a></h2>
<p>It is easy to make mistakes while deriving and implementing numerical
algorithms, so we should never believe in the printed <span class="math">\(u\)</span> values before
they have been thoroughly verified. The most obvious idea is to compare
the computed solution with the exact solution, when that exists,
but there will always be a discrepancy between these two solutions
because of the numerical approximations. The challenging question is whether
we have the mathematically correct discrepancy or if we have another,
maybe small, discrepancy due to both an approximation error
and an error in the implementation.</p>
<p>The purpose of <em>verifying</em> a program is to bring evidence for the
fact that there are no errors in the implementation. To avoid
mixing unavoidable approximation errors and undesired
implementation errors, we should
try to make tests where we have some exact computation of the
discrete solution or at least parts of it.</p>
<div class="section" id="running-a-few-algorithmic-steps-by-hand">
<h3>Running a few algorithmic steps by hand<a class="headerlink" href="#running-a-few-algorithmic-steps-by-hand" title="Permalink to this headline">¶</a></h3>
<p>The simplest approach to produce a correct reference for the discrete
solution <span class="math">\(u\)</span> of finite difference equations is to compute a few
steps of the algorithm by hand. Then we can compare the hand
calculations with numbers produced by the program.</p>
<p>A straightforward approach is to use a calculator and
compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>. However, the chosen values of <span class="math">\(I\)</span> and <span class="math">\(\theta\)</span>
given in the execution example above are not good, because the
numbers 0 and 1 can easily
simplify formulas too much for test purposes. For example, with
<span class="math">\(\theta =1\)</span> the nominator in the formula for <span class="math">\(u^n\)</span> will be the same for
all <span class="math">\(a\)</span> and <span class="math">\(\Delta t\)</span> values. One should therefore choose more
&#8220;arbitrary&#8221; values, say <span class="math">\(\theta =0.8\)</span> and <span class="math">\(I=0.1\)</span>. Hand calculations
with the aid of a calculator gives</p>
<div class="math">
\[A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035\]</div>
<div class="math">
\[\begin{split}u^1 &amp;= AI=0.0298245614035,\\
u^2 &amp;= Au^1= 0.00889504462912,\\
u^3 &amp;=Au^2= 0.00265290804728\end{split}\]</div>
<p>Comparison of these manual calculations with the result of the
<tt class="docutils literal"><span class="pre">solver</span></tt> function is carried out in the function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_three_steps</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare three steps with known manual computations.&quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">I</span><span class="p">,</span>
                       <span class="mf">0.0298245614035</span><span class="p">,</span>
                       <span class="mf">0.00889504462912</span><span class="p">,</span>
                       <span class="mf">0.00265290804728</span><span class="p">])</span>

    <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># number of time steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>  <span class="c"># tolerance for comparing floats</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_by_hand</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="k">return</span> <span class="n">success</span>
</pre></div>
</div>
<p>The main program, where we call the <tt class="docutils literal"><span class="pre">solver</span></tt> function and print <tt class="docutils literal"><span class="pre">u</span></tt>,
is now put in a separate function <tt class="docutils literal"><span class="pre">main</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Write out a table of t and u values:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="k">print</span> <span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s"> u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c"># or print &#39;t={t:6.3f} u={u:g}&#39;.format(t=t[i], u=u[i])</span>
</pre></div>
</div>
<p>The main program in the file may now first run the verification test
and then go on with the real simulation (<tt class="docutils literal"><span class="pre">main()</span></tt>) only if the test is passed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">verify_three_steps</span><span class="p">():</span>
    <span class="n">main</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Bug in the implementation!&#39;</span>
</pre></div>
</div>
<p>Since the verification test is always done, future errors introduced
accidentally in the program have a good chance of being detected.</p>
<p>It is essential that verification tests can be automatically run
at <em>any</em> time. For this purpose,
there are test frameworks and corresponding programming
rules that allow us to request running through a suite of test cases,
but in this very early stage of program development we just implement
and run the verification in our own code so that every detail is
visible and understood.</p>
<p>The complete program including the <tt class="docutils literal"><span class="pre">verify_three_steps*</span></tt> functions is
found in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_verf1.py">dc_verf1.py</a>.</p>
</div>
<div class="section" id="comparison-with-an-exact-discrete-solution">
<h3>Comparison with an exact discrete solution<a class="headerlink" href="#comparison-with-an-exact-discrete-solution" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is possible to find a closed-form
<em>exact discrete solution</em> that fulfills the discrete finite
difference equations. The implementation can then be verified against
the exact discrete solution. This is usually the best technique for
verification.</p>
<p>Define</p>
<div class="math">
\[A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}\thinspace .\]</div>
<p>Manual computations with the <span class="math">\(\theta\)</span>-rule results in</p>
<div class="math">
\[\begin{split}u^0 &amp;= I,\\
u^1 &amp;= Au^0 = AI,\\
u^2 &amp;= Au^1 = A^2I,\\
&amp;\vdots\\
u^n &amp;= A^nu^{n-1} = A^nI \thinspace .\end{split}\]</div>
<p>We have then established the exact discrete solution as</p>
<div class="math" id="equation-decay:un:exact">
<span class="eqno">(24)</span>\[     u^n = IA^n\]\[     \thinspace .\]</div>
<p>One should be conscious about the different meanings of the notation
on the left- and right-hand side
of this equation: on the left, <span class="math">\(n\)</span> is a superscript reflecting a counter
of mesh points, while on the right, <span class="math">\(n\)</span> is the power in an exponentiation.</p>
<p>Comparison of the exact discrete solution and the computed
solution is done in the following function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_exact_discrete_solution</span><span class="p">():</span>

    <span class="k">def</span> <span class="nf">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">factor</span><span class="o">**</span><span class="n">n</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_de</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>  <span class="c"># tolerance for comparing floats</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="k">return</span> <span class="n">success</span>
</pre></div>
</div>
<p>Note that one can define a function inside another function (but such
a function is invisible outside the function in which it is defined).
The complete program is found in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_verf2.py">dc_verf2.py</a>.</p>
</div>
</div>
<div class="section" id="computing-the-numerical-error">
<span id="decay-computing-error"></span><h2>Computing the numerical error<a class="headerlink" href="#computing-the-numerical-error" title="Permalink to this headline">¶</a></h2>
<p>Now that we have evidence for a correct implementation, we are in a
position to compare the computed <span class="math">\(u^n\)</span> values in the <tt class="docutils literal"><span class="pre">u</span></tt> array with
the exact <span class="math">\(u\)</span> values at the mesh points, in order to study the error
in the numerical solution.</p>
<p>Let us first make a function for the analytical solution <span class="math">\(u_{\small\mbox{e}}(t)=Ie^{-at}\)</span>
of the model problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>A natural way to compare the exact and discrete solutions is to
calculate their difference at the mesh points:</p>
<div class="math">
\[e_n = u_{\small\mbox{e}}(t_n) - u^n,\quad n=0,1,\ldots,N \thinspace .\]</div>
<p>These numbers are conveniently computed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>  <span class="c"># Numerical solution</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
</pre></div>
</div>
<p>The last two statements make use of array arithmetics: <tt class="docutils literal"><span class="pre">t</span></tt> is an
array of mesh points that we pass to <tt class="docutils literal"><span class="pre">exact_solution</span></tt>. This function
evaluates <tt class="docutils literal"><span class="pre">-a*t</span></tt>, which is a scalar times an array, meaning that
the scalar is multiplied with each array element.
The result is an array, let us call it <tt class="docutils literal"><span class="pre">tmp1</span></tt>. Then
<tt class="docutils literal"><span class="pre">exp(tmp1)</span></tt> means applying the exponential function to each element in
<tt class="docutils literal"><span class="pre">tmp</span></tt>, resulting an array, say <tt class="docutils literal"><span class="pre">tmp2</span></tt>. Finally, <tt class="docutils literal"><span class="pre">I*tmp2</span></tt> is computed
(scalar times array) and <tt class="docutils literal"><span class="pre">u_e</span></tt> refers to this array returned from
<tt class="docutils literal"><span class="pre">exact_solution</span></tt>. The expression <tt class="docutils literal"><span class="pre">u_e</span> <span class="pre">-</span> <span class="pre">u</span></tt> is the difference between
two arrays, resulting in a new array referred to by <tt class="docutils literal"><span class="pre">e</span></tt>.</p>
<p>The array <tt class="docutils literal"><span class="pre">e</span></tt> is the current problem&#8217;s discrete <em>error function</em>. Very
often we want to work with just one number reflecting the size of the
error. A common choice is to integrate <span class="math">\(e_n^2\)</span> over the mesh and take
the square root.  Assuming the exact and discrete solution to vary
linearly between the mesh points, the integral is given exactly by the
Trapezoidal rule:</p>
<div class="math">
\[\hat E^2 = \Delta t\left(\frac{1}{2}e_0^2 + \frac{1}{2}e_N^2
+ \sum_{n=1}^{N-1} e_n^2\right)\]</div>
<p>A common approximation of this expression, for convenience, is</p>
<div class="math">
\[\hat E^2 \approx E^2 = \Delta t\sum_{n=0}^{N} e_n^2\]</div>
<p>The error in this approximation is not much of a concern: it means that
the error measure is not exactly the Trapezoidal rule of an integral, but
a slightly different measure. We could equally well have chosen other
error messages, but the choice is not important as long as we use the
same error measure consistently in all experiments
when investigating the error.</p>
<p>The error measure <span class="math">\(\hat E\)</span> or <span class="math">\(E\)</span> is referred to as the
<span class="math">\(L_2\)</span> norm of the discrete error function.
The formula for <span class="math">\(E\)</span> will be frequently used:</p>
<div class="math" id="equation-decay:E">
<span class="eqno">(25)</span>\[     E = \sqrt{\Delta t\sum_{n=0}^N e_n^2}\]</div>
<p>The corresponding Python code, using array arithmetics, reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">sum</span></tt> function comes from <tt class="docutils literal"><span class="pre">numpy</span></tt> and computes the sum of the elements
of an array. Also the <tt class="docutils literal"><span class="pre">sqrt</span></tt> function is from <tt class="docutils literal"><span class="pre">numpy</span></tt> and computes the
square root of each element in the array argument.</p>
<p>Instead of doing array computing we can compute with
one element at a time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>     <span class="c"># length of u array (alt: u.size)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># summation variable</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Such element-wise computing, often called <em>scalar</em> computing, takes
more code, is less readable, and runs much slower than array computing.</p>
</div>
<div class="section" id="plotting-solutions">
<h2>Plotting solutions<a class="headerlink" href="#plotting-solutions" title="Permalink to this headline">¶</a></h2>
<p>Having the <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> arrays, the approximate solution <tt class="docutils literal"><span class="pre">u</span></tt> is visualized
by <tt class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>It will be illustrative to also plot <span class="math">\(u_{\small\mbox{e}}(t)\)</span> for comparison. Doing a
<tt class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u_e)</span></tt> is not exactly what we want: the <tt class="docutils literal"><span class="pre">plot</span></tt> function draws
straight lines between the discrete points <tt class="docutils literal"><span class="pre">(t[n],</span> <span class="pre">u_e[n])</span></tt> while
<span class="math">\(u_{\small\mbox{e}}(t)\)</span> varies as an exponential function between the mesh points.
The technique for showing the &#8220;exact&#8221; variation of <span class="math">\(u_{\small\mbox{e}}(t)\)</span> between
the mesh points is to introduce a very fine mesh for <span class="math">\(u_{\small\mbox{e}}(t)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>      <span class="c"># fine mesh</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r-&#39;</span><span class="p">)</span>            <span class="c"># red  line for u</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>            <span class="c"># blue line for u_e</span>
</pre></div>
</div>
<p>With more than one curve in the plot we need to associate each curve
with a legend. We also want appropriate names on the axis, a title,
and a file containing the plot as an image for inclusion in reports.
The Matplotlib package (<tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt>) contains functions for
this purpose. The names of the functions are similar to the plotting
functions known from MATLAB.  A complete plot session then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">figure</span><span class="p">()</span>                          <span class="c"># create new plot</span>
<span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>        <span class="c"># fine mesh for u_e</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">)</span>            <span class="c"># red dashes w/circles</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>              <span class="c"># blue line for exact sol.</span>
<span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
<span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">savefig</span></tt> here creates a PNG file whose name reflects the
values of <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> so that we can easily distinguish
files from different runs with <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span>.</p>
<p>A bit more sophisticated and easy-to-read filename can be generated
by mapping the <span class="math">\(\theta\)</span> value to acronyms for the three common
schemes: FE (Forward Euler, <span class="math">\(\theta=0\)</span>), BE (Backward Euler, <span class="math">\(\theta=1\)</span>),
CN (Crank-Nicolson, <span class="math">\(\theta=0.5\)</span>). A Python dictionary is ideal for such
a mapping from numbers to strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
<span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<p>Let us wrap up the computation of the error measure and all the
plotting statements in a function <tt class="docutils literal"><span class="pre">explore</span></tt>. This function
can be called for various <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> values
to see how the error varies with the method and the mesh resolution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a case with the solver, compute error measure,</span>
<span class="sd">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>  <span class="c"># Numerical solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>                         <span class="c"># create new plot</span>
        <span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>       <span class="c"># fine mesh for u_e</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">)</span>           <span class="c"># red dashes w/circles</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>             <span class="c"># blue line for exact sol.</span>
        <span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
        <span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.eps&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">figure()</span></tt> call is key here: without it, a new <tt class="docutils literal"><span class="pre">plot</span></tt> command will
draw the new pair of curves in the same plot window, while we want
the different pairs to appear in separate windows and files.
Calling <tt class="docutils literal"><span class="pre">figure()</span></tt> ensures this.</p>
<p>The complete code resides in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_mpl.py">dc_plot_mpl.py</a>.
Running this program results in</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_plot_mpl.py</span>
<span class="go">0.0   0.40:    2.105E-01</span>
<span class="go">0.0   0.04:    1.449E-02</span>
<span class="go">0.5   0.40:    3.362E-02</span>
<span class="go">0.5   0.04:    1.887E-04</span>
<span class="go">1.0   0.40:    1.030E-01</span>
<span class="go">1.0   0.04:    1.382E-02</span>
</pre></div>
</div>
<p>We observe that reducing <span class="math">\(\Delta t\)</span> by a factor of 10 increases the
accuracy for all three methods (<span class="math">\(\theta\)</span> values). We also see that
the combination of <span class="math">\(\theta=0.5\)</span> and a small time step <span class="math">\(\Delta t =0.04\)</span>
gives a much more accurate solution, and that <span class="math">\(\theta=0\)</span> and <span class="math">\(\theta=0\)</span>
with <span class="math">\(\Delta t = 0.4\)</span> result in the least accurate solutions.</p>
<p>Figure <a class="reference internal" href="#decay-fig-fe1"><em>The Forward Euler scheme for two values of the time step</em></a> demonstrates that the numerical solution for
<span class="math">\(\Delta t=0.4\)</span> clearly lies below the exact curve, but that the
accuracy improves considerably by using 1/10 of this time step.</p>
<div class="figure" id="decay-fig-fe1">
<img alt="_images/FE1.png" src="_images/FE1.png" style="width: 600px;" />
<p class="caption"><em>The Forward Euler scheme for two values of the time step</em></p>
</div>
<p>Mounting two PNG files, as done in the figure, is easily done by the
<a class="reference external" href="http://www.imagemagick.org/script/montage.php">montage</a> program
from the ImageMagick suite:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; montage -background white -geometry 100% -tile 2x1 \</span>
<span class="go">          FE_0.4.png FE_0.04.png FE1.png</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">-geometry</span></tt> argument is used to specify the size of the image, and here
we preserve the individual sizes of the images. The <tt class="docutils literal"><span class="pre">-tile</span> <span class="pre">HxV</span></tt> option
specifies <tt class="docutils literal"><span class="pre">H</span></tt> images in the horizontal direction and <tt class="docutils literal"><span class="pre">V</span></tt> images in
the vertical direction. A series of image files to be combined are then listed,
with the name of the resulting combined image, here <tt class="docutils literal"><span class="pre">FE1.png</span></tt> at the end.</p>
<p>For LaTeX{} reports it is not recommended to use <tt class="docutils literal"><span class="pre">montage</span></tt> and PNG files
as the result has too low resolution. Instead, plots should be made
in the PDF format and combined using the <tt class="docutils literal"><span class="pre">pdftk</span></tt> and <tt class="docutils literal"><span class="pre">pdfnup</span></tt> tools
(on Linux/Unix):</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; pdftk FE_0.4.png FE_0.04.png output tmp.pdf</span>
<span class="go">Terminal&gt; pdfnup --nup 2x1 tmp.pdf  # output in tmp-nup.pdf</span>
<span class="go">Terminal&gt; mv tmp-nup.pdf FE1.png</span>
</pre></div>
</div>
<p>The behavior of the two other schemes is shown in Figures <a class="reference internal" href="#decay-fig-be1"><em>The Backward Euler scheme for two values of the time step</em></a>
and <a class="reference internal" href="#decay-fig-cn1"><em>The Crank-Nicolson scheme for two values of the time step</em></a>. Crank-Nicolson is obviously the most accurate
scheme from this visual point of view.</p>
<div class="figure" id="decay-fig-be1">
<img alt="_images/BE1.png" src="_images/BE1.png" style="width: 600px;" />
<p class="caption"><em>The Backward Euler scheme for two values of the time step</em></p>
</div>
<div class="figure" id="decay-fig-cn1">
<img alt="_images/CN1.png" src="_images/CN1.png" style="width: 600px;" />
<p class="caption"><em>The Crank-Nicolson scheme for two values of the time step</em></p>
</div>
</div>
<div class="section" id="plotting-with-scitools">
<h2>Plotting with SciTools<a class="headerlink" href="#plotting-with-scitools" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://code.google.com/p/scitools">SciTools package</a> provides a
unified plotting interface, called Easyviz, to many different plotting
packages, including Matplotlib. The syntax is very similar to that of
Matplotlib and MATLAB. In fact, the plotting commands shown above look
the same in SciTool&#8217;s Easyviz interface, apart from the import
statement, which reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This statement performs a <tt class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></tt> as well as an import
of the most common pieces of the Easyviz (<tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt>) package,
along with some additional numerical functionality.</p>
<p>With Easyviz one can, using an extended <tt class="docutils literal"><span class="pre">plot</span></tt> command,
merge several plotting commands into one,
using keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">,</span>           <span class="c"># red dashes w/circles</span>
     <span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span>             <span class="c"># blue line for exact sol.</span>
     <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span>
     <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span>
     <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
     <span class="n">title</span><span class="o">=</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">show</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_st.py">dc_plot_st.py</a> file
contains such a demo.</p>
<p>By default, Easyviz employs Matplotlib for plotting, but <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> and <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a> are viable alternatives:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_plot_st.py --SCITOOLS_easyviz_backend gnuplot</span>
<span class="go">Terminal&gt; python dc_plot_st.py --SCITOOLS_easyviz_backend grace</span>
</pre></div>
</div>
<p>The backend used for creating plots (and numerous other options)
can be permanently set in SciTool&#8217;s configuration file.</p>
<p>All the Gnuplot windows are launched without any need to kill one before
the next one pops up (as is the case with Matplotlib) and one can
press the key &#8216;q&#8217; anywhere in a plot window to kill it.
Another advantage of Gnuplot is the automatic choice of sensible
and distinguishable line types in black-and-white PostScript
files (produced by <tt class="docutils literal"><span class="pre">savefig('myplot.eps')</span></tt>).</p>
<p>Regarding functionality for annotating plots with title, labels on the
axis, legends, etc., we refer to the documentation of Matplotlib and
SciTools for more detailed information on the syntax. The hope is that
the programming syntax explained so far suffices for understanding the
code and learning more from a combination of the forthcoming examples
and other resources such as books and web pages.</p>
</div>
<div class="section" id="creating-user-interfaces">
<h2>Creating user interfaces<a class="headerlink" href="#creating-user-interfaces" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-16"></span><p id="index-17">It is good programming practice to let programs read input from the user
rather than require the user to edit the source code when trying out
new values of input parameters.
Reading input from the command line is a simple and flexible way of interacting
with the user. Python stores all the command-line arguments in
the list <tt class="docutils literal"><span class="pre">sys.argv</span></tt>, and there are, in principle, two ways of programming with
command-line arguments in Python:</p>
<blockquote>
<div><ul class="simple">
<li>Decide upon a sequence of parameters on the command line and read
their values directly from the <tt class="docutils literal"><span class="pre">sys.argv</span></tt> list (<tt class="docutils literal"><span class="pre">sys.argv[0]</span></tt> is
the just program name).</li>
<li>Use option-value pairs (<tt class="docutils literal"><span class="pre">--option</span> <span class="pre">value</span></tt>) on
the command line to override default values of input parameters,
and use the <tt class="docutils literal"><span class="pre">argparse.ArgumentParser</span></tt> tool to interact with the command line.</li>
</ul>
</div></blockquote>
<p>Both strategies will be illustrated next.</p>
<div class="section" id="reading-a-sequence-of-command-line-arguments">
<h3>Reading a sequence of command-line arguments<a class="headerlink" href="#reading-a-sequence-of-command-line-arguments" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_mpl.py">dc_plot_mpl.py</a>
program needs the following input data: <span class="math">\(I\)</span>, <span class="math">\(a\)</span>, <span class="math">\(T\)</span>, an option to
turn the plot on or off (<tt class="docutils literal"><span class="pre">makeplot</span></tt>), and a list of <span class="math">\(\Delta t\)</span> values.</p>
<p>The simplest way of reading this input from the command line is to say
that the first four command-line arguments correspond to the first
four points in the list above, in that order, and that the rest of the
command-line arguments are the <span class="math">\(\Delta t\)</span> values.  The input given for
<tt class="docutils literal"><span class="pre">makeplot</span></tt> can be a string among <tt class="docutils literal"><span class="pre">'on'</span></tt>, <tt class="docutils literal"><span class="pre">'off'</span></tt>, <tt class="docutils literal"><span class="pre">'True'</span></tt>, and
<tt class="docutils literal"><span class="pre">'False'</span></tt>. The code for reading this input is most conveniently put in
a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">read_command_line</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Usage: </span><span class="si">%s</span><span class="s"> I a T on/off dt1 dt2 dt3 ...&#39;</span> <span class="o">%</span> \
              <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>

    <span class="n">I</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">makeplot</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">,</span> <span class="s">&#39;True&#39;</span><span class="p">)</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">5</span><span class="p">:]]</span>

    <span class="k">return</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span>
</pre></div>
</div>
<span class="target" id="index-19"></span><p id="index-20">One should note the following about the constructions in the program above:</p>
<blockquote>
<div><ul class="simple">
<li>Everything on the command line ends up in a <em>string</em> in
the list <tt class="docutils literal"><span class="pre">sys.argv</span></tt>. Explicit conversion to, e.g., a <tt class="docutils literal"><span class="pre">float</span></tt> object is
required if the string as a number we want to compute with.</li>
<li>The value of <tt class="docutils literal"><span class="pre">makeplot</span></tt> is determined from a boolean expression,
which becomes <tt class="docutils literal"><span class="pre">True</span></tt> if the command-line argument is either <tt class="docutils literal"><span class="pre">'on'</span></tt> or
<tt class="docutils literal"><span class="pre">'True'</span></tt>, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</li>
<li>It is easy to build the list of <span class="math">\(\Delta t\)</span> values: we simply run through
the rest of the list, <tt class="docutils literal"><span class="pre">sys.argv</span></tt>, convert each command-line argument
to <tt class="docutils literal"><span class="pre">float</span></tt>, and collect these <tt class="docutils literal"><span class="pre">float</span></tt> objects in a list, using the
compact and convenient <em>list comprehension</em> syntax in Python.</li>
</ul>
</div></blockquote>
<p>The loops over <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> values can be coded in a <tt class="docutils literal"><span class="pre">main</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="si">%3.1f</span><span class="s"> </span><span class="si">%6.2f</span><span class="s">: </span><span class="si">%12.3E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete program can be found in <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_cml.py">dc_cml.py</a>.</p>
</div>
<div class="section" id="working-with-an-argument-parser">
<h3>Working with an argument parser<a class="headerlink" href="#working-with-an-argument-parser" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><p id="index-24">Python&#8217;s <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> tool in the <tt class="docutils literal"><span class="pre">argparse</span></tt> module makes it
easy to create a professional command-line interface to any
program. The <cite>documentation of `ArgumentParser</cite> &lt;<a class="reference external" href="http://docs.python.org/library/argparse.html">http://docs.python.org/library/argparse.html</a>&gt;`_ demonstrates its
versatile applications, so we shall here just list an example
containing the most used features.  On the command line we want to
specify option value pairs for <span class="math">\(I\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(T\)</span>, e.g., <tt class="docutils literal"><span class="pre">--a</span> <span class="pre">3.5</span> <span class="pre">--I</span> <span class="pre">2</span>
<span class="pre">--T</span> <span class="pre">2</span></tt>. Including <tt class="docutils literal"><span class="pre">--makeplot</span></tt> turns the plot on and excluding this
option turns the plot off.  The <span class="math">\(\Delta t\)</span> values can be given as
<tt class="docutils literal"><span class="pre">--dt</span> <span class="pre">1</span> <span class="pre">0.5</span> <span class="pre">0.25</span> <span class="pre">0.1</span> <span class="pre">0.01</span></tt>.  Each parameter must have a sensible
default value so that we specify the option on the command line only
when the default value is not suitable.</p>
<p>We introduce a function for defining the mentioned command-line options:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">define_command_line_options</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="s">&#39;--initial_condition&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;initial condition, u(0)&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;I&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--a&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;coefficient in ODE&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--T&#39;</span><span class="p">,</span> <span class="s">&#39;--stop_time&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;end time of simulation&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--makeplot&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s">&#39;display plot or not&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="s">&#39;--time_step_values&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;time step values&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;dt&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;dt_values&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span>
</pre></div>
</div>
<p>Each command-line option is defined through the <tt class="docutils literal"><span class="pre">parser.add_argument</span></tt>
method. Alternative options, like the short <tt class="docutils literal"><span class="pre">--I</span></tt> and the more
explaining version <tt class="docutils literal"><span class="pre">--initial_condition</span></tt> can be defined. Other arguments
are <tt class="docutils literal"><span class="pre">type</span></tt> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <tt class="docutils literal"><span class="pre">-h</span></tt> or <tt class="docutils literal"><span class="pre">--help</span></tt> is
included. The <tt class="docutils literal"><span class="pre">metavar</span></tt> argument specifies the value associated with
the option when the help string is printed. For example, the option for
<span class="math">\(I\)</span> has this help output:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_argparse.py -h</span>
<span class="go">  ...</span>
<span class="go">  --I I, --initial_condition I</span>
<span class="go">                        initial condition, u(0)</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>The structure of this output is</p>
<div class="highlight-py"><div class="highlight"><pre><span class="o">--</span><span class="n">I</span> <span class="n">metavar</span><span class="p">,</span> <span class="o">--</span><span class="n">initial_condition</span> <span class="n">metavar</span>
                      <span class="n">help</span><span class="o">-</span><span class="n">string</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">--makeplot</span></tt> option is a pure flag without any value, implying a
true value if the flag is present and otherwise a false value. The
<tt class="docutils literal"><span class="pre">action='store_true'</span></tt> makes an option for such a flag.</p>
<p>Finally, the <tt class="docutils literal"><span class="pre">--dt</span></tt> option demonstrates how to allow for more than one
value (separated by blanks) through the <tt class="docutils literal"><span class="pre">nargs='+'</span></tt> keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the <tt class="docutils literal"><span class="pre">dist</span></tt> keyword argument, which for the <tt class="docutils literal"><span class="pre">--dt</span></tt> option reads
<tt class="docutils literal"><span class="pre">dt_values</span></tt>. Without the <tt class="docutils literal"><span class="pre">dest</span></tt> argument, the value of option <tt class="docutils literal"><span class="pre">--opt</span></tt>
is stored as the attribute <tt class="docutils literal"><span class="pre">opt</span></tt>.</p>
<p>The code below demonstrates how to read the command line and extract
the values for each option:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_command_line</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">define_command_line_options</span><span class="p">()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;I={}, a={}, T={}, makeplot={}, dt_values={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">makeplot</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">dt_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">makeplot</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">dt_values</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">main</span></tt> function remains the same as in the <tt class="docutils literal"><span class="pre">dc_cml.py</span></tt> code based
on reading from <tt class="docutils literal"><span class="pre">sys.argv</span></tt> directly. A complete program using the
demo above of <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> appears in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_argparse.py">dc_argparse.py</a>.</p>
</div>
</div>
<div class="section" id="computing-convergence-rates">
<span id="decay-convergence-rate"></span><h2>Computing convergence rates<a class="headerlink" href="#computing-convergence-rates" title="Permalink to this headline">¶</a></h2>
<p id="index-25">We normally expect that the error <span class="math">\(E\)</span> in the numerical solution is
reduced if the mesh size <span class="math">\(\Delta t\)</span> is decreased. More specifically,
many numerical methods obey a power-law relation between <span class="math">\(E\)</span> and
<span class="math">\(\Delta t\)</span>:</p>
<div class="math" id="equation-decay:E:dt">
<span class="eqno">(26)</span>\[     E = C\Delta t^r,\]</div>
<p>where <span class="math">\(C\)</span> and <span class="math">\(r\)</span> are (usually unknown) constants independent of <span class="math">\(\Delta t\)</span>.
The formula <a href="#equation-decay:E:dt">(26)</a> is viewed as an asymptotic model valid for
sufficiently small <span class="math">\(\Delta t\)</span>. How small is normally hard to estimate
without doing numerical estimations of <span class="math">\(r\)</span>.</p>
<p>The parameter <span class="math">\(r\)</span> is known as the <em>convergence rate</em>. For example,
if the convergence rate is 2, halving <span class="math">\(\Delta t\)</span> reduces the error by
a factor of 4. Diminishing <span class="math">\(\Delta t\)</span> then has a greater impact on
the error compared with methods that have <span class="math">\(r=1\)</span>. For a given value of <span class="math">\(r\)</span>,
we refer to the method as of <span class="math">\(r\)</span>-th order. First- and second-order
methods are most common in scientific computing.</p>
<div class="section" id="estimating">
<h3>Estimating <span class="math">\(r\)</span><a class="headerlink" href="#estimating" title="Permalink to this headline">¶</a></h3>
<p>There are two ways of estimating <span class="math">\(C\)</span> and <span class="math">\(r\)</span> based on a set of
<span class="math">\(m\)</span> simulations with corresponding pairs <span class="math">\((\Delta t_i, E_i)\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>,
and <span class="math">\(\Delta t_{i} &lt; \Delta t_{i-1}\)</span> (i.e., decreasing cell size).</p>
<blockquote>
<div><ol class="arabic simple">
<li>Take the logarithm of <a href="#equation-decay:E:dt">(26)</a>, <span class="math">\(\ln E = r\ln \Delta t + \ln C\)</span>,
and fit a straight line to the data points <span class="math">\((\Delta t_i, E_i)\)</span>,
<span class="math">\(i=0,\ldots,m-1\)</span>.</li>
<li>Consider two consecutive experiments, <span class="math">\((\Delta t_i, E_i)\)</span> and
<span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span>. Dividing the equation
<span class="math">\(E_{i-1}=C\Delta t_{i-1}^r\)</span> by <span class="math">\(E_{i}=C\Delta t_{i}^r\)</span> and solving
for <span class="math">\(r\)</span> yields</li>
</ol>
</div></blockquote>
<div class="math" id="equation-decay:conv:rate">
<span class="eqno">(27)</span>\[     r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}\]</div>
<p>for <span class="math">\(i=1,=\ldots,m-1\)</span>.</p>
<p>The disadvantage of method 1 is that <a href="#equation-decay:E:dt">(26)</a> might not be valid
for the coarsest meshes (largest <span class="math">\(\Delta t\)</span> values), and fitting a line
to all the data points is then misleading.  Method 2 computes
convergence rates for pairs of experiments and allows us to see
if the sequence <span class="math">\(r_i\)</span> converges to some value as <span class="math">\(i\rightarrow m-2\)</span>.
The final <span class="math">\(r_{m-2}\)</span> can then be taken as the convergence rate.
If the coarsest meshes have a differing rate, the corresponding
time steps are probably too large for <a href="#equation-decay:E:dt">(26)</a> to be valid.
That is, those time steps lie outside the asymptotic range of
<span class="math">\(\Delta t\)</span> values where the error behave like <a href="#equation-decay:E:dt">(26)</a>.</p>
</div>
<div class="section" id="id3">
<h3>Implementation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>It is straightforward to extend the <tt class="docutils literal"><span class="pre">main</span></tt> function in the program
<tt class="docutils literal"><span class="pre">dc_argparse.py</span></tt> with statements for computing <span class="math">\(r_0, r_1, \ldots, r_{m-2}\)</span>
from <a href="#equation-decay:E:dt">(26)</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># estimated convergence rates</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

        <span class="c"># Compute convergence rates</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_values</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
                    <span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Pairwise convergence rates for theta=</span><span class="si">%g</span><span class="s">:&#39;</span> <span class="o">%</span> <span class="n">theta</span>
        <span class="k">print</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_</span> <span class="k">for</span> <span class="n">r_</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>The program is called <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_convrate.py">dc_convrate.py</a>.</p>
<p id="index-26">The <tt class="docutils literal"><span class="pre">r</span></tt> object is a <em>dictionary of lists</em>. The keys in this
dictionary are the <span class="math">\(\theta\)</span> values. For example,
<tt class="docutils literal"><span class="pre">r[1]</span></tt> holds the list of the <span class="math">\(r_i\)</span> values corresponding to
<span class="math">\(\theta=1\)</span>. In the loop <tt class="docutils literal"><span class="pre">for</span> <span class="pre">theta</span> <span class="pre">in</span> <span class="pre">r</span></tt>, the loop variable <tt class="docutils literal"><span class="pre">theta</span></tt>
takes on the values of the keys in the dictionary <tt class="docutils literal"><span class="pre">r</span></tt> (in an
undetermined ordering). We could simply do a <tt class="docutils literal"><span class="pre">print</span> <span class="pre">r[theta]</span></tt>
inside the loop, but this would typically yield output of
the convergence rates with 16 decimals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mf">1.331919482274763</span><span class="p">,</span> <span class="mf">1.1488178494691532</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Instead, we format each number with 2 decimals, using a list
comprehension to turn the list of numbers, <tt class="docutils literal"><span class="pre">r[theta]</span></tt>, into
a list of formatted strings. Then we join these strings
with a space in between to get a sequence of rates on one line
in the terminal window. More generally, <tt class="docutils literal"><span class="pre">d.join(list)</span></tt> joins the
strings in the list <tt class="docutils literal"><span class="pre">list</span></tt> to one string, with <tt class="docutils literal"><span class="pre">d</span></tt>
as delimiter between <tt class="docutils literal"><span class="pre">list[0]</span></tt>, <tt class="docutils literal"><span class="pre">list[1]</span></tt>, etc.</p>
<p>Here is an example on the outcome of the convergence rate computations:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_convrate.py --dt 0.5 0.25 0.1 0.05 0.025 0.01</span>
<span class="go">...</span>
<span class="go">Pairwise convergence rates for theta=0:</span>
<span class="go">1.33 1.15 1.07 1.03 1.02</span>

<span class="go">Pairwise convergence rates for theta=0.5:</span>
<span class="go">2.14 2.07 2.03 2.01 2.01</span>

<span class="go">Pairwise convergence rates for theta=1:</span>
<span class="go">0.98 0.99 0.99 1.00 1.00</span>
</pre></div>
</div>
<p>The Forward and Backward Euler methods seem to have an <span class="math">\(r\)</span> value which
stabilizes at 1, while the Crank-Nicolson seems to be a second-order
method with <span class="math">\(r=2\)</span>.</p>
<p id="index-27">Very often, we have some theory that predicts what <span class="math">\(r\)</span> is for a numerical
method. Various theoretical error measures for the <span class="math">\(\theta\)</span>-rule point to
<span class="math">\(r=2\)</span> for <span class="math">\(\theta =0.5\)</span> and <span class="math">\(r=1\)</span> otherwise. The computed estimates of <span class="math">\(r\)</span> are
in very good agreement with these theoretical values.</p>
<p>The strong practical application of computing convergence rates is for
verification: wrong convergence rates point to errors in the code, and
correct convergence rates brings evidence that the implementation is
correct. Experience shows that bugs in the code easily destroys the
expected convergence rate.</p>
</div>
<div class="section" id="debugging-via-convergence-rates">
<h3>Debugging via convergence rates<a class="headerlink" href="#debugging-via-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>Let us experiment with bugs and see the implication on the convergence
rate. We may, for instance, forget to multiply by <tt class="docutils literal"><span class="pre">a</span></tt> in the denominator
in the updating formula for <tt class="docutils literal"><span class="pre">u[n+1]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>Running the same <tt class="docutils literal"><span class="pre">dc_convrate.py</span></tt> command as above gives the expected
convergence rates (!). Why? The reason is that we just specified
the <span class="math">\(\Delta t\)</span> values are relied on default values for other
parameters. The default value of <span class="math">\(a\)</span> is 1. Forgetting the factor
<tt class="docutils literal"><span class="pre">a</span></tt> has then no effect. This example shows how importance it is to
avoid parameters that are 1 or 0 when verifying implementations.
Running the code <tt class="docutils literal"><span class="pre">dc_v0.py</span></tt> with <span class="math">\(a=2.1\)</span> and <span class="math">\(I=0.1\)</span> yields</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_convrate.py --a 2.1 --I 0.1  \</span>
<span class="go">          --dt 0.5 0.25 0.1 0.05 0.025 0.01</span>
<span class="go">...</span>
<span class="go">Pairwise convergence rates for theta=0:</span>
<span class="go">1.49 1.18 1.07 1.04 1.02</span>

<span class="go">Pairwise convergence rates for theta=0.5:</span>
<span class="go">-1.42 -0.22 -0.07 -0.03 -0.01</span>

<span class="go">Pairwise convergence rates for theta=1:</span>
<span class="go">0.21 0.12 0.06 0.03 0.01</span>
</pre></div>
</div>
<p>This time we see that the expected convergence rates for the Crank-Nicolson and
Backward Euler methods are not obtained, while <span class="math">\(r=1\)</span> for the Forward Euler
method. The reason for correct rate in the latter case is that <span class="math">\(\theta=0\)</span>
and the wrong <tt class="docutils literal"><span class="pre">theta*dt</span></tt> term in the denominator vanishes anyway.</p>
<p>The error</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>manifests itself through wrong rates <span class="math">\(r\approx 0\)</span> for all three methods.
About the same results arise from an erroneous initial condition, <tt class="docutils literal"><span class="pre">u[0]</span> <span class="pre">=</span> <span class="pre">1</span></tt>,
or wrong loop limits, <tt class="docutils literal"><span class="pre">range(1,N)</span></tt>. It seems that in this simple
problem, most bugs we can think of are detected by the convergence rate
test, provided the values of the input data do not hide the bug.</p>
<p>A <tt class="docutils literal"><span class="pre">verify_convergence_rate</span></tt> function could compute the dictionary of
list via <tt class="docutils literal"><span class="pre">main</span></tt> and check if the final rate estimates (<span class="math">\(r_{m-2}\)</span>)
are sufficiently close to the expected ones. A tolerance of 0.1
seems appropriate, given the uncertainty in estimating <span class="math">\(r\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_convergence_rate</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">main</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">expected_rates</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">r_final</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected_rates</span><span class="p">[</span><span class="n">theta</span><span class="p">]</span> <span class="o">-</span> <span class="n">r_final</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>  <span class="c"># all tests passed</span>
</pre></div>
</div>
<p>We remark that <tt class="docutils literal"><span class="pre">r[theta]</span></tt> is a list and the last element in any list
can be extracted by the index <tt class="docutils literal"><span class="pre">-1</span></tt>.</p>
</div>
</div>
<div class="section" id="memory-saving-implementation">
<h2>Memory-saving implementation<a class="headerlink" href="#memory-saving-implementation" title="Permalink to this headline">¶</a></h2>
<p>The memory storage requirements of our implementations so far consists
mainly of the <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> arrays, both of length <span class="math">\(N+1\)</span>, plus some other
temporary arrays that Python needs for intermediate results if we do
array arithmetics in our program (e.g., <tt class="docutils literal"><span class="pre">I*exp(-a*t)</span></tt> needs to store
<tt class="docutils literal"><span class="pre">a*t</span></tt> before <tt class="docutils literal"><span class="pre">-</span></tt> can be applied to it and then <tt class="docutils literal"><span class="pre">exp</span></tt>).  The
extremely modest storage requirements of simple ODE problems put no
restrictions on the formulations of the algorithm and implementation.
Nevertheless, when the methods for ODEs used here are applied to
three-dimensional partial differential equation (PDE) problems,
memory storage requirements
suddenly become an issue.</p>
<p>The PDE counterpart to our model problem
<span class="math">\(u'=-a\)</span> is a diffusion equation <span class="math">\(u_t = a\nabla^2 u\)</span> posed on a
space-time domain. The discrete representation of this domain may in
3D be a spatial mesh of <span class="math">\(M^3\)</span> points and a time mesh of <span class="math">\(N\)</span> points. A
typical desired value for <span class="math">\(M\)</span> is 100 in many applications, or even
<span class="math">\(1000\)</span>.  Storing all the computed <span class="math">\(u\)</span> values, like we have done in the
programs so far, demands storage of some arrays of size <span class="math">\(M^3N\)</span>, giving
a factor of <span class="math">\(M^3\)</span> larger storage demands compared to our ODE
programs. Each real number in the array for <span class="math">\(u\)</span> requires 8 bytes of
storage, resulting in a demand for 8 Gb of memory for only one array.
In such cases one needs good ideas on how to lower the storage
requirements. Fortunately, we can usually get rid of the <span class="math">\(M^3\)</span>
factor. Below we explain how this is done, and the technique is almost
always applied in implementations of PDE problems.</p>
<p>Let us critically evaluate how much we really need to store in the
computer&#8217;s memory in our implementation of the <span class="math">\(\theta\)</span> method. To
compute a new <span class="math">\(u^{n+1}\)</span>, all we need is <span class="math">\(u^n\)</span>. This implies that the
previous <span class="math">\(u^{n-1},u^{n-2},\dots,u^0\)</span> values do not need to be stored
in an array, although this is convenient for plotting and data
analysis in the program.  Instead of the <tt class="docutils literal"><span class="pre">u</span></tt> array we can work with
two variables for real numbers, <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">u_1</span></tt>, representing
<span class="math">\(u^{n+1}\)</span> and <span class="math">\(u^n\)</span> in the algorithm, respectively.  At each time
level, we update <tt class="docutils literal"><span class="pre">u</span></tt> from <tt class="docutils literal"><span class="pre">u_1</span></tt> and then set <tt class="docutils literal"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">u</span></tt> so that the
computed <span class="math">\(u^{n+1}\)</span> value becomes the &#8220;previous&#8221; value <span class="math">\(u^n\)</span> at the
next time level. The downside is that we cannot plot the solution
after the simulation is done since only the last two numbers are
available.  The remedy is to store computed values in a file and use
the file for visualizing the solution later.</p>
<p>We have implemented this memory saving idea in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_memsave.py">dc_memsave.py</a>, which is a
merge of the <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_mpl.py">dc_plot_mpl.py</a> and
<a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_argparse.py">dc_argparse.py</a>
programs, using module prefixes <tt class="docutils literal"><span class="pre">np</span></tt> for <tt class="docutils literal"><span class="pre">numpy</span></tt> and <tt class="docutils literal"><span class="pre">plt</span></tt> for
<tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt>.</p>
<p>The following function implements the ideas above regarding minimizing
memory usage and storing the solution on file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span class="sd">    Minimum use of memory. The solution is store on file</span>
<span class="sd">    (with name filename) for later plotting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>        <span class="c"># avoid integer division</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>  <span class="c"># no of intervals</span>

    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="c"># u: time level n+1, u_1: time level n</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.16E</span><span class="s">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u_1</span>
        <span class="n">u_1</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.16E</span><span class="s">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>This code snippet serves as a quick introduction to file writing in Python.
Reading the data in the file into arrays <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> are done by the
function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[];</span>  <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Found more than two numbers on a line!&#39;</span><span class="p">,</span> <span class="n">words</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>This type of file with numbers in rows and columns is very common, and <tt class="docutils literal"><span class="pre">numpy</span></tt>
has a function <tt class="docutils literal"><span class="pre">loadtxt</span></tt> which loads such tabular data into a two-dimensional
array, say <tt class="docutils literal"><span class="pre">data</span></tt>. The number in row <tt class="docutils literal"><span class="pre">i</span></tt> and column <tt class="docutils literal"><span class="pre">j</span></tt> is then <tt class="docutils literal"><span class="pre">data[i,j]</span></tt>.
The whole column number <tt class="docutils literal"><span class="pre">j</span></tt> can be extracted by <tt class="docutils literal"><span class="pre">data[:,j]</span></tt>.
A version of <tt class="docutils literal"><span class="pre">read_file</span></tt> using <tt class="docutils literal"><span class="pre">np.loadtxt</span></tt> reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file_numpy</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
<p>The present counterpart to the <tt class="docutils literal"><span class="pre">explore</span></tt> function from
<a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_plot_mpl.py">dc_plot_mpl.py</a> must run
<tt class="docutils literal"><span class="pre">solver_memsave</span></tt> and then load data from file before we can compute
the error measure and make the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;u.dat&#39;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">t</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_memsave.py">dc_memsave.py</a>
file also includes command-line options <tt class="docutils literal"><span class="pre">--I</span></tt>, <tt class="docutils literal"><span class="pre">--a</span></tt>, <tt class="docutils literal"><span class="pre">--T</span></tt>, <tt class="docutils literal"><span class="pre">--dt</span></tt>,
<tt class="docutils literal"><span class="pre">--theta</span></tt>, and <tt class="docutils literal"><span class="pre">--makeplot</span></tt> for controlling input parameters and
making a single run.  For example,</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_memsave.py --T 10 --theta 1 --dt 2</span>
<span class="go">I=1.0, a=1.0, T=10.0, makeplot=True, theta=1.0, dt=2.0</span>
<span class="go">theta=1.0 dt=2 Error=3.136E-01</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="software-engineering">
<h1>Software engineering<a class="headerlink" href="#software-engineering" title="Permalink to this headline">¶</a></h1>
<p>Efficient use of differential equation models requires software that is easy to
test and flexible for setting up extensive numerical experiments.
This section introduces three important concepts and their applications
to the exponential decay model:</p>
<blockquote>
<div><ul class="simple">
<li>Modules</li>
<li>Testing frameworks</li>
<li>Implementation with classes</li>
</ul>
</div></blockquote>
<div class="section" id="making-a-module">
<h2>Making a module<a class="headerlink" href="#making-a-module" title="Permalink to this headline">¶</a></h2>
<p id="index-28">The previous sections has outlined numerous different programs, all of
them having their own copy of the <tt class="docutils literal"><span class="pre">solver</span></tt> function.  Such copies
of the same piece of code is against the important <em>Don&#8217;t Repeat
Yourself</em> (DRY) principle in programming.  If we want to change the
<tt class="docutils literal"><span class="pre">solver</span></tt> function there should be one and only one place where the
change needs to be performed.</p>
<p>To clean up the repetitive code snippets scattered among the
<tt class="docutils literal"><span class="pre">dc_*.py</span></tt> files, we start by collecting the
various functions we want to keep for the future in one file,
now called <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/dc_mod.py">dc_mod.py</a>.
The following functions are copied to this file:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">solver</span></tt></li>
<li><tt class="docutils literal"><span class="pre">verify_three_steps</span></tt></li>
<li><tt class="docutils literal"><span class="pre">verify_discrete_solution</span></tt></li>
<li><tt class="docutils literal"><span class="pre">explore</span></tt></li>
<li><tt class="docutils literal"><span class="pre">define_command_line_options</span></tt></li>
<li><tt class="docutils literal"><span class="pre">read_command_line</span></tt> extended to work both with <tt class="docutils literal"><span class="pre">sys.argv</span></tt> directly
and with an <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> object</li>
<li><tt class="docutils literal"><span class="pre">main</span></tt> (with convergence rates estimation as in <tt class="docutils literal"><span class="pre">dc_convrate.py</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">verify_convergence_rate</span></tt></li>
</ul>
</div></blockquote>
<p>We use Matplotlib for plotting. A sketch of the <tt class="docutils literal"><span class="pre">dc_mod.py</span></tt>
file, with complete versions of the modified functions, looks as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">verify_three_steps</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">verify_exact_discrete_solution</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">define_command_line_options</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">read_command_line</span><span class="p">(</span><span class="n">use_argparse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">use_argparse</span><span class="p">:</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">define_command_line_options</span><span class="p">()</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&#39;I={}, a={}, makeplot={}, dt_values={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">makeplot</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">dt_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">makeplot</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">dt_values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Usage: </span><span class="si">%s</span><span class="s"> I a on/off dt1 dt2 dt3 ...&#39;</span> <span class="o">%</span> \
                  <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">I</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">T</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">makeplot</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">,</span> <span class="s">&#39;True&#39;</span><span class="p">)</span>
        <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">5</span><span class="p">:]]</span>

        <span class="k">return</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">dc_mod.py</span></tt> file is already a module such that we can import
desired in functions in other programs. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decay_theta</span> <span class="kn">import</span> <span class="n">solver</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-29">However, it should also be possible to both use <tt class="docutils literal"><span class="pre">dc_mod.py</span></tt> as
a module <em>and</em> execute the file as a program that runs <tt class="docutils literal"><span class="pre">main()</span></tt>. This is
accomplished by ending the file with a <em>test block</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">dc_mod.py</span></tt> is used as a module, <tt class="docutils literal"><span class="pre">__name__</span></tt> equals the module
name <tt class="docutils literal"><span class="pre">decay_theta</span></tt>, while <tt class="docutils literal"><span class="pre">__name__</span></tt> equals <tt class="docutils literal"><span class="pre">'__main__'</span></tt> when the
file is run as a program.
Optionally, we could run the verification tests if the word <tt class="docutils literal"><span class="pre">verify</span></tt>
is present on the command line and <tt class="docutils literal"><span class="pre">verify_convergence_rate</span></tt> could
be tested if <tt class="docutils literal"><span class="pre">verify_rates</span></tt> is found on the command line. The
<tt class="docutils literal"><span class="pre">verify_rates</span></tt> argument must be removed before we read parameter values from
the command line, other wise <tt class="docutils literal"><span class="pre">read_command_line</span></tt> (called by <tt class="docutils literal"><span class="pre">main</span></tt>)
will not work properly.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="s">&#39;verify&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verify_three_steps</span><span class="p">()</span> <span class="ow">and</span> <span class="n">verify_discrete_solution</span><span class="p">():</span>
            <span class="k">pass</span> <span class="c"># ok</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Bug in the implementation!&#39;</span>
    <span class="k">elif</span> <span class="s">&#39;verify_rates&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;verify_rates&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;--dt&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Must assign several dt values&#39;</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>
        <span class="k">if</span> <span class="n">verify_convergence_rate</span><span class="p">():</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Bug in the implementation!&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Perform simulations</span>
        <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="prefixing-imported-functions-by-the-module-name">
<h2>Prefixing imported functions by the module name<a class="headerlink" href="#prefixing-imported-functions-by-the-module-name" title="Permalink to this headline">¶</a></h2>
<p id="index-30">Import statements of the form <tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></tt> imports
functions and variables in <tt class="docutils literal"><span class="pre">module.py</span></tt> into the current file.
For example, when doing</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>we get mathematical functions like <tt class="docutils literal"><span class="pre">sin</span></tt> and <tt class="docutils literal"><span class="pre">exp</span></tt>
as well as MATLAB-style functions like <tt class="docutils literal"><span class="pre">linspace</span></tt> and <tt class="docutils literal"><span class="pre">plot</span></tt>,
which can be called by these well-known names.
However, it sometimes becomes confusing to
know where a particular function comes from. Is it from <tt class="docutils literal"><span class="pre">numpy</span></tt>? Or
<tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt>?
Or is it our own function?</p>
<p>An alternative import is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>
</pre></div>
</div>
<p>and such imports require functions to be prefixed by the module name, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_e</span><span class="p">)</span>
</pre></div>
</div>
<p>This is normally regarded as a better habit because it is explicitly stated
from which module a function comes from.</p>
<p>The modules <tt class="docutils literal"><span class="pre">numpy</span></tt> and <tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt> are so frequently used,
and their full names quite tedious to write, so two standard abbreviations
have evolved in the Python scientific computing community:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_e</span><span class="p">)</span>
</pre></div>
</div>
<p>A version of the <tt class="docutils literal"><span class="pre">decay_theta</span></tt> module where we use the <tt class="docutils literal"><span class="pre">np</span></tt> and <tt class="docutils literal"><span class="pre">plt</span></tt>
prefixes is found in the file
<a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/decay_theta_v2.py">decay_theta_v2.py</a>.</p>
<p>The downside of prefixing functions by the module name is that
mathematical expressions like <span class="math">\(e^{-at}\sin(2\pi t)\)</span> gets
cluttered with module names,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Such an expression looks like <tt class="docutils literal"><span class="pre">exp(-a*t)*sin(2*pi*t)</span></tt> in most
other programming languages. Similarly,
<tt class="docutils literal"><span class="pre">np.linspace</span></tt> and <tt class="docutils literal"><span class="pre">plt.plot</span></tt> look less familiar to people who are
used to MATLAB and who have not adopted Python&#8217;s prefix style.
Whether to do <tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></tt> or <tt class="docutils literal"><span class="pre">import</span> <span class="pre">module</span></tt> depends
on personal taste and the problem at hand. In these writings we use
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span></tt> in shorter programs where similarity with
MATLAB could be an advantage, and where a one-to-one correspondence between
mathematical formulas and Python expressions is important.
The style <tt class="docutils literal"><span class="pre">import</span> <span class="pre">module</span></tt> is preferred inside Python modules (see
<a class="reference internal" href="#decay-exer-module1"><em>Exercise 9: Make a module</em></a> for a demonstration).</p>
</div>
<div class="section" id="doctests">
<h2>Doctests<a class="headerlink" href="#doctests" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-31"></span><p id="index-32">We have emphasized how important it is to be able to run tests in the
program at any time. This was solved by calling various <tt class="docutils literal"><span class="pre">verify*</span></tt>
functions in the previous examples. However, there exists
well-established procedures and corresponding tools for automating
checking of tests. We shall briefly demonstrate two important
techniques: <em>doctest</em> and <em>unit testing</em>. The corresponding files are
the modules <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/dc_mod_doctest.py">dc_mod_doctest.py</a>
and <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/dc_mod_unittest.py">dc_mod_unittest.py</a>.</p>
<p>Doc strings (the first string after the function header) are used to
document the purpose of functions and their arguments. Very often it
is instructive to include an example on how to use the function.
Interactive examples in the Python shell are most illustrative as
we can see the output resulting from function calls. For example,
we can in the <tt class="docutils literal"><span class="pre">solver</span></tt> function include an example on calling
this function and printing the computed <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>


<span class="sd">    &gt;&gt;&gt; u, t = solver(I=0.8, a=1.2, T=4, dt=0.5, theta=0.5)</span>
<span class="sd">    &gt;&gt;&gt; for t_n, u_n in zip(t, u):</span>
<span class="sd">    ...     print &#39;t=%.1f, u=%.14f&#39; % (t_n, u_n)</span>
<span class="sd">    t=0.0, u=0.80000000000000</span>
<span class="sd">    t=0.5, u=0.43076923076923</span>
<span class="sd">    t=1.0, u=0.23195266272189</span>
<span class="sd">    t=1.5, u=0.12489758761948</span>
<span class="sd">    t=2.0, u=0.06725254717972</span>
<span class="sd">    t=2.5, u=0.03621291001985</span>
<span class="sd">    t=3.0, u=0.01949925924146</span>
<span class="sd">    t=3.5, u=0.01049960113002</span>
<span class="sd">    t=4.0, u=0.00565363137770</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>When such interactive demonstrations are inserted in doc strings,
Python&#8217;s <tt class="docutils literal"><span class="pre">doctest</span></tt> module can be used to automate running all commands
in interactive sessions and compare new output with the output
appearing in the doc string.  All we have to do in the current example
is to write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Terminal</span><span class="o">&gt;</span> <span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">doctest</span> <span class="n">dc_mod_doctest</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>This command imports the <tt class="docutils literal"><span class="pre">doctest</span></tt> module, which runs all tests.
No additional command-line argument is allowed when running doctest.
If any test fails, the problem is reported, e.g.,</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python -m doctest dc_mod_doctest.py</span>
<span class="go">********************************************************</span>
<span class="go">File &quot;dc_mod_doctest.py&quot;, line 12, in dc_mod_doctest....</span>
<span class="go">Failed example:</span>
<span class="go">    for t_n, u_n in zip(t, u):</span>
<span class="go">        print &#39;t=%.1f, u=%.14f&#39; % (t_n, u_n)</span>
<span class="go">Expected:</span>
<span class="go">    t=0.0, u=0.80000000000000</span>
<span class="go">    t=0.5, u=0.43076923076923</span>
<span class="go">    t=1.0, u=0.23195266272189</span>
<span class="go">    t=1.5, u=0.12489758761948</span>
<span class="go">    t=2.0, u=0.06725254717972</span>
<span class="go">    t=2.5, u=0.03621291001985</span>
<span class="go">    t=3.0, u=0.01949925924146</span>
<span class="go">    t=3.5, u=0.01049960113002</span>
<span class="go">    t=4.0, u=0.00565363137770</span>
<span class="go">Got:</span>
<span class="go">    t=0.0, u=0.80000000000000</span>
<span class="go">    t=0.5, u=0.43076923076923</span>
<span class="go">    t=1.0, u=0.23195266272189</span>
<span class="go">    t=1.5, u=0.12489758761948</span>
<span class="go">    t=2.0, u=0.06725254717972</span>
<span class="go">********************************************************</span>
<span class="go">1 items had failures:</span>
<span class="go">   1 of   2 in dc_mod_doctest.solver</span>
<span class="go">***Test Failed*** 1 failures.</span>
</pre></div>
</div>
<p>Note that in the output of <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> we write <tt class="docutils literal"><span class="pre">u</span></tt> with 14 digits.
Writing all 16 digits is not a good idea: if the tests are run on
different hardware, round-off errors might be different, and
the <tt class="docutils literal"><span class="pre">doctest</span></tt> module detects numbers are not precisely the same
and reports failures. In the present application, where <span class="math">\(0 &lt; u(t) \leq 0.8\)</span>,
we expect round-off errors to be of size <span class="math">\(10^{-16}\)</span>, so comparing 15
digits would probably be reliable, but we compare 14 to be on the
safe side.</p>
<p>Doctests are highly encouraged as they do two things: 1) demonstrate
how a function is used and 2) test that the function works.</p>
<p>Here is an example on a doctest in the <tt class="docutils literal"><span class="pre">explore</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a case with the solver, compute error measure,</span>
<span class="sd">    and plot the numerical and exact solutions (if makeplot=True).</span>

<span class="sd">    &gt;&gt;&gt; for theta in 0, 0.5, 1:</span>
<span class="sd">    ...    E = explore(I=1.9, a=2.1, T=5, dt=0.1, theta=theta,</span>
<span class="sd">    ...                makeplot=False)</span>
<span class="sd">    ...    print &#39;%.10E&#39; % E</span>
<span class="sd">    ...</span>
<span class="sd">    7.3565079236E-02</span>
<span class="sd">    2.4183893110E-03</span>
<span class="sd">    6.5013039886E-02</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This time we limit the output to 10 digits.</p>
<p>We remark that doctests are not straightforward to construct for
functions that rely on command-line input and that print results to
the terminal window.</p>
</div>
<div class="section" id="unit-testing-with-nose">
<h2>Unit testing with nose<a class="headerlink" href="#unit-testing-with-nose" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-33"></span><span class="target" id="index-34"></span><p id="index-35">The unit testing technique consists of identifying small units
of code, usually functions (or classes), and write one or more tests for
each unit. One test should, ideally, not depend on the outcome of
other tests. For example, the doctest in function <tt class="docutils literal"><span class="pre">solver</span></tt> is a
unit test, and the doctest in function <tt class="docutils literal"><span class="pre">explore</span></tt> as well, but the
latter depends on a working <tt class="docutils literal"><span class="pre">solver</span></tt>. Putting the error computation
and plotting in <tt class="docutils literal"><span class="pre">explore</span></tt> in two separate functions would allow
independent unit tests. In this way, the design of unit tests impacts
the design of functions. The recommended practice is actually to
design and write the unit tests first and <em>then</em> implement the functions!</p>
<p>In scientific computing it is still not obvious how to best perform
unit testing. The units is naturally larger than in non-scientific
software. Very often the solution procedure of a mathematical problem
identifies a unit.</p>
<div class="section" id="basic-use-of-nose">
<h3>Basic use of nose<a class="headerlink" href="#basic-use-of-nose" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">nose</span></tt> package is a versatile tool for implementing unit tests
in Python. Here is a recommended way of structuring tests:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Implement tests in functions with names starting with <tt class="docutils literal"><span class="pre">test_</span></tt>.</li>
<li>Test functions perform assertions on computed results
using <tt class="docutils literal"><span class="pre">assert</span></tt> functions from the <tt class="docutils literal"><span class="pre">nose.tools</span></tt> module.</li>
<li>Test functions can be in the source code files or be
collected in separate files, usually with names starting with <tt class="docutils literal"><span class="pre">test_</span></tt>.</li>
</ol>
</div></blockquote>
<p>Here comes a very simple illustration of the three points.
Assume that we have this function in a module <tt class="docutils literal"><span class="pre">mymod</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span>
</pre></div>
</div>
<p>Either in this file or in a separate file <tt class="docutils literal"><span class="pre">test_mymod.py</span></tt>, we
implement a test function whose purpose is
to test that the function <tt class="docutils literal"><span class="pre">double</span></tt> works as intended:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nose.tools</span> <span class="kn">as</span> <span class="nn">nt</span>

<span class="k">def</span> <span class="nf">test_double</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">mymod</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">nt</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>We need to do an <tt class="docutils literal"><span class="pre">import</span> <span class="pre">mymod</span></tt> if this test is in a separate file, and
Python needs to be able to find <tt class="docutils literal"><span class="pre">mymod</span></tt>.</p>
<p>Running</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; nosetests</span>
</pre></div>
</div>
<p>makes the <tt class="docutils literal"><span class="pre">nose</span></tt> tool look for Python files with <tt class="docutils literal"><span class="pre">test_*()</span></tt>
functions and run these functions. If the <tt class="docutils literal"><span class="pre">nt.assert_equal</span></tt> function
finds that the two arguments are equal, the test is a success, otherwise
it is a failure and an exception of type <tt class="docutils literal"><span class="pre">AssertionError</span></tt> is raised.
Instead of calling the convenience function <tt class="docutils literal"><span class="pre">nt.assert_equal</span></tt>, we
can use Python&#8217;s <tt class="docutils literal"><span class="pre">assert</span></tt> statement, which tests if a boolean
expression is true and raises an <tt class="docutils literal"><span class="pre">AssertionError</span></tt> if the expression is
false. Here, the statement is <tt class="docutils literal"><span class="pre">assert</span> <span class="pre">result</span> <span class="pre">==</span> <span class="pre">8</span></tt>.
A completely manual alternative is to write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
</pre></div>
</div>
<p>The number of failed tests and their details are
reported, or an <tt class="docutils literal"><span class="pre">OK</span></tt> is printed if all tests passed.
Imports like <tt class="docutils literal"><span class="pre">import</span> <span class="pre">mymod</span></tt> in <tt class="docutils literal"><span class="pre">test_*.py</span></tt> files works even if <tt class="docutils literal"><span class="pre">mymod.py</span></tt>
is not located in the same directory as the test file (<tt class="docutils literal"><span class="pre">nose</span></tt> will
find it without any need for manipulating <tt class="docutils literal"><span class="pre">PYTHONPATH</span></tt> or <tt class="docutils literal"><span class="pre">sys.path</span></tt>).</p>
<p>The advantage with the <tt class="docutils literal"><span class="pre">nose</span></tt> is two-fold: 1) tests are written and collected
in a structured way, and 2) large collections of tests, scattered
throughout a tree of folders, can be executed with one command (<tt class="docutils literal"><span class="pre">nosetests</span></tt>).</p>
</div>
<div class="section" id="demonstrating-nose">
<h3>Demonstrating nose<a class="headerlink" href="#demonstrating-nose" title="Permalink to this headline">¶</a></h3>
<p>Let us illustrate how to use the <tt class="docutils literal"><span class="pre">nose</span></tt> tool for testing key functions
in the <tt class="docutils literal"><span class="pre">decay_theta</span></tt> module. Or more precisely, the module is called
<tt class="docutils literal"><span class="pre">decay_theta_unittest</span></tt> with all the <tt class="docutils literal"><span class="pre">verify*</span></tt> functions removed
as these now are outdated by the unit tests.</p>
<p>We design three unit tests:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A comparison between the computed <span class="math">\(u^n\)</span> values and the
exact discrete solution.</li>
<li>A comparison between the computed <span class="math">\(u^n\)</span> values and precomputed,
verified reference values.</li>
<li>A comparison between observed and expected convergence rates.</li>
</ol>
</div></blockquote>
<p>These tests follow very closely the code in the previously shown
<tt class="docutils literal"><span class="pre">verify*</span></tt> functions. We start with comparing <span class="math">\(u^n\)</span>, as computed by
the function <tt class="docutils literal"><span class="pre">solver</span></tt>, to the formula
for the exact discrete solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nose.tools</span> <span class="kn">as</span> <span class="nn">nt</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">dc_mod_unittest</span> <span class="kn">as</span> <span class="nn">dc_mod</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return exact discrete solution of the theta scheme.&quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># avoid integer division</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">factor</span><span class="o">**</span><span class="n">n</span>

<span class="k">def</span> <span class="nf">test_against_discrete_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare result from solver against</span>
<span class="sd">    formula for the discrete solution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">dc_mod</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_de</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">nt.assert_almost_equal</span></tt> is the relevant function for comparing two
real numbers. The <tt class="docutils literal"><span class="pre">delta</span></tt> argument specifies a tolerance for the
comparison. Alternatively, one can specify a <tt class="docutils literal"><span class="pre">places</span></tt> argument
for the number of decimal places to enter the comparison.</p>
<p>When we at some point have carefully verified the implementation, we may
store correctly computed numbers in the test program or in files for
use in future tests. Here is an example on how the outcome from the
<tt class="docutils literal"><span class="pre">solver</span></tt> function can be compared to what is considered to be
correct results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare result from solver against</span>
<span class="sd">    precomputed arrays for theta=0, 0.5, 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span><span class="o">=</span><span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span><span class="o">=</span><span class="mf">1.2</span><span class="p">;</span> <span class="n">T</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.5</span>  <span class="c"># fixed parameters</span>
    <span class="n">precomputed</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;t&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="mf">0.</span> <span class="p">,</span>  <span class="mf">0.5</span><span class="p">,</span>  <span class="mf">1.</span> <span class="p">,</span>  <span class="mf">1.5</span><span class="p">,</span>  <span class="mf">2.</span> <span class="p">,</span>  <span class="mf">2.5</span><span class="p">,</span>
                        <span class="mf">3.</span> <span class="p">,</span>  <span class="mf">3.5</span><span class="p">,</span>  <span class="mf">4.</span> <span class="p">]),</span>
        <span class="mf">0.5</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span> <span class="mf">0.8</span>       <span class="p">,</span>  <span class="mf">0.43076923</span><span class="p">,</span>  <span class="mf">0.23195266</span><span class="p">,</span> <span class="mf">0.12489759</span><span class="p">,</span>
              <span class="mf">0.06725255</span><span class="p">,</span>  <span class="mf">0.03621291</span><span class="p">,</span>  <span class="mf">0.01949926</span><span class="p">,</span> <span class="mf">0.0104996</span> <span class="p">,</span>
              <span class="mf">0.00565363</span><span class="p">]),</span>
        <span class="mi">0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>  <span class="mf">8.00000000e-01</span><span class="p">,</span>   <span class="mf">3.20000000e-01</span><span class="p">,</span>
               <span class="mf">1.28000000e-01</span><span class="p">,</span>   <span class="mf">5.12000000e-02</span><span class="p">,</span>
               <span class="mf">2.04800000e-02</span><span class="p">,</span>   <span class="mf">8.19200000e-03</span><span class="p">,</span>
               <span class="mf">3.27680000e-03</span><span class="p">,</span>   <span class="mf">1.31072000e-03</span><span class="p">,</span>
               <span class="mf">5.24288000e-04</span><span class="p">]),</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span> <span class="mf">0.8</span>       <span class="p">,</span>  <span class="mf">0.5</span>       <span class="p">,</span>  <span class="mf">0.3125</span>    <span class="p">,</span>  <span class="mf">0.1953125</span> <span class="p">,</span>
              <span class="mf">0.12207031</span><span class="p">,</span>  <span class="mf">0.07629395</span><span class="p">,</span>  <span class="mf">0.04768372</span><span class="p">,</span>  <span class="mf">0.02980232</span><span class="p">,</span>
              <span class="mf">0.01862645</span><span class="p">]),</span>
        <span class="p">}</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">dc_mod</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">precomputed</span><span class="p">[</span><span class="n">theta</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="c"># Precomputed numbers are known to 8 decimal places</span>
        <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                               <span class="n">msg</span><span class="o">=</span><span class="s">&#39;theta=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">precomputed</span></tt> object is a dictionary with four keys: <tt class="docutils literal"><span class="pre">'t'</span></tt> for the
time mesh, and three <span class="math">\(\theta\)</span> values for <span class="math">\(u^n\)</span> solutions corresponding
to the <span class="math">\(\theta=0,0.5,1\)</span>.</p>
<p>Testing for special type of input data that may cause trouble constitutes
a common way of constructing unit tests. The updating formula for
<span class="math">\(u^{n+1}\)</span> may be incorrectly evaluated because of unintended integer
divisions. For example, with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">theta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>the nominator and denominator in the updating expression,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>evaluate to 1 and 3, respectively, and the fraction <tt class="docutils literal"><span class="pre">1/3</span></tt> will
call up integer division and consequently lead to <tt class="docutils literal"><span class="pre">u[n+1]=0</span></tt>.
We construct a unit test to make sure <tt class="docutils literal"><span class="pre">solver</span></tt> is smart
enough to avoid this problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_potential_integer_division</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Choose variables that can trigger integer division.&quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">dc_mod</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_de</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">)</span>
</pre></div>
</div>
<p>The final test is to see if <span class="math">\(\theta=0,1\)</span> has convergence rate 1 and
<span class="math">\(\theta=0.5\)</span> has convergence rate 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare empirical convergence rates to exact ones.&quot;&quot;&quot;</span>
    <span class="c"># Set command-line arguments directly in sys.argv</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="s">&#39;--I 0.8 --a 2.1 --T 5 &#39;</span>\
                   <span class="s">&#39;--dt 0.4 0.2 0.1 0.05 0.025&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="c"># Suppress output from dc_mod.main()</span>
    <span class="n">stdout</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>  <span class="c"># save standard output for later use</span>
    <span class="n">scratchfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;.tmp&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>  <span class="c"># fake standard output</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">scratchfile</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">dc_mod</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">nt</span><span class="o">.</span><span class="n">assert_true</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">])</span>  <span class="c"># check for non-empty list</span>

    <span class="n">scratchfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">stdout</span>  <span class="c"># restore standard output</span>

    <span class="n">expected_rates</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">r_final</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c"># Compare to 1 decimal place</span>
        <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">expected_rates</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">r_final</span><span class="p">,</span>
                               <span class="n">places</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;theta=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>

<span class="c"># no need for any main</span>
</pre></div>
</div>
<p>Nothing more is needed in the <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/test/test_dc_nose.py">test_dc_nose.py</a>.
file. Running <tt class="docutils literal"><span class="pre">nosetests</span></tt> will report <tt class="docutils literal"><span class="pre">Ran</span> <span class="pre">3</span> <span class="pre">tests</span></tt> and an <tt class="docutils literal"><span class="pre">OK</span></tt> for
success.  Everytime we modify the <tt class="docutils literal"><span class="pre">decay_theta_unittest</span></tt> module we can
run <tt class="docutils literal"><span class="pre">nosetests</span></tt> to quickly see if the edits have any impact on the
test collection.</p>
</div>
<div class="section" id="installation-of-nose">
<h3>Installation of nose<a class="headerlink" href="#installation-of-nose" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">nose</span></tt> does not come with a standard Python distribution and must
therefore be installed separately. The procedure is standard and
described on <a class="reference external" href="http://nose.readthedocs.org/en/latest/">Nose&#8217;s web pages</a>.  On Debian-based Linux
systems the command is <tt class="docutils literal"><span class="pre">sudo</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">python-nose</span></tt>, and
with MacPorts you run <tt class="docutils literal"><span class="pre">sudo</span> <span class="pre">port</span> <span class="pre">install</span> <span class="pre">py27-nose</span></tt>.</p>
</div>
</div>
<div class="section" id="classical-unit-testing-with-unittest">
<h2>Classical unit testing with unittest<a class="headerlink" href="#classical-unit-testing-with-unittest" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-36"></span><span class="target" id="index-37"></span><p id="index-38">The classical way of implementing unit tests derives from the JUnit
tool in Java where all tests are methods in a class for testing.
Python comes with a module <tt class="docutils literal"><span class="pre">unittest</span></tt> for doing this type of unit tests.
While <tt class="docutils literal"><span class="pre">nose</span></tt> allows simple functions for unit tests, <tt class="docutils literal"><span class="pre">unittest</span></tt>
requires deriving a class <tt class="docutils literal"><span class="pre">Test*</span></tt> from <tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> and
implementing each test as methods with names <tt class="docutils literal"><span class="pre">test_*</span></tt> in that class.</p>
<div class="section" id="basic-use-of-unittest">
<h3>Basic use of unittest<a class="headerlink" href="#basic-use-of-unittest" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-39"></span><p id="index-40">Using the <tt class="docutils literal"><span class="pre">double</span></tt> function in the <tt class="docutils literal"><span class="pre">mymod</span></tt> module introduced in the
previous section, unit testing with the aid of the <tt class="docutils literal"><span class="pre">unittest</span></tt> module
consists of writing a file <tt class="docutils literal"><span class="pre">test_mymod.py</span></tt> with the content</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">mymod</span>

<span class="k">class</span> <span class="nc">TestMyCode</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_double</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">mymod</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>The test is run by executing the test file <tt class="docutils literal"><span class="pre">test_mymod.py</span></tt> as a standard
Python program. There is no support in <tt class="docutils literal"><span class="pre">unittest</span></tt> for automatically
locating and running all tests in all test files in a folder tree.</p>
<p>Those who have experience with object-oriented programming will see that
the difference between using <tt class="docutils literal"><span class="pre">unittest</span></tt> and <tt class="docutils literal"><span class="pre">nose</span></tt> is minor.
Programmers with no or little knowledge of classes will certainly
prefer <tt class="docutils literal"><span class="pre">nose</span></tt>.</p>
</div>
<div class="section" id="demonstration-of-unittest">
<h3>Demonstration of unittest<a class="headerlink" href="#demonstration-of-unittest" title="Permalink to this headline">¶</a></h3>
<p>The same tests as shown for the nose framework are reimplemented
with the <tt class="docutils literal"><span class="pre">TestCase</span></tt> classes in the file <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/test/test_dc_nose.py">test_dc_unittest.py</a>.
The tests are identical, the only difference being that with
<tt class="docutils literal"><span class="pre">unittest</span></tt> we must write the tests as methods in
a class and the assert functions have
slightly different syntax.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">dc_mod_unittest</span> <span class="kn">as</span> <span class="nn">decay</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">factor</span><span class="o">**</span><span class="n">n</span>

<span class="k">class</span> <span class="nc">TestDecay</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_against_discrete_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
            <span class="o">...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                   <span class="n">msg</span><span class="o">=</span><span class="s">&#39;theta=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_potential_integer_division</span><span class="p">():</span>
        <span class="o">...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1E-14</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
            <span class="o">...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="implementing-simple-problem-and-solver-classes">
<h2>Implementing simple problem and solver classes<a class="headerlink" href="#implementing-simple-problem-and-solver-classes" title="Permalink to this headline">¶</a></h2>
<p>The <span class="math">\(\theta\)</span>-rule was compactly and conveniently implemented in
a function <tt class="docutils literal"><span class="pre">solver</span></tt>. In more complicated problems it might
be beneficial to use classes and introduce a class <tt class="docutils literal"><span class="pre">Problem</span></tt> to
hold the definition of the physical problem, a class <tt class="docutils literal"><span class="pre">Solver</span></tt>
to hold the data and methods needed to numerically solve the problem,
and a class <tt class="docutils literal"><span class="pre">Visualizer</span></tt> to make plots.
This idea will now be illustrated, resulting in code that represents
an alternative to the <tt class="docutils literal"><span class="pre">solver</span></tt> and <tt class="docutils literal"><span class="pre">explore</span></tt> functions found
in the <tt class="docutils literal"><span class="pre">dc_mod</span></tt> module.</p>
<p>Explaining the details of class programming in Python
is considered beyond the scope of this text.
Readers who are unfamiliar with Python class programming
should first consult one of the many electronic Python tutorials
or textbooks to come up to speed with concepts and syntax of
Python classes before reading on.</p>
<div class="section" id="the-problem-class">
<h3>The problem class<a class="headerlink" href="#the-problem-class" title="Permalink to this headline">¶</a></h3>
<p id="index-41">The purpose of the problem class is to store all information about
the mathematical model. This usually means all the physical parameters
in the problem. In the current example with exponential decay we may
also add the exact solution of the ODE to the problem class.
The simplest form of a problem class is therefore</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span>

<span class="k">class</span> <span class="nc">Problem</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">I</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">T</span>

    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>We could in the <tt class="docutils literal"><span class="pre">exact_solution</span></tt> method have written
<tt class="docutils literal"><span class="pre">self.I*exp(-self.a*t)</span></tt>, but using local variables <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">a</span></tt> allows
a formula <tt class="docutils literal"><span class="pre">I*exp(-a*t)</span></tt> which looks closer to the mathematical
expression <span class="math">\(Ie^{-at}\)</span>.  This is not an important issue with the
current compact formula, but is beneficial in more complicated
problems with longer formulas. We will therefore often &#8220;strip off&#8221;
<tt class="docutils literal"><span class="pre">self</span></tt> in variables in forthcoming examples.</p>
<p>The class data can be set either as arguments in the constructor or
at any time later, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">problem</span> <span class="o">=</span> <span class="n">Problem</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">problem</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">problem</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">1.5</span>
</pre></div>
</div>
<p>However, it would be convenient if class <tt class="docutils literal"><span class="pre">Problem</span></tt> could also initialize
the data from the command line. To this end, we add a method for
defining a set of command-line options and a method that sets the
local attributes equal to what was found on the command line.
The default values associated with the command-line options are taken
as the values provided to the constructor. Class <tt class="docutils literal"><span class="pre">Problem</span></tt> now becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Problem</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">I</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">T</span>

    <span class="k">def</span> <span class="nf">define_command_line_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parser</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">argparse</span>
            <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>

        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="s">&#39;--initial_condition&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;initial condition, u(0)&#39;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;I&#39;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s">&#39;--a&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s">&#39;coefficient in ODE&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s">&#39;--T&#39;</span><span class="p">,</span> <span class="s">&#39;--stop_time&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s">&#39;end time of simulation&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parser</span>

    <span class="k">def</span> <span class="nf">init_from_command_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Observe that if the user already has an <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> object it can be
supplied, but if we do not have, class <tt class="docutils literal"><span class="pre">Problem</span></tt> makes one for us.
Python&#8217;s <tt class="docutils literal"><span class="pre">None</span></tt> object is used to indicate that a variable is not
initialized with a value.</p>
</div>
<div class="section" id="the-solver-class">
<h3>The solver class<a class="headerlink" href="#the-solver-class" title="Permalink to this headline">¶</a></h3>
<p id="index-42">The solver class stores data related to the numerical solution method
and provides a function <tt class="docutils literal"><span class="pre">solve</span></tt> for solving the problem.
A problem object must be given to the constructor so that the solver
can easily look up physical data. In the present example, the
data related to the numerical solution method consist of <span class="math">\(\Delta t\)</span>
and <span class="math">\(\theta\)</span>. We add, as in the problem class, functionality for
reading <span class="math">\(\Delta t\)</span> and <span class="math">\(\theta\)</span> from the command line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Solver</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem</span> <span class="o">=</span> <span class="n">problem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">),</span> <span class="n">theta</span>

    <span class="k">def</span> <span class="nf">define_command_line_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="s">&#39;--time_step_value&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;time step value&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;dt&#39;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s">&#39;--theta&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s">&#39;time discretization parameter&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;dt&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parser</span>

    <span class="k">def</span> <span class="nf">init_from_command_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">theta</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">dc_mod</span> <span class="kn">import</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">exact_solution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
<p>Note that we here simply reuse the implementation of the numerical method
from the <tt class="docutils literal"><span class="pre">dc_mod</span></tt> module.</p>
</div>
<div class="section" id="the-visualizer-class">
<h3>The visualizer class<a class="headerlink" href="#the-visualizer-class" title="Permalink to this headline">¶</a></h3>
<p id="index-43">The purpose of the visualizer class is to plot the numerical solution
stored in class <tt class="docutils literal"><span class="pre">Solver</span></tt>. We also add the possibility to plot the
exact solution. Access to the problem and solver objects is required
when making plots so the constructor must store these objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Visualizer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">problem</span><span class="p">,</span> <span class="n">solver</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_exact</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">plt</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add solver.u curve to scitools plotting object plt,</span>
<span class="sd">        and include the exact solution if include_exact is True.</span>
<span class="sd">        This plot function can be called several times (if</span>
<span class="sd">        the solver object has computed new solutions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">plt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">scitools.std</span>
            <span class="n">plt</span> <span class="o">=</span> <span class="n">scitools</span><span class="o">.</span><span class="n">std</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="s">&#39;--o&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
        <span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">theta2name</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s">&#39;numerical </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">include_exact</span><span class="p">:</span>
            <span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>
            <span class="n">u_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s">&#39;exact&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span>
                  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">plt</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">plt</span></tt> object in the <tt class="docutils literal"><span class="pre">plot</span></tt> method is worth a comment. The idea is
that <tt class="docutils literal"><span class="pre">plot</span></tt> can add a numerical solution curve to an existing
plot. Calling <tt class="docutils literal"><span class="pre">plot</span></tt> with a <tt class="docutils literal"><span class="pre">plt</span></tt> object, which has to be a
<tt class="docutils literal"><span class="pre">scitools.std</span></tt> object in this implementation, will just add the curve
<tt class="docutils literal"><span class="pre">self.solver.u</span></tt> as a dashed line with circles at the mesh points
(leaving the color of the curve up to the plotting tool). This
functionality allows plots with several solutions: just make a loop
where new data is set in the problem and/or solver classes, the
solver&#8217;s <tt class="docutils literal"><span class="pre">solve()</span></tt> method is called, the most recent numerical
solution is plotted by the <tt class="docutils literal"><span class="pre">plot(plt)</span></tt> method in the visualizer object
(<a class="reference internal" href="#decay-exer-dc-class-exper"><em>Exercise 10: Make use of a class implementation</em></a> describes a problem setting
where this functionality is explored).</p>
</div>
<div class="section" id="combing-the-objects">
<h3>Combing the objects<a class="headerlink" href="#combing-the-objects" title="Permalink to this headline">¶</a></h3>
<p>Eventually we need to show how the classes <tt class="docutils literal"><span class="pre">Problem</span></tt>, <tt class="docutils literal"><span class="pre">Solver</span></tt>, and
<tt class="docutils literal"><span class="pre">Visualizer</span></tt> play together:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">Problem</span><span class="p">()</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
    <span class="n">viz</span> <span class="o">=</span> <span class="n">Visualizer</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>

    <span class="c"># Read input from the command line</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">define_command_line_options</span><span class="p">()</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span> <span class="n">define_command_line_options</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">init_from_command_line</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span> <span class="n">init_from_command_line</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="c"># Solve and plot</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">plt</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">error</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Error: </span><span class="si">%.4E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">E</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The file <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/dc_class.py">dc_class.py</a>
constitutes a module with the three classes and the <tt class="docutils literal"><span class="pre">main</span></tt> function.</p>
</div>
</div>
<div class="section" id="implementing-more-advanced-problem-and-solver-classes">
<h2>Implementing more advanced problem and solver classes<a class="headerlink" href="#implementing-more-advanced-problem-and-solver-classes" title="Permalink to this headline">¶</a></h2>
<p>The previous <tt class="docutils literal"><span class="pre">Problem</span></tt> and <tt class="docutils literal"><span class="pre">Solver</span></tt> classes containing parameters
soon get much repetitive code when the number of parameters increases.
Much of this code can be parameterized and be made more compact.
For this purpose, we decide to collect all parameters in a dictionary,
<tt class="docutils literal"><span class="pre">self.prms</span></tt>, with two associated dictionaries <tt class="docutils literal"><span class="pre">self.types</span></tt> and
<tt class="docutils literal"><span class="pre">self.help</span></tt> for holding associated object types and help strings.
Provided a problem, solver, or visualizer class defines these three
dictionaries in the constructor, using default or user-supplied values
of the parameters, we can create a super class <tt class="docutils literal"><span class="pre">Parameters</span></tt> with general code
for defining command-line options and reading them as well as
methods for setting and getting a parameter. A <tt class="docutils literal"><span class="pre">Problem</span></tt> or <tt class="docutils literal"><span class="pre">Solver</span></tt> class will
then inherit command-line functionality and the set/get methods from
the <tt class="docutils literal"><span class="pre">Parameters</span></tt> class.</p>
<div class="section" id="a-generic-class-for-parameters">
<h3>A generic class for parameters<a class="headerlink" href="#a-generic-class-for-parameters" title="Permalink to this headline">¶</a></h3>
<p>A simplified version of the parameter class looks as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Parameters</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prms</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prms</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">define_command_line_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parser</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">argparse</span>
            <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prms</span><span class="p">:</span>
            <span class="n">tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="k">else</span> <span class="nb">str</span>
            <span class="n">help</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">help</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">help</span> <span class="k">else</span> <span class="bp">None</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="s">&#39;--&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">tp</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="n">help</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parser</span>

    <span class="k">def</span> <span class="nf">init_from_command_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prms</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>The file <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/class_dc_verf1.py">class_dc_verf1.py</a> contains
a slightly more advanced version of class <tt class="docutils literal"><span class="pre">Parameters</span></tt> where we
in the <tt class="docutils literal"><span class="pre">set</span></tt> and <tt class="docutils literal"><span class="pre">get</span></tt> functions test for valid parameter names and
raise exceptions with informative messages if any name is not registered.</p>
</div>
<div class="section" id="id8">
<h3>The problem class<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p id="index-44">A class <tt class="docutils literal"><span class="pre">Problem</span></tt> for the exponential decay ODE with parameters <span class="math">\(a\)</span>, <span class="math">\(I\)</span>, and
<span class="math">\(T\)</span> can now be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Problem</span><span class="p">(</span><span class="n">Parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Physical parameters for the problem u&#39;=-a*u, u(0)=I,</span>
<span class="sd">    with t in [0,T].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="s">&#39;initial condition, u(0)&#39;</span><span class="p">,</span>
                         <span class="n">a</span><span class="o">=</span><span class="s">&#39;coefficient in ODE&#39;</span><span class="p">,</span>
                         <span class="n">T</span><span class="o">=</span><span class="s">&#39;end time of simulation&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>The solver class<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p id="index-45">Also the solver class is derived from class <tt class="docutils literal"><span class="pre">Parameters</span></tt> and works with
the <tt class="docutils literal"><span class="pre">prms</span></tt>, <tt class="docutils literal"><span class="pre">types</span></tt>, and <tt class="docutils literal"><span class="pre">help</span></tt> dictionaries in the same way as class
<tt class="docutils literal"><span class="pre">Problem</span></tt>. Otherwise, the code is very similar to class <tt class="docutils literal"><span class="pre">Solver</span></tt> in
the <tt class="docutils literal"><span class="pre">decay_class.py</span></tt> file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Solver</span><span class="p">(</span><span class="n">Parameters</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">problem</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem</span> <span class="o">=</span> <span class="n">problem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="s">&#39;time step value&#39;</span><span class="p">,</span>
                         <span class="n">theta</span><span class="o">=</span><span class="s">&#39;time discretization parameter&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#from dc_mod import solver</span>
        <span class="kn">from</span> <span class="nn">decay_theta</span> <span class="kn">import</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;dt&#39;</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;theta&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">u_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem</span><span class="o">.</span><span class="n">exact_solution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;dt&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>The visualizer class<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>Class <tt class="docutils literal"><span class="pre">Visualizer</span></tt> can be identical to the one in the <tt class="docutils literal"><span class="pre">decay_class.py</span></tt> file
since the class does not need any parameters. However, a few
adjustments in the <tt class="docutils literal"><span class="pre">plot</span></tt> method is necessary since parameters are
accessed as, e.g., <tt class="docutils literal"><span class="pre">problem.get('T')</span></tt> rather than <tt class="docutils literal"><span class="pre">problem.T</span></tt>.
The details are found in the file <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/class_dc_verf1.py">class_dc_verf1.py</a>.</p>
<p>Finally, we need a function that solves a real problem using the
classes <tt class="docutils literal"><span class="pre">Problem</span></tt>, <tt class="docutils literal"><span class="pre">Solver</span></tt>, and <tt class="docutils literal"><span class="pre">Visualizer</span></tt>. This function can
be just like <tt class="docutils literal"><span class="pre">main</span></tt> in the <tt class="docutils literal"><span class="pre">class_dc_v1.py</span></tt> file.</p>
<p>The advantage with the <tt class="docutils literal"><span class="pre">Parameters</span></tt> class is that it scales to problems
with a large number of physical and numerical parameters:
as long as the parameters are defined once via a dictionary,
the compact code in class <tt class="docutils literal"><span class="pre">Parameters</span></tt> can handle any collection of
parameters of any size.</p>
</div>
</div>
</div>
<div class="section" id="performing-scientific-experiments">
<span id="decay-experiments"></span><h1>Performing scientific experiments<a class="headerlink" href="#performing-scientific-experiments" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-47"></span><p id="index-48">The goal of this section is to explore the behavior of a numerical
method for a differential equation and show how scientific experiments
can be set up and reported. We address the ODE problem</p>
<div class="math" id="equation-decay:experiments:model">
<span class="eqno">(28)</span>\[\begin{split}     u'(t) = -au(t),\quad u(0)=I,\quad 0&lt;t\leq T,\end{split}\]</div>
<p>numerically discretized by the <span class="math">\(\theta\)</span>-rule:</p>
<div class="math">
\[u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
\quad u^0=I\thinspace .\]</div>
<p>Our aim is to plot <span class="math">\(u^n\)</span> against the exact solution <span class="math">\(u_{\small\mbox{e}} = Ie^{-at}\)</span>
for various choices of the parameters in this numerical problem:
<span class="math">\(I\)</span>, <span class="math">\(a\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(\theta\)</span>. In particular, we are interested
in how the discrete solution compares with the exact solution
when the <span class="math">\(\Delta t\)</span> parameter is varied and <span class="math">\(\theta\)</span> takes on the three values
corresponding to the Forward Euler, Backward Euler, and Crank-Nicolson
schemes (<span class="math">\(\theta=0,1,0.5\)</span>, respectively).</p>
<p>A verified implementation for computing <span class="math">\(u^n\)</span> and plotting <span class="math">\(u^n\)</span> together
with <span class="math">\(u_{\small\mbox{e}}\)</span> is found in the file
<a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/dc_mod.py">dc_mod.py</a>.
This program admits command-line arguments to specify a series of
<span class="math">\(\Delta t\)</span> values and will run a loop over these values and
<span class="math">\(\theta=0,0.5,1\)</span>. We make a slight edit of how the plots are
designed: the numerical solution is specified with line type <tt class="docutils literal"><span class="pre">'r--o'</span></tt>
(dashed red lines with dots at the mesh points), and the <tt class="docutils literal"><span class="pre">show()</span></tt>
command is removed to avoid a lot of plot windows popping up on
the computer screen (but hardcopies of the plot are still stored
in files via <tt class="docutils literal"><span class="pre">savefig</span></tt>). The slightly
modified program has the name
<a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_mod.py">experiments/dc_mod.py</a>.
All files associated with the scientific investigation are collected
in a subfolder <tt class="docutils literal"><span class="pre">experiments</span></tt>.</p>
<p>Running the experiments is easy since the <tt class="docutils literal"><span class="pre">dc_mod.py</span></tt> program
already has the loops over <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> implemented:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_mod.py --I 1 --a 2 --makeplot \</span>
<span class="go">          --T 5 --dt 0.5 0.25 0.1 0.05</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">dc_mod.py</span></tt> program generates a lot of image files, e.g.,
<tt class="docutils literal"><span class="pre">FE_*.png</span></tt>, <tt class="docutils literal"><span class="pre">BE_*.png</span></tt>, and <tt class="docutils literal"><span class="pre">CN_*.png</span></tt>.
We want to combine all the <tt class="docutils literal"><span class="pre">FE_*.png</span></tt> files in a table
fashion in one file, with two images in each row,
starting with the largest <span class="math">\(\Delta t\)</span> in the upper
left corner and decreasing the value as we go to the right and down.
This can be done using the <a class="reference external" href="http://www.imagemagick.org/script/montage.php">montage</a> program.</p>
<p>Also plot files in the PDF format with names <tt class="docutils literal"><span class="pre">FE_*.pdf</span></tt>, <tt class="docutils literal"><span class="pre">BE_*.pdf</span></tt>,
and <tt class="docutils literal"><span class="pre">CN_*.pdf</span></tt> are generated and these should be combined using other
tools: <tt class="docutils literal"><span class="pre">pdftk</span></tt> to combine individual plots into one file with one plot
per page, and <tt class="docutils literal"><span class="pre">pdfnup</span></tt> to combine the pages into a table with multiple
plots per page. The code snippets below contains all details about the
usage of <tt class="docutils literal"><span class="pre">montage</span></tt>, <tt class="docutils literal"><span class="pre">pdftk</span></tt>, and <tt class="docutils literal"><span class="pre">pdfnup</span></tt>.</p>
<p id="index-49">Running manual commands is boring, and errors may easily
sneak in. Both for automating manual work and documenting the
operating system commands we actually issued in the experiment,
we should write a <em>script</em> (little program). The script takes
a list of <span class="math">\(\Delta t\)</span> values on the command line as input and
makes three combined images, one for each <span class="math">\(\theta\)</span> value,
displaying the quality of the numerical solution as <span class="math">\(\Delta t\)</span>
varies. For example,</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python dc_exper0.py 0.5 0.25 0.1 0.05</span>
</pre></div>
</div>
<p>results in images <tt class="docutils literal"><span class="pre">FE.png</span></tt>, <tt class="docutils literal"><span class="pre">CN.png</span></tt>, <tt class="docutils literal"><span class="pre">BE.png</span></tt>,
<tt class="docutils literal"><span class="pre">FE.pdf</span></tt>, <tt class="docutils literal"><span class="pre">CN.pdf</span></tt>, and <tt class="docutils literal"><span class="pre">BE.pdf</span></tt>,
each with four plots corresponding to the four <span class="math">\(\Delta t\)</span> values.
Each plot compares the numerical solution with the exact one.
The latter image is shown in Figure <a class="reference internal" href="#decay-experiments-fig-be4a"><em>Illustration of the Backward Euler method for four time step values</em></a>.</p>
<div class="figure" id="decay-experiments-fig-be4a">
<img alt="_images/BE4a.png" src="_images/BE4a.png" style="width: 600px;" />
<p class="caption"><em>Illustration of the Backward Euler method for four time step values</em></p>
</div>
<p>Ideally, the script should be scalable in the sense that it works for
any number of <span class="math">\(\Delta t\)</span> values, which is the case for this particular
implementation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>

<span class="c"># The command line must contain dt values</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Usage: </span><span class="si">%s</span><span class="s"> dt1 dt2 dt3 ...&#39;</span><span class="p">;</span>  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>

<span class="c"># Fixed physical parameters</span>
<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c"># Run module file as a stand-alone application</span>
<span class="n">cmd</span> <span class="o">=</span> <span class="s">&#39;python dc_mod.py --I </span><span class="si">%g</span><span class="s"> --a </span><span class="si">%g</span><span class="s"> --makeplot --T </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> \
      <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">dt_values_str</span> <span class="o">=</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">])</span>
<span class="n">cmd</span> <span class="o">+=</span> <span class="s">&#39; --dt </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt_values_str</span>
<span class="k">print</span> <span class="n">cmd</span>
<span class="n">failure</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
<span class="k">if</span> <span class="n">failure</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Command failed:&#39;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">;</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Combine images into rows with 2 plots in each row</span>
<span class="n">combine_image_commands</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="s">&#39;CN&#39;</span><span class="p">,</span> <span class="s">&#39;FE&#39;</span><span class="p">:</span>
    <span class="n">imagefiles</span> <span class="o">=</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">])</span>
    <span class="n">combine_image_commands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="s">&#39;montage -background white -geometry 100%&#39;</span> <span class="o">+</span> \
        <span class="s">&#39; -tile 2x </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">imagefiles</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="n">combine_image_commands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="s">&#39;pdftk </span><span class="si">%s</span><span class="s"> output tmp.pdf&#39;</span> <span class="o">%</span> <span class="n">imagefiles</span><span class="p">)</span>
    <span class="n">num_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dt_values</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span>
    <span class="n">combine_image_commands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="s">&#39;pdfnup --nup 2x</span><span class="si">%d</span><span class="s"> tmp.pdf&#39;</span> <span class="o">%</span> <span class="n">num_rows</span><span class="p">)</span>
    <span class="n">combine_image_commands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="s">&#39;mv -f tmp-nup.pdf </span><span class="si">%s</span><span class="s">.pdf&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">imagefiles</span> <span class="o">=</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">])</span>

<span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">combine_image_commands</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">cmd</span>
    <span class="n">failure</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">failure</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Command failed:&#39;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">;</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Remove the files generated by dc_mod.py</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="s">&#39;*_*.png&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">glob</span><span class="p">(</span><span class="s">&#39;*_*.pdf&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">glob</span><span class="p">(</span><span class="s">&#39;*_*.eps&#39;</span><span class="p">)</span>  <span class="o">+</span>\
            <span class="n">glob</span><span class="p">(</span><span class="s">&#39;tmp*.pdf&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>This file is available as <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_exper0.py">experiments/dc_exper0.py</a>.</p>
<span class="target" id="index-50"></span><p id="index-51">We may comment upon many useful constructs in this script:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">[float(arg)</span> <span class="pre">for</span> <span class="pre">arg</span> <span class="pre">in</span> <span class="pre">sys.argv]</span></tt> builds a list of real numbers
from all the command-line arguments.</li>
<li><tt class="docutils literal"><span class="pre">failure</span> <span class="pre">=</span> <span class="pre">os.system(cmd)</span></tt> runs an operating system command, e.g.,
another program. The execution successful only if <tt class="docutils literal"><span class="pre">failure</span></tt> is zero.</li>
<li>Unsuccessful execution usually makes it meaningless to continue
the program, and therefore we abort the program with <tt class="docutils literal"><span class="pre">sys.exit(1)</span></tt>.
Any argument different from 0 signifies that our program stopped
with a failure.</li>
<li><tt class="docutils literal"><span class="pre">['%s_%s.png'</span> <span class="pre">%</span> <span class="pre">(method,</span> <span class="pre">dt)</span> <span class="pre">for</span> <span class="pre">dt</span> <span class="pre">in</span> <span class="pre">dt_values]</span></tt> builds a list of
filenames from a list of numbers (<tt class="docutils literal"><span class="pre">dt_values</span></tt>).</li>
<li>All <tt class="docutils literal"><span class="pre">montage</span></tt>, <tt class="docutils literal"><span class="pre">pdftk</span></tt>, <tt class="docutils literal"><span class="pre">pdfnup</span></tt>, and <tt class="docutils literal"><span class="pre">mv</span></tt> commands for creating
composite figures are stored in a
list and thereafter executed in a loop.</li>
<li><tt class="docutils literal"><span class="pre">glob('*_*.png')</span></tt> returns a list of the names of all files in the
current folder where the filename matches the <em>Unix wildcard notation</em>
<tt class="docutils literal"><span class="pre">*_*.png</span></tt> (meaning &#8220;any text, underscore, any text, and then <cite>.png</cite>&#8221;).</li>
<li><tt class="docutils literal"><span class="pre">os.remove(filename)</span></tt> removes the file with name <tt class="docutils literal"><span class="pre">filename</span></tt>.</li>
</ul>
</div></blockquote>
<div class="section" id="interpreting-output-from-other-programs">
<h2>Interpreting output from other programs<a class="headerlink" href="#interpreting-output-from-other-programs" title="Permalink to this headline">¶</a></h2>
<p>Programs that run other programs, like <tt class="docutils literal"><span class="pre">dc_exper0.py</span></tt> does, will often
need to interpret output from the other programs. Let us demonstrate how
this is done in Python by extracting the relations between <span class="math">\(\theta\)</span>,
<span class="math">\(\Delta t\)</span>, and the error <span class="math">\(E\)</span> as written to the terminal window
by the <tt class="docutils literal"><span class="pre">dc_mod.py</span></tt> program, which is being executed by
<tt class="docutils literal"><span class="pre">dc_exper0.py</span></tt>. We will</p>
<blockquote>
<div><ul class="simple">
<li>read the output from the <tt class="docutils literal"><span class="pre">dc_mod.py</span></tt> program</li>
<li>interpret this output and store the <span class="math">\(E\)</span> values in arrays for each
<span class="math">\(\theta\)</span> value</li>
<li>plot <span class="math">\(E\)</span> versus <span class="math">\(\Delta t\)</span>, for each <span class="math">\(\theta\)</span>, in a log-log plot</li>
</ul>
</div></blockquote>
<span class="target" id="index-52"></span><p id="index-53">The simple <tt class="docutils literal"><span class="pre">os.system(cmd)</span></tt> call does not allow us to read the
output from running <tt class="docutils literal"><span class="pre">cmd</span></tt>. Instead we need to invoke a bit more
involved procedure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">subprocess</span> <span class="kn">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span><span class="p">,</span> <span class="n">STDOUT</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">STDOUT</span><span class="p">)</span>
<span class="n">output</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
<span class="n">failure</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">returncode</span>
<span class="k">if</span> <span class="n">failure</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Command failed:&#39;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">;</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The command stored in <tt class="docutils literal"><span class="pre">cmd</span></tt> is run and all text that is written to
the standard output <em>and</em> the standard error is available in the
string <tt class="docutils literal"><span class="pre">output</span></tt>. The text in <tt class="docutils literal"><span class="pre">output</span></tt> is what appeared in the
terminal window while running <tt class="docutils literal"><span class="pre">cmd</span></tt>.</p>
<p>Our next task is to run through the <tt class="docutils literal"><span class="pre">output</span></tt> string, line by line,
and if the current line prints <span class="math">\(\theta\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(E\)</span>,
we split the line into these three pieces and store the data.
The chosen storage structure is a dictionary <tt class="docutils literal"><span class="pre">errors</span></tt> with keys <tt class="docutils literal"><span class="pre">dt</span></tt>
to hold the <span class="math">\(\Delta t\)</span> values, and three <span class="math">\(\theta\)</span> keys to hold
the corresponding <span class="math">\(E\)</span> values. The relevant code lines are</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;dt&#39;</span><span class="p">:</span> <span class="n">dt_values</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">:</span> <span class="p">[],</span> <span class="mf">0.5</span><span class="p">:</span> <span class="p">[]}</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">output</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;0.0&#39;</span><span class="p">,</span> <span class="s">&#39;0.5&#39;</span><span class="p">,</span> <span class="s">&#39;1.0&#39;</span><span class="p">):</span>  <span class="c"># line with E?</span>
        <span class="c"># typical line: 0.0   1.25:    7.463E+00</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">E</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">errors</span><span class="p">[</span><span class="n">theta</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we do not bother to store the <span class="math">\(\Delta t\)</span> values as we
read them from <tt class="docutils literal"><span class="pre">output</span></tt>, because we already have these values in
the <tt class="docutils literal"><span class="pre">dt_values</span></tt> list.</p>
<p>We are now ready to plot <span class="math">\(E\)</span> versus <span class="math">\(\Delta t\)</span> for <span class="math">\(\theta=0,0.5,1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="c">#import scitools.std as plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">errors</span><span class="p">[</span><span class="s">&#39;dt&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;ro-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>  <span class="c"># MATLAB style...</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">errors</span><span class="p">[</span><span class="s">&#39;dt&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mf">0.5</span><span class="p">],</span> <span class="s">&#39;b+-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">errors</span><span class="p">[</span><span class="s">&#39;dt&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;gx-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="s">&#39;CN&#39;</span><span class="p">,</span> <span class="s">&#39;BE&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;log(time step)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;log(error)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Error vs time step&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;error_BE_CN_FE.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;error_BE_CN_FE.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Plots occasionally need some manual adjustments. Here, the axis of
the log-log plot look nicer if we adapt them strictly to the data,
see Figure <a class="reference internal" href="#decay-exper-evsdt"><em>Default plot (left) and manually adjusted plot (right)</em></a>.
To this end, we need to compute <span class="math">\(\min E\)</span> and <span class="math">\(\max E\)</span>, and later
specify the extent of the axes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">errors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;dt&#39;</span><span class="p">:</span> <span class="n">dt_values</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">:</span> <span class="p">[],</span> <span class="mf">0.5</span><span class="p">:</span> <span class="p">[]}</span>
<span class="n">min_E</span> <span class="o">=</span> <span class="mf">1E+20</span><span class="p">;</span> <span class="n">max_E</span> <span class="o">=</span> <span class="o">-</span><span class="n">min_E</span>  <span class="c"># keep track of min/max E for axis</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">output</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
    <span class="o">...</span>
        <span class="o">...</span>
        <span class="n">min_E</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_E</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>  <span class="n">max_E</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">errors</span><span class="p">[</span><span class="s">&#39;dt&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;ro-&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">dt_values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">dt_values</span><span class="p">),</span> <span class="n">min_E</span><span class="p">,</span> <span class="n">max_E</span><span class="p">])</span>
<span class="o">...</span>
</pre></div>
</div>
<div class="figure" id="decay-exper-evsdt">
<img alt="_images/error_plot_improvement.png" src="_images/error_plot_improvement.png" style="width: 800px;" />
<p class="caption"><em>Default plot (left) and manually adjusted plot (right)</em></p>
</div>
<p>The complete program, incorporating the code snippets above, is found
in <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_exper1.py">experiments/dc_exper1.py</a>.
This program can hopefully be reused in a number of other occasions
where one needs to run experiments, extract data from the output
of programs, make plots, and combine several plots in a figure file.</p>
</div>
<div class="section" id="making-a-report">
<span id="decay-exper-report"></span><h2>Making a report<a class="headerlink" href="#making-a-report" title="Permalink to this headline">¶</a></h2>
<p>The results of running computer experiments are best documented in a
little report containing the problem to be solved, key code segments,
and the plots from a series of experiments. At least the part of the
report containing the plots should be automatically generated by the
script that performs the set of experiments, because in that script we
know exactly which input data that were used to generate a specific
plot, thereby ensuring that each figure is connected to the
right data. Take a look at an
<a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/sphinx-cloud/">example</a>  to see what we have in
mind.</p>
<div class="section" id="plain-html">
<h3>Plain HTML<a class="headerlink" href="#plain-html" title="Permalink to this headline">¶</a></h3>
<p>Scientific reports can be written in a variety of formats. Here we
begin with the <a class="reference external" href="http://en.wikipedia.org/wiki/HTML">HTML</a> format
which allows efficient browsing of all the experiments in any web
browser. An extended version of the <tt class="docutils literal"><span class="pre">dc_exper1.py</span></tt> from the last
section, called <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_exper1_html.py">dc_exper1_html.py</a>,
adds code at the end for creating an HTML file with a summary, a
section on the mathematical problem, a section on the numerical
method, a section on the <tt class="docutils literal"><span class="pre">solver</span></tt> function implementing the
method, and a section with subsections containing figures that shows
the results of experiments where <span class="math">\(\Delta t\)</span> is varied for
<span class="math">\(\theta=0,0.5,1\)</span>. The mentioned
Python file contains all the details for writing
this <a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/report_html.html">HTML report</a>.</p>
</div>
<div class="section" id="html-with-mathjax">
<h3>HTML with MathJax<a class="headerlink" href="#html-with-mathjax" title="Permalink to this headline">¶</a></h3>
<p>Scientific reports usually need mathematical formulas and hence
mathematical typesetting. In plain HTML, as used in the
<tt class="docutils literal"><span class="pre">dc_exper1_html.py</span></tt> file, we have to use just the keyboard
characters to write mathematics. However, there is an extension to
HTML, called <a class="reference external" href="http://www.mathjax.org/">MathJax</a>, that allows
formulas and equations to be typeset with LaTeX syntax and nicely
rendered in web browsers.  A relatively small subset of LaTeX
environments is supported, but the syntax for formulas is quite
rich. Inline formulas are look like <tt class="docutils literal"><span class="pre">\(</span> <span class="pre">u'=-au</span> <span class="pre">\)</span></tt> while equations are
surrounded by <tt class="docutils literal"><span class="pre">$$</span></tt> signs.  Inside such signs, one can use <tt class="docutils literal"><span class="pre">\[</span> <span class="pre">u'=-au</span>
<span class="pre">\]</span></tt> for unnumbered equations, or <tt class="docutils literal"><span class="pre">\begin{equation}</span></tt> and
<tt class="docutils literal"><span class="pre">\end{equation}</span></tt> surrounding <tt class="docutils literal"><span class="pre">u'=-au</span></tt> for numbered equations, or <tt class="docutils literal"><span class="pre">\begin{align}</span></tt>
and <tt class="docutils literal"><span class="pre">\end{align}</span></tt> for multiple aligned equations, with (<tt class="docutils literal"><span class="pre">align</span></tt>) or
without (<tt class="docutils literal"><span class="pre">align*</span></tt>) numbers and labels.</p>
<p>The file <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/experiments/dc_exper1_html.py">dc_exper1_mathjax.py</a>
contains all the details for turning the previous plain HTML report
into <a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/report_html_mathjax.html">web pages with nicely typeset mathematics</a>.</p>
</div>
<div class="section" id="latex">
<h3>LaTeX<a class="headerlink" href="#latex" title="Permalink to this headline">¶</a></h3>
<p>The <em>de facto</em> language for mathematical typesetting and scientific
report writing is <a class="reference external" href="http://en.wikipedia.org/wiki/LaTeX">LaTeX</a>.  A
number of very sophisticated packages have been added to the language
over a period of three decades, allowing very fine-tuned layout and
typesetting. For output in the <a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/report.pdf">PDF format</a>, LaTeX is
the definite choice when it comes to quality. The LaTeX language used
to write the reports has typically a lot of commands involving
<a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/report.tex.html">backslashes and braces</a>.
For output on
the web, using HTML (and not the PDF directly in the browser window),
LaTeX struggles with delivering high quality typesetting. Other tools,
especially Sphinx, gives better results and can also produce
nice-looking PDFs.</p>
</div>
<div class="section" id="sphinx">
<h3>Sphinx<a class="headerlink" href="#sphinx" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://sphinx.pocoo.org/">Sphinx</a> is a typesetting language with
similarities to HTML and LaTeX, but with much less tagging. It has
recently become very popular for software documentation and
mathematical reports. Sphinx can utilize MathJax or LaTeX for
mathematical formulas and equations, but has limitations compared to
both tools. The Sphinx <a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/report_sphinx.rst.html">syntax</a>
is an extension of the reStructuredText language, and comes with rich
support for <a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/sphinx-cloud/index.html">fancy layout of web pages</a>. In
particular, Sphinx can easily be combined with various layout <em>themes</em>
that give a certain look and feel to the web site and that offers
table of contents, navigation, search facilities, etc.</p>
</div>
<div class="section" id="markdown">
<h3>Markdown<a class="headerlink" href="#markdown" title="Permalink to this headline">¶</a></h3>
<p>A recently popular format for easy writing of web pages is
<a class="reference external" href="http://daringfireball.net/projects/markdown/">Markdown</a>.
Text is written very much like one would do in email, using
spacing and special characters to naturally format the code
instead of heavily tagging the text as in LaTeX and HTML.
With the tool <a class="reference external" href="http://johnmacfarlane.net/pandoc/">Pandoc</a> one
can go from Markdown to a variety of formats.
HTML is a common output format, but LaTeX, epub, XML,
OpenOffice, MediaWiki, and MS Word are some other possibilities.</p>
</div>
<div class="section" id="wiki-formats">
<h3>Wiki formats<a class="headerlink" href="#wiki-formats" title="Permalink to this headline">¶</a></h3>
<p>A range of wiki formats are popular for creating notes on the web,
especially documents which allow groups of people to edit and evolve
the content. Apart from <a class="reference external" href="http://www.mediawiki.org/wiki/MediaWiki">MediaWiki</a> (the wiki format used for
Wikipedia), wiki formats have no support for mathematical typesetting
and also limited tools for displaying computer code in nice ways.
Wiki formats are therefore less suitable for scientific reports compared
to the other formats mentioned here.</p>
</div>
<div class="section" id="doconce">
<h3>Doconce<a class="headerlink" href="#doconce" title="Permalink to this headline">¶</a></h3>
<p>Since it is difficult to choose the right tool or format for writing
a scientific report, it is advantageous to write the content in a
format that easily can be translated to LaTeX, HTML, Sphinx, Markdown,
and wikis. <a class="reference external" href="http://code.google.com/p/doconce">Doconce</a> is such
a tool. It is similar to Pandoc, but offers some special convenient
features for writing about mathematics and programming.
The tagging is modest, <a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/report.do.txt.html">somewhere between LaTeX and Markdown</a>.</p>
<p>The HTML, LaTeX PDF, Sphinx, and Doconce formats for the scientific
report whose content is outlined above, are exemplified
with source codes and results at the <a class="reference external" href="http://hplgit.github.com/INF5620/doc/writing_reports/">web pages associated with this
teaching material</a>.</p>
</div>
</div>
<div class="section" id="publishing-a-complete-project">
<span id="decay-exper-github"></span><h2>Publishing a complete project<a class="headerlink" href="#publishing-a-complete-project" title="Permalink to this headline">¶</a></h2>
<p>A report documenting scientific investigations should be accompanied by
all the software and data used for the investigations so that others
have a possibility to redo the work and assess the qualify of the results.
This possibility is important for <em>reproducible research</em> and
hence reaching reliable scientific conclusions.</p>
<p>One way of documenting a complete project is to make a folder tree
with all relevant files. Preferably, the tree is published at
some project hosting site like <a class="reference external" href="http://hplgit.github.com/teamods/bitgit/html/">Bitbucket, GitHub, or Googlecode</a> so that others can download it
as a tarfile, zipfile, or clone the files directly using a version control
system like Mercurial or Git.
For the investigations outlined in the section <a class="reference internal" href="#decay-exper-report"><em>Making a report</em></a>,
we can create a folder tree with files</p>
<div class="highlight-py"><div class="highlight"><pre><span class="n">src</span><span class="o">/</span><span class="n">dc_exper1_mathjax</span><span class="o">.</span><span class="n">py</span>
<span class="n">doc</span><span class="o">/</span><span class="n">report</span><span class="o">.</span><span class="n">html</span>
<span class="n">doc</span><span class="o">/</span><span class="n">run</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">run.sh</span></tt> file is a simple Bash script listing the <tt class="docutils literal"><span class="pre">python</span></tt> command
we used to generate the experiments that are documented in <tt class="docutils literal"><span class="pre">report.html</span></tt>.</p>
</div>
</div>
<div class="section" id="exercises">
<h1>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-1-experiment-with-integer-division">
<span id="decay-exer-intdiv"></span><h2>Exercise 1: Experiment with integer division<a class="headerlink" href="#exercise-1-experiment-with-integer-division" title="Permalink to this headline">¶</a></h2>
<p>Explain what happens in the following computations, where
some are (mathematically) unexpected:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="n">dt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Filename: <tt class="docutils literal"><span class="pre">pyproblems.txt</span></tt>.</p>
</div>
<div class="section" id="exercise-2-experiment-with-wrong-computations">
<span id="decay-exer-decay1err"></span><h2>Exercise 2: Experiment with wrong computations<a class="headerlink" href="#exercise-2-experiment-with-wrong-computations" title="Permalink to this headline">¶</a></h2>
<p>Consider the <tt class="docutils literal"><span class="pre">solver</span></tt> function in the <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_v1.py">dc_v1.py</a>
and the following call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The output becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span><span class="o">=</span> <span class="mf">0.000</span> <span class="n">u</span><span class="o">=</span><span class="mi">1</span>
<span class="n">t</span><span class="o">=</span> <span class="mf">2.000</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span>
<span class="n">t</span><span class="o">=</span> <span class="mf">4.000</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span>
<span class="n">t</span><span class="o">=</span> <span class="mf">6.000</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span>
</pre></div>
</div>
<p>Print out the result of all intermediate computations and use
<tt class="docutils literal"><span class="pre">type(v)</span></tt> to see the object type of the result stored in <tt class="docutils literal"><span class="pre">v</span></tt>.
Examine the intermediate calculations and explain
why <tt class="docutils literal"><span class="pre">u</span></tt> is wrong and why we compute up to <span class="math">\(t=6\)</span> only even though we
specified <span class="math">\(T=7\)</span>.
Filename: <tt class="docutils literal"><span class="pre">dc_v1_err.py</span></tt>.</p>
</div>
<div class="section" id="exercise-3-implement-specialized-functions">
<span id="decay-exer-febecn"></span><h2>Exercise 3: Implement specialized functions<a class="headerlink" href="#exercise-3-implement-specialized-functions" title="Permalink to this headline">¶</a></h2>
<p>Implement a specialized Python function <tt class="docutils literal"><span class="pre">ForwardEuler</span></tt> that solves
the problem <span class="math">\(u'=-au\)</span>, <span class="math">\(u(0)=I\)</span>, using the Forward Euler method.
Do not reimplement the solution algorithm, but let the <tt class="docutils literal"><span class="pre">ForwardEuler</span></tt>
function call the <tt class="docutils literal"><span class="pre">solver</span></tt> function. Import this latter function
from the module <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_mod.py">dc_mod</a>.
Also make similar functions <tt class="docutils literal"><span class="pre">BackwardEuler</span></tt> and <tt class="docutils literal"><span class="pre">CrankNicolson</span></tt>.
Filename: <tt class="docutils literal"><span class="pre">dc_FE_BE_CN.py</span></tt>.</p>
</div>
<div class="section" id="exercise-4-plot-the-error-function">
<span id="decay-exer-plot-error"></span><h2>Exercise 4: Plot the error function<a class="headerlink" href="#exercise-4-plot-the-error-function" title="Permalink to this headline">¶</a></h2>
<p>Solve the problem <span class="math">\(u'=-au\)</span>, <span class="math">\(u(0)=I\)</span>, using the Forward Euler, Backward
Euler, and Crank-Nicolson schemes. For each scheme, plot the error function
<span class="math">\(e_n = u_{\small\mbox{e}}(t_n)-u^n\)</span> for <span class="math">\(\Delta t\)</span>, <span class="math">\(\frac{1}{4}\Delta t\)</span>, and
<span class="math">\(\frac{1}{8}\Delta t\)</span>, where <span class="math">\(u_{\small\mbox{e}}\)</span> is the exact solution of the ODE and
<span class="math">\(u^n\)</span> is the numerical solution at mesh point <span class="math">\(t_n\)</span>.
Filename: <tt class="docutils literal"><span class="pre">decay_plot_error.py</span></tt>.</p>
</div>
<div class="section" id="exercise-5-compare-methods-for-a-give-time-mesh">
<span id="decay-exer-plot-dtconst"></span><h2>Exercise 5: Compare methods for a give time mesh<a class="headerlink" href="#exercise-5-compare-methods-for-a-give-time-mesh" title="Permalink to this headline">¶</a></h2>
<p>Make a program that imports the <tt class="docutils literal"><span class="pre">solver</span></tt> function from the
<tt class="docutils literal"><span class="pre">dc_mod</span></tt> module and offers a function <tt class="docutils literal"><span class="pre">compare(dt,</span> <span class="pre">I,</span> <span class="pre">a)</span></tt> for
comparing, in a plot, the methods corresponding to <span class="math">\(\theta=0,0.5,1\)</span>
and the exact solution.  This plot shows the accuracy of the methods
for a given time mesh. Read input data for the problem from the
command line using appropriate functions in the <tt class="docutils literal"><span class="pre">dc_mod</span></tt> module
(the <tt class="docutils literal"><span class="pre">--dt</span></tt> option for giving several time step values can be reused:
just use the first time step value for the computations).
Filename: <tt class="docutils literal"><span class="pre">decay_compare_theta.py</span></tt>.</p>
</div>
<div class="section" id="exercise-6-change-formatting-of-numbers-and-debug">
<span id="decay-exer-inexact-output"></span><h2>Exercise 6: Change formatting of numbers and debug<a class="headerlink" href="#exercise-6-change-formatting-of-numbers-and-debug" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://github.hplgit.com/INF5620/src/decay/dc_memsave.py">dc_memsave.py</a> program
writes the time values and solution values to a file which looks
like</p>
<div class="highlight-py"><div class="highlight"><pre><span class="mf">0.0000000000000000E+00</span>  <span class="mf">1.0000000000000000E+00</span>
<span class="mf">2.0000000000000001E-01</span>  <span class="mf">8.3333333333333337E-01</span>
<span class="mf">4.0000000000000002E-01</span>  <span class="mf">6.9444444444444453E-01</span>
<span class="mf">6.0000000000000009E-01</span>  <span class="mf">5.7870370370370383E-01</span>
<span class="mf">8.0000000000000004E-01</span>  <span class="mf">4.8225308641975323E-01</span>
<span class="mf">1.0000000000000000E+00</span>  <span class="mf">4.0187757201646102E-01</span>
<span class="mf">1.2000000000000000E+00</span>  <span class="mf">3.3489797668038418E-01</span>
<span class="mf">1.3999999999999999E+00</span>  <span class="mf">2.7908164723365347E-01</span>
</pre></div>
</div>
<p>Modify the file output such that it looks like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">0.000</span>  <span class="mf">1.00000</span>
<span class="mf">0.200</span>  <span class="mf">0.83333</span>
<span class="mf">0.400</span>  <span class="mf">0.69444</span>
<span class="mf">0.600</span>  <span class="mf">0.57870</span>
<span class="mf">0.800</span>  <span class="mf">0.48225</span>
<span class="mf">1.000</span>  <span class="mf">0.40188</span>
<span class="mf">1.200</span>  <span class="mf">0.33490</span>
<span class="mf">1.400</span>  <span class="mf">0.27908</span>
</pre></div>
</div>
<p>Run</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay8_v2.py --T 10 --theta 1 --dt 0.2 --makeplot</span>
</pre></div>
</div>
<p>The program just prints <tt class="docutils literal"><span class="pre">Bug</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">implementation!</span></tt> and does not
show the plot. What went wrong?
Filename: <tt class="docutils literal"><span class="pre">dc_memsave_v2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-7-write-a-doctest">
<span id="decay-exer-doctest1"></span><h2>Exercise 7: Write a doctest<a class="headerlink" href="#exercise-7-write-a-doctest" title="Permalink to this headline">¶</a></h2>
<p>Type in the following program and equip the <tt class="docutils literal"><span class="pre">roots</span></tt> function with a doctest:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="c"># This sqrt(x) returns real if x&gt;0 and complex if x&lt;0</span>
<span class="kn">from</span> <span class="nn">numpy.lib.scimath</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the roots of the quadratic polynomial</span>
<span class="sd">    p(x) = a*x**2 + b*x + c.</span>

<span class="sd">    The roots are real or complex objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
<span class="k">print</span> <span class="n">roots</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>Make sure to test both real and complex roots.
Write out numbers with 14 digits or less.
Filename: <tt class="docutils literal"><span class="pre">doctest_roots.py</span></tt>.</p>
</div>
<div class="section" id="exercise-8-write-a-nose-test">
<span id="decay-exer-nosetest1"></span><h2>Exercise 8: Write a nose test<a class="headerlink" href="#exercise-8-write-a-nose-test" title="Permalink to this headline">¶</a></h2>
<p>Make a nose test for the <tt class="docutils literal"><span class="pre">roots</span></tt> function in <a class="reference internal" href="#decay-exer-doctest1"><em>Exercise 7: Write a doctest</em></a>.
Filename: <tt class="docutils literal"><span class="pre">test_roots.py</span></tt>.</p>
</div>
<div class="section" id="exercise-9-make-a-module">
<span id="decay-exer-module1"></span><h2>Exercise 9: Make a module<a class="headerlink" href="#exercise-9-make-a-module" title="Permalink to this headline">¶</a></h2>
<p>Let</p>
<div class="math">
\[q(t) = \frac{RAe^{at}}{R + A(e^{at} - 1)}
\thinspace .\]</div>
<p>Make a Python module <tt class="docutils literal"><span class="pre">q_module</span></tt> containing two functions <tt class="docutils literal"><span class="pre">q(t)</span></tt> and
<tt class="docutils literal"><span class="pre">dqdt(t)</span></tt> for computing <span class="math">\(q(t)\)</span> and <span class="math">\(q'(t)\)</span>, respectively. Perform a
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></tt> in this module. Import <tt class="docutils literal"><span class="pre">q</span></tt> and <tt class="docutils literal"><span class="pre">dqdt</span></tt> in another
file using the &#8220;star import&#8221; construction <tt class="docutils literal"><span class="pre">from</span> <span class="pre">q_module</span> <span class="pre">import</span>
<span class="pre">*</span></tt>. All objects available in this file is given by <tt class="docutils literal"><span class="pre">dir()</span></tt>. Print
<tt class="docutils literal"><span class="pre">dir()</span></tt> and <tt class="docutils literal"><span class="pre">len(dir())</span></tt>.  Then change the import of <tt class="docutils literal"><span class="pre">numpy</span></tt> in
<tt class="docutils literal"><span class="pre">q_module.py</span></tt> to <tt class="docutils literal"><span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></tt>. What is the effect of this
import on the number of objects in <tt class="docutils literal"><span class="pre">dir()</span></tt> in a file that does <tt class="docutils literal"><span class="pre">from</span>
<span class="pre">q_module</span> <span class="pre">import</span> <span class="pre">*</span></tt>?</p>
<p>Filename: <tt class="docutils literal"><span class="pre">q_module.py</span></tt>.</p>
</div>
<div class="section" id="exercise-10-make-use-of-a-class-implementation">
<span id="decay-exer-dc-class-exper"></span><h2>Exercise 10: Make use of a class implementation<a class="headerlink" href="#exercise-10-make-use-of-a-class-implementation" title="Permalink to this headline">¶</a></h2>
<p>We want to solve the exponential decay problem <span class="math">\(u'=-au\)</span>, <span class="math">\(u(0)=I\)</span>,
for several <span class="math">\(\Delta t\)</span> values and <span class="math">\(\theta=0,0.5,1\)</span>.
For each <span class="math">\(\Delta t\)</span> value, we want to make a plot where the
three solutions corresponding to <span class="math">\(\theta=0,0.5,1\)</span> appear along with
the exact solution.
Write a function <tt class="docutils literal"><span class="pre">experiment</span></tt> to accomplish this. The function should
import the classes <tt class="docutils literal"><span class="pre">Problem</span></tt>, <tt class="docutils literal"><span class="pre">Solver</span></tt>, and <tt class="docutils literal"><span class="pre">Visualizer</span></tt> from the
<a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_class.py">decay_class1</a>
module and make use of these. A new command-line option <tt class="docutils literal"><span class="pre">--dt_values</span></tt>
must be added to allow the user to specify the <span class="math">\(\Delta t\)</span> values on
the command line (the options <tt class="docutils literal"><span class="pre">--dt</span></tt> and <tt class="docutils literal"><span class="pre">--theta</span></tt> have then no effect
when running the <tt class="docutils literal"><span class="pre">experiment</span></tt> function).
Note that the classes in the <tt class="docutils literal"><span class="pre">decay_class1</span></tt> module should <em>not</em> be
modified.
Filename: <tt class="docutils literal"><span class="pre">dc_class_exper.py</span></tt>.</p>
</div>
</div>
<div class="section" id="analysis-of-the-rule-for-a-decay-ode">
<span id="decay-analysis"></span><h1>Analysis of the <span class="math">\(\theta\)</span>-rule for a decay ODE<a class="headerlink" href="#analysis-of-the-rule-for-a-decay-ode" title="Permalink to this headline">¶</a></h1>
<p>We address the ODE for exponential decay,</p>
<div class="math">
\[u'(t) = -au(t),\quad u(0)=I,\]</div>
<p>where <span class="math">\(a\)</span> and <span class="math">\(I\)</span> are given constants. This problem is solved
by the <span class="math">\(\theta\)</span>-rule finite difference scheme, resulting in
the recursive equations</p>
<div class="math" id="equation-decay:analysis:scheme">
<span class="eqno">(29)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n\]</div>
<p>for the numerical solution <span class="math">\(u^{n+1}\)</span>, which approximates the exact
solution <span class="math">\(u_{\small\mbox{e}}\)</span> at time point <span class="math">\(t_{n+1}\)</span>. For constant mesh spacing,
which we assume here, <span class="math">\(t_{n+1}=(n+1)\Delta t\)</span>.</p>
<div class="section" id="discouraging-numerical-solutions">
<h2>Discouraging numerical solutions<a class="headerlink" href="#discouraging-numerical-solutions" title="Permalink to this headline">¶</a></h2>
<p>Choosing <span class="math">\(I=1\)</span>, <span class="math">\(a=2\)</span>, and running experiments with <span class="math">\(\theta =1,0.5, 0\)</span>
for <span class="math">\(\Delta t=1.25, 0.75, 0.5, 0.1\)</span>, gives the results in
Figures <a class="reference internal" href="#decay-analysis-be4c"><em>Backward Euler</em></a>, <a class="reference internal" href="#decay-analysis-cn4c"><em>Crank-Nicolson</em></a>, and
<a class="reference internal" href="#decay-analysis-fe4c"><em>Forward Euler</em></a>.</p>
<div class="figure" id="decay-analysis-be4c">
<img alt="_images/BE4c.png" src="_images/BE4c.png" style="width: 600px;" />
<p class="caption"><em>Backward Euler</em></p>
</div>
<div class="figure" id="decay-analysis-cn4c">
<img alt="_images/CN4c.png" src="_images/CN4c.png" style="width: 600px;" />
<p class="caption"><em>Crank-Nicolson</em></p>
</div>
<div class="figure" id="decay-analysis-fe4c">
<img alt="_images/FE4c.png" src="_images/FE4c.png" style="width: 600px;" />
<p class="caption"><em>Forward Euler</em></p>
</div>
<p>The characteristics of the displayed curves can be summarized as follows:</p>
<blockquote>
<div><ul class="simple">
<li>The Backward Euler scheme always give a monotone solution, lying above
the exact curve.</li>
<li>The Crank-Nicolson scheme gives the most accurate results, but for
<span class="math">\(\Delta t=1.25\)</span> the solution oscillates.</li>
<li>The Forward Euler scheme gives a growing, oscillating solution for
<span class="math">\(\Delta t=1.25\)</span>; a decaying, oscillating solution for <span class="math">\(\Delta t=0.75\)</span>;
a strange solution <span class="math">\(u^n=0\)</span> for <span class="math">\(n\geq 1\)</span> when <span class="math">\(\Delta t=0.5\)</span>; and
a solution seemingly as accurate as the one by the Backward Euler
scheme for <span class="math">\(\Delta t = 0.1\)</span>, but the curve lies below the exact
solution.</li>
</ul>
</div></blockquote>
<p>Since the exact solution of our model problem is a monotone function,
<span class="math">\(u(t)=Ie^{-at}\)</span>, some of these qualitatively wrong results are indeed alarming!</p>
</div>
<div class="section" id="experimental-investigation-of-oscillatory-solutions">
<h2>Experimental investigation of oscillatory solutions<a class="headerlink" href="#experimental-investigation-of-oscillatory-solutions" title="Permalink to this headline">¶</a></h2>
<p>We may ask the question: Under what circumstances, i.e., values of
the input data <span class="math">\(I\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(\Delta t\)</span> will the Forward Euler and
Crank-Nicolson schemes result in undesired oscillatory solutions?</p>
<p>We may set up an experiment where we loop over values of <span class="math">\(I\)</span>, <span class="math">\(a\)</span>,
and <span class="math">\(\Delta t\)</span>. For each experiment, we flag the solution as
oscillatory if</p>
<div class="math">
\[\begin{split}u^{n} &gt; u^{n-1},\end{split}\]</div>
<p>for some value of <span class="math">\(n\)</span>,
since we expect <span class="math">\(u^n\)</span> to decay with <span class="math">\(n\)</span>, but oscillations make
<span class="math">\(u\)</span> increase over a time step. We will quickly see that
oscillations are independent of <span class="math">\(I\)</span>, but do depend on <span class="math">\(a\)</span> and
<span class="math">\(\Delta t\)</span>. Therefore, we introduce a two-dimensional
function <span class="math">\(B(a,\Delta t)\)</span> which is 1 if oscillations occur
and 0 otherwise. We can visualize <span class="math">\(B\)</span> as a contour plot
(lines for which <span class="math">\(B=\hbox{const}\)</span>). The contour <span class="math">\(B=0.5\)</span> will
correspond to the borderline between oscillatory regions with <span class="math">\(B=1\)</span>
and monotone regions with <span class="math">\(B=0\)</span> in the <span class="math">\(a-\Delta t\)</span> plane.</p>
<p>The <span class="math">\(B\)</span> function is defined at discrete <span class="math">\(a\)</span> and <span class="math">\(\Delta t\)</span> values.
Say we have given <span class="math">\(P\)</span> $a$ values, <span class="math">\(a_0,\ldots,a_{P-1}\)</span>, and
<span class="math">\(Q\)</span> $Delta t$ values, <span class="math">\(\Delta t_0,\ldots,\Delta t_{Q-1}\)</span>.
These <span class="math">\(a_i\)</span> and <span class="math">\(\Delta t_j\)</span> values, <span class="math">\(i=0,\ldots,P-1\)</span>,
<span class="math">\(j=0,\ldots,Q-1\)</span>, form a rectangular mesh of <span class="math">\(P\times Q\)</span> points
in the plane. At each point <span class="math">\((a_i, \Delta t_j)\)</span>, we associate
the corresponding value of <span class="math">\(B(a_i,\Delta t_j)\)</span>, denoted <span class="math">\(B_{ij}\)</span>.
The <span class="math">\(B_{ij}\)</span> values are naturally stored in a two-dimensional
array. Both Matplotlib and SciTools can create a plot of the
contour line <span class="math">\(B_{ij}=0.5\)</span> dividing the oscillatory and monotone
regions. The file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_osc_regions.py">dc_osc_regions.py</a> contains all nuts and
bolts to produce the <span class="math">\(B=0.5\)</span> line in Figures <a class="reference internal" href="#decay-analysis-b-fe"><em>Forward Euler scheme: oscillatory solutions occur for points above the curve</em></a>
and <a class="reference internal" href="#decay-analysis-b-cn"><em>Crank-Nicolson scheme: oscillatory solutions occur for points above the curve</em></a>. The oscillatory region is above this line.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dc_mod</span> <span class="kn">import</span> <span class="n">solver</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">st</span>

<span class="k">def</span> <span class="nf">non_physical_behavior</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given lists/arrays a and dt, and numbers I, dt, and theta,</span>
<span class="sd">    make a two-dimensional contour line B=0.5, where B=1&gt;0.5</span>
<span class="sd">    means oscillatory (unstable) solution, and B=0&lt;0.5 means</span>
<span class="sd">    monotone solution of u&#39;=-au.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># must be arrays</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>         <span class="c"># results</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)):</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">theta</span><span class="p">)</span>
            <span class="c"># Does u have the right monotone decay properties?</span>
            <span class="n">correct_qualitative_behavior</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c"># Not decaying?</span>
                    <span class="n">correct_qualitative_behavior</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>  <span class="c"># Jump out of loop</span>
            <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">correct_qualitative_behavior</span><span class="p">)</span>
    <span class="n">a_</span><span class="p">,</span> <span class="n">dt_</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">ndgrid</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c"># make mesh of a and dt values</span>
    <span class="n">st</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">a_</span><span class="p">,</span> <span class="n">dt_</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">);</span> <span class="n">st</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;dt&#39;</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;osc_region_theta_</span><span class="si">%s</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;osc_region_theta_</span><span class="si">%s</span><span class="s">.eps&#39;</span> <span class="o">%</span> <span class="n">theta</span><span class="p">)</span>

<span class="n">non_physical_behavior</span><span class="p">(</span>
    <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span>
    <span class="n">dt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span>
    <span class="n">T</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure" id="decay-analysis-b-fe">
<img alt="_images/osc_region_FE.png" src="_images/osc_region_FE.png" style="width: 500px;" />
<p class="caption"><em>Forward Euler scheme: oscillatory solutions occur for points above the curve</em></p>
</div>
<div class="figure" id="decay-analysis-b-cn">
<img alt="_images/osc_region_CN.png" src="_images/osc_region_CN.png" style="width: 500px;" />
<p class="caption"><em>Crank-Nicolson scheme: oscillatory solutions occur for points above the curve</em></p>
</div>
<p>By looking at the curves in the figures one may guess that <span class="math">\(a\Delta t\)</span>
must be less than a critical limit to avoid the undesired
oscillations.  This limit seems to be about 2 for Crank-Nicolson and 1
for Forward Euler.  We shall now establish a mathematical analysis of
the discrete model that can explain the observations in our numerical
experiments.</p>
</div>
<div class="section" id="exact-numerical-solution">
<h2>Exact numerical solution<a class="headerlink" href="#exact-numerical-solution" title="Permalink to this headline">¶</a></h2>
<p>Starting with <span class="math">\(u^0=I\)</span>, the simple recursion <a href="#equation-decay:analysis:scheme">(29)</a>
can be applied repeatedly <span class="math">\(n\)</span> times, with the result that</p>
<div class="math" id="equation-decay:analysis:unex">
<span class="eqno">(30)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n\thinspace .\]</div>
<p>Difference equations where all terms are linear in
<span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and maybe <span class="math">\(u^{n-1}\)</span>, <span class="math">\(u^{n-2}\)</span>, etc., are
called <em>homogeneous, linear</em> difference equations, and their solutions
are generally of the form <span class="math">\(u^n=A^n\)</span>. Inserting this expression
and dividing by <span class="math">\(A^{n+1}\)</span> gives
a polynomial equation in <span class="math">\(A\)</span>. In the present case we get</p>
<div class="math">
\[A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}\thinspace .\]</div>
<p>This is a solution technique of wider applicability than repeated use of
the recursion <a href="#equation-decay:analysis:scheme">(29)</a>.</p>
<p>Regardless of the solution approach, we have obtained a formula for
<span class="math">\(u^n\)</span>.  This formula can explain everything what we see in the figures
above, but it also gives us a more general insight into accuracy and
stability properties of the three schemes.</p>
</div>
<div class="section" id="stability">
<h2>Stability<a class="headerlink" href="#stability" title="Permalink to this headline">¶</a></h2>
<p id="index-54">Since <span class="math">\(u^n\)</span> is a factor</p>
<div class="math">
\[A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}\]</div>
<p>raised to an integer power (<span class="math">\(n\)</span>), we realize that <span class="math">\(A&lt;0\)</span>
will for odd powers imply <span class="math">\(u^n&lt;0\)</span> and for even power result in <span class="math">\(u^n&gt;0\)</span>,
i.e., a solution that oscillates between the mesh points.
We have that <span class="math">\(A&lt;0\)</span> when</p>
<div class="math" id="equation-decay:th:stability">
<span class="eqno">(31)</span>\[\begin{split}     (1-\theta)a\Delta t &gt; 1 \thinspace .\end{split}\]</div>
<p>Since <span class="math">\(A&gt;0\)</span> is a requirement for having a numerical solution with the
same basic property (monotonicity) as the exact solution, we may say
that <span class="math">\(A&gt;0\)</span> is a <em>stability criterion</em>. Expressed in terms of <span class="math">\(\Delta t\)</span>
the stability criterion reads</p>
<div class="math">
\[\Delta t \leq \frac{1}{(1-\theta)a}\thinspace .\]</div>
<p>The Backward
Euler scheme is always stable (since <span class="math">\(A&lt;0\)</span> is impossible), while
non-oscillating solutions for Forward Euler and Crank-Nicolson
demand <span class="math">\(\Delta t\leq 1/a\)</span> and <span class="math">\(\Delta t\leq 2/a\)</span>, respectively.
The relation between <span class="math">\(\Delta t\)</span> and <span class="math">\(a\)</span> look reasonable: a smaller
<span class="math">\(a\)</span> means faster decay and hence a need for smaller time steps.</p>
<p>Looking at Figure <a class="reference internal" href="#decay-analysis-fe4c"><em>Forward Euler</em></a>, we see that with <span class="math">\(a\Delta
t= 2\cdot 1.25=2.5\)</span>, <span class="math">\(A=-1.5\)</span>, and the solution <span class="math">\(u^n=(-1.5)^n\)</span>
oscillates <em>and</em> grows. With <span class="math">\(a\Delta t = 2\cdot 0.75=1.5\)</span>, <span class="math">\(A=-0.5\)</span>,
<span class="math">\(u^n=(-0.5)^n\)</span> decays but oscillates. The peculiar case <span class="math">\(\Delta t =
0.5\)</span>, where the Forward Euler scheme produces a solution that is stuck
on the <span class="math">\(t\)</span> axis, corresponds to <span class="math">\(A=0\)</span> and therefore <span class="math">\(u^0=I=1\)</span> and
<span class="math">\(u^n=0\)</span> for <span class="math">\(n\geq 1\)</span>.  The decaying oscillations in the Crank-Nicolson scheme
for <span class="math">\(\Delta t=1.25\)</span> is easily explained by <span class="math">\(A=-0.25\)</span>.</p>
<p id="index-55">The factor <span class="math">\(A\)</span> is called <em>amplification factor</em> since the solution at
a new time level is <span class="math">\(A\)</span> times the solution at the previous time level. For
a decay process, we must obviously have <span class="math">\(|A|\leq 1\)</span> for all <span class="math">\(\Delta
t\)</span>, which is fulfilled for <span class="math">\(\theta \geq 1/2\)</span>. Arbitrarily large values
of <span class="math">\(u\)</span> can be generated when <span class="math">\(|A|&gt;1\)</span> and <span class="math">\(n\)</span> is large enough. The
numerical solution is in such cases totally irrelevant to an ODE modeling decay
processes.</p>
</div>
<div class="section" id="comparing-amplification-factors">
<h2>Comparing Amplification Factors<a class="headerlink" href="#comparing-amplification-factors" title="Permalink to this headline">¶</a></h2>
<p>After establishing how <span class="math">\(A\)</span> impacts the qualitative features of the
solution, we shall now look more into how well the numerical amplification
factor approximates the exact one. The exact solution reads
<span class="math">\(u(t)=Ie^{-at}\)</span>, which can be rewritten as</p>
<div class="math">
\[{u_{\small\mbox{e}}}(t_n) = Ie^{-a n\Delta t} = I(e^{-a\Delta t})^n \thinspace .\]</div>
<p>From this formula we see that the exact amplification factor is</p>
<div class="math">
\[A_{\small\mbox{e}} = e^{-a\Delta t} \thinspace .\]</div>
<p>We realize that the exact and numerical amplification factors depend
on <span class="math">\(a\)</span> and <span class="math">\(\Delta t\)</span> through the product <span class="math">\(a\Delta t\)</span>. Therefore, it
is convenient to introduce a symbol for this product, <span class="math">\(p=a\Delta t\)</span>,
and view <span class="math">\(A\)</span> and <span class="math">\(A_{\small\mbox{e}}\)</span> as functions of <span class="math">\(p\)</span>. Figure
<a class="reference internal" href="#decay-analysis-fig-a"><em>Comparison of amplification factors</em></a> shows these functions. Crank-Nicolson is
clearly closest to the exact amplification factor, but that method has
the unfortunate oscillatory behavior when <span class="math">\(p&gt;2\)</span>.</p>
<div class="figure" id="decay-analysis-fig-a">
<img alt="_images/A_factors.png" src="_images/A_factors.png" style="width: 500px;" />
<p class="caption"><em>Comparison of amplification factors</em></p>
</div>
</div>
<div class="section" id="series-expansion-of-amplification-factors">
<h2>Series Expansion of Amplification Factors<a class="headerlink" href="#series-expansion-of-amplification-factors" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to the visual understanding
inherent in Figure <a class="reference internal" href="#decay-analysis-fig-a"><em>Comparison of amplification factors</em></a>, there
is a strong tradition in numerical analysis to investigate
approximation errors when the discretization parameter, here <span class="math">\(\Delta t\)</span>,
becomes small. In the present case we let <span class="math">\(p\)</span> be our small
discretization parameter, and it makes sense to simplify the
expressions for <span class="math">\(A\)</span> and <span class="math">\(A_{\small\mbox{e}}\)</span> by using Taylor polynomials around <span class="math">\(p=0\)</span>.
The Taylor polynomials are accurate for small <span class="math">\(p\)</span> and greatly simplifies
the comparison of the analytical expressions since we then can compare
polynomials, term by term.</p>
<p>Calculating the Taylor series for <span class="math">\(A_{\small\mbox{e}}\)</span> is easily done by hand, but
the three versions of <span class="math">\(A\)</span> for <span class="math">\(\theta=0,1,\frac{1}{2}\)</span> lead to more
cumbersome calculations.
Nowadays, analytical computations can benefit greatly by
symbolic computer algebra software. The Python package <tt class="docutils literal"><span class="pre">sympy</span></tt>
represents a powerful computer algebra system, not as sophisticated as
the famous Maple and Mathematica systems, but free and
very easy to integrate with our numerical computations in Python.</p>
<p>When using <tt class="docutils literal"><span class="pre">sympy</span></tt>, it is convenient to enter the interactive Python
mode where we can write expressions and statements and immediately see
the results.  Here is a simple example. We strongly recommend to use
<tt class="docutils literal"><span class="pre">isympy</span></tt> (or <tt class="docutils literal"><span class="pre">ipython</span></tt>) for such interactive sessions, although our
typesetting will apply the different prompt <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> (associated with the
primitive Python shell that results from writing <tt class="docutils literal"><span class="pre">python</span></tt> in a
terminal window).</p>
<p>Let us enter <tt class="docutils literal"><span class="pre">sympy</span></tt> in a Python shell and show how
we can find the Taylor series for <span class="math">\(e^{-p}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">)</span>  <span class="c"># all variables must be declared as Symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_e</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># First 6 terms of the Taylor series of A_e</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">1 + (1/2)*p**2 - p - 1/6*p**3 - 1/120*p**5 + (1/24)*p**4 + O(p**6)</span>
</pre></div>
</div>
<p>Lines with <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> represent input lines and lines without
this prompt represents the result of computations.
Apart from the order of the powers, the computed formula is easily
recognized as the beginning of the Taylor series for <span class="math">\(e^{-p}\)</span>.</p>
<p>Let us define the numerical amplification factor where <span class="math">\(p\)</span> and <span class="math">\(\theta\)</span>
enter the formula as symbols:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;theta&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">theta</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>To work with the factor for the Backward Euler scheme we
can substitute the value 1 for <tt class="docutils literal"><span class="pre">theta</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1/(1 + p)</span>
</pre></div>
</div>
<p>Similarly, we can substitute <tt class="docutils literal"><span class="pre">theta</span></tt> by 1/2 for Crank-Nicolson,
preferably using an exact rational representation of 1/2 in <tt class="docutils literal"><span class="pre">sympy</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">half</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>
<span class="go">1/(1 + (1/2)*p)*(1 - 1/2*p)</span>
</pre></div>
</div>
<p>The Taylor series of the amplification factor for the Crank-Nicolson
scheme can be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1 + (1/2)*p**2 - p - 1/4*p**3 + O(p**4)</span>
</pre></div>
</div>
<p>We are now in a position to compare Taylor series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">FE</span> <span class="o">=</span> <span class="n">A_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BE</span> <span class="o">=</span> <span class="n">A_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span> <span class="o">=</span> <span class="n">A_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FE</span>
<span class="go">(1/2)*p**2 - 1/6*p**3 + O(p**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BE</span>
<span class="go">-1/2*p**2 + (5/6)*p**3 + O(p**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span>
<span class="go">(1/12)*p**3 + O(p**4)</span>
</pre></div>
</div>
<p>From these expressions we see that the error <span class="math">\(A-A_{\small\mbox{e}}\sim {\cal O}(p^2)\)</span>
for the Forward and Backward Euler schemes, while
<span class="math">\(A-A_{\small\mbox{e}}\sim {\cal O}(p^3)\)</span> for the Crank-Nicolson scheme.
It is the <em>leading order term</em>,
i.e., the term of the lowest order (degree),
that is of interest, because as <span class="math">\(p\rightarrow 0\)</span>, this term is
(much) bigger than the higher-order terms.</p>
<p>Now, <span class="math">\(a\)</span> is a given parameter in the problem, while <span class="math">\(\Delta t\)</span> is
what we can vary. One therefore usually writes the error expressions in
terms <span class="math">\(\Delta t\)</span>. When then have</p>
<div class="math">
\[\begin{split}A-A_{\small\mbox{e}} = \left\lbrace\begin{array}{ll}
{\cal O}(\Delta t^2), &amp; \hbox{Forward and Backward Euler},\\
{\cal O}(\Delta t^3), &amp; \hbox{Crank-Nicolson}
\end{array}\right.\end{split}\]</div>
<p>What is the significance of this result? If we halve <span class="math">\(\Delta t\)</span>,
the error in amplification factor at a time level will be reduced
by a factor of 4 in the Forward and Backward Euler schemes, and by
a factor of 8 in the Crank-Nicolson scheme. That is, as we
reduce <span class="math">\(\Delta t\)</span> to obtain more accurate results, the Crank-Nicolson
scheme reduces the error more efficiently than the other schemes.</p>
</div>
<div class="section" id="local-error">
<h2>Local error<a class="headerlink" href="#local-error" title="Permalink to this headline">¶</a></h2>
<p>(max/infinity norm etc).
Both errors can be investigated analytically.]</p>
</div>
<div class="section" id="analytical-comparison-of-schemes">
<h2>Analytical comparison of schemes<a class="headerlink" href="#analytical-comparison-of-schemes" title="Permalink to this headline">¶</a></h2>
<p>An alternative comparison of the schemes is to look at the
ratio <span class="math">\(A/A_{\small\mbox{e}}\)</span>, or the error <span class="math">\(1-A/A_{\small\mbox{e}}\)</span> in this ratio:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">FE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">A_e</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">A_e</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span><span class="o">/</span><span class="n">A_e</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FE</span>
<span class="go">(1/2)*p**2 + (1/3)*p**3 + O(p**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BE</span>
<span class="go">-1/2*p**2 + (1/3)*p**3 + O(p**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span>
<span class="go">(1/12)*p**3 + O(p**4)</span>
</pre></div>
</div>
<p>The leading-order terms have the same powers as
in the analysis of <span class="math">\(A-A_{\small\mbox{e}}\)</span>.</p>
</div>
<div class="section" id="the-real-global-error-at-a-point">
<h2>The real (global) error at a point<a class="headerlink" href="#the-real-global-error-at-a-point" title="Permalink to this headline">¶</a></h2>
<p>The error in the amplification factor reflects the error when
progressing from time level <span class="math">\(t_n\)</span> to <span class="math">\(t_{n-1}\)</span>.
To investigate the real error at a point, known as the <em>global error</em>,
we look at <span class="math">\(u^n-u_{\small\mbox{e}}(t_n)\)</span> for some <span class="math">\(n\)</span> and Taylor expand the
mathematical expressions as functions of <span class="math">\(p=a\Delta t\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_e</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_n</span> <span class="o">=</span> <span class="n">A</span><span class="o">**</span><span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FE</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">u_n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BE</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">u_n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="n">u_n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FE</span>
<span class="go">(1/2)*n*p**2 - 1/2*n**2*p**3 + (1/3)*n*p**3 + O(p**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BE</span>
<span class="go">(1/2)*n**2*p**3 - 1/2*n*p**2 + (1/3)*n*p**3 + O(p**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CN</span>
<span class="go">(1/12)*n*p**3 + O(p**4)</span>
</pre></div>
</div>
<p>For a fixed time <span class="math">\(t\)</span>, the parameter <span class="math">\(n\)</span> in these expressions increases
as <span class="math">\(p\rightarrow 0\)</span> since <span class="math">\(t=n\Delta t\)</span>. That is, <span class="math">\(n=t/\Delta t\)</span>, and
the leading-order error terms therefore become <span class="math">\(\frac{1}{2}na^2\Delta
t^2 = \frac{1}{2}ta^2t\Delta t\)</span> for the Forward and Backward Euler
scheme, and <span class="math">\(\frac{1}{12}na^3\Delta t^3 = \frac{1}{12}ta^3\Delta t^2\)</span>
for the Crank-Nicolson scheme.  The global error is therefore of
second order in <span class="math">\(\Delta t\)</span> for the latter scheme and first order for
the former schemes.</p>
</div>
<div class="section" id="integrated-errors">
<h2>Integrated errors<a class="headerlink" href="#integrated-errors" title="Permalink to this headline">¶</a></h2>
<p>The formulas for various error measures have so far measured the
error at one time point. Many prefer to use the error
integrated over the whole time interval of interest: <span class="math">\([0,T]\)</span>.
An immediate practical problem arises, however, since the
numerical solution is only known at the mesh points, while an
integration will need this solution also at the points between
the mesh points. Let <span class="math">\(\tilde u\)</span> be a continuous representation
of the numerical solution, usually obtained by drawing straight
lines between the values at the mesh points. Then
a common measure of the global error is the so-called <span class="math">\(L^2\)</span> error:</p>
<div class="math">
\[E_2 = \sqrt{\int_0^T ({u_{\small\mbox{e}}}(t) - \tilde u(t))^2dt} \thinspace .\]</div>
<p>A family of such measures is the <span class="math">\(L^p\)</span> errors, defined as</p>
<div class="math">
\[E_p = \left(\int_0^T ({u_{\small\mbox{e}}}(t) - \tilde u(t))^pdt\right)^{1/p} \thinspace .\]</div>
<p>For <span class="math">\(p=1\)</span> we just take the absolute value of the integrand.</p>
<p>Strictly speaking, it is questionable in a finite difference method
to introduce an additional approximation in the error measure,
namely how <span class="math">\(\tilde u\)</span> varies
between the mesh points. Some may argue and say that the numerical
solution is defined at the mesh points only and that we should
approximate the integrals above by numerical methods involving
the integrand at just the mesh points. The numerical integration
method also represents an approximation, but a discrete integration
procedure is consistent with having only discrete values of the integrand.</p>
<p>For uniformly distributed mesh points we have the well-known Trapezoidal
rule,</p>
<div class="math" id="equation-decay:E2:Tr">
<span class="eqno">(32)</span>\[     E_2 \approx \left(\Delta t\left( \half ({u_{\small\mbox{e}}}(0) - u^0)^2
     + \half ({u_{\small\mbox{e}}}(T) - u^N)^2  + \sum_{k=1}^{N-1} ({u_{\small\mbox{e}}}(k\Delta t) - u^k)^2 \right)
     \right)^{1/2} \thinspace .\]</div>
<p>In case the mesh points are arbitrarily spaced, we have an immediate
generalization in terms of the sum of the various trapezoids:</p>
<div class="math" id="equation-decay:E2:Trg">
<span class="eqno">(33)</span>\[     E_2 \approx \left(\half\sum_{k=0}^{N-1}(t_{k+1} - t_k)
     \left( ({u_{\small\mbox{e}}}(k\Delta t) - u^k)^2 + ({u_{\small\mbox{e}}}((k+1)\Delta t) - u^{k+1})^2\right)
     \right)^{1/2} \thinspace .\]</div>
<p>A simpler approximation is to use rectangles whose heights are determined
by the left (or right) value in each interval:</p>
<div class="math" id="equation-decay:E2:Reg1">
<span class="eqno">(34)</span>\[     E_2 \approx \left(\sum_{k=0}^{N-1}(t_{k+1} - t_k)({u_{\small\mbox{e}}}(k\Delta t) - u^k)^2
     \right)^{1/2} \thinspace .\]</div>
<p>With uniformly distributed mesh points we get the simplification</p>
<div class="math" id="equation-decay:E2:Reg">
<span class="eqno">(35)</span>\[     E_2 \approx \left(\Delta t\sum_{k=0}^{N-1}({u_{\small\mbox{e}}}(k\Delta t) - u^k)^2
     \right)^{1/2} \thinspace .\]</div>
<p>Suppose that in a program the <span class="math">\(u^k\)</span> values are available as elements
in the array <tt class="docutils literal"><span class="pre">u</span></tt>, while the <span class="math">\({u_{\small\mbox{e}}}(k\Delta t)\)</span> values are available
as elements in the array <tt class="docutils literal"><span class="pre">u_e</span></tt>. The formula <a href="#equation-decay:E2:Reg">(35)</a> can
then be calculated as follows by array arithmetics in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">((</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>This is exactly the &#8220;array formula&#8221; that popped up in
the section <a class="reference internal" href="#decay-computing-error"><em>Computing the numerical error</em></a>.</p>
<p>Integrated error measures sum up the contributions from each mesh point,
so we must expect the global error to be larger than
the local error. Roughly speaking, if <span class="math">\(|u_{\small\mbox{e}}(t_n) - u^n|\sim ta^{r+1}\Delta t^r\)</span>, we have</p>
<div class="math">
\[E \approx \sqrt{\Delta t\sum_{i=0}^N i^2a^{2(r+1)}\Delta t^{2r+1}} =
\sqrt{a^{2(r+1)}\Delta t^{2r+2} \sum_i i^2} \approx
a^{r+1}\Delta t^{r+1} N^{3/2} = a^{r+1}\Delta t^{r-1/2} T^{3/2} ,\]</div>
<p>since <span class="math">\(t=i\Delta t\)</span>, <span class="math">\(\sum_{i=0}^N i^2\approx \frac{1}{3}N^3\)</span>, and
<span class="math">\(N=T/Delta t\)</span>.</p>
</div>
</div>
<div class="section" id="id20">
<h1>Exercises<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-11-explore-the-rule-for-exponential-growth">
<span id="decay-analysis-exer-growth"></span><h2>Exercise 11: Explore the <span class="math">\(\theta\)</span>-rule for exponential growth<a class="headerlink" href="#exercise-11-explore-the-rule-for-exponential-growth" title="Permalink to this headline">¶</a></h2>
<p>Solve the ODE <span class="math">\(u'=-au\)</span> with <span class="math">\(a&lt;0\)</span> such that the ODE models
exponential growth. Run experiments with <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> using
the <tt class="docutils literal"><span class="pre">dc_exper1.py</span></tt> code modified to your needs.
Are there any numerical artifacts?
Filename: <tt class="docutils literal"><span class="pre">growth_exper1.py</span></tt>.</p>
</div>
<div class="section" id="exercise-12-summarize-investigations-in-a-report">
<span id="decay-analysis-exer-growth-report"></span><h2>Exercise 12: Summarize investigations in a report<a class="headerlink" href="#exercise-12-summarize-investigations-in-a-report" title="Permalink to this headline">¶</a></h2>
<p>Write a scientific report about the findings in
<a class="reference internal" href="#decay-analysis-exer-growth"><em>Exercise 11: Explore the -rule for exponential growth</em></a>.
You can use examples from the section <a class="reference internal" href="#decay-exper-report"><em>Making a report</em></a> to
see how various formats can be used for scientific reports.
Filename: <tt class="docutils literal"><span class="pre">growth_analysis.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-13-plot-amplification-factors-for-exponential-growth">
<span id="decay-analysis-exer-growth-a"></span><h2>Exercise 13: Plot amplification factors for exponential growth<a class="headerlink" href="#exercise-13-plot-amplification-factors-for-exponential-growth" title="Permalink to this headline">¶</a></h2>
<p>Modify the <tt class="docutils literal"><span class="pre">dc_ampf_plot.py</span></tt> code to visualize the
amplification factors for <span class="math">\(\theta =0, 0.5, 1\)</span> and the exact
amplification factor in case of exponential growth as in
<a class="reference internal" href="#decay-analysis-exer-growth"><em>Exercise 11: Explore the -rule for exponential growth</em></a>.  Explain the
artifacts seen in <a class="reference internal" href="#decay-analysis-exer-growth"><em>Exercise 11: Explore the -rule for exponential growth</em></a>.
Filename: <tt class="docutils literal"><span class="pre">growth_ampf_plot.py</span></tt>.</p>
</div>
</div>
<div class="section" id="model-extensions">
<h1>Model extensions<a class="headerlink" href="#model-extensions" title="Permalink to this headline">¶</a></h1>
<p>It is time to consider generalizations of the simple decay model
<span class="math">\(u=-au\)</span>, where <span class="math">\(a\)</span> is constant, and also to look at other numerical
solution methods.</p>
<div class="section" id="extension-to-a-variable-coefficient">
<h2>Extension to a variable coefficient<a class="headerlink" href="#extension-to-a-variable-coefficient" title="Permalink to this headline">¶</a></h2>
<p>In the ODE for decay, <span class="math">\(u'=-au\)</span>, we now consider the case where <span class="math">\(a\)</span>
depends on time:</p>
<div class="math" id="equation-decay:problem:a">
<span class="eqno">(36)</span>\[     u'(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I \thinspace .\]</div>
<p>A Forward Euler scheme consist of evaluating <a href="#equation-decay:problem:a">(36)</a>
at <span class="math">\(t=t_n\)</span> and approximating the derivative with a forward
difference <span class="math">\([D^+_t u]^n\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
\thinspace .\]</div>
<p>The Backward Euler scheme becomes</p>
<div class="math">
\[\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
\thinspace .\]</div>
<p>The Crank-Nicolson method builds on sampling the ODE at
<span class="math">\(t_{n+\frac{1}{2}}\)</span>. We can evaluate <span class="math">\(a\)</span> at <span class="math">\(t_{n+\frac{1}{2}}\)</span>
and use an average for <span class="math">\(u\)</span> at
times <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\frac{1}{2}})\frac{1}{2}(u^n + u^{n+1})
\thinspace .\]</div>
<p>Alternatively, we can use an average for the product <span class="math">\(au\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -\frac{1}{2}(a(t_n)u^n + a(t_{n+1})u^{n+1})
\thinspace .\]</div>
<p>The <span class="math">\(\theta\)</span>-rule unifies the three mentioned schemes,</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
\thinspace .\]</div>
<p>or,</p>
<div class="math">
\[\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
\thinspace .\]</div>
<p>With the finite difference operator notation the Forward Euler and Backward
Euler schemes can be summarized as</p>
<div class="math">
\[\begin{split}\lbrack D^+_t u &amp;= -au\rbrack^n,\\
\lbrack D^-_t u &amp;= -au\rbrack^n
\thinspace .\end{split}\]</div>
<p>The Crank-Nicolson and <span class="math">\(\theta\)</span> schemes depend on whether we evaluate
<span class="math">\(a\)</span> at the sample point for the ODE or if we use an average. The
various versions are written as</p>
<div class="math">
\[\begin{split}\lbrack D_t u &amp;= -a\overline{u}^t\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u &amp;= -\overline{au}^t\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u &amp;= -a\overline{u}^{t,\theta}\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u &amp;= -\overline{au}^{t,\theta}\rbrack^{n+\frac{1}{2}}
\thinspace .\end{split}\]</div>
</div>
<div class="section" id="extension-to-a-source-term">
<span id="decay-source"></span><h2>Extension to a source term<a class="headerlink" href="#extension-to-a-source-term" title="Permalink to this headline">¶</a></h2>
<p>A further extension of the model ODE is to include a source term <span class="math">\(b(t)\)</span>:</p>
<div class="math" id="equation-decay:problem:ab">
<span class="eqno">(37)</span>\[     u'(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
     \thinspace .\]</div>
<div class="section" id="schemes">
<h3>Schemes<a class="headerlink" href="#schemes" title="Permalink to this headline">¶</a></h3>
<p>The time point where we sample the ODE determines where <span class="math">\(b(t)\)</span> is
evaluated. For the Crank-Nicolson scheme and the <span class="math">\(\theta\)</span>-rule we
have a choice of whether to evaluate <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> at the
correct point or use an average. The chosen strategy becomes
particularly clear if we write up the schemes in the operator notation:</p>
<div class="math">
\[\begin{split}\lbrack D^+_t u &amp;= -au + b\rbrack^n,\\
\lbrack D^-_t u &amp;= -au + b\rbrack^n,\\
\lbrack D_t u   &amp;= -a\overline{u}^t + b\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u   &amp;= \overline{-au+b}^t\rbrack^{n+\frac{1}{2}},\\
\lbrack D_t u   &amp;= -a\overline{u}^{t,\theta} + b\rbrack^{n+\theta},\\
\lbrack D_t u   &amp;= \overline{-au+b}^{t,\theta}\rbrack^{n+\theta}
\thinspace .\end{split}\]</div>
</div>
</div>
<div class="section" id="implementation-of-the-generalized-model-problem">
<span id="decay-general"></span><h2>Implementation of the generalized model problem<a class="headerlink" href="#implementation-of-the-generalized-model-problem" title="Permalink to this headline">¶</a></h2>
<div class="section" id="deriving-the-rule-formula">
<h3>Deriving the <span class="math">\(\theta\)</span>-rule formula<a class="headerlink" href="#deriving-the-rule-formula" title="Permalink to this headline">¶</a></h3>
<p>Writing out the latter <span class="math">\(\theta\)</span>-rule, using (<em class="xref std std-ref">decay:fd1:Du:theta</em>)
and (<em class="xref std std-ref">decay:fd1:wmean:a</em>), we get</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} = \theta(-a^{n+1}u^{n+1} + b^{n+1}))
+ (1-\theta)(-a^nu^{n} + b^n)),\]</div>
<p>where <span class="math">\(a^n\)</span> means evaluating <span class="math">\(a\)</span> at <span class="math">\(t=t_n\)</span> and similar for
<span class="math">\(a^{n+1}\)</span>, <span class="math">\(b^n\)</span>, and <span class="math">\(b^{n+1}\)</span>.
We solve for <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
\thinspace .\]</div>
</div>
<div class="section" id="the-python-code">
<h3>The Python code<a class="headerlink" href="#the-python-code" title="Permalink to this headline">¶</a></h3>
<p>A suitable implementation where <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> are given as
Python functions is given next.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a(t)*u + b(t), u(0)=I,</span>
<span class="sd">    for t in (0,T] with steps of dt.</span>
<span class="sd">    a and b are Python functions of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>           <span class="c"># avoid integer division</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>     <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                 <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>    <span class="c"># n=0,1,...,N-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> \
                  <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span>\
                  <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>This function is found in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_vc.py">dc_vc.py</a>.</p>
</div>
<div class="section" id="implementations-of-variable-coefficients">
<h3>Implementations of variable coefficients<a class="headerlink" href="#implementations-of-variable-coefficients" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">solver</span></tt> function shown above demands the arguments <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> to
be implemented as functions of <tt class="docutils literal"><span class="pre">t</span></tt>, say</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a_0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">tp</span> <span class="k">else</span> <span class="n">k</span><span class="o">*</span><span class="n">a_0</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">a(t)</span></tt> has three parameters <tt class="docutils literal"><span class="pre">a0</span></tt>, <tt class="docutils literal"><span class="pre">tp</span></tt>, and <tt class="docutils literal"><span class="pre">k</span></tt>,
which must be global variables.
A better implementation is to represent <tt class="docutils literal"><span class="pre">a</span></tt> by a class where the
parameters are attributes and a <em>special method</em> <tt class="docutils literal"><span class="pre">__call__</span></tt> evaluates <span class="math">\(a(t)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">a0</span><span class="p">,</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a0</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">a0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># a behaves as a function a(t)</span>
</pre></div>
</div>
<p id="index-56">For quick tests it is cumbersome to write a complete function or a class.
The <em>lambda function</em> construction in Python is then convenient. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">a_0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">tp</span> <span class="k">else</span> <span class="n">k</span><span class="o">*</span><span class="n">a_0</span>
</pre></div>
</div>
<p>is equivalent to the <tt class="docutils literal"><span class="pre">def</span> <span class="pre">a(t):</span></tt> definition above. In general,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">:</span> <span class="n">expressin</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expression</span>
</pre></div>
</div>
<p>One can use lambda functions directly in calls. Say we want to
solve <span class="math">\(u'=-u+1\)</span>, <span class="math">\(u(0)=1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>A lambda function can appear anywhere where a variable can appear.</p>
</div>
</div>
<div class="section" id="verification-via-trivial-solutions">
<span id="decay-verify-trivial"></span><h2>Verification via trivial solutions<a class="headerlink" href="#verification-via-trivial-solutions" title="Permalink to this headline">¶</a></h2>
<p>A very useful partial verification method is to construct a test
problem with a very simple solution, usually <span class="math">\(u=\hbox{const}\)</span>.
Especially the initial debugging of a program code can benefit greatly
from such tests, because 1) all relevant numerical methods will
exactly reproduce a constant solution, and 2) many of the intermediate
calculations are easy to control for a constant <span class="math">\(u\)</span>.</p>
<p>The only constant solution for the problem <span class="math">\(u'=-au\)</span>
is <span class="math">\(u=0\)</span>, but too many bugs can escape from that trivial solution.
It is much better to search for a problem where <span class="math">\(u=C=\hbox{const}\neq 0\)</span>.
Then <span class="math">\(u'=-a(t)u + b(t)\)</span> is more appropriate. With <span class="math">\(u=C\)</span>
we can choose any <span class="math">\(a(t)\)</span> and set <span class="math">\(b=a(t)C\)</span> and
<span class="math">\(I=C\)</span>. An appropriate nose test is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nose.tools</span> <span class="kn">as</span> <span class="nn">nt</span>

<span class="k">def</span> <span class="nf">test_constant_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test problem where u=u_const is the exact solution, to be</span>
<span class="sd">    reproduced (to machine precision) by any relevant method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">u_const</span>

    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">2.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c"># can be arbitrary</span>

    <span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">u_const</span>

    <span class="n">u_const</span> <span class="o">=</span> <span class="mf">2.15</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="n">u_const</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c"># enough with a few steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">u</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">difference</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>An interesting question is what type of bugs that will make the
computed <span class="math">\(u^n\)</span> to deviate from the exact solution <span class="math">\(C\)</span>.
Fortunately, the updating formula and the initial condition must
be absolutely correct for the test to pass! Any attempt to make
a wrong indexing in terms like <tt class="docutils literal"><span class="pre">a(t[n])</span></tt> or any attempt to
introduce an erroneous factor in the formula creates a solution
that is different from <span class="math">\(C\)</span>.</p>
</div>
<div class="section" id="verification-via-manufactured-solutions">
<span id="decay-mms"></span><h2>Verification via manufactured solutions<a class="headerlink" href="#verification-via-manufactured-solutions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-57"></span><p id="index-58">Following the idea of the previous section, we can choose any formula
as the exact solution, insert the formula in the ODE problem and fit
<span class="math">\(a(t)\)</span>, <span class="math">\(b(t)\)</span>, and I to make the formula fulfill the equation. This
powerful technique for generating exact solutions is very useful for
verification purposes and known as the <em>method of manufactured
solutions</em>, often abbreviated MMS.</p>
<p>One common choice of solution is a linear function in the independent
variable(s). The rationale behind such a simple variation is that
almost any relevant numerical solution method for differential
equation problems is able to reproduce the linear function exactly (to
machine precision). The linear solution also makes some stronger
demands to the numerical method and the implementation than the
constant solution used in the section <a class="reference internal" href="#decay-verify-trivial"><em>Verification via trivial solutions</em></a>, at least
in more complicated applications. However,
the constant solution is often ideal for initial debugging before
proceeding with a linear solution.</p>
<p>Let <span class="math">\(u(t) = ct + d\)</span>. We must then have <span class="math">\(d=I\)</span> from the initial condition.
Inserting this <span class="math">\(u\)</span> in the ODE results in</p>
<div class="math">
\[c = -a(t)u + b(t) \thinspace .\]</div>
<p>Any function <span class="math">\(u=ct+I\)</span> is then a correct solution if we choose</p>
<div class="math">
\[b(t) = c + a(t)(ct + I) \thinspace .\]</div>
<p>Note that there are no restrictions on <span class="math">\(a(t)\)</span> and <span class="math">\(c\)</span>.</p>
<p>The following function offers an implementation of the verification
test based on a linear exact solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_linear_solution</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test problem where u=c*t+I is the exact solution, to be</span>
<span class="sd">    reproduced (to machine precision) by any relevant method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>

    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">**</span><span class="mf">0.5</span>  <span class="c"># can be arbitrary</span>

    <span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">+</span> <span class="n">a</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">difference</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>As in the section <a class="reference internal" href="#decay-verify-trivial"><em>Verification via trivial solutions</em></a>, any error in the updating
formula makes this test fail.</p>
<p>Choosing more complicated formulas as the exact solution, say
<span class="math">\(\cos(t)\)</span>, will not make the numerical and exact solution
coincide to machine precision. In such cases, the verification procedure
must be based on measuring the convergence rates as exemplified in
the section <a class="reference internal" href="#decay-convergence-rate"><em>Computing convergence rates</em></a>. This is possible since one has
an exact solution of a problem that the solver can be tested on.</p>
</div>
<div class="section" id="extension-to-systems-of-odes">
<h2>Extension to systems of ODEs<a class="headerlink" href="#extension-to-systems-of-odes" title="Permalink to this headline">¶</a></h2>
<p>Many ODE models involves more than one unknown function and more
than one equation. Here is an example of two unknown functions <span class="math">\(u(t)\)</span>
and <span class="math">\(v(t)\)</span> (modeling, e.g., the radioactive decay of two substances):</p>
<div class="math">
\[\begin{split}u' &amp;= -a_u u + a_vv,\\
v' &amp;= -a_vv + a_uu,\end{split}\]</div>
<p>for constants <span class="math">\(a_u, a_v&gt;0\)</span>.
Applying the Forward Euler method to each equation results in simple
updating formula</p>
<div class="math">
\[\begin{split}u^{n+1} &amp;= u^n + \Delta t (-a_u u^n + a_vv^n),\\
v^{n+1} &amp;= u^n + \Delta t (-a_vv^n + a_uu^n)
\thinspace .\end{split}\]</div>
<p>However, the Crank-Nicolson or Backward Euler schemes result in a
<span class="math">\(2\times 2\)</span> linear system for the new unknowns. The latter schemes gives</p>
<div class="math">
\[\begin{split}u^{n+1} &amp;= u^n + \Delta t (-a_u u^{n+1} + a_vv^{n+1}),\\
v^{n+1} &amp;= v^n + \Delta t (-a_vv^{n+1} + a_uu^{n+1}),\end{split}\]</div>
<p>and bringing <span class="math">\(u^{n+1}\)</span> as well as <span class="math">\(v^{n+1}\)</span> on the left-hand side results
in</p>
<div class="math">
\[\begin{split}(1 + \Delta t a_u)u^{n+1} + a_vv^{n+1}) &amp;= u^n ,\\
a_uu^{n+1} + (1 + \Delta t a_v) v^{n+1} &amp;= v^n ,\end{split}\]</div>
<p>which is a system of two coupled, linear, algebraic equations in two
unknowns.</p>
</div>
</div>
<div class="section" id="general-first-order-odes">
<h1>General first-order ODEs<a class="headerlink" href="#general-first-order-odes" title="Permalink to this headline">¶</a></h1>
<p>We now turn the attention to general, nonlinear ODEs and systems of such ODEs.
Many schemes that are occasionally reused for PDEs are listed. We also
demonstrate a Python interface to a range of different software for
general first-order ODE systems.</p>
<div class="section" id="generic-form">
<h2>Generic form<a class="headerlink" href="#generic-form" title="Permalink to this headline">¶</a></h2>
<p>ODEs are commonly written in a generic form</p>
<div class="math" id="equation-decay:ode:general">
<span class="eqno">(38)</span>\[     u' = f(u,t),\quad u(0)=I,\]</div>
<p>where <span class="math">\(f(u,t)\)</span>  is a prescribed function.
As an example, our most
general exponential decay model <a href="#equation-decay:problem:ab">(37)</a> has
<span class="math">\(f(u,t)=-a(t)u(t) + b(t)\)</span>.</p>
<p>The unknown <span class="math">\(u\)</span> in <a href="#equation-decay:ode:general">(38)</a> may either be
a scalar function of time <span class="math">\(t\)</span>, or a vector valued function of <span class="math">\(t\)</span> in
case of a <em>system of ODEs</em>:</p>
<div class="math">
\[u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t)) \thinspace .\]</div>
<p>In that case, the right-hand side is vector-valued function with <span class="math">\(m\)</span>
components,</p>
<div class="math">
\[\begin{split}f(u, t) = ( &amp; f^{(0)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\
            &amp; f^{(1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)),\\
            &amp; \vdots,\\
            &amp; f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
\thinspace .\end{split}\]</div>
<p>Actually, any system of ODEs can
be written in the form <a href="#equation-decay:ode:general">(38)</a>, but higher-order
ODEs then need auxiliary unknown functions.</p>
</div>
<div class="section" id="the-odespy-software">
<h2>The Odespy software<a class="headerlink" href="#the-odespy-software" title="Permalink to this headline">¶</a></h2>
<p>A wide range of methods and software exist for solving <a href="#equation-decay:ode:general">(38)</a>.
Many of methods are accessible through a unified Python interface offered
by the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> package.
Odespy features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a class="reference external" href="https://computation.llnl.gov/casc/odepack/odepack_home.html">ODEPACK</a>, <a class="reference external" href="https://computation.llnl.gov/casc/odepack/odepack_home.html">Vode</a>,
<a class="reference external" href="http://www.netlib.org/ode/rkc.f">rkc.f</a>, &#8220;rkf45.f&#8221;: <a class="reference external" href="http://www.netlib.org/ode/rkf45.f">http://www.netlib.org/ode/rkf45.f</a>&#8221;, &#8220;Radau5&#8221;: &#8220;<a class="reference external" href="http://www.unige.ch/~hairer/software.html">http://www.unige.ch/~hairer/software.html</a>, as well
as the ODE solvers in <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html">SciPy</a>, <a class="reference external" href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html">SymPy</a>, and <a class="reference external" href="http://olivierverdier.github.com/odelab/">odelab</a>.</p>
<p>The usage of Odespy follows this setup for the ODE <span class="math">\(u'=-au\)</span> solved
by the famous 4th-order Runge-Kutta method:</p>
<div class="highlight-py"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span>

<span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RK4</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="example-runge-kutta-methods">
<h2>Example: Runge-Kutta methods<a class="headerlink" href="#example-runge-kutta-methods" title="Permalink to this headline">¶</a></h2>
<p>Since all solvers have the same interface, modulo different set of
parameters to the solvers&#8217; constructors, one can easily make a list of
solver objects and run a loop for comparing (a lot of) solvers. The
code below, found in complete form in <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_odespy.py">dc_odespy.py</a>
compares the famous Runge-Kutta methods of orders 2, 3, and 4 with the
Backward Euler scheme and the exact solution of the decay equation
<span class="math">\(u'=-au\)</span>. Figure <a class="reference internal" href="#decay-odespy-fig1"><em>Behavior of different schemes for the decay equation</em></a> shows the results.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="mf">0.75</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">RK2</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
           <span class="n">odespy</span><span class="o">.</span><span class="n">RK3</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
           <span class="n">odespy</span><span class="o">.</span><span class="n">RK4</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
           <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">)]</span>

<span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="c"># Compare with exact solution plotted on a very fine mesh</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">10001</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t_fine</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">)</span> <span class="c"># avoid markers by specifying line type</span>
<span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;exact&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Time step: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This code might deserve a couple of comments. We use SciTools for
plotting, because with the Matplotlib and Gnuplot backends, curves are
automatically given colors <em>and</em> markers, the latter being important
when PNG plots are printed in reports in black and white. (The default
Matplotlib and Gnuplot behavior gives colored lines, which are
difficult to distinguish. However, Gnuplot automatically introduces
different line styles if output in the Encapsulated PostScript format
is specified via <tt class="docutils literal"><span class="pre">savefig</span></tt>).  The automatic adding of markers is not
suitable for a very finely resolved line, like the one for <tt class="docutils literal"><span class="pre">u_e</span></tt> in
this case, and then we specify the line type as a solid line (<tt class="docutils literal"><span class="pre">-</span></tt>),
leaving the color up to the backend used for plotting.  The legends
are based on the class names of the solvers, and in Python the name of
a the class type (as a string) of an object <tt class="docutils literal"><span class="pre">obj</span></tt> is obtained by
<tt class="docutils literal"><span class="pre">obj.__class__.__name__</span></tt>.</p>
<div class="figure" id="decay-odespy-fig1">
<img alt="_images/decay_odespy1_png.png" src="_images/decay_odespy1_png.png" style="width: 600px;" />
<p class="caption"><em>Behavior of different schemes for the decay equation</em></p>
</div>
<p>Since we have quite long time steps, we have included the only
relevant <span class="math">\(\theta\)</span>-rule for large time steps, the BackwardEuler scheme
(<span class="math">\(\theta=1\)</span>), as well in Figure <a class="reference internal" href="#decay-odespy-fig1"><em>Behavior of different schemes for the decay equation</em></a>.  These and
other experiments reveal that</p>
<blockquote>
<div><ul class="simple">
<li>The 2-nd order Runge-Kutta method (<tt class="docutils literal"><span class="pre">RK2</span></tt>) is unstable for <span class="math">\(\Delta t&gt;1\)</span>
and decays slower than the Backward Euler scheme, which is known to
decay slower than the Crank-Nicolson and Forward Euler schemes.
However, for fine <span class="math">\(\Delta t = 0.25\)</span> the 2-nd order Runge-Kutta method
decays faster than the Backward Euler scheme and lies closer to the
exact curve. This means that the 2-nd order Runge-Kutta method
approaches the exact solution faster than the Backward Euler scheme,
although it is less accurate for large <span class="math">\(\Delta t\)</span> values.</li>
<li>The 3-rd order Runge-Kutta method (<tt class="docutils literal"><span class="pre">RK3</span></tt>) is oscillating for
<span class="math">\(\Delta t = 1.05\)</span> and lies partly above and below the exact curve for
<span class="math">\(\Delta t = 0.75\)</span>. This behavior is much like what one observes for
the Crank-Nicolson scheme. For finer <span class="math">\(\Delta t\)</span>,
the 3-rd order Runge-Kutta method converges quickly to the exact
solution.</li>
<li>The 4-th order Runge-Kutta method (<tt class="docutils literal"><span class="pre">RK4</span></tt>) is slightly inferior
to the Backward Euler scheme on the coarsest mesh, but is then
clearly superior to all the other schemes. It is definitely the
method of choise for all the tested schemes.</li>
</ul>
</div></blockquote>
<div class="section" id="remark-about-using-the-rule-in-odespy">
<h3>Remark about using the <span class="math">\(\theta\)</span>-rule in Odespy<a class="headerlink" href="#remark-about-using-the-rule-in-odespy" title="Permalink to this headline">¶</a></h3>
<p>The Odespy package assumes that the ODE is written as <span class="math">\(u'=f(u,t)\)</span> with
an <span class="math">\(f\)</span> that is possibly nonlinear in <span class="math">\(u\)</span>. The <span class="math">\(\theta\)</span>-rule for
<span class="math">\(u'=f(u,t)\)</span> leads to</p>
<div class="math">
\[u^{n+1} = u^{n} + \Delta t\left(\theta f(u^{n+1}, t_{n+1})
+ (1-\theta) f(u^{n}, t_{n})\right),\]</div>
<p>which is a <em>nonlinear equation</em> in <span class="math">\(u^{n+1}\)</span>. Odespy&#8217;s implementation
of the <span class="math">\(\theta\)</span>-rule (<tt class="docutils literal"><span class="pre">ThetaRule</span></tt>) and the specialized Backward Euler
and Crank-Nicolson schemes (called <tt class="docutils literal"><span class="pre">BackwardEuler</span></tt> and
<tt class="docutils literal"><span class="pre">MidpointImplicit</span></tt>, respectively) must invoke iterative methods for
solving the nonlinear equation in <span class="math">\(u^{n+1}\)</span>. This is done even when
<span class="math">\(f\)</span> is linear in <span class="math">\(u\)</span>, as in the model problem <span class="math">\(u'=-au\)</span>, where we can
easily solve for <span class="math">\(u^{n+1}\)</span>.  In the present example, we need to use
Newton&#8217;s method to ensure that Odespy is capable of solving the
equation for <span class="math">\(u^{n+1}\)</span> for large <span class="math">\(\Delta t\)</span>. (The reason is that the
Forward Euler method is used to compute the initial guess for the
nonlinear iteration method, and this Forward Euler may give very wrong
values for large <span class="math">\(\Delta t\)</span>.  The Newton method is not sensitive to a
bad initial guess in linear problems.)</p>
</div>
</div>
<div class="section" id="example-adaptive-runge-kutta-methods">
<h2>Example: Adaptive Runge-Kutta methods<a class="headerlink" href="#example-adaptive-runge-kutta-methods" title="Permalink to this headline">¶</a></h2>
<p>Odespy offers solution methods that can adapt the size of <span class="math">\(\Delta t\)</span>
with time to match a desired accuracy in solution. Intuitively,
small time steps will be chosen in areas where the solution is changing
rapidly, while larger time steps can be used where the solution
is slowly varying. Some kind of <em>error estimator</em> is used to
adjust the next time step at each time level.</p>
<p>A very popular adaptive method for solving ODEs is the Dormand-Prince
Runge-Kutta method of order 4 and 5. The 5th-order method is used as a
reference solution and the difference between the 4th- and 5th-order
methods is used as an indicator of the error in the numerical
solution.  The Dormand-Prince method is the default choice in MATLAB&#8217;s
famous <tt class="docutils literal"><span class="pre">ode45</span></tt> routine.</p>
<p>We can easily set up Odespy to use the Dormand-Prince method and
see how it selects the optimal time steps. To this end, we request
only one time step from <span class="math">\(t=0\)</span> to <span class="math">\(t=T\)</span> and ask the method to
compute the necessary non-uniform time mesh to meet a certain
error tolerance. The code goes like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">dc_mod</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="c">#import matplotlib.pyplot as plt</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span>

<span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">tol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">DormandPrince</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tol</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># just one step - let the scheme find its intermediate points</span>
<span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">10001</span><span class="p">)</span>

<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>

<span class="c"># u and t will only consist of [I, u^N] and [0,T]</span>
<span class="c"># solver.u_all and solver.t_all contains all computed points</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">t_all</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">u_all</span><span class="p">,</span> <span class="s">&#39;ko&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_fine</span><span class="p">),</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;tol=</span><span class="si">%.0E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_odespy_adaptive.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Running four cases with tolerances <span class="math">\(10^{-1}\)</span>, <span class="math">\(10^{-3}\)</span>, <span class="math">\(10^{-5}\)</span>,
and <span class="math">\(10^{-7}\)</span>, gives the results in Figure <a class="reference internal" href="#decay-odespy-fig2"><em>Choice of adaptive time mesh by the Dormand-Prince method for different tolerances</em></a>.
Intuitively, one would expect denser points in the beginning of
the decay and larger time steps when the solution flattens out.</p>
<div class="figure" id="decay-odespy-fig2">
<img alt="_images/decay_DormandPrince_adaptivity.png" src="_images/decay_DormandPrince_adaptivity.png" style="width: 800px;" />
<p class="caption"><em>Choice of adaptive time mesh by the Dormand-Prince method for different tolerances</em></p>
</div>
</div>
<div class="section" id="other-schemes">
<h2>Other schemes<a class="headerlink" href="#other-schemes" title="Permalink to this headline">¶</a></h2>
<p>Next we list some well-known methods for <span class="math">\(u'=f(u,t)\)</span>, valid both for
a single ODE (scalar <span class="math">\(u\)</span>) and systems of ODEs (vector <span class="math">\(u\)</span>).</p>
<span class="target" id="index-59"></span><div class="section" id="implicit-2-step-backward-scheme">
<span id="index-60"></span><h3>Implicit 2-step backward scheme<a class="headerlink" href="#implicit-2-step-backward-scheme" title="Permalink to this headline">¶</a></h3>
<p>The implicit backward method with 2 steps applies a
three-level backward difference as approximation to <span class="math">\(u'(t)\)</span>,</p>
<div class="math">
\[u'(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t},\]</div>
<p>which is an approximation of order <span class="math">\(\Delta t^2\)</span> to the first derivative.
The resulting scheme for <span class="math">\(u'=f(u,t)\)</span> reads</p>
<div class="math" id="equation-decay:fd2:bw:2step  u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} + \frac{2}{3}\Delta t f(u^{n+1}, t_{n+1}) \thinspace .">
</div>
<p>Higher-order versions of the scheme <a href="#equation-decay:fd2:bw:2step">(?)</a> can
be constructed by including more time levels. These schemes are known
as the Backward Differentiation Formulas (BDF), and the particular
version <a href="#equation-decay:fd2:bw:2step">(?)</a> is often referred to as BDF2.
The family of BDF schemes are available in the solvers <tt class="docutils literal"><span class="pre">odespy.Vode</span></tt>,
<tt class="docutils literal"><span class="pre">odespy.Lsode</span></tt>, <tt class="docutils literal"><span class="pre">odespy.Lsoda</span></tt>, and <tt class="docutils literal"><span class="pre">odespy.lsoda_scipy</span></tt>.</p>
<p>Note that the scheme <a href="#equation-decay:fd2:bw:2step">(?)</a> is implicit and requires
solution of nonlinear equations when <span class="math">\(f\)</span> is nonlinear in <span class="math">\(u\)</span>.  The
standard 1st-order Backward Euler method or the Crank-Nicolson scheme
can be used for the first step.</p>
</div>
<div class="section" id="the-leapfrog-scheme">
<span id="index-61"></span><h3>The Leapfrog scheme<a class="headerlink" href="#the-leapfrog-scheme" title="Permalink to this headline">¶</a></h3>
<p>The derivative of <span class="math">\(u\)</span> at some point <span class="math">\(t_n\)</span> can be approximated by
a central difference over two time steps,</p>
<div class="math">
\[u'(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t},\]</div>
<p>which is an approximation of second order in <span class="math">\(\Delta t\)</span>.
This approximation gives the scheme</p>
<div class="math" id="equation-decay:fd2:leapfrog">
<span class="eqno">(40)</span>\[     u^{n+1} = u^{n-1} + \Delta t f(u^n, t_n)
     \thinspace .\]</div>
<p>Some other scheme must be used as starter to compute <span class="math">\(u^1\)</span>.
Observe that <a href="#equation-decay:fd2:leapfrog">(40)</a> is an explicit scheme, and that
a nonlinear <span class="math">\(f\)</span> (in <span class="math">\(u\)</span>) is trivial to handle.</p>
</div>
<div class="section" id="the-filtered-leapfrog-scheme">
<span id="index-62"></span><h3>The filtered Leapfrog scheme<a class="headerlink" href="#the-filtered-leapfrog-scheme" title="Permalink to this headline">¶</a></h3>
<p>Unfortunately, the Leapfrog scheme <a href="#equation-decay:fd2:leapfrog">(40)</a>
will develop growing oscillations with time (see <a class="reference internal" href="#decay-fd2-exer-leapfrog1"><em>Exercise 15: Implement the Leapfrog scheme</em></a>, {decay:fd2:exer:leapfrog2}, and
{decay:fd2:exer:leapfrog3}). A remedy for such undesired oscillations
is to introduce a <em>filtering technique</em>. First, a standard Leapfrog
step is taken, according to <a href="#equation-decay:fd2:leapfrog">(40)</a>, and then
the previous <span class="math">\(u^n\)</span> value is adjusted according to</p>
<div class="math" id="equation-decay:fd2:leapfrog:filtered">
<span class="eqno">(41)</span>\[     u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})\]\[     \thinspace .\]</div>
<p>The <span class="math">\(\gamma\)</span>-terms will effectively damp oscillations in the solution,
especially those with short wavelength (point-to-point oscillations in
particular). A common choice of <span class="math">\(\gamma\)</span> is 0.6 (a value used in the
famous NCAR Climate Model).</p>
<span class="target" id="index-63"></span></div>
<div class="section" id="nd-order-runge-kutta-scheme">
<span id="index-64"></span><h3>2nd-order Runge-Kutta scheme<a class="headerlink" href="#nd-order-runge-kutta-scheme" title="Permalink to this headline">¶</a></h3>
<p>The two-step scheme</p>
<div class="math">
\[\begin{split}u^* &amp;= u^n + \Delta t f(u^n, t_n),
\\
u^{n+1} &amp;= u^n + \Delta t \frac{1}{2} \left( f(u^n, t_n) + f(u^*, t_{n+1})
\right),\end{split}\]</div>
<p>essentially applies a Crank-Nicolson method to the ODE, but replaces
the term <span class="math">\(f(u^{n+1}, t_{n+1})\)</span> by a prediction
<span class="math">\(f(u^{*}, t_{n+1})\)</span> based on a Forward Euler step.
The scheme (<em class="xref std std-ref">decay:fd2:RK2:s1</em>)-(<em class="xref std std-ref">decay:fd2:RK2:s2</em>) is
known as Huen&#8217;s method, but is also a 2nd-order Runge-Kutta method.
The scheme is explicit, and the error is expected to behave as <span class="math">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="nd-order-adams-bashforth-scheme">
<span id="index-65"></span><h3>2nd-order Adams-Bashforth scheme<a class="headerlink" href="#nd-order-adams-bashforth-scheme" title="Permalink to this headline">¶</a></h3>
<p>The following method is known as the 2nd-order Adams-Bashforth scheme:</p>
<div class="math" id="equation-decay:fd2:AB2">
<span class="eqno">(42)</span>\[     u^{n+1} = u^n + \frac{1}{2}\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
     \right)
     \thinspace .\]</div>
<p>The scheme is explicit and requires another one-step scheme to compute
<span class="math">\(u^1\)</span> (the Forward Euler scheme or Heun&#8217;s method, for instance).
As the name implies, the scheme is of order <span class="math">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="rd-order-adams-bashforth-scheme">
<span id="index-66"></span><h3>3rd-order Adams-Bashforth scheme<a class="headerlink" href="#rd-order-adams-bashforth-scheme" title="Permalink to this headline">¶</a></h3>
<p>Another explicit scheme, involving four time levels, is the
3rd-order Adams-Bashforth scheme</p>
<div class="math" id="equation-decay:fd2:AB3">
<span class="eqno">(43)</span>\[     u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
     + 5f(u^{n-2}, t_{n-2})\right)
     \thinspace .\]</div>
<p>The numerical error is of order <span class="math">\(\Delta t^3\)</span>, and the scheme needs
some method for computing <span class="math">\(u^1\)</span> and <span class="math">\(u^2\)</span>.</p>
<span class="target" id="index-67"></span></div>
</div>
</div>
<div class="section" id="id21">
<h1>Exercises<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-14-implement-the-2-step-backward-scheme">
<span id="decay-fd2-exer-bw2"></span><h2>Exercise 14: Implement the 2-step backward scheme<a class="headerlink" href="#exercise-14-implement-the-2-step-backward-scheme" title="Permalink to this headline">¶</a></h2>
<p>Implement the 2-step backward method <a href="#equation-decay:fd2:bw:2step">(?)</a>
for the model <span class="math">\(u'(t) = -a(t)u(t) + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>.
Allow the first step to be computed by either the Backward Euler
scheme or the Crank-Nicolson scheme. Verify the implementing by choosing
<span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> such that the exact solution is linear in <span class="math">\(t\)</span>
(see the section <a class="reference internal" href="#decay-mms"><em>Verification via manufactured solutions</em></a>).</p>
<p>Compute convergence rates (see the section <a class="reference internal" href="#decay-convergence-rate"><em>Computing convergence rates</em></a>) in
a test case <span class="math">\(a=\hbox{const}\)</span> and <span class="math">\(b=0\)</span>, where we easily have an exact
solution, and determine if the choice of
a first-order scheme (Backward Euler) has any impact on the overall
accuracy of this scheme. The expected error goes like <span class="math">\({\cal O}(\Delta t^2)\)</span>.
Filename: <tt class="docutils literal"><span class="pre">dc_backward2step.py</span></tt>.</p>
</div>
<div class="section" id="exercise-15-implement-the-leapfrog-scheme">
<span id="decay-fd2-exer-leapfrog1"></span><h2>Exercise 15: Implement the Leapfrog scheme<a class="headerlink" href="#exercise-15-implement-the-leapfrog-scheme" title="Permalink to this headline">¶</a></h2>
<p>Implement the Leapfrog scheme <a href="#equation-decay:fd2:leapfrog">(40)</a>
for the model <span class="math">\(u'(t) = -a(t)u(t) + b(t)\)</span>,
<span class="math">\(u(0)=I\)</span>. Since the Leapfrog scheme is explicit in time, it is most
convenient to use the explicit Forward Euler scheme for computing <span class="math">\(u^1\)</span>.</p>
<p>Verify the implementation by choosing <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> such that
the exact solution is linear in <span class="math">\(t\)</span> (see the section <a class="reference internal" href="#decay-mms"><em>Verification via manufactured solutions</em></a>).
Also run the case <span class="math">\(u'=-u + 1\)</span>, <span class="math">\(u(0)=0\)</span>, and compare the numerical
and exact solutions in a plot (<span class="math">\(u_{\small\mbox{e}}(t)=1-e^{-t}\)</span> for this case).</p>
<p>Compute convergence rates (see the section <a class="reference internal" href="#decay-convergence-rate"><em>Computing convergence rates</em></a>)
to determine if the choice of a first-order scheme (Forward Euler) for
the first time step has any impact on the overall accuracy of the
Leapfrog scheme, which is expected to be of second order in <span class="math">\(\Delta t\)</span>.
Filename: <tt class="docutils literal"><span class="pre">dc_leapfrog.py</span></tt>.</p>
</div>
<div class="section" id="exercise-16-experiment-with-the-leapfrog-scheme">
<span id="decay-fd2-exer-leapfrog2"></span><h2>Exercise 16: Experiment with the Leapfrog scheme<a class="headerlink" href="#exercise-16-experiment-with-the-leapfrog-scheme" title="Permalink to this headline">¶</a></h2>
<p>Set up a set of experiments to demonstrate that the Leapfrog scheme
<a href="#equation-decay:fd2:leapfrog">(40)</a> as implemented in <a class="reference internal" href="#decay-fd2-exer-leapfrog1"><em>Exercise 15: Implement the Leapfrog scheme</em></a> is associated with numerical artifacts
(instabilities).
Filename: <tt class="docutils literal"><span class="pre">dc_leapfrog_exper.py</span></tt>.</p>
</div>
<div class="section" id="exercise-17-analyze-the-leapfrog-scheme">
<span id="decay-fd2-exer-leapfrog3"></span><h2>Exercise 17: Analyze the Leapfrog scheme<a class="headerlink" href="#exercise-17-analyze-the-leapfrog-scheme" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this exercise is to analyze and explain
instabilities of the Leapfrog scheme <a href="#equation-decay:fd2:leapfrog">(40)</a>.
Consider the case where <span class="math">\(a\)</span> is constant and <span class="math">\(b=0\)</span>.
Assume that an exact solution of the discrete equations has
the form <span class="math">\(u^n=A^n\)</span>, where <span class="math">\(A\)</span> is an amplification factor to
be determined. Use <tt class="docutils literal"><span class="pre">sympy</span></tt> to compute <span class="math">\(A\)</span>. Since the governing
polynomial for <span class="math">\(A\)</span> has two roots, <span class="math">\(A_1\)</span> and <span class="math">\(A_2\)</span>,
<span class="math">\(u^n\)</span> is a linear combination <span class="math">\(u^n=C_1A_1^n + C_2A_2^n\)</span>.
Filename: <tt class="docutils literal"><span class="pre">dc_leapfrog_anaysis.py</span></tt>.</p>
</div>
<div class="section" id="exercise-18-implement-the-2nd-order-adams-bashforth-scheme">
<span id="decay-fd2-exer-ab2"></span><h2>Exercise 18: Implement the 2nd-order Adams-Bashforth scheme<a class="headerlink" href="#exercise-18-implement-the-2nd-order-adams-bashforth-scheme" title="Permalink to this headline">¶</a></h2>
<p>Implement the 2nd-order Adams-Bashforth method <a href="#equation-decay:fd2:AB2">(42)</a>
for the decay problem <span class="math">\(u'=-a(t)u + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(t\in (0, T]\)</span>.
Use the Forward Euler method for the first step such that the overall
scheme is explicit. Verify the implementation using an exact
solution that is linear in time.
Analyze the scheme by searching for solutions <span class="math">\(u^n=A^n\)</span> when <span class="math">\(a=\hbox{const}\)</span>
and <span class="math">\(b=0\)</span>. Compare this second-order secheme to the Crank-Nicolson scheme.
Filename: <tt class="docutils literal"><span class="pre">dc_AdamBashforth2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-19-implement-the-3rd-order-adams-bashforth-scheme">
<span id="decay-fd2-exer-ab3"></span><h2>Exercise 19: Implement the 3rd-order Adams-Bashforth scheme<a class="headerlink" href="#exercise-19-implement-the-3rd-order-adams-bashforth-scheme" title="Permalink to this headline">¶</a></h2>
<p>Implement the 3rd-order Adams-Bashforth method <a href="#equation-decay:fd2:AB3">(43)</a>
for the decay problem <span class="math">\(u'=-a(t)u + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(t\in (0, T]\)</span>.
Since the scheme is explicit, allow it to be started by two steps with
the Forward Euler method.  Investigate experimentally the case where
<span class="math">\(b=0\)</span> and <span class="math">\(a\)</span> is a constant: Can we have oscillatory solutions for
large <span class="math">\(\Delta t\)</span>?
Filename: <tt class="docutils literal"><span class="pre">dc_AdamBashforth3.py</span></tt>.</p>
</div>
<div class="section" id="exercise-20-generalize-a-class-implementation">
<span id="decay-exer-dc-class2"></span><h2>Exercise 20: Generalize a class implementation<a class="headerlink" href="#exercise-20-generalize-a-class-implementation" title="Permalink to this headline">¶</a></h2>
<p>Consider the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_class.py">dc_class.py</a>
where the exponential decay problem <span class="math">\(u'=-au\)</span>, <span class="math">\(u(0)=I\)</span>, is implemented
via three classes <tt class="docutils literal"><span class="pre">Problem</span></tt>, <tt class="docutils literal"><span class="pre">Solver</span></tt>, and <tt class="docutils literal"><span class="pre">Visualizer</span></tt>.
Extend the classes to handle the more general problem</p>
<div class="math">
\[u'(t) = -a(t)u(t) + b(t),\quad u(0)=I,\ t\in (0,T],\]</div>
<p>using the <span class="math">\(\theta\)</span>-rule for discretization.</p>
<p>In the case with arbitrary functions <span class="math">\(a(t)\)</span> and <span class="math">\(b(t)\)</span> the problem class
is no longer guaranteed to provide an exact solution. Let
the <tt class="docutils literal"><span class="pre">exact_solution</span></tt> in class <tt class="docutils literal"><span class="pre">Problem</span></tt> return <tt class="docutils literal"><span class="pre">None</span></tt> if the exact
solution for the particular problem is not available. Modify classes
<tt class="docutils literal"><span class="pre">Solver</span></tt> and <tt class="docutils literal"><span class="pre">Visualizer</span></tt> accordingly.</p>
<p>Add test functions <tt class="docutils literal"><span class="pre">test_*()</span></tt> for the nose testing tool in the module.
Also add a demo example for a rough model of a parachute jumper where
<span class="math">\(b(t)=g\)</span> (acceleration of gravity) and</p>
<div class="math">
\[\begin{split}a(t) =\left\lbrace\begin{array}{ll}
a_0, &amp; 0\leq t\leq t_p,\\
ka_0, &amp; t&gt; t_p,\end{array}\right.\end{split}\]</div>
<p>where <span class="math">\(t_p\)</span> is the point of time the parachute is released and <span class="math">\(k\)</span> is
the factor of increased air resistance. Scale the model using the
terminal velocity of the free fall, <span class="math">\(v=\sqrt{g/a_0}\)</span>, as velocity scale.
Make a demo of the scaled model with <span class="math">\(k=50\)</span>.
Filename: <tt class="docutils literal"><span class="pre">dc_class2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-21-generalize-an-advanced-class-implementation">
<span id="decay-exer-dc-class3"></span><h2>Exercise 21: Generalize an advanced class implementation<a class="headerlink" href="#exercise-21-generalize-an-advanced-class-implementation" title="Permalink to this headline">¶</a></h2>
<p>Solve <a class="reference internal" href="#decay-exer-dc-class2"><em>Exercise 20: Generalize a class implementation</em></a> by utilizing the
class implementations in
<a class="reference external" href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/dc_class_oo.py">dc_class_oo.py</a>.
Filename: <tt class="docutils literal"><span class="pre">dc_class3.py</span></tt>.</p>
</div>
<div class="section" id="exercise-22-make-a-unified-implementation-of-many-schemes">
<span id="decay-fd2-exer-uni"></span><h2>Exercise 22: Make a unified implementation of many schemes<a class="headerlink" href="#exercise-22-make-a-unified-implementation-of-many-schemes" title="Permalink to this headline">¶</a></h2>
<p>Consider the linear ODE problem <span class="math">\(u'(t)=-a(t)u(t) + b(t)\)</span>, <span class="math">\(u(0)=I\)</span>.
Many solution schemes for this problem can be written in the (explicit) form</p>
<div class="math" id="equation-decay:analysis:exer:sumcj">
<span class="eqno">(44)</span>\[     u^{n+1} = \sum_{j=0}^m c_ju^{n-j},\]</div>
<p>for some choice of <span class="math">\(c_0,\ldots,c_m\)</span>.
Find thhe <span class="math">\(c_j\)</span> coefficients for the
<span class="math">\(\theta\)</span>-rule, the three-level backward scheme,
the Leapfrog scheme, the 2nd-order Runge-Kutta method,
and the 3rd-order Adams-Bashforth scheme.</p>
<p>Make a class <tt class="docutils literal"><span class="pre">ExpDecay</span></tt> that implements <a href="#equation-decay:analysis:exer:sumcj">(44)</a>,
with subclasses specifying lists <span class="math">\(c_0,\ldots,c_m\)</span> for the various methods.
The subclasses also need extra lists for methods needed to start
schemes with <span class="math">\(m&gt;0\)</span>.
Verify the implementation by testing with a linear solution (<span class="math">\(u_{\small\mbox{e}}(t)=ct+d\)</span>).
Filename: <tt class="docutils literal"><span class="pre">decay_schemes_oo.py</span></tt>.</p>
</div>
</div>
<div class="section" id="applications-of-exponential-decay-models">
<span id="decay-app"></span><h1>Applications of exponential decay models<a class="headerlink" href="#applications-of-exponential-decay-models" title="Permalink to this headline">¶</a></h1>
<p>This section presents many mathematical models that all
end up with ODEs of the type <span class="math">\(u'=-au+b\)</span>, where the solution exhibits
exponential growth or decay.  The applications are taken from biology,
finance, and physics, and cover population growth or decay, compound
interest and inflation, radioactive decay, cooling of bodies, pressure
variations in the atmosphere, and air resistance on falling or rising
bodies.</p>
<div class="section" id="evolution-of-a-population">
<span id="decay-app-pop"></span><h2>Evolution of a population<a class="headerlink" href="#evolution-of-a-population" title="Permalink to this headline">¶</a></h2>
<p id="index-68">Let <span class="math">\(N\)</span> be the number of individuals in a population occupying some
spatial domain.
Despite <span class="math">\(N\)</span> being an integer we shall compute with <span class="math">\(N\)</span> as a real number
and view <span class="math">\(N(t)\)</span> as a continuous function of time.
The basic model assumption is that in a time interval <span class="math">\(\Delta t\)</span> the number of
newcomers to the populations (newborns) is proportional to
<span class="math">\(N\)</span>, with proportionality constant <span class="math">\(\bar b\)</span>. The amount of
newcomers will increase the population and result in
to</p>
<div class="math">
\[N(t+\Delta t) = N(t) + \bar bN(t)\thinspace .\]</div>
<p>It is obvious that a long time interval <span class="math">\(\Delta t\)</span> will result in
more newcomers and hence a larger <span class="math">\(\bar b\)</span>. Therefore, we introduce
<span class="math">\(b=\bar b/\Delta t\)</span>: the number of newcomers per unit time and per
individual. We must then multiply <span class="math">\(b\)</span> by the length of the time
interval considered and by the population size to get the
total number of new individuals, <span class="math">\(b\Delta t N\)</span>.</p>
<p>If the number of removals from the population (deaths) is also
proportional to <span class="math">\(N\)</span>, with proportionality constant <span class="math">\(d\Delta t\)</span>,
the population evolves according to</p>
<div class="math">
\[N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t)\thinspace .\]</div>
<p>Dividing by <span class="math">\(\Delta t\)</span> and letting <span class="math">\(\Delta t \rightarrow 0\)</span>,
we get the ODE</p>
<div class="math">
\[N' = (b-d)N\thinspace .\]</div>
<p>In a population where the death rate (<span class="math">\(d\)</span>) is larger than
then newborn rate (<span class="math">\(b\)</span>), <span class="math">\(a&gt;0\)</span>, and the population experiences
exponential decay rather than exponential growth.</p>
<p>In some populations there is an immigration of individuals into the
spatial domain. With <span class="math">\(I\)</span> individuals coming in per time unit,
the equation for the population change becomes</p>
<div class="math">
\[N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t) + \Delta t I\thinspace .\]</div>
<p>The corresponding ODE reads</p>
<div class="math">
\[N' = (b-d)N + I,\quad N(0)=N_0
\thinspace .\]</div>
<p>Some simplification arises if we introduce a fractional measure
of the population: <span class="math">\(u=N/N_0\)</span> and set <span class="math">\(r=b-d\)</span>. The ODE problem
now becomes</p>
<div class="math" id="equation-decay:app:pop:ueq">
<span class="eqno">(45)</span>\[     u' = ru + f,\quad u(0)=1,\]</div>
<p>where <span class="math">\(f=I/N_0\)</span> measures the net immigration per time unit as
the fraction of the initial population.</p>
<p id="index-69">The growth rate <span class="math">\(r\)</span> of a population decreases if the environment
has limited resources. Suppose the environment can sustain at
most <span class="math">\(N_{\max}\)</span> individuals. We may then assume that the growth rate
approaches zero as <span class="math">\(N\)</span> approaches <span class="math">\(N_{\max}\)</span>, i.e., as <span class="math">\(u\)</span> approaches
<span class="math">\(M=N_{\max}/N_0\)</span>. The simplest possible evolution of <span class="math">\(r\)</span> is then a
linear function: <span class="math">\(r(t)=r_0(1-u(t)/M)\)</span>, where <span class="math">\(r_0\)</span>
is the initial growth rate when the population is small relative to the
maximum size and there is enough resources. Using this <span class="math">\(r(t)\)</span> in
<a href="#equation-decay:app:pop:ueq">(45)</a> results in the <em>logistic model</em> for the
evolution of a population:</p>
<div class="math" id="equation-decay:app:pop:logistic">
<span class="eqno">(46)</span>\[     u' = r_0(1-u/M)u,\quad u(0)=1
     \thinspace .\]</div>
<p>Initially, <span class="math">\(u\)</span> will grow at rate <span class="math">\(r_0\)</span>, but the growth will decay
as <span class="math">\(u\)</span> approaches <span class="math">\(M\)</span>, and then there is no more change in <span class="math">\(u\)</span>, causing
the limit <span class="math">\(u\rightarrow M\)</span> as <span class="math">\(t\rightarrow\infty\)</span>.
Note that the logistic equation <span class="math">\(u'=r_0(1-u/M)u\)</span> is <em>nonlinear</em> because
of the quadratic term <span class="math">\(-u^2r_0/M\)</span>.</p>
</div>
<div class="section" id="compound-interest-and-inflation">
<span id="decay-app-interest"></span><h2>Compound interest and inflation<a class="headerlink" href="#compound-interest-and-inflation" title="Permalink to this headline">¶</a></h2>
<p>Say the annual interest rate is <span class="math">\(r\)</span> percent and that the bank
adds the interest once a year to your investment.
If <span class="math">\(u^n\)</span> is the investment in year <span class="math">\(n\)</span>, the investment in year <span class="math">\(u^{n+1}\)</span>
grows to</p>
<div class="math">
\[u^{n+1} = u^n + \frac{r}{100}u^n
\thinspace .\]</div>
<p>In reality, the interest rate is added every day. We therefore introduce
a parameter <span class="math">\(m\)</span> for the number of periods per year when the interest
is added. If <span class="math">\(n\)</span> counts the periods, we have the fundamental model
for compound interest:</p>
<div class="math" id="equation-decay:app:interest:eq1">
<span class="eqno">(47)</span>\[     u^{n+1} = u^n + \frac{r}{100 m}u^n
     \thinspace .\]</div>
<p>This model is a <em>difference equation</em>, but it can be transformed to a
continuous differential equation through a limit process.
The first step is to derive a formula for the growth of the investment
over a time <span class="math">\(t\)</span>.
Starting with an investment <span class="math">\(u^0\)</span>, and assuming that <span class="math">\(r\)</span> is constant in time,
we get</p>
<div class="math">
\[\begin{split}u^{n+1} &amp;= \left(1 + \frac{r}{100 m}\right)u^{n}\\
&amp;= \left(1 + \frac{r}{100 m}\right)^2u^{n-1}\\
&amp;\ \ \vdots\\
&amp;= \left(1 +\frac{r}{100 m}\right)^{n+1}u^{0}\end{split}\]</div>
<p>Introducing time <span class="math">\(t\)</span>, which here is a real-numbered counter for years,
we have that <span class="math">\(n=mt\)</span>, so we can write</p>
<div class="math">
\[u^{mt} = \left(1 + \frac{r}{100 m}\right)^{mt} u^0\thinspace .\]</div>
<p>The second step is to assume <em>continuous compounding</em>, meaning that the
interest is added continuously. This implies <span class="math">\(m\rightarrow\infty\)</span>, and
in the limit one gets the formula</p>
<div class="math">
\[u(t) = u_0e^{rt/100},\]</div>
<p>which is nothing but the solution of the ODE problem</p>
<div class="math" id="equation-decay:app:interest:eq2">
<span class="eqno">(48)</span>\[     u' = \frac{r}{100}u,\quad u(0)=u_0
     \thinspace .\]</div>
<p>This is then taken as the ODE model for compound interest if <span class="math">\(r&gt;0\)</span>.
However, the reasoning applies equally well to inflation, which is
just the case <span class="math">\(r&lt;0\)</span>. One may also take the <span class="math">\(r\)</span> in <a href="#equation-decay:app:interest:eq2">(48)</a>
as the net growth of an investemt, where <span class="math">\(r\)</span> takes both compound interest
and inflation into account. Note that for real applications we must
use a time-dependent <span class="math">\(r\)</span> in <a href="#equation-decay:app:interest:eq2">(48)</a>.</p>
<p>Introducing <span class="math">\(a=\frac{r}{100}\)</span>, continuous inflation of an initial
fortune <span class="math">\(I\)</span> is then
a process exhibiting exponential decay according to</p>
<div class="math">
\[u' = -au,\quad u(0)=I\thinspace .\]</div>
</div>
<div class="section" id="radioactive-decay">
<h2>Radioactive Decay<a class="headerlink" href="#radioactive-decay" title="Permalink to this headline">¶</a></h2>
<p>An atomic nucleus of an unstable atom may lose energy by emitting
ionizing particles and thereby be transformed to a nucleus with a
different number of protons and neutrons.  This process is known as
<a class="reference external" href="http://en.wikipedia.org/wiki/Radioactive_decay">radioactive decay</a>.
Actually, the process is stochastic when viewed for a single atom,
because it is impossible to predict exactly when a particular atom
emits a particle. Nevertheless, with a large number of atoms, <span class="math">\(N\)</span>, one may
view the process as deterministic and compute the mean behavior
of the decay.</p>
<p>Suppose at time <span class="math">\(t\)</span>, the number of the original atom type is <span class="math">\(N(t)\)</span>.
A basic model assumption is that the transformation of the atoms of the original
type in a small time interval <span class="math">\(\Delta t\)</span> is proportional to
<span class="math">\(N\)</span>, so that</p>
<div class="math">
\[N(t+\Delta t) = N(t) - a\Delta t N(t),\]</div>
<p>where <span class="math">\(a\)</span> is a constant. Introducing <span class="math">\(u=N(t)/N(0)\)</span>, dividing by
<span class="math">\(\Delta t\)</span> and letting <span class="math">\(\Delta t\rightarrow 0\)</span> gives the
following ODE:</p>
<div class="math">
\[u' = -au,\quad u(0)=1
\thinspace .\]</div>
<p>The parameter <span class="math">\(a\)</span> can for a given nucleus be expressed through the
<em>half-life</em> <span class="math">\(t_{1/2}\)</span>, which is the time taken for the decay to reduce the
initial amount by one half, i.e., <span class="math">\(u(t_{1/2}) = 0.5\)</span>.
With <span class="math">\(u(t)=e^{-at}\)</span>, we get <span class="math">\(t_{1/2}=a^{-1}\ln 2\)</span> or <span class="math">\(a=\ln 2/t_{1/2}\)</span>.</p>
</div>
<div class="section" id="newton-s-law-of-cooling">
<h2>Newton&#8217;s law of cooling<a class="headerlink" href="#newton-s-law-of-cooling" title="Permalink to this headline">¶</a></h2>
<p>When a body at some temperature is placed in a cooling environment,
experience shows that the temperature falls rapidly in the beginning,
and then the changes in temperature levels off until the body&#8217;s
temperature equals that of the surroundings. Newton carried out some
experiments on cooling hot iron and found that the temperature
evolved as a &#8220;geometric progression at times in arithmetic progression&#8221;,
meaning that the temperature decayed exponentially.
Later, this result was formulated as a differential equation:
the rate of change of the temperature in a body is proportional to
the temperature difference between the body and its surroundings.
This statement is known as <em>Newton&#8217;s law of cooling</em>, which
can be mathematically expressed as</p>
<div class="math" id="equation-decay:Newton:cooling">
<span class="eqno">(49)</span>\[     {dT\over dt} = -k(T-T_s),\]</div>
<p>where <span class="math">\(T\)</span> is the temperature of the body, <span class="math">\(T_s\)</span> is the temperature
of the surroundings, <span class="math">\(t\)</span> is time, and <span class="math">\(k\)</span> is a positive constant.
Equation <a href="#equation-decay:Newton:cooling">(49)</a> is primarily viewed as an
empirical law, valid when heat is efficiently convected away
from the surface of the body by a flowing fluid such as air
at constant temperature <span class="math">\(T_s\)</span>.
The constant <span class="math">\(k\)</span> reflects the transfer of heat from the body to
the surroundings and must be determined from physical experiments.</p>
</div>
<div class="section" id="decay-of-atmospheric-pressure-with-altitude">
<span id="decay-app-atm"></span><h2>Decay of atmospheric pressure with altitude<a class="headerlink" href="#decay-of-atmospheric-pressure-with-altitude" title="Permalink to this headline">¶</a></h2>
<p>Vertical equilibrium of air in the atmosphere is governed by
the equation</p>
<div class="math" id="equation-decay:app:atm:dpdz">
<span class="eqno">(50)</span>\[     \frac{dp}{dz} = -\varrho g
     \thinspace .\]</div>
<p>Here, <span class="math">\(p(z)\)</span> is the air pressure, <span class="math">\(\varrho\)</span> is the density of
air, and <span class="math">\(g=9.807\hbox{ m/s}^2\)</span> is a standard value of
the acceleration of gravity.
(Equation <a href="#equation-decay:app:atm:dpdz">(50)</a> follows directly from the general
Navier-Stokes equations for fluid motion, with
the assumption that the air does not move.)</p>
<p>The pressure is related to density and temperature through the ideal gas law</p>
<div class="math" id="equation-decay:app:atm:rho">
<span class="eqno">(51)</span>\[     \varrho = \frac{Mp}{R^*T},\]</div>
<p>where <span class="math">\(M\)</span> is the molar mass of Earth&#8217;s air (0.029 kg/mol),
<span class="math">\(R^*\)</span> is the universal
gas constant (<span class="math">\(8.314\)</span> Nm/(mol K)), and <span class="math">\(T\)</span> is the temperature.
All variables <span class="math">\(p\)</span>, <span class="math">\(\varrho\)</span>, and <span class="math">\(T\)</span> vary with the height <span class="math">\(z\)</span>.
Inserting <a href="#equation-decay:app:atm:rho">(51)</a> in <a href="#equation-decay:app:atm:dpdz">(50)</a> results
in an ODE for with a variable coefficient:</p>
<div class="math" id="equation-decay:app:atm:ode">
<span class="eqno">(52)</span>\[     \frac{dp}{dz} = -\frac{Mg}{R^*T(z)} p\]\[     \thinspace  .\]</div>
<div class="section" id="multiple-atmospheric-layers">
<h3>Multiple atmospheric layers<a class="headerlink" href="#multiple-atmospheric-layers" title="Permalink to this headline">¶</a></h3>
<p>The atmosphere can be approximately modeled by seven layers.
In each layer, <a href="#equation-decay:app:atm:ode">(52)</a> is applied with
a linear temperature of the form</p>
<div class="math">
\[T(z) = \bar T_i + L_i(z-h_i),\]</div>
<p>where <span class="math">\(z=h_i\)</span> denotes the bottom of layer number <span class="math">\(i\)</span>,
having temperature <span class="math">\(\bar T_i\)</span>,
and <span class="math">\(L_i\)</span> is a constant in layer number <span class="math">\(i\)</span>. The table below
lists <span class="math">\(h_i\)</span> (m), <span class="math">\(\bar T_i\)</span> (K), and <span class="math">\(L_i\)</span> (K/m) for the layers
<span class="math">\(i=0,\ldots,6\)</span>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math">\(i\)</span></th>
<th class="head"><span class="math">\(h_i\)</span></th>
<th class="head"><span class="math">\(\bar T_i\)</span></th>
<th class="head"><span class="math">\(L_i\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>288</td>
<td>-0.0065</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>11,000</td>
<td>216</td>
<td>0.0</td>
</tr>
<tr class="row-even"><td>2</td>
<td>20,000</td>
<td>216</td>
<td>0.001</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>32,000</td>
<td>228</td>
<td>0.0028</td>
</tr>
<tr class="row-even"><td>4</td>
<td>47,000</td>
<td>270</td>
<td>0.0</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>51,000</td>
<td>270</td>
<td>-0.0028</td>
</tr>
<tr class="row-even"><td>6</td>
<td>71,000</td>
<td>214</td>
<td>-0.002</td>
</tr>
</tbody>
</table>
<p>For implementation it might be convenient to write <a href="#equation-decay:app:atm:ode">(52)</a>
on the form</p>
<div class="math">
\[\frac{dp}{dz} = -\frac{Mg}{R^*(\bar T(z) + L(z)(z-h(z)))} p,\]</div>
<p>where <span class="math">\(\bar T(z)\)</span>, <span class="math">\(L(z)\)</span>, and <span class="math">\(h(z)\)</span> are piecewise constant
functions with values given in the table.
The value of the pressure at the ground <span class="math">\(z=0\)</span> is <span class="math">\(101325\)</span> Pa.</p>
</div>
<div class="section" id="simplification">
<h3>Simplification: <span class="math">\(L=0\)</span><a class="headerlink" href="#simplification" title="Permalink to this headline">¶</a></h3>
<p>One commonly used simplification is to assume that the temperature is
constant within each layer. This means that <span class="math">\(L=0\)</span>.</p>
</div>
<div class="section" id="simplification-one-layer-model">
<h3>Simplification: one-layer model<a class="headerlink" href="#simplification-one-layer-model" title="Permalink to this headline">¶</a></h3>
<p>Another commonly used approximation is to work with one layer instead of
seven. This <a class="reference external" href="http://en.wikipedia.org/wiki/Density_of_air">one-layer model</a>
is based on <span class="math">\(T(z)=T_0 - Lz\)</span>, with
sea level standard temperature <span class="math">\(T_0=288\)</span> K and
temperature lapse rate <span class="math">\(L=0.0065\)</span> K/m.
Furthermore, <span class="math">\(p_0\)</span> is the sea level atmospheric pressure <span class="math">\(1\cdot 10^5\)</span> Pa.</p>
</div>
</div>
<div class="section" id="vertical-motion-of-a-body-in-a-viscous-fluid">
<span id="decay-app-drag"></span><h2>Vertical motion of a body in a viscous fluid<a class="headerlink" href="#vertical-motion-of-a-body-in-a-viscous-fluid" title="Permalink to this headline">¶</a></h2>
<p>A body moving vertically through a fluid (liquid or gas) is subject to
three different types of forces: the gravity force, <a class="reference external" href="http://en.wikipedia.org/wiki/Drag_(physics)">the drag force</a>,
and the buoyancy force.</p>
<div class="section" id="overview-of-forces">
<h3>Overview of forces<a class="headerlink" href="#overview-of-forces" title="Permalink to this headline">¶</a></h3>
<p>The gravity force is <span class="math">\(F_g= -mg\)</span>, where <span class="math">\(m\)</span> is the mass of the body and
<span class="math">\(g\)</span> is the acceleration of gravity.
The uplift or buoyancy force (&#8220;Archimedes force&#8221;) <span class="math">\(F_b = \varrho gV\)</span>,
where <span class="math">\(\varrho\)</span> is the density of the fluid and
<span class="math">\(V\)</span> is the volume of the body.
Forces and other quantities are taken as positive in the upward
direction.</p>
<p>The drag force is of two types, depending on the Reynolds number</p>
<div class="math">
\[\hbox{Re} = \frac{\varrho dv}{\mu},\]</div>
<p>where <span class="math">\(d\)</span> is the diameter of the body in
the direction perpendicular to the flow, <span class="math">\(v\)</span> is the velocity of the
body, and <span class="math">\(\mu\)</span> is the dynamic viscosity of the fluid.
When <span class="math">\(\hbox{Re} &lt; 1\)</span>, the drag force is fairly well modeled by
the so-called Stokes&#8217; drag,
which for a spherical body of diameter <span class="math">\(d\)</span> reads</p>
<div class="math">
\[F_d^{(S)} = - 3\pi d\mu v
\thinspace .\]</div>
<p>For large Re, typically <span class="math">\(\hbox{Re} &gt; 10^3\)</span>, the drag force is quadratic
in the velocity:</p>
<div class="math">
\[F_d^{(q)} = -{1\over2}C_D\varrho A|v|v,\]</div>
<p>where <span class="math">\(C_D\)</span> is a dimensionless drag coefficient depending on the body&#8217;s shape,
<span class="math">\(A\)</span> is the cross-sectional area as
produced by a cut plane, perpendicular to the motion, through the thickest
part of the body. The superscripts <span class="math">\({}^q\)</span> and <span class="math">\({}^S\)</span> in
<span class="math">\(F_d^{(S)}\)</span> and <span class="math">\(F_d^{(q)}\)</span> indicates Stokes drag and quadratic drag,
respectively.</p>
</div>
<div class="section" id="equation-of-motion">
<h3>Equation of motion<a class="headerlink" href="#equation-of-motion" title="Permalink to this headline">¶</a></h3>
<p>All the mentioned forces act in the vertical direction.
Newton&#8217;s second law of motion applied to the body says that the sum of
these forces must equal the mass of the body times its acceleration
<span class="math">\(a\)</span> in the vertical direction.</p>
<div class="math">
\[ma = F_g + F_d^{(S)} + F_b ,\]</div>
<p>if we choose to work with the Stokes drag.
Inserting the expressions for the forces yields</p>
<div class="math">
\[ma = -mg - 3\pi d\mu v + \varrho gV
\thinspace .\]</div>
<p>The unknowns here are <span class="math">\(v\)</span> and <span class="math">\(a\)</span>, i.e., we have two unknowns but only
one equation. From kinematics in physics we know that
the acceleration is the time derivative of the velocity: <span class="math">\(a = dv/dt\)</span>.
This is our second equation.
We can easily eliminate <span class="math">\(a\)</span> and get a single differential equation for <span class="math">\(v\)</span>:</p>
<div class="math">
\[m{dv\over dt} = -mg - 3\pi d\mu v + \varrho gV
\thinspace .\]</div>
<p>A small rewrite of this equation is handy: We express <span class="math">\(m\)</span> as <span class="math">\(\varrho_bV\)</span>,
where <span class="math">\(\varrho_b\)</span> is the density of the body, and we divide by
the mass to get</p>
<div class="math" id="equation-decay:app:fallingbody:model:S">
<span class="eqno">(53)</span>\[     v'(t) = - \frac{3\pi d\mu}{\varrho_b V} v + g\left(\frac{\varrho}{\varrho_b} -1\right)\]\[     \thinspace .\]</div>
<p>We may introduce the constants</p>
<div class="math">
\[a = \frac{3\pi d\mu}{\varrho_b V},\quad
b = g\left(\frac{\varrho}{\varrho_b} -1\right),\]</div>
<p>so that the structure of the differential equation becomes evident:</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:S">
<span class="eqno">(54)</span>\[     v'(t) = -av(t) + b\]\[     \thinspace .\]</div>
<p>The corresponding initial condition is <span class="math">\(v(0)=v_0\)</span> for some prescribed
starting velocity <span class="math">\(v_0\)</span>.</p>
<p>This derivation can be repeated with the quadratic drag force
<span class="math">\(F_d^{(q)}\)</span>, yielding</p>
<div class="math" id="equation-decay:app:fallingbody:model:q">
<span class="eqno">(55)</span>\[     v'(t) =
     -{1\over2}C_D{\varrho A\over\varrho_b V}|v|v +
     g\left({\varrho\over\varrho_b} - 1\right)
     \thinspace .\]</div>
<p>Defining</p>
<div class="math">
\[a = {1\over2}C_D{\varrho A\over\varrho_b V},\]</div>
<p>and <span class="math">\(b\)</span> as above, we can write <a href="#equation-decay:app:fallingbody:model:q">(55)</a> as</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:q">
<span class="eqno">(56)</span>\[     v'(t) = -a|v|v + b
     \thinspace .\]</div>
</div>
<div class="section" id="terminal-velocity">
<span id="index-71"></span><h3>Terminal velocity<a class="headerlink" href="#terminal-velocity" title="Permalink to this headline">¶</a></h3>
<p>An interesting aspect of <a href="#equation-decay:app:fallingbody:gmodel:S">(54)</a> and
<a href="#equation-decay:app:fallingbody:gmodel:q">(56)</a> is whether we can approach
a constant, so-called <em>terminal velocity</em> <span class="math">\(v_T\)</span>, as <span class="math">\(t\rightarrow\infty\)</span>. The
existence of <span class="math">\(v_T\)</span> assumes that
<span class="math">\(v'(t)\rightarrow 0\)</span> as <span class="math">\(t\rightarrow\infty\)</span> and therefore</p>
<div class="math">
\[0 = -av_T + b\]</div>
<p>and</p>
<div class="math">
\[0 = -a|v_T|v_T + b
\thinspace .\]</div>
<p>The former equation implies <span class="math">\(v_T = b/a\)</span>, while the latter has solutions
<span class="math">\(v_T =-\sqrt{|b|/a}\)</span> for a falling body (<span class="math">\(v_T&lt;0\)</span>) and
<span class="math">\(v_T = \sqrt{b/a}\)</span> for a rising body (<span class="math">\(v_T&gt;0\)</span>).</p>
</div>
<div class="section" id="a-crank-nicolson-scheme">
<h3>A Crank-Nicolson scheme<a class="headerlink" href="#a-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h3>
<p>Both governing equations, the Stokes&#8217; drag model
<a href="#equation-decay:app:fallingbody:gmodel:S">(54)</a> and the quadratic drag model
<a href="#equation-decay:app:fallingbody:gmodel:q">(56)</a>, can be readily solved
by the Forward Euler scheme. The Crank-Nicolson method gives
a nonlinear equation in <span class="math">\(v\)</span> when applied to
<a href="#equation-decay:app:fallingbody:gmodel:q">(56)</a>:</p>
<div class="math">
\[\frac{v^{n+1}-v^n}{\Delta t}
= -a^{n+\frac{1}{2}}\frac{1}{2}(|v^{n+1}|v^{n+1} + a^n|v^n|v^n) + b^{n+\frac{1}{2}}
\thinspace .\]</div>
<p>However, instead of approximating the term <span class="math">\(-|v|v\)</span> by an arithmetic
average, we can use a <em>geometric average</em>:</p>
<div class="math">
\[|v|v^{n+\frac{1}{2}} \approx |v|^nv^{n+1}
\thinspace .\]</div>
<p>The error is of second order in <span class="math">\(\Delta t\)</span>, just as for the arithmetic
average. Now,</p>
<div class="math">
\[\frac{v^{n+1}-v^n}{\Delta t} = - a^{n+\frac{1}{2}}|v^{n}|v^{n+1} + b^{n+\frac{1}{2}}\]</div>
<p>becomes a linear equation in <span class="math">\(v^{n+1}\)</span>, and we can easily solve for <span class="math">\(v^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:app:fallingbody:gmodel:q:CN">
<span class="eqno">(57)</span>\[     v^{n+1} = \frac{v_n + \Delta t b^{n+\frac{1}{2}}}{1 + \Delta t a^{n+\frac{1}{2}}|v^{n}|}\]</div>
</div>
<div class="section" id="physical-data">
<h3>Physical data<a class="headerlink" href="#physical-data" title="Permalink to this headline">¶</a></h3>
<p>Suitable values of <span class="math">\(\mu\)</span> are <span class="math">\(1.8\cdot 10^{-5}\hbox{ Pa}\, \hbox{s}\)</span> for air
and <span class="math">\(8.9\cdot 10^{-4}\hbox{ Pa}\, \hbox{s}\)</span> for water.
Densities can be taken as <span class="math">\(1.2\hbox{ kg/m}^3\)</span> for air and as
<span class="math">\(1.0\cdot 10^3\hbox{ kg/m}^3\)</span> for water. For considerable vertical
displacement in the atmosphere one should take into account that
the density of air varies with height, see the section <a class="reference internal" href="#decay-app-atm"><em>Decay of atmospheric pressure with altitude</em></a>.
One possible density variation arises from the one-layer model
in the section <a class="reference internal" href="#decay-app-atm"><em>Decay of atmospheric pressure with altitude</em></a>.</p>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Drag_coefficient">drag coefficient</a> <span class="math">\(C_D\)</span> depends heavily
on the shape of the body.  Some values are: 0.45 for a sphere, 0.42
for a semi-sphere, 1.05 for a cube, 0.82 for a long cylinder (with the
length along the vertical direction), 0.75 for a rocket,
1.0-1.3 for a man in upright position, 1.3 for a flat plate perpendicular
to the flow, and
0.04 for a streamlined (droplet-like) body.</p>
</div>
<div class="section" id="verification">
<h3>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h3>
<p>To verify the program, one may assume a heavy body in air such that the <span class="math">\(F_b\)</span>
force can be neglected, and assume a small velocity such that the
air resistance <span class="math">\(F_d\)</span> can also be neglected. Setting <span class="math">\(\varrho =0\)</span>
removes both these terms from the equation. The motion then leads to
the velocity
<span class="math">\(v(t)=v_0 - gt\)</span>, which is linear in <span class="math">\(t\)</span> and therefore should be
reproduced to machine precision (say tolerance <span class="math">\(10^{-15}\)</span>) by any
implementation based on the Crank-Nicolson or Forward Euler schemes.</p>
<p>Another verification, but not as powerful as the one above,
can be based on computing the terminal velocity and comparing with
the exact expressions.</p>
</div>
</div>
</div>
<div class="section" id="id24">
<h1>Exercises<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-23-simulate-the-pressure-drop-in-the-atmosphere">
<span id="decay-app-exer-atm1"></span><h2>Exercise 23: Simulate the pressure drop in the atmosphere<a class="headerlink" href="#exercise-23-simulate-the-pressure-drop-in-the-atmosphere" title="Permalink to this headline">¶</a></h2>
<p>We consider the models for atmospheric pressure in
the section <a class="reference internal" href="#decay-app-atm"><em>Decay of atmospheric pressure with altitude</em></a>.
Make a program with three functions,</p>
<blockquote>
<div><ul class="simple">
<li>one computing the pressure <span class="math">\(p(z)\)</span> using a seven-layer model
and varying <span class="math">\(L\)</span>,</li>
<li>one computing <span class="math">\(p(z)\)</span> using a seven-layer model,
but with constant temperature in each layer, and</li>
<li>one computing <span class="math">\(p(z)\)</span> based on the
one-layer model.</li>
</ul>
</div></blockquote>
<p>How can these implementations be verified? Should ease of verification
impact how you code the functions?
Compare the three models in a plot.
Filename: <tt class="docutils literal"><span class="pre">atmospheric_pressure.py</span></tt>.</p>
</div>
<div class="section" id="exercise-24-make-a-program-for-vertical-motion-in-a-fluid">
<span id="decay-app-exer-drag-prog"></span><h2>Exercise 24: Make a program for vertical motion in a fluid<a class="headerlink" href="#exercise-24-make-a-program-for-vertical-motion-in-a-fluid" title="Permalink to this headline">¶</a></h2>
<p>Implement the Stokes&#8217; drag model <a href="#equation-decay:app:fallingbody:model:S">(53)</a>
and the quadratic drag model <a href="#equation-decay:app:fallingbody:model:q">(55)</a> from
the section <a class="reference internal" href="#decay-app-drag"><em>Vertical motion of a body in a viscous fluid</em></a> in a program, using the Crank-Nicolson
scheme as explained. At each time level, compute the Reynolds number
Re and choose the Stokes&#8217; drag model if <span class="math">\(\hbox{Re} &lt; 1\)</span> and the
quadratic drag model otherwise.  Include nose tests (in the file) that
runs the two suggested verification tests in the section <a class="reference internal" href="#decay-app-drag"><em>Vertical motion of a body in a viscous fluid</em></a>.
Filename: <tt class="docutils literal"><span class="pre">vertical_motion.py</span></tt>.</p>
</div>
<div class="section" id="exercise-25-plot-forces-acting-in-vertical-motion-in-a-fluid">
<span id="decay-app-exer-drag-prog-viz"></span><h2>Exercise 25: Plot forces acting in vertical motion in a fluid<a class="headerlink" href="#exercise-25-plot-forces-acting-in-vertical-motion-in-a-fluid" title="Permalink to this headline">¶</a></h2>
<p>Extend the program from <a class="reference internal" href="#decay-app-exer-drag-prog"><em>Exercise 24: Make a program for vertical motion in a fluid</em></a> to compute
the forces <span class="math">\(F_d^{(q)}\)</span>, <span class="math">\(F_d^{(S)}\)</span>, <span class="math">\(F_g\)</span>, and <span class="math">\(F_b\)</span>.
Plot the latter two and the relevant drag force, depending on
the value of the Reynolds number.
Filename: <tt class="docutils literal"><span class="pre">vertical_motion_force_plot.py</span></tt>.</p>
</div>
<div class="section" id="exercise-26-simulate-a-free-fall-of-a-parachute-jumper">
<span id="decay-app-exer-drag-parachute1"></span><h2>Exercise 26: Simulate a free fall of a parachute jumper<a class="headerlink" href="#exercise-26-simulate-a-free-fall-of-a-parachute-jumper" title="Permalink to this headline">¶</a></h2>
<p>Apply the program from <a class="reference internal" href="#decay-app-exer-drag-prog"><em>Exercise 24: Make a program for vertical motion in a fluid</em></a> to
a parachute jumper in free fall before the parachute opens.
Set the density of the human body
as <span class="math">\(\varrho_b = 1003 \hbox{ kg}/\hbox{m}^3\)</span>
and the mass as <span class="math">\(m=80\)</span> kg, implying <span class="math">\(V=m/\varrho_b = 0.08\hbox{ m}^3\)</span>.
One can base
the cross-sectional area <span class="math">\(A\)</span> the assumption of a circular cross section
of diameter 50 cm,
giving <span class="math">\(A= \pi R^2 = 0.9\hbox{ m}^2\)</span>.
The density of air decreases with height, but for a free fall
we may use the approximation
<span class="math">\(\varrho = 0.79 \hbox{ kg/m}^3\)</span> which is relevant for about 5000 m height.
The <span class="math">\(C_D\)</span> coefficient can be set to 1.2. Start with <span class="math">\(v_0=0\)</span>.
Filename: <tt class="docutils literal"><span class="pre">parachute_jumper1.py</span></tt>.</p>
</div>
<div class="section" id="exercise-27-simulate-a-complete-parachute-jump">
<span id="decay-app-exer-drag-parachute2"></span><h2>Exercise 27: Simulate a complete parachute jump<a class="headerlink" href="#exercise-27-simulate-a-complete-parachute-jump" title="Permalink to this headline">¶</a></h2>
<p>A parachute jumper moves a vertical distance of about 5000 m where
<span class="math">\(A\)</span> and <span class="math">\(C_D\)</span> change dramatically when the parachute is released.
Moreover, the density of air changes with altitude.
Add a differential equation for the altitude <span class="math">\(z\)</span>,</p>
<div class="math">
\[z'(t) = v(t),\]</div>
<p>and a differential equation for the air density, based on
the information for the one-layer atmospheric model in
the section <a class="reference internal" href="#decay-app-atm"><em>Decay of atmospheric pressure with altitude</em></a>:</p>
<div class="math">
\[\begin{split}p'(z) &amp;= -\frac{Mg}{R^*(T_0+Lz)} p,\\
\varrho &amp;= p \frac{M}{R^*T}
\thinspace .\end{split}\]</div>
<p>Extend the program from <a class="reference internal" href="#decay-app-exer-drag-prog"><em>Exercise 24: Make a program for vertical motion in a fluid</em></a> to
handle three coupled differential equations. With the Crank-Nicolson
method, one must solve a <span class="math">\(3\times 3\)</span> system of equations at each time
level, since <span class="math">\(p\)</span> depends on <span class="math">\(z\)</span>, which depends on <span class="math">\(v\)</span>, which depends
on <span class="math">\(\varrho\)</span>, which depends on <span class="math">\(p\)</span>.  Switching to the Forward Euler
method avoids the need to solve coupled equations, but demands smaller
<span class="math">\(\Delta t\)</span> for accuracy. Make sure <span class="math">\(A\)</span> and <span class="math">\(C_D\)</span> can be changed at
some time <span class="math">\(t_p\)</span> when the parachute is released.
Make nose tests of this program based on the
same verification cases as outlined in <a class="reference internal" href="#decay-app-exer-drag-prog"><em>Exercise 24: Make a program for vertical motion in a fluid</em></a>.</p>
<p>Use the program to simulate a jump from <span class="math">\(z=5000\)</span> m to the ground <span class="math">\(z=0\)</span>.
Filename: <tt class="docutils literal"><span class="pre">parachute_jumper2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-28-simulate-a-rising-ball-in-water">
<span id="decay-app-exer-drag-rising"></span><h2>Exercise 28: Simulate a rising ball in water<a class="headerlink" href="#exercise-28-simulate-a-rising-ball-in-water" title="Permalink to this headline">¶</a></h2>
<p>A ball with the size of a soccer ball is placed in somewhat deep
water, and we seek to model its motion upwards.  The buoyancy force
<span class="math">\(F_b\)</span> is now the driving force.
Set <span class="math">\(A=\pi a^2\)</span> with <span class="math">\(a=11\)</span> cm, the mass of the ball is 0.43
kg, the density of water is <span class="math">\(1000\hbox{ kg/m}^3\)</span>, and <span class="math">\(C_D\)</span> is 0.45.
Start with <span class="math">\(v_0=0\)</span> and see how the ball rises.
Filename: <tt class="docutils literal"><span class="pre">rising_ball.py</span></tt>.</p>
</div>
<div class="section" id="exercise-29-radioactive-decay-of-carbon-14">
<span id="decay-app-exer-radio-c14"></span><h2>Exercise 29: Radioactive decay of Carbon-14<a class="headerlink" href="#exercise-29-radioactive-decay-of-carbon-14" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Carbon-14">Carbon-14</a> isotope,
whose radioactive decay is used extensively in dating organic material
that is tens of thousands of years old, has a half-life of <span class="math">\(5,730\)</span>
years.  Determine the age of an organic material that contains 8.4%
of its initial amount of Carbon-14.  Use a time unit of 1 year in the
computations.  The uncertainty in the half time of Carbon-14 is <span class="math">\(\pm
40\)</span> years.  What is the corresponding uncertainty in the estimate of
the age?  (Use simulations, not the exact solution.)
Filename: <tt class="docutils literal"><span class="pre">carbon14.py</span></tt>.</p>
</div>
<div class="section" id="exercise-30-radioactive-decay-of-two-substances">
<span id="decay-app-exer-radio-twosubst"></span><h2>Exercise 30: Radioactive decay of two substances<a class="headerlink" href="#exercise-30-radioactive-decay-of-two-substances" title="Permalink to this headline">¶</a></h2>
<p>Consider two radioactive substances A and B. The nuclei in substance A
decay to form nuclei of type B with a half-life <span class="math">\(A_{1/2}\)</span>, while
substance B decay to form type A nuclei with a half-life <span class="math">\(B_{1/2}\)</span>.
Letting <span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> be the fractions of the initial amount of
material in substance A and B, respectively, the following system of
ODEs governs the evolution of <span class="math">\(u_A(t)\)</span> and <span class="math">\(u_B(t)\)</span>:</p>
<div class="math">
\[\begin{split}\frac{1}{\ln 2} u_A' &amp;= u_B/B_{1/2} - u_A/A_{1/2},\\
\frac{1}{\ln 2} u_B' &amp;= u_A/A_{1/2} - u_B/B_{1/2},\end{split}\]</div>
<p>with <span class="math">\(u_A(0)=u_B(0)=1\)</span>.</p>
<p>Make a simulation program that solves for <span class="math">\(u_A(t)\)</span> and <span class="math">\(u_B(t)\)</span>.
Verify the implementation by computing analytically
the limiting values of
<span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> as <span class="math">\(t\rightarrow \infty\)</span> (assume <span class="math">\(u_A',u_B'\rightarrow 0\)</span>)
and comparing these with those obtained numerically.</p>
<p>Run the program for the case of <span class="math">\(A_{1/2}=10\)</span> minutes and <span class="math">\(B_{1/2}=50\)</span> minutes.
Use a time unit of 1 minute. Plot <span class="math">\(u_A\)</span> and <span class="math">\(u_B\)</span> versus time in the same
plot.
Filename: <tt class="docutils literal"><span class="pre">radioactive_decay_2subst.py</span></tt>.</p>
</div>
<div class="section" id="exercise-31-find-time-of-murder-from-body-temperature">
<span id="decay-app-exer-cooling-pizza"></span><h2>Exercise 31: Find time of murder from body temperature<a class="headerlink" href="#exercise-31-find-time-of-murder-from-body-temperature" title="Permalink to this headline">¶</a></h2>
<p>A detective measures the temperature of a dead body to be
26.7 C at 2 pm. One hour later
the temperature is 25.8 C. The question is when
death occurred.</p>
<p>Assume that Newton&#8217;s law of cooling <a href="#equation-decay:Newton:cooling">(49)</a>
is an appropriate mathematical
model for the evolution of the temperature in the body.
First, determine <span class="math">\(k\)</span> in <a href="#equation-decay:Newton:cooling">(49)</a> by
formulating a Forward Euler approximation with one time steep
from time 2 am to time 3 am, where knowing the two temperatures
allows for finding <span class="math">\(k\)</span>. Thereafter, simulate the temperature evolution
from the time of murder, taken as <span class="math">\(t=0\)</span>, when <span class="math">\(T=37\hbox{ C}\)</span>,
until the temperature
reaches 26.7 C. The corresponding time allows for answering when
death occurred.
Filename: <tt class="docutils literal"><span class="pre">detective.py</span></tt>.</p>
</div>
<div class="section" id="exercise-32-simulate-an-oscillating-cooling-process">
<span id="decay-app-exer-cooling-osc"></span><h2>Exercise 32: Simulate an oscillating cooling process<a class="headerlink" href="#exercise-32-simulate-an-oscillating-cooling-process" title="Permalink to this headline">¶</a></h2>
<p>The surrounding temperature <span class="math">\(T_s\)</span> in Newton&#8217;s law of cooling
<a href="#equation-decay:Newton:cooling">(49)</a> may vary in time. Assume that the
variations are periodic with period <span class="math">\(P\)</span> and amplitude <span class="math">\(a\)</span> around
a constant mean temperature <span class="math">\(T_m\)</span>:</p>
<div class="math">
\[T_s(t) = T_m + a\sin\left(\frac{2\pi}{P}t\right)
\thinspace .\]</div>
<p>Simulate a process with the following data: <span class="math">\(k=20 \hbox{ min}^{-1}\)</span>,
<span class="math">\(T(0)=5\)</span> C, <span class="math">\(T_m=25\)</span> C, <span class="math">\(a=2.5\)</span> C, and <span class="math">\(P=1\)</span> h. Also experiment with
<span class="math">\(P=10\)</span> min and <span class="math">\(P=3\)</span> h. Plot <span class="math">\(T\)</span> and <span class="math">\(T_s\)</span> in the same plot.
Filename: <tt class="docutils literal"><span class="pre">osc_cooling.py</span></tt>.</p>
</div>
<div class="section" id="exercise-33-compute-by-solving-an-ode">
<span id="decay-app-exer-signum"></span><h2>Exercise 33: Compute <span class="math">\(y=|x|\)</span> by solving an ODE<a class="headerlink" href="#exercise-33-compute-by-solving-an-ode" title="Permalink to this headline">¶</a></h2>
<p>Consider the ODE problem</p>
<div class="math">
\[\begin{split}y'(x) = \left\lbrace\begin{array}{ll}
-1, &amp; x &lt; 0,\\
1, &amp; x \geq 0
\end{array}\right.\quad x\in (-1, 1],
\quad y(1-)=1,\end{split}\]</div>
<p>which has the solution <span class="math">\(y(x)=|x|\)</span>.
Using a mesh <span class="math">\(x_0=-1\)</span>, <span class="math">\(x_1=0\)</span>, and <span class="math">\(x_2=1\)</span>, calculate by hand
<span class="math">\(y_1\)</span> and <span class="math">\(y_2\)</span> from the Forward Euler, Backward Euler, Crank-Nicolson,
and Leapfrog methods. Use all of the former three methods for computing
the <span class="math">\(y_1\)</span> value to be used in the Leapfrog calculation of <span class="math">\(y_2\)</span>.
Thereafter, visualize how these schemes perform for a uniformly partitioned
mesh with <span class="math">\(N=10\)</span> and <span class="math">\(N=11\)</span> points.
Filename: <tt class="docutils literal"><span class="pre">signum.py</span></tt>.</p>
</div>
<div class="section" id="exercise-34-simulate-growth-of-a-fortune-with-random-interest-rate">
<span id="decay-app-exer-interest"></span><h2>Exercise 34: Simulate growth of a fortune with random interest rate<a class="headerlink" href="#exercise-34-simulate-growth-of-a-fortune-with-random-interest-rate" title="Permalink to this headline">¶</a></h2>
<p>The goal of this exercise is to compute the value of a fortune subject
to inflation and a random interest rate.
Suppose that the inflation is constant at <span class="math">\(i\)</span> percent per year and that the
annual interest rate, <span class="math">\(p\)</span>, changes randomly at each time step,
starting at some value <span class="math">\(p_0\)</span> at <span class="math">\(t=0\)</span>.
The random change is from a value <span class="math">\(p^n\)</span> at <span class="math">\(t=t_n\)</span> to
<span class="math">\(p_n +\Delta p\)</span> with probability 0.25 and <span class="math">\(p_n -\Delta p\)</span> with probability 0.25.
No change occurs with probability 0.5. There is also no change if
<span class="math">\(p^{n+1}\)</span> exceeds 15 or becomes below 1.
Use a time step of one month, <span class="math">\(p_0=i\)</span>, initial fortune scaled to 1,
and simulate 1000 scenarios of
length 20 years. Compute the mean evolution of one unit of money and the
corresponding
standard deviation. Plot these two curves along with the <span class="math">\(p^n-i\)</span> curve.
Filename: <tt class="docutils literal"><span class="pre">random_interest.py</span></tt>.</p>
<p><em>Hint 1.</em> The following code snippet computes <span class="math">\(p^{n+1}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">new_interest_rate</span><span class="p">(</span><span class="n">p_n</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>  <span class="c"># uniformly distr. random number in [0,1)</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.25</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span> <span class="o">+</span> <span class="n">dp</span>
    <span class="k">elif</span> <span class="mf">0.25</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span> <span class="o">-</span> <span class="n">dp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_np1</span> <span class="o">=</span> <span class="n">p_n</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p_np1</span> <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">p_np1</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="k">else</span> <span class="n">p_n</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Hint 2.</em> If <span class="math">\(u_i(t)\)</span> is the value of the fortune in experiment number <span class="math">\(i\)</span>,
<span class="math">\(i=0,\ldots,N-1\)</span>,
the mean evolution of the fortune is</p>
<div class="math">
\[\bar u(t)= \frac{1}{N}\sum_{i=0}^{N-1} u_i(t),\]</div>
<p>and the standard deviation is</p>
<div class="math">
\[s(t) = \sqrt{\frac{1}{N-1}\left(- (\bar u(t))^2 +
                \sum_{i=0}^{N-1} (u_i(t))^2\right)}
\thinspace .\]</div>
<p>Suppose <span class="math">\(u_i(t)\)</span> is stored in an array <tt class="docutils literal"><span class="pre">u</span></tt>.
The mean and the standard deviation of the fortune
is most efficiently computed by
using to accumulation arrays, <tt class="docutils literal"><span class="pre">sum_u</span></tt> and <tt class="docutils literal"><span class="pre">sum_u2</span></tt>, and
performing <tt class="docutils literal"><span class="pre">sum_u</span> <span class="pre">+=</span> <span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">sum_u2</span> <span class="pre">+=</span> <span class="pre">u**2</span></tt> after every experiment.
This technique avoids storing all the <span class="math">\(u_i(t)\)</span> time series for
computing the statistics.</p>
</div>
<div class="section" id="exercise-35-simulate-sudden-environmental-changes-for-a-population">
<span id="decay-app-exer-pop-at"></span><h2>Exercise 35: Simulate sudden environmental changes for a population<a class="headerlink" href="#exercise-35-simulate-sudden-environmental-changes-for-a-population" title="Permalink to this headline">¶</a></h2>
<p>We shall study a population modeled by <a href="#equation-decay:app:pop:ueq">(45)</a> where
the environment, represented by <span class="math">\(r\)</span> and <span class="math">\(f\)</span>, undergoes changes with time.
Assume that there is a sudden drop (increase) in the birth (death)
rate at time <span class="math">\(t=t_r\)</span>,
because of limited nutrition or food supply:</p>
<div class="math">
\[\begin{split}a(t) =\left\lbrace\begin{array}{ll}
r_0, &amp; t&lt; t_r,\\
r_0 - A, &amp; t\geq t_r,\end{array}\right.\end{split}\]</div>
<p>This drop in population growth is compensated by a sudden net immigration
at time <span class="math">\(t_f&gt;t_r\)</span>:</p>
<div class="math">
\[\begin{split}f(t) =\left\lbrace\begin{array}{ll}
0, &amp; t&lt; t_f,\\
f_0, &amp; t\geq t_a,\end{array}\right.\end{split}\]</div>
<p>Start with <span class="math">\(r_0\)</span> and make <span class="math">\(A&gt;r_0\)</span>. Experiment these and other parameters to
illustrate the interplay of growth and decay in such a problem.
Filename: <tt class="docutils literal"><span class="pre">population_drop.py</span></tt>.</p>
</div>
<div class="section" id="exercise-36-simulate-oscillating-environment-for-a-population">
<span id="decay-app-exer-pop-osc"></span><h2>Exercise 36: Simulate oscillating environment for a population<a class="headerlink" href="#exercise-36-simulate-oscillating-environment-for-a-population" title="Permalink to this headline">¶</a></h2>
<p>This exercise is a variant of <a class="reference internal" href="#decay-app-exer-pop-at"><em>Exercise 35: Simulate sudden environmental changes for a population</em></a>.
Now we assume that the environmental conditions changes periodically with
time so that we may take</p>
<div class="math">
\[r(t) = r_0 + A\sin\left(\frac{2\pi}{P}t\right)
\thinspace .\]</div>
<p>That is, the combined birth and death rate oscillates around <span class="math">\(r_0\)</span> with
a maximum change of <span class="math">\(\pm A\)</span> repeating over a period of length <span class="math">\(P\)</span> in time.
Set <span class="math">\(f=0\)</span> and experiment with the other parameters to illustrate typical
features of the solution.
Filename: <tt class="docutils literal"><span class="pre">population_osc.py</span></tt>.</p>
</div>
<div class="section" id="exercise-37-simulate-logistic-growth">
<span id="decay-app-exer-pop-logistic1"></span><h2>Exercise 37: Simulate logistic growth<a class="headerlink" href="#exercise-37-simulate-logistic-growth" title="Permalink to this headline">¶</a></h2>
<p>Solve the logistic ODE
<a href="#equation-decay:app:pop:logistic">(46)</a> using a Crank-Nicolson scheme where
<span class="math">\((u^{n+1/2})^2\)</span> is approximated by a <em>geometric mean</em>:</p>
<div class="math">
\[(u^{n+1/2})^2 \approx u^{n+1}u^n
\thinspace .\]</div>
<p>This trick makes the discrete equation linear in <span class="math">\(u^{n+1}\)</span>.
Filename: <tt class="docutils literal"><span class="pre">logistic_growth.py</span></tt>.</p>
</div>
<div class="section" id="exercise-38-rederive-the-equation-for-continuous-compound-interest">
<span id="decay-app-exer-interest-derive"></span><h2>Exercise 38: Rederive the equation for continuous compound interest<a class="headerlink" href="#exercise-38-rederive-the-equation-for-continuous-compound-interest" title="Permalink to this headline">¶</a></h2>
<p>The ODE model <a href="#equation-decay:app:interest:eq2">(48)</a> was derived under the assumption
that <span class="math">\(r\)</span> was constant. Perform an alternative derivation without
this assumption: 1) start with <a href="#equation-decay:app:interest:eq1">(47)</a>;
2) introduce a time step <span class="math">\(\Delta t\)</span> instead of <span class="math">\(m\)</span>: <span class="math">\(\Delta t = 1/m\)</span> if
<span class="math">\(t\)</span> is measured in years; 3) divide by <span class="math">\(\Delta t\)</span> and take the
limit <span class="math">\(\Delta t\rightarrow 0\)</span>. Simulate a case where the inflation is
at a constant level <span class="math">\(I\)</span> percent per year and the interest rate oscillates
around <span class="math">\(I/2 + r_0\sin(2\pi t)\)</span>, giving <span class="math">\(r=-I/2 + r_0\sin(2\pi t)\)</span>.
Compare solutions for <span class="math">\(r_0=I, 3I/2, 2I\)</span>.
Filename: <tt class="docutils literal"><span class="pre">interest_modeling.py</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Discretizing first-order ODEs by finite difference methods</a></li>
<li><a class="reference internal" href="#finite-difference-methods-for-an-ode">Finite difference methods for an ODE</a><ul>
<li><a class="reference internal" href="#exponential-decay">Exponential decay</a></li>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#the-unifying-rule">The unifying <span class="math">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#constant-time-step">Constant time step</a></li>
<li><a class="reference internal" href="#compact-operator-notation-for-finite-differences">Compact operator notation for finite differences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a><ul>
<li><a class="reference internal" href="#making-a-program">Making a program</a><ul>
<li><a class="reference internal" href="#function-for-computing-the-numerical-solution">Function for computing the numerical solution</a></li>
<li><a class="reference internal" href="#integer-division">Integer division</a></li>
<li><a class="reference internal" href="#doc-strings">Doc strings</a></li>
<li><a class="reference internal" href="#formatting-of-numbers">Formatting of numbers</a></li>
<li><a class="reference internal" href="#running-the-program">Running the program</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verifying-the-implementation">Verifying the implementation</a><ul>
<li><a class="reference internal" href="#running-a-few-algorithmic-steps-by-hand">Running a few algorithmic steps by hand</a></li>
<li><a class="reference internal" href="#comparison-with-an-exact-discrete-solution">Comparison with an exact discrete solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-the-numerical-error">Computing the numerical error</a></li>
<li><a class="reference internal" href="#plotting-solutions">Plotting solutions</a></li>
<li><a class="reference internal" href="#plotting-with-scitools">Plotting with SciTools</a></li>
<li><a class="reference internal" href="#creating-user-interfaces">Creating user interfaces</a><ul>
<li><a class="reference internal" href="#reading-a-sequence-of-command-line-arguments">Reading a sequence of command-line arguments</a></li>
<li><a class="reference internal" href="#working-with-an-argument-parser">Working with an argument parser</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-convergence-rates">Computing convergence rates</a><ul>
<li><a class="reference internal" href="#estimating">Estimating <span class="math">\(r\)</span></a></li>
<li><a class="reference internal" href="#id3">Implementation</a></li>
<li><a class="reference internal" href="#debugging-via-convergence-rates">Debugging via convergence rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-saving-implementation">Memory-saving implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#software-engineering">Software engineering</a><ul>
<li><a class="reference internal" href="#making-a-module">Making a module</a></li>
<li><a class="reference internal" href="#prefixing-imported-functions-by-the-module-name">Prefixing imported functions by the module name</a></li>
<li><a class="reference internal" href="#doctests">Doctests</a></li>
<li><a class="reference internal" href="#unit-testing-with-nose">Unit testing with nose</a><ul>
<li><a class="reference internal" href="#basic-use-of-nose">Basic use of nose</a></li>
<li><a class="reference internal" href="#demonstrating-nose">Demonstrating nose</a></li>
<li><a class="reference internal" href="#installation-of-nose">Installation of nose</a></li>
</ul>
</li>
<li><a class="reference internal" href="#classical-unit-testing-with-unittest">Classical unit testing with unittest</a><ul>
<li><a class="reference internal" href="#basic-use-of-unittest">Basic use of unittest</a></li>
<li><a class="reference internal" href="#demonstration-of-unittest">Demonstration of unittest</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-simple-problem-and-solver-classes">Implementing simple problem and solver classes</a><ul>
<li><a class="reference internal" href="#the-problem-class">The problem class</a></li>
<li><a class="reference internal" href="#the-solver-class">The solver class</a></li>
<li><a class="reference internal" href="#the-visualizer-class">The visualizer class</a></li>
<li><a class="reference internal" href="#combing-the-objects">Combing the objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-more-advanced-problem-and-solver-classes">Implementing more advanced problem and solver classes</a><ul>
<li><a class="reference internal" href="#a-generic-class-for-parameters">A generic class for parameters</a></li>
<li><a class="reference internal" href="#id8">The problem class</a></li>
<li><a class="reference internal" href="#id9">The solver class</a></li>
<li><a class="reference internal" href="#id10">The visualizer class</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#performing-scientific-experiments">Performing scientific experiments</a><ul>
<li><a class="reference internal" href="#interpreting-output-from-other-programs">Interpreting output from other programs</a></li>
<li><a class="reference internal" href="#making-a-report">Making a report</a><ul>
<li><a class="reference internal" href="#plain-html">Plain HTML</a></li>
<li><a class="reference internal" href="#html-with-mathjax">HTML with MathJax</a></li>
<li><a class="reference internal" href="#latex">LaTeX</a></li>
<li><a class="reference internal" href="#sphinx">Sphinx</a></li>
<li><a class="reference internal" href="#markdown">Markdown</a></li>
<li><a class="reference internal" href="#wiki-formats">Wiki formats</a></li>
<li><a class="reference internal" href="#doconce">Doconce</a></li>
</ul>
</li>
<li><a class="reference internal" href="#publishing-a-complete-project">Publishing a complete project</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-1-experiment-with-integer-division">Exercise 1: Experiment with integer division</a></li>
<li><a class="reference internal" href="#exercise-2-experiment-with-wrong-computations">Exercise 2: Experiment with wrong computations</a></li>
<li><a class="reference internal" href="#exercise-3-implement-specialized-functions">Exercise 3: Implement specialized functions</a></li>
<li><a class="reference internal" href="#exercise-4-plot-the-error-function">Exercise 4: Plot the error function</a></li>
<li><a class="reference internal" href="#exercise-5-compare-methods-for-a-give-time-mesh">Exercise 5: Compare methods for a give time mesh</a></li>
<li><a class="reference internal" href="#exercise-6-change-formatting-of-numbers-and-debug">Exercise 6: Change formatting of numbers and debug</a></li>
<li><a class="reference internal" href="#exercise-7-write-a-doctest">Exercise 7: Write a doctest</a></li>
<li><a class="reference internal" href="#exercise-8-write-a-nose-test">Exercise 8: Write a nose test</a></li>
<li><a class="reference internal" href="#exercise-9-make-a-module">Exercise 9: Make a module</a></li>
<li><a class="reference internal" href="#exercise-10-make-use-of-a-class-implementation">Exercise 10: Make use of a class implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-rule-for-a-decay-ode">Analysis of the <span class="math">\(\theta\)</span>-rule for a decay ODE</a><ul>
<li><a class="reference internal" href="#discouraging-numerical-solutions">Discouraging numerical solutions</a></li>
<li><a class="reference internal" href="#experimental-investigation-of-oscillatory-solutions">Experimental investigation of oscillatory solutions</a></li>
<li><a class="reference internal" href="#exact-numerical-solution">Exact numerical solution</a></li>
<li><a class="reference internal" href="#stability">Stability</a></li>
<li><a class="reference internal" href="#comparing-amplification-factors">Comparing Amplification Factors</a></li>
<li><a class="reference internal" href="#series-expansion-of-amplification-factors">Series Expansion of Amplification Factors</a></li>
<li><a class="reference internal" href="#local-error">Local error</a></li>
<li><a class="reference internal" href="#analytical-comparison-of-schemes">Analytical comparison of schemes</a></li>
<li><a class="reference internal" href="#the-real-global-error-at-a-point">The real (global) error at a point</a></li>
<li><a class="reference internal" href="#integrated-errors">Integrated errors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id20">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-11-explore-the-rule-for-exponential-growth">Exercise 11: Explore the <span class="math">\(\theta\)</span>-rule for exponential growth</a></li>
<li><a class="reference internal" href="#exercise-12-summarize-investigations-in-a-report">Exercise 12: Summarize investigations in a report</a></li>
<li><a class="reference internal" href="#exercise-13-plot-amplification-factors-for-exponential-growth">Exercise 13: Plot amplification factors for exponential growth</a></li>
</ul>
</li>
<li><a class="reference internal" href="#model-extensions">Model extensions</a><ul>
<li><a class="reference internal" href="#extension-to-a-variable-coefficient">Extension to a variable coefficient</a></li>
<li><a class="reference internal" href="#extension-to-a-source-term">Extension to a source term</a><ul>
<li><a class="reference internal" href="#schemes">Schemes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-the-generalized-model-problem">Implementation of the generalized model problem</a><ul>
<li><a class="reference internal" href="#deriving-the-rule-formula">Deriving the <span class="math">\(\theta\)</span>-rule formula</a></li>
<li><a class="reference internal" href="#the-python-code">The Python code</a></li>
<li><a class="reference internal" href="#implementations-of-variable-coefficients">Implementations of variable coefficients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-via-trivial-solutions">Verification via trivial solutions</a></li>
<li><a class="reference internal" href="#verification-via-manufactured-solutions">Verification via manufactured solutions</a></li>
<li><a class="reference internal" href="#extension-to-systems-of-odes">Extension to systems of ODEs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-first-order-odes">General first-order ODEs</a><ul>
<li><a class="reference internal" href="#generic-form">Generic form</a></li>
<li><a class="reference internal" href="#the-odespy-software">The Odespy software</a></li>
<li><a class="reference internal" href="#example-runge-kutta-methods">Example: Runge-Kutta methods</a><ul>
<li><a class="reference internal" href="#remark-about-using-the-rule-in-odespy">Remark about using the <span class="math">\(\theta\)</span>-rule in Odespy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-adaptive-runge-kutta-methods">Example: Adaptive Runge-Kutta methods</a></li>
<li><a class="reference internal" href="#other-schemes">Other schemes</a><ul>
<li><a class="reference internal" href="#implicit-2-step-backward-scheme">Implicit 2-step backward scheme</a></li>
<li><a class="reference internal" href="#the-leapfrog-scheme">The Leapfrog scheme</a></li>
<li><a class="reference internal" href="#the-filtered-leapfrog-scheme">The filtered Leapfrog scheme</a></li>
<li><a class="reference internal" href="#nd-order-runge-kutta-scheme">2nd-order Runge-Kutta scheme</a></li>
<li><a class="reference internal" href="#nd-order-adams-bashforth-scheme">2nd-order Adams-Bashforth scheme</a></li>
<li><a class="reference internal" href="#rd-order-adams-bashforth-scheme">3rd-order Adams-Bashforth scheme</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id21">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-14-implement-the-2-step-backward-scheme">Exercise 14: Implement the 2-step backward scheme</a></li>
<li><a class="reference internal" href="#exercise-15-implement-the-leapfrog-scheme">Exercise 15: Implement the Leapfrog scheme</a></li>
<li><a class="reference internal" href="#exercise-16-experiment-with-the-leapfrog-scheme">Exercise 16: Experiment with the Leapfrog scheme</a></li>
<li><a class="reference internal" href="#exercise-17-analyze-the-leapfrog-scheme">Exercise 17: Analyze the Leapfrog scheme</a></li>
<li><a class="reference internal" href="#exercise-18-implement-the-2nd-order-adams-bashforth-scheme">Exercise 18: Implement the 2nd-order Adams-Bashforth scheme</a></li>
<li><a class="reference internal" href="#exercise-19-implement-the-3rd-order-adams-bashforth-scheme">Exercise 19: Implement the 3rd-order Adams-Bashforth scheme</a></li>
<li><a class="reference internal" href="#exercise-20-generalize-a-class-implementation">Exercise 20: Generalize a class implementation</a></li>
<li><a class="reference internal" href="#exercise-21-generalize-an-advanced-class-implementation">Exercise 21: Generalize an advanced class implementation</a></li>
<li><a class="reference internal" href="#exercise-22-make-a-unified-implementation-of-many-schemes">Exercise 22: Make a unified implementation of many schemes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#applications-of-exponential-decay-models">Applications of exponential decay models</a><ul>
<li><a class="reference internal" href="#evolution-of-a-population">Evolution of a population</a></li>
<li><a class="reference internal" href="#compound-interest-and-inflation">Compound interest and inflation</a></li>
<li><a class="reference internal" href="#radioactive-decay">Radioactive Decay</a></li>
<li><a class="reference internal" href="#newton-s-law-of-cooling">Newton&#8217;s law of cooling</a></li>
<li><a class="reference internal" href="#decay-of-atmospheric-pressure-with-altitude">Decay of atmospheric pressure with altitude</a><ul>
<li><a class="reference internal" href="#multiple-atmospheric-layers">Multiple atmospheric layers</a></li>
<li><a class="reference internal" href="#simplification">Simplification: <span class="math">\(L=0\)</span></a></li>
<li><a class="reference internal" href="#simplification-one-layer-model">Simplification: one-layer model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vertical-motion-of-a-body-in-a-viscous-fluid">Vertical motion of a body in a viscous fluid</a><ul>
<li><a class="reference internal" href="#overview-of-forces">Overview of forces</a></li>
<li><a class="reference internal" href="#equation-of-motion">Equation of motion</a></li>
<li><a class="reference internal" href="#terminal-velocity">Terminal velocity</a></li>
<li><a class="reference internal" href="#a-crank-nicolson-scheme">A Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#physical-data">Physical data</a></li>
<li><a class="reference internal" href="#verification">Verification</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id24">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-23-simulate-the-pressure-drop-in-the-atmosphere">Exercise 23: Simulate the pressure drop in the atmosphere</a></li>
<li><a class="reference internal" href="#exercise-24-make-a-program-for-vertical-motion-in-a-fluid">Exercise 24: Make a program for vertical motion in a fluid</a></li>
<li><a class="reference internal" href="#exercise-25-plot-forces-acting-in-vertical-motion-in-a-fluid">Exercise 25: Plot forces acting in vertical motion in a fluid</a></li>
<li><a class="reference internal" href="#exercise-26-simulate-a-free-fall-of-a-parachute-jumper">Exercise 26: Simulate a free fall of a parachute jumper</a></li>
<li><a class="reference internal" href="#exercise-27-simulate-a-complete-parachute-jump">Exercise 27: Simulate a complete parachute jump</a></li>
<li><a class="reference internal" href="#exercise-28-simulate-a-rising-ball-in-water">Exercise 28: Simulate a rising ball in water</a></li>
<li><a class="reference internal" href="#exercise-29-radioactive-decay-of-carbon-14">Exercise 29: Radioactive decay of Carbon-14</a></li>
<li><a class="reference internal" href="#exercise-30-radioactive-decay-of-two-substances">Exercise 30: Radioactive decay of two substances</a></li>
<li><a class="reference internal" href="#exercise-31-find-time-of-murder-from-body-temperature">Exercise 31: Find time of murder from body temperature</a></li>
<li><a class="reference internal" href="#exercise-32-simulate-an-oscillating-cooling-process">Exercise 32: Simulate an oscillating cooling process</a></li>
<li><a class="reference internal" href="#exercise-33-compute-by-solving-an-ode">Exercise 33: Compute <span class="math">\(y=|x|\)</span> by solving an ODE</a></li>
<li><a class="reference internal" href="#exercise-34-simulate-growth-of-a-fortune-with-random-interest-rate">Exercise 34: Simulate growth of a fortune with random interest rate</a></li>
<li><a class="reference internal" href="#exercise-35-simulate-sudden-environmental-changes-for-a-population">Exercise 35: Simulate sudden environmental changes for a population</a></li>
<li><a class="reference internal" href="#exercise-36-simulate-oscillating-environment-for-a-population">Exercise 36: Simulate oscillating environment for a population</a></li>
<li><a class="reference internal" href="#exercise-37-simulate-logistic-growth">Exercise 37: Simulate logistic growth</a></li>
<li><a class="reference internal" href="#exercise-38-rederive-the-equation-for-continuous-compound-interest">Exercise 38: Rederive the equation for continuous compound interest</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Preliminary notes for INF5620</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Preliminary notes for INF5620"
             >previous</a> |</li>
        <li><a href="index.html">Preliminary notes for INF5620 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Hans Petter Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>