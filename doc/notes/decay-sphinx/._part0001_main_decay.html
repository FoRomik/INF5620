

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite difference methods &mdash; Introduction to computing with finite difference methods</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Introduction to computing with finite difference methods" href="index.html" />
    <link rel="next" title="Implementation (1)" href="._part0002_main_decay.html" />
    <link rel="prev" title="Introduction to computing with finite difference methods" href="._part0000_main_decay.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._part0002_main_decay.html" title="Implementation (1)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._part0000_main_decay.html" title="Introduction to computing with finite difference methods"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Introduction to computing with finite difference methods</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="finite-difference-methods">
<span id="decay-basics"></span><h1>Finite difference methods<a class="headerlink" href="#finite-difference-methods" title="Permalink to this headline">¶</a></h1>
<div class="admonition-goal admonition">
<p class="first admonition-title">Goal</p>
<p class="last">We explain the basic ideas of finite difference methods
using a simple ordinary differential equation <span class="math">\(u'=-au\)</span> as
primary example.
Emphasis is put on the reasoning when discretizing the problem and
introduction of key concepts such as mesh, mesh function,
finite difference approximations, averaging in a mesh,
deriation of algorithms, and discrete operator notation.</p>
</div>
<div class="section" id="a-basic-model-for-exponential-decay">
<span id="decay-model"></span><h2>A basic model for exponential decay<a class="headerlink" href="#a-basic-model-for-exponential-decay" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><p id="index-1">Our model problem is perhaps the simplest ordinary differential
equation (ODE):</p>
<div class="math">
\[u'(t) = -au(t),\]</div>
<p>Here, <span class="math">\(a&gt;0\)</span> is a constant and <span class="math">\(u'(t)\)</span> means differentiation with
respect to time <span class="math">\(t\)</span>. This type of equation arises in a number of
widely different phenomena where some quantity <span class="math">\(u\)</span> undergoes
exponential reduction. Examples include radioactive decay, population
decay, investment decay, cooling of an object, pressure decay in the
atmosphere, and retarded motion in fluids (for some of these models,
<span class="math">\(a\)</span> can be negative as well), see the section <a class="reference internal" href="main_decay.html#decay-app"><em>Applications of exponential decay models</em></a> for details
and motivation.  We have chosen this particular ODE not only because
its applications are relevant, but even more because studying
numerical solution methods for this simple ODE gives important insight
that can be reused in much more complicated settings, in particular
when solving diffusion-type partial differential equations.</p>
<p>The analytical solution of the ODE is found by the method of
separation of variables, which results in</p>
<div class="math">
\[u(t) = Ce^{-at},\]</div>
<p>for any arbitrary constant <span class="math">\(C\)</span>.
To formulate a mathematical problem for which there
is a unique solution, we need a condition to fix the value of <span class="math">\(C\)</span>.
This condition is known as the <em>initial condition</em> and stated as
<span class="math">\(u(0)=I\)</span>. That is, we know the
value <span class="math">\(I\)</span> of <span class="math">\(u\)</span> when the process starts at <span class="math">\(t=0\)</span>. The exact solution
is then <span class="math">\(u(t)=Ie^{-at}\)</span>.</p>
<p>We seek the solution <span class="math">\(u(t)\)</span> of the ODE for <span class="math">\(t\in (0,T]\)</span>. The point <span class="math">\(t=0\)</span> is not
included since we know <span class="math">\(u\)</span> here and assume that the equation governs
<span class="math">\(u\)</span> for <span class="math">\(t&gt;0\)</span>. The complete ODE problem then reads: find <span class="math">\(u(t)\)</span>
such that</p>
<div class="math" id="equation-decay:problem">
<span class="eqno">(1)</span>\[     u' = -au,\ t\in (0,T], \quad u(0)=I\thinspace .\]</div>
<p>This is known as a <em>continuous problem</em> because the parameter <span class="math">\(t\)</span>
varies continuously from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>. For each <span class="math">\(t\)</span> we have a corresponding
<span class="math">\(u(t)\)</span>. There are hence infinitely many values of <span class="math">\(t\)</span> and <span class="math">\(u(t)\)</span>.
The purpose of a numerical method is to formulate a corresponding
<em>discrete</em> problem whose solution is characterized by a finite number of values,
which can be computed in a finite number of steps on a computer.</p>
</div>
<div class="section" id="the-forward-euler-scheme">
<span id="decay-schemes-fe"></span><h2>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>Solving an ODE like <a href="#equation-decay:problem">(1)</a> by a finite difference method
consists of the following four steps:</p>
<ol class="arabic simple">
<li>discretizing the domain,</li>
<li>fulfilling the equation at discrete time points,</li>
<li>replacing derivatives by finite differences,</li>
<li>formulating a recursive algorithm.</li>
</ol>
<span class="target" id="index-2"></span><div class="section" id="step-1-discretizing-the-domain">
<span id="index-3"></span><h3>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The time domain <span class="math">\([0,T]\)</span> is represented by a finite number of
<span class="math">\(N_t+1\)</span> points</p>
<div class="math">
\[\begin{split}0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T\thinspace .\end{split}\]</div>
<p>The collection of points <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span> constitutes a <em>mesh</em>
or <em>grid</em>. Often the mesh points will be uniformly spaced in
the domain <span class="math">\([0,T]\)</span>, which means that the spacing <span class="math">\(t_{n+1}-t_n\)</span> is
the same for all <span class="math">\(n\)</span>. This spacing is often denoted by <span class="math">\(\Delta t\)</span>,
in this case <span class="math">\(t_n=n\Delta t\)</span>.</p>
<p id="index-4">We seek the solution <span class="math">\(u\)</span> at the mesh points:
<span class="math">\(u(t_n)\)</span>, <span class="math">\(n=1,2,\ldots,N_t\)</span>. Note that <span class="math">\(u^0\)</span> is already known as <span class="math">\(I\)</span>.
A notational short-form for <span class="math">\(u(t_n)\)</span>,
which will be used extensively, is <span class="math">\(u^{n}\)</span>. More precisely, we let
<span class="math">\(u^n\)</span> be the <em>numerical approximation</em> to the exact solution <span class="math">\(u(t_n)\)</span>
at <span class="math">\(t=t_n\)</span>. The numerical approximation is a <em>mesh function</em>,
here defined only at the mesh points.
When we need to clearly distinguish between the numerical
and the exact solution, we often place a subscript e on the exact
solution, as in <span class="math">\(u_{\small\mbox{e}}(t_n)\)</span>. Figure <a class="reference internal" href="main_decay.html#decay-fdu-e"><em>Time mesh with discrete solution values</em></a> shows the
<span class="math">\(t_n\)</span> and <span class="math">\(u_n\)</span> points for <span class="math">\(n=0,1,\ldots,N_t=7\)</span> as well as <span class="math">\(u_{\small\mbox{e}}(t)\)</span>
as the dashed line. The goal of a numerical method for ODEs is
to compute the mesh function by solving a finite set of
<em>algebraic equations</em> derived from the original ODE problem.</p>
<div class="figure" id="decay-fdu-e">
<img alt="_images/fdm_u_ue.png" src="_images/fdm_u_ue.png" style="width: 600px;" />
<p class="caption"><em>Time mesh with discrete solution values</em></p>
</div>
<p>Since finite difference methods produce solutions at the mesh
points only, it is an open question what the solution is between
the mesh points. One can use methods for interpolation to
compute the value of <span class="math">\(u\)</span> between mesh points. The simplest
(and most widely used) interpolation method is to assume that
<span class="math">\(u\)</span> varies linearly between the mesh points, see
Figure <a class="reference internal" href="main_decay.html#decay-fdu-ei"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></a>. Given <span class="math">\(u^{n}\)</span>
and <span class="math">\(u^{n+1}\)</span>, the value of <span class="math">\(u\)</span> at some <span class="math">\(t\in [t_{n}, t_{n+1}]\)</span>
is by linear interpolation</p>
<div class="math">
\[u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n)\thinspace .\]</div>
<div class="figure" id="decay-fdu-ei">
<img alt="_images/fdm_u_uei.png" src="_images/fdm_u_uei.png" style="width: 600px;" />
<p class="caption"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></p>
</div>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h3>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h3>
<p>The ODE is supposed to hold for all <span class="math">\(t\in (0,T]\)</span>, i.e., at an infinite
number of points. Now we relax that requirement and require that
the ODE is fulfilled at a finite set of discrete points in time.
The mesh points <span class="math">\(t_1,t_2,\ldots,t_{N_t}\)</span> are a natural choice of points.
The original ODE is then reduced to  the following <span class="math">\(N_t\)</span> equations:</p>
<div class="math" id="equation-decay:step2">
<span class="eqno">(2)</span>\[     u'(t_n) = -au(t_n),\quad n=1,\ldots,N_t\thinspace .\]</div>
</div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<span id="index-5"></span><h3>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The next and most essential step of the method is to replace the
derivative <span class="math">\(u'\)</span> by a finite difference approximation. Let us first
try a one-sided difference approximation (see Figure <a class="reference internal" href="main_decay.html#decay-sketch-fe"><em>Illustration of a forward difference</em></a>),</p>
<div class="math" id="equation-decay:FEdiff">
<span class="eqno">(3)</span>\[     u'(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}\thinspace .\]</div>
<p>Inserting this approximation in <a href="#equation-decay:step2">(2)</a> results in</p>
<div class="math" id="equation-decay:step3">
<span class="eqno">(4)</span>\[     \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N_t-1\thinspace .\]</div>
<p>This equation is the discrete counterpart to the original ODE problem
<a href="#equation-decay:problem">(1)</a>, and often referred to as <em>finite difference scheme</em>
or more generally as the <em>discrete equations</em> of the problem.
The fundamental feature of these equations is that they are <em>algebraic</em>
and can hence be straightforwardly solved to produce the mesh function, i.e.,
the values of <span class="math">\(u\)</span> at
the mesh points (<span class="math">\(u^n\)</span>, <span class="math">\(n=1,2,\ldots,N_t\)</span>).</p>
<div class="figure" id="decay-sketch-fe">
<img alt="_images/fd_forward.png" src="_images/fd_forward.png" style="width: 400px;" />
<p class="caption"><em>Illustration of a forward difference</em></p>
</div>
<span class="target" id="index-6"></span><span class="target" id="index-7"></span><span class="target" id="index-8"></span><span class="target" id="index-9"></span></div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<span id="index-10"></span><h3>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The final step is to identify the computational algorithm to be implemented
in a program. The key observation here is to realize that
<a href="#equation-decay:step3">(4)</a> can be used to compute <span class="math">\(u^{n+1}\)</span> if <span class="math">\(u^n\)</span> is known.
Starting with <span class="math">\(n=0\)</span>, <span class="math">\(u^0\)</span> is known since <span class="math">\(u^0=u(0)=I\)</span>, and
<a href="#equation-decay:step3">(4)</a> gives an equation for <span class="math">\(u^1\)</span>. Knowing <span class="math">\(u^1\)</span>,
<span class="math">\(u^2\)</span> can be found from <a href="#equation-decay:step3">(4)</a>. In general, <span class="math">\(u^n\)</span>
in <a href="#equation-decay:step3">(4)</a> can be assumed known, and then we can easily solve for
the unknown <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:FE">
<span class="eqno">(5)</span>\[     u^{n+1} = u^n - a(t_{n+1} -t_n)u^n\thinspace .\]</div>
<p>We shall refer to <a href="#equation-decay:FE">(5)</a> as the Forward Euler (FE) scheme
for our model problem. From a mathematical point of view,
equations of the form <a href="#equation-decay:FE">(5)</a> are known as
<em>difference equations</em> since they express how differences in
<span class="math">\(u\)</span>, like <span class="math">\(u^{n+1}-u^n\)</span>, evolve with <span class="math">\(n\)</span>.
The finite difference method can be viewed as a method for turning
a differential equation into a difference equation.</p>
<p>Computation with <a href="#equation-decay:FE">(5)</a> is straightforward:</p>
<div class="math">
\[\begin{split}u_0 &amp;= I,\\
u_1 &amp; = u^0 - a(t_{1} -t_0)u^0 = I(1-a(t_1-t_0)),\\
u_2 &amp; = u^1 - a(t_{2} -t_1)u^1 = I(1-a(t_1-t_0))(1 - a(t_2-t_1)),\\
u^3 &amp;= u^2 - a(t_{3} -t_2)u^2 = I(1-a(t_1-t_0))(1 - a(t_2-t_1))(1 - a(t_3-t_2)),\end{split}\]</div>
<p>and so on until we reach <span class="math">\(u^{N_t}\)</span>.
Very often, <span class="math">\(t_{n+1}-t_n\)</span> is constant for all <span class="math">\(n\)</span>, so we can introduce
the common symbol <span class="math">\(\Delta t\)</span> for the time step:
<span class="math">\(\Delta t = t_{n+1}-t_n\)</span>, <span class="math">\(n=0,1,\ldots,N_t-1\)</span>.
Using a constant time step <span class="math">\(\Delta t\)</span> in the above calculations gives</p>
<div class="math">
\[\begin{split}u_0 &amp;= I,\\
u_1 &amp; = I(1-a\Delta t),\\
u_2 &amp; = I(1-a\Delta t)^2,\\
u^3 &amp;= I(1-a\Delta t)^3,\\
&amp;\vdots\\
u^{N_t} &amp;= I(1-a\Delta t)^{N_t}\thinspace .\end{split}\]</div>
<p>This means that we have found a closed formula for <span class="math">\(u^n\)</span>, and there is
no need to let a computer generate the sequence <span class="math">\(u^1, u^2, u^3, \ldots\)</span>.
However, finding such a formula for <span class="math">\(u^n\)</span> is possible only for a few very
simple problems, so in general finite difference equations must be
solved on a computer.</p>
<p>As the next sections will show, the scheme <a href="#equation-decay:FE">(5)</a> is just one
out of many alternative finite difference (and other) methods for
the model problem <a href="#equation-decay:problem">(1)</a>.</p>
</div>
</div>
<div class="section" id="the-backward-euler-scheme">
<span id="decay-schemes-be"></span><h2>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>There are several choices of difference approximations in step 3 of
the finite difference method as presented in the previous section.
Another alternative is</p>
<div class="math" id="equation-decay:BEdiff">
<span class="eqno">(6)</span>\[     u'(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}\thinspace .\]</div>
<p>Since this difference is based on going backward in time (<span class="math">\(t_{n-1}\)</span>)
for information, it is known as the Backward Euler difference.
Figure <em class="xref std std-ref">decay:sketch:BE</em> explains the idea.</p>
<div class="figure" id="decay-sketch-be">
<img alt="_images/fd_backward.png" src="_images/fd_backward.png" style="width: 400px;" />
<p class="caption"><em>Illustration of a backward difference</em></p>
</div>
<span class="target" id="index-11"></span><p id="index-12">Inserting <a href="#equation-decay:BEdiff">(6)</a> in <a href="#equation-decay:step2">(2)</a> yields
the Backward Euler (BE) scheme:</p>
<div class="math" id="equation-decay:BE0">
<span class="eqno">(7)</span>\[     \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n\thinspace .\]</div>
<p>We assume, as explained under step 4 in the section <a class="reference internal" href="main_decay.html#decay-schemes-fe"><em>The Forward Euler scheme</em></a>,
that we have computed <span class="math">\(u^0, u^1, \ldots, u^{n-1}\)</span> such that
<a href="#equation-decay:BE0">(7)</a> can be used to compute <span class="math">\(u^n\)</span>.
For direct similarity with the Forward Euler scheme <a href="#equation-decay:FE">(5)</a>
we replace <span class="math">\(n\)</span> by <span class="math">\(n+1\)</span> in <a href="#equation-decay:BE0">(7)</a> and solve for the
unknown value <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:BE">
<span class="eqno">(8)</span>\[     u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n\thinspace .\]</div>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<span id="decay-schemes-cn"></span><h2>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p id="index-13">The finite difference approximations used to derive the schemes
<a href="#equation-decay:FE">(5)</a> and <a href="#equation-decay:BE">(8)</a> are both one-sided differences,
known to be less accurate than central (or midpoint)
differences. We shall now construct
a central difference at <span class="math">\(t_{n+1/2}=\frac{1}{2} (t_n + t_{n+1})\)</span>, or
<span class="math">\(t_{n+1/2}=(n+\frac{1}{2})\Delta t\)</span> if the mesh spacing is uniform in time.
The approximation reads</p>
<div class="math" id="equation-decay:CNdiff">
<span class="eqno">(9)</span>\[     u'(t_{n+\frac{1}{2}}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}\thinspace .\]</div>
<p>Note that the fraction on the right-hand side is the same as for the
Forward Euler approximation <a href="#equation-decay:FEdiff">(3)</a> and
the Backward Euler approximation <a href="#equation-decay:BEdiff">(6)</a> (with
<span class="math">\(n\)</span> replaced by <span class="math">\(n+1\)</span>). The accuracy of this fraction as an approximation
to the derivative of <span class="math">\(u\)</span> depends on <em>where</em> we seek the derivative:
in the center of the interval <span class="math">\([t_{n},t_{n+1}]\)</span> or at the end points.</p>
<p>With the formula <a href="#equation-decay:CNdiff">(9)</a>, where <span class="math">\(u'\)</span> is evaluated at
<span class="math">\(t_{n+1/2}\)</span>, it is natural to demand the
ODE to be fulfilled at the time points between the mesh points:</p>
<div class="math" id="equation-decay:step2m">
<span class="eqno">(10)</span>\[     u'(t_{n+\frac{1}{2}}) = -au(t_{n+\frac{1}{2}}),\quad n=0,
     \ldots,N_t-1\thinspace .\]</div>
<p>Using <a href="#equation-decay:CNdiff">(9)</a> in <a href="#equation-decay:step2m">(10)</a> results in</p>
<div class="math" id="equation-decay:CN0">
<span class="eqno">(11)</span>\[     \frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -au^{n+\frac{1}{2}},\]</div>
<p>where <span class="math">\(u^{n+\frac{1}{2}}\)</span> is a short form for <span class="math">\(u(t_{n+\frac{1}{2}})\)</span>.
The problem is that we aim to compute <span class="math">\(u^n\)</span> for integer <span class="math">\(n\)</span>, implying that
<span class="math">\(u^{n+\frac{1}{2}}\)</span> is not a quantity computed by our method. It must
therefore be
expressed by the quantities that we actually produce, i.e.,
the numerical solution at the
mesh points. One possibility is to approximate <span class="math">\(u^{n+\frac{1}{2}}\)</span>
as an arithmetic average of the <span class="math">\(u\)</span> values at the neighboring mesh points:</p>
<div class="math" id="equation-decay:uhalfavg">
<span id="index-14"></span><span class="eqno">(12)</span>\[     u^{n+\frac{1}{2}} \approx \frac{1}{2} (u^n + u^{n+1})\thinspace .\]</div>
<p>Using <a href="#equation-decay:uhalfavg">(12)</a> in <a href="#equation-decay:CN0">(11)</a> results in</p>
<div class="math" id="equation-decay:CN1">
<span class="eqno">(13)</span>\[     \frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\frac{1}{2} (u^n + u^{n+1})\thinspace .\]</div>
<p>Figure <em class="xref std std-ref">decay:sketch:BE</em> sketches the geometric interpretation of
such a centered difference.</p>
<div class="figure" id="id1">
<img alt="_images/fd_centered.png" src="_images/fd_centered.png" style="width: 400px;" />
<p class="caption"><em>Illustration of a centered difference</em></p>
</div>
<p>We assume that <span class="math">\(u^n\)</span> is already computed so that <span class="math">\(u^{n+1}\)</span> is the
unknown, which we can solve for:</p>
<div class="math" id="equation-decay:CN">
<span class="eqno">(14)</span>\[     u^{n+1} = \frac{1-\frac{1}{2} a(t_{n+1}-t_n)}{1 + \frac{1}{2} a(t_{n+1}-t_n)}u^n\thinspace .\]</div>
<p>The finite difference scheme <a href="#equation-decay:CN">(14)</a> is often called
the Crank-Nicolson (CN) scheme or a midpoint or centered scheme.</p>
</div>
<div class="section" id="the-unifying-rule">
<span id="decay-schemes-theta"></span><h2>The unifying <span class="math">\(\theta\)</span>-rule<a class="headerlink" href="#the-unifying-rule" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-15"></span><span class="target" id="index-16"></span><p id="index-17">The Forward Euler, Backward Euler, and Crank-Nicolson schemes can be
formulated as one scheme with a varying parameter <span class="math">\(\theta\)</span>:</p>
<div class="math">
\[:label: decay:th0\]\[       \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})\]\[       \thinspace .\]\[* :math:`\theta =0` gives the Forward Euler scheme\]\[* :math:`\theta =1` gives the Backward Euler scheme, and\]\[* :math:`\theta =1/2` gives the Crank-Nicolson scheme.\]\[* We may alternatively choose any other value of :math:`\theta` in :math:`[0,1]`.\]</div>
<p>As before, <span class="math">\(u^n\)</span> is considered known and <span class="math">\(u^{n+1}\)</span> unknown, so
we solve for the latter:</p>
<div class="math" id="equation-decay:th">
<span class="eqno">(15)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}\thinspace .\]</div>
<p>This scheme is known as the <span class="math">\(\theta\)</span>-rule, or alternatively written as
the &#8220;theta-rule&#8221;.</p>
<div class="admonition-derivation admonition">
<p class="first admonition-title">Derivation</p>
<p>We start with replacing <span class="math">\(u'\)</span> by the fraction</p>
<div class="math">
\[\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n},\]</div>
<p>in the Forward Euler, Backward Euler,
and Crank-Nicolson schemes. Then we observe that
the difference between the methods concerns which point this
fraction approximates the derivative. Or in other words, at which point we
sample the ODE. So far this has been the
end points or the midpoint of <span class="math">\([t_n,t_{n+1}]\)</span>. However, we may choose any point
<span class="math">\(\tilde t \in [t_n,t_{n+1}]\)</span>.
The difficulty
is that evaluating the right-hand side <span class="math">\(-au\)</span> at an arbitrary point
faces the same problem as in
the section <a class="reference internal" href="main_decay.html#decay-schemes-cn"><em>The Crank-Nicolson scheme</em></a>: the point value must be expressed
by the discrete <span class="math">\(u\)</span> quantities that we compute by the scheme, i.e.,
<span class="math">\(u^n\)</span> and <span class="math">\(u^{n+1}\)</span>. Following the averaging idea from
the section <a class="reference internal" href="main_decay.html#decay-schemes-cn"><em>The Crank-Nicolson scheme</em></a>,
the value of <span class="math">\(u\)</span> at an arbitrary point <span class="math">\(\tilde t\)</span> can be
calculated as a <em>weighted average</em>, which generalizes the arithmetic average
<span class="math">\(\frac{1}{2}u^n + \frac{1}{2}u^{n+1}\)</span>.
If we express <span class="math">\(\tilde t\)</span> as a weighted average</p>
<div class="math">
\[t_{n+\theta} = \theta t_{n+1} + (1-\theta) t_{n},\]</div>
<p>where <span class="math">\(\theta\in [0,1]\)</span> is the weighting factor, we can write</p>
<div class="math" id="equation-decay:thetaavg">
<span class="eqno">(16)</span>\[     u(\tilde t) = u(\theta t_{n+1} + (1-\theta) t_{n}) \approx
     \theta u^{n+1} + (1-\theta) u^{n}\thinspace .\]</div>
<p class="last" id="index-18">We can now let the ODE hold at the point
<span class="math">\(\tilde t\in [t_n,t_{n+1}]\)</span>, approximate <span class="math">\(u'\)</span> by the fraction
<span class="math">\((u^{n+1}-u^{n})/(t_{n+1}-t_n)\)</span>, and approximate the right-hand
side <span class="math">\(-au\)</span> by the weighted average <a href="#equation-decay:thetaavg">(16)</a>.
The result is <a href="#equation-decay:th0">(?)</a>.</p>
</div>
</div>
<div class="section" id="constant-time-step">
<h2>Constant time step<a class="headerlink" href="#constant-time-step" title="Permalink to this headline">¶</a></h2>
<p>All schemes up to now have been formulated for a general non-uniform
mesh in time: <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>. Non-uniform meshes are highly relevant
since one can use many points in regions where <span class="math">\(u\)</span> varies rapidly, and
save points in regions where <span class="math">\(u\)</span> is slowly varying. This is the key idea
of <em>adaptive</em> methods where the spacing of the mesh points
are determined as the computations proceed.</p>
<p>However, a uniformly distributed set of mesh points is very common and
sufficient for many applications. It therefore makes sense to
present the finite difference schemes for a uniform point distribution
<span class="math">\(t_n=n\Delta t\)</span>, where <span class="math">\(\Delta t\)</span> is the constant spacing between
the mesh points, also referred to as the <em>time step</em>.
The resulting formulas look simpler and are perhaps more
well known.</p>
<div class="admonition-summary-of-schemes-for-constant-time-step admonition">
<p class="first admonition-title">Summary of schemes for constant time step</p>
<div class="math" id="equation-decay:FE:u">
<span class="eqno">(17)</span>\[     u^{n+1} = (1 - a\Delta t )u^n  \quad (\hbox{FE})\]</div>
<div class="math" id="equation-decay:BE:u">
<span class="eqno">(18)</span>\[     u^{n+1} = \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})\]</div>
<div class="math" id="equation-decay:CN:u">
<span class="eqno">(19)</span>\[     u^{n+1} = \frac{1-\frac{1}{2} a\Delta t}{1 + \frac{1}{2} a\Delta t} u^n \quad (\hbox{CN})\]</div>
<div class="last math" id="equation-decay:th:u">
<span class="eqno">(20)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})\]</div>
</div>
<p>Not surprisingly, we present these three alternative schemes
because they have different pros and cons, both for the simple ODE
in question (which can easily be solved as accurately as desired), and for
more advanced differential equation problems.</p>
<div class="admonition-test-the-understanding admonition">
<p class="first admonition-title">Test the understanding</p>
<p class="last">At this point it can be good training to apply the explained
finite difference discretization techniques to a slightly
different equation. <a class="reference internal" href="main_decay.html#decay-app-exer-cooling-schemes"><em>Exercise 1: Derive schemes for Newton&#8217;s law of cooling</em></a>
is therefore highly recommended to check that the key concepts
are understood.</p>
</div>
</div>
<div class="section" id="compact-operator-notation-for-finite-differences">
<span id="decay-fd-op"></span><h2>Compact operator notation for finite differences<a class="headerlink" href="#compact-operator-notation-for-finite-differences" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-19"></span><p id="index-20">Finite difference formulas can be tedious to write and read,
especially for differential equations with many terms and many
derivatives. To save space and help the reader of the scheme to quickly
see the nature of the difference approximations, we introduce a
compact notation. A forward difference approximation is denoted
by the <span class="math">\(D_t^+\)</span> operator:</p>
<div class="math" id="equation-fd:D:f">
<span class="eqno">(21)</span>\[     [D_t^+u]^n = \frac{u^{n+1} - u^{n}}{\Delta t}
     \approx \frac{d}{dt} u(t_n)
     \thinspace .\]</div>
<p>The notation consists of an operator that approximates
differentiation with respect to an independent variable, here <span class="math">\(t\)</span>.
The operator is built of the symbol <span class="math">\(D\)</span>, with the variable as subscript
and a superscript denoting the type of difference. The superscript <span class="math">\(\,{}^+\)</span>
indicates a forward difference.
We place square brackets around the operator and the function it operates
on and specify the mesh point, where the operator is acting, by
a superscript.</p>
<p>The corresponding operator notation for a centered difference and
a backward difference reads</p>
<div class="math" id="equation-fd:D:c">
<span class="eqno">(22)</span>\[     [D_tu]^n = \frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t}
     \approx \frac{d}{dt} u(t_n),\]</div>
<p>and</p>
<div class="math" id="equation-fd:D:b">
<span class="eqno">(23)</span>\[     [D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}
     \approx \frac{d}{dt} u(t_n)
     \thinspace .\]</div>
<p>Note that the superscript <span class="math">\(\,{}^-\)</span> denotes the backward
difference, while no superscript implies a central difference.</p>
<p>An averaging operator is also convenient to have:</p>
<div class="math" id="equation-fd:mean:a">
<span class="eqno">(24)</span>\[     [\overline{u}^{t}]^n = \frac{1}{2} (u^{n-\frac{1}{2}} + u^{n+\frac{1}{2}} )
     \approx u(t_n)\]</div>
<p>The superscript <span class="math">\(t\)</span> indicates that the average is taken along the time
coordinate. The common average <span class="math">\((u^n + u^{n+1})/2\)</span> can now be
expressed as <span class="math">\([\overline{u}^{t}]^{n+1/2}\)</span>. (When also spatial coordinates
enter the problem, we need the explicit specification of the coordinate
after the bar.)</p>
<p>The Backward Euler finite difference approximation to <span class="math">\(u'=-au\)</span> can be written
as follows utilizing the compact notation:</p>
<div class="math">
\[[D_t^-u]^n = -au^n \thinspace .\]</div>
<p>In difference equations we often place the square brackets around
the whole equation, to indicate at which mesh point the equation applies,
since each term is supposed to be approximated at the same point:</p>
<div class="math">
\[[D_t^- u  = -au]^n \thinspace .\]</div>
<p>The Forward Euler scheme takes the form</p>
<div class="math">
\[[D_t^+ u  = -au]^n,\]</div>
<p>while the Crank-Nicolson scheme is written as</p>
<div class="math" id="equation-fd:compact:ex:CN">
<span class="eqno">(25)</span>\[     [D_t u = -a\overline{u}^t]^{n+\frac{1}{2}}\thinspace .\]</div>
<div class="admonition-question admonition">
<p class="first admonition-title">Question</p>
<p class="last">Apply <a href="#equation-fd:D:c">(22)</a> and <a href="#equation-fd:mean:a">(24)</a> and write out the
expressions to see that <a href="#equation-fd:compact:ex:CN">(25)</a> is indeed the
Crank-Nicolson scheme.</p>
</div>
<p>The <span class="math">\(\theta\)</span>-rule can be specified by</p>
<div class="math" id="equation-decay:fd1:op:theta">
<span class="eqno">(26)</span>\[     [\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta},\]</div>
<p>if we define a new time difference and a <em>weighted averaging operator</em>:</p>
<div class="math">
\[\lbrack\bar D_t u\rbrack^{n+\theta} = \frac{u^{n+1}-u^n}{t^{n+1}-t^n},\]\[\lbrack\overline{u}^{t,\theta}\rbrack^{n+\theta} = (1-\theta)u^{n} + \theta u^{n+1}
\approx u(t_{n+\theta}),\]</div>
<p>where <span class="math">\(\theta\in [0,1]\)</span>. Note that for <span class="math">\(\theta =1/2\)</span> we recover
the standard centered difference and the standard arithmetic average.
The idea in <a href="#equation-decay:fd1:op:theta">(26)</a> is to sample the equation at
<span class="math">\(t_{n+\theta}\)</span>, use a skew difference at that
point <span class="math">\([\bar D_t u]^{n+\theta}\)</span>, and a skew mean value.
An alternative notation is</p>
<div class="math">
\[[D_t u]^{n+1/2} = \theta [-au]^{n+1} + (1-\theta)[-au]^{n}\thinspace .\]</div>
<p>Looking at the various examples above and comparing them with the
underlying differential equations, we see immediately which difference
approximations that have been used and at which point they
apply. Therefore, the compact notation effectively communicates the
reasoning behind turning a differential equation into a difference
equation.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite difference methods</a><ul>
<li><a class="reference internal" href="#a-basic-model-for-exponential-decay">A basic model for exponential decay</a></li>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#the-unifying-rule">The unifying <span class="math">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#constant-time-step">Constant time step</a></li>
<li><a class="reference internal" href="#compact-operator-notation-for-finite-differences">Compact operator notation for finite differences</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._part0000_main_decay.html"
                        title="previous chapter">Introduction to computing with finite difference methods</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._part0002_main_decay.html"
                        title="next chapter">Implementation  (1)</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._part0001_main_decay.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._part0002_main_decay.html" title="Implementation (1)"
             >next</a> |</li>
        <li class="right" >
          <a href="._part0000_main_decay.html" title="Introduction to computing with finite difference methods"
             >previous</a> |</li>
        <li><a href="index.html">Introduction to computing with finite difference methods</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>