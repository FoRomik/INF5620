<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(http://code.google.com/p/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: http://code.google.com/p/doconce/" />
<meta name="description" content="Introduction to computing with finite difference methods">
<meta name="keywords" content="decay (problem),exponential decay,mesh finite differences,grid finite differences,mesh function,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,weighted average,theta-rule,$\theta$-rule,finite difference operator notation,operator notation, finite differences,doc strings,printf format (Python),format string syntax (Python),PNG plot,PDF plot,EPS plot,view PNG plot,view PDF plot,view EPS plot,user interfaces to programs,command-line interfaces,reading the command line,list comprehension,option-value pairs (command line),command-line options and values,reading the command line,convergence rate,dictionary,verification,modules (Python),test block (Python modules),module import,doctests,software testing doctests,unit testing,software testing nose,software testing nose w/doctests,unit testing,problem class,solver class,visualizer class,problem class,solver class,visualizer class,numerical experiments,scientific experiments,script,Unix wildcard notation,stability criterion,amplification factor,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order scheme,Taylor-series methods (for ODEs),Adams-Bashforth scheme, 2nd order,Adams-Bashforth scheme, 3rd order,Runge-Kutta, 4th-order scheme,RK4,population dynamics,logistic model,radioactive decay,terminal velocity,geometric average,averaging geometric">



<style type="text/css">
    body {
      margin:5;
      padding:0;
      border:0;	/* Remove the border around the viewport in old versions of IE */
      width:100%;
      background: #fdf6e3;
      min-width:600px;	/* Minimum width of layout - remove if not required */
      font-family: Verdana, Helvetica, Arial, sans-serif;
      font-size: 1.0em;
      line-height: 1.3em;
      color: #657b83;
    }
    a { color: #657b83; text-decoration:none; }
    a:hover { color: #b58900; background: #eee8d5; text-decoration:none; }
    h1, h2, h3 { margin:.8em 0 .2em 0; padding:0; line-height: 125%; }
    h2 { font-variant: small-caps; }
    pre {
      background: #fdf6e3;
      -webkit-box-shadow: inset 0 0 2px #000000;
      -moz-box-shadow: inset 0 0 2px #000000;
      box-shadow: inset 0 0 2px #000000;
      color: #586e75;
      margin-left: 0px;
      font-family: 'Droid Sans Mono', monospace;
      padding: 2px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      -moz-background-clip: padding;
      -webkit-background-clip: padding-box;
      background-clip: padding-box;
    }
    tt { font-family: "Courier New", Courier; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p { text-indent: 0px; }
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #bababa;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: whiteSmoke;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:0}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods  ',
               1,
               'decay:basics',
               'decay:basics'),
              (' A basic model for exponential decay ',
               2,
               'decay:model',
               'decay:model'),
              (' The Forward Euler scheme ',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              (' Step 1: Discretizing the domain ', 3, None, '___sec3'),
              (' Step 2: Fulfilling the equation at discrete time points ',
               3,
               None,
               '___sec4'),
              (' Step 3: Replacing derivatives by finite differences ',
               3,
               None,
               '___sec5'),
              (' Step 4: Formulating a recursive algorithm ',
               3,
               None,
               '___sec6'),
              (' The Backward Euler scheme ',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              (' The Crank-Nicolson scheme ',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              (' The unifying $\\theta$-rule ',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              (' Constant time step ', 2, None, '___sec10'),
              (' Compact operator notation for finite differences ',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              (' Implementation ', 1, 'decay:impl1', 'decay:impl1'),
              (' Making a solver function ', 2, 'decay:py1', 'decay:py1'),
              (' Function for computing the numerical solution ',
               3,
               None,
               '___sec14'),
              (' Integer division ', 3, None, '___sec15'),
              (' Doc strings ', 3, None, '___sec16'),
              (' Formatting of numbers ', 3, None, '___sec17'),
              (' Running the program ', 3, None, '___sec18'),
              (' Verifying the implementation ', 2, None, '___sec19'),
              (' Running a few algorithmic steps by hand ',
               3,
               None,
               '___sec20'),
              (' Comparison with an exact discrete solution ',
               3,
               None,
               '___sec21'),
              (' Computing the numerical error ',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              (' Plotting solutions ', 2, None, '___sec23'),
              (' Plotting with SciTools ', 2, None, '___sec24'),
              (' Creating user interfaces ', 2, None, '___sec25'),
              (' Reading a sequence of command-line arguments ',
               3,
               None,
               '___sec26'),
              (' Working with an argument parser ', 3, None, '___sec27'),
              (' Computing convergence rates ',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              (' Estimating $r$ ', 3, None, '___sec29'),
              (' Implementation ', 3, None, '___sec30'),
              (' Debugging via convergence rates ', 3, None, '___sec31'),
              (' Memory-saving implementation ', 2, None, '___sec32'),
              (' Software engineering ', 1, None, '___sec33'),
              (' Making a module ',
               2,
               'decay:prog:se:module',
               'decay:prog:se:module'),
              (' Prefixing imported functions by the module name ',
               2,
               'decay:prog:se:import',
               'decay:prog:se:import'),
              (' Doctests ',
               2,
               'decay:prog:se:doctest',
               'decay:prog:se:doctest'),
              (' Unit testing with nose ',
               2,
               'decay:prog:se:nose',
               'decay:prog:se:nose'),
              (' Basic use of nose ', 3, None, '___sec38'),
              (' Demonstrating nose ', 3, None, '___sec39'),
              (' Installation of nose ', 3, None, '___sec40'),
              (' Using nose to test modules with doctests ',
               3,
               None,
               '___sec41'),
              (' Classical unit testing with unittest ',
               2,
               'decay:prog:se:unittest',
               'decay:prog:se:unittest'),
              (' Basic use of unittest ', 3, None, '___sec43'),
              (' Demonstration of unittest ', 3, None, '___sec44'),
              (' Implementing simple problem and solver classes ',
               2,
               'decay:prog:se:class',
               'decay:prog:se:class'),
              (' The problem class ', 3, None, '___sec46'),
              (' The solver class ', 3, None, '___sec47'),
              (' The visualizer class ', 3, None, '___sec48'),
              (' Combing the objects ', 3, None, '___sec49'),
              (' Improving the problem and solver classes ',
               2,
               'decay:prog:se:class2',
               'decay:prog:se:class2'),
              (' A generic class for parameters ', 3, None, '___sec51'),
              (' The problem class ', 3, None, '___sec52'),
              (' The solver class ', 3, None, '___sec53'),
              (' The visualizer class ', 3, None, '___sec54'),
              (' Performing scientific experiments ',
               1,
               'decay:experiments',
               'decay:experiments'),
              (' Interpreting output from other programs ',
               2,
               None,
               '___sec56'),
              (' Making a report ',
               2,
               'decay:exper:report',
               'decay:exper:report'),
              (' Plain HTML ', 3, None, '___sec58'),
              (' HTML with MathJax ', 3, None, '___sec59'),
              (' LaTeX ', 3, None, '___sec60'),
              (' Sphinx ', 3, None, '___sec61'),
              (' Markdown ', 3, None, '___sec62'),
              (' Wiki formats ', 3, None, '___sec63'),
              (' Doconce ', 3, None, '___sec64'),
              (' Worked example ', 3, None, '___sec65'),
              (' Publishing a complete project ',
               2,
               'decay:exper:github',
               'decay:exper:github'),
              (' Exercises ', 1, None, '___sec67'),
              (' Exercise 1: Experiment with integer division ',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              (' Exercise 2: Experiment with wrong computations ',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              (' Exercise 3: Implement specialized functions ',
               2,
               'decay:exer:FEBECN',
               'decay:exer:FEBECN'),
              (' Exercise 4: Plot the error function ',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              (' Exercise 5: Compare methods for a give time mesh ',
               2,
               'decay:exer:plot:dtconst',
               'decay:exer:plot:dtconst'),
              (' Exercise 6: Change formatting of numbers and debug ',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              (' Exercise 7: Write a doctest ',
               2,
               'decay:exer:doctest1',
               'decay:exer:doctest1'),
              (' Exercise 8: Write a nose test ',
               2,
               'decay:exer:nosetest1',
               'decay:exer:nosetest1'),
              (' Exercise 9: Make a module ',
               2,
               'decay:exer:module1',
               'decay:exer:module1'),
              (' Exercise 10: Make use of a class implementation ',
               2,
               'decay:exer:decay_class:exper',
               'decay:exer:decay_class:exper'),
              (' Analysis of finite difference equations ',
               1,
               'decay:analysis',
               'decay:analysis'),
              (' Discouraging numerical solutions ', 2, None, '___sec79'),
              (' Experimental investigation of oscillatory solutions ',
               2,
               None,
               '___sec80'),
              (' Exact numerical solution ', 2, None, '___sec81'),
              (' Stability ', 2, None, '___sec82'),
              (' Comparing amplification factors ', 2, None, '___sec83'),
              (' Series expansion of amplification factors ',
               2,
               None,
               '___sec84'),
              (' Local error ', 2, None, '___sec85'),
              (' Analytical comparison of schemes ', 2, None, '___sec86'),
              (' The real (global) error at a point ', 2, None, '___sec87'),
              (' Integrated errors ', 2, None, '___sec88'),
              (' Exercises ', 1, None, '___sec89'),
              (' Exercise 11: Explore the $\\theta$-rule for exponential growth ',
               2,
               'decay:analysis:exer:growth',
               'decay:analysis:exer:growth'),
              (' Exercise 12: Summarize investigations in a report ',
               2,
               'decay:analysis:exer:growth:report',
               'decay:analysis:exer:growth:report'),
              (' Exercise 13: Plot amplification factors for exponential growth ',
               2,
               'decay:analysis:exer:growth:A',
               'decay:analysis:exer:growth:A'),
              (' Model extensions ', 1, None, '___sec93'),
              (' Generalization: including a variable coefficient ',
               2,
               None,
               '___sec94'),
              (' Generalization: including a source term ',
               2,
               'decay:source',
               'decay:source'),
              (' Schemes ', 3, None, '___sec96'),
              (' Implementation of the generalized model problem ',
               2,
               'decay:general',
               'decay:general'),
              (' Deriving the $\\theta$-rule formula ', 3, None, '___sec98'),
              (' The Python code ', 3, None, '___sec99'),
              (' Coding of variable coefficients ', 3, None, '___sec100'),
              (' Verification via trivial solutions ',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              (' Verification via manufactured solutions ',
               2,
               'decay:MMS',
               'decay:MMS'),
              (' Extension to systems of ODEs ', 2, None, '___sec103'),
              (' General first-order ODEs ', 1, None, '___sec104'),
              (' Generic form ', 2, None, '___sec105'),
              (' Some popular schemes for ODEs ', 2, None, '___sec106'),
              (' Implicit 2-step backward scheme ', 3, None, '___sec107'),
              (' The Leapfrog scheme ', 3, None, '___sec108'),
              (' The filtered Leapfrog scheme ', 3, None, '___sec109'),
              (' 2nd-order Runge-Kutta scheme ', 3, None, '___sec110'),
              (' A 2nd-order Taylor-series method ', 3, None, '___sec111'),
              (' 2nd-order Adams-Bashforth scheme ', 3, None, '___sec112'),
              (' 3rd-order Adams-Bashforth scheme ', 3, None, '___sec113'),
              (' 4th-order Runge-Kutta scheme ', 3, None, '___sec114'),
              (' The Odespy software ', 2, None, '___sec115'),
              (' Example: Runge-Kutta methods  ', 2, None, '___sec116'),
              (' Remark about using the $\\theta$-rule in Odespy ',
               3,
               None,
               '___sec117'),
              (' Example: Adaptive Runge-Kutta methods  ',
               2,
               None,
               '___sec118'),
              (' Exercises ', 1, None, '___sec119'),
              (' Exercise 14: Experiment with precision in tests and the size of $u$ ',
               2,
               'decay:fd2:exer:precision',
               'decay:fd2:exer:precision'),
              (' Exercise 15: Implement the 2-step backward scheme ',
               2,
               'decay:fd2:exer:bw2',
               'decay:fd2:exer:bw2'),
              (' Exercise 16: Implement the Leapfrog scheme ',
               2,
               'decay:fd2:exer:leapfrog1',
               'decay:fd2:exer:leapfrog1'),
              (' Exercise 17: Experiment with the Leapfrog scheme ',
               2,
               'decay:fd2:exer:leapfrog2',
               'decay:fd2:exer:leapfrog2'),
              (' Exercise 18: Analyze the Leapfrog scheme ',
               2,
               'decay:fd2:exer:leapfrog3',
               'decay:fd2:exer:leapfrog3'),
              (' Exercise 19: Implement the filtered Leapfrog scheme ',
               2,
               'decay:fd2:exer:leapfrog4',
               'decay:fd2:exer:leapfrog4'),
              (' Exercise 20: Implement the 2nd-order Adams-Bashforth scheme ',
               2,
               'decay:fd2:exer:AB2',
               'decay:fd2:exer:AB2'),
              (' Exercise 21: Implement the 3rd-order Adams-Bashforth scheme ',
               2,
               'decay:fd2:exer:AB3',
               'decay:fd2:exer:AB3'),
              (' Exercise 22: Generalize a class implementation ',
               2,
               'decay:exer:decay_class2',
               'decay:exer:decay_class2'),
              (' Exercise 23: Generalize an advanced class implementation ',
               2,
               'decay:exer:decay_class3',
               'decay:exer:decay_class3'),
              (' Exercise 24: Make a unified implementation of many schemes ',
               2,
               'decay:fd2:exer:uni',
               'decay:fd2:exer:uni'),
              (' Exercise 25: Analyze explicit 2nd-order methods ',
               2,
               'decay:exer:RK2:Taylor:analysis',
               'decay:exer:RK2:Taylor:analysis'),
              (' Applications of exponential decay models ',
               1,
               'decay:app',
               'decay:app'),
              (' Evolution of a population ',
               2,
               'decay:app:pop',
               'decay:app:pop'),
              (' Compound interest and inflation ',
               2,
               'decay:app:interest',
               'decay:app:interest'),
              (' Radioactive Decay ',
               2,
               'decay:app:nuclear',
               'decay:app:nuclear'),
              (' Deterministic model ', 3, None, '___sec136'),
              (' Stochastic model ', 3, None, '___sec137'),
              (' Relation between stochastic and deterministic models ',
               3,
               None,
               '___sec138'),
              (" Newton's law of cooling ", 2, None, '___sec139'),
              (' Decay of atmospheric pressure with altitude ',
               2,
               'decay:app:atm',
               'decay:app:atm'),
              (' Multiple atmospheric layers ', 3, None, '___sec141'),
              (' Simplification: $L=0$ ', 3, None, '___sec142'),
              (' Simplification: one-layer model ', 3, None, '___sec143'),
              (' Compaction of sediments ',
               2,
               'decay:app:sediment',
               'decay:app:sediment'),
              (' Vertical motion of a body in a viscous fluid ',
               2,
               'decay:app:drag',
               'decay:app:drag'),
              (' Overview of forces ', 3, None, '___sec146'),
              (' Equation of motion ', 3, None, '___sec147'),
              (' Terminal velocity ', 3, None, '___sec148'),
              (' A Crank-Nicolson scheme ', 3, None, '___sec149'),
              (' Physical data ', 3, None, '___sec150'),
              (' Verification ', 3, None, '___sec151'),
              (' Decay ODEs from solving a PDE by Fourier expansions ',
               2,
               'decay:app:diffusion:Fourier',
               'decay:app:diffusion:Fourier'),
              (' Exercises ', 1, None, '___sec153'),
              (' Exercise 26: Simulate stochastic radioactive decay ',
               2,
               'decay:app:exer:stoch:nuclear',
               'decay:app:exer:stoch:nuclear'),
              (" Exercise 27: Derive schemes for Newton's law of cooling ",
               2,
               'decay:app:exer:cooling:schemes',
               'decay:app:exer:cooling:schemes'),
              (' Exercise 28: Simulate the pressure drop in the atmosphere ',
               2,
               'decay:app:exer:atm1',
               'decay:app:exer:atm1'),
              (' Exercise 29: Make a program for vertical motion in a fluid ',
               2,
               'decay:app:exer:drag:prog',
               'decay:app:exer:drag:prog'),
              (' Exercise 30: Plot forces acting in vertical motion in a fluid ',
               2,
               'decay:app:exer:drag:prog:viz',
               'decay:app:exer:drag:prog:viz'),
              (' Exercise 31: Simulate a free fall of a parachute jumper ',
               2,
               'decay:app:exer:drag:parachute1',
               'decay:app:exer:drag:parachute1'),
              (' Exercise 32: Simulate a complete parachute jump ',
               2,
               'decay:app:exer:drag:parachute2',
               'decay:app:exer:drag:parachute2'),
              (' Exercise 33: Simulate a rising ball in water ',
               2,
               'decay:app:exer:drag:rising',
               'decay:app:exer:drag:rising'),
              (' Exercise 34: Radioactive decay of Carbon-14 ',
               2,
               'decay:app:exer:radio:C14',
               'decay:app:exer:radio:C14'),
              (' Exercise 35: Radioactive decay of two substances ',
               2,
               'decay:app:exer:radio:twosubst',
               'decay:app:exer:radio:twosubst'),
              (' Exercise 36: Find time of murder from body temperature ',
               2,
               'decay:app:exer:cooling:pizza',
               'decay:app:exer:cooling:pizza'),
              (' Exercise 37: Simulate an oscillating cooling process ',
               2,
               'decay:app:exer:cooling:osc',
               'decay:app:exer:cooling:osc'),
              (' Exercise 38: Compute $y=|x|$ by solving an ODE ',
               2,
               'decay:app:exer:signum',
               'decay:app:exer:signum'),
              (' Exercise 39: Simulate growth of a fortune with random interest rate ',
               2,
               'decay:app:exer:interest',
               'decay:app:exer:interest'),
              (' Exercise 40: Simulate sudden environmental changes for a population ',
               2,
               'decay:app:exer:pop:at',
               'decay:app:exer:pop:at'),
              (' Exercise 41: Simulate oscillating environment for a population ',
               2,
               'decay:app:exer:pop:osc',
               'decay:app:exer:pop:osc'),
              (' Exercise 42: Simulate logistic growth ',
               2,
               'decay:app:exer:pop:logistic1',
               'decay:app:exer:pop:logistic1'),
              (' Exercise 43: Rederive the equation for continuous compound interest ',
               2,
               'decay:app:exer:interest:derive',
               'decay:app:exer:interest:derive')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{u_{\small\mbox{e}}}
\newcommand{\Aex}{A_{\small\mbox{e}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{{\cal O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{{\cal I}_x}
\newcommand{\Iy}{{\cal I}_y}
\newcommand{\Iz}{{\cal I}_z}
\newcommand{\It}{{\cal I}_t}
\newcommand{\setb}[1]{{#1}^0}    % set begin
\newcommand{\sete}[1]{{#1}^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{{#1}^-}
\newcommand{\setr}[1]{{#1}^+}
\newcommand{\seti}[1]{{#1}^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0006"></a>
<!-- begin top navigation -->
<a href="._part0005_main_decay-solarized.html"><img src="https://doconce.googlecode.com/hg/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0007_main_decay-solarized.html"><img src="https://doconce.googlecode.com/hg/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end top navigation -->

<p>
<!-- !split -->
<!-- 2DO -->

<p>
<!-- Explain the concepts of convergence, stability and consistence, -->
<!-- see Doug's article. -->

<h2>Analysis of finite difference equations <a name="decay:analysis"></a></h2>

<p>
We address the ODE for exponential decay,
$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I,
\end{equation}
$$

where \( a \) and \( I \) are given constants. This problem is solved
by the \( \theta \)-rule finite difference scheme, resulting in
the recursive equations
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n
\label{decay:analysis:scheme}
\end{equation}
$$

for the numerical solution \( u^{n+1} \), which approximates the exact
solution \( \uex \) at time point \( t_{n+1} \). For constant mesh spacing,
which we assume here, \( t_{n+1}=(n+1)\Delta t \).

<h3>Discouraging numerical solutions  <a name="___sec79"></a></h3>

<p>
Choosing \( I=1 \), \( a=2 \), and running experiments with \( \theta =1,0.5, 0 \)
for \( \Delta t=1.25, 0.75, 0.5, 0.1 \), gives the results in
Figures <a href="#decay:analysis:BE4c">14</a>, <a href="#decay:analysis:CN4c">15</a>, and
<a href="#decay:analysis:FE4c">16</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 14:  Backward Euler. <a name="decay:analysis:BE4c"></a> </p></center>
<p><img src="fig-decay/BE4c.png" align="bottom" width=600,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 15:  Crank-Nicolson. <a name="decay:analysis:CN4c"></a> </p></center>
<p><img src="fig-decay/CN4c.png" align="bottom" width=600,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 16:  Forward Euler. <a name="decay:analysis:FE4c"></a> </p></center>
<p><img src="fig-decay/FE4c.png" align="bottom" width=600,></p>
</center>

<p>
The characteristics of the displayed curves can be summarized as follows:

<p>

<ul>
  <li> The Backward Euler scheme always give a monotone solution, lying above
    the exact curve.</li>
  <li> The Crank-Nicolson scheme gives the most accurate results, but for
    \( \Delta t=1.25 \) the solution oscillates.</li>
  <li> The Forward Euler scheme gives a growing, oscillating solution for
    \( \Delta t=1.25 \); a decaying, oscillating solution for \( \Delta t=0.75 \);
    a strange solution \( u^n=0 \) for \( n\geq 1 \) when \( \Delta t=0.5 \); and
    a solution seemingly as accurate as the one by the Backward Euler
    scheme for \( \Delta t = 0.1 \), but the curve lies below the exact
    solution.</li>
</ul>

Since the exact solution of our model problem is a monotone function,
\( u(t)=Ie^{-at} \), some of these qualitatively wrong results are indeed alarming!

<h3>Experimental investigation of oscillatory solutions  <a name="___sec80"></a></h3>

<p>
We may ask the question: Under what circumstances, i.e., values of
the input data \( I \), \( a \), and \( \Delta t \) will the Forward Euler and
Crank-Nicolson schemes result in undesired oscillatory solutions?

<p>
We may set up an experiment where we loop over values of \( I \), \( a \),
and \( \Delta t \). For each experiment, we flag the solution as
oscillatory if
$$ u^{n} > u^{n-1},$$

for some value of \( n \),
since we expect \( u^n \) to decay with \( n \), but oscillations make
\( u \) increase over a time step. We will quickly see that
oscillations are independent of \( I \), but do depend on \( a \) and
\( \Delta t \). Therefore, we introduce a two-dimensional
function \( B(a,\Delta t) \) which is 1 if oscillations occur
and 0 otherwise. We can visualize \( B \) as a contour plot
(lines for which \( B=\hbox{const} \)). The contour \( B=0.5 \) will
correspond to the borderline between oscillatory regions with \( B=1 \)
and monotone regions with \( B=0 \) in the \( a-\Delta t \) plane.

<p>
The \( B \) function is defined at discrete \( a \) and \( \Delta t \) values.
Say we have given \( P \) $a$ values, \( a_0,\ldots,a_{P-1} \), and
\( Q \) $\Delta t$ values, \( \Delta t_0,\ldots,\Delta t_{Q-1} \).
These \( a_i \) and \( \Delta t_j \) values, \( i=0,\ldots,P-1 \),
\( j=0,\ldots,Q-1 \), form a rectangular mesh of \( P\times Q \) points
in the plane. At each point \( (a_i, \Delta t_j) \), we associate
the corresponding value of \( B(a_i,\Delta t_j) \), denoted \( B_{ij} \).
The \( B_{ij} \) values are naturally stored in a two-dimensional
array. Both Matplotlib and SciTools can create a plot of the
contour line \( B_{ij}=0.5 \) dividing the oscillatory and monotone
regions. The file <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/decay_osc_regions.py"><tt>decay_osc_regions.py</tt></a> contains all nuts and
bolts to produce the \( B=0.5 \) line in Figures <a href="#decay:analysis:B:FE">17</a>
and <a href="#decay:analysis:B:CN">18</a>. The oscillatory region is above this line.

<p>

<!-- code=python (from !bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay_mod</span> <span style="color: #8B008B; font-weight: bold">import</span> solver
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">st</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">non_physical_behavior</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Given lists/arrays a and dt, and numbers I, dt, and theta,</span>
<span style="color: #CD5555">    make a two-dimensional contour line B=0.5, where B=1&gt;0.5</span>
<span style="color: #CD5555">    means oscillatory (unstable) solution, and B=0&lt;0.5 means</span>
<span style="color: #CD5555">    monotone solution of u&#39;=-au.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    a = np.asarray(a); dt = np.asarray(dt)  <span style="color: #228B22"># must be arrays</span>
    B = np.zeros((<span style="color: #658b00">len</span>(a), <span style="color: #658b00">len</span>(dt)))         <span style="color: #228B22"># results</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(a)):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(dt)):
            u, t = solver(I, a[i], T, dt[j], theta)
            <span style="color: #228B22"># Does u have the right monotone decay properties?</span>
            correct_qualitative_behavior = <span style="color: #658b00">True</span>
            <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, <span style="color: #658b00">len</span>(u)):
                <span style="color: #8B008B; font-weight: bold">if</span> u[n] &gt; u[n-<span style="color: #B452CD">1</span>]:  <span style="color: #228B22"># Not decaying?</span>
                    correct_qualitative_behavior = <span style="color: #658b00">False</span>
                    <span style="color: #8B008B; font-weight: bold">break</span>  <span style="color: #228B22"># Jump out of loop</span>
            B[i,j] = <span style="color: #658b00">float</span>(correct_qualitative_behavior)
    a_, dt_ = st.ndgrid(a, dt)  <span style="color: #228B22"># make mesh of a and dt values</span>
    st.contour(a_, dt_, B, <span style="color: #B452CD">1</span>)
    st.grid(<span style="color: #CD5555">&#39;on&#39;</span>)
    st.title(<span style="color: #CD5555">&#39;theta=%g&#39;</span> % theta)
    st.xlabel(<span style="color: #CD5555">&#39;a&#39;</span>); st.ylabel(<span style="color: #CD5555">&#39;dt&#39;</span>)
    st.savefig(<span style="color: #CD5555">&#39;osc_region_theta_%s.png&#39;</span> % theta)
    st.savefig(<span style="color: #CD5555">&#39;osc_region_theta_%s.eps&#39;</span> % theta)

non_physical_behavior(
    I=<span style="color: #B452CD">1</span>,
    a=np.linspace(<span style="color: #B452CD">0.01</span>, <span style="color: #B452CD">4</span>, <span style="color: #B452CD">22</span>),
    dt=np.linspace(<span style="color: #B452CD">0.01</span>, <span style="color: #B452CD">4</span>, <span style="color: #B452CD">22</span>),
    T=<span style="color: #B452CD">6</span>,
    theta=<span style="color: #B452CD">0.5</span>)
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 17:  Forward Euler scheme: oscillatory solutions occur for points above the curve. <a name="decay:analysis:B:FE"></a> </p></center>
<p><img src="fig-decay/osc_region_FE.png" align="bottom" width=500></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 18:  Crank-Nicolson scheme: oscillatory solutions occur for points above the curve. <a name="decay:analysis:B:CN"></a> </p></center>
<p><img src="fig-decay/osc_region_CN.png" align="bottom" width=500></p>
</center>

<p>
By looking at the curves in the figures one may guess that \( a\Delta t \)
must be less than a critical limit to avoid the undesired
oscillations.  This limit seems to be about 2 for Crank-Nicolson and 1
for Forward Euler.  We shall now establish a mathematical analysis of
the discrete model that can explain the observations in our numerical
experiments.

<h3>Exact numerical solution  <a name="___sec81"></a></h3>

<p>
Starting with \( u^0=I \), the simple recursion \eqref{decay:analysis:scheme}
can be applied repeatedly \( n \) times, with the result that
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n\thinspace .
\label{decay:analysis:unex}
\end{equation}
$$


<p>
Difference equations where all terms are linear in
\( u^{n+1} \), \( u^n \), and maybe \( u^{n-1} \), \( u^{n-2} \), etc., are
called <em>homogeneous, linear</em> difference equations, and their solutions
are generally of the form \( u^n=A^n \). Inserting this expression
and dividing by \( A^{n+1} \) gives
a polynomial equation in \( A \). In the present case we get
$$ A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}\thinspace .$$

This is a solution technique of wider applicability than repeated use of
the recursion \eqref{decay:analysis:scheme}.

<p>
Regardless of the solution approach, we have obtained a formula for
\( u^n \).  This formula can explain everything what we see in the figures
above, but it also gives us a more general insight into accuracy and
stability properties of the three schemes.

<h3>Stability  <a name="___sec82"></a></h3>

<p>
Since \( u^n \) is a factor

<p>
$$
\begin{equation}
A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}
\end{equation}
$$

raised to an integer power (\( n \)), we realize that \( A<0 \)
will for odd powers imply \( u^n<0 \) and for even power result in \( u^n>0 \),
i.e., a solution that oscillates between the mesh points.
We have that \( A<0 \) when

<p>
$$
\begin{equation}
(1-\theta)a\Delta t > 1 \thinspace .
\label{decay:th:stability}
\end{equation}
$$

Since \( A>0 \) is a requirement for having a numerical solution with the
same basic property (monotonicity) as the exact solution, we may say
that \( A>0 \) is a <em>stability criterion</em>. Expressed in terms of \( \Delta t \)
the stability criterion reads

<p>
$$
\begin{equation}
\Delta t \leq \frac{1}{(1-\theta)a}\thinspace .
\end{equation}
$$


<p>
The Backward
Euler scheme is always stable (since \( A<0 \) is impossible), while
non-oscillating solutions for Forward Euler and Crank-Nicolson
demand \( \Delta t\leq 1/a \) and \( \Delta t\leq 2/a \), respectively.
The relation between \( \Delta t \) and \( a \) look reasonable: a smaller
\( a \) means faster decay and hence a need for smaller time steps.

<p>
Looking at Figure <a href="#decay:analysis:FE4c">16</a>, we see that with \( a\Delta
t= 2\cdot 1.25=2.5 \), \( A=-1.5 \), and the solution \( u^n=(-1.5)^n \)
oscillates <em>and</em> grows. With \( a\Delta t = 2\cdot 0.75=1.5 \), \( A=-0.5 \),
\( u^n=(-0.5)^n \) decays but oscillates. The peculiar case \( \Delta t =
0.5 \), where the Forward Euler scheme produces a solution that is stuck
on the \( t \) axis, corresponds to \( A=0 \) and therefore \( u^0=I=1 \) and
\( u^n=0 \) for \( n\geq 1 \).  The decaying oscillations in the Crank-Nicolson scheme
for \( \Delta t=1.25 \) is easily explained by \( A=-0.25 \).

<p>
The factor \( A \) is called <em>amplification factor</em> since the solution at
a new time level is \( A \) times the solution at the previous time level. For
a decay process, we must obviously have \( |A|\leq 1 \) for all \( \Delta
t \), which is fulfilled for \( \theta \geq 1/2 \). Arbitrarily large values
of \( u \) can be generated when \( |A|>1 \) and \( n \) is large enough. The
numerical solution is in such cases totally irrelevant to an ODE modeling decay
processes.

<h3>Comparing amplification factors  <a name="___sec83"></a></h3>

<p>
After establishing how \( A \) impacts the qualitative features of the
solution, we shall now look more into how well the numerical amplification
factor approximates the exact one. The exact solution reads
\( u(t)=Ie^{-at} \), which can be rewritten as
$$
\begin{equation}
{\uex}(t_n) = Ie^{-a n\Delta t} = I(e^{-a\Delta t})^n \thinspace .
\end{equation}
$$

From this formula we see that the exact amplification factor is
$$
\begin{equation}
\Aex = e^{-a\Delta t} \thinspace .
\end{equation}
$$


<p>
We realize that the exact and numerical amplification factors depend
on \( a \) and \( \Delta t \) through the product \( a\Delta t \). Therefore, it
is convenient to introduce a symbol for this product, \( p=a\Delta t \),
and view \( A \) and \( \Aex \) as functions of \( p \). Figure
<a href="#decay:analysis:fig:A">19</a> shows these functions. Crank-Nicolson is
clearly closest to the exact amplification factor, but that method has
the unfortunate oscillatory behavior when \( p>2 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 19:  Comparison of amplification factors. <a name="decay:analysis:fig:A"></a> </p></center>
<p><img src="fig-decay/A_factors.png" align="bottom" width=500></p>
</center>

<h3>Series expansion of amplification factors  <a name="___sec84"></a></h3>

<p>
As an alternative to the visual understanding
inherent in Figure <a href="#decay:analysis:fig:A">19</a>, there
is a strong tradition in numerical analysis to investigate
approximation errors when the discretization parameter, here \( \Delta t \),
becomes small. In the present case we let \( p \) be our small
discretization parameter, and it makes sense to simplify the
expressions for \( A \) and \( \Aex \) by using Taylor polynomials around \( p=0 \).
The Taylor polynomials are accurate for small \( p \) and greatly simplifies
the comparison of the analytical expressions since we then can compare
polynomials, term by term.

<p>
Calculating the Taylor series for \( \Aex \) is easily done by hand, but
the three versions of \( A \) for \( \theta=0,1,\frac{1}{2} \) lead to more
cumbersome calculations.
Nowadays, analytical computations can benefit greatly by
symbolic computer algebra software. The Python package <code>sympy</code>
represents a powerful computer algebra system, not as sophisticated as
the famous Maple and Mathematica systems, but free and
very easy to integrate with our numerical computations in Python.

<p>
When using <code>sympy</code>, it is convenient to enter the interactive Python
mode where we can write expressions and statements and immediately see
the results.  Here is a simple example. We strongly recommend to use
<code>isympy</code> (or <code>ipython</code>) for such interactive sessions, although our
typesetting will apply the different prompt <code>>>></code> (associated with the
primitive Python shell that results from writing <code>python</code> in a
terminal window).

<p>
Let us enter <code>sympy</code> in a Python shell and show how
we can find the Taylor series for \( e^{-p} \):
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; p = Symbol(&#39;p&#39;)  # all variables must be declared as Symbols
&gt;&gt;&gt; A_e = exp(-p)
&gt;&gt;&gt;
&gt;&gt;&gt; # First 6 terms of the Taylor series of A_e
&gt;&gt;&gt; A_e.series(p, 6)
1 + (1/2)*p**2 - p - 1/6*p**3 - 1/120*p**5 + (1/24)*p**4 + O(p**6)
</pre></div>
<p>
Lines with <code>>>></code> represent input lines and lines without
this prompt represents the result of computations.
Apart from the order of the powers, the computed formula is easily
recognized as the beginning of the Taylor series for \( e^{-p} \).

<p>
Let us define the numerical amplification factor where \( p \) and \( \theta \)
enter the formula as symbols:
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; theta = Symbol(&#39;theta&#39;)
&gt;&gt;&gt; A = (1-(1-theta)*p)/(1+theta*p)
</pre></div>
<p>
To work with the factor for the Backward Euler scheme we
can substitute the value 1 for <code>theta</code>:
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; A.subs(theta, 1)
1/(1 + p)
</pre></div>
<p>
Similarly, we can substitute <code>theta</code> by 1/2 for Crank-Nicolson,
preferably using an exact rational representation of 1/2 in <code>sympy</code>:
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; half = Rational(1,2)
&gt;&gt;&gt; A.subs(theta, half)
1/(1 + (1/2)*p)*(1 - 1/2*p)
</pre></div>
<p>
The Taylor series of the amplification factor for the Crank-Nicolson
scheme can be computed as
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; A.subs(theta, half).series(p, 4)
1 + (1/2)*p**2 - p - 1/4*p**3 + O(p**4)
</pre></div>
<p>
We are now in a position to compare Taylor series:
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; FE = A_e.series(p, 4) - A.subs(theta, 0).series(p, 4)
&gt;&gt;&gt; BE = A_e.series(p, 4) - A.subs(theta, 1).series(p, 4)
&gt;&gt;&gt; CN = A_e.series(p, 4) - A.subs(theta, half).series(p, 4)
&gt;&gt;&gt; FE
(1/2)*p**2 - 1/6*p**3 + O(p**4)
&gt;&gt;&gt; BE
-1/2*p**2 + (5/6)*p**3 + O(p**4)
&gt;&gt;&gt; CN
(1/12)*p**3 + O(p**4)
</pre></div>
<p>
From these expressions we see that the error \( A-\Aex\sim \Oof{p^2} \)
for the Forward and Backward Euler schemes, while
\( A-\Aex\sim \Oof{p^3} \) for the Crank-Nicolson scheme.
It is the <em>leading order term</em>,
i.e., the term of the lowest order (degree),
that is of interest, because as \( p\rightarrow 0 \), this term is
(much) bigger than the higher-order terms.

<p>
Now, \( a \) is a given parameter in the problem, while \( \Delta t \) is
what we can vary. One therefore usually writes the error expressions in
terms \( \Delta t \). When then have
$$
\begin{equation}
A-\Aex = \left\lbrace\begin{array}{ll}
\Oof{\Delta t^2}, & \hbox{Forward and Backward Euler},\\ 
\Oof{\Delta t^3}, & \hbox{Crank-Nicolson}
\end{array}\right.
\end{equation}
$$

What is the significance of this result? If we halve \( \Delta t \),
the error in amplification factor at a time level will be reduced
by a factor of 4 in the Forward and Backward Euler schemes, and by
a factor of 8 in the Crank-Nicolson scheme. That is, as we
reduce \( \Delta t \) to obtain more accurate results, the Crank-Nicolson
scheme reduces the error more efficiently than the other schemes.

<h3>Local error  <a name="___sec85"></a></h3>

<p>
(max/infinity norm etc).
Both errors can be investigated analytically.]

<h3>Analytical comparison of schemes  <a name="___sec86"></a></h3>

<p>
An alternative comparison of the schemes is to look at the
ratio \( A/\Aex \), or the error \( 1-A/\Aex \) in this ratio:
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; FE = 1 - (A.subs(theta, 0)/A_e).series(p, 4)
&gt;&gt;&gt; BE = 1 - (A.subs(theta, 1)/A_e).series(p, 4)
&gt;&gt;&gt; CN = 1 - (A.subs(theta, half)/A_e).series(p, 4)
&gt;&gt;&gt; FE
(1/2)*p**2 + (1/3)*p**3 + O(p**4)
&gt;&gt;&gt; BE
-1/2*p**2 + (1/3)*p**3 + O(p**4)
&gt;&gt;&gt; CN
(1/12)*p**3 + O(p**4)
</pre></div>
<p>
The leading-order terms have the same powers as
in the analysis of \( A-\Aex \).

<h3>The real (global) error at a point  <a name="___sec87"></a></h3>

<p>
The error in the amplification factor reflects the error when
progressing from time level \( t_n \) to \( t_{n-1} \).
To investigate the real error at a point, known as the <em>global error</em>,
we look at \( u^n-\uex(t_n) \) for some \( n \) and Taylor expand the
mathematical expressions as functions of \( p=a\Delta t \):
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; n = Symbol(&#39;n&#39;)
&gt;&gt;&gt; u_e = exp(-p*n)
&gt;&gt;&gt; u_n = A**n
&gt;&gt;&gt; FE = u_e.series(p, 4) - u_n.subs(theta, 0).series(p, 4)
&gt;&gt;&gt; BE = u_e.series(p, 4) - u_n.subs(theta, 1).series(p, 4)
&gt;&gt;&gt; CN = u_e.series(p, 4) - u_n.subs(theta, half).series(p, 4)
&gt;&gt;&gt; FE
(1/2)*n*p**2 - 1/2*n**2*p**3 + (1/3)*n*p**3 + O(p**4)
&gt;&gt;&gt; BE
(1/2)*n**2*p**3 - 1/2*n*p**2 + (1/3)*n*p**3 + O(p**4)
&gt;&gt;&gt; CN
(1/12)*n*p**3 + O(p**4)
</pre></div>
<p>
For a fixed time \( t \), the parameter \( n \) in these expressions increases
as \( p\rightarrow 0 \) since \( t=n\Delta t \). That is, \( n=t/\Delta t \), and
the leading-order error terms therefore become \( \frac{1}{2}na^2\Delta
t^2 = \frac{1}{2}ta^2t\Delta t \) for the Forward and Backward Euler
scheme, and \( \frac{1}{12}na^3\Delta t^3 = \frac{1}{12}ta^3\Delta t^2 \)
for the Crank-Nicolson scheme.  The global error is therefore of
second order in \( \Delta t \) for the latter scheme and first order for
the former schemes.

<h3>Integrated errors  <a name="___sec88"></a></h3>

<p>
The formulas for various error measures have so far measured the
error at one time point. Many prefer to use the error
integrated over the whole time interval of interest: \( [0,T] \).
An immediate practical problem arises, however, since the
numerical solution is only known at the mesh points, while an
integration will need this solution also at the points between
the mesh points. Let \( \tilde u \) be a continuous representation
of the numerical solution, usually obtained by drawing straight
lines between the values at the mesh points. Then
a common measure of the global error is the so-called \( L^2 \) error:
$$
\begin{equation}
E_2 = \sqrt{\int_0^T ({\uex}(t) - \tilde u(t))^2dt} \thinspace .
\end{equation}
$$

A family of such measures is the \( L^p \) errors, defined as
$$
\begin{equation}
E_p = \left(\int_0^T ({\uex}(t) - \tilde u(t))^pdt\right)^{1/p} \thinspace .
\end{equation}
$$

For \( p=1 \) we just take the absolute value of the integrand.

<p>
Strictly speaking, it is questionable in a finite difference method
to introduce an additional approximation in the error measure,
namely how \( \tilde u \) varies
between the mesh points. Some may argue and say that the numerical
solution is defined at the mesh points only and that we should
approximate the integrals above by numerical methods involving
the integrand at just the mesh points. The numerical integration
method also represents an approximation, but a discrete integration
procedure is consistent with having only discrete values of the integrand.

<p>
For uniformly distributed mesh points we have the well-known Trapezoidal
rule,
$$
\begin{equation}
E_2 \approx \left(\Delta t\left( \half ({\uex}(0) - u^0)^2
+ \half ({\uex}(T) - u^N)^2  + \sum_{k=1}^{N-1} ({\uex}(k\Delta t) - u^k)^2 \right)
\right)^{1/2} \thinspace .
\label{decay:E2:Tr}
\end{equation}
$$

In case the mesh points are arbitrarily spaced, we have an immediate
generalization in terms of the sum of the various trapezoids:
$$
\begin{equation}
E_2 \approx \left(\half\sum_{k=0}^{N-1}(t_{k+1} - t_k)
\left( ({\uex}(k\Delta t) - u^k)^2 + ({\uex}((k+1)\Delta t) - u^{k+1})^2\right)
\right)^{1/2} \thinspace .
\label{decay:E2:Trg}
\end{equation}
$$

A simpler approximation is to use rectangles whose heights are determined
by the left (or right) value in each interval:
$$
\begin{equation}
E_2 \approx \left(\sum_{k=0}^{N-1}(t_{k+1} - t_k)({\uex}(k\Delta t) - u^k)^2
\right)^{1/2} \thinspace .
\label{decay:E2:Reg1}
\end{equation}
$$

With uniformly distributed mesh points we get the simplification
$$
\begin{equation}
E_2 \approx \left(\Delta t\sum_{k=0}^{N-1}({\uex}(k\Delta t) - u^k)^2
\right)^{1/2} \thinspace .
\label{decay:E2:Reg}
\end{equation}
$$


<p>
Suppose that in a program the \( u^k \) values are available as elements
in the array <code>u</code>, while the \( \uex(k\Delta t) \) values are available
as elements in the array <code>u_e</code>. The formula \eqref{decay:E2:Reg} can
then be calculated as follows by array arithmetics in Python:

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">E2 = sqrt(dt*sum((u_e - u)**2))
</pre></div>
<p>
This is exactly the "array formula" that popped up in
the section <a href="._part0002_main_decay-solarized.html#decay:computing:error">Computing the numerical error</a>.

<p>
Integrated error measures sum up the contributions from each mesh point,
so we must expect the global error to be larger than
the local error. Roughly speaking,
if \( |\uex(t_n) - u^n|\sim ta^{r+1}\Delta t^r \), we have

<p>
$$
\begin{align*}
E &\approx \sqrt{\Delta t\sum_{i=0}^N i^2a^{2(r+1)}\Delta t^{2r+1}}\\ 
&= \sqrt{a^{2(r+1)}\Delta t^{2r+2} \sum_i i^2}\\ 
& \approx a^{r+1}\Delta t^{r+1} N^{3/2} = a^{r+1}\Delta t^{r-1/2} T^{3/2}
\end{align*}
$$

since \( t=i\Delta t \), \( \sum_{i=0}^N i^2\approx \frac{1}{3}N^3 \), and
\( N=T/\Delta t \).

<h2>Exercises  <a name="___sec89"></a></h2>

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 11: Explore the \( \theta \)-rule for exponential growth <a name="decay:analysis:exer:growth"></a></h3>

<p>
Solve the ODE \( u'=-au \) with \( a<0 \) such that the ODE models
exponential growth. Run experiments with \( \theta \) and \( \Delta t \) using
the <code>decay_exper1.py</code> code modified to your needs.
Are there any numerical artifacts?
Filename: <code>growth_exper1.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 12: Summarize investigations in a report <a name="decay:analysis:exer:growth:report"></a></h3>

<p>
Write a scientific report about the findings in
<a href="#decay:analysis:exer:growth">Exercise 11: Explore the \( \theta \)-rule for exponential growth</a>.
You can use examples from the section <a href="._part0004_main_decay-solarized.html#decay:exper:report">Making a report</a> to
see how various formats can be used for scientific reports.
Filename: <code>growth_analysis.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 13: Plot amplification factors for exponential growth <a name="decay:analysis:exer:growth:A"></a></h3>

<p>
Modify the <code>decay_ampf_plot.py</code> code to visualize the
amplification factors for \( \theta =0, 0.5, 1 \) and the exact
amplification factor in case of exponential growth as in
<a href="#decay:analysis:exer:growth">Exercise 11: Explore the \( \theta \)-rule for exponential growth</a>.  Explain the
artifacts seen in <a href="#decay:analysis:exer:growth">Exercise 11: Explore the \( \theta \)-rule for exponential growth</a>.
Filename: <code>growth_ampf_plot.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<a href="._part0005_main_decay-solarized.html"><img src="https://doconce.googlecode.com/hg/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0007_main_decay-solarized.html"><img src="https://doconce.googlecode.com/hg/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

