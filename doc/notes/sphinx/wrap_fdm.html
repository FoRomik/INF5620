
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Discretizing first-order ODEs by finite difference methods &mdash; Preliminary notes for INF5620 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Preliminary notes for INF5620 1.0 documentation" href="index.html" />
    <link rel="prev" title="Preliminary notes for INF5620" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Preliminary notes for INF5620"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Preliminary notes for INF5620 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="discretizing-first-order-odes-by-finite-difference-methods">
<h1>Discretizing first-order ODEs by finite difference methods<a class="headerlink" href="#discretizing-first-order-odes-by-finite-difference-methods" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Aug 23, 2012</td>
</tr>
</tbody>
</table>
<p><strong>WARNING: ULTRA-PRELIMINARY VERSION!</strong></p>
<p>Finite difference methods for partial differential equations (PDEs)
employ a range of concepts and tools that can be introduced and
illustrated in the context of simple ordinary differential equation
(ODE) examples.  By first working with ODEs, we keep the mathematical
problems to be solved as simple as possible (but no simpler), thereby
allowing full focus on understanding the concepts and tools that will
be reused and futher extended when addressing finite difference
methods for time-dependent PDEs. The
forthcoming treatment of ODEs is therefore solely dominated by
reasoning and methods that directly carry over to numerical
methods for PDEs.</p>
<p>We study two model problems: an ODE for a decaying phenomena, which will
be relevant for PDEs of diffusive nature, and an ODE for oscillating
phenomena, which will be relevant for PDEs of wave nature.
Both problems are linear with known analytical solutions such that we can
easily assess the quality of various numerical methods and analyze
their behavior.</p>
</div>
<div class="section" id="finite-difference-methods-for-an-ode">
<span id="sec-ode-d"></span><h1>Finite difference methods for an ODE<a class="headerlink" href="#finite-difference-methods-for-an-ode" title="Permalink to this headline">¶</a></h1>
<p>The purpose of this module is to explain finite difference methods
in detail for a simple ordinary differential equation (ODE).
Emphasis is put on the reasoning when discretizing the problem,
various ways of programming the methods, how to verify that
the implementation is correct, experimental investigations of
the numerical behavior of the methods, and theoretical analysis
of the methods to explain the observations.</p>
<div class="section" id="a-decay-problem">
<span id="decay-model"></span><h2>A decay problem<a class="headerlink" href="#a-decay-problem" title="Permalink to this headline">¶</a></h2>
<p>Our model problem is perhaps the simplest ODE:</p>
<div class="math">
\[u'(t) = -au(t),\]</div>
<p>Here, <span class="math">\(a&gt;0\)</span> is a constant and <span class="math">\(u'(t)\)</span> means differentiation with respect
to time <span class="math">\(t\)</span>. This type of equation arises in a number of widely different
phenomena where some quantity <span class="math">\(u\)</span> undergoes exponential
reduction. Examples include radioactive decay, population decay,
investment decay,
cooling of an object,
pressure decay in the atmosphere,
and retarded motion in fluids (for some of these models, <span class="math">\(a\)</span> can be
negative as well).
Studying numerical solution methods for this simple ODE
gives imporant insight that can be reused for diffusion PDEs.</p>
<p>The analytical solution of the ODE is found by the method of
separation of variables, resulting in</p>
<div class="math">
\[u(t) = Ce^{-at},\]</div>
<p>for any arbitrary constant <span class="math">\(C\)</span>.
To formulate a mathematical problem for which there
is a unique solution, we need a condition to fix the value of <span class="math">\(C\)</span>.
This condition is known as the <em>initial condition</em> and stated as
<span class="math">\(u(0)=I\)</span>. That is, we know the
value <span class="math">\(I\)</span> of <span class="math">\(u\)</span> when the process starts at <span class="math">\(t=0\)</span>. The exact solution
is then <span class="math">\(u(t)=I\exp{(-at)}\)</span>.</p>
<p>We seek the solution <span class="math">\(u(t)\)</span> of the ODE for <span class="math">\(t\in (0,T]\)</span>. The point <span class="math">\(t=0\)</span> is not
included since we know <span class="math">\(u\)</span> here and assume that the equation governs
<span class="math">\(u\)</span> for <span class="math">\(t&gt;0\)</span>. The complete ODE problem then reads: find <span class="math">\(u(t)\)</span>
such that</p>
<div class="math" id="equation-decay:problem">
<span class="eqno">(1)</span>\[     u' = -au,\ t\in (0,T], \quad u(0)=I\thinspace .\]</div>
<p>This is known as a <em>continuous problem</em> because the parameter <span class="math">\(t\)</span>
varies continuously from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>. For each <span class="math">\(t\)</span> we have a corresponding
<span class="math">\(u(t)\)</span>. There are hence infinitely many values of <span class="math">\(t\)</span> and <span class="math">\(u(t)\)</span>.
The purpose of a numerical method is to formulate a corresponding
<em>discrete</em> problem whose solution is characterized by a finite number of values,
which can be computed in a finite number of steps on a computer.</p>
</div>
<div class="section" id="the-forward-euler-scheme">
<span id="decay-sec-fe"></span><h2>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>Solving an ODE like <a href="#equation-decay:problem">(1)</a> by a finite difference method
consists of the following four steps:</p>
<ol class="arabic simple">
<li>discretizing the domain,</li>
<li>fulfilling the equation at discrete time points,</li>
<li>replacing derivatives by finite differences,</li>
<li>formulating a recursive algorithm.</li>
</ol>
<div class="section" id="step-1-discretizing-the-domain">
<span id="index-0"></span><h3>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The time domain <span class="math">\([0,T]\)</span> is represented by a finite number of
<span class="math">\(N+1\)</span> points</p>
<div class="math">
\[\begin{split}0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N-1} &lt; t_N = T\thinspace .\end{split}\]</div>
<p>The collection of points <span class="math">\(t_0,t_1,\ldots,t_N\)</span> constitutes a <em>mesh</em>
or <em>grid</em>. Often the mesh points will be uniformly spaced in
the domain <span class="math">\([0,T]\)</span>, which means that the spacing <span class="math">\(t_{n+1}-t_n\)</span> is
the same for all <span class="math">\(n\)</span>. This spacing is then often denoted by <span class="math">\(\Delta t\)</span>,
in this case <span class="math">\(t_n=n\Delta t\)</span>.</p>
<p>We seek the solution <span class="math">\(u\)</span> at the mesh points:
<span class="math">\(u(t_n)\)</span>, <span class="math">\(n=1,2,\ldots,N\)</span> (note that <span class="math">\(u^0\)</span> is already known as <span class="math">\(I\)</span>).
A notational short-form for <span class="math">\(u(t_n)\)</span>,
which will be used extensively, is <span class="math">\(u^{n}\)</span>. More precisely, we let
<span class="math">\(u^n\)</span> be the <em>numerical approximation</em> to the exact solution
at <span class="math">\(t=t_n\)</span>, <span class="math">\(u(t_n)\)</span>. When we need to clearly distinguish the numerical
and the exact solution, we often place a subscript e on the exact
solution, as in <span class="math">\({u_{\mbox{\footnotesize e}}}(t_n)\)</span>. Figure <a class="reference internal" href="#decay-fdu-e"><em>Time mesh with discrete solution values</em></a> shows the
<span class="math">\(t_n\)</span> and <span class="math">\(u_n\)</span> points for <span class="math">\(n=0,1,\ldots,N=7\)</span> as well as <span class="math">\(u_{\mbox{\footnotesize e}}(t)\)</span>
as the dashed line.</p>
<div class="figure" id="decay-fdu-e">
<img alt="_images/fdm_u_ue.png" src="_images/fdm_u_ue.png" style="width: 400px;" />
<p class="caption"><em>Time mesh with discrete solution values</em></p>
</div>
<p>Since finite difference methods produce solutions at the mesh
points only, it is an open question what the solution is between
the mesh points. One can use methods for interpolation to
compute the value of <span class="math">\(u\)</span> between mesh points. The simplest
(and most widely used) interpolation method is to assume that
<span class="math">\(u\)</span> varies linearly between the mesh points, see
Figure <a class="reference internal" href="#decay-fdu-ei"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></a>. Given <span class="math">\(u^{n}\)</span>
and <span class="math">\(u^{n+1}\)</span>, the value of <span class="math">\(u\)</span> at some <span class="math">\(t\in [t_{n}, t_{n+1}]\)</span>
is by linear interpolation</p>
<div class="math">
\[u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n)\thinspace .\]</div>
<div class="figure" id="decay-fdu-ei">
<img alt="_images/fdm_u_uei.png" src="_images/fdm_u_uei.png" style="width: 400px;" />
<p class="caption"><em>Linear interpolation between the discrete solution values (dashed curve is exact solution)</em></p>
</div>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h3>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h3>
<p>The ODE is supposed to hold for all <span class="math">\(t\in (0,T]\)</span>, i.e., at an infinite
number of points. Now we relax that requirement and require that
the ODE is fulfilled at a finite set of discrete points in time.
The mesh points <span class="math">\(t_1,t_2,\ldots,t_N\)</span> are a natural choice of points.
The original ODE is then reduced to  the following <span class="math">\(N\)</span> equations:</p>
<div class="math" id="equation-decay:step2">
<span class="eqno">(2)</span>\[     u'(t_n) = -au(t_n),\quad n=1,\ldots,N\thinspace .\]</div>
</div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<h3>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The next and most essential step of the method is to replace the
derivative <span class="math">\(u'\)</span> by a finite difference approximation. Let us first
try a one-sided difference approximation (see Figure <a class="reference internal" href="#decay-sketch-fe"><em>Illustration of a forward difference</em></a>),</p>
<div class="math" id="equation-decay:FEdiff">
<span class="eqno">(3)</span>\[     u'(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}\thinspace .\]</div>
<p>Inserting this approximation in <a href="#equation-decay:step2">(2)</a> results in</p>
<div class="math" id="equation-decay:step3">
<span class="eqno">(4)</span>\[     \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N-1\thinspace .\]</div>
<p>This equation is the discrete counterpart to the original ODE problem
<a href="#equation-decay:problem">(1)</a>, and often known as a <em>finite difference scheme</em>,
which yields a straightforward way to compute the solution at
the mesh points (<span class="math">\(u(t_n)\)</span>, <span class="math">\(n=1,2,\ldots,N\)</span>) as shown next.</p>
<div class="figure" id="decay-sketch-fe">
<img alt="_images/fd_forward.png" src="_images/fd_forward.png" style="width: 400px;" />
<p class="caption"><em>Illustration of a forward difference</em></p>
</div>
</div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<h3>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p id="index-1">The final step is to identify the computational algorithm to be implemented
in a program. The key observation here is to realize that
<a href="#equation-decay:step3">(4)</a> can be used to compute <span class="math">\(u^{n+1}\)</span> if <span class="math">\(u^n\)</span> is known.
Starting with <span class="math">\(n=0\)</span>, <span class="math">\(u^0\)</span> is known since <span class="math">\(u^0=u(0)=I\)</span>, and
<a href="#equation-decay:step3">(4)</a> gives an equation for <span class="math">\(u^1\)</span>. Knowing <span class="math">\(u^1\)</span>,
<span class="math">\(u^2\)</span> can be found from <a href="#equation-decay:step3">(4)</a>. In general, <span class="math">\(u^n\)</span>
in <a href="#equation-decay:step3">(4)</a> can be assumed known, and then we can easily solve for
the unknown <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:FE">
<span class="eqno">(5)</span>\[     u^{n+1} = u^n - a(t_{n+1} -t_n)u^n\thinspace .\]</div>
<p>We shall refer to <a href="#equation-decay:FE">(5)</a> as the Forward Euler (FE) scheme
for our model problem. From a mathematical point of view,
equations of the form <a href="#equation-decay:FE">(5)</a> are known as
<em>difference equations</em> since they express how differences in
<span class="math">\(u\)</span>, like <span class="math">\(u^{n+1}-u^n\)</span>, evolve with <span class="math">\(n\)</span>.
The finite difference method can be viewed as a method for turning
a differential equation into a difference equation.</p>
<p>Computation with <a href="#equation-decay:FE">(5)</a> is straightforward:</p>
<div class="math">
\[\begin{split}u_0 &amp;= I,\\
u_1 &amp; = u^0 - a(t_{1} -t_0)u^0 = I(1-a(t_1-t_0)),\\
u_2 &amp; = u^1 - a(t_{2} -t_1)u^1 = I(1-a(t_1-t_0))(1 - a(t_2-t_1)),\\
u^3 &amp;= u^2 - a(t_{3} -t_2)u^2 = I(1-a(t_1-t_0))(1 - a(t_2-t_1))(1 - a(t_3-t_2)),\end{split}\]</div>
<p>and so on until we reach <span class="math">\(u^N\)</span>.
In the case <span class="math">\(t_{n+1}-t_n\)</span> is a constant, denoted by <span class="math">\(\Delta t\)</span>,
we realize from the above calculations that</p>
<div class="math">
\[\begin{split}u_0 &amp;= I,\\
u_1 &amp; = I(1-a\Delta t),\\
u_2 &amp; = I(1-a\Delta t)^2,\\
u^3 &amp;= I(1-a\Delta t)^3,\\
&amp;\vdots\\
u^N &amp;= I(1-a\Delta t)^N\thinspace .\end{split}\]</div>
<p>This means that we have found a closed formula for <span class="math">\(u^n\)</span>, and there is
no need to let a computer generate the sequence <span class="math">\(u^1, u^2, u^3, \ldots\)</span>.
However, finding such a formula for <span class="math">\(u^n\)</span> is possible only for a few very
simple problems.</p>
<p>As the next sections will show, the scheme <a href="#equation-decay:FE">(5)</a> is just one
out of many alternative finite difference (and other) schemes for
the model problem <a href="#equation-decay:problem">(1)</a>.</p>
</div>
</div>
<div class="section" id="the-backward-euler-scheme">
<span id="decay-sec-be"></span><h2>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>There are many choices of difference approximations in step 3 of
the finite difference method as presented in the previous section.
Another alternative is</p>
<div class="math" id="equation-decay:BEdiff">
<span class="eqno">(6)</span>\[     u'(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}\thinspace .\]</div>
<p>Since this difference is based on going backward in time (<span class="math">\(t_{n-1}\)</span>)
for information, it is known as the Backward Euler difference.
Figure <em class="xref std std-ref">decay:sketch:BE</em> explains the idea.</p>
<div class="figure" id="decay-sketch-be">
<img alt="_images/fd_backward.png" src="_images/fd_backward.png" style="width: 400px;" />
<p class="caption"><em>Illustration of a backward difference</em></p>
</div>
<p>Inserting <a href="#equation-decay:BEdiff">(6)</a> in <a href="#equation-decay:step2">(2)</a> yields
the Backward Euler (BE) scheme:</p>
<div class="math" id="equation-decay:BE0">
<span class="eqno">(7)</span>\[     \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n\thinspace .\]</div>
<p>We assume, as explained under step 4 in the section <a class="reference internal" href="#decay-sec-fe"><em>The Forward Euler scheme</em></a>,
that we have computed <span class="math">\(u^0, u^1, \ldots, u^{n-1}\)</span> such that
<a href="#equation-decay:BE0">(7)</a> can be used to compute <span class="math">\(u^n\)</span>.
For direct similarity with the Forward Euler scheme <a href="#equation-decay:FE">(5)</a>
we replace <span class="math">\(n\)</span> by <span class="math">\(n+1\)</span> in <a href="#equation-decay:BE0">(7)</a> and solve for the
unknown value <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-decay:BE">
<span class="eqno">(8)</span>\[     u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n\thinspace .\]</div>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<span id="decay-sec-cn"></span><h2>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p>The finite difference approximations used to derive the schemes
<a href="#equation-decay:FE">(5)</a> and <a href="#equation-decay:BE">(8)</a> are both one-sided differences,
known to be less accurate than central (or midpoint)
differences. We shall now construct
a central difference at <span class="math">\(t_{n+1/2}=\frac{1}{2} (t_n + t_{n+1})\)</span>, or
<span class="math">\(t_{n+1/2}=(n+\frac{1}{2})\Delta t\)</span> if the mesh spacing is uniform in time.
The approximation reads</p>
<div class="math" id="equation-decay:CNdiff">
<span class="eqno">(9)</span>\[     u'(t_{n+\frac{1}{2}}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}\thinspace .\]</div>
<p>Note that the fraction on the right-hand side is the same as for the
Forward Euler approximation <a href="#equation-decay:FEdiff">(3)</a> and
the Backward Euler approximation <a href="#equation-decay:BEdiff">(6)</a> (with
<span class="math">\(n\)</span> replaced by <span class="math">\(n+1\)</span>). The accuracy of this fraction as an approximation
to the derivative of <span class="math">\(u\)</span> depends on <em>where</em> we seek the derivative:
in the center of the interval <span class="math">\([t_{n+1},t_n]\)</span> or at the end points.</p>
<p>With the formula <a href="#equation-decay:CNdiff">(9)</a>, where <span class="math">\(u'\)</span> is evaluated at
<span class="math">\(t_{n+1/2}\)</span>, it is natural to demand the
ODE to be fulfilled at the time points between the mesh points:</p>
<div class="math" id="equation-decay:step2m">
<span class="eqno">(10)</span>\[     u'(t_{n+\frac{1}{2}}) = -au(t_{n+\frac{1}{2}}),\quad n=0,\ldots,N-1\thinspace .\]</div>
<p>Using <a href="#equation-decay:CNdiff">(9)</a> in <a href="#equation-decay:step2m">(10)</a> results in</p>
<div class="math" id="equation-decay:CN0">
<span class="eqno">(11)</span>\[     \frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -au^{n+\frac{1}{2}},\]</div>
<p>where <span class="math">\(u^{n+\frac{1}{2}}\)</span> is a short form for <span class="math">\(u(t_{n+\frac{1}{2}})\)</span>.
The problem is that we aim to compute <span class="math">\(u^n\)</span> for integer <span class="math">\(n\)</span>, implying that
<span class="math">\(u^{n+\frac{1}{2}}\)</span> is not a quantity computed by our method. It must be
expressed by the quantities that we actually produce, i.e., <span class="math">\(u\)</span> at the
mesh points. One possibility is to approximate <span class="math">\(u^{n+\frac{1}{2}}\)</span>
as an average of the <span class="math">\(u\)</span> values at the neighboring mesh points:</p>
<div class="math" id="equation-decay:uhalfavg">
<span class="eqno">(12)</span>\[     u^{n+\frac{1}{2}} \approx \frac{1}{2} (u^n + u^{n+1})\thinspace .\]</div>
<p>Using <a href="#equation-decay:uhalfavg">(12)</a> in <a href="#equation-decay:CN0">(11)</a> results in</p>
<div class="math" id="equation-decay:CN1">
<span class="eqno">(13)</span>\[     \frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\frac{1}{2} (u^n + u^{n+1})\thinspace .\]</div>
<p>Figure <em class="xref std std-ref">decay:sketch:BE</em> sketches the geometric interpretation of
such a centered difference.</p>
<div class="figure" id="id1">
<img alt="_images/fd_backward.png" src="_images/fd_backward.png" style="width: 400px;" />
<p class="caption"><em>Illustration of a centered difference</em></p>
</div>
<p>We assume that <span class="math">\(u^n\)</span> is already computed so that <span class="math">\(u^{n+1}\)</span> is the
unknown, which we can solve for:</p>
<div class="math" id="equation-decay:CN">
<span class="eqno">(14)</span>\[     u^{n+1} = \frac{1-\frac{1}{2} a(t_{n+1}-t_n)}{1 + \frac{1}{2} a(t_{n+1}-t_n)}u^n\thinspace .\]</div>
<p>The finite difference scheme <a href="#equation-decay:CN">(14)</a> is known as
the midpoint scheme or the Crank-Nicolson (CN) scheme. We shall use the latter
name.</p>
</div>
<div class="section" id="the-unifying-rule">
<span id="decay-sec-theta"></span><h2>The unifying <span class="math">\(\theta\)</span>-rule<a class="headerlink" href="#the-unifying-rule" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-2"></span><p id="index-3">Let us reconsider the derivation of the Forward Euler, Backward Euler,
and Crank-Nicolson schemes. In all the mentioned schemes we replace <span class="math">\(u'\)</span> by the
fraction</p>
<div class="math">
\[\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n},\]</div>
<p>and the difference between the methods lies in which point this
fraction approximates the derivative; i.e., in which point we
sample the ODE. So far this has been the
end points or the midpoint of <span class="math">\([t_n,t_{n+1}]\)</span>. However, we may choose any point
<span class="math">\(\tilde t \in [t_n,t_{n+1}]\)</span>.
The difficulty
is that evaluating the right-hand side <span class="math">\(-au\)</span> at an arbitrary point
faces the same problem as in
the section <a class="reference internal" href="#decay-sec-cn"><em>The Crank-Nicolson scheme</em></a>: the point value must be expressed
by the discrete <span class="math">\(u\)</span> quantities that we compute by the scheme, i.e.,
<span class="math">\(u^n\)</span> and <span class="math">\(u^{n+1}\)</span>. Following the averaging idea from
the section <a class="reference internal" href="#decay-sec-cn"><em>The Crank-Nicolson scheme</em></a>,
the value of <span class="math">\(u\)</span> at an arbitrary point <span class="math">\(\tilde t\)</span> can be
calculated as a <em>weighted average</em>, which generalizes the arithmetic average
<span class="math">\(\frac{1}{2}u^n + \frac{1}{2}u^{n+1}\)</span>.
If we express <span class="math">\(\tilde t\)</span> as a weighted average</p>
<div class="math">
\[t_{n+\theta} = \theta t_{n+1} + (1-\theta) t_{n},\]</div>
<p>where <span class="math">\(\theta\in [0,1]\)</span> is the weighting factor, we can write</p>
<div class="math" id="equation-decay:thetaavg">
<span class="eqno">(15)</span>\[     u(\tilde t) = u(\theta t_{n+1} + (1-\theta) t_{n}) \approx
     \theta u^{n+1} + (1-\theta) u^{n}\thinspace .\]</div>
<p>We can now let the ODE hold at the point
<span class="math">\(\tilde t\in [t_n,t_{n+1}]\)</span>, approximate <span class="math">\(u'\)</span> by the fraction
<span class="math">\((u^{n+1}-u^{n})/(t_{n+1}-t_n)\)</span>, and approximate the right-hand
side <span class="math">\(-au\)</span> by the weighted average <a href="#equation-decay:thetaavg">(15)</a>.
The result is</p>
<div class="math" id="equation-decay:th0">
<span class="eqno">(16)</span>\[     \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})\]\[     \thinspace .\]</div>
<p>This is a generalized scheme for our model problem:
<span class="math">\(\theta =0\)</span> gives the Forward Euler scheme, <span class="math">\(\theta =1\)</span> gives the
Backward Euler scheme, and <span class="math">\(\theta =1/2\)</span> gives the Crank-Nicolson
scheme. In addition, we may choose any other value of <span class="math">\(\theta\)</span> in <span class="math">\([0,1]\)</span>.</p>
<p>As before, <span class="math">\(u^n\)</span> is considered known and <span class="math">\(u^{n+1}\)</span> unknown, so
we solve for the latter:</p>
<div class="math" id="equation-decay:th">
<span class="eqno">(17)</span>\[     u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}\thinspace .\]</div>
<p>This scheme is known as the <span class="math">\(\theta\)</span>-rule, or alternatively written as
the &#8220;theta-rule&#8221;.</p>
</div>
<div class="section" id="constant-time-step">
<h2>Constant time step<a class="headerlink" href="#constant-time-step" title="Permalink to this headline">¶</a></h2>
<p>All schemes up to now have been formulated for a general non-uniform
mesh in time: <span class="math">\(t_0,t_1,\ldots,t_N\)</span>. Non-uniform meshes are highly relevant
since one can use many points in regions where <span class="math">\(u\)</span> varies rapidly, and
save points in regions where <span class="math">\(u\)</span> is slowly varying. This is the key idea
of <em>adaptive</em> methods where the spacing of the mesh points
are determined as the computations proceed.</p>
<p>However, a uniformly distributed set of mesh points is very common and
sufficient for many applications. It therefore makes sense to
present the finite difference schemes for a uniform point distribution
<span class="math">\(t_n=n\Delta t\)</span>, where <span class="math">\(\Delta t\)</span> is the constant spacing between
the mesh points, also referred to as the <em>time step</em>.
The resulting formulas look simpler and are perhaps more
well known:</p>
<div class="math">
\[\begin{split}u^{n+1} &amp;= (1 - a\Delta t )u^n  \quad (\hbox{FE})
\\
u^{n+1} &amp;= \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})
\\
u^{n+1} &amp;= \frac{1-\frac{1}{2} a\Delta t}{1 + \frac{1}{2} a\Delta t} u^n \quad \quad (\hbox{CN})
\\
u^{n+1} &amp;= \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})\end{split}\]</div>
<p>Not surprisingly, we present alternative schemes
because they have different pros and cons, both for the simple ODE
in question (which can easily be solved as accurately as desired), and for
more advanced differential equation problems.</p>
</div>
<div class="section" id="operator-notation-for-finite-differences">
<span id="decay-sec-fdop"></span><h2>Operator notation for finite differences<a class="headerlink" href="#operator-notation-for-finite-differences" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><p id="index-5">Finite difference formulas can be tedious to write and read,
especially for differential equations with many terms and many
derivatives. To save space and help the reader of the scheme to quickly
see the nature of the difference approximations, we introduce a
compact notation:</p>
<div class="math">
\[\begin{split}[D_tu]^n &amp;= \frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \\
[D_t^-u]^n &amp;= \frac{u^{n} - u^{n-1}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \\
[D_t^+u]^n &amp;= \frac{u^{n+1} - u^{n}}{\Delta t}
\approx \frac{d}{dt} u(t_n)\end{split}\]</div>
<p>The notation consists of an operator that approximates
differentiation with respect to an independent variable, here <span class="math">\(t\)</span>.
The operator is built of the symbol <span class="math">\(D\)</span>, with the variable as subscript
and a superscript <span class="math">\({}^-\)</span> for a backward difference and <span class="math">\({}^+\)</span> for a forward
difference. No superscript implies a central difference.
We place square brackets around the operator and the function it operates
on and specify the mesh point, where the operator is acting, by
a superscript.</p>
<p>An averaging operator is also convenient to have:</p>
<div class="math" id="equation-fd:mean:a">
<span class="eqno">(18)</span>\[     [\overline{u}^{t}]^n = \frac{1}{2} (u^{n-\frac{1}{2}} + u^{n+\frac{1}{2}} )
     \approx u(t_n)\]</div>
<p>The superscript <span class="math">\(t\)</span> indicates that the average is taken along the time
coordinate. The common average <span class="math">\((u^n + u^{n+1})/2\)</span> can now be
expressed as <span class="math">\([\overline{u}^{t}]^{n+1/2}\)</span>.</p>
<p>The Backward Euler finite difference approximation to <span class="math">\(u'=-au\)</span> can be written
as follows utilizing the compact notation:</p>
<div class="math">
\[[D_t^-u]^n = -au^n \thinspace .\]</div>
<p>In difference equations we often place the square brackets around
the whole equation, to indicate at which mesh point the equation applies,
since each term is supposed to be approximated at the same point:</p>
<div class="math">
\[[D_t^- u  = -au]^n \thinspace .\]</div>
<p>The Forward Euler scheme takes the form</p>
<div class="math">
\[[D_t^+ u  = -au]^n,\]</div>
<p>while the Crank-Nicolson scheme is written as</p>
<div class="math" id="equation-fd:compact:ex:CN">
<span class="eqno">(19)</span>\[     [D_t u = -a\overline{u}^t]^{n+\frac{1}{2}}\thinspace .\]</div>
<p>Just apply (<em class="xref std std-ref">fd:D:c</em>) and <a href="#equation-fd:mean:a">(18)</a> and write out the
expressions to see that <a href="#equation-fd:compact:ex:CN">(19)</a> is indeed the
Crank-Nicolson scheme.</p>
<p>The <span class="math">\(\theta\)</span>-rule can be specified by</p>
<div class="math" id="equation-decay:fd1:op:theta">
<span class="eqno">(20)</span>\[     [\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta},\]</div>
<p>if we define a new time difference and a <em>weighted averaging operator</em>:</p>
<div class="math">
\[[\bar D_t u]^{n+\theta} = \frac{u^{n+1}-u^n}{t^{n+1}-t^n},\]\[[\overline{u}^{t,\theta}]^{n+\theta} = (1-\theta)u^{n} + \theta u^{n+1}
\approx u(t_{n+\theta}),\]</div>
<p>where <span class="math">\(\theta\in [0,1]\)</span>. Note that for <span class="math">\(\theta =1/2\)</span> we recover
the standard centered difference and the standard arithmetic average.
The idea in <a href="#equation-decay:fd1:op:theta">(20)</a> is to sample the equation at
<span class="math">\(t_{n+\theta}\)</span>, use a skew difference at that
point <span class="math">\([\bar D_t u]^{n+\theta}\)</span>, and a shifted mean value.
An alternative notation is</p>
<div class="math">
\[[D_t u]^{n+1/2} = \theta [-au]^{n+1} + (1-\theta)[-au]^{n}\thinspace .\]</div>
<p>Looking at the various examples above and comparing them with the
underlying differential equations, we see immediately which difference
approximations that have been used and at which point they
apply. Therefore, the compact notation efficiently communicates the
reasoning behind turning a differential equation into a difference
equation.</p>
</div>
</div>
<div class="section" id="implementation">
<span id="decay-impl1"></span><h1>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<p>The purpose now is to make a computer program for solving</p>
<div class="math">
\[u'(t) = -au(t),\quad t\in (0,T], \quad u(0)=I,\]</div>
<p>and display the solution on the screen, preferably together with the
exact solution. We shall also be concerned with how we can test
that the implementation is correct.</p>
<p>All programs referred to in this section are found in the
<a class="reference external" href="https://github.com/hplgit/INF5620/tree/master/src/decay">src/decay</a> directory.</p>
<p>We want to explore the Forward Euler scheme, the
Backward Euler, and the Crank-Nicolson schemes applied to our model problem.
From an implementational points of view, it is advantageous to
implement the <span class="math">\(\theta\)</span>-rule</p>
<div class="math">
\[u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,\]</div>
<p>since it can generate the three other schemes by various of
choices of <span class="math">\(\theta\)</span>: <span class="math">\(\theta=0\)</span> for Forward Euler, <span class="math">\(\theta =1\)</span> for
Backward Euler, and <span class="math">\(\theta =1/2\)</span> for Crank-Nicolson.
Given <span class="math">\(a\)</span>, <span class="math">\(u^0=I\)</span>, <span class="math">\(T\)</span>, and <span class="math">\(\Delta t\)</span>,
our task is to use the <span class="math">\(\theta\)</span>-rule to
compute <span class="math">\(u^1, u^2,\ldots,u^N\)</span>, where <span class="math">\(t_N=N\Delta t\)</span>, and
<span class="math">\(N\)</span> the closest integer to <span class="math">\(T/\Delta t\)</span>.</p>
<p>Any programming language can be used to generate the <span class="math">\(u^{n+1}\)</span> values from
the formula above. However, in this document we shall mainly make use of
Python of several reasons:</p>
<blockquote>
<div><ul class="simple">
<li>Python has a very clean, readable syntax (often known as
&#8220;executable pseudo-code&#8221;).</li>
<li>Python code is very similar to MATLAB code (and MATLAB has a
particularly widespread use for scientific computing).</li>
<li>Python is similar to, but much simpler to work with and
results in more reliable code than C++.</li>
<li>Python is a full-fledged, very powerful programming language.</li>
<li>Python has a rich set of modules for scientific computing, and its
popularity in scientific computing is rapidly growing.</li>
<li>Python was made for being combined with compiled languages
(C, C++, Fortran) to reuse existing numerical software and to
reach high computational performance of new implementations.</li>
<li>Python has extensive support for administrative task
needed when doing large-scale computational investigations.</li>
<li>Python has extensive support for graphics (visualization,
user interfaces, web applications).</li>
<li>FEniCS, a very powerful tool for solving PDEs by
the finite element method, is most human-efficient to operate
from Python.</li>
</ul>
</div></blockquote>
<p>Learning Python is easy. Many newcomers to the language will probably
learn enough from the examples to perform their own computer
experiements. The examples start with simple Python code and gradually
make use of more powerful constructs as we proceed. As long as it is
not inconvenient for the problem at hand, our Python code is made as
close as possible to MATLAB code for easy transition between the two
languages.</p>
<div class="section" id="making-a-program">
<span id="decay-py1"></span><h2>Making a program<a class="headerlink" href="#making-a-program" title="Permalink to this headline">¶</a></h2>
<p>We choose to have an array <tt class="docutils literal"><span class="pre">u</span></tt> for storing the <span class="math">\(u^n\)</span> values, <span class="math">\(n=0,1,\ldots,N\)</span>.
The algorithmic steps are</p>
<blockquote>
<div><ol class="arabic simple">
<li>initialize <span class="math">\(u^0\)</span></li>
<li>for <span class="math">\(t=t_n\)</span>, <span class="math">\(n=1,2,\ldots,N\)</span>: compute <span class="math">\(u_n\)</span> using
the <span class="math">\(\theta\)</span>-rule formula</li>
</ol>
</div></blockquote>
<div class="section" id="function-for-computing-the-numerical-solution">
<h3>Function for computing the numerical solution<a class="headerlink" href="#function-for-computing-the-numerical-solution" title="Permalink to this headline">¶</a></h3>
<p>The following Python function takes the input data of the problem
(<span class="math">\(I\)</span>, <span class="math">\(a\)</span>, <span class="math">\(T\)</span>, <span class="math">\(\Delta t\)</span>, <span class="math">\(\theta\)</span>) as arguments and returns two arrays with
the solution <span class="math">\(u^0,\ldots,u^N\)</span> and the mesh points <span class="math">\(t_0,\ldots,t_N\)</span>,
respectively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>            <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                 <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>    <span class="c"># n=0,1,...,N-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">numpy</span></tt> library contains a lot of functions for array computing. Most
of the function names are similar to what is found
in the the alternative scientific computing language MATLAB. Here
we make use of</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">zeros(N+1)</span></tt> for creating an array of a size <tt class="docutils literal"><span class="pre">N+1</span></tt>
and initializing the elements to zero</li>
<li><tt class="docutils literal"><span class="pre">linspace(0,</span> <span class="pre">T,</span> <span class="pre">N+1)</span></tt> for creating an array with <tt class="docutils literal"><span class="pre">N+1</span></tt> coordinates uniformly
distributed between <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt></li>
</ul>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">for</span></tt> loop deserves a comment, especially for newcomers to Python.
The construction <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">N,</span> <span class="pre">s)</span></tt> generates all integers from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">N</span></tt>
in steps of <tt class="docutils literal"><span class="pre">s</span></tt>, <em>but not including</em> <tt class="docutils literal"><span class="pre">N</span></tt>. Omitting <tt class="docutils literal"><span class="pre">s</span></tt> means <tt class="docutils literal"><span class="pre">s=1</span></tt>.
For example, <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">6,</span> <span class="pre">3)</span></tt>
gives <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt>, while <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">N)</span></tt> generates <tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">1</span></tt>, ..., <tt class="docutils literal"><span class="pre">N-1</span></tt>.
In our loop, <tt class="docutils literal"><span class="pre">n</span></tt> takes on the values generated by <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">N)</span></tt>,
implying the following assignments <tt class="docutils literal"><span class="pre">u[n+1]</span></tt>: <tt class="docutils literal"><span class="pre">u[1]</span></tt>, <tt class="docutils literal"><span class="pre">u[2]</span></tt>, ...,
<tt class="docutils literal"><span class="pre">u[N]</span></tt>, which is what we want since <tt class="docutils literal"><span class="pre">u</span></tt> has length <tt class="docutils literal"><span class="pre">N+1</span></tt>.
The first index in Python arrays or lists is <em>always</em> <tt class="docutils literal"><span class="pre">0</span></tt> and the
last is then <tt class="docutils literal"><span class="pre">len(u)-1</span></tt>.</p>
<p>To compute with the <tt class="docutils literal"><span class="pre">theta_rule</span></tt> function, we need to <em>call</em> it. Here
is a sample call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="integer-division">
<h3>Integer division<a class="headerlink" href="#integer-division" title="Permalink to this headline">¶</a></h3>
<p>The shown implementation of the <tt class="docutils literal"><span class="pre">theta_rule</span></tt> may face problems and
wrong results if <tt class="docutils literal"><span class="pre">T</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">dt</span></tt>, and <tt class="docutils literal"><span class="pre">theta</span></tt> are given as integers,
see Exercises <em class="xref std std-ref">decay:exer:intdiv</em> and <em class="xref std std-ref">decay:exer:decay1err</em>.
The problem is related to <em>integer division</em> in Python (as well as
in Fortran, C, and C++): <tt class="docutils literal"><span class="pre">1/2</span></tt> becomes <tt class="docutils literal"><span class="pre">0</span></tt>,
while <tt class="docutils literal"><span class="pre">1.0/2</span></tt>, <tt class="docutils literal"><span class="pre">1/2.0</span></tt>, or <tt class="docutils literal"><span class="pre">1.0/2.0</span></tt> all become are <tt class="docutils literal"><span class="pre">0.5</span></tt>. It is enough
that at least the nominator or the denominator is a real number
(i.e., a <tt class="docutils literal"><span class="pre">float</span></tt> object)
to ensure correct mathematical division. Inserting
a conversion <tt class="docutils literal"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">float(dt)</span></tt>
guarantees that <tt class="docutils literal"><span class="pre">dt</span></tt> is
<tt class="docutils literal"><span class="pre">float</span></tt> and avoids problems in Exercise ref:ref:<cite>decay:exer:decay1err</cite>.</p>
<p>Another problem with computing <span class="math">\(N=T/\Delta t\)</span> is that we should
round <span class="math">\(N\)</span> to the nearest integer. With <tt class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">int(T/dt)</span></tt> the <tt class="docutils literal"><span class="pre">int</span></tt>
operation picks the largest integer smaller than <tt class="docutils literal"><span class="pre">T/dt</span></tt>. Correct
rounding is obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete version of our improved, safer <tt class="docutils literal"><span class="pre">theta_rule</span></tt> function then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>           <span class="c"># avoid integer division</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>     <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                 <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>    <span class="c"># n=0,1,...,N-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
<div class="section" id="doc-strings">
<h3>Doc strings<a class="headerlink" href="#doc-strings" title="Permalink to this headline">¶</a></h3>
<p id="index-6">Right below the header line in the <tt class="docutils literal"><span class="pre">theta_rule</span></tt> function there is a
Python string enclosed in triple double quotes <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt>.
The purpose of this string object is to document what the function
does and what the arguments are. In this case the necessary
documentation do not span more than one line, but with triple double
quoted strings the text may span several lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve</span>

<span class="sd">        u&#39;(t) = -a*u(t),</span>

<span class="sd">    with initial condition u(0)=I, for t in the time interval</span>
<span class="sd">    (0,T]. The time interval is divided into time steps of</span>
<span class="sd">    length dt.</span>

<span class="sd">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span class="sd">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span class="sd">    Nicolson method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Such documentation strings appearing right after the header of
a function are called <em>doc strings</em>. There are tools that can automatically
extract the definition of functions and the contents of doc strings
and then produce nicely formatted documentation.</p>
<p>It is strongly recommended to equip any function whose purpose
is not obvious with a doc string. Nevertheless, the forthcoming
text deviates from this rule if the function is explained in the text.</p>
</div>
<div class="section" id="formatting-of-numbers">
<h3>Formatting of numbers<a class="headerlink" href="#formatting-of-numbers" title="Permalink to this headline">¶</a></h3>
<p>Having computed the discrete solution <tt class="docutils literal"><span class="pre">u</span></tt>, it is natural to look at
the numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Write out a table of t and u values:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>The convenient <tt class="docutils literal"><span class="pre">print</span></tt> statement gives unfortunately quite ugly output
because the <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> values are not aligned in nicely formatted columns.
To fix this problem, we recommend to use the <em>printf format</em>, supported most
programming languages with inheritage from C,
or Python&#8217;s recent <em>format string syntax</em>.</p>
<p>Writing <tt class="docutils literal"><span class="pre">t[i]</span></tt> and <tt class="docutils literal"><span class="pre">u[i]</span></tt> in two nicely formatted columns is done like
this with the printf format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s"> u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>The percentage signs signify &#8220;slots&#8221; in the
text where the variables listed at the end of the statement are
inserted. For each &#8220;slot&#8221; one must specify a format for how the
variable is going to appear in the string: <tt class="docutils literal"><span class="pre">s</span></tt> for pure text,
<tt class="docutils literal"><span class="pre">d</span></tt> for an integer, <tt class="docutils literal"><span class="pre">g</span></tt> for a real number written as compactly as possible,
<tt class="docutils literal"><span class="pre">9.3E</span></tt> for scientific notation with three decimals in a field of
with 12 (e.g., <tt class="docutils literal"><span class="pre">-1.351E-2</span></tt>), or <tt class="docutils literal"><span class="pre">.2f</span></tt> for a standard decimal notation,
here with two decimals, formatted with minimum width. The printf syntax provides
a quick way of formatting tabular output of numbers with full control of
the layout.</p>
<p>The corresponding format string syntax looks like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;t={t:6.3f} u={u:g}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>As seen, this format allows logical names in the &#8220;slots&#8221; where
<tt class="docutils literal"><span class="pre">t[i]</span></tt> and <tt class="docutils literal"><span class="pre">u[i]</span></tt> are to be inserted. The &#8220;slots&#8221; are surrounded
by curly braces, and the logical name is followed by a colon and
then the printf-like specification of how to format real numbers,
integers, or strings.</p>
</div>
<div class="section" id="running-the-program">
<h3>Running the program<a class="headerlink" href="#running-the-program" title="Permalink to this headline">¶</a></h3>
<p>The function and main program shown above must be placed in a file,
say with name <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay1.py">decay1.py</a>.  Make sure you
write the code with a suitable text editor (Gedit, Emacs, Vim,
Notepad++, or similar).  The program is run by executing the file this
way:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay1.py</span>
</pre></div>
</div>
<p>The text <tt class="docutils literal"><span class="pre">Terminal&gt;</span></tt> just signifies the prompt that one has in
a Unix/Linux or DOS terminal window.</p>
<p>We strongly recommend to run Python programs within the IPython shell.
First start IPython by typing</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; ipython</span>
</pre></div>
</div>
<p>in a terminal window.
The program is run by the command</p>
<div class="highlight-py"><div class="highlight"><pre><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">run</span> <span class="n">decay1</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>The advantage of running programs in IPython are many: previous commands
are easily recalled, <tt class="docutils literal"><span class="pre">%pdb</span></tt> turns on debugging so that
variables can be examined if the program
aborts due to an exception, output of commands are stored in variables,
programs and statements can be profiled,
any operating system command can be executed, modules can be loaded
automatically and other customizations can be performed when starting
IPython &#8211; to mention some of the most
useful featuers.</p>
<p>Although running programs in IPython is strongly recommended, most
execution examples in the forthcoming text simply use a minimal
text like <tt class="docutils literal"><span class="pre">Terminal&gt;</span> <span class="pre">python</span> <span class="pre">programname</span></tt>.</p>
</div>
</div>
<div class="section" id="verifying-the-implementation">
<h2>Verifying the implementation<a class="headerlink" href="#verifying-the-implementation" title="Permalink to this headline">¶</a></h2>
<p>Since it is easy to make mistakes while implementating numerical
algorithms, we should believe in the printed <span class="math">\(u\)</span> values before
we have a done a more thorough test. Many will think of comparing
the computed solution with the exact solution can prove that
the implementation is correct, but there is a difference between
the computed solution and the exact formula <span class="math">\(Ie^{-at}\)</span>. We do not
know what this difference is. The challenging question is whether
we have the mathematically correct difference or if we have another,
maybe small, difference that is due to both an approximation error
and an error in the implementation.</p>
<p>The purpose of <em>verifying</em> a program is to bring evidence for the
fact that there are no errors in the implementation. To avoid
mixing necessary approximation errors and undesired
implementation errors, we should
try to make tests where we have some exact computation of the
discrete solution or parts of it.</p>
<div class="section" id="running-a-few-algorithmic-steps-by-hand">
<h3>Running a few algorithmic steps by hand<a class="headerlink" href="#running-a-few-algorithmic-steps-by-hand" title="Permalink to this headline">¶</a></h3>
<p>The simplest approach to produce a correct reference for the discrete
solution <span class="math">\(u\)</span> of finite difference equations is is to compute a few
steps with the algorithm by hand. Then we can compare the hand
calculations with the discrete solution produced by the program.</p>
<p>With the present test example we could use a calculator and
compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>. However, the chosen values of <span class="math">\(I\)</span> and <span class="math">\(\theta\)</span>
given in the execution example above are not good: 0 and 1 can easily
simplify formulas too much for test purposes. For example, with
<span class="math">\(\theta =1\)</span> the nominator if the formula for <span class="math">\(u^n\)</span> will be the same for
all <span class="math">\(a\)</span> and <span class="math">\(\Delta t\)</span> values. We therefore choose more
&#8220;arbitrary&#8221; values, say <span class="math">\(\theta =0.8\)</span> and <span class="math">\(I=0.1\)</span>. Hand calculations
with the aid of a calculator gives</p>
<div class="math">
\[A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035\]</div>
<div class="math">
\[\begin{split}u^1 &amp;= AI=0.0298245614035,\\
u^2 &amp;= Au^1= 0.00889504462912,\\
u^3 &amp;=Au^2= 0.00265290804728\end{split}\]</div>
<p>Instead of doing this by hand, we may write the formulas in Python and
let Python do the calculations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_three_steps</span><span class="p">():</span>
    <span class="c"># Three manual steps</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="n">u1</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="n">I</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="n">u1</span>
    <span class="n">u3</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="n">u2</span>

    <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># number of time steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">print</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c"># u[1], u[2], ...</span>
    <span class="k">print</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">u3</span>
</pre></div>
</div>
<p>Visual inspection of the printed output is tedious and errorprone. What
we really want to test is whether the difference between the &#8220;hand calculations&#8221;
<tt class="docutils literal"><span class="pre">u1</span></tt>, <tt class="docutils literal"><span class="pre">u2</span></tt>, and <tt class="docutils literal"><span class="pre">u3</span></tt> and the general numerical solution in the <tt class="docutils literal"><span class="pre">u</span></tt> array
is within the machine precision. The last two print statements in the
above <tt class="docutils literal"><span class="pre">verify_three_steps</span></tt> function should therefore be replaced by
an automated comparison:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_three_steps</span><span class="p">():</span>
    <span class="o">...</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>  <span class="c"># tolerance for comparing floats</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u1</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u2</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u3</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="k">return</span> <span class="n">success</span>
</pre></div>
</div>
<p>We also put the main program, where a complete numerical simulation
of a case is carried out, in a separate function, <tt class="docutils literal"><span class="pre">main</span></tt>, since this makes
it easier to run the verify function and real simulations as desired. The
<tt class="docutils literal"><span class="pre">main</span></tt> function is then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Write out a table of t and u values:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="k">print</span> <span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s"> u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c"># or print &#39;t={t:6.3f} u={u:g}&#39;.format(t=t[i], u=u[i])</span>
</pre></div>
</div>
<p>The main program in the file may now first run the test (<tt class="docutils literal"><span class="pre">verify_three_steps()</span></tt>)
and then go on with the real simulation (<tt class="docutils literal"><span class="pre">main()</span></tt>) only if the test is passed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">verify_three_steps</span><span class="p">():</span>
    <span class="n">main</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Bug in the implementation!&#39;</span>
</pre></div>
</div>
<p>Since the verification test is always done, future errors introduced
accidentally in the program have a good chance of being detected.  It
is extremely important that verification test can always be easily
executed.  There are test frameworks and corresponding programming
rules that allow us to request running through a suite of test cases,
but in this very early stage of Python programming we just implement
and run the verification in our own code so that every detail is
visible and understood.</p>
<p>The complete program including the <tt class="docutils literal"><span class="pre">verify_three_steps*</span></tt> functions is
found in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay2.py">decay2.py</a>.  A problem
with the <tt class="docutils literal"><span class="pre">verify_three_steps</span></tt> function is that one often ends up
copying expressions from the implementation that is to be
tested. Buggy expressions are then tested against the same buggy
expressions. A much safer approach is described next.</p>
</div>
<div class="section" id="finding-an-exact-discrete-solution">
<h3>Finding an exact discrete solution<a class="headerlink" href="#finding-an-exact-discrete-solution" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is possible to find an <em>exact discrete solution</em>. That
is, we have a formula for <span class="math">\(u^n\)</span> that fulfilles the discrete finite
difference equations. The implementation can then be verified against
the exact discrete solution. This is usually the best technique for
verification.</p>
<p>Define</p>
<div class="math">
\[A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}\ thinspace .\]</div>
<p>Manual computations with the <span class="math">\(\theta\)</span>-rule results in</p>
<div class="math">
\[\begin{split}u^0 &amp;= I,\\
u^1 &amp;= Au^0 = AI,\\
u^2 &amp;= Au^1 = A^2I,\\
&amp;\vdots\\
u^n &amp;= A^nu^{n-1} = A^nI thinspace .\end{split}\]</div>
<p>We have then established the exact discrete solution as</p>
<div class="math" id="equation-decay:un:exact">
<span class="eqno">(21)</span>\[     u^n = IA^n\]\[     thinspace .\]</div>
<p>Note that <span class="math">\(n\)</span> has different meaning on the left- and right-hand side
of this equation. On the left, <span class="math">\(n\)</span> is a superscript reflecting a counter
of mesh points, while on the right, <span class="math">\(n\)</span> is a power reflecting exponentiation.</p>
<p>Comparison of the exact discrete solution and the computed
solution is done in the following function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_exact_discrete_solution</span><span class="p">():</span>

    <span class="k">def</span> <span class="nf">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">factor</span><span class="o">**</span><span class="n">n</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_de</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>  <span class="c"># tolerance for comparing floats</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="k">return</span> <span class="n">success</span>
</pre></div>
</div>
<p>Note that one can define a function inside another function (but such
a function is invisible outside the function in which it is defined).
The complete program is found in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay3.py">decay3.py</a>.</p>
</div>
</div>
<div class="section" id="computing-the-numerical-error">
<span id="decay-computing-error"></span><h2>Computing the numerical error<a class="headerlink" href="#computing-the-numerical-error" title="Permalink to this headline">¶</a></h2>
<p>Now that we have evidence for a correct implementation, we are
in a position to compare the computed <span class="math">\(u^n\)</span> values in the <tt class="docutils literal"><span class="pre">u</span></tt>
array with the exact <span class="math">\(u\)</span> values at the mesh points. The purpose
is not to check that the program is correct, but to study the
error in the numerical solution.</p>
<p>Let us first make a function for the analytical solution <span class="math">\(u_{\mbox{\footnotesize e}}(t)=Ie^{-at}\)</span>
of the model problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>A natural way to compare the exact and discrete solutions is to
calculate their difference at the mesh points:</p>
<div class="math">
\[e_n = u_{\mbox{\footnotesize e}}(t_n) - u_n,\quad n=0,1,\ldots,Nthinspace .\]</div>
<p>These numbers are conveniently computed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>  <span class="c"># Numerical solution</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
</pre></div>
</div>
<p>The last two statements make use of array arithmetics: <tt class="docutils literal"><span class="pre">t</span></tt> is an
array of mesh points that we pass to <tt class="docutils literal"><span class="pre">exact_solution</span></tt>. This function
evaluates <tt class="docutils literal"><span class="pre">-a*t</span></tt>, which is a scalar times an array, meaning that
the scalar is multiplied with each array element.
The result is an array, let us call it <tt class="docutils literal"><span class="pre">tmp1</span></tt>. Then
<tt class="docutils literal"><span class="pre">exp(tmp1)</span></tt> means applying the exponential function to each element in
<tt class="docutils literal"><span class="pre">tmp</span></tt>, resulting an array, say <tt class="docutils literal"><span class="pre">tmp2</span></tt>. Finally, <tt class="docutils literal"><span class="pre">I*tmp2</span></tt> is computed
(scalar times array) and <tt class="docutils literal"><span class="pre">u_e</span></tt> refers to this array returned from
<tt class="docutils literal"><span class="pre">exact_solution</span></tt>. The expression <tt class="docutils literal"><span class="pre">u_e</span> <span class="pre">-</span> <span class="pre">u</span></tt> is the difference between
two arrays, resulting in a new array referred to by <tt class="docutils literal"><span class="pre">e</span></tt>.</p>
<p>The array <tt class="docutils literal"><span class="pre">e</span></tt> is the current problem&#8217;s disctete <em>error function</em>. Very
often we want to work with just one number reflecting the size of the
error. A common choice is to integrate <span class="math">\(e_n^2\)</span> over the mesh and take
the square root.  Assuming the exact and discrete solution to vary
linearly between the mesh points, the integral is given exactly by the
Trapezoidal rule:</p>
<div class="math">
\[\hat E^2 = \Delta t\left(\frac{1}{2}e_0^2 + \frac{1}{2}e_N^2
+ \sum_{n=1}^{N-1} e_n^2\right)\]</div>
<p>A common approximation of this expression, for convenience, is</p>
<div class="math">
\[\hat E^2 \approx E^2 = \Delta t\sum_{n=0}^{N} e_n^2\]</div>
<p>The error in this approximation is not much of a concern: it means that
the error measure is not exactly the Trapezoidal rule of an integral, but
a slightly different measure. We could equally well have chosen other
error messages, but the choice is not important as long as we use the
same error measure consistently when investigating the error.</p>
<p>The error measure <span class="math">\(\hat E\)</span> or <span class="math">\(E\)</span> is referred to as the
<span class="math">\(L_2\)</span> norm of the discrete error function.
The formula for <span class="math">\(E\)</span> will be frequently used:</p>
<div class="math" id="equation-decay:E">
<span class="eqno">(22)</span>\[     E = \sqrt{\sum_{n=0}^N e_n^2}\]</div>
<p>The corresponding Python code, using array arithmetics, reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">sum</span></tt> function comes from <tt class="docutils literal"><span class="pre">numpy</span></tt> and computes the sum of the elements
of an array. Also the <tt class="docutils literal"><span class="pre">sqrt</span></tt> function is from <tt class="docutils literal"><span class="pre">numpy</span></tt> and computes the
square root of each element in the array argument.</p>
<p>Instead of doing array computing we can compute with
one element at a time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>     <span class="c"># length of u array (alt: u.size)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># summation variable</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Such element-wise computing, often called <em>scalar</em> computing, takes
more code, is less readable, and runs much slower than array computing.</p>
</div>
<div class="section" id="plotting-solutions">
<h2>Plotting solutions<a class="headerlink" href="#plotting-solutions" title="Permalink to this headline">¶</a></h2>
<p>Having the <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> arrays, the approximate solution <tt class="docutils literal"><span class="pre">u</span></tt> is visualized
by <tt class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>It will be illustrative to also plot <span class="math">\(u_{\mbox{\footnotesize e}}(t)\)</span> for comparison. Doing a
<tt class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u_e)</span></tt> is not exactly what we want: the <tt class="docutils literal"><span class="pre">plot</span></tt> function draws
straight lines between the discrete points <tt class="docutils literal"><span class="pre">(t[n],</span> <span class="pre">u_e[n])</span></tt> while
<span class="math">\(u_{\mbox{\footnotesize e}}(t)\)</span> varies as an exponential function between the mesh points.
The technique for showing the &#8220;exact&#8221; variation of <span class="math">\(u_{\mbox{\footnotesize e}}(t)\)</span> between
the mesh points is to introduce a very fine mesh for <span class="math">\(u_{\mbox{\footnotesize e}}(t)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Plot the error using a very fine mesh</span>
<span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r-&#39;</span><span class="p">)</span>            <span class="c"># red  line for u</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>            <span class="c"># blue line for u_e</span>
</pre></div>
</div>
<p>With more than one curve in the plot we need to associate each curve
with a legend. We also want appropriate names on the axis, a title,
and a file containing the plot as an image for inclusion in reports.
The Matplotlib package (<tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt>) contains functions for
this purpose. The names of the functions are similar to the plotting
functions known from MATLAB.  A complete plot session then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">figure</span><span class="p">()</span>                          <span class="c"># create new plot</span>
<span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>        <span class="c"># very fine mesh for</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;ro&#39;</span><span class="p">)</span>              <span class="c"># red circles for u</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>              <span class="c"># blue line for u_e</span>
<span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
<span class="n">title</span><span class="p">(</span><span class="s">&#39;Method: theta-rule, theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">savefig</span></tt> here creates a PNG file whose name reflects the
values of <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> so that we can easily distinguish
files from different runs with <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span>.</p>
<p>A bit more sophisticated and easy-to-read filename can be generated
by mapping the <span class="math">\(\theta\)</span> value to acronyms for the three common
schemes: FE (Forward Euler, <span class="math">\(\theta=0\)</span>), BE (Backward Euler, <span class="math">\(\theta=1\)</span>),
CN (Crank-Nicolson, <span class="math">\(\theta=0.5\)</span>). A Python dictionary is ideal for such
a mapping from numbers to strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
<span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<p>Let us wrap up the computation of the error measure and all the
plotting statements in a function <tt class="docutils literal"><span class="pre">explore</span></tt>. This function
can be called for various <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> values
to see how the error varies with the method and the mesh resolution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a case with the theta_rule, compute error measure,</span>
<span class="sd">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">theta_rule</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>  <span class="c"># Numerical solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>                         <span class="c"># create new plot</span>
        <span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>       <span class="c"># very fine mesh for u_e</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;ro&#39;</span><span class="p">)</span>             <span class="c"># red circles for u</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>             <span class="c"># blue line for u_e</span>
        <span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
        <span class="n">title</span><span class="p">(</span><span class="s">&#39;Method: theta-rule, theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">E</span>

<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">:</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%3.1f</span><span class="s"> </span><span class="si">%6.2f</span><span class="s">: </span><span class="si">%12.3E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">figure()</span></tt> call is key here, without it a new <tt class="docutils literal"><span class="pre">plot</span></tt> command will
just earse the last plot instead of creating a new plot in a separate window.
The complete code resides in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay4.py">decay4.py</a>.
Running this program results in</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay4.py</span>
<span class="go">0.0   0.40:    2.105E-01</span>
<span class="go">0.0   0.04:    1.449E-02</span>
<span class="go">0.5   0.40:    3.362E-02</span>
<span class="go">0.5   0.04:    1.887E-04</span>
<span class="go">1.0   0.40:    1.030E-01</span>
<span class="go">1.0   0.04:    1.382E-02</span>
</pre></div>
</div>
<p>We observe that reducing <span class="math">\(\Delta t\)</span> by a factor of 10 increases the
accuracy for all three methods (<span class="math">\(\theta\)</span> values). We also see that
the combination of <span class="math">\(\theta=0.5\)</span> and a small time step <span class="math">\(\Delta t =0.04\)</span>
gives a much more accurate solution, and that <span class="math">\(\theta=0\)</span> and <span class="math">\(\theta=0\)</span>
with <span class="math">\(\Delta t = 0.4\)</span> result in the least accurate solutions.</p>
<p>Figure <em class="xref std std-ref">decay:fig:FE1</em> demonstrates that the numerical solution for
<span class="math">\(\Delta t=0.4\)</span> clearly lies below the exact curve, but that the
accuracy improves considerably by using 1/10 of this time step.</p>
<p>Mounting two PNG files, as done in the figure, is easily done by the
<a class="reference external" href="http://www.imagemagick.org/script/montage.php">montage</a> program
from the ImageMagick suite:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; montage -background white -geometry 100% -tile 2x1 \</span>
<span class="go">          FE_0.4.png FE_0.04.png FE1.png</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">-geometry</span></tt> argument is used to specify the size of the image, and here
we preserve the individual sizes of the images. The <tt class="docutils literal"><span class="pre">-tile</span> <span class="pre">HxV</span></tt> option
specifies <tt class="docutils literal"><span class="pre">H</span></tt> images in the horizontal direction and <tt class="docutils literal"><span class="pre">V</span></tt> images in
the vertical direction. A series of image files to be combined are then listed,
with the name of the resulting combined image, here <tt class="docutils literal"><span class="pre">FE1.png</span></tt> at the end.</p>
<p>The behavior of the two other schemes are shown in Figures <em class="xref std std-ref">decay:fig:BE1</em>
and <em class="xref std std-ref">decay:fig:CN1</em>. Crank-Nicolson is obviously the most accurate
scheme from a visual point of view.</p>
</div>
<div class="section" id="plotting-with-scitools">
<h2>Plotting with SciTools<a class="headerlink" href="#plotting-with-scitools" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://code.google.com/p/scitools">SciTools package</a> provides a
plotting interface, called Easyviz (<tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt>), to many different plotting
packages, including Matplotlib. The syntax is very similar to
that of Matplotlib and MATLAB. In fact, the plotting commands
shown above look the same in SciTool&#8217;s Easyviz interface,
apart from the import statement, which reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This import also performs a <tt class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></tt> (and more) so that
array functionality becomes available as well.</p>
<p>With Easyviz one can merge several plotting commands into one,
using keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;ro&#39;</span><span class="p">,</span>             <span class="c"># red circles for u</span>
     <span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span>             <span class="c"># blue line for u_e</span>
     <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span>
     <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span>
     <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
     <span class="n">title</span><span class="o">=</span><span class="s">&#39;Method: theta-rule, theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">show</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay5.py">decay5.py</a> file
contains such a demo.</p>
<p>By default, Easyviz employs Matplotlib for plotting, but <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> and <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a> are viable alternatives:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay5.py --SCITOOLS_easyviz_backend gnuplot</span>
<span class="go">Terminal&gt; python decay5.py --SCITOOLS_easyviz_backend grace</span>
</pre></div>
</div>
<p>All the plot windows are launched with the need to kill one before
the next one pops up (as is the case with Matplotlib) and one can
press the key &#8216;q&#8217; anywhere in a plot window to kill it.
Another advantage of Gnuplot is the automatic choice of sensible
and distinguishable line types in black-and-white plot files.
This is particularly handy when making plot files in the PostScript
format (<tt class="docutils literal"><span class="pre">savefig('myplot.eps')</span></tt>).</p>
<p>The default backend for Easyviz (together with numerous
other features) can be set in a configuration file</p>
<p>Regarding functionality for annotating plots with title, labels on the
axis, legends, etc., we refer to the documentation of Matplotlib and
SciTools for more detailed information on the syntax. The hope is that
the programming syntax explained so far suffices for understanding the
code and learning more from a combination of the forthcoming examples
and other resources such as books and web pages.</p>
</div>
<div class="section" id="reading-input-from-the-command-line">
<h2>Reading input from the command line<a class="headerlink" href="#reading-input-from-the-command-line" title="Permalink to this headline">¶</a></h2>
<p>It is good programming practice to let programs read input from the user
rather than require the user to edit the source code when changing parameters.
Reading input from the command line is a simple and flexible way of interacting
with the user. Python stores all the command-line arguments in
the list <tt class="docutils literal"><span class="pre">sys.argv</span></tt>. There are, in principle, two ways of programming with
command-line arguments in Python:</p>
<blockquote>
<div><ul class="simple">
<li>Decide upon a sequence of parameters on the command line and read
their values directly from the <tt class="docutils literal"><span class="pre">sys.argv[1:]</span></tt> (<tt class="docutils literal"><span class="pre">sys.argv[0]</span></tt> is the
program name).</li>
<li>Introduce default values for parameters, use option-value pairs on
the command line to override the default values, and use the
<tt class="docutils literal"><span class="pre">argparse.ArgumentParser</span></tt> tool to interact with the command line.</li>
</ul>
</div></blockquote>
<p>Both strategies will be illustrated next.</p>
<div class="section" id="reading-a-sequence-of-command-line-arguments">
<h3>Reading a sequence of command-line arguments<a class="headerlink" href="#reading-a-sequence-of-command-line-arguments" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay4.py">decay4.py</a> program needs
the following input data:</p>
<ol class="arabic simple">
<li><span class="math">\(I\)</span></li>
<li><span class="math">\(a\)</span></li>
<li><span class="math">\(T\)</span></li>
<li>an option to turn the plot on or off (<tt class="docutils literal"><span class="pre">makeplot</span></tt>)</li>
<li>a list of <span class="math">\(\Delta t\)</span> values</li>
</ol>
<p>The simplest way of reading this input from the command line is to say
that the first four command-line arguments correspond to the first
four points in the list above, in that order, and that the rest of the
command-line arguments are the <span class="math">\(\Delta t\)</span> values.  The input given for
<tt class="docutils literal"><span class="pre">makeplot</span></tt> can be a string among <tt class="docutils literal"><span class="pre">'on'</span></tt>, <tt class="docutils literal"><span class="pre">'off'</span></tt>, <tt class="docutils literal"><span class="pre">'True'</span></tt>, and
<tt class="docutils literal"><span class="pre">'False'</span></tt>. The code for reading this input can be put in a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">read_command_line</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Usage: </span><span class="si">%s</span><span class="s"> I a T on/off dt1 dt2 dt3 ...&#39;</span> <span class="o">%</span> \
              <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>

    <span class="n">I</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">makeplot</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">,</span> <span class="s">&#39;True&#39;</span><span class="p">)</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">5</span><span class="p">:]]</span>

    <span class="k">return</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span>
</pre></div>
</div>
<p>First note that everything on the command line ends up in a string in
the list <tt class="docutils literal"><span class="pre">sys.argv</span></tt>.
Then note that the value of <tt class="docutils literal"><span class="pre">makeplot</span></tt> is determined from a boolean expression,
which becomes <tt class="docutils literal"><span class="pre">True</span></tt> if the command-line argument is either <tt class="docutils literal"><span class="pre">'on'</span></tt> or
<tt class="docutils literal"><span class="pre">'True'</span></tt>, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise. Also note how easy it is to build the
list of <span class="math">\(\Delta t\)</span> value: we simply run through
the rest of the list, <tt class="docutils literal"><span class="pre">sys.argv[5:]</span></tt>, convert each command-line argument
to <tt class="docutils literal"><span class="pre">float</span></tt>, and collect these <tt class="docutils literal"><span class="pre">float</span></tt> objects in a list, using the
compact and convenient <em>list comprehension</em> syntax in Python.</p>
<p>The loops over <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> values can be coded in a <tt class="docutils literal"><span class="pre">main</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="si">%3.1f</span><span class="s"> </span><span class="si">%6.2f</span><span class="s">: </span><span class="si">%12.3E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete program can be found in <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay6.py">decay6.py</a>.</p>
</div>
<div class="section" id="working-with-an-argument-parser">
<h3>Working with an argument parser<a class="headerlink" href="#working-with-an-argument-parser" title="Permalink to this headline">¶</a></h3>
<p>Python&#8217;s <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> tool in in the <tt class="docutils literal"><span class="pre">argparse</span></tt> module makes it
easy to create a professional command-line interface to any
program. The <cite>documentation of `ArgumentParser</cite> &lt;<a class="reference external" href="http://docs.python.org/library/argparse.html">http://docs.python.org/library/argparse.html</a>&gt;`_ demonstrates its
versatile applications, so we shall here just list an example
containing the most used features.  On the command line we want to
specify option value pairs for <span class="math">\(I\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(T\)</span>, e.g., <tt class="docutils literal"><span class="pre">--a</span> <span class="pre">3.5</span> <span class="pre">--I</span> <span class="pre">2</span>
<span class="pre">--T</span> <span class="pre">2</span></tt>. Including <tt class="docutils literal"><span class="pre">--makeplot</span></tt> turns the plot on and excluding this
option turns the plot off.  The <span class="math">\(\Delta t\)</span> values can be given as
<tt class="docutils literal"><span class="pre">--dt</span> <span class="pre">1</span> <span class="pre">0.5</span> <span class="pre">0.25</span> <span class="pre">0.1</span> <span class="pre">0.01</span></tt>.  Each parameter must have a sensible
default value so that we specify the option on the command line only
when the default value is not suitable.</p>
<p>We introduce a function for defining the mentioned command-line options:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">define_command_line_options</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="s">&#39;--initial_condition&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;initial condition, u(0)&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;I&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--a&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;coefficient in ODE&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--T&#39;</span><span class="p">,</span> <span class="s">&#39;--stop_time&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;end time of simulation&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--makeplot&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s">&#39;display plot or not&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="s">&#39;--time_step_values&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;time step values&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;dt&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;dt_values&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span>
</pre></div>
</div>
<p>Each command-line option is defined through the <tt class="docutils literal"><span class="pre">parser.add_argument</span></tt>
method. Alternative options, like the short <tt class="docutils literal"><span class="pre">--I</span></tt> and the more
explaning <tt class="docutils literal"><span class="pre">--initial_condition</span></tt> can be defined. Other arguments
are <tt class="docutils literal"><span class="pre">type</span></tt> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <tt class="docutils literal"><span class="pre">-h</span></tt> or <tt class="docutils literal"><span class="pre">--help</span></tt> is
included. The <tt class="docutils literal"><span class="pre">metavar</span></tt> argument specifies the value associated with
the option when the help string is printed. For example, the option for
<span class="math">\(I\)</span> has this help output:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay7.py -h</span>
<span class="go">  ...</span>
<span class="go">  --I I, --initial_condition I</span>
<span class="go">                        initial condition, u(0)</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>The structure of this explanation is</p>
<div class="highlight-py"><div class="highlight"><pre><span class="o">--</span><span class="n">I</span> <span class="n">metavar</span><span class="p">,</span> <span class="o">--</span><span class="n">initial_condition</span> <span class="n">metavar</span>
                      <span class="n">help</span><span class="o">-</span><span class="n">string</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">--makeplot</span></tt> option is a
pure flag without any value,
implying a true value if the flag is present and otherwise
a false value. The <tt class="docutils literal"><span class="pre">action='store_true'</span></tt> makes an option such a flag.
Finally, the <tt class="docutils literal"><span class="pre">--dt</span></tt> option demonstrates how to allow for more
than one value (separated by blanks) through the <tt class="docutils literal"><span class="pre">nargs='+'</span></tt>
keyword argument.
After the command line is parsed, we get an object
where the values of the options are stored as attributes. The attribute
name is specified by the <tt class="docutils literal"><span class="pre">dist</span></tt> keyword argument, which for the
<tt class="docutils literal"><span class="pre">--dt</span></tt> option reads <tt class="docutils literal"><span class="pre">dt_values</span></tt>. The code below demonstrates how to
read the command line and extract the values for each option:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_command_line</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">define_command_line_options</span><span class="p">()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;I={}, a={}, T={}, makeplot={}, dt_values={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">makeplot</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">dt_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">makeplot</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">dt_values</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">main</span></tt> function remains the same as in the <tt class="docutils literal"><span class="pre">decay6.py</span></tt> code based
on reading from <tt class="docutils literal"><span class="pre">sys.argv</span></tt> directly. A complete program using the
demo above of <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> appears in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay7.py">decay7.py</a>.</p>
</div>
</div>
<div class="section" id="computing-convergence-rates">
<span id="decay-convergence-rate"></span><h2>Computing convergence rates<a class="headerlink" href="#computing-convergence-rates" title="Permalink to this headline">¶</a></h2>
<p id="index-7">We normally expect that the error <span class="math">\(E\)</span> in the numerical solution is reduced
if the mesh size <span class="math">\(\Delta t\)</span>. More specifically, many numerical methods
obey a power-law relation between <span class="math">\(E\)</span> and <span class="math">\(\Delta t\)</span>, if the latter is
sufficiently small:</p>
<div class="math" id="equation-decay:E:dt">
<span class="eqno">(23)</span>\[     E = C\Delta t^r,\]</div>
<p>where <span class="math">\(C\)</span> and <span class="math">\(r\)</span> are (usually unknown) constants independent of <span class="math">\(\Delta t\)</span>.
The parameter <span class="math">\(r\)</span> is known as the <em>convergence rate</em>. For example,
if the convergence rate is 2, halving <span class="math">\(\Delta t\)</span> reduces the error by
a factor of <span class="math">\(E\)</span>. Diminishing <span class="math">\(\Delta t\)</span> then has a greater impact on
the error compared with methods that have <span class="math">\(r=1\)</span>. For a given value of <span class="math">\(r\)</span>,
we refer to the method as of <span class="math">\(r\)</span>-th order. First- and second-order
methods are most common in scientific computing.</p>
<p>There are two ways of estimating <span class="math">\(C\)</span> and <span class="math">\(r\)</span> based on a set of
<span class="math">\(m\)</span> simulations with corresponding pairs <span class="math">\((\Delta t_i, E_i)\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>,
and <span class="math">\(\Delta t_{i} &lt; \Delta t_{i-1}\)</span> (i.e., decreasing cell size).</p>
<blockquote>
<div><ol class="arabic simple">
<li>Take the logarithm of <em class="xref std std-ref">decay:E:dt</em>, <span class="math">\(\ln E = r\ln \Delta t + \ln C\)</span>,
and fit a straight line to the data points <span class="math">\((\Delta t_i, E_i)\)</span>,
<span class="math">\(i=0,\ldots,m-1\)</span>.</li>
<li>Consider two consecutive experiments, <span class="math">\((\Delta t_i, E_i)\)</span> and
<span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span>. Dividing the equation
<span class="math">\(E_{i-1}=C\Delta t_{i-1}^r\)</span> by <span class="math">\(E_{i}=C\Delta t_{i}^r\)</span> and solving
for <span class="math">\(r\)</span> yields</li>
</ol>
</div></blockquote>
<div class="math" id="equation-decay:conv:rate">
<span class="eqno">(24)</span>\[     r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}\]</div>
<p>for <span class="math">\(i=1,=ldots,m-1\)</span>.</p>
<p>The disadvantage of method 1 is that <em class="xref std std-ref">decay:E:dt</em> might not be valid
for the coarsest meshes (largest <span class="math">\(\Delta t\)</span> values), and fitting a line
to all the data points is then misleading. However, we usually have no
idea of which <span class="math">\(\Delta t\)</span> values to exclude. Method 2 computes
convergence rates for pairs of experiments and allows us to see
if the sequence <span class="math">\(r_i\)</span> converges to some value as <span class="math">\(i\rightarrow m-1\)</span>.
The final <span class="math">\(r_{m-1}\)</span> can then be taken as the convergence rate.
If the coarsest meshes have a differing rate, the corresponding
time steps are probably too large for <em class="xref std std-ref">decay:E:dt</em> to be valid.
(We say that the those time steps are not in the asymptotic range.)</p>
<p>It is straightforward to extend the <tt class="docutils literal"><span class="pre">main</span></tt> function in the program
<tt class="docutils literal"><span class="pre">decay7.py</span></tt> with statements for computing <span class="math">\(r_0, r_1, \ldots, r_{m-2}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

        <span class="c"># Compute convergence rates</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_values</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
                    <span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Pairwise convergence rates for theta=</span><span class="si">%g</span><span class="s">:&#39;</span> <span class="o">%</span> <span class="n">theta</span>
        <span class="k">print</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_</span> <span class="k">for</span> <span class="n">r_</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>The program is called <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay8.py">decay8.py</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">r</span></tt> object is a <em>dictionary of lists</em>. The keys in this
dictionary are the <span class="math">\(\theta\)</span> values. For example,
<tt class="docutils literal"><span class="pre">r[1]</span></tt> holds the a list of the <span class="math">\(r_i\)</span> values corresponding to
<span class="math">\(\theta=1\)</span>. In the loop <tt class="docutils literal"><span class="pre">for</span> <span class="pre">theta</span> <span class="pre">in</span> <span class="pre">r</span></tt>, the loop variable <tt class="docutils literal"><span class="pre">theta</span></tt>
takes on the values of the keys in the dictionary <tt class="docutils literal"><span class="pre">r</span></tt> (in an
undetermined ordering). We could simply do a <tt class="docutils literal"><span class="pre">print</span> <span class="pre">r[theta]</span></tt>
inside the loop, but this would typically yield output of
the convergence rates with 16 decimals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mf">1.331919482274763</span><span class="p">,</span> <span class="mf">1.1488178494691532</span><span class="p">,</span> <span class="mf">1.0657737105411782</span><span class="p">,</span>  <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Instead, we format each number with 2 decimals, using a list
comprehension to turn the list of numbers, <tt class="docutils literal"><span class="pre">r[method]</span></tt>, into
a list of formatted strings. Then we join these strings
with a space in between to get a sequence of rates on one line
in the terminal window. In general, <tt class="docutils literal"><span class="pre">d.join(list)</span></tt> joins the
strings in the list <tt class="docutils literal"><span class="pre">list</span></tt> to one string, with <tt class="docutils literal"><span class="pre">d</span></tt>
as delimiter between <tt class="docutils literal"><span class="pre">list[0]</span></tt>, <tt class="docutils literal"><span class="pre">list[1]</span></tt>, etc.</p>
<p>Here is an example on the outcome of the convergence rate computations:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay8.py --dt 0.5 0.25 0.1 0.05 0.025 0.01</span>
<span class="go">...</span>
<span class="go">Pairwise convergence rates for theta=0:</span>
<span class="go">1.33 1.15 1.07 1.03 1.02</span>

<span class="go">Pairwise convergence rates for theta=0.5:</span>
<span class="go">2.14 2.07 2.03 2.01 2.01</span>

<span class="go">Pairwise convergence rates for theta=1:</span>
<span class="go">0.98 0.99 0.99 1.00 1.00</span>
</pre></div>
</div>
<p>The Forward and Backward Euler methods seem to have an <span class="math">\(r\)</span> value which
stabilizes at 1, while the Crank-Nicolson seems to be a second-order
method with <span class="math">\(r=2\)</span>.</p>
<p id="index-8">Very often, we have some theory that predicts what <span class="math">\(r\)</span> is for a numerica
method. It can be shown that in case of the <span class="math">\(\theta\)</span>-rule, <span class="math">\(r=2\)</span> for
<span class="math">\(\theta =0.5\)</span> and <span class="math">\(r=1\)</span> otherwise. The computed estimates of <span class="math">\(r\)</span> are
in very good agreement with these theoretical values. The strong
practical application of computing convergence rates is for
verification: wrong convergence rates point to errors in the code,
and correct convergence rates brings evidence that the implementation
is correct. Experience shows bugs in the code easily destroys the
expected convergence rate.</p>
<p>Let us experiment with bugs and see the implication on the convergence
rate. We may, for instance, forget to multiply by <tt class="docutils literal"><span class="pre">a</span></tt> in the denominator
in the updating formula for <tt class="docutils literal"><span class="pre">u[n+1]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>Running the same <tt class="docutils literal"><span class="pre">decay8.py</span></tt> command as above gives the expected
convergence rates (!). Why? The reason is that we just specified
the <span class="math">\(\Delta t\)</span> values are relied on default values for other
parameters. The default value of <span class="math">\(a\)</span> is 1. Forgetting the factor
<tt class="docutils literal"><span class="pre">a</span></tt> has then no effect. This example shows how importance it is to
avoid parameters that are 1 or 0 when verifying implementations.
Running the code with <span class="math">\(a=2.1\)</span> and <span class="math">\(I=0.1\)</span> yields</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay8.py --a 2.1 --I 0.1  \</span>
<span class="go">          --dt 0.5 0.25 0.1 0.05 0.025 0.01</span>
<span class="go">...</span>
<span class="go">Pairwise convergence rates for theta=0:</span>
<span class="go">1.49 1.18 1.07 1.04 1.02</span>

<span class="go">Pairwise convergence rates for theta=0.5:</span>
<span class="go">-1.42 -0.22 -0.07 -0.03 -0.01</span>

<span class="go">Pairwise convergence rates for theta=1:</span>
<span class="go">0.21 0.12 0.06 0.03 0.01</span>
</pre></div>
</div>
<p>This time we see that the expected convergence rates for the Crank-Nicolson and
Backward Euler methods are not obtained, while <span class="math">\(r=1\)</span> for the Forward Euler
method. The reason for correct rate in the latter case is that <span class="math">\(\theta=0\)</span>
and the wrong <tt class="docutils literal"><span class="pre">theta*dt</span></tt> term in the denominator vanishes anyway.</p>
<p>The error</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>manifests itself through wrong rates <span class="math">\(r\approx 0\)</span> for all three methods.
About the same results arise from an erroneous initial condition, <tt class="docutils literal"><span class="pre">u[0]</span> <span class="pre">=</span> <span class="pre">1</span></tt>,
or wrong loop limits, <tt class="docutils literal"><span class="pre">range(1,N)</span></tt>. It seems that in this simple
problem, most bugs we can think of are detected by the convergence rate
test.</p>
<p>A <tt class="docutils literal"><span class="pre">verify_convergence_rate</span></tt> function could compute the dictionary of
list via <tt class="docutils literal"><span class="pre">main</span></tt> and check if the final rate estimates (<span class="math">\(r_{m-2}\)</span>)
are sufficiently close to the expected ones. A tolerance of 0.1
seems appropriate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_convergence_rate</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">main</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">expected_rates</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">r_final</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected_rates</span><span class="p">[</span><span class="n">theta</span><span class="p">]</span> <span class="o">-</span> <span class="n">r_final</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>  <span class="c"># all tests passed</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">r[theta]</span></tt> is a list and the last element in any list
can be extracted by the index <tt class="docutils literal"><span class="pre">-1</span></tt>.</p>
</div>
<div class="section" id="memory-saving-implementation">
<h2>Memory-saving implementation<a class="headerlink" href="#memory-saving-implementation" title="Permalink to this headline">¶</a></h2>
<p>The memory storage requirements of our implementations so far consists
mainly of the <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> arrays, both of length <span class="math">\(N+1\)</span>, plus some other
temporary arrays that Python needs for intermediate results if we do
array arithmetics in our program (e.g., <tt class="docutils literal"><span class="pre">I*exp(-a*t)</span></tt> needs to store
<tt class="docutils literal"><span class="pre">a*t</span></tt> before <tt class="docutils literal"><span class="pre">-</span></tt> can be applied to it and then <tt class="docutils literal"><span class="pre">exp</span></tt>).  The
extremely modest storage requirements of simple ODE problems put no
restrictions on the formulations of the algorithm and implementation.
Nevertheless, when the methods for ODEs used here are applied to
three-dimensional partial differential equation (PDE) problems,
memory storage requirements
suddenly become an issue.</p>
<p>The PDE counterpart to our model problem
<span class="math">\(u'=-a\)</span> is a diffusion equation <span class="math">\(u_t = a\nabla^2 u\)</span> posed on a
space-time domain. The discrete representation of this domain may in
3D be a spatial mesh of <span class="math">\(M^3\)</span> points and a time mesh of <span class="math">\(N\)</span> points. A
typical desired value for <span class="math">\(M\)</span> is 100 in many applications, and be may
<span class="math">\(1000\)</span>.  Storing all the computed <span class="math">\(u\)</span> values, like we have done in the
programs so far, demands storage of some arrays of size <span class="math">\(M^3N\)</span>, giving
a factor of <span class="math">\(M^3\)</span> larger storage demands compared to our ODE
programs. Each real number in the array for <span class="math">\(u\)</span> requires 8 bytes of
storage, resulting in a demand for 8 Gb of memory for only one array.
Then there are needs for good ideas on how to lower the storage
requirements. Fortunately, we can almost always get rid of the <span class="math">\(M^3\)</span>
factor. Below we explain how this is done, and the technique is almost
always applied in implementations of PDE problems.</p>
<p>Let us critically evaluate how much we really need to store in the
computer&#8217;s memory in our implementation of the <span class="math">\(\theta\)</span> method. To
compute a new <span class="math">\(u^{n+1}\)</span>, all we need is <span class="math">\(u^n\)</span>. This imples that the
previous <span class="math">\(u^{n-1},u^{n-2},\dots,u^0\)</span> values do not need to be stored
in an array, although this is convenient for plotting and data
analysis in the program.  Instead of the <tt class="docutils literal"><span class="pre">u</span></tt> array we can work with
two variables from real real numbers, <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">u_1</span></tt>, representing
<span class="math">\(u^{n+1}\)</span> and <span class="math">\(u^n\)</span> in the algorithm, respectively.  At each time
level, we update <tt class="docutils literal"><span class="pre">u</span></tt> from <tt class="docutils literal"><span class="pre">u_1</span></tt> and then set <tt class="docutils literal"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">u</span></tt> so that the
computed <span class="math">\(u^{n+1}\)</span> value becomes the &#8220;previous&#8221; value <span class="math">\(u^n\)</span> at the
next time level. The downside is that we cannot plot the solution
after simulation is done since only the last two numbers are
available.  The remedy is to store computed values in a file and use
the file for visualizing the solution later.</p>
<p>We have implemented this memory saving idea in the file <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay9.py">decay9.py</a>, which is a
merge of the <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay4.py">decay4.py</a> and
<a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay7.py">decay7.py</a>
programs, using module prefixes <tt class="docutils literal"><span class="pre">np</span></tt> for <tt class="docutils literal"><span class="pre">numpy</span></tt> and <tt class="docutils literal"><span class="pre">plt</span></tt> for
<tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt>.</p>
<p>The following function implements
the algorithm without using arrays and stores the solution
in a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">theta_rule_minmem</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span class="sd">    Minimum use of memory. The solution is store on file</span>
<span class="sd">    (with name filename) for later plotting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>        <span class="c"># avoid integer division</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>  <span class="c"># no of intervals</span>

    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="c"># u: time level n+1, u_1: time level n</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.16E</span><span class="s">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u_1</span>
        <span class="n">u_1</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.16E</span><span class="s">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>This code snippet serves as a quick introduction on how to perform
file writing in Python.</p>
<p>Reading the data in the file into arrays <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> are done by the
function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[];</span>  <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Found more than two numbers on a line!&#39;</span><span class="p">,</span> <span class="n">words</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>Such a file with numbers in rows and columns is very common, and <tt class="docutils literal"><span class="pre">numpy</span></tt>
has a function <tt class="docutils literal"><span class="pre">loadtxt</span></tt> which loads the data into a two-dimensional
array, say <tt class="docutils literal"><span class="pre">data</span></tt>. The number in row <tt class="docutils literal"><span class="pre">i</span></tt> and column <tt class="docutils literal"><span class="pre">j</span></tt> is then <tt class="docutils literal"><span class="pre">data[i,j]</span></tt>.
The whole column number <tt class="docutils literal"><span class="pre">j</span></tt> can be extracted by <tt class="docutils literal"><span class="pre">data[:,j]</span></tt>.
A version of <tt class="docutils literal"><span class="pre">read_file</span></tt> using <tt class="docutils literal"><span class="pre">np.loadtxt</span></tt> reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file_numpy</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
<p>The present counterpart to the <tt class="docutils literal"><span class="pre">explore</span></tt> function from
<a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay4.py">decay4.py</a> must run
<tt class="docutils literal"><span class="pre">theta_rule_minmem</span></tt> and then load data from file before we can compute
the error measure and make the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;u.dat&#39;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">theta_rule_minmem</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">t</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://github.com/hplgit/INF5620/blob/master/src/decay/decay9.py">decay9.py</a> also includes
command-line options <tt class="docutils literal"><span class="pre">--I</span></tt>, <tt class="docutils literal"><span class="pre">--a</span></tt>, <tt class="docutils literal"><span class="pre">--T</span></tt>, <tt class="docutils literal"><span class="pre">--dt</span></tt>, <tt class="docutils literal"><span class="pre">--theta</span></tt>, and
<tt class="docutils literal"><span class="pre">--makeplot</span></tt> for controlling input parameters and <em>making a single run</em>.
For example,</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay9.py --T 10 --theta 1 --dt 2</span>
<span class="go">I=1.0, a=1.0, T=10.0, makeplot=True, theta=1.0, dt=2.0</span>
<span class="go">theta=1.0 dt=2 Error=3.136E-01</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Discretizing first-order ODEs by finite difference methods</a></li>
<li><a class="reference internal" href="#finite-difference-methods-for-an-ode">Finite difference methods for an ODE</a><ul>
<li><a class="reference internal" href="#a-decay-problem">A decay problem</a></li>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#the-unifying-rule">The unifying <span class="math">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#constant-time-step">Constant time step</a></li>
<li><a class="reference internal" href="#operator-notation-for-finite-differences">Operator notation for finite differences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a><ul>
<li><a class="reference internal" href="#making-a-program">Making a program</a><ul>
<li><a class="reference internal" href="#function-for-computing-the-numerical-solution">Function for computing the numerical solution</a></li>
<li><a class="reference internal" href="#integer-division">Integer division</a></li>
<li><a class="reference internal" href="#doc-strings">Doc strings</a></li>
<li><a class="reference internal" href="#formatting-of-numbers">Formatting of numbers</a></li>
<li><a class="reference internal" href="#running-the-program">Running the program</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verifying-the-implementation">Verifying the implementation</a><ul>
<li><a class="reference internal" href="#running-a-few-algorithmic-steps-by-hand">Running a few algorithmic steps by hand</a></li>
<li><a class="reference internal" href="#finding-an-exact-discrete-solution">Finding an exact discrete solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-the-numerical-error">Computing the numerical error</a></li>
<li><a class="reference internal" href="#plotting-solutions">Plotting solutions</a></li>
<li><a class="reference internal" href="#plotting-with-scitools">Plotting with SciTools</a></li>
<li><a class="reference internal" href="#reading-input-from-the-command-line">Reading input from the command line</a><ul>
<li><a class="reference internal" href="#reading-a-sequence-of-command-line-arguments">Reading a sequence of command-line arguments</a></li>
<li><a class="reference internal" href="#working-with-an-argument-parser">Working with an argument parser</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-convergence-rates">Computing convergence rates</a></li>
<li><a class="reference internal" href="#memory-saving-implementation">Memory-saving implementation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Preliminary notes for INF5620</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Preliminary notes for INF5620"
             >previous</a> |</li>
        <li><a href="index.html">Preliminary notes for INF5620 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Hans Petter Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>