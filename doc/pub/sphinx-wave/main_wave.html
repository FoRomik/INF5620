

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite difference methods for wave motion</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Finite difference methods for wave motion" href="index.html" /> 
  
   <style type=text/css>
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">Finite difference methods for wave motion</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="finite-difference-methods-for-wave-motion">
<h1>Finite difference methods for wave motion<a class="headerlink" href="#finite-difference-methods-for-wave-motion" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Sep 18, 2013</td>
</tr>
</tbody>
</table>
<p>This is still a <strong>preliminary version</strong> (expect typos).
Updated from H12 until the section <em class="xref std std-ref">wave:pde1:analysis</em>.</p>
<p>A very wide range of physical processes lead to wave motion, where
signals are propagated through a medium in space and time, normally
with little or no permanent movement of the medium itself.
The shape of the signals may undergo changes as they travel through
matter, but usually not so much that the signals cannot be recognized
at some later point in space and time.
Many types of wave motion can be described by the <em>wave equation</em>
<span class="math">\(u_{tt}=\nabla\cdot (c^2\nabla u) + f\)</span>, which we will solve
in the forthcoming text by finite difference methods.</p>
</div>
<div class="section" id="finite-difference-methods-for-waves-on-a-string">
<span id="wave-string"></span><h1>Finite difference methods for waves on a string<a class="headerlink" href="#finite-difference-methods-for-waves-on-a-string" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">We begin our study of wave equations by simulating one-dimensional
waves on a string, say on a guitar or violin string.
Let the string in the deformed state
coincide with the interval
<span class="math">\([0,L]\)</span> on the <span class="math">\(x\)</span> axis, and let <span class="math">\(u(x,t)\)</span> be the displacement at
time <span class="math">\(t\)</span> in the <span class="math">\(y\)</span> direction of a point initially at <span class="math">\(x\)</span>.
The displacement function <span class="math">\(u\)</span> is governed by the mathematical model</p>
<div class="math" id="equation-wave:pde1">
<span class="eqno">(1)</span>\[     \frac{\partial^2 u}{\partial t^2} =
     c^2 \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="equation-wave:pde1:ic:u">
<span class="eqno">(2)</span>\[     u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="equation-wave:pde1:ic:ut">
<span class="eqno">(3)</span>\[     \frac{\partial}{\partial t}u(x,0) = 0, \quad x\in [0,L]\]</div>
<div class="math" id="equation-wave:pde1:bc:0">
<span class="eqno">(4)</span>\[     u(0,t)  = 0, \quad  t\in (0,T],\]</div>
<div class="math" id="equation-wave:pde1:bc:L">
<span class="eqno">(5)</span>\[     u(L,t)  = 0, \quad  t\in (0,T]
     \thinspace .\]</div>
<p>The constant <span class="math">\(c\)</span> and the function <span class="math">\(I(x)\)</span> must be prescribed.</p>
<p>Equation <a href="#equation-wave:pde1">(1)</a> is known as the one-dimensional
<em>wave equation</em>. Since this PDE contains a second-order derivative
in time, we need <em>two initial conditions</em>, here <a href="#equation-wave:pde1:ic:u">(2)</a>
specifying the initial shape of the string, <span class="math">\(I(x)\)</span>, and
<a href="#equation-wave:pde1:ic:ut">(3)</a> reflecting that the initial velocity of the
string is zero. In addition, PDEs need <em>boundary conditions</em>, here
<a href="#equation-wave:pde1:bc:0">(4)</a> and <a href="#equation-wave:pde1:bc:L">(5)</a>, specifying that
the string is fixed at the ends, i.e., that the displacement <span class="math">\(u\)</span> is zero
at the ends.</p>
<p>Sometimes we will use a more compact notation for the partial derivatives
to save space:</p>
<div class="math">
\[u_t = \frac{\partial u}{\partial t}, u_{tt} = \frac{\partial^2 u}{\partial t^2},\]</div>
<p>and similar for derivatives with respect to other variables. Then the
wave equation can be written compactly as <span class="math">\(u_{tt} = c^2u_{xx}\)</span>.</p>
<p id="index-2">The PDE problem <a href="#equation-wave:pde1">(1)</a>-<a href="#equation-wave:pde1:bc:L">(5)</a> will now be
discretized in space and time by a finite difference method.</p>
<div class="section" id="discretizing-the-domain">
<span id="wave-string-mesh"></span><span id="index-3"></span><h2>Discretizing the domain<a class="headerlink" href="#discretizing-the-domain" title="Permalink to this headline">¶</a></h2>
<p>The temporal domain <span class="math">\([0,T]\)</span> is represented by a finite number of mesh points</p>
<div class="math">
\[\begin{split}0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T \thinspace .\end{split}\]</div>
<p>Similarly, the spatial domain <span class="math">\([0,L]\)</span> is replaced by a set of mesh points</p>
<div class="math">
\[\begin{split}0 = x_0 &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_{N_x-1} &lt; x_{N_x} = L \thinspace .\end{split}\]</div>
<p>One may view the mesh as two-dimensional in the <span class="math">\(x,t\)</span> plane, consisting
of points <span class="math">\((x_i, t_n)\)</span>, with <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.</p>
<div class="section" id="uniform-meshes">
<h3>Uniform meshes<a class="headerlink" href="#uniform-meshes" title="Permalink to this headline">¶</a></h3>
<p>For uniformly distributed mesh points we can introduce the constant
mesh spacings <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>. We have that</p>
<div class="math">
\[x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
t_i = n\Delta t,\ n=0,\ldots,N_t{\thinspace .}\]</div>
<p>We also have that <span class="math">\(\Delta x = x_i-x_{i-1}\)</span>, <span class="math">\(i=1,\ldots,N_x\)</span>, and
<span class="math">\(\Delta t = t_n - t_{n-1}\)</span>, <span class="math">\(n=1,\ldots,N_t\)</span>. Figure <a class="reference internal" href="#wave-pde1-fig-mesh"><em>Mesh in space and time for a 1D wave equation</em></a>
displays a mesh in the <span class="math">\(x,t\)</span> plane with <span class="math">\(N_t=5\)</span>, <span class="math">\(N_x=5\)</span>, and constant
mesh spacings.</p>
</div>
</div>
<div class="section" id="the-discrete-solution">
<span id="wave-string-numerical-sol"></span><h2>The discrete solution<a class="headerlink" href="#the-discrete-solution" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><p id="index-5">The solution <span class="math">\(u(x,t)\)</span> is sought at the mesh points. We introduce
the mesh function <span class="math">\(u_i^n\)</span>, which approximates the exact
solution at the
mesh point <span class="math">\((x_i,t_n)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.
Using the finite difference method, we shall
develop algebraic equations for computing the mesh function.
The circles in Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><em>Mesh in space and time for a 1D wave equation</em></a> illustrate neighboring mesh points where
values of <span class="math">\(u^n_i\)</span> are connected through an algebraic equation. In this
particular case, <span class="math">\(u_2^1\)</span>, <span class="math">\(u_1^2\)</span>, <span class="math">\(u_2^2\)</span>, <span class="math">\(u_3^2\)</span>, and <span class="math">\(u_2^3\)</span> are
connected in an algebraic equation associated with the center point
<span class="math">\((2,2)\)</span>. The term <em>stencil</em> is often used about the algebraic equation
at a mesh point, and the geometry of a typical stencil is
illustrated in Figure <a class="reference internal" href="#wave-pde1-fig-mesh"><em>Mesh in space and time for a 1D wave equation</em></a>. One also often refers
to the algebraic equations as <em>discrete equations</em>,
<em>(finite) difference equations</em> or a <em>finite difference
scheme</em>.</p>
<div class="figure" id="wave-pde1-fig-mesh">
<img alt="_images/wave_PDE_Dirichlet_n_interior1.png" src="_images/wave_PDE_Dirichlet_n_interior1.png" style="width: 500px;" />
<p class="caption"><em>Mesh in space and time for a 1D wave equation</em></p>
</div>
</div>
<div class="section" id="fulfilling-the-equation-at-the-mesh-points">
<span id="wave-string-samplingpde"></span><h2>Fulfilling the equation at the mesh points<a class="headerlink" href="#fulfilling-the-equation-at-the-mesh-points" title="Permalink to this headline">¶</a></h2>
<p>For a numerical solution by the finite difference method, we relax
the condition that <a href="#equation-wave:pde1">(1)</a> holds at all points in
the space-time domain <span class="math">\((0,L)\times (0,T]\)</span> to the requirement that the PDE is
fulfilled at the <em>interior</em> mesh points:</p>
<div class="math" id="equation-wave:pde1:step2">
<span class="eqno">(6)</span>\[     \frac{\partial^2}{\partial t^2} u(x_i, t_n) =
     c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span> and <span class="math">\(n=1,\ldots,N_t-1\)</span>. For <span class="math">\(n=0\)</span> we have
the initial conditions <span class="math">\(u=I(x)\)</span> and <span class="math">\(u_t=0\)</span>,
and at the boundaries <span class="math">\(i=0,N_x\)</span> we
have the boundary condition <span class="math">\(u=0\)</span>.</p>
</div>
<div class="section" id="replacing-derivatives-by-finite-differences">
<span id="wave-string-fd"></span><h2>Replacing derivatives by finite differences<a class="headerlink" href="#replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h2>
<p>The second-order derivatives can be replaced by central
differences. The most widely used difference approximation of
the second-order derivative is</p>
<div class="math">
\[\frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}\]</div>
<p>It is convenient to introduce the finite difference operator notation</p>
<div class="math">
\[[D_tD_t u]^n_i = \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}
A similar approximation of the second-order derivative in the $x$
direction reads
!bt
 \frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
\thinspace .\]</div>
<div class="section" id="algebraic-version-of-the-pde">
<h3>Algebraic version of the PDE<a class="headerlink" href="#algebraic-version-of-the-pde" title="Permalink to this headline">¶</a></h3>
<p>We can now replace the derivatives in <a href="#equation-wave:pde1:step2">(6)</a>
and get</p>
<div class="math" id="equation-wave:pde1:step3b">
<span class="eqno">(7)</span>\[     \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
     c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},\]</div>
<p>or written more compactly using the operator notation:</p>
<div class="math" id="equation-wave:pde1:step3a">
<span class="eqno">(8)</span>\[     [D_tD_t u = c^2 D_xD_x]^{n}_i
     \thinspace .\]</div>
</div>
<div class="section" id="algebraic-version-of-the-initial-conditions">
<h3>Algebraic version of the initial conditions<a class="headerlink" href="#algebraic-version-of-the-initial-conditions" title="Permalink to this headline">¶</a></h3>
<p>We also need to replace the derivative in the initial condition
<a href="#equation-wave:pde1:ic:ut">(3)</a> by a finite difference approximation.
A centered difference of the type</p>
<div class="math">
\[\frac{\partial}{\partial t} u(x_i,t_n)\approx
\frac{u^1_i - u^{-1}_i}{2\Delta t} = [D_{2t} u]^0_i,\]</div>
<p>seems appropriate. In operator notation the initial condition is
written as</p>
<div class="math">
\[[D_{2t} u]^n_i = 0,\quad n=0 \thinspace .\]</div>
<p>Writing out this equation and ordering the terms give</p>
<div class="math" id="equation-wave:pde1:step3c">
<span class="eqno">(9)</span>\[     u^{n-1}_i=u^{n+1}_i,\quad i=0,\ldots,N_x,\ n=0\thinspace .\]</div>
<p>The other initial condition can be computed by</p>
<div class="math">
\[u_i^0 = I(x_i),\quad i=0,\ldots,N_x{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="formulating-a-recursive-algorithm">
<span id="wave-string-alg"></span><h2>Formulating a recursive algorithm<a class="headerlink" href="#formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h2>
<p>We assume that <span class="math">\(u^n_i\)</span> and
<span class="math">\(u^{n-1}_i\)</span> are already computed for <span class="math">\(i=0,\ldots,N_x\)</span>.
The only unknown quantity in <a href="#equation-wave:pde1:step3b">(7)</a> is
therefore <span class="math">\(u^{n+1}_i\)</span>, which we can solve for:</p>
<div class="math" id="equation-wave:pde1:step4">
<span class="eqno">(10)</span>\[     u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
     \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),\]</div>
<p>where we have introduced the parameter</p>
<div class="math">
\[C = c\frac{\Delta t}{\Delta x},\]</div>
<p>known as the (dimensionless) <em>Courant number</em>. We see that the
discrete version of the PDE features only one parameter, <span class="math">\(C\)</span>,
which is therefore the key parameter that governs the
quality of the numerical solution. Both the primary
physical parameter <span class="math">\(c\)</span> and the numerical parameters <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>
are lumped together in <span class="math">\(C\)</span>.</p>
<p>Given that <span class="math">\(u^{n-1}_i\)</span> and <span class="math">\(u^n_i\)</span> are computed for <span class="math">\(i=0,\ldots,N_x\)</span>,
we find new values at the next time level by applying the formula
<a href="#equation-wave:pde1:step4">(10)</a> for <span class="math">\(i=1,\ldots,N_x-1\)</span>. Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><em>Mesh in space and time for a 1D wave equation</em></a> illustrates the points that are used to
compute <span class="math">\(u^3_2\)</span>. For the boundary points, <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, we apply
the boundary conditions <span class="math">\(u_i^{n+1}=0\)</span>.</p>
<p>A problem with <a href="#equation-wave:pde1:step4">(10)</a> arises when <span class="math">\(n=0\)</span> since the
formula for <span class="math">\(u^1_i\)</span> involves <span class="math">\(u^{-1}_i\)</span>, which is an undefined
quantity outside the time mesh (and the time domain). However, we can
use the initial condition <a href="#equation-wave:pde1:step3c">(9)</a> in combination with
<a href="#equation-wave:pde1:step4">(10)</a> when <span class="math">\(n=0\)</span> to arrive at a special formula for
<span class="math">\(u_i^1\)</span>:</p>
<div class="math" id="equation-wave:pde1:step4:1">
<span class="eqno">(11)</span>\[     u_i^1 = u^0_i - \frac{1}{2}
     C^2\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right)
     \thinspace .\]</div>
<p>Figure <a class="reference internal" href="#wave-pde1-fig-stencil-u1"><em>Modified stencil for the first time step</em></a> illustrates how <a href="#equation-wave:pde1:step4:1">(11)</a>
connects four instead of five points: <span class="math">\(u^1_2\)</span>, <span class="math">\(u_1^0\)</span>, <span class="math">\(u_2^0\)</span>, and <span class="math">\(u_3^0\)</span>.</p>
<div class="figure" id="wave-pde1-fig-stencil-u1">
<img alt="_images/wave_PDE_Dirichlet_n0_interior1.png" src="_images/wave_PDE_Dirichlet_n0_interior1.png" style="width: 500px;" />
<p class="caption"><em>Modified stencil for the first time step</em></p>
</div>
<p>We can now summarize the computational algorithm:</p>
<ol class="arabic simple">
<li>Compute <span class="math">\(u^0_i=I(x_i)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span></li>
<li>Compute <span class="math">\(u^1_i\)</span> by <a href="#equation-wave:pde1:step4:1">(11)</a> and set <span class="math">\(u_i^1=0\)</span>
for the boundary points <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, for <span class="math">\(n=1,2,\ldots,N-1\)</span>,</li>
<li>For each time level <span class="math">\(n=1,2,\ldots,N_t-1\)</span></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>apply <a href="#equation-wave:pde1:step4">(10)</a> to find <span class="math">\(u^{n+1}_i\)</span> for <span class="math">\(i=1,\ldots,N_x-1\)</span></li>
<li>set <span class="math">\(u^{n+1}_i=0\)</span> for the boundary points <span class="math">\(i=0\)</span>, <span class="math">\(i=N_x\)</span>.</li>
</ol>
</div></blockquote>
<p>The algorithm essentially consists of moving
a finite difference stencil through all the mesh points, which is
illustrated by an animation in a <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.flv">movie file</a>.</p>
</div>
<div class="section" id="sketch-of-an-implementation">
<span id="wave-string-impl"></span><h2>Sketch of an implementation<a class="headerlink" href="#sketch-of-an-implementation" title="Permalink to this headline">¶</a></h2>
<p>In a Python implementation of this algorithm, we use the array
elements <tt class="docutils literal"><span class="pre">u[i]</span></tt> to store <span class="math">\(u^{n+1}_i\)</span>, <tt class="docutils literal"><span class="pre">u_1[i]</span></tt> to store <span class="math">\(u^n_i\)</span>, and
<tt class="docutils literal"><span class="pre">u_2[i]</span></tt> to store <span class="math">\(u^{n-1}_i\)</span>. Our naming convention is use <tt class="docutils literal"><span class="pre">u</span></tt> for the
unknown new spatial field to be computed, <tt class="docutils literal"><span class="pre">u_1</span></tt> as the solution at
one time step back in time, <tt class="docutils literal"><span class="pre">u_2</span></tt> as the solution two time steps back
in time and so forth.</p>
<p>The algorithm only needs to access the
three most recent time levels, so we need only three arrays for
<span class="math">\(u_i^{n+1}\)</span>, <span class="math">\(u_i^n\)</span>, and <span class="math">\(u_i^{n-1}\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>.  Storing all
the solutions in a two-dimensional array of size <span class="math">\((N_x+1)\times (N_t+1)\)</span>
would be possible in this simple one-dimensional PDE problem, but is
normally out of the question in three-dimensional (3D) and large
two-dimensional (2D) problems. We shall therefore in all our programs
for solving PDEs have the unknown in memory at as few time levels as
possible.</p>
<p>The following Python snippet realizes the steps in the computational
algorithm.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Given mesh points as arrays x and t (x[i], t[n])</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span>            <span class="c"># Courant number</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>              <span class="c"># Help variable in the scheme</span>

<span class="c"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c"># Apply special formula for first step, incorporating du/dt=0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># Enforce boundary conditions</span>

<span class="c"># Switch variables before next step</span>
<span class="n">u_2</span><span class="p">[:],</span> <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="c"># Update all inner mesh points at time t[n+1]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
               <span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c"># Insert boundary conditions</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># Switch variables before next step</span>
    <span class="n">u_2</span><span class="p">[:],</span> <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-1">
<h1>Verification  (1)<a class="headerlink" href="#verification-1" title="Permalink to this headline">¶</a></h1>
<p>Before implementing the algorithm, it is convenient to add a source
term to the PDE <a href="#equation-wave:pde1">(1)</a>
since it gives us more freedom in finding test problems for
verification. In particular, the source term allows us to use
<em>manufactured solutions</em> for software testing, where we simply choose some
function as solution, fit the corresponding source term, and define
boundary and initial conditions consistent with the chosen
solution. Such solutions
will seldom fulfill the initial condition <a href="#equation-wave:pde1:ic:ut">(3)</a> so
we need to generalize this condition to <span class="math">\(u_t=V(x)\)</span>.</p>
<div class="section" id="a-slightly-generalized-model-problem">
<span id="wave-pde2-fd"></span><h2>A slightly generalized model problem<a class="headerlink" href="#a-slightly-generalized-model-problem" title="Permalink to this headline">¶</a></h2>
<p>We now address the following extended initial-boundary value problem
for one-dimensional wave phenomena:</p>
<div class="math" id="equation-wave:pde2">
<span class="eqno">(12)</span>\[     u_{tt} = c^2 u_{xx} + f(x,t), \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="equation-wave:pde2:ic:u">
<span class="eqno">(13)</span>\[     u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="equation-wave:pde2:ic:ut">
<span class="eqno">(14)</span>\[     u_t(x,0) = V(x), \quad x\in [0,L]\]</div>
<div class="math" id="equation-wave:pde2:bc:0">
<span class="eqno">(15)</span>\[\begin{split}     u(0,t)  = 0, \quad  t&gt;0,\end{split}\]</div>
<div class="math" id="equation-wave:pde2:bc:L">
<span class="eqno">(16)</span>\[\begin{split}     u(L,t)  = 0, \quad  t&gt;0
     \thinspace .\end{split}\]</div>
<p>Sampling the PDE at <span class="math">\((x_i,t_n)\)</span> and using the same finite difference
approximations as above, yields</p>
<div class="math" id="equation-wave:pde2:fdop">
<span class="eqno">(17)</span>\[     [D_tD_t u = c^2 D_xD_x + f]^{n}_i
     \thinspace .\]</div>
<p>Writing this out and solving for the unknown <span class="math">\(u^{n+1}_i\)</span> results in</p>
<div class="math" id="equation-wave:pde2:step3b">
<span class="eqno">(18)</span>\[     u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
     (u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i\]\[     \thinspace .\]</div>
<p>The equation for the first time step must be rederived. The discretization
of the initial condition <span class="math">\(u_t = V(x)\)</span> at <span class="math">\(t=0\)</span>
becomes</p>
<div class="math">
\[[D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,\]</div>
<p>which, when inserted in <a href="#equation-wave:pde2:step3b">(18)</a> for <span class="math">\(n=0\)</span>, gives
the special formula</p>
<div class="math" id="equation-wave:pde2:step3c">
<span class="eqno">(19)</span>\[     u^{1}_i = u^0_i - \Delta t V_i + \frac{1}{2}
     C^2
     \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \frac{1}{2}\Delta t^2 f^n_i\]\[     \thinspace .\]</div>
</div>
<div class="section" id="using-an-analytical-solution-of-physical-significance">
<h2>Using an analytical solution of physical significance<a class="headerlink" href="#using-an-analytical-solution-of-physical-significance" title="Permalink to this headline">¶</a></h2>
<p>Many wave problems feature sinusoidal oscillations in time
and space. For example, the original PDE problem
<a href="#equation-wave:pde1">(1)</a>-<a href="#equation-wave:pde1:bc:L">(5)</a> allows a solution</p>
<div class="math" id="equation-wave:pde2:test:ue">
<span class="eqno">(20)</span>\[     {u_{\small\mbox{e}}}(x,y,t)) = A\sin\left(\frac{\pi}{L}x\right)
     \cos\left(\frac{\pi}{L}ct\right){\thinspace .}\]</div>
<p>This <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfills the PDE with <span class="math">\(f=0\)</span>, boundary conditions
<span class="math">\({u_{\small\mbox{e}}}(0,t)={u_{\small\mbox{e}}}(L,0)=0\)</span>, as well as initial
conditions <span class="math">\(I(x)=A\sin\left(\frac{\pi}{L}x\right)\)</span> and <span class="math">\(V=0\)</span>.</p>
<p>It is common to use such exact solutions of physical interest
to verify implementations. However, the numerical
solution <span class="math">\(u^n_i\)</span> will only be an approximation to <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>.
We no have knowledge of the precise size of the error in
this approximation, and therefore we can never know if discrepancies
between the computed <span class="math">\(u^n_i\)</span> and <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span> are caused
by mathematical approximations or programming errors.
In particular, if a plot of the computed solution <span class="math">\(u^n_i\)</span> and
the exact one eq:ref:<cite>wave:pde2:test:ue</cite> looks similar, many
are attempted to claim that the implementation works, but
there can still be serious programming errors although color
plots look nice.</p>
<p>The only way to use exact physical solutions like
<a href="#equation-wave:pde2:test:ue">(20)</a> for serious and thorough verification is to
run a series of finer and finer meshes, measure the integrated error
in each mesh, and from this information estimate the convergence
rate. If these rates are very close to 2, we have strong evidence that
the implementation works.</p>
</div>
<div class="section" id="manufactured-solution">
<h2>Manufactured solution<a class="headerlink" href="#manufactured-solution" title="Permalink to this headline">¶</a></h2>
<p>One problem with the exact solution <a href="#equation-wave:pde2:test:ue">(20)</a> is
that it requires a simplification (<span class="math">\(V=0, f=0\)</span>) of the implemented problem
<a href="#equation-wave:pde2">(12)</a>-<a href="#equation-wave:pde2:bc:L">(16)</a>. An advantage of using
a manufactured solution is that we can test all terms in the
PDE problem. The idea of this approach is to set up some chosen
solution and fit the source term, boundary conditions, and initial
conditions to be compatible with the chosen solution.
Given that our boundary conditions in the implementation are
<span class="math">\(u(0,t)=u(L,t)=0\)</span>, we must choose a solution that fulfills these
conditions. One example is</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,t) = x(L-x)\sin t{\thinspace .}\]</div>
<p>Inserted in the PDE <span class="math">\(u_{tt}=c^2u_{xx}+f\)</span> we get</p>
<div class="math">
\[-x(L-x)\sin t = -2\sin t + f\quad\Rightarrow f = (2 - x(L-x))\sin t{\thinspace .}\]</div>
<p>The initial conditions become</p>
<div class="math">
\[\begin{split}u(x,0) =&amp; I(x) = 0,\\
u_t(x,0) &amp;= V(x) = (2 - x(L-x))\cos t{\thinspace .}\end{split}\]</div>
<p>To verify the code, we run a series of refined meshes and compute
the convergence rates. In more detail, we keep <span class="math">\(\Delta t/\Delta x\)</span>
constant for each mesh, implying that <span class="math">\(C\)</span> is also constant throughout
the experiments. A common discretization parameter
<span class="math">\(h = \Delta t\)</span> is introduced. For a given <span class="math">\(C\)</span> (and <span class="math">\(c\)</span>), <span class="math">\(\Delta x
ch/C\)</span>. We choose an initial time cell size <span class="math">\(h_0\)</span> and run
experiments with decreasing <span class="math">\(h\)</span>: <span class="math">\(h_i=2^{-i}h_0\)</span>, <span class="math">\(i=1,2,\ldots,m\)</span>.
Halving the cell size in each experiment is not necessary, but common.
For each experiment we must record a scalar measure of the error.
As will be shown later, it is expected that such error measures
are proportional to <span class="math">\(h^2\)</span>.
A standard choice of error measure
is the <span class="math">\(\ell^2\)</span> or <span class="math">\(\ell^\infty\)</span> norm of
the error mesh function <span class="math">\(e^n_i\)</span>:</p>
<div class="math">
\[||e^n_i||_{\ell^2} = \left( \Delta t\Delta x\sum_{n=0}^{N_t}\sum_{i=0}^{N_x}
(e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,\]</div>
<div class="math">
\[||e^n_i||_{\ell^\infty} = \max_{i,n} |e^i_n|{\thinspace .}\]</div>
<p>In Python, one can compute <span class="math">\(\sum_{i}(e^{n+1}_i)^2\)</span> at each time step
and accumulate the value in some sum variable, say <tt class="docutils literal"><span class="pre">e2_sum</span></tt>.  At the
final time step one can do <tt class="docutils literal"><span class="pre">sqrt(dt*dx*e2_sum)</span></tt>.  For the
<span class="math">\(\ell^\infty\)</span> norm one must compare the maximum error at a time level
(<tt class="docutils literal"><span class="pre">e.max()</span></tt>) with the global maximum over the time domain: <tt class="docutils literal"><span class="pre">e_max</span> <span class="pre">=</span>
<span class="pre">max(e_max,</span> <span class="pre">e.max())</span></tt>.</p>
<p>An alternative error measure
is to use a spatial norm at one time step only, e.g.,
the end time <span class="math">\(T\)</span>:</p>
<div class="math">
\[||e^n_i||_{\ell^2} = \left( \Delta x\sum_{i=0}^{N_x}
(e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,\]</div>
<div class="math">
\[||e^n_i||_{\ell^\infty} = \max_{0\leq i\leq N_x} |e^i_{n}|{\thinspace .}\]</div>
<p>Let <span class="math">\(E_i\)</span> be the error measure in experiment (mesh) number <span class="math">\(i\)</span> and
let <span class="math">\(h_i\)</span> be the corresponding discretization parameter (<span class="math">\(h\)</span>).
We expect an error model <span class="math">\(E_i = Ch_i^r\)</span>, here with <span class="math">\(r=0\)</span>. To
estimate <span class="math">\(r\)</span>, we can compare two consecutive
experiments and compute</p>
<div class="math">
\[r_i = \frac{\ln E_{i+1}/E_{i}}{\ln h_{i+1}/h_{i}},\quad i=0,\ldots,m-1{\thinspace .}\]</div>
<p>We should observe that <span class="math">\(r_i\)</span> approaches <span class="math">\(2\)</span> as <span class="math">\(i\)</span> increases.</p>
<p>The next section describes a method of manufactured solutions where
do not need to compute error measures and check that they converge
as expected as the mesh is refined.</p>
</div>
<div class="section" id="constructing-an-exact-solution-of-the-discrete-equations">
<h2>Constructing an exact solution of the discrete equations<a class="headerlink" href="#constructing-an-exact-solution-of-the-discrete-equations" title="Permalink to this headline">¶</a></h2>
<p>For verification purposes we shall use a solution that is quadratic in space
and linear in time. More specifically, our choice of the manufactured
solution is</p>
<div class="math">
\[{u_{\small\mbox{e}}} (x,t) = x(L-x)(1+\frac{1}{2}t),\]</div>
<p>which by insertion in the PDE leads to <span class="math">\(f(x,t)=2(1+t)c^2\)</span>. This <span class="math">\({u_{\small\mbox{e}}}\)</span>
fulfills the boundary conditions and is compatible with <span class="math">\(I(x)=x(L-x)\)</span>
and <span class="math">\(V(x)=\frac{1}{2}x(L-x)\)</span>.</p>
<p>A key feature of the chosen <span class="math">\({u_{\small\mbox{e}}}\)</span> is that it is also <em>an exact
solution of the discrete equations</em>. To realize this very important
result, we first establish the results</p>
<div class="math">
\[\lbrack D_tD_t t^2\rbrack^n = \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
= (n+1)^2 -n^2 + (n-1)^2 = 2,\]</div>
<div class="math">
\[\lbrack D_tD_t t\rbrack^n = \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
= \frac{((n+1) -n + (n-1))\Delta t}{\Delta t^2} = 0
\thinspace .\]</div>
<p>Hence,</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}}]^n_i = x_i(L-x_i)[D_tD_t (1+\frac{1}{2}t)]^n =
x_i(L-x_i)\frac{1}{2}[D_tD_t t]^n = 0,\]</div>
<p>and</p>
<div class="math">
\[\begin{split}\lbrack D_xD_x {u_{\small\mbox{e}}}\rbrack^n_i &amp;=
(1+\frac{1}{2}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i =
(1+\frac{1}{2}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\
&amp;= -2(1+\frac{1}{2}t_n)
\thinspace .\end{split}\]</div>
<p>Now, <span class="math">\(f^n_i = 2(1+\frac{1}{2}t_n)c^2\)</span> and we get</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}} - c^2D_xD_x{u_{\small\mbox{e}}} - f]^n_i = 0 - c^2(-1)2(1 + \frac{1}{2}t_n
+ 2(1+\frac{1}{2}t_n)c^2 = 0{\thinspace .}\]</div>
<p>Moreover, <span class="math">\({u_{\small\mbox{e}}}(x_i,0)=I(x_i)\)</span>,
<span class="math">\(\partial {u_{\small\mbox{e}}}/\partial t = V(x_i)\)</span> at <span class="math">\(t=0\)</span>, and
<span class="math">\({u_{\small\mbox{e}}}(x_0,t)={u_{\small\mbox{e}}}(x_{N_x},0)=0\)</span>. Also the modified scheme for the
first time step is fulfilled by <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>.</p>
<p>Therefore, the exact solution <span class="math">\({u_{\small\mbox{e}}}(x,t)=x(L-x)(1+t/2)\)</span>
of the PDE problem is also an exact solution of the discrete problem.
We can use this result to check that the computed <span class="math">\(u^n_i\)</span> vales from
an implementation equals <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span> within machine precision,
<em>regardless of the mesh spacings</em> <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>!
Nevertheless, there might be stability
restrictions on <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>, so the test can only be
run for a mesh that is compatible with the stability criterion (which
in the present case is <span class="math">\(C\leq 1\)</span>, to be derived later).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A product of quadratic or linear expressions in the various
independent variables, as shown above, will often fulfill both the
continuous and discrete PDE problem and can therefore be very useful
solutions for verifying implementations.  However, for 1D wave
equations of the type <span class="math">\(u_t=c^2u_{xx}\)</span> we shall see that there is always
another much more powerful way of generating exact
solutions (just set <span class="math">\(C=1\)</span>).</p>
</div>
</div>
</div>
<div class="section" id="implementation-1">
<span id="wave-pde1-impl"></span><h1>Implementation  (1)<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h1>
<p id="index-6">This section present the complete computational algorithm, its
implementation in Python code, animation of the solution,
and verification of the implementation.</p>
<p>A real implementation of the basic computational algorithm
from the sections <a class="reference internal" href="#wave-string-alg"><em>Formulating a recursive algorithm</em></a> and <a class="reference internal" href="#wave-string-impl"><em>Sketch of an implementation</em></a> can be
encapsulated in a function,
taking all the input data for the problem as arguments.  The physical
input data consists of <span class="math">\(c\)</span>, <span class="math">\(I(x)\)</span>, <span class="math">\(V(x)\)</span>, <span class="math">\(f(x,t)\)</span>, <span class="math">\(L\)</span>, and <span class="math">\(T\)</span>.
The numerical input is the mesh parameters <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>.
One possibility is to specify <span class="math">\(N_x\)</span> and the Courant number <span class="math">\(C=c\Delta
t/\Delta x\)</span>.  The latter is convenient to prescribe instead of <span class="math">\(\Delta
t\)</span> when performing numerical investigations, because the numerical
accuracy depends directly on <span class="math">\(C\)</span>.</p>
<p>The solution at all spatial points at a new time level is stored in an
array <tt class="docutils literal"><span class="pre">u</span></tt> (of length <span class="math">\(N_x+1\)</span>). We need to decide what do to with
this solution, e.g., visualize the curve, analyze the values, or write
the array to file for later use. The decision what to do is left to
the user in a suppled function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">u</span></tt> is the solution at the spatial points <tt class="docutils literal"><span class="pre">x</span></tt> at time <tt class="docutils literal"><span class="pre">t[n]</span></tt>.</p>
<div class="section" id="making-a-solver-function">
<h2>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h2>
<p>A first attempt at a solver function is listed below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u_tt=c^2*u_xx + f on (0,L)x(0,T].&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>     <span class="c"># Mesh points in space</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="n">dx</span><span class="o">/</span><span class="n">c</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c"># Mesh points in time</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>                    <span class="c"># Help variable in the scheme</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">V</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span>

    <span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Solution array at new time level</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Solution at 1 time level back</span>
    <span class="n">u_2</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Solution at 2 time levels back</span>

    <span class="kn">import</span> <span class="nn">time</span><span class="p">;</span>  <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>  <span class="c"># for measuring CPU time</span>

    <span class="c"># Load initial condition into u_1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c"># Special formula for first time step</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Switch variables before next step</span>
    <span class="n">u_2</span><span class="p">[:],</span> <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="c"># Update all inner points at time t[n+1]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                     <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                     <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="c"># Insert boundary conditions</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">break</span>

        <span class="c"># Switch variables before next step</span>
        <span class="n">u_2</span><span class="p">[:],</span> <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span>

    <span class="n">cpu_time</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu_time</span>
</pre></div>
</div>
</div>
<div class="section" id="verification-exact-quadratic-solution">
<h2>Verification: exact quadratic solution<a class="headerlink" href="#verification-exact-quadratic-solution" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-7"></span><span class="target" id="index-8"></span><p id="index-9">We use the test problem derived in the section <a class="reference internal" href="#wave-pde2-fd"><em>A slightly generalized model problem</em></a> for
verification. Here is a function realizing this verification as a
.. cite</p>
<p>nose test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nose.tools</span> <span class="kn">as</span> <span class="nn">nt</span>

<span class="k">def</span> <span class="nf">test_quadratic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that u(x,t)=x(L-x)(1+t/2) is exactly reproduced.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># Very coarse mesh</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="visualization-animating">
<h2>Visualization: animating <span class="math">\(u(x,t)\)</span><a class="headerlink" href="#visualization-animating" title="Permalink to this headline">¶</a></h2>
<p>Now that we have verified the implementation it is time to do a
real computation where we also display the evolution of the waves
on the screen.</p>
<div class="section" id="visualization-via-scitools">
<h3>Visualization via SciTools<a class="headerlink" href="#visualization-via-scitools" title="Permalink to this headline">¶</a></h3>
<p>The following <tt class="docutils literal"><span class="pre">viz</span></tt> function defines a <tt class="docutils literal"><span class="pre">user_action</span></tt>
callback function for plotting the solution at each time level:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">viz</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run solver and visualize u at each time level.&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>

    <span class="k">def</span> <span class="nf">plot_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span>
                 <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
                 <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">show</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># Let the initial condition stay on the screen for 2</span>
        <span class="c"># seconds, else insert a pause of 0.2 s between each plot</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;frame_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>  <span class="c"># for movie making</span>

    <span class="c"># Clean up old movie frames</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;frame_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">user_action</span> <span class="o">=</span> <span class="n">plot_u</span> <span class="k">if</span> <span class="n">animate</span> <span class="k">else</span> <span class="bp">None</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="p">)</span>

    <span class="c"># Make movie files</span>
    <span class="n">fps</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c"># Frames per second</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">movie</span><span class="p">(</span><span class="s">&#39;frame_*.png&#39;</span><span class="p">,</span> <span class="n">encoder</span><span class="o">=</span><span class="s">&#39;html&#39;</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span>
              <span class="n">output_file</span><span class="o">=</span><span class="s">&#39;movie.html&#39;</span><span class="p">)</span>
    <span class="n">codec2ext</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">flv</span><span class="o">=</span><span class="s">&#39;flv&#39;</span><span class="p">,</span> <span class="n">libx64</span><span class="o">=</span><span class="s">&#39;mp4&#39;</span><span class="p">,</span> <span class="n">libvpx</span><span class="o">=</span><span class="s">&#39;webm&#39;</span><span class="p">,</span>
                     <span class="n">libtheora</span><span class="o">=</span><span class="s">&#39;ogg&#39;</span><span class="p">)</span>
    <span class="n">filespec</span> <span class="o">=</span> <span class="s">&#39;frame_</span><span class="si">%04d</span><span class="s">.png&#39;</span>
    <span class="n">movie_program</span> <span class="o">=</span> <span class="s">&#39;avconv&#39;</span>  <span class="c"># or &#39;ffmpeg&#39;</span>
    <span class="k">for</span> <span class="n">codec</span> <span class="ow">in</span> <span class="n">codec2ext</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">codec2ext</span><span class="p">[</span><span class="n">codec</span><span class="p">]</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%(movie_program)s</span><span class="s"> -r </span><span class="si">%(fps)d</span><span class="s"> -i </span><span class="si">%(filespec)s</span><span class="s"> &#39;</span>\
              <span class="s">&#39;-vcodec </span><span class="si">%(codec)s</span><span class="s"> movie.</span><span class="si">%(ext)s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
</pre></div>
</div>
<p>A function inside another function, like <tt class="docutils literal"><span class="pre">plot_u</span></tt> in the above code
segment, has access to <em>and remembers</em> all the local variables
in the surrounding code inside the <tt class="docutils literal"><span class="pre">viz</span></tt> function (!). This is known
in computer science as a <em>closure</em> and is very convenient to
program with. For example,
the <tt class="docutils literal"><span class="pre">plt</span></tt> and <tt class="docutils literal"><span class="pre">time</span></tt> modules defined outside <tt class="docutils literal"><span class="pre">plot_u</span></tt> are accessible for
<tt class="docutils literal"><span class="pre">plot_u</span></tt> when
the function is called (as <tt class="docutils literal"><span class="pre">user_action</span></tt>) in the <tt class="docutils literal"><span class="pre">solver</span></tt> function.
Some may think, however, that a class instead of a closure is a cleaner
and easier-to-understand implementation of
the user action function, see the section <a class="reference internal" href="#wave-pde2-software"><em>Building a general 1D wave equation solver</em></a>.</p>
</div>
<div class="section" id="making-movie-files">
<h3>Making movie files<a class="headerlink" href="#making-movie-files" title="Permalink to this headline">¶</a></h3>
<p>Several hardcopies of the animation are made from the
<tt class="docutils literal"><span class="pre">frame_*.png</span></tt> files. The first movie, made by the SciTools function
<tt class="docutils literal"><span class="pre">plt.movie</span></tt> creates a <tt class="docutils literal"><span class="pre">movie.html</span></tt> file with a movie player
for displaying the <tt class="docutils literal"><span class="pre">frame_*.png</span></tt> files. This movie player can
be generated from the command line too</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; scitools movie encoder=html output_file=movie.html \</span>
<span class="go">          fps=4 frame_*.png</span>
</pre></div>
</div>
<p>We also use
the <tt class="docutils literal"><span class="pre">avconv</span></tt> (or <tt class="docutils literal"><span class="pre">ffmpeg</span></tt>) programs to make movie files in modern
formats: Flash, MP4, Webm, and Ogg.
A typical <tt class="docutils literal"><span class="pre">avconv</span></tt> (or <tt class="docutils literal"><span class="pre">ffmpeg</span></tt>) commands for creating a movie file
look like</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; avconv -r 4 -i frame_%04d.png -vcodec libtheora movie.ogg</span>
</pre></div>
</div>
<p>The different formats require
different encoders to be installed: Flash applies <tt class="docutils literal"><span class="pre">flv</span></tt>,
WebM applies <tt class="docutils literal"><span class="pre">libvpx</span></tt>, and MP4 applies <tt class="docutils literal"><span class="pre">libx64</span></tt>.
Players like <tt class="docutils literal"><span class="pre">vlc</span></tt>, <tt class="docutils literal"><span class="pre">mplayer</span></tt>,
<tt class="docutils literal"><span class="pre">gxine</span></tt>, and <tt class="docutils literal"><span class="pre">totem</span></tt> can be used to play these movie files.</p>
<p>Note that padding the frame counter with zeros in the <tt class="docutils literal"><span class="pre">frame_*.png</span></tt>
files, as specified by the <tt class="docutils literal"><span class="pre">%04d</span></tt> format, is essential so that the wildcard
notation <tt class="docutils literal"><span class="pre">frame_*.png</span></tt> expands to the correct set of files.</p>
</div>
<div class="section" id="skipping-frames-for-animation-speed">
<h3>Skipping frames for animation speed<a class="headerlink" href="#skipping-frames-for-animation-speed" title="Permalink to this headline">¶</a></h3>
<p>Sometimes the time step is small and <span class="math">\(T\)</span> is large, leading to an
inconveniently large number of plot files and a slow animation on the
screen. The solution to such a problem is to decide on a total number
of frames in the animation, <tt class="docutils literal"><span class="pre">num_frames</span></tt>, and plot the solution only at
every <tt class="docutils literal"><span class="pre">every</span></tt> frame. The total number of time levels (i.e., maximum
possible number of frames) is the length of <tt class="docutils literal"><span class="pre">t</span></tt>, <tt class="docutils literal"><span class="pre">t.size</span></tt>, and if we
want <tt class="docutils literal"><span class="pre">num_frames</span></tt>, we need to plot every <tt class="docutils literal"><span class="pre">t.size/num_frames</span></tt> frame:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">every</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">num_frames</span><span class="p">))</span>
<span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">every</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The initial condition (<tt class="docutils literal"><span class="pre">n=0</span></tt>) is natural to include,
and as <tt class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">every</span> <span class="pre">==</span> <span class="pre">0</span></tt> will very seldom be true for the
very final frame, we also ensure that <tt class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">t.size-1</span></tt> and hence
the final frame is included.</p>
<p>A simple choice of numbers may illustrate the formulas: say we have
801 frames in total (<tt class="docutils literal"><span class="pre">t.size</span></tt>) and we allow only 60 frames to be
plotted. Then we need to plot every 801/60 frame, which with integer
division yields 13 as <tt class="docutils literal"><span class="pre">every</span></tt>. Using the mod function, <tt class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">every</span></tt>,
this operation is zero every time <tt class="docutils literal"><span class="pre">n</span></tt> can be divided by 13 without a
remainder. That is, the <tt class="docutils literal"><span class="pre">if</span></tt> test is true when <tt class="docutils literal"><span class="pre">n</span></tt> equals <span class="math">\(0, 13, 26,
39, ..., 780, 801\)</span>. The associated code is included in the <tt class="docutils literal"><span class="pre">plot_u</span></tt>
function in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D_u0_sv.py">wave1D_u0_sv.py</a>.</p>
</div>
<div class="section" id="visualization-via-matplotlib">
<h3>Visualization via Matplotlib<a class="headerlink" href="#visualization-via-matplotlib" title="Permalink to this headline">¶</a></h3>
<p>The previous code based on the <tt class="docutils literal"><span class="pre">plot</span></tt> interface from <tt class="docutils literal"><span class="pre">scitools.std</span></tt>
can be run with Matplotlib as the visualization backend, but if one
desires to program directly with Matplotlib, quite different code
is needed. Matplotlib&#8217;s interactive mode must be turned on:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>  <span class="c"># interactive mode on</span>
</pre></div>
</div>
<p>The most
commonly used animation technique with Matplotlib
is to update the data in the plot at each time level:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Make a first plot</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="c"># call plt.axis, plt.xlabel, plt.ylabel, etc. as desired</span>

<span class="c"># At later time levels</span>
<span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s">&#39;t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c"># make updated plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>An alternative is to rebuild the plot at every time level:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>        <span class="c"># delete any previous curve(s)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="c"># plt.xlabel, plt.legend and other decorations</span>
<span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Many prefer to work with figure and axis objects as in MATLAB:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">fig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="c"># ax.set_xlabel, ax.legend and other decorations</span>
<span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="running-a-case">
<span id="wave-pde1-guitar-data"></span><h2>Running a case<a class="headerlink" href="#running-a-case" title="Permalink to this headline">¶</a></h2>
<p>The first demo of our 1D wave equation solver concerns vibrations of a
string that is initially deformed to a triangular shape, like when picking
a guitar string:</p>
<div class="math" id="equation-wave:pde1:guitar:I">
<span class="eqno">(21)</span>\[\begin{split}     I(x) = \left\lbrace
     \begin{array}{ll}
     ax/x_0, &amp; x &lt; x_0,\\
     a(L-x)/(L-x_0), &amp; \hbox{otherwise}
     \end{array}\right.\end{split}\]</div>
<p>We choose <span class="math">\(L=75\)</span> cm, <span class="math">\(x_0=0.8L\)</span>, <span class="math">\(a=5\)</span> mm, <span class="math">\(N_x=50\)</span>, and a time frequency
<span class="math">\(\nu = 440\)</span> Hz. The relation between the wave speed <span class="math">\(c\)</span> and <span class="math">\(\nu\)</span> is
<span class="math">\(c=\nu\lambda\)</span>, where <span class="math">\(\lambda\)</span> is the wavelength, taken as <span class="math">\(2L\)</span> because
the longest wave on the string form half a wavelength. There is no
external force, so <span class="math">\(f=0\)</span>, and the string is at rest initially so
that <span class="math">\(V=0\)</span>. A function setting
these physical parameters and calling <tt class="docutils literal"><span class="pre">viz</span></tt> for this case goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">guitar</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">L</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.005</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">440</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="n">wavelength</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">freq</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span><span class="o">*</span><span class="n">num_periods</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">x0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x0</span> <span class="k">else</span> <span class="n">a</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>

    <span class="n">umin</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.2</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">cpu</span> <span class="o">=</span> <span class="n">viz</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The associated program has the name <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D_u0_s.py">wave1D_u0_s.py</a>. Run
the program and watch the <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/mov-wave/guitar_C0.8/index.html">movie of the vibrating string</a>.</p>
</div>
<div class="section" id="the-benefits-of-scaling">
<h2>The benefits of scaling<a class="headerlink" href="#the-benefits-of-scaling" title="Permalink to this headline">¶</a></h2>
<p>The previous example demonstrated that quite some work is needed
with establishing relevant physical parameters for a case. By <em>scaling</em>
the mathematical problem we can often reduce the need to estimate
physical parameters dramatically. A scaling consists of introducing new
independent and dependent variables, with the aim that the absolute
value of these vary between 0 and 1:</p>
<div class="math">
\[\bar x = \frac{x}{L},\quad \bar t = \frac{c}{L}t,\quad
\bar u = \frac{u}{a}
\thinspace .\]</div>
<p>Replacing old by new variables in the PDE, using <span class="math">\(f=0\)</span>,
and dropping the bars, results in the <em>scaled equation</em>
<span class="math">\(u_{tt} = u_{xx}\)</span>. This is simply
the original equation with <span class="math">\(c=1\)</span>. The initial condition
corresponds to <a href="#equation-wave:pde1:guitar:I">(21)</a> with <span class="math">\(a=1\)</span>, <span class="math">\(L=1\)</span>, and
<span class="math">\(x_0\in [0,1]\)</span>. This means that we only need to decide on <span class="math">\(x_0\)</span>, because
the scaled problem corresponds to setting all
other parameters to unity! In the code we can just set
<tt class="docutils literal"><span class="pre">a=c=L=1</span></tt>, <tt class="docutils literal"><span class="pre">x0=0.8</span></tt>, and there is no need to calculate with
wavelengths and frequencies to estimate <span class="math">\(c\)</span>.</p>
<p>The only non-trivial parameter to estimate in the scaled problem
is the final end time of the simulation, or more precisely, how it relates
to periods in periodic solutions in time, since we often want to
express the end time as a certain number of periods.
Suppose as <span class="math">\(u\)</span> behaves as <span class="math">\(\sin (\omega t)\)</span> in time in variables
with dimension. The corresponding period is <span class="math">\(P=2\pi/\omega\)</span>.
The frequency <span class="math">\(\omega\)</span> is related to the wavelength <span class="math">\(\lambda\)</span> of the waves
through the relations <span class="math">\(\omega = kc\)</span> and <span class="math">\(k=2\pi/\lambda\)</span>, giving
<span class="math">\(\omega = 2\pi c/\lambda\)</span> and <span class="math">\(P=\lambda/c\)</span>. It remains to estimate <span class="math">\(\lambda\)</span>.
With <span class="math">\(u(x,t)=F(x)\sin\omega t\)</span> we find from <span class="math">\(u_{tt}=c^2u_{xx}\)</span>
that <span class="math">\(c^2F'' + \omega^2F=0\)</span>, and the boundary conditions demand
<span class="math">\(F(0)=F(L)=0\)</span>. The solution is <span class="math">\(F(x)=\sin(x\pi/L)\)</span>, which has
wavelength <span class="math">\(\lambda = 2\pi/(\pi/L)=2L\)</span>. One period is therefore
given by <span class="math">\(P=2L/c\)</span>. The dimensionless period is <span class="math">\(\bar P=Pc/L = 2\)</span>.</p>
</div>
</div>
<div class="section" id="vectorization">
<h1>Vectorization<a class="headerlink" href="#vectorization" title="Permalink to this headline">¶</a></h1>
<p id="index-10">The computational algorithm for solving the wave equation visits one
mesh point at a time and evaluates a formula for the new value <span class="math">\(u_i^{n+1}\)</span>
at
that point. Technically, this is implemented by a loop over array
elements in a program. Such loops may run slowly in Python (and
similar interpreted languages such as R and MATLAB).
One technique for speeding up loops is to
perform operations on entire arrays instead of working with one element
at a time. This is referred to as <em>vectorization</em>, <em>vector computing</em>,
or <em>array computing</em>.
Operations on whole arrays are possible if the computations
involving each element is independent of each other and therefore can,
at least in principle, be performed simultaneously.
Vectorization not only speeds up the code on serial computers, but it
also makes it easy to exploit parallel computing.</p>
<div class="section" id="operations-on-slices-of-arrays">
<h2>Operations on slices of arrays<a class="headerlink" href="#operations-on-slices-of-arrays" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-11"></span><span class="target" id="index-12"></span><p id="index-13">Efficient computing with <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays demands that we avoid loops
and compute with entire arrays at once (or at least large portions of them).
Consider this calculation of differences <span class="math">\(d_i = u_{i+1}-u_i\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">size</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>All the differences here are independent of each other.
The computation of <tt class="docutils literal"><span class="pre">d</span></tt> can therefore alternatively be done by
subtracting the array <span class="math">\((u_0,u_1,\ldots,u_{n-1})\)</span> from
the array where the elements are shifted one index upwards:
<span class="math">\((u_1,u_2,\ldots,u_n)\)</span>, see Figure <a class="reference internal" href="#wave-pde1-vec-fig1"><em>Illustration of subtracting two slices of two arrays</em></a>.
The former subset of the array can be
expressed by <tt class="docutils literal"><span class="pre">u[0:n-1]</span></tt>,
<tt class="docutils literal"><span class="pre">u[0:-1]</span></tt>, or just
<tt class="docutils literal"><span class="pre">u[:-1]</span></tt>, meaning from index 0 up to,
but not including, the last element (<tt class="docutils literal"><span class="pre">-1</span></tt>). The latter subset
is obtained by <tt class="docutils literal"><span class="pre">u[1:n]</span></tt> or <tt class="docutils literal"><span class="pre">u[1:]</span></tt>,
meaning from index 1 and the rest of the array.
The computation of <tt class="docutils literal"><span class="pre">d</span></tt> can now be done without an explicit Python loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>or with explicit limits if desired:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Indices with a colon, going from an index to (but not including) another
index are called <em>slices</em>. With <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays, the computations
are still done by loops, but in efficient, compiled, highly optimized code
in C or Fortran. Such array operations can also easily be distributed
among many processors on parallel computers. We say that the <em>scalar code</em>
above, working on an element (a scalar) at a time, has been replaced by
an equivalent <em>vectorized code</em>. The process of vectorizing code is called
<em>vectorization</em>.</p>
<div class="figure" id="wave-pde1-vec-fig1">
<img alt="_images/vectorized_diff1.png" src="_images/vectorized_diff1.png" style="width: 400px;" />
<p class="caption"><em>Illustration of subtracting two slices of two arrays</em></p>
</div>
<div class="admonition-test-the-understanding admonition">
<p class="first admonition-title">Test the understanding</p>
<p class="last">Newcomers to vectorization are encouraged to choose
a small array <tt class="docutils literal"><span class="pre">u</span></tt>, say with five elements,
and simulate with pen and paper
both the loop version and the vectorized version.</p>
</div>
<p>Finite difference schemes basically contains differences between array
elements with shifted indices. Consider the updating formula</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The vectorization consists of replacing the loop by arithmetics on
slices of arrays of length <tt class="docutils literal"><span class="pre">n-2</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="n">u2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>   <span class="c"># alternative</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">u2</span></tt> here gets length <tt class="docutils literal"><span class="pre">n-2</span></tt>. If <tt class="docutils literal"><span class="pre">u2</span></tt> is already an array of
length <tt class="docutils literal"><span class="pre">n</span></tt> and we want to use the formula to update all the &#8220;inner&#8221;
elements of <tt class="docutils literal"><span class="pre">u2</span></tt>, as we will when solving a 1D wave equation, we can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>   <span class="c"># alternative</span>
</pre></div>
</div>
<p>Pen and paper calculations with a small array will demonstrate what is
actually going on. The expression on the right-hand side are done in the
following steps, involving temporary arrays with intermediate results,
since we can only work with two arrays at a time in
arithmetic expressions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">temp1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">temp2</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp1</span>
<span class="n">temp3</span> <span class="o">=</span> <span class="n">temp2</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp3</span>
</pre></div>
</div>
<p>We can extend the previous example to a formula with an additional term computed
by calling a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>Assuming <tt class="docutils literal"><span class="pre">u2</span></tt>, <tt class="docutils literal"><span class="pre">u</span></tt>, and <tt class="docutils literal"><span class="pre">x</span></tt> all have length <tt class="docutils literal"><span class="pre">n</span></tt>, the vectorized
version becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="finite-difference-schemes-expressed-as-slices">
<h2>Finite difference schemes expressed as slices<a class="headerlink" href="#finite-difference-schemes-expressed-as-slices" title="Permalink to this headline">¶</a></h2>
<p>We now have the necessary tools to vectorize the algorithm for
the wave equation. There are three loops: one for the initial condition,
one for the first time step, and finally the loop that is repeated for
all subsequent time levels. Since only the latter is repeated a potentially
large number of times, we limit the efforts of vectorizing the code
to this loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The vectorized version becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span><span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The program
<a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D_u0_sv.py">wave1D_u0_sv.py</a>
contains a new version of the function <tt class="docutils literal"><span class="pre">solver</span></tt> where both the scalar
and the vectorized loops are included (the argument <tt class="docutils literal"><span class="pre">version</span></tt> is
set to <tt class="docutils literal"><span class="pre">scalar</span></tt> or <tt class="docutils literal"><span class="pre">vectorized</span></tt>, respectively).</p>
</div>
<div class="section" id="verification-2">
<h2>Verification  (2)<a class="headerlink" href="#verification-2" title="Permalink to this headline">¶</a></h2>
<p id="index-14">We may reuse the quadratic solution <span class="math">\({u_{\small\mbox{e}}}(x,t)=x(L-x)(1+\frac{1}{2}t)\)</span> for
verifying also the vectorized code. A nose test can now test
both the scalar and the vectorized version. Moreover, we may
use a <tt class="docutils literal"><span class="pre">user_action</span></tt> function that compares the computed and exact
solution at each time level and performs a test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_quadratic</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the scalar and vectorized versions work for</span>
<span class="sd">    a quadratic u(x,t)=x(L-x)(1+t/2) that is exactly reproduced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># The following function must work for x as array or scalar</span>
    <span class="n">exact_solution</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c"># f is a scalar (zeros_like(x) works for scalar x too)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mf">2.5</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># Very coarse mesh</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>  <span class="c"># Long time integration</span>

    <span class="k">def</span> <span class="nf">assert_no_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>

    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-lambda-functions admonition">
<p class="first admonition-title">Lambda functions</p>
<p>The code segment above demonstrates how to achieve very
compact code with the use of lambda functions for the various
input parameters that require a Python function. In essence,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>Note that lambda functions can just contain a single expression and no
statements.</p>
<p>One advantage with lambda functions is that they can be used directly
in calls:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="o">/</span><span class="n">L</span><span class="p">),</span> <span class="n">V</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="efficiency-measurements">
<h2>Efficiency measurements<a class="headerlink" href="#efficiency-measurements" title="Permalink to this headline">¶</a></h2>
<p>Running the <tt class="docutils literal"><span class="pre">wave1D_u0_sv.py</span></tt> code with the previous string vibration example
for <span class="math">\(N_x=50,100,200,400,800\)</span> and measuring the CPU time
(see the <tt class="docutils literal"><span class="pre">run_efficiency_experiments</span></tt> function), shows that the vectorized
code runs substantially faster: the scalar code uses approximately
a factor <span class="math">\(N_x/5\)</span> more time!</p>
</div>
</div>
<div class="section" id="exercises-1">
<h1>Exercises  (1)<a class="headerlink" href="#exercises-1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-1-simulate-a-standing-wave">
<span id="wave-exer-standingwave"></span><h2>Exercise 1: Simulate a standing wave<a class="headerlink" href="#exercise-1-simulate-a-standing-wave" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this exercise is to simulate standing waves on <span class="math">\([0,L]\)</span>
and illustrate the error in the simulation.
Standing waves arise from an initial condition</p>
<div class="math">
\[u(x,0)= A \sin\left(\frac{pi}{L}mx\right),\]</div>
<p>where <span class="math">\(m\)</span> is an integer and <span class="math">\(A\)</span> is a freely chosen amplitude.
The corresponding exact solution can be computed and reads</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,t) =  A\sin\left(\frac{\pi}{L}mx\right)
\cos\left(\frac{\pi}{L}mct\right){\thinspace .}\]</div>
<p>Make an animation where you show
both the numerical and the exact solution, or the error. It is of
interest to see how the error develops in time.</p>
<p><em>Hint.</em> Import the <tt class="docutils literal"><span class="pre">solver</span></tt> function <tt class="docutils literal"><span class="pre">wave1D_u0_s.py</span></tt> into a new file
<tt class="docutils literal"><span class="pre">wave_standing.py</span></tt>. Reimplement the <tt class="docutils literal"><span class="pre">viz</span></tt> function in this file
that plots either the numerical and exact solution, or the error,
instead of just the numerical solution.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave_standing.py</span></tt>.</p>
</div>
<div class="section" id="exercise-2-add-storage-of-solution-in-a-user-action-function">
<span id="wave-exer-store-list"></span><h2>Exercise 2: Add storage of solution in a user action function<a class="headerlink" href="#exercise-2-add-storage-of-solution-in-a-user-action-function" title="Permalink to this headline">¶</a></h2>
<p>Extend the <tt class="docutils literal"><span class="pre">plot_u</span></tt> function in the file <tt class="docutils literal"><span class="pre">wave1D_u0_s.py</span></tt> to also store
the solutions <tt class="docutils literal"><span class="pre">u</span></tt> in a list.
To this end, declare <tt class="docutils literal"><span class="pre">all_u</span></tt> as
an empty list in the <tt class="docutils literal"><span class="pre">viz</span></tt> function, outside <tt class="docutils literal"><span class="pre">plot_u</span></tt>, and perform
an append operation inside the <tt class="docutils literal"><span class="pre">plot_u</span></tt> function. Note that a
function, like <tt class="docutils literal"><span class="pre">plot_u</span></tt>, inside another function, like <tt class="docutils literal"><span class="pre">viz</span></tt>,
remembers all local variables in <tt class="docutils literal"><span class="pre">viz</span></tt> function, including <tt class="docutils literal"><span class="pre">all_u</span></tt>,
even when <tt class="docutils literal"><span class="pre">plot_u</span></tt> is called (as <tt class="docutils literal"><span class="pre">user_action</span></tt>) in the <tt class="docutils literal"><span class="pre">solver</span></tt> function.
Test both <tt class="docutils literal"><span class="pre">all_u.append(u)</span></tt> and <tt class="docutils literal"><span class="pre">all_u.append(u.copy())</span></tt>.
Why does one of these constructions fail to store the solution correctly?
Let the <tt class="docutils literal"><span class="pre">viz</span></tt> function return the <tt class="docutils literal"><span class="pre">all_u</span></tt> list
converted to a two-dimensional <tt class="docutils literal"><span class="pre">numpy</span></tt> array.
Filename: <tt class="docutils literal"><span class="pre">wave1D_u0_s_store.py</span></tt>.</p>
</div>
<div class="section" id="exercise-3-use-a-class-for-the-user-action-function">
<span id="wave-exer-store-list-class"></span><h2>Exercise 3: Use a class for the user action function<a class="headerlink" href="#exercise-3-use-a-class-for-the-user-action-function" title="Permalink to this headline">¶</a></h2>
<p>Redo <a class="reference internal" href="#wave-exer-store-list"><em>Exercise 2: Add storage of solution in a user action function</em></a> using a class for the
user action function. That is, define a class <tt class="docutils literal"><span class="pre">Action</span></tt> where
the <tt class="docutils literal"><span class="pre">all_u</span></tt> list is an attribute, and implement the user action
function as a method (the special method <tt class="docutils literal"><span class="pre">__call__</span></tt> is a natural
choice). The class versions avoids that the user action function
depends on parameters defined outside the function (such as <tt class="docutils literal"><span class="pre">all_u</span></tt>
in <a class="reference internal" href="#wave-exer-store-list"><em>Exercise 2: Add storage of solution in a user action function</em></a>).
Filename: <tt class="docutils literal"><span class="pre">wave1D_u0_s2c.py</span></tt>.</p>
</div>
<div class="section" id="exercise-4-compare-several-courant-numbers-in-one-movie">
<span id="wave-exer-multiple-c"></span><h2>Exercise 4: Compare several Courant numbers in one movie<a class="headerlink" href="#exercise-4-compare-several-courant-numbers-in-one-movie" title="Permalink to this headline">¶</a></h2>
<p>The goal of this exercise is to make movies where several curves,
corresponding to different Courant numbers, are visualized.
Import the <tt class="docutils literal"><span class="pre">solver</span></tt> function from the <tt class="docutils literal"><span class="pre">wave1D_u0_s</span></tt> movie
in a new file <tt class="docutils literal"><span class="pre">wave_compare.py</span></tt>. Reimplement the <tt class="docutils literal"><span class="pre">viz</span></tt> function
such that it can take a list of <tt class="docutils literal"><span class="pre">C</span></tt> values as argument
and create a movie with solutions corresponding to the given <tt class="docutils literal"><span class="pre">C</span></tt>
values. The <tt class="docutils literal"><span class="pre">plot_u</span></tt> function must be changed to store the solution
in an array (see <a class="reference internal" href="#wave-exer-store-list"><em>Exercise 2: Add storage of solution in a user action function</em></a> or
<a class="reference internal" href="#wave-exer-store-list-class"><em>Exercise 3: Use a class for the user action function</em></a> for details), <tt class="docutils literal"><span class="pre">solver</span></tt> must be
computed for each value of the Courant number, and finally
one must run through each time step and plot all the spatial
solution curves in one figure and store it in a file.</p>
<p>The challenge in such a visualization is to ensure that the curves in
one plot corresponds to the same time point. The easiest remedy is to
keep the time and space resolution constant and change the wave
velocity <span class="math">\(c\)</span> to change the Courant number.
Filename: <tt class="docutils literal"><span class="pre">wave_numerics_comparison.py</span></tt>.</p>
</div>
<div class="section" id="project-5-calculus-with-1d-mesh-functions">
<span id="wave-exer-mesh1d-calculus"></span><h2>Project 5: Calculus with 1D mesh functions<a class="headerlink" href="#project-5-calculus-with-1d-mesh-functions" title="Permalink to this headline">¶</a></h2>
<p>This project explores integration and differentiation of
mesh functions, both with scalar and vectorized implementations.
We are given a mesh function <span class="math">\(f_i\)</span> on a spatial one-dimensional
mesh <span class="math">\(x_i=i\Delta x\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>, over the interval <span class="math">\([a,b]\)</span>.</p>
<p><em>a)</em> Define the discrete derivative of <span class="math">\(f_i\)</span> by using centered
differences at internal mesh points and one-sided differences
at the end points. Implement a scalar version of
the computation in a Python function and supply a nose test
for the linear case <span class="math">\(f(x)=4x-2.5\)</span> where the discrete derivative should
be exact.</p>
<p><em>b)</em> Vectorize the implementation of the discrete derivative.
Extend the nose test to check the validity of the implementation.</p>
<p><em>c)</em> To compute the discrete integral <span class="math">\(F_i\)</span> of <span class="math">\(f_i\)</span>, we assume that
the mesh function <span class="math">\(f_i\)</span> varies linearly between the mesh points.
Let <span class="math">\(f(x)\)</span> be such a linear interpolant of <span class="math">\(f_i\)</span>. We then
have</p>
<div class="math">
\[F_i = \int_{x_0}^{x_i} f(x) dx{\thinspace .}\]</div>
<p>The exact integral of a piecewise linear function <span class="math">\(f(x)\)</span> is
given by the Trapezoidal rule. S
how that if <span class="math">\(F_{i}\)</span> is already computed, we can find <span class="math">\(F_{i+1}\)</span>
from</p>
<div class="math">
\[F_{i+1} = F_i + \frac{1}{2}(f_i + f_{i+1})\Delta x{\thinspace .}\]</div>
<p>Make a function for a scalar implementation of the discrete integral
as a mesh function. That is, the function should return
<span class="math">\(F_i\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span>.
For a nose test one can use the fact that the above defined
discrete integral of a linear
function (say <span class="math">\(f(x)=4x-2.5\)</span>) is exact.</p>
<p><em>d)</em> Vectorize the implementation of the discrete integral.
Extend the nose test to check the validity of the implementation.</p>
<p><em>Hint.</em> Interpret the recursive formula for <span class="math">\(F_{i+1}\)</span> as a sum.
Make an array with each element of the sum and use the &#8220;cumsum&#8221;
(<tt class="docutils literal"><span class="pre">numpy.cumsum</span></tt>) operation to compute the accumulative sum:
<tt class="docutils literal"><span class="pre">numpy.cumsum([1,3,5])</span></tt> is <tt class="docutils literal"><span class="pre">[1,4,9]</span></tt>.</p>
<p><em>e)</em> Create a class <tt class="docutils literal"><span class="pre">MeshCalculus</span></tt> that can integrate and differentiate
mesh functions. The class can just define some methods that call
the previously implemented Python functions. Here is an example
on the usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">calc</span> <span class="o">=</span> <span class="n">MeshCalculus</span><span class="p">(</span><span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>        <span class="c"># mesh</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                    <span class="c"># mesh function</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">differentiate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>    <span class="c"># discrete derivative</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>         <span class="c"># discrete anti-derivative</span>
</pre></div>
</div>
<p>Filename: <tt class="docutils literal"><span class="pre">mesh_calculus_1D.py</span></tt>.</p>
</div>
</div>
<div class="section" id="generalization-reflecting-boundaries">
<h1>Generalization: reflecting boundaries<a class="headerlink" href="#generalization-reflecting-boundaries" title="Permalink to this headline">¶</a></h1>
<p>The boundary condition <span class="math">\(u=0\)</span> makes <span class="math">\(u\)</span> change sign at the boundary,
while the condition <span class="math">\(u_x=0\)</span> perfectly reflects the wave, see
a <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/mov-wave/demo_BC_gaussian/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/mov-wave/demo_BC_gaussian/movie.flv">movie file</a>
for demonstration.
Our next task is to explain how to implement the boundary
condition <span class="math">\(u_x=0\)</span>, which is
more complicated to express numerically and also to implement than
a given value of <span class="math">\(u\)</span>.
We shall present two methods for implementing <span class="math">\(u_x=0\)</span>
in a finite difference scheme, one based on deriving a modified
stencil at the boundary, and another one based on extending the mesh
with ghost cells and ghost points.</p>
<div class="section" id="neumann-boundary-condition">
<span id="wave-pde2-neumann"></span><h2>Neumann boundary condition<a class="headerlink" href="#neumann-boundary-condition" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><p id="index-18">When a wave hits a boundary and is to be reflected back, one applies
the condition</p>
<div class="math" id="equation-wave:pde1:Neumann:0">
<span class="eqno">(22)</span>\[      \frac{\partial u}{\partial n} \equiv \boldsymbol{n}\cdot\nabla u = 0\]\[     \thinspace .\]</div>
<p>The derivative <span class="math">\(\partial /\partial n\)</span> is in the
outward normal direction from a general boundary.
For a 1D domain <span class="math">\([0,L]\)</span>,
we have that</p>
<div class="math">
\[\left.\frac{\partial}{\partial n}\right\vert_{x=L} =
\frac{\partial}{\partial x},\quad
\left.\frac{\partial}{\partial n}\right\vert_{x=0} = -
\frac{\partial}{\partial x}{\thinspace .}\]</div>
<div class="admonition-boundary-condition-terminology admonition">
<p class="first admonition-title">Boundary condition terminology</p>
<p class="last">Boundary conditions
that specify the value of <span class="math">\(\partial u/\partial n\)</span>,
or shorter <span class="math">\(u_n\)</span>, are known as
<a class="reference external" href="http://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann</a> conditions, while <a class="reference external" href="http://en.wikipedia.org/wiki/Dirichlet_conditions">Dirichlet conditions</a>
refer to specifications of <span class="math">\(u\)</span>.
When the values are zero (<span class="math">\(\partial u/\partial n=0\)</span> or <span class="math">\(u=0\)</span>) we speak
about <em>homogeneous</em> Neumann or Dirichlet conditions.</p>
</div>
</div>
<div class="section" id="discretization-of-derivatives-at-the-boundary">
<span id="wave-pde2-neumann-discr"></span><h2>Discretization of derivatives at the boundary<a class="headerlink" href="#discretization-of-derivatives-at-the-boundary" title="Permalink to this headline">¶</a></h2>
<p>How can we incorporate the condition <a href="#equation-wave:pde1:Neumann:0">(22)</a>
in the finite difference scheme?  Since we have used central
differences in all the other approximations to derivatives in the
scheme, it is tempting to implement <a href="#equation-wave:pde1:Neumann:0">(22)</a> at
<span class="math">\(x=0\)</span> and <span class="math">\(t=t_n\)</span> by the difference</p>
<div class="math" id="equation-wave:pde1:Neumann:0:cd">
<span class="eqno">(23)</span>\[     \frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
     \thinspace .\]</div>
<p>The problem is that <span class="math">\(u_{-1}^n\)</span> is not a <span class="math">\(u\)</span> value that is being
computed since the point is outside the mesh. However, if we combine
<a href="#equation-wave:pde1:Neumann:0:cd">(23)</a> with the scheme
.. <a href="#equation-wave:pde1:step4">(10)</a></p>
<p>for <span class="math">\(i=0\)</span>,</p>
<div class="math" id="equation-wave:pde1:Neumann:0:scheme">
<span class="eqno">(24)</span>\[     u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
     \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),\]</div>
<p>we can eliminate the fictitious value <span class="math">\(u_{-1}^n\)</span>. We see that
<span class="math">\(u_{-1}^n=u_1^n\)</span> from <a href="#equation-wave:pde1:Neumann:0:cd">(23)</a>, which
can be used in <a href="#equation-wave:pde1:Neumann:0:scheme">(24)</a> to
arrive at a modified scheme for the boundary point <span class="math">\(u_0^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1}_i = -u^{n-1}_i  + 2u^n_i + 2C^2
\left(u^{n}_{i+1}-u^{n}_{i}\right),\quad i=0 \thinspace .\]</div>
<p>Figure <a class="reference internal" href="#wave-pde1-fig-neumann-stencil"><em>Modified stencil at a boundary with a Neumann condition</em></a> visualizes this equation
for computing <span class="math">\(u^3_0\)</span> in terms of <span class="math">\(u^2_0\)</span>, <span class="math">\(u^1_0\)</span>, and
<span class="math">\(u^2_1\)</span>.</p>
<div class="figure" id="wave-pde1-fig-neumann-stencil">
<span id="index-19"></span><img alt="_images/wave_PDE_Neumann_n_left1.png" src="_images/wave_PDE_Neumann_n_left1.png" style="width: 500px;" />
<p class="caption"><em>Modified stencil at a boundary with a Neumann condition</em></p>
</div>
<p>Similarly, <a href="#equation-wave:pde1:Neumann:0">(22)</a> applied at <span class="math">\(x=L\)</span>
is discretized by a central difference</p>
<div class="math" id="equation-wave:pde1:Neumann:0:cd2">
<span class="eqno">(25)</span>\[     \frac{u_{N_x+1}^n - u_{N_x-1}^n}{2\Delta x} = 0
     \thinspace .\]</div>
<p>Combined with the scheme for <span class="math">\(i=N_x\)</span> we get a modified scheme for
the boundary value <span class="math">\(u_{N_x}^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1}_i = -u^{n-1}_i + 2u^n_i + 2C^2
\left(u^{n}_{i-1}-u^{n}_{i}\right),\quad i=N_x \thinspace .\]</div>
<p>The modification of the scheme at the boundary is also required for
the special formula for the first time step. How the stencil moves
through the mesh and is modified at the boundary can be illustrated
by an animation
in a <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.flv">movie file</a>.</p>
</div>
<div class="section" id="implementation-of-neumann-conditions">
<span id="wave-pde2-neumann-impl"></span><h2>Implementation of Neumann conditions<a class="headerlink" href="#implementation-of-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>The implementation of the special formulas for the boundary points
can benefit from using the general formula for the interior points
also at the boundaries,
but replacing <span class="math">\(u_{i-1}^n\)</span> by <span class="math">\(u_{i+1}^n\)</span> when computing
<span class="math">\(u_i^{n+1}\)</span> for <span class="math">\(i=0\)</span> and
<span class="math">\(u_{i+1}^n\)</span> by <span class="math">\(u_{i-1}^n\)</span> for <span class="math">\(i=N_x\)</span>. This is achieved by
just replacing the index
<span class="math">\(i-1\)</span> by <span class="math">\(i+1\)</span> for <span class="math">\(i=0\)</span> and <span class="math">\(i+1\)</span> by <span class="math">\(i-1\)</span> for
<span class="math">\(i=N_x\)</span>. In a program, we introduce variables to hold the value of
the offset indices: <tt class="docutils literal"><span class="pre">im1</span></tt> for <tt class="docutils literal"><span class="pre">i-1</span></tt> and <tt class="docutils literal"><span class="pre">ip1</span></tt> for <tt class="docutils literal"><span class="pre">i+1</span></tt>.
It is now just a manner of defining <tt class="docutils literal"><span class="pre">im1</span></tt> and <tt class="docutils literal"><span class="pre">ip1</span></tt> properly
for the internal points and the boundary points.
The coding for the latter reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">ip1</span>  <span class="c"># i-1 -&gt; i+1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">im1</span>  <span class="c"># i+1 -&gt; i-1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>
</pre></div>
</div>
<p>We can in fact create one loop over both the internal and boundary
points and use only one updating formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="k">else</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="k">else</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>
</pre></div>
</div>
<p>The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn0.py">wave1D_dn0.py</a>
contains a complete implementation of the 1D wave equation with
boundary conditions <span class="math">\(u_x = 0\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>.</p>
</div>
<div class="section" id="index-set-notation">
<span id="wave-indexset"></span><h2>Index set notation<a class="headerlink" href="#index-set-notation" title="Permalink to this headline">¶</a></h2>
<p id="index-20">We shall introduce a special notation for index sets, consisting of
writing <span class="math">\(x_i\)</span>, <span class="math">\(i\in{\mathcal{I}_x}\)</span>, instead of <span class="math">\(i=0,\ldots,N_x\)</span>.
Obviously, <span class="math">\({\mathcal{I}_x}\)</span> must be the set <span class="math">\({\mathcal{I}_x} =\{0,\ldots,N_x\}\)</span>, but it
is often advantageous to have a symbol for this set rather than
specifying all its elements. This saves writing and makes
specification of algorithms and implementation of computer code easier.</p>
<p>The first index in the set will be denoted <span class="math">\({{\mathcal{I^0}_x}}\)</span>
and the last <span class="math">\({\mathcal{I^{-1}_x}}\)</span>. Sometimes we need to count from the second
element in the set, and the notation <span class="math">\({{\mathcal{I^+}_x}}\)</span> is then used.
Correspondingly, <span class="math">\({{\mathcal{I^-}_x}}\)</span> means <span class="math">\(\{0,\ldots,N_x-1\}\)</span>.  All the
indices corresponding to inner grid points are
<span class="math">\({{\mathcal{I^i}_x}}=\{1,\ldots,N_x-1\}\)</span>.  For the time domain we find it
natural to explicitly use 0 as the first index, so we will usually
write <span class="math">\(n=0\)</span> and <span class="math">\(t_0\)</span> rather than <span class="math">\(n={\mathcal{I}_t}^0\)</span>. We also avoid notation
like <span class="math">\(x_{{\mathcal{I^{-1}_x}}}\)</span> and will instead use <span class="math">\(x_i\)</span>, <span class="math">\(i={\mathcal{I^{-1}_x}}\)</span>.</p>
<p>The Python code associated with index sets applies the following
conventions:</p>
<p>An important feature of the index set notation is that it
keeps our formulas and code independent of how
we count mesh points. For example, the notation <span class="math">\(i\in{\mathcal{I}_x}\)</span> or <span class="math">\(i={{\mathcal{I^0}_x}}\)</span>
remains the same whether <span class="math">\({\mathcal{I}_x}\)</span> is defined as above or as starting at 1,
i.e., <span class="math">\({\mathcal{I}_x}=\{1,\ldots,Q\}\)</span>. Similarly, we can in the code define
<tt class="docutils literal"><span class="pre">Ix=range(Nx+1)</span></tt> or <tt class="docutils literal"><span class="pre">Ix=range(1,Q)</span></tt>, and expressions
like <tt class="docutils literal"><span class="pre">Ix[0]</span></tt> and <tt class="docutils literal"><span class="pre">Ix[1:-1]</span></tt> remain correct. One application where
the index set notation is convenient is
conversion of code from a language where arrays has base index 0 (e.g.,
Python and C) to languages where the base index is 1 (e.g., MATLAB and
Fortran). Another important application is implementation of
Neumann conditions via ghost points (see next section).</p>
<p>For the current problem setting in the <span class="math">\(x,t\)</span> plane, we work with
the index sets</p>
<div class="math">
\[{\mathcal{I}_x} = \{0,\ldots,N_x\},\quad {\mathcal{I}_t} = \{0,\ldots,N_t\},\]</div>
<p>defined in Python as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">It</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>A finite difference scheme can with the index set notation be specified as</p>
<div class="math">
\[\begin{split}u^{n+1}_i &amp;= -u^{n-1}_i  + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i}+u^{n}_{i-1}\right),
\quad i\in{{\mathcal{I^i}_x}},\ n\in{{\mathcal{I^i}_t}},\\
u_i &amp;= 0,
\quad i={{\mathcal{I^0}_x}},\ n\in{{\mathcal{I^i}_t}},\\
u_i &amp;= 0,
\quad i={\mathcal{I^{-1}_x}},\ n\in{{\mathcal{I^i}_t}},\end{split}\]</div>
<p>and implemented by code like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
               <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn.py">wave1D_dn.py</a>
applies the index set notation and
solves the 1D wave equation <span class="math">\(u_{tt}=c^2u_{xx}+f(x,t)\)</span> with
quite general boundary and initial conditions:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(x=0\)</span>: <span class="math">\(u=U_0(t)\)</span> or <span class="math">\(u_x=0\)</span></li>
<li><span class="math">\(x=L\)</span>: <span class="math">\(u=U_L(t)\)</span> or <span class="math">\(u_x=0\)</span></li>
<li><span class="math">\(t=0\)</span>: <span class="math">\(u=I(x)\)</span></li>
<li><span class="math">\(t=0\)</span>: <span class="math">\(u_t=I(x)\)</span></li>
</ul>
</div></blockquote>
<p>The program combines Dirichlet and Neumann conditions, scalar and vectorized
implementation of schemes, and the index notation into one piece of code.
A lot of test examples are also included in the program:</p>
<blockquote class="last">
<div><ul class="simple">
<li>A rectangular plug profile as initial condition (easy to use as
test example as the rectangle should jump one cell per time
step when <span class="math">\(C=1\)</span>, without any numerical errors).</li>
<li>A Gaussian function as initial condition.</li>
<li>A triangular profile as initial condition, which resembles the
typical initial shape of a guitar string.</li>
<li>A sinusoidal variation of <span class="math">\(u\)</span> at <span class="math">\(x=0\)</span> and either <span class="math">\(u=0\)</span> or
<span class="math">\(u_x=0\)</span> at <span class="math">\(x=L\)</span>.</li>
<li>An exact analytical solution <span class="math">\(u(x,t)=\cos(m\pi t/L)\sin(\frac{1}{2}m\pi x/L)\)</span>, which can be used for convergence rate tests.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="alternative-implementation-via-ghost-cells">
<span id="wave-pde1-neumann-ghost"></span><h2>Alternative implementation via ghost cells<a class="headerlink" href="#alternative-implementation-via-ghost-cells" title="Permalink to this headline">¶</a></h2>
<div class="section" id="idea">
<h3>Idea<a class="headerlink" href="#idea" title="Permalink to this headline">¶</a></h3>
<p>Instead of modifying the scheme at the boundary, we can introduce
extra points outside the domain such that the fictitious values
<span class="math">\(u_{-1}^n\)</span> and <span class="math">\(u_{N_x+1}^n\)</span>
are defined in the mesh.
Adding the intervals <span class="math">\([-\Delta x,0]\)</span> and <span class="math">\([L, L+\Delta x]\)</span>,
often referred to as <em>ghost cells</em>, to the mesh gives us all the
needed mesh points, corresponding to <span class="math">\(i=-1,0,\ldots,N_x,N_x+1\)</span>.
The extra points <span class="math">\(i=-1\)</span> and <span class="math">\(i=N_x+1\)</span> are known as <em>ghost points</em>,
and values at these points, <span class="math">\(u_{-1}^n\)</span> and <span class="math">\(u_{N_x+1}^n\)</span>, are
called <em>ghost values</em>.</p>
<p>The important idea is
to ensure that we always have</p>
<div class="math">
\[u_{-1}^n = u_{1}^n\hbox{ and } u_{N_x-1}^n = u_{N_x+1}^n,\]</div>
<p>because then
the application of the standard scheme at a boundary point <span class="math">\(i=0\)</span> or <span class="math">\(i=N_x\)</span>
will be correct and guarantee that the solution is compatible with the
boundary condition <span class="math">\(u_x=0\)</span>.</p>
</div>
<div class="section" id="implementation-2">
<h3>Implementation  (2)<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">u</span></tt> array now needs extra elements corresponding to the ghost cells
and points. Two new point values are needed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The arrays <tt class="docutils literal"><span class="pre">u_1</span></tt> and <tt class="docutils literal"><span class="pre">u_2</span></tt> must be defined accordingly.</p>
<p>Unfortunately, a major indexing problem arises with ghost cells.
The reason is that Python indices <em>must</em> start
at 0 and <tt class="docutils literal"><span class="pre">u[-1]</span></tt> will always mean the last element in <tt class="docutils literal"><span class="pre">u</span></tt>.
This fact gives, apparently, a mismatch between the mathematical
indices <span class="math">\(i=-1,0,\ldots,N_x+1\)</span> and the Python indices running over
<tt class="docutils literal"><span class="pre">u</span></tt>: <tt class="docutils literal"><span class="pre">0,..,Nx+2</span></tt>. One remedy is to change the mathematical notation
of the scheme, as in</p>
<div class="math">
\[u^{n+1}_i = \cdots,\quad i=1,\ldots,N_x+1,\]</div>
<p>meaning that the ghost points correspond to <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x+1\)</span>.
A better solution is to use the ideas of the section <a class="reference internal" href="#wave-indexset"><em>Index set notation</em></a>:
we hide the specific index value in an index set and operate with
inner and boundary points using the index set notation.</p>
<p>To this end, we define <tt class="docutils literal"><span class="pre">u</span></tt> with proper length and <tt class="docutils literal"><span class="pre">Ix</span></tt> to be the corresponding
indices for the real physical points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, the boundary points have indices <tt class="docutils literal"><span class="pre">Ix[0]</span></tt> and <tt class="docutils literal"><span class="pre">Ix[-1]</span></tt> (as before).
We first update the solution at all physical mesh points (i.e., interior
points in the mesh extended with ghost cells):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>It remains to update the ghost points. For a boundary condition <span class="math">\(u_x=0\)</span>,
the ghost value must equal to the value at the associated inner mesh
point. Computer code makes this statement precise:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c"># x=0 boundary</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>         <span class="c"># x=L boundary</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The physical solution to be plotted is now in <tt class="docutils literal"><span class="pre">u[1:-1]</span></tt>, so this slice is
the quantity to be returned from a solver function.
A complete implementation appears in the program
<a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn0_ghost.py">wave1D_dn0_ghost.py</a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>We have to be careful with how the spatial and temporal mesh
points are stored. Say we let <tt class="docutils literal"><span class="pre">x</span></tt> be the physical mesh points,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>&#8220;Standard coding&#8221; of the initial condition,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>becomes wrong, since <tt class="docutils literal"><span class="pre">u_1</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> have different lengths and the index <tt class="docutils literal"><span class="pre">i</span></tt>
corresponds to two different mesh points. In fact, <tt class="docutils literal"><span class="pre">x[i]</span></tt> corresponds
to <tt class="docutils literal"><span class="pre">u[1+i]</span></tt>. A correct implementation is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Similarly, a source term usually coded as <tt class="docutils literal"><span class="pre">f(x[i],</span> <span class="pre">t[n])</span></tt> is incorrect
if <tt class="docutils literal"><span class="pre">x</span></tt> is defined to be the physical points.</p>
<p class="last">An alternative remedy is to let <tt class="docutils literal"><span class="pre">x</span></tt> also cover the ghost points such that
<tt class="docutils literal"><span class="pre">u[i]</span></tt> is the value at <tt class="docutils literal"><span class="pre">x[i]</span></tt>.</p>
</div>
<p>The ghost cell is only added to the boundary where we have a Neumann
condition. Suppose we have a Dirichlet condition at <span class="math">\(x=L\)</span> and
a homogeneous Neumann condition at <span class="math">\(x=0\)</span>. The relevant implementation
then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
           <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0</span>       <span class="c"># set Dirichlet value</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># update ghost value</span>
</pre></div>
</div>
<p>The physical solution to be plotted is now in <tt class="docutils literal"><span class="pre">u[1:]</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="generalization-variable-wave-velocity">
<span id="wave-pde2-var-c"></span><h1>Generalization: variable wave velocity<a class="headerlink" href="#generalization-variable-wave-velocity" title="Permalink to this headline">¶</a></h1>
<p>Our next generalization of the 1D wave equation <a href="#equation-wave:pde1">(1)</a> or
<a href="#equation-wave:pde2">(12)</a> is to allow for a variable wave velocity <span class="math">\(c\)</span>:
<span class="math">\(c=c(x)\)</span>, usually motivated by wave motion in a domain composed of
different physical media with different properties for
propagating waves and hence different wave velocities <span class="math">\(c\)</span>.
Figure</p>
<div class="figure" id="wave-pde1-fig-pulse1-two-media">
<img alt="_images/pulse1_in_two_media1.png" src="_images/pulse1_in_two_media1.png" style="width: 800px;" />
<p class="caption"><em>Left: wave entering another medium; right: transmitted and reflected wave</em></p>
</div>
<div class="section" id="the-model-pde-with-a-variable-coefficient">
<h2>The model PDE with a variable coefficient<a class="headerlink" href="#the-model-pde-with-a-variable-coefficient" title="Permalink to this headline">¶</a></h2>
<p>Instead of working with the squared quantity <span class="math">\(c^2(x)\)</span> we
shall for notational convenience introduce <span class="math">\(q(x) = c^2(x)\)</span>.
A 1D wave equation with variable wave velocity often takes the form</p>
<div class="math" id="equation-wave:pde2:var:c:pde">
<span class="eqno">(26)</span>\[     \frac{\partial^2 u}{\partial t^2} =
     \frac{\partial}{\partial x}\left( q(x)
     \frac{\partial u}{\partial x}\right) + f(x,t)\]\[     \thinspace .\]</div>
<p>This equation sampled at a mesh point <span class="math">\((x_i,t_n)\)</span> reads</p>
<div class="math">
\[\frac{\partial^2 }{\partial t^2} u(x_i,t_n) =
\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) + f(x_i,t_n),\]</div>
<p>where the only new term is</p>
<div class="math">
\[\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) = \left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\thinspace .\]</div>
</div>
<div class="section" id="discretizing-the-variable-coefficient">
<span id="wave-pde2-var-c-ideas"></span><h2>Discretizing the variable coefficient<a class="headerlink" href="#discretizing-the-variable-coefficient" title="Permalink to this headline">¶</a></h2>
<p>The principal idea is to first discretize the outer derivative.
Define</p>
<div class="math">
\[\phi = q(x)
\frac{\partial u}{\partial x},\]</div>
<p>and use a centered derivative around <span class="math">\(x=x_i\)</span> for the derivative of <span class="math">\(\phi\)</span>:</p>
<div class="math">
\[\left[\frac{\partial\phi}{\partial x}\right]^n_i
\approx \frac{\phi_{i+\frac{1}{2}} - \phi_{i-\frac{1}{2}}}{\Delta x}
= [D_x\phi]^n_i
\thinspace .\]</div>
<p>Then discretize</p>
<div class="math">
\[\phi_{i+\frac{1}{2}}  = q_{i+\frac{1}{2}}
\left[\frac{\partial u}{\partial x}\right]^n_{i+\frac{1}{2}}
\approx q_{i+\frac{1}{2}} \frac{u^n_{i+1} - u^n_{i}}{\Delta x}
= [q D_x u]_{i+\frac{1}{2}}^n
\thinspace .\]</div>
<p>Similarly,</p>
<div class="math">
\[\phi_{i-\frac{1}{2}}  = q_{i-\frac{1}{2}}
\left[\frac{\partial u}{\partial x}\right]^n_{i-\frac{1}{2}}
\approx q_{i-\frac{1}{2}} \frac{u^n_{i} - u^n_{i-1}}{\Delta x}
= [q D_x u]_{i-\frac{1}{2}}^n
\thinspace .\]</div>
<p>These intermediate results are now combined to</p>
<div class="math" id="equation-wave:pde2:var:c:formula">
<span class="eqno">(27)</span>\[     \left[
     \frac{\partial}{\partial x}\left( q(x)
     \frac{\partial u}{\partial x}\right)\right]^n_i
     \approx \frac{1}{\Delta x^2}
     \left( q_{i+\frac{1}{2}} \left({u^n_{i+1} - u^n_{i}}\right)
     - q_{i-\frac{1}{2}} \left({u^n_{i} - u^n_{i-1}}\right)\right)\]\[     \thinspace .\]</div>
<p>With operator notation we can write the discretization as</p>
<div class="math" id="equation-wave:pde2:var:c:formula:op">
<span class="eqno">(28)</span>\[     \left[
     \frac{\partial}{\partial x}\left( q(x)
     \frac{\partial u}{\partial x}\right)\right]^n_i
     \approx [D_xq D_x u]^n_i\]\[     \thinspace .\]</div>
<div class="admonition-remark admonition">
<p class="first admonition-title">Remark</p>
<p class="last"><em>Remark.</em> Many are tempted to use the chain rule on the
term <span class="math">\(\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\)</span>, but this is not a good idea
when discretizing such a term.</p>
</div>
</div>
<div class="section" id="computing-the-coefficient-between-mesh-points">
<span id="wave-pde2-var-c-means"></span><h2>Computing the coefficient between mesh points<a class="headerlink" href="#computing-the-coefficient-between-mesh-points" title="Permalink to this headline">¶</a></h2>
<p>If <span class="math">\(q\)</span> is a known function of <span class="math">\(x\)</span>, we can easily evaluate
<span class="math">\(q_{i+\frac{1}{2}}\)</span> simply as <span class="math">\(q(x_{i+\frac{1}{2}})\)</span> with
<span class="math">\(x_{i+\frac{1}{2}} = x_i + \frac{1}{2}\Delta x\)</span>.
However, in many cases <span class="math">\(c\)</span>, and hence <span class="math">\(q\)</span>,
is only known as a discrete function, often at the mesh points <span class="math">\(x_i\)</span>.
Evaluating <span class="math">\(q\)</span> between two mesh points <span class="math">\(x_i\)</span> and <span class="math">\(x_{i+1}\)</span> can then
be done by averaging in three ways:</p>
<span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><span class="target" id="index-24"></span><span class="target" id="index-25"></span><div class="math" id="equation-wave:pde2:var:c:mean:arithmetic">
<span id="index-26"></span><span class="eqno">(29)</span>\[     q_{i+\frac{1}{2}} \approx
     \frac{1}{2}\left( q_{i} + q_{i+1}\right) =
     [\overline{q}^{x}]_i,
     \quad \hbox{(arithmetic mean)}\]</div>
<div class="math" id="equation-wave:pde2:var:c:mean:harmonic">
<span class="eqno">(30)</span>\[     q_{i+\frac{1}{2}} \approx
     2\left( \frac{1}{q_{i}} + \frac{1}{q_{i+1}}\right)^{-1},
     \quad \hbox{(harmonic mean)}\]</div>
<div class="math" id="equation-wave:pde2:var:c:mean:geometric">
<span class="eqno">(31)</span>\[     q_{i+\frac{1}{2}} \approx
     \left(q_{i}q_{i+1}\right)^{1/2},
     \quad \hbox{(geometric mean)}\]</div>
<p>The arithmetic mean in <a href="#equation-wave:pde2:var:c:mean:arithmetic">(29)</a> is by
far the most commonly used averaging technique.</p>
<p>With the operator notation from <a href="#equation-wave:pde2:var:c:mean:arithmetic">(29)</a>
we can specify the discretization of the complete variable-coefficient
wave equation in a compact way:</p>
<div class="math" id="equation-wave:pde2:var:c:scheme:op">
<span class="eqno">(32)</span>\[     \lbrack D_tD_t u = D_x\overline{q}^{x}D_x u + f\rbrack^{n}_i
     \thinspace .\]</div>
<p>From this notation we immediately see what kind of differences that
each term is approximated with. The notation <span class="math">\(\overline{q}^{x}\)</span>
also specifies that the variable coefficient is approximated by
an arithmetic mean, the definition being
<span class="math">\([\overline{q}^{x}]_{i+\frac{1}{2}}=(q_i+q_{i+1})/2\)</span>.
With the notation <span class="math">\([D_xq D_x u]^n_i\)</span>,
we specify that <span class="math">\(q\)</span> is evaluated directly, as a function,
between the mesh points:
<span class="math">\(q(x_{i-\frac{1}{2}})\)</span> and <span class="math">\(q(x_{i+\frac{1}{2}})\)</span>.</p>
<p>Before any implementation, it remains to solve
<a href="#equation-wave:pde2:var:c:scheme:op">(32)</a> with respect to <span class="math">\(u_i^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math">
\[\quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
\frac{1}{2}(q_{i} + q_{i+1})(u_{i+1}^n - u_{i}^n) -
\frac{1}{2}(q_{i} + q_{i-1})(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\]</div>
<div class="math" id="equation-wave:pde2:var:c:scheme:impl">
<span class="eqno">(33)</span>\[      \quad \Delta t^2 f^n_i
     \thinspace .\]</div>
</div>
<div class="section" id="how-a-variable-coefficient-affects-the-stability">
<span id="wave-pde2-var-c-stability"></span><h2>How a variable coefficient affects the stability<a class="headerlink" href="#how-a-variable-coefficient-affects-the-stability" title="Permalink to this headline">¶</a></h2>
<p>The stability criterion derived in the section <em class="xref std std-ref">wave:pde1:analysis</em>
reads <span class="math">\(\Delta t\leq \Delta x/c\)</span>. If <span class="math">\(c=c(x)\)</span>, the criterion will depend
on the spatial location. We must therefore choose a <span class="math">\(\Delta t\)</span> that
is small enough such that no mesh cell has <span class="math">\(\Delta x/c(x) &gt;\Delta t\)</span>.
That is, we must use the largest <span class="math">\(c\)</span> value in the criterion:</p>
<div class="math">
\[\Delta t \leq \beta \frac{\Delta x}{\max_{x\in [0,L]}c(x)}
\thinspace .\]</div>
<p>The parameter <span class="math">\(\beta\)</span> is included as a safety factor: in some problems with a
significantly varying <span class="math">\(c\)</span> it turns out that one must choose <span class="math">\(\beta &lt;1\)</span> to
have stable solutions (<span class="math">\(\beta =0.9\)</span> may act as an all-round value).</p>
</div>
<div class="section" id="neumann-condition-and-a-variable-coefficient">
<span id="wave-pde2-var-c-neumann"></span><h2>Neumann condition and a variable coefficient<a class="headerlink" href="#neumann-condition-and-a-variable-coefficient" title="Permalink to this headline">¶</a></h2>
<p>Consider a Neumann condition <span class="math">\(\partial u/\partial x=0\)</span> at <span class="math">\(x=L=N_x\Delta x\)</span>,
discretized as</p>
<div class="math">
\[\frac{u_{i+1}^{n} - u_{i-1}^n}{2\Delta x} = 0\quad u_{i+1}^n = u_{i-1}^n,\]</div>
<p>for <span class="math">\(i=N_x\)</span>. Using the scheme <a href="#equation-wave:pde2:var:c:scheme:impl">(33)</a>
at the end point <span class="math">\(i=N_x\)</span> with <span class="math">\(u_{i+1}^n=u_{i-1}^n\)</span> results in</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math">
\[\quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
q_{i+\frac{1}{2}}(u_{i-1}^n - u_{i}^n) -
q_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\]</div>
<div class="math">
\[\quad \Delta t^2 f^n_i\]</div>
<div class="math">
\[= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
(q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}})(u_{i-1}^n - u_{i}^n) +
\Delta t^2 f^n_i\]</div>
<div class="math" id="equation-wave:pde2:var:c:scheme:impl:Neumann">
<span class="eqno">(34)</span>\[     \approx - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
     2q_{i}(u_{i-1}^n - u_{i}^n) + \Delta t^2 f^n_i
     \thinspace .\]</div>
<p>Here we used the approximation</p>
<div class="math">
\[q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}} =
q_i + \left(\frac{dq}{dx}\right)_i \Delta x
+ \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots
+\nonumber\]</div>
<div class="math">
\[\quad q_i - \left(\frac{dq}{dx}\right)_i \Delta x
+ \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots\nonumber\]</div>
<div class="math">
\[= 2q_i + 2\left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + {\cal O}(\Delta x^4)
\nonumber\]</div>
<div class="math">
\[\approx 2q_i
\thinspace .\]</div>
<p>An alternative derivation may apply the arithmetic mean of <span class="math">\(q\)</span> in
<a href="#equation-wave:pde2:var:c:scheme:impl">(33)</a>, leading to the term</p>
<div class="math">
\[(q_i + \frac{1}{2}(q_{i+1}+q_{i-1}))(u_{i-1}^n-u_i^n){\thinspace .}\]</div>
<p>Since <span class="math">\(\frac{1}{2}(q_{i+1}+q_{i-1}) = q_i + {\cal O}(\Delta x^2)\)</span>,
we end up with <span class="math">\(2q_i(u_{i-1}^n-u_i^n)\)</span> for <span class="math">\(i=N_x\)</span> as we did above.</p>
<p>A common technique in implementations of <span class="math">\(\partial u/\partial x=0\)</span>
boundary conditions is to assume <span class="math">\(dq/dx=0\)</span> as well. This implies
<span class="math">\(q_{i+1}=q_{i-1}\)</span> and <span class="math">\(q_{i+1/2}=q_{i-1/2}\)</span> for <span class="math">\(i=N_x\)</span>.
The implications for the scheme are</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math">
\[\quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
q_{i+\frac{1}{2}}(u_{i-1}^n - u_{i}^n) -
q_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\]</div>
<div class="math">
\[\quad \Delta t^2 f^n_i\]</div>
<div class="math" id="equation-wave:pde2:var:c:scheme:impl:Neumann2">
<span class="eqno">(35)</span>\[     = - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
     2q_{i-\frac{1}{2}}(u_{i-1}^n - u_{i}^n) +
     \Delta t^2 f^n_i
     \thinspace .\]</div>
</div>
<div class="section" id="implementation-of-variable-coefficients">
<span id="wave-pde2-var-c-impl"></span><h2>Implementation of variable coefficients<a class="headerlink" href="#implementation-of-variable-coefficients" title="Permalink to this headline">¶</a></h2>
<p>The implementation of the scheme with a variable wave velocity
may assume that <span class="math">\(c\)</span> is available as an array <tt class="docutils literal"><span class="pre">c[i]</span></tt> at
the mesh points. The following loop is a straightforward
implementation of the scheme <a href="#equation-wave:pde2:var:c:scheme:impl">(33)</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="o">-</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> \
           <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>The coefficient <tt class="docutils literal"><span class="pre">C2</span></tt> is now defined as <tt class="docutils literal"><span class="pre">(dt/dx)**2</span></tt> and <em>not</em> as the
squared Courant number since the wave velocity is variable and appears
inside the parenthesis.</p>
<p>With Neumann conditions <span class="math">\(u_x=0\)</span> at the
boundary, we need to combine this scheme with the discrete
version of the boundary condition, as shown in the section <a class="reference internal" href="#wave-pde2-var-c-neumann"><em>Neumann condition and a variable coefficient</em></a>.
Nevertheless, it would be convenient to reuse the formula for the
interior points and just modify the indices <tt class="docutils literal"><span class="pre">ip1=i+1</span></tt> and <tt class="docutils literal"><span class="pre">im1=i-1</span></tt>
as we did in the section <a class="reference internal" href="#wave-pde2-neumann-impl"><em>Implementation of Neumann conditions</em></a>. Assuming
<span class="math">\(dq/dx=0\)</span> at the boundaries, we can implement the scheme at
the boundary with the following code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">ip1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
       <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="o">-</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">im1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]))</span> <span class="o">+</span> \
       <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>With ghost cells we can just reuse the formula for the interior
points also at the boundary, provided that the ghost values of both
<span class="math">\(u\)</span> and <span class="math">\(q\)</span> are correctly updated to ensure <span class="math">\(u_x=0\)</span> and <span class="math">\(q_x=0\)</span>.</p>
<p>A vectorized version of the scheme with a variable coefficient
at internal points in the mesh becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
              <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> \
          <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="a-more-general-model-pde-with-variable-coefficients">
<h2>A more general model PDE with variable coefficients<a class="headerlink" href="#a-more-general-model-pde-with-variable-coefficients" title="Permalink to this headline">¶</a></h2>
<p>Sometimes a wave PDE has a variable coefficient also in front of
the time-derivative term:</p>
<div class="math" id="equation-wave:pde2:var:c:pde2">
<span class="eqno">(36)</span>\[     \varrho(x)\frac{\partial^2 u}{\partial t^2} =
     \frac{\partial}{\partial x}\left( q(x)
     \frac{\partial u}{\partial x}\right) + f(x,t)\]\[     \thinspace .\]</div>
<p>A natural scheme is</p>
<div class="math">
\[[\varrho D_tD_t u = D_x\overline{q}^xD_x u + f]^n_i
\thinspace .\]</div>
<p>We realize that the <span class="math">\(\varrho\)</span> coefficient poses no particular
difficulty because the only value <span class="math">\(\varrho_i^n\)</span> enters the formula
above (when written out). There is hence no need for any averaging
of <span class="math">\(\varrho\)</span>. Often, <span class="math">\(\varrho\)</span> will be moved to the right-hand side,
also without any difficulty:</p>
<div class="math">
\[[D_tD_t u = \varrho^{-1}D_x\overline{q}^xD_x u + f]^n_i
\thinspace .\]</div>
</div>
<div class="section" id="generalization-damping">
<h2>Generalization: damping<a class="headerlink" href="#generalization-damping" title="Permalink to this headline">¶</a></h2>
<p>Waves die out by two mechanisms. In 2D and 3D the energy of the wave
spreads out in space, and energy conservation then requires
the amplitude to decrease. This effect is not present in 1D.
Damping is another cause of amplitude reduction. For example,
the vibrations of a string die out because of damping due to
air resistance and non-elastic effects in the string.</p>
<p>The simplest way of including damping is to add a first-order derivative
to the equation (in the same way as friction forces enter a vibrating
mechanical system):</p>
<div class="math" id="equation-wave:pde3">
<span class="eqno">(37)</span>\[     \frac{\partial^2 u}{\partial t^2} + b\frac{\partial u}{\partial t} =
     c^2\frac{\partial^2 u}{\partial x^2}
      + f(x,t),\]</div>
<p>where <span class="math">\(b \geq 0\)</span> is a prescribed damping coefficient.</p>
<p>A typical discretization of <a href="#equation-wave:pde3">(37)</a> in terms of centered
differences reads</p>
<div class="math" id="equation-wave:pde3:fd">
<span class="eqno">(38)</span>\[     [D_tD_t u + bD_{2t}u = c^2D_xD_x u + f]^n_i
     \thinspace .\]</div>
<p>Writing out the equation and solving for the unknown <span class="math">\(u^{n+1}_i\)</span>
gives the scheme</p>
<div class="math" id="equation-wave:pde3:fd2">
<span class="eqno">(39)</span>\[     u^{n+1}_i = (1 + \frac{1}{2}b\Delta t)^{-1}((\frac{1}{2}b\Delta t -1)
     u^{n-1}_i + 2u^n_i + C^2
     \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \Delta t^2 f^n_i),\]</div>
<p>for <span class="math">\(i\in{{\mathcal{I^i}_x}}\)</span> and <span class="math">\(n\geq 1\)</span>.
New equations must be derived for <span class="math">\(u^1_i\)</span>, and for boundary points in case
of Neumann conditions.</p>
<p>The damping is very small in many wave phenomena and then only evident
for very long time simulations. This makes the standard wave equation
without damping relevant for a lot of applications.</p>
</div>
</div>
<div class="section" id="building-a-general-1d-wave-equation-solver">
<span id="wave-pde2-software"></span><h1>Building a general 1D wave equation solver<a class="headerlink" href="#building-a-general-1d-wave-equation-solver" title="Permalink to this headline">¶</a></h1>
<p>The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py">wave1D_dn_vc.py</a>
is a fairly general code for 1D wave propagation problems that
targets the following initial-boundary value problem</p>
<div class="math" id="equation-wave:pde2:software:ueq">
<span class="eqno">(40)</span>\[     u_t = (c^2(x)u_x)_x + f(x,t),\quad x\in (0,L),\ t\in (0,T],\]</div>
<div class="math">
\[u(x,0) = I(x),\quad x\in [0,L],\]</div>
<div class="math">
\[u_t(x,0) = V(t),\quad x\in [0,L],\]</div>
<div class="math">
\[u(0,t) = U_0(t)\hbox{ or } u_x(0,t)=0,\quad t\in (0,T],\]</div>
<div class="math" id="equation-wave:pde2:software:bcL">
<span class="eqno">(41)</span>\[     u(L,t) = U_L(t)\hbox{ or } u_x(L,t)=0,\quad t\in (0,T]\]</div>
<p>The <tt class="docutils literal"><span class="pre">solver</span></tt> function is a natural extension of the simplest
<tt class="docutils literal"><span class="pre">solver</span></tt> function in the initial <tt class="docutils literal"><span class="pre">wave1D_u0_s.py</span></tt> program,
extended with Neumann boundary conditions (<span class="math">\(u_x=0\)</span>),
a possibly time-varying boundary condition on <span class="math">\(u\)</span> (<span class="math">\(U_0(t)\)</span>, <span class="math">\(U_L(t)\)</span>),
and a variable wave velocity. The different code segments needed
to make these extensions are shown and commented upon in the
preceding text.</p>
<p>The vectorization is only applied inside the time loop, not for the
initial condition or the first time steps, since this initial work
is negligible for long time simulations in 1D problems.</p>
<p>The following sections explain various more advanced programming
techniques applied in the general 1D wave equation solver.</p>
<div class="section" id="user-action-function-as-a-class">
<h2>User action function as a class<a class="headerlink" href="#user-action-function-as-a-class" title="Permalink to this headline">¶</a></h2>
<p>A useful feature in the <tt class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></tt> program is the specification of
the <tt class="docutils literal"><span class="pre">user_action</span></tt> function as a class. Although the <tt class="docutils literal"><span class="pre">plot_u</span></tt>
function in the <tt class="docutils literal"><span class="pre">viz</span></tt> function of previous <tt class="docutils literal"><span class="pre">wave1D*.py</span></tt> programs
remembers the local variables in the <tt class="docutils literal"><span class="pre">viz</span></tt> function, it is a
cleaner solution to store the needed variables together with
the function, which is exactly what a class offers.</p>
<p>A class for flexible plotting, cleaning up files, and making a movie
files like function <tt class="docutils literal"><span class="pre">viz</span></tt> and <tt class="docutils literal"><span class="pre">plot_u</span></tt> did can be coded as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">PlotSolution</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for the user_action function in solver.</span>
<span class="sd">    Visualizes the solution only.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">casename</span><span class="o">=</span><span class="s">&#39;tmp&#39;</span><span class="p">,</span>    <span class="c"># Prefix in filenames</span>
                 <span class="n">umin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">umax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>   <span class="c"># Fixed range of y axis</span>
                 <span class="n">pause_between_frames</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>  <span class="c"># Movie speed</span>
                 <span class="n">backend</span><span class="o">=</span><span class="s">&#39;matplotlib&#39;</span><span class="p">,</span>       <span class="c"># or &#39;gnuplot&#39;</span>
                 <span class="n">screen_movie</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="c"># Show movie on screen?</span>
                 <span class="n">title</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span>          <span class="c"># Extra message in title</span>
                 <span class="n">every_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>    <span class="c"># Show every_frame frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casename</span> <span class="o">=</span> <span class="n">casename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span> <span class="o">=</span> <span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pause</span> <span class="o">=</span> <span class="n">pause_between_frames</span>
        <span class="n">module</span> <span class="o">=</span> <span class="s">&#39;scitools.easyviz.&#39;</span> <span class="o">+</span> <span class="n">backend</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span>
        <span class="k">exec</span><span class="p">(</span><span class="s">&#39;import </span><span class="si">%s</span><span class="s"> as plt&#39;</span> <span class="o">%</span> <span class="n">module</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plt</span> <span class="o">=</span> <span class="n">plt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen_movie</span> <span class="o">=</span> <span class="n">screen_movie</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">every_frame</span> <span class="o">=</span> <span class="n">every_frame</span>

        <span class="c"># Clean up old movie frames</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="s">&#39;frame_*.png&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">every_frame</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;t=</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="n">title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span>
                     <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
                     <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                     <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                     <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">screen_movie</span><span class="p">)</span>
        <span class="c"># pause</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c"># let initial condition stay 2 s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pause</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pause</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">pause</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_frame_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">casename</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>Understanding this class requires quite some familiarity with Python
in general and class programming in particular.</p>
<p>The constructor shows how we can flexibly import the plotting engine
as (typically) <tt class="docutils literal"><span class="pre">scitools.easyviz.gnuplot_</span></tt> or
<tt class="docutils literal"><span class="pre">scitools.easyviz.matplotlib_</span></tt> (note the trailing underscore).
With the <tt class="docutils literal"><span class="pre">screen_movie</span></tt> parameter
we can suppress displaying each movie frame on the screen.
Alternatively, for slow movies associated with
fine meshes, one can set
<tt class="docutils literal"><span class="pre">every_frame</span></tt> to, e.g., 10, causing every 10 frames to be shown.</p>
<p>The <tt class="docutils literal"><span class="pre">__call__</span></tt> method makes <tt class="docutils literal"><span class="pre">PlotSolution</span></tt> instances behave like
functions, so we can just pass an instance, say <tt class="docutils literal"><span class="pre">p</span></tt>, as the
<tt class="docutils literal"><span class="pre">user_action</span></tt> argument in the <tt class="docutils literal"><span class="pre">solver</span></tt> function, and any call to
<tt class="docutils literal"><span class="pre">user_action</span></tt> will be a call to <tt class="docutils literal"><span class="pre">p.__call__</span></tt>.</p>
</div>
<div class="section" id="collection-of-initial-conditions">
<h2>Collection of initial conditions<a class="headerlink" href="#collection-of-initial-conditions" title="Permalink to this headline">¶</a></h2>
<p>The function <tt class="docutils literal"><span class="pre">pulse</span></tt> in <tt class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></tt> demonstrates wave motion in
heterogeneous media where <span class="math">\(c\)</span> varies. One can specify an interval
where the wave velocity is decreased by a factor <tt class="docutils literal"><span class="pre">slowness_factor</span></tt>
(or increased by making this factor less than one).
Four types of initial conditions are available: a square pulse (<tt class="docutils literal"><span class="pre">plug</span></tt>),
a Gaussian function (<tt class="docutils literal"><span class="pre">gaussian</span></tt>), a cosine &#8220;hat&#8221; consisting of one
period of the cosine function (<tt class="docutils literal"><span class="pre">cosinehat</span></tt>), and half a period of
a cosine &#8220;hat&#8221; (<tt class="docutils literal"><span class="pre">half-cosinehat</span></tt>). These peak-shaped initial
conditions can be placed in the middle (<tt class="docutils literal"><span class="pre">loc='center'</span></tt>) or at
the left end (<tt class="docutils literal"><span class="pre">loc='left'</span></tt>) of the domain. The <tt class="docutils literal"><span class="pre">pulse</span></tt>
function is a flexible tool for playing around with various wave
shapes and location of a medium with a different wave velocity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">pulse</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
          <span class="n">loc</span><span class="o">=</span><span class="s">&#39;center&#39;</span><span class="p">,</span> <span class="n">pulse_tp</span><span class="o">=</span><span class="s">&#39;gaussian&#39;</span><span class="p">,</span> <span class="n">slowness_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
          <span class="n">medium</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="n">every_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Various peaked-shaped initial conditions on [0,1].</span>
<span class="sd">    Wave velocity is decreased by the slowness_factor inside</span>
<span class="sd">    medium. The loc parameter can be &#39;center&#39; or &#39;left&#39;,</span>
<span class="sd">    depending on where the initial pulse is to be located.</span>
<span class="sd">    The sigma parameter governs the width of the pulse.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Use scaled parameters: L=1 for domain length, c_0=1</span>
    <span class="c"># for wave velocity outside the domain.</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">c_0</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="s">&#39;center&#39;</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">pulse_tp</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;gaussian&#39;</span><span class="p">,</span><span class="s">&#39;Gaussian&#39;</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;plug&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;cosinehat&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c"># One period of a cosine</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">sigma</span>
            <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">))</span> \
                   <span class="k">if</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;half-cosinehat&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c"># Half a period of a cosine</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">sigma</span>
            <span class="k">return</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">)</span> \
                   <span class="k">if</span> <span class="n">xc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xc</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">a</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Wrong pulse_tp=&quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="n">pulse_tp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c_0</span><span class="o">/</span><span class="n">slowness_factor</span> \
               <span class="k">if</span> <span class="n">medium</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">medium</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">c_0</span>

    <span class="n">umin</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">;</span> <span class="n">umax</span><span class="o">=</span><span class="mf">1.5</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
    <span class="n">casename</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_Nx</span><span class="si">%s</span><span class="s">_sf</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
               <span class="p">(</span><span class="n">pulse_tp</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">slowness_factor</span><span class="p">)</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">PlotMediumAndSolution</span><span class="p">(</span>
        <span class="n">medium</span><span class="p">,</span> <span class="n">casename</span><span class="o">=</span><span class="n">casename</span><span class="p">,</span> <span class="n">umin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span>
        <span class="n">every_frame</span><span class="o">=</span><span class="n">every_frame</span><span class="p">,</span> <span class="n">screen_movie</span><span class="o">=</span><span class="n">animate</span><span class="p">)</span>

    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">U_0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">U_L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
           <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">=</span><span class="n">Nx</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">,</span>
           <span class="n">dt_safety_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">PlotMediumAndSolution</span></tt> class used here is a subclass of
<tt class="docutils literal"><span class="pre">PlotSolution</span></tt> where the medium with reduced <span class="math">\(c\)</span> value,
as specified by the <tt class="docutils literal"><span class="pre">medium</span></tt> interval,
is visualized in the plots.</p>
<p>The reader is encouraged to play around with the <tt class="docutils literal"><span class="pre">pulse</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">wave1D_dn_vc</span> <span class="kn">as</span> <span class="nn">w</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">pulse</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="n">pulse_tp</span><span class="o">=</span><span class="s">&#39;cosinehat&#39;</span><span class="p">,</span> <span class="n">Nx</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">every_frame</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>To easily kill the graphics by Ctrl-C and restart a new simulation it might be
easier to run the above two statements from the command line
with <tt class="docutils literal"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">'...statements...'</span></tt>.</p>
</div>
</div>
<div class="section" id="exercises-2">
<h1>Exercises  (2)<a class="headerlink" href="#exercises-2" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-6-explore-the-effect-of-boundary-conditions">
<span id="wave-exer-1d-bceffects"></span><h2>Problem 6: Explore the effect of boundary conditions<a class="headerlink" href="#problem-6-explore-the-effect-of-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this exercise is to increase the understanding of
the solutions of the wave equation <span class="math">\(u_{tt}=c^2u_xx\)</span>
and how boundary conditions,
especially <span class="math">\(u=0\)</span> versus <span class="math">\(u_x=0\)</span>, impact the solution.</p>
<p>We address plug-shaped waves, starting from rest (<span class="math">\(u_t=0\)</span>)
at <span class="math">\(t=0\)</span>.
The plug shape means that <span class="math">\(u=1\)</span> in some region and <span class="math">\(u=0\)</span> outside this
region. Present the simulations as movies with the names indicated
(and a file extension depending on the movie format).</p>
<p><em>Hint.</em> One can use the <tt class="docutils literal"><span class="pre">plug</span></tt>
function with <tt class="docutils literal"><span class="pre">C=1</span></tt> in the program <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn.py">wave1D_dn.py</a> for simulating such waves.</p>
<p><em>a)</em> Demonstrate that the initial profile is split in two
waves, with same shape as the initial profile, but half the amplitude.
The two waves are traveling to the left and right. Stop the simulation
before the waves hit the boundaries.
Filename: <tt class="docutils literal"><span class="pre">wave1D_split_ic</span></tt>.</p>
<p><em>b)</em> Apply <span class="math">\(u_x=0\)</span> at both ends. Demonstrate how the waves are reflected
from the boundaries. Run the simulation for two periods, where one
period is the time it takes for the two waves to reflect and come
back to exactly the initial condition.
Filename: <tt class="docutils literal"><span class="pre">wave1D_reflecting_bc</span></tt>.</p>
<p><em>c)</em> Repeat the previous experiment, but use <span class="math">\(u=0\)</span> at both ends.
Filename: <tt class="docutils literal"><span class="pre">wave1D_u0_bc</span></tt>.</p>
<p><em>d)</em> Repeat the previous experiment, but use <span class="math">\(u=0\)</span> at one and <span class="math">\(u_x=0\)</span>
at the other. Run the simulation for four periods.
Filename: <tt class="docutils literal"><span class="pre">wave1D_mixed_bc</span></tt>.</p>
</div>
<div class="section" id="problem-7-explore-symmetry-boundary-conditions">
<span id="wave-exer-symmetry-bc"></span><h2>Problem 7: Explore symmetry boundary conditions<a class="headerlink" href="#problem-7-explore-symmetry-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p><em>a)</em> Consider the simple &#8220;plug&#8221; wave where <span class="math">\(\Omega = [-L,L]\)</span> and</p>
<div class="math">
\[\begin{split}I(x) = \left\lbrace\begin{array}{ll}
1, &amp; x\in [-\delta, \delta],\\
0, &amp; \hbox{otherwise}
\end{array}\right.\end{split}\]</div>
<p>for some number <span class="math">\(0 &lt; \delta &lt; L\)</span>.
The boundary conditions can be set to <span class="math">\(u=0\)</span>.
The solution to this problem is symmetric around <span class="math">\(x=0\)</span>.
This means that we can simulate the wave process in only the half
of the domain <span class="math">\([0,L]\)</span>. Argue why the symmetry boundary condition
is <span class="math">\(u_x=0\)</span> at <span class="math">\(x=0\)</span>.</p>
<p><em>Hint.</em> Symmetry of a function about <span class="math">\(x=x_0\)</span> means that
<span class="math">\(f(x_0+h) = f(x_0-h)\)</span>.</p>
<p><em>b)</em> Perform simulations of the complete wave problem from
on <span class="math">\([-L,L]\)</span>. Thereafter, utilize the
symmetry of the solution and run a simulation
in half of the domain <span class="math">\([0,L]\)</span>, using a boundary condition
at <span class="math">\(x=0\)</span>. Compare the two solutions and
make sure that they are the same.</p>
<p><em>c)</em> Prove the symmetry property of the solution
by setting up the complete initial-boundary value problem
and showing that if <span class="math">\(u(x,t)\)</span> is a solution, then also <span class="math">\(u(-x,t)\)</span>
is a solution.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave1D_symmetric</span></tt>.</p>
</div>
<div class="section" id="exercise-8-send-pulse-waves-through-a-layered-medium">
<span id="wave-app-exer-pulse1d"></span><h2>Exercise 8: Send pulse waves through a layered medium<a class="headerlink" href="#exercise-8-send-pulse-waves-through-a-layered-medium" title="Permalink to this headline">¶</a></h2>
<p>Use the <tt class="docutils literal"><span class="pre">pulse</span></tt> function in <tt class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></tt> to investigate
sending a pulse, located with its peak at <span class="math">\(x=0\)</span>, through the
medium to the right where it hits another medium for <span class="math">\(x\in [0.7,0.9]\)</span>
where the wave velocity is decreased by a factor <span class="math">\(s_f\)</span>.
Report what happens with a Gaussian pulse, a &#8220;cosinehat&#8221; pulse,
half a &#8220;cosinehat&#8221; pulse, and a plug pulse for resolutions
<span class="math">\(N_x=40,80,160\)</span>, and <span class="math">\(s_f=2,4\)</span>. Make a reference solution in
the homogeneous case too with <span class="math">\(s_f=1\)</span> and <span class="math">\(N_x=40\)</span>. Use <span class="math">\(C=1\)</span>
in the medium outside <span class="math">\([0.7,0.9]\)</span>. Simulate until <span class="math">\(T=2\)</span>.
Filename: <tt class="docutils literal"><span class="pre">pulse1D.py</span></tt>.</p>
</div>
<div class="section" id="exercise-9-compare-discretizations-of-a-neumann-condition">
<h2>Exercise 9: Compare discretizations of a Neumann condition<a class="headerlink" href="#exercise-9-compare-discretizations-of-a-neumann-condition" title="Permalink to this headline">¶</a></h2>
<p>We have a 1D wave equation with variable wave velocity:
<span class="math">\(u_t=(qu_x)_x\)</span>.
A Neumann condition <span class="math">\(u_x\)</span> at <span class="math">\(x=0, L\)</span> can be
discretized as shown in <a href="#equation-wave:pde2:var:c:scheme:impl:Neumann">(34)</a>
and <a href="#equation-wave:pde2:var:c:scheme:impl:Neumann2">(35)</a>.</p>
<p>The aim of this exercise is to examine the rate of the numerical
error when using different ways of discretizing the Neumann condition.
As test problem, <span class="math">\(q=1+(x-L/2)^4\)</span> can be used, with <span class="math">\(f(x,t)\)</span>
adapted such that the solution has a simple form, say
<span class="math">\(u(x,t)=\cos (\pi x/L)\cos (\omega t)\)</span> for some <span class="math">\(\omega = \sqrt{q}\pi/L\)</span>.</p>
<p><em>a)</em> Perform numerical experiments and find the convergence rate of the
error using
the approximation
and <a href="#equation-wave:pde2:var:c:scheme:impl:Neumann2">(35)</a>.</p>
<p><em>b)</em> Switch to <span class="math">\(q(x)=\cos(\pi x/L)\)</span>, which symmetric at <span class="math">\(x=0,L\)</span>,
and check the convergence rate
of the scheme
<a href="#equation-wave:pde2:var:c:scheme:impl:Neumann2">(35)</a>. Now,
<span class="math">\(q_{i-1/2}\)</span> is a 2nd-order approximation to <span class="math">\(q_i\)</span>,
<span class="math">\(q_{i-1/2}=q_i + 0.25q_i''\Delta x^2 + \cdots\)</span>, because <span class="math">\(q_i'=0\)</span>
for <span class="math">\(i=N_x\)</span> (a similar argument can be applied to the case <span class="math">\(i=0\)</span>).</p>
<p><em>c)</em> A third discretization can be based on a simple and convenient,
but less accurate, one-sided difference:
<span class="math">\(u_{i}-u_{i-1}=0\)</span> at <span class="math">\(i=N_x\)</span> and <span class="math">\(u_{i+1}-u_i=0\)</span> at <span class="math">\(i=0\)</span>.
Derive the resulting scheme in detail and implement it.
Run experiments to establish the rate of convergence.</p>
<p><em>d)</em> A fourth technique is to view the scheme as</p>
<div class="math">
\[[D_tD_tu]^n_i = [qD_xu]_{i+\frac{1}{2}}^n - [qD_xu]_{i-\frac{1}{2}}^n
+ [f]_i^n,\]</div>
<p>and place the boundary at <span class="math">\(x_{i+\frac{1}{2}}\)</span>, <span class="math">\(i=N_x\)</span>, instead of
exactly at the physical boundary. With this idea,
we can just set <span class="math">\([qD_xu]_{i+\frac{1}{2}}^n=0\)</span>. Derive the complete scheme
using this technique. The implementation of the boundary condition at
<span class="math">\(L-\Delta x/2\)</span> is <span class="math">\({\mathcal{O}(\Delta x^2)}\)</span> accurate, but the interesting question
is what impact the movement of the boundary has on the convergence
rate (compute the errors as usual over the entire mesh).</p>
</div>
</div>
<div class="section" id="analysis-of-the-continuous-and-discrete-solutions">
<span id="wave-pde1-analysis"></span><h1>Analysis of the continuous and discrete solutions<a class="headerlink" href="#analysis-of-the-continuous-and-discrete-solutions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="properties-of-the-solution-of-the-wave-equation">
<span id="wave-pde1-properties"></span><h2>Properties of the solution of the wave equation<a class="headerlink" href="#properties-of-the-solution-of-the-wave-equation" title="Permalink to this headline">¶</a></h2>
<p id="index-27">The wave equation</p>
<div class="math">
\[\frac{\partial^2 u}{\partial t^2} =
c^2 \frac{\partial^2 u}{\partial x^2}\]</div>
<p>has solutions of the form</p>
<div class="math" id="equation-wave:pde1:gensol">
<span class="eqno">(42)</span>\[     u(x,t) = g_R(x-ct) + g_L(x+ct),\]</div>
<p>for any functions <span class="math">\(g_R\)</span> and <span class="math">\(g_L\)</span> sufficiently smooth to be differentiated
twice. The result follows from inserting <a href="#equation-wave:pde1:gensol">(42)</a>
in the wave equation. A function of the form <span class="math">\(g_R(x-ct)\)</span> represents a
signal
moving to the right in time with constant velocity <span class="math">\(c\)</span>.
This feature can be explained as follows.
At time <span class="math">\(t=0\)</span> the signal looks like <span class="math">\(g_R(x)\)</span>. Introducing a
moving <span class="math">\(x\)</span> axis with coordinates <span class="math">\(\xi = x-ct\)</span>, we see the function
<span class="math">\(g_R(\xi)\)</span> is &#8220;at rest&#8221;
in the <span class="math">\(\xi\)</span> coordinate system, and the shape is always
the same. Say the <span class="math">\(g_R(\xi)\)</span> function has a peak at <span class="math">\(\xi=0\)</span>. This peak
is located at <span class="math">\(x=ct\)</span>, which means that it moves with the velocity
<span class="math">\(dx/dt=c\)</span> in the <span class="math">\(x\)</span> coordinate system. Similarly, <span class="math">\(g_L(x+ct)\)</span>
is a function initially with shape <span class="math">\(g_L(x)\)</span> that moves in the negative
<span class="math">\(x\)</span> direction with constant velocity <span class="math">\(c\)</span>.</p>
<p>With the particular initial conditions</p>
<div class="math">
\[u(x,0)=I(x),\quad \frac{\partial}{\partial t}u(x,0) =0,\]</div>
<p>we get, with <span class="math">\(u\)</span> as in <a href="#equation-wave:pde1:gensol">(42)</a>,</p>
<div class="math">
\[g_R(x) + g_L(x) = I(x),\quad -cg_R'(x) + cg_L'(x) = 0,\]</div>
<p>which have the solution <span class="math">\(g_R=g_L=I/2\)</span>, and consequently</p>
<div class="math" id="equation-wave:pde1:gensol2">
<span class="eqno">(43)</span>\[     u(x,t) = \frac{1}{2} I(x-ct) + \frac{1}{2} I(x+ct) \thinspace .\]</div>
<p>The interpretation of <a href="#equation-wave:pde1:gensol2">(43)</a> is that
the initial shape of <span class="math">\(u\)</span> is split into two parts, each with the same
shape as <span class="math">\(I\)</span> but half
of the initial amplitude. One part is traveling to the left and the
other one to the right.</p>
<p>The solution <a href="#equation-wave:pde1:gensol2">(43)</a> will be influenced by
boundary conditions when the parts
<span class="math">\(\frac{1}{2} I(x-ct)\)</span> and <span class="math">\(\frac{1}{2} I(x+ct)\)</span> hit the boundaries and get, e.g.,
reflected back into the domain. However, when <span class="math">\(I(x)\)</span> is nonzero
only in a small part in the middle
of the spatial domain <span class="math">\([0,L]\)</span>, which means that the
boundaries are placed far away from the initial disturbance of <span class="math">\(u\)</span>,
the solution <a href="#equation-wave:pde1:gensol2">(43)</a> is very clearly observed
in a simulation.</p>
<p>A useful representation of solutions of wave equations is a linear
combination of sine and/or cosine waves. Such a sum of waves is a
solution if the governing PDE is linear and each wave fulfills the
equation.  To ease analytical calculations by hand we shall work with
complex exponential functions instead of real-valued sine or cosine
functions. The real part of complex expressions will typically be
taken as the physical relevant quantity (whenever a physical relevant
quantity is strictly needed).
The idea now is to build <span class="math">\(I(x)\)</span> of complex wave components
<span class="math">\(e^{ikx}\)</span>:</p>
<div class="math" id="equation-wave:Fourier:I I(x) \approx \sum_{k\in K} b_k e^{ikx} \thinspace .">
</div>
<p>Here, <span class="math">\(k\)</span> is the frequency of a component,
<span class="math">\(K\)</span> is some set of all the discrete
<span class="math">\(k\)</span> values needed to approximate <span class="math">\(I(x)\)</span> well,
and <span class="math">\(b_k\)</span> are
constants that must be determined. We will very seldom
need to compute the <span class="math">\(b_k\)</span> coefficients: most of the insight
we look for, and understanding of the numerical methods, comes from
investigating how the PDE and the scheme treat a single
component <span class="math">\(e^{ikx}\)</span> of the solution.</p>
<p>Letting the number of <span class="math">\(k\)</span> values in <span class="math">\(K\)</span> tend to infinity makes the sum
<a href="#equation-wave:Fourier:I">(?)</a> converge to <span class="math">\(I(x)\)</span>, and this sum is known as a
<em>Fourier series</em> representation of <span class="math">\(I(x)\)</span>.  Looking at
<a href="#equation-wave:pde1:gensol2">(43)</a>, we see that the solution <span class="math">\(u(x,t)\)</span>, when
<span class="math">\(I(x)\)</span> is represented as in <a href="#equation-wave:Fourier:I">(?)</a>, is also built of
basic complex exponential wave components of the form <span class="math">\(e^{ik(x\pm
ct)}\)</span> according to</p>
<div class="math" id="equation-wave:Fourier:u1">
<span class="eqno">(45)</span>\[     u(x,t) = \frac{1}{2} \sum_{k\in K} b_k e^{ik(x - ct)}
     + \frac{1}{2} \sum_{k\in K} b_k e^{ik(x + ct)} \thinspace .\]</div>
<p>It is common to introduce the frequency in time <span class="math">\(\omega = kc\)</span> and
assume that <span class="math">\(u(x,t)\)</span> is a sum of basic wave components
written as <span class="math">\(e^{ikx -\omega t}\)</span>.
Observe that inserting such a wave component in the governing PDE reveals that
<span class="math">\(\omega^2 = k^2c^2\)</span>, or <span class="math">\(\omega \pm kc\)</span>, reflecting the
two solutions: one (<span class="math">\(+kc\)</span>) traveling to the right and the other (<span class="math">\(-kc\)</span>)
traveling to the left.</p>
</div>
<div class="section" id="more-precise-definition-of-fourier-representations">
<span id="wave-pde1-fourier"></span><h2>More precise definition of Fourier representations<a class="headerlink" href="#more-precise-definition-of-fourier-representations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-28"></span><span class="target" id="index-29"></span><p id="index-30">The quick intuitive introduction above to representing a function by a sum
of sine and cosine waves suffices as background for the forthcoming
material on analyzing a single wave component. However, to understand
all details of how different wave components sum up to the analytical
and numerical solution, a more precise mathematical treatment is helpful.</p>
<p>It is well known that periodic functions can be represented by
Fourier series. A generalization of the Fourier series idea to
non-periodic functions defined on the real line is the <em>Fourier transform</em>:</p>
<div class="math" id="equation-wave:pde1:Fourier:I">
<span class="eqno">(46)</span>\[     I(x) = \int_{-\infty}^\infty A(k)e^{ikx}dk,\]</div>
<div class="math" id="equation-wave:pde1:Fourier:A">
<span class="eqno">(47)</span>\[     A(k) = \int_{-\infty}^\infty I(x)e^{-ikx}dx{\thinspace .}\]</div>
<p>The function <span class="math">\(A(k)\)</span> reflects the weight of each wave component <span class="math">\(e^{ikx}\)</span>
in an infinite sum of such wave components. That is, <span class="math">\(A(k)\)</span>
reflects the frequency content in the function <span class="math">\(I(x)\)</span>. Fourier transforms
are particularly fundamental for analyzing and understanding time-varying
signals.</p>
<p>The solution of the linear 1D wave PDE can now be expressed as</p>
<div class="math">
\[u(x,t) = \int_{-\infty}^\infty A(k)e^{i(kx-\omega(k)t)}dx{\thinspace .}\]</div>
<p>In a finite difference method, we represent <span class="math">\(u\)</span> by a mesh function
<span class="math">\(u^n_j\)</span>, where <span class="math">\(n\)</span> counts temporal mesh points and <span class="math">\(j\)</span> counts
the spatial ones (the usual counter for spatial points, <span class="math">\(i\)</span>, is
here used as imaginary unit). Similarly, <span class="math">\(I(x)\)</span> is approximated by
the mesh function <span class="math">\(I_j\)</span>, <span class="math">\(j=0,\ldots,N_x\)</span>.
On a mesh, it does not make sense to work with wave
components <span class="math">\(e^{ikx}\)</span> for very large <span class="math">\(k\)</span>, because the shortest possible
sine or cosine wave that can be represented on a mesh with spacing <span class="math">\(\Delta x\)</span>
is the wave with wavelength <span class="math">\(2\Delta x\)</span> (the sine/cosine signal jumps
up and down between each mesh point). The corresponding <span class="math">\(k\)</span> value is
<span class="math">\(k=2\pi /(2\Delta x) = \pi/\Delta x\)</span>, known as the <em>Nyquist frequency</em>.
Within this range of
relevant frequencies one defines
the <a class="reference external" href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform">discrete Fourier transform</a>, using <span class="math">\(N_x+1\)</span> discrete frequencies which are
multiples of the Nyquist frequency (<span class="math">\(\pi/\Delta x\)</span>):</p>
<div class="math">
\[I_j \approx \frac{1}{N_x+1}\sum_{k=0}^{N_x} A_k e^{i2\pi k j/(N_x+1)},\quad
i=0,\ldots,N_x,\]</div>
<div class="math">
\[A_k =\approx \sum_{j=0}^{N_x} I_j e^{-i2\pi k j/(N_x+1)},
\quad k=0,\ldots,N_x+1{\thinspace .}\]</div>
<p>The <span class="math">\(A_k\)</span> values is the discrete Fourier transform of the <span class="math">\(I_j\)</span> values,
and the latter are the inverse discrete Fourier transform of the <span class="math">\(A_k\)</span>
values.</p>
<p>The discrete Fourier transform is efficiently computed by the
<em>Fast Fourier transform</em> algorithm. For a real function <span class="math">\(I(x)\)</span>
the relevant Python code for computing and plotting
the discrete Fourier transform appears in the example below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sin</span>

<span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="c"># Mesh</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">Nx</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>

<span class="c"># Discrete Fourier transform</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">A_amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="c"># Compute the corresponding frequencies</span>
<span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pi</span><span class="o">/</span><span class="n">dx</span><span class="p">,</span> <span class="n">A_amplitude</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">A_amplitude</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="analysis-of-the-finite-difference-scheme">
<span id="id7"></span><h2>Analysis of the finite difference scheme<a class="headerlink" href="#analysis-of-the-finite-difference-scheme" title="Permalink to this headline">¶</a></h2>
<p id="index-31">The scheme</p>
<div class="math" id="equation-wave:pde1:analysis:scheme">
<span class="eqno">(48)</span>\[     [D_tD_t u = c^2 D_xD_x u]^n_q\]</div>
<p>for the wave equation <span class="math">\(u_t = c^2u_{xx}\)</span> allows basic wave components
<span class="math">\(e^{i(kx - \tilde\omega t)}\)</span> as solution, but it turns out that
the frequency in time, <span class="math">\(\tilde\omega\)</span>, is not equal to
the exact <span class="math">\(\omega = kc\)</span>.  The idea now is to study how the scheme treats
an arbitrary wave component with a given <span class="math">\(k\)</span>. How accurate is <span class="math">\(\tilde\omega\)</span>
compared to <span class="math">\(\omega\)</span>? And does the amplitude of such a wave component
preserve its (unit) amplitude, as it should,
or does it get amplified or damped in time (due to a complex <span class="math">\(\tilde\omega\)</span>)?
These are the questions we aim to answer in the following analysis.
Note the need for using <span class="math">\(q\)</span> as counter for the mesh point in <span class="math">\(x\)</span> direction
since <span class="math">\(i\)</span> is already used as the imaginary unit (in this analysis).</p>
<p>A key result needed in the investigations is the finite difference
approximation of a second-order derivative acting on a complex
wave component:</p>
<div class="math">
\[[D_tD_t e^{i\omega t}]^n = -\frac{4}{\Delta t^2}\sin^2\left(
\frac{\omega\Delta t}{2}\right)e^{i\omega n\Delta t}
\thinspace .\]</div>
<p>Similarly, by just changing symbols (<span class="math">\(\omega\rightarrow k\)</span>,
<span class="math">\(t\rightarrow x\)</span>, <span class="math">\(n\rightarrow p\)</span>) it follows that</p>
<div class="math">
\[[D_xD_x e^{ikx}]_q = -\frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right)e^{ikq\Delta x} \thinspace .\]</div>
<p>Inserting a basic wave component <span class="math">\(u=e^{i(kx-\tilde\omega t)}\)</span> in
<a href="#equation-wave:pde1:analysis:scheme">(48)</a> results in the need to
evaluate two expressions:</p>
<div class="math">
\[\lbrack D_tD_t e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q = \lbrack D_tD_t e^{-i\tilde\omega t}\rbrack^ne^{ikq\Delta x}\nonumber\]</div>
<div class="math">
\[= -\frac{4}{\Delta t^2}\sin^2\left(
\frac{\tilde\omega\Delta t}{2}\right)e^{-i\tilde\omega n\Delta t}e^{ikq\Delta x}\]</div>
<div class="math">
\[\lbrack D_xD_x e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q = \lbrack D_xD_x e^{ikx}\rbrack_q e^{-i\tilde\omega n\Delta t}\nonumber\]</div>
<div class="math">
\[= -\frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right)e^{ikq\Delta x}e^{-i\tilde\omega n\Delta t} \thinspace .\]</div>
<p>Then the complete scheme,</p>
<div class="math">
\[\lbrack D_tD_t e^{ikx}e^{-i\tilde\omega t} = c^2D_xD_x e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q\]</div>
<p>leads to the following equation for the unknown numerical
frequency <span class="math">\(\tilde\omega\)</span>
(after dividing by <span class="math">\(-e^{ikx}e^{-i\tilde\omega t}\)</span>):</p>
<div class="math">
\[\frac{4}{\Delta t^2}\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
= c^2 \frac{4}{\Delta x^2}\sin^2\left(\frac{k\Delta x}{2}\right),\]</div>
<p>or</p>
<div class="math" id="equation-wave:pde1:analysis:sineq1">
<span class="eqno">(49)</span>\[     \sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
     = C^2\sin^2\left(\frac{k\Delta x}{2}\right),\]</div>
<p>where</p>
<div class="math" id="index-32">
\[C = \frac{c\Delta t}{\Delta x}\]</div>
<p>is the Courant number.
Taking the square root of <a href="#equation-wave:pde1:analysis:sineq1">(49)</a> yields</p>
<div class="math" id="equation-wave:pde1:analysis:sineq2">
<span class="eqno">(50)</span>\[     \sin\left(\frac{\tilde\omega\Delta t}{2}\right)
     = C\sin\left(\frac{k\Delta x}{2}\right),\]</div>
<p>Since the exact <span class="math">\(\omega\)</span> is real it is reasonable to look for a real
solution <span class="math">\(\tilde\omega\)</span> of <a href="#equation-wave:pde1:analysis:sineq2">(50)</a>.
The right-hand side of
<a href="#equation-wave:pde1:analysis:sineq2">(50)</a> must then be in <span class="math">\([-1,1]\)</span> because
the sine function on the left-hand side has values in <span class="math">\([-1,1]\)</span>
for real <span class="math">\(\tilde\omega\)</span>. The sine function on
the right-hand side can attain the value 1 when</p>
<div class="math">
\[\frac{k\Delta x}{2} = q\frac{\pi}{2},\quad q\in\mathbb{Z}
\thinspace .\]</div>
<p>With <span class="math">\(q=1\)</span> we have <span class="math">\(k\Delta x = \pi\)</span>, which means that
the wavelength <span class="math">\(\lambda = 2\pi/k\)</span> becomes <span class="math">\(2\Delta x\)</span>. This is
the absolutely shortest wavelength that can be represented on the mesh:
the wave jumps up and down between each mesh point. Higher values of <span class="math">\(q\)</span>
are irrelevant since these waves are too short to be represented
on a mesh with spacing <span class="math">\(\Delta x\)</span>.
For the shortest possible wave in the mesh, <span class="math">\(\sin\left(k\Delta x/2\right)=1\)</span>
and we must require</p>
<span class="target" id="index-33"></span><div class="math" id="equation-wave:pde1:stability">
<span id="index-34"></span><span class="eqno">(51)</span>\[     C\leq 1 \thinspace .\]</div>
<p>For smoother wave components with longer wave lengths per length <span class="math">\(\Delta x\)</span>,
<a href="#equation-wave:pde1:stability">(51)</a> can in theory be relaxed. However,
small round-off errors are always present in a numerical solution and these
vary arbitrarily from mesh point to mesh point and can be viewed as
unavoidable noise with wavelength <span class="math">\(2\Delta x\)</span>. As we shall see below, <span class="math">\(C&gt;1\)</span>
will for this very small noise lead to exponential growth of
the shortest possible wave component in the mesh. This noise will
therefore grow with time and destroy the whole solution.</p>
<p>Consider a right-hand side in <a href="#equation-wave:pde1:analysis:sineq2">(50)</a> of
magnitude larger
than unity. The solution <span class="math">\(\tilde\omega\)</span> of <a href="#equation-wave:pde1:analysis:sineq2">(50)</a>
.. see the chapter <em class="xref std std-ref">sec:ode:o:eq1:analysis</em></p>
<p>must then be a complex number <span class="math">\(\tilde\omega = \tilde\omega_r + i\tilde\omega_i\)</span>.
One can show that for any <span class="math">\(\omega_i\)</span>  there will also be a
corresponding solution with <span class="math">\(-\omega_i\)</span>. The component with <span class="math">\(\omega_i&gt;0\)</span>
gives an amplification factor <span class="math">\(e^{\omega_it}\)</span> that grows exponentially
in time. We cannot allow this and must therefore require <span class="math">\(C\leq 1\)</span>
as a <em>stability criterion</em>.</p>
<p>Equation <a href="#equation-wave:pde1:analysis:sineq2">(50)</a> can be solved with respect
to <span class="math">\(\tilde\omega\)</span>:</p>
<div class="math" id="equation-wave:pde1:disprel">
<span class="eqno">(52)</span>\[     \tilde\omega = \frac{2}{\Delta t}
     \sin^{-1}\left( C\sin\left(\frac{k\Delta x}{2}\right)\right) \thinspace .\]</div>
<p>The relation between the numerical frequency <span class="math">\(\tilde\omega\)</span> and
the other parameters <span class="math">\(k\)</span>, <span class="math">\(c\)</span>, <span class="math">\(\Delta x\)</span>, and <span class="math">\(\Delta t\)</span> is called
a <em>numerical dispersion relation</em>. Correspondingly,
<span class="math">\(\omega =kc\)</span> is the <em>analytical dispersion relation</em>.</p>
<p>The special case <span class="math">\(C=1\)</span> deserves attention since then the right-hand side
of <a href="#equation-wave:pde1:disprel">(52)</a> reduces to</p>
<div class="math">
\[\frac{2}{\Delta t}\frac{k\Delta x}{2} = \frac{1}{\Delta t}
\frac{\omega\Delta x}{c} = \frac{\omega}{C} = \omega \thinspace .\]</div>
<p>That is, <span class="math">\(\tilde\omega = \omega\)</span> and the numerical solution is exact
at all mesh points regardless of <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>!
This implies that the numerical solution method is also an analytical
solution method, at least for computing <span class="math">\(u\)</span> at discrete points (the
numerical method says nothing about the
variation of <span class="math">\(u\)</span> <em>between</em> the mesh points, and employing the
common linear interpolation for extending the discrete solution
gives a curve that deviates from the exact one).</p>
<p>For a closer examination of the error in the numerical dispersion
relation when <span class="math">\(C&lt;1\)</span>, we can study
<span class="math">\(\tilde\omega -\omega\)</span>, <span class="math">\(\tilde\omega/\omega\)</span>, or the similar
error measures in wave velocity: <span class="math">\(\tilde c - c\)</span> and <span class="math">\(\tilde c/c\)</span>,
where <span class="math">\(c=\omega /k\)</span> and <span class="math">\(\tilde c = \tilde\omega /k\)</span>.
It appears that the most convenient expression to work with is <span class="math">\(\tilde c/c\)</span>:</p>
<div class="math">
\[\frac{\tilde c}{c} = \frac{1}{Cp}{\sin}^{-1}\left(C\sin p\right),\]</div>
<p>with <span class="math">\(p=k\Delta x/2\)</span> as a non-dimensional measure of spatial frequency.
In essence, <span class="math">\(p\)</span> tells how many spatial mesh points we have per
spatial period of the wave component with frequency <span class="math">\(k\)</span> (the period is
<span class="math">\(2\pi/k\)</span>), i.e., how well the spatial variation of the wave component
is resolved in the mesh. Wave components with wave length
less than <span class="math">\(2\Delta x\)</span> (<span class="math">\(2\pi/k &lt; 2\Delta x\)</span>) are not visible in the mesh,
so it does not make sense to have <span class="math">\(p&gt;\pi/2\)</span>.</p>
<p>We may introduce the function <span class="math">\(r(C, p)=\tilde c/c\)</span>:</p>
<div class="math" id="equation-wave:pde1:disprel2">
<span class="eqno">(53)</span>\[     r(C, p) = \frac{1}{Cp}{\sin}^{-1}\left(C\sin p\right), \quad C\in (0,1],\ p\in (0,\pi/2] \thinspace .\]</div>
<p>This function is very well suited for plotting since it combines several
parameters in the problem into a dependence on two non-dimensional
numbers <span class="math">\(C\)</span> and <span class="math">\(p\)</span>.</p>
<div class="figure" id="wave-pde1-fig-disprel">
<img alt="_images/disprel1.png" src="_images/disprel1.png" style="width: 600px;" />
<p class="caption"><em>The fractional error in the wave velocity for different Courant numbers</em></p>
</div>
<p>Defining</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
</pre></div>
</div>
<p>we can easily plot <span class="math">\(r(C,p)\)</span> as a function of <span class="math">\(p\)</span> for various values of
<span class="math">\(C\)</span>, see Figure <a class="reference internal" href="#wave-pde1-fig-disprel"><em>The fractional error in the wave velocity for different Courant numbers</em></a>. Note that the shortest
waves have the most erroneous velocity, and that short waves move
more slowly than they should.</p>
<p>With <tt class="docutils literal"><span class="pre">sympy</span></tt> we can also easily make a Taylor series expansion in the
discretization parameter <span class="math">\(p\)</span>:</p>
<div class="highlight-text"><div class="highlight"><pre>&gt;&gt;&gt; C, p = symbols(&#39;C p&#39;)
&gt;&gt;&gt; rs = r(C, p).series(p, 0, 7)
&gt;&gt;&gt; print rs
1 - p**2/6 + p**4/120 - p**6/5040 + C**2*p**2/6 -
C**2*p**4/12 + 13*C**2*p**6/720 + 3*C**4*p**4/40 -
C**4*p**6/16 + 5*C**6*p**6/112 + O(p**7)
&gt;&gt;&gt; rs_factored = [factor(term) for term in rs.lseries(p)]
&gt;&gt;&gt; rs_factored = sum(rs_factored)
&gt;&gt;&gt; print rs_factored
p**6*(C - 1)*(C + 1)*(225*C**4 - 90*C**2 + 1)/5040 +
p**4*(C - 1)*(C + 1)*(3*C - 1)*(3*C + 1)/120 +
p**2*(C - 1)*(C + 1)/6 + 1
</pre></div>
</div>
<p>We see that <span class="math">\(C=1\)</span> makes all the terms in <tt class="docutils literal"><span class="pre">rs_factored</span></tt> vanish, except
the last one.
Since we already know that the numerical solution is exact for <span class="math">\(C=1\)</span>, the
remaining terms in the Taylor series expansion
will also contain factors of <span class="math">\(C-1\)</span> and cancel for <span class="math">\(C=1\)</span>.</p>
<p>From <tt class="docutils literal"><span class="pre">rs_factored</span></tt> expression above we also see that the leading
order terms in the error of this series expansion are</p>
<div class="math">
\[\frac{k^2}{24}\left( c^2\Delta t^2 - \Delta x^2\right)\]</div>
<p>pointing to an error <span class="math">\({\mathcal{O}(\Delta t^2, \Delta x^2)}\)</span>, which is
compatible with the errors in the difference approximations (<span class="math">\(D_tD_t\)</span>
and <span class="math">\(D_xD_x\)</span>).</p>
</div>
<div class="section" id="extending-the-analysis-to-2d-and-3d">
<span id="wave-pde1-analysis-2d3d"></span><h2>Extending the analysis to 2D and 3D<a class="headerlink" href="#extending-the-analysis-to-2d-and-3d" title="Permalink to this headline">¶</a></h2>
<p>The typical analytical solution of a 2D wave equation</p>
<div class="math">
\[u_{tt} = c^2(u_{xx} + u_{yy}),\]</div>
<p>is a wave traveling in the direction of <span class="math">\(\boldsymbol{k} = k_x\boldsymbol{i} + k_y\boldsymbol{j}\)</span>, where
<span class="math">\(\boldsymbol{i}\)</span> and <span class="math">\(\boldsymbol{j}\)</span> are unit vectors in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions, respectively.
Such a wave can be expressed by</p>
<div class="math">
\[u(x,y,t) = g(k_xx + k_yy - kct)\]</div>
<p>for some twice differentiable function <span class="math">\(g\)</span>, or with <span class="math">\(\omega =kc\)</span>:</p>
<div class="math">
\[u(x,y,t) = g(k_xx + k_yy - \omega t){\thinspace .}\]</div>
<p>We can in particular build a solution by adding complex Fourier components
of the form</p>
<div class="math">
\[\exp{(i(k_xx + k_yy - \omega t))}
\thinspace .\]</div>
<p>A discrete 2D wave equation can be written as</p>
<div class="math" id="equation-wave:pde1:analysis:scheme2D">
<span class="eqno">(54)</span>\[     \lbrack D_tD_t u = c^2(D_xD_x u + D_yD_y u)\rbrack^n_{q,r}
     \thinspace .\]</div>
<p>This equation admits a Fourier component</p>
<div class="math" id="equation-wave:pde1:analysis:numsol2D">
<span class="eqno">(55)</span>\[     u^n_{q,r} = \exp{\left( i(k_x q\Delta x + k_y r\Delta y
     - \tilde\omega n\Delta t)\right)},\]</div>
<p>as solution. Letting the operators <span class="math">\(D_tD_t\)</span>, <span class="math">\(D_xD_x\)</span>, and <span class="math">\(D_yD_y\)</span>
act on <span class="math">\(u^n_{q,r}\)</span> from <a href="#equation-wave:pde1:analysis:numsol2D">(55)</a> transforms
<a href="#equation-wave:pde1:analysis:scheme2D">(54)</a> to</p>
<div class="math">
\[\frac{4}{\Delta t^2}\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
= c^2 \frac{4}{\Delta x^2}\sin^2\left(\frac{k_x\Delta x}{2}\right)
+ c^2 \frac{4}{\Delta y^2}\sin^2\left(\frac{k_y\Delta y}{2}\right) \thinspace .\]</div>
<p>or</p>
<div class="math">
\[\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
= C_x^2\sin^2 p_x
+ C_y^2\sin^2 p_y,\]</div>
<p>where we have eliminated the factor 4 and introduced the symbols</p>
<div class="math">
\[C_x = \frac{c^2\Delta t^2}{\Delta x^2},\quad
C_y = \frac{c^2\Delta t^2}{\Delta y^2}, \quad
p_x = \frac{k_x\Delta x}{2},\quad
p_y = \frac{k_y\Delta y}{2}{\thinspace .}\]</div>
<p>For a real-valued <span class="math">\(\tilde\omega\)</span> the right-hand side
must be less than or equal to unity in absolute value, requiring in general
that</p>
<div class="math" id="equation-wave:pde1:analysis:2DstabC">
<span class="eqno">(56)</span>\[     C_x^2 + C_y^2 \leq 1 \thinspace .\]</div>
<p>This gives the stability criterion, more commonly expressed directly
in an inequality for the time step:</p>
<div class="math" id="equation-wave:pde1:analysis:2Dstab">
<span class="eqno">(57)</span>\[     \Delta t \leq \frac{1}{c} \left( \frac{1}{\Delta x^2} +
     \frac{1}{\Delta y^2}\right)^{-{1/2}}\]</div>
<p>A similar, straightforward analysis for the 3D case leads to</p>
<div class="math">
\[\Delta t \leq \frac{1}{c}\left( \frac{1}{\Delta x^2} +
\frac{1}{\Delta y^2} + \frac{1}{\Delta z^2}\right)^{-{1/2}}\]</div>
<p>In the case of a variable coefficient <span class="math">\(c^2=c^2(\boldsymbol{x})\)</span>, we must use
the worst-case value</p>
<div class="math">
\[\bar c = \sqrt{\max_{\boldsymbol{x}\in\Omega} c^2(\boldsymbol{x})}\]</div>
<p>in the stability criteria. Often, especially in the variable wave
velocity case, it is wise to introduce a safety factor <span class="math">\(\beta\in (0,1]\)</span> too:</p>
<div class="math">
\[\Delta t \leq \beta \frac{1}{\bar c}
\left( \frac{1}{\Delta x^2} +
\frac{1}{\Delta y^2} + \frac{1}{\Delta z^2}\right)^{-{1/2}}\]</div>
<p>The exact numerical dispersion relations in 2D and 3D becomes, for constant <span class="math">\(c\)</span>,</p>
<div class="math">
\[\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(
\left( C_x^2\sin^2 p_x + C_y^2\sin^ p_y\right)^{\frac{1}{2}}\right),\]</div>
<div class="math">
\[\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(
\left( C_x^2\sin^2 p_x + C_y^2\sin^ p_y + C_z^2\sin^ p_z\right)^{\frac{1}{2}}\right){\thinspace .}\]</div>
<p>We can visualize the numerical dispersion error in 2D much like we did
in 1D. To this end, we need to reduce the number of parameters in
<span class="math">\(\tilde\omega\)</span>. The direction of the wave is parameterized by the
polar angle <span class="math">\(\theta\)</span>, which means that</p>
<div class="math">
\[k_x = k\sin\theta,\quad k_y=k\cos\theta{\thinspace .}\]</div>
<p>A simplification is to set <span class="math">\(\Delta x=\Delta y=h\)</span>.
Then <span class="math">\(C_x=C_y=c\Delta t/h\)</span>, which we call <span class="math">\(C\)</span>. Also,</p>
<div class="math">
\[p_x=\frac{1}{2} kh\cos\theta,\quad p_y=\frac{1}{2} kh\sin\theta{\thinspace .}\]</div>
<p>The numerical frequency <span class="math">\(\tilde\omega\)</span>
is now a function of three parameters:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(C\)</span> reflecting the number cells a wave is displaced during a time step</li>
<li><span class="math">\(kh\)</span> reflecting the number of cells per wave length in space</li>
<li><span class="math">\(\theta\)</span> expressing the direction of the wave</li>
</ul>
</div></blockquote>
<p>We want to visualize the error in the numerical frequency. To avoid having
<span class="math">\(\Delta t\)</span> as a free parameter in <span class="math">\(\tilde\omega\)</span>, we work with
<span class="math">\(\tilde c/c\)</span>, because the fraction <span class="math">\(2/\Delta t\)</span> is then rewritten as</p>
<div class="math">
\[\frac{2}{kc Delta t} = \frac{2}{2kc\Delta t h/h} =
\frac{1}{Ckh},\]</div>
<p>and</p>
<div class="math">
\[\frac{\tilde c}{c} = \frac{1}{Ckh}
\sin^{-1}\left(C\left(\sin^2 (\frac{1}{2}kh\cos\theta)
+ \sin^2(\frac{1}{2}kh\sin\theta) \right)^{\frac{1}{2}}\right){\thinspace .}\]</div>
<p>We want to visualize this quantity as a function of
<span class="math">\(kh\)</span> and <span class="math">\(\theta\)</span> for some values of <span class="math">\(C\leq 1\)</span>. It is
instructive
to make color contour plots of <span class="math">\(1-\tilde c/c\)</span> in
<em>polar coordinates</em> with <span class="math">\(\theta\)</span> as the angular coordinate and
<span class="math">\(kh\)</span> as the radial coordinate.</p>
<p>The stability criterion <a href="#equation-wave:pde1:analysis:2DstabC">(56)</a>
becomes <span class="math">\(C\leq C_{\max} = 1/\sqrt{2}\)</span> in the present 2D case with the
<span class="math">\(C\)</span> defined above. Let us plot <span class="math">\(1-\tilde c/c\)</span> in polar coordinates
for <span class="math">\(C_{\max}, 0.9C_{\max}, 0.5C_{\max}, 0.2C_{\max}\)</span>.
The program below does the somewhat tricky
work in Matplotlib, and the result appears
in Figure <em class="xref std std-ref">wave:pde1:fig:disprel2D</em>. From the figure we clearly
see that the maximum <span class="math">\(C\)</span> value gives the best results, and that
waves whose propagation direction makes an angle of 45 degrees with
an axis are the most accurate.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">dispersion_relation_2D</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">kh</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                 <span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">kh</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">c_frac</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">kh</span><span class="p">)</span><span class="o">*</span><span class="n">arcsin</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c_frac</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> \
     <span class="n">pi</span><span class="p">,</span> <span class="n">meshgrid</span><span class="p">,</span> <span class="n">arcsin</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">kh</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

<span class="c"># Make 2x2 filled contour plots for 4 values of C</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">C_max</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="n">C_max</span><span class="p">,</span> <span class="mf">0.9</span><span class="o">*</span><span class="n">C_max</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="n">C_max</span><span class="p">,</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">C_max</span><span class="p">]]</span>
<span class="n">fix</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">polar</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">error</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dispersion_relation_2D</span><span class="p">(</span>
            <span class="n">kh</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">C</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">column</span><span class="p">])</span>
        <span class="k">print</span> <span class="n">error</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">error</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span>
            <span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mf">0.36</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

<span class="c"># Add colorbar to the last plot</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">)</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;error in wave velocity&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;disprel2D.png&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;disprel2D.pdf&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure">
<img alt="_images/disprel2D1.png" src="_images/disprel2D1.png" style="width: 600px;" />
<p class="caption">Error in numerical dispersion in 2D. {wave:pde1:fig:disprel2D}</p>
</div>
</div>
</div>
<div class="section" id="finite-difference-methods-for-2d-and-3d-wave-equations">
<span id="wave-2d3d"></span><h1>Finite difference methods for 2D and 3D wave equations<a class="headerlink" href="#finite-difference-methods-for-2d-and-3d-wave-equations" title="Permalink to this headline">¶</a></h1>
<p>A natural next step is to consider extensions of the methods for
various
variants of the one-dimensional wave equation to two-dimensional (2D) and
three-dimensional (3D) versions of the wave equation.</p>
<div class="section" id="multi-dimensional-wave-equations">
<span id="wave-2d3d-models"></span><h2>Multi-dimensional wave equations<a class="headerlink" href="#multi-dimensional-wave-equations" title="Permalink to this headline">¶</a></h2>
<p>The general wave equation in <span class="math">\(d\)</span> space dimensions, with constant
wave velocity <span class="math">\(c\)</span>,
can be written in the compact form</p>
<div class="math" id="equation-wave:2D3D:model1">
<span class="eqno">(58)</span>\[     \frac{\partial^2 u}{\partial t^2} = c^2\nabla^2 u\hbox{ for }\boldsymbol{x}\in\Omega\subset\mathbb{R}^d,\ t\in (0,T] \thinspace .\]</div>
<p>In a 2D problem, <span class="math">\(d=2\)</span>, and</p>
<div class="math">
\[\nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} ,\]</div>
<p>while in three space dimensions, <span class="math">\(d=3\)</span>, and</p>
<div class="math">
\[\nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}
\thinspace .\]</div>
<p>Many applications involve variable coefficients, and the general
wave equation in <span class="math">\(d\)</span> dimensions is in this case written as</p>
<div class="math" id="equation-wave:2D3D:model2">
<span class="eqno">(59)</span>\[     \varrho\frac{\partial^2 u}{\partial t^2} = \nabla\cdot (q\nabla u) + f\hbox{ for }\boldsymbol{x}\in\Omega\subset\mathbb{R}^d,\ t\in (0,T],\]</div>
<p>which in 2D becomes</p>
<div class="math">
\[\varrho(x,y)
\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x,y)
\frac{\partial u}{\partial x}\right)
+
\frac{\partial}{\partial y}\left( q(x,y)
\frac{\partial u}{\partial y}\right)
+ f(x,y,t)
\thinspace .\]</div>
<p>To save some writing and space we may use the index notation, where
subscript <span class="math">\(t\)</span>, <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, or <span class="math">\(z\)</span> means differentiation with respect
to that coordinate. For example,</p>
<div class="math">
\[\begin{split}\frac{\partial^2 u}{\partial t^2} &amp;= u_{tt},\\
\frac{\partial}{\partial y}\left( q(x,y)
\frac{\partial u}{\partial y}\right) &amp;= (q u_y)_y
\thinspace .\end{split}\]</div>
<p>The 3D versions of the
two model PDEs, with and without variable coefficients,
can with now with the aid of the index notation for differentiation
be stated as</p>
<div class="math" id="equation-wave:2D3D:model1:v2">
<span class="eqno">(60)</span>\[     u_{tt} = c^2(u_{xx} + u_{yy} + u_{zz}) + f,\]</div>
<div class="math" id="equation-wave:2D3D:model2:v2">
<span class="eqno">(61)</span>\[     \varrho u_{tt} = (q u_x)_x + (q u_z)_z + (q u_z)_z + f\]\[     \thinspace .\]</div>
<p>At <em>each point</em> of the boundary <span class="math">\(\partial\Omega\)</span> of <span class="math">\(\Omega\)</span> we need
<em>one</em> boundary condition involving the unknown <span class="math">\(u\)</span>.
The boundary conditions are of three principal types:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u\)</span> is prescribed (usually for a known incoming wave),</li>
<li><span class="math">\(\partial u/\partial n = \boldsymbol{n}\cdot\nabla u\)</span> prescribed
(zero for reflecting boundaries),</li>
<li>an open boundary condition (also called radiation condition)
is specified to let waves travel undisturbed out of the domain,
see <a class="reference internal" href="#wave-app-exer-tsunami1d-radiation"><em>Exercise 18: Implement an open boundary condition</em></a> for details.</li>
</ol>
</div></blockquote>
<p>All the listed wave equations with <em>second-order</em> derivatives in
time need <em>two</em> initial conditions:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u=I\)</span>,</li>
<li><span class="math">\(\partial u/\partial u = V\)</span>.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="mesh">
<span id="wave-2d3d-mesh"></span><h2>Mesh<a class="headerlink" href="#mesh" title="Permalink to this headline">¶</a></h2>
<p>We introduce a mesh in time and in space. The mesh in time consists
of time points <span class="math">\(t_0=0 &lt; t_1 &lt;\cdots &lt; t_{N_t}\)</span>, often with a constant
spacing <span class="math">\(\Delta t= t_{n+1}-t_{n}\)</span>, <span class="math">\(n\in{{\mathcal{I^-}_t}}\)</span>.</p>
<p>When using finite difference approximations, the domain shape in space is
normally simple. We assume that <span class="math">\(\Omega\)</span> has the shape of a <span class="math">\(d\)</span>-dimensional
box shape.
Mesh points are introduced separately in the various space directions:
<span class="math">\(x_0 &lt; x_1 &lt;\cdots &lt; x_{N_x}\)</span> in <span class="math">\(x\)</span> direction,
<span class="math">\(y_0 &lt; y_1 &lt;\cdots &lt; y_{N_y}\)</span> in <span class="math">\(y\)</span> direction, and
<span class="math">\(z_0 &lt; z_1 &lt;\cdots &lt; z_{N_z}\)</span> in <span class="math">\(z\)</span> direction.
It is a very common choice to use constant mesh spacings:
<span class="math">\(\Delta x = x_{i+1}-x_{i}\)</span>, <span class="math">\(i\in{{\mathcal{I^-}_x}}\)</span>,
<span class="math">\(\Delta y = y_{j+1}-y_{j}\)</span>, <span class="math">\(j\in{{\mathcal{I^-}_y}}\)</span>, and
<span class="math">\(\Delta z = z_{k+1}-z_{k}\)</span>, <span class="math">\(k\in{{\mathcal{I^-}_z}}\)</span>, but often with
<span class="math">\(\Delta x\neq \Delta y\neq \Delta z\)</span>. In case the mesh spacings
are equal in the spatial directions, one often introduces the
symbol <span class="math">\(h\)</span>:
<span class="math">\(h = \Delta x = \Delta y =\Delta z\)</span>.</p>
<p>The unknown <span class="math">\(u\)</span> at mesh point <span class="math">\((x_i,y_j,z_k,t_n)\)</span> is denoted
<span class="math">\(u^{n}_{i,j,k}\)</span>. In 2D problems we just skip the <span class="math">\(z\)</span> coordinate
(by assuming no variation in that direction: <span class="math">\(\partial/\partial z=0\)</span>)
and write <span class="math">\(u^n_{i,j}\)</span>.</p>
</div>
<div class="section" id="discretization">
<span id="id8"></span><h2>Discretization<a class="headerlink" href="#discretization" title="Permalink to this headline">¶</a></h2>
<p>Two- and three-dimensional wave equations are easily discretized by
assembling building blocks for discretization of
1D wave equations, because the multi-dimensional versions just contain
terms of the same type that occur in 1D.</p>
<div class="section" id="discretizing-the-pdes">
<h3>Discretizing the PDEs<a class="headerlink" href="#discretizing-the-pdes" title="Permalink to this headline">¶</a></h3>
<p>For example,
<a href="#equation-wave:2D3D:model1:v2">(60)</a> can be discretized as</p>
<div class="math">
\[[D_tD_t u = c^2(D_xD_x u + D_yD_yu + D_zD_z u) + f]^n_{i,j,k}
\thinspace .\]</div>
<p>A 2D version might be instructive to write out in detail:</p>
<div class="math">
\[[D_tD_t u = c^2(D_xD_x u + D_yD_yu) + f]^n_{i,j,k},\]</div>
<p>which becomes</p>
<div class="math">
\[\frac{u^{n+1}_{i,j} - 2u^{n}_{i,j} + u^{n-1}_{i,j}}{\Delta t^2}
= c^2
\frac{u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}}{\Delta x^2}
+ c^2
\frac{u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}}{\Delta y^2}
+ f^n_{i,j},\]</div>
<p>Assuming as usual that all values at the time levels <span class="math">\(n\)</span> and <span class="math">\(n-1\)</span>
are known, we can solve for the only unknown <span class="math">\(u^{n+1}_{i,j}\)</span>.</p>
<p>As in the 1D case, we need to develop a special formula for <span class="math">\(u^1_{i,j}\)</span>
where we combine the general scheme for <span class="math">\(u^{n+1}_{i,j}\)</span>, when <span class="math">\(n=0\)</span>,
with the discretization of the initial condition:</p>
<div class="math">
\[[D_{2t}u = V]^0_{i,j}\quad\Rightarrow\quad u^{-1}_{i,j} = u^1_{i,j} - 2\Delta t V_{i,j}
\thinspace .\]</div>
<p>The PDE <a href="#equation-wave:2D3D:model2:v2">(61)</a>
with variable coefficients is discretized term by term using
the corresponding elements from the 1D case:</p>
<div class="math">
\[[\varrho D_tD_t u = (D_x\overline{q}^x D_x u +
D_y\overline{q}^y D_yu + D_z\overline{q}^z D_z u) + f]^n_{i,j,k}
\thinspace .\]</div>
<p>When written out and solved for the unknown <span class="math">\(u^{n+1}_{i,j,k}\)</span>, one gets the
scheme</p>
<div class="math">
\[\begin{split}u^{n+1}_{i,j,k} &amp;= - u^{n-1}_{i,j,k}  + 2u^{n}_{i,j,k} + \\
&amp;= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i+1,j,k})(u^{n}_{i+1,j,k} - u^{n}_{i,j,k}) - \\
&amp;\qquad\quad \frac{1}{2}(q_{i-1,j,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i-1,j,k})) + \\
&amp;= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i,j+1,k})(u^{n}_{i,j+1,k} - u^{n}_{i,j,k}) - \\
&amp;\qquad\quad\frac{1}{2}(q_{i,j-1,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j-1,k})) + \\
&amp;= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i,j,k+1})(u^{n}_{i,j,k+1} - u^{n}_{i,j,k}) -\\
&amp;\qquad\quad \frac{1}{2}(q_{i,j,k-1} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j,k-1})) + \\
+ &amp;\qquad \Delta t^2 f^n_{i,j,k}
\thinspace .\end{split}\]</div>
<p>Also here we need to develop a special formula for <span class="math">\(u^1_{i,j,k}\)</span>
by combining the scheme for <span class="math">\(n=0\)</span> with the discrete initial condition
<span class="math">\(u^{-1}_{i,j,k}=u^1_{i,j,k} - 2\Delta tV_{i,j,k}\)</span>.</p>
</div>
<div class="section" id="handling-boundary-conditions-where-is-known">
<h3>Handling boundary conditions where is <span class="math">\(u\)</span> known<a class="headerlink" href="#handling-boundary-conditions-where-is-known" title="Permalink to this headline">¶</a></h3>
<p>The schemes listed above are valid for the internal points in the mesh.
After updating these, we need to visit all the mesh points at the
boundaries and set the prescribed <span class="math">\(u\)</span> value.</p>
</div>
<div class="section" id="discretizing-the">
<h3>Discretizing the <span class="math">\(\partial u/\partial n = 0\)</span><a class="headerlink" href="#discretizing-the" title="Permalink to this headline">¶</a></h3>
<p>The condition <span class="math">\(\partial u/\partial n = 0\)</span> was implemented in 1D by
discretizing it with a <span class="math">\(D_{2t}u\)</span> centered difference, and thereafter
eliminating the fictitious <span class="math">\(u\)</span> point outside the mesh by using the
general scheme at the boundary point. Exactly the same idea is reused
in multi dimensions. Consider  <span class="math">\(\partial u/\partial n = 0\)</span>
at a boundary <span class="math">\(y=0\)</span>. The normal direction is then in <span class="math">\(-y\)</span> direction,
so</p>
<div class="math">
\[\frac{\partial u}{\partial n} = -\frac{\partial u}{\partial y},\]</div>
<p>and we set</p>
<div class="math">
\[[-D_{2y} u = 0]^n_{i,0}\quad\Rightarrow\quad \frac{u^n_{i,1}-u^n_{i,-1}}{2\Delta y} = 0
\thinspace .\]</div>
<p>From this it follows that <span class="math">\(u^n_{i,-1}=u^n_{i,1}\)</span>.
The discretized PDE at the boundary point <span class="math">\((i,0)\)</span> reads</p>
<div class="math">
\[\frac{u^{n+1}_{i,0} - 2u^{n}_{i,0} + u^{n-1}_{i,0}}{\Delta t^2}
= c^2
\frac{u^{n}_{i+1,0} - 2u^{n}_{i,0} + u^{n}_{i-1,0}}{\Delta x^2}
+ c^2
\frac{u^{n}_{i,1} - 2u^{n}_{i,0} + u^{n}_{i,-1}}{\Delta y^2}
+ f^n_{i,j},\]</div>
<p>We can then just insert <span class="math">\(u^1_{i,j}\)</span> for <span class="math">\(u^n_{i,-1}\)</span> in this equation
and then solve for the boundary value <span class="math">\(u^{n+1}_{i,0}\)</span>.</p>
<p>From these calculations, we see a pattern:
the general scheme applies at the boundary <span class="math">\(j=0\)</span> too if we just
replace <span class="math">\(j-1\)</span> by <span class="math">\(j+1\)</span>. Such a pattern is particularly useful for
implementations.</p>
</div>
</div>
</div>
<div class="section" id="implementation-3">
<span id="wave-2d3d-impl"></span><h1>Implementation  (3)<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h1>
<p id="index-35">We shall now describe in detail various Python implementations
for solving a standard 2D, linear wave equation with constant
wave velocity and <span class="math">\(u=0\)</span> on the
boundary. The wave equation is to be solved
in the space-time domain <span class="math">\(\Omega\times (0,T]\)</span>,
where <span class="math">\(\Omega = [0,L_x]\times [0,L_y]\)</span> is a rectangular spatial
domain. More precisely,
the complete initial-boundary value problem is defined by</p>
<div class="math">
\[u_t = c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad (x,y)\in \Omega,\ t\in (0,T],\]</div>
<div class="math">
\[u(x,y,0) = I(x,y),\quad (x,y)\in\Omega,\]</div>
<div class="math">
\[u_t(x,y,0) = V(x,y),\quad (x,y)\in\Omega,\]</div>
<div class="math">
\[u = 0,\quad (x,y)\in\partial\Omega,\ t\in (0,T],\]</div>
<p>where <span class="math">\(\partial\Omega\)</span> is the boundary of <span class="math">\(\Omega\)</span>, in this case
the four sides of the rectangle <span class="math">\([0,L_x]\times [0,L_y]\)</span>:
<span class="math">\(x=0,\)</span>, <span class="math">\(x=L_x\)</span>, <span class="math">\(y=0\)</span>, and <span class="math">\(y=L_y\)</span>.</p>
<p>The PDE is discretized as</p>
<div class="math">
\[[D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j},\]</div>
<p>which leads to an explicit updating formula to be implemented in a
program:</p>
<div class="math" id="equation-wave:2D3D:impl1:2Du0:ueq:discrete">
<span class="eqno">(62)</span>\[     u^{n+1} = -u^{n-1}_{i,j} + 2u^n_{i,j} + C_x^2(
     u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}) + C_y^2
     (u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}) + \Delta t^2 f_{i,j}^n,\]</div>
<p>for all interior mesh points <span class="math">\(i=0,\ldots,N_x-1\)</span> and
<span class="math">\(j=0,\ldots,N_y-1\)</span>, and for <span class="math">\(n=1,\ldots, N_t\)</span>.
The constants <span class="math">\(C_x\)</span> and <span class="math">\(C_y\)</span> are defined as</p>
<div class="math">
\[C_x = c\frac{\Delta t}{\Delta x},\quad C_x = c\frac{\Delta t}{\Delta y}
\thinspace .\]</div>
<p>At the boundary we simply set <span class="math">\(u^{n+1}_{i,j}=0\)</span> for
<span class="math">\(i=0\)</span>, <span class="math">\(j=0,\ldots,N_y\)</span>; <span class="math">\(i=N_x\)</span>, <span class="math">\(j=0,\ldots,N_y\)</span>;
<span class="math">\(j=0\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>; and <span class="math">\(j=N_y\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>.
For the first step, <span class="math">\(n=0\)</span>, <a href="#equation-wave:2D3D:impl1:2Du0:ueq:discrete">(63)</a>
is combined with the discretization of the initial condition <span class="math">\(u_t=V\)</span>,
<span class="math">\([D_{2t} u = V]^0_{i,j}\)</span> to obtain a special formula for
<span class="math">\(u^1_{i,j}\)</span> at the interior mesh points:</p>
<div class="math" id="equation-wave:2D3D:impl1:2Du0:ueq:discrete">
<span class="eqno">(63)</span>\[     u^{1} = u^0_{i,j} + \Delta t V_{i,j} + \frac{1}{2}C_x^2(
     u^{0}_{i+1,j} - 2u^{0}_{i,j} + u^{0}_{i-1,j}) + \frac{1}{2}C_y^2
     (u^{0}_{i,j+1} - 2u^{0}_{i,j} + u^{0}_{i,j-1}) + \frac{1}{2}\Delta t^2f_{i,j}^n,\]</div>
<div class="section" id="scalar-computations">
<h2>Scalar computations<a class="headerlink" href="#scalar-computations" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">solver</span></tt> function for a 2D case with constant wave velocity and
<span class="math">\(u=0\)</span> as boundary condition follows the setup from the similar
function for the 1D case in <tt class="docutils literal"><span class="pre">wave1D_u0_s.py</span></tt>, but there are
a few necessary extensions. The code is in the program
<a class="reference external" href="/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>.</p>
<div class="section" id="domain-and-mesh">
<h3>Domain and mesh<a class="headerlink" href="#domain-and-mesh" title="Permalink to this headline">¶</a></h3>
<p>The spatial domain is now <span class="math">\([0,L_x]\times [0,L_y]\)</span>, specified
by the arguments <tt class="docutils literal"><span class="pre">Lx</span></tt> and <tt class="docutils literal"><span class="pre">Ly</span></tt>. Similarly, the number of mesh
points in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions,
<span class="math">\(N_x\)</span> and <span class="math">\(N_y\)</span>, become the arguments <tt class="docutils literal"><span class="pre">Nx</span></tt> and <tt class="docutils literal"><span class="pre">Ny</span></tt>.
In multi-dimensional problems it makes less sense to specify a
Courant number as the wave velocity is a vector and the mesh spacings
may differ in the various spatial directions.
We therefore give <span class="math">\(\Delta t\)</span> explicitly. The signature of
the <tt class="docutils literal"><span class="pre">solver</span></tt> function is then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span>
           <span class="n">dt_safety_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</pre></div>
</div>
<p>Key parameters used in the calculations are created as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># mesh points in x dir</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># mesh points in y dir</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># mesh points in time</span>
<span class="n">Cx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>    <span class="c"># help variables</span>
<span class="n">dt2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="stability-limit">
<h3>Stability limit<a class="headerlink" href="#stability-limit" title="Permalink to this headline">¶</a></h3>
<p>Specifying a negative <tt class="docutils literal"><span class="pre">dt</span></tt> parameter makes us use the stability
limit with a safety factor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">stability_limit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt_safety_factor</span><span class="o">*</span><span class="n">stability_limit</span>
</pre></div>
</div>
</div>
<div class="section" id="solution-arrays">
<h3>Solution arrays<a class="headerlink" href="#solution-arrays" title="Permalink to this headline">¶</a></h3>
<p>We store <span class="math">\(u^{n+1}_{i,j}\)</span>, <span class="math">\(u^{n}_{i,j}\)</span>, and
<span class="math">\(u^{n-1}_{i,j}\)</span> in three two-dimensional arrays,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution array</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution at t-dt</span>
<span class="n">u_2</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution at t-2*dt</span>
</pre></div>
</div>
<p>where <span class="math">\(u^{n+1}_{i,j}\)</span> corresponds to <tt class="docutils literal"><span class="pre">u[i,j]</span></tt>,
<span class="math">\(u^{n}_{i,j}\)</span> to <tt class="docutils literal"><span class="pre">u_1[i,j]</span></tt>, and
<span class="math">\(u^{n-1}_{i,j}\)</span> to <tt class="docutils literal"><span class="pre">u_1[i,j]</span></tt></p>
</div>
<div class="section" id="computing-the-solution">
<h3>Computing the solution<a class="headerlink" href="#computing-the-solution" title="Permalink to this headline">¶</a></h3>
<p>Inserting the initial
condition <tt class="docutils literal"><span class="pre">I</span></tt> in <tt class="docutils literal"><span class="pre">u_1</span></tt> and making a callback to the user in terms of
the <tt class="docutils literal"><span class="pre">user_action</span></tt> function should be straightforward generalization of
the 1D code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

<span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">user_action</span></tt> function has more arguments which will be commented
upon in the section on vectorization.</p>
<p>The key finite difference formula for updating the solution at
a time level is implemented as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
                 <span class="n">Cx2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">Cy2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                 <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>We must thereafter ensure that <tt class="docutils literal"><span class="pre">u</span></tt> is zero on the four boundaries:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>The special formula for the first step (<span class="math">\(u^1_{i,j}\)</span>) is implemented
in a very similar manner.</p>
<p>The code segments with the loop over internal points and boundary
points at each time level are put in a separate function <tt class="docutils literal"><span class="pre">advance_scalar</span></tt>.
Below, we will make many alternative implementations to speed
up the code since most of
the CPU time is spent in this function.</p>
</div>
</div>
<div class="section" id="vectorized-computations">
<h2>Vectorized computations<a class="headerlink" href="#vectorized-computations" title="Permalink to this headline">¶</a></h2>
<p>The scalar code above turns out to be extremely slow for large 2D
meshes, and probably useless beyond initial debugging in 3D.
Vectorization is therefore a must for multi-dimensional
finite difference computations in Python. For example,
with a mesh consisting of <span class="math">\(30\times 30\)</span> cells, vectorization
brings down the CPU time by a factor of 70 (!).</p>
<p>In the vectorized case we must be able to evaluate user-given functions
like <span class="math">\(I(x,y)\)</span> and <span class="math">\(f(x,y,t)\)</span>, provided as Python functions <tt class="docutils literal"><span class="pre">I(x,y)</span></tt>
and <tt class="docutils literal"><span class="pre">f(x,y,t)</span></tt>, for the entire mesh in one array operation.
Having the one-dimensional coordinate arrays <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> is not
sufficient: these must be extended to vectorized versions,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span>
<span class="c"># or</span>
<span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</pre></div>
</div>
<p>This is a standard required technique when evaluating functions over
a 2D mesh, say <tt class="docutils literal"><span class="pre">sin(xv)*cos(xv)</span></tt>, which then gives a results with shape
<tt class="docutils literal"><span class="pre">(Nx+1,Ny+1)</span></tt>.
With the <tt class="docutils literal"><span class="pre">xv</span></tt> and <tt class="docutils literal"><span class="pre">yv</span></tt> arrays for vectorized computing,
setting the initial condition is just a matter of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_1</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">)</span>
</pre></div>
</div>
<p>One could also have written <tt class="docutils literal"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">I(xv,</span> <span class="pre">yv)</span></tt> and let <tt class="docutils literal"><span class="pre">u_1</span></tt> point
to a new object, but vectorized operations often makes use of
direct insertion in the original array through <tt class="docutils literal"><span class="pre">u_1[:,:]</span></tt> because
sometimes not all of the array is to be filled by such a function
evaluation. This is the case with the computational scheme for <span class="math">\(u^{n+1}_{i,j}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
      <span class="n">Cx2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
      <span class="n">Cy2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:])</span> <span class="o">+</span> \
      <span class="n">dt2</span><span class="o">*</span><span class="n">f_a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Array slices in 2D are more complicated to understand than those in
1D, but the logic from 1D applies to each dimension separately.
For example, when doing <span class="math">\(u^{n}_{i,j} - u^{n}_{i-1,j}\)</span> for <span class="math">\(i=1,\ldots,N_x\)</span>,
we just keep <tt class="docutils literal"><span class="pre">j</span></tt> constant and make a slice in the first index:
<tt class="docutils literal"><span class="pre">u_1[1:,j]</span> <span class="pre">-</span> <span class="pre">u_1[:-1,j]</span></tt>, exactly as in 1D. The <tt class="docutils literal"><span class="pre">1:</span></tt> slice
specifies all the indices <span class="math">\(i=1,\ldots,N_x\)</span> for the term <span class="math">\(u^n_{i,j}\)</span>,
while <tt class="docutils literal"><span class="pre">:-1</span></tt> specifies the relevant indices for the second term,
where <span class="math">\(i-1=1,\ldots,N_x\)</span> and the indices therefore becomes <span class="math">\(0,1,\ldots,N_x-1\)</span>.
In the above code segment, the situation is slightly more complicated,
because each displaced slice in one direction is
accompanied by a <tt class="docutils literal"><span class="pre">1:-1</span></tt> slice in the other direction. The reason is
that we only work with the internal points for the index that is
kept constant in a difference.</p>
<p>The <tt class="docutils literal"><span class="pre">f</span></tt> function is in the above vectorized update of <tt class="docutils literal"><span class="pre">u</span></tt> first computed
as an array over all mesh points:</p>
<div class="highlight-text"><div class="highlight"><pre>f_a = f(xv, yv, t[n])
</pre></div>
</div>
<p>(We could, alternatively, used the call <tt class="docutils literal"><span class="pre">f(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])[1:-1,1:-1]</span></tt>
in the last term of the update statement, but other implementations
in compiled languages benefit from having <tt class="docutils literal"><span class="pre">f</span></tt> available in an array
rather than calling our Python function <tt class="docutils literal"><span class="pre">f(x,y,t)</span></tt> for
every point.)</p>
<p>The boundary conditions along the four sides makes use of
a slice consisting of all indices along a boundary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[:</span> <span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[:,</span><span class="n">Ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span> <span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>The shown snippets appear in a function <tt class="docutils literal"><span class="pre">advance_vectorized</span></tt>.</p>
<p>The callback function now has the arguments
<tt class="docutils literal"><span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">xv,</span> <span class="pre">y,</span> <span class="pre">yv,</span> <span class="pre">t,</span> <span class="pre">n</span></tt>. The inclusion of <tt class="docutils literal"><span class="pre">xv</span></tt> and <tt class="docutils literal"><span class="pre">yv</span></tt> makes it
easy to, e.g., compute an exact 2D solution in the callback function
and compute errors, through something like
<tt class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">exact_solution(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])</span></tt>.</p>
</div>
<div class="section" id="verification-3">
<h2>Verification  (3)<a class="headerlink" href="#verification-3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="testing-a-quadratic-solution">
<h3>Testing a quadratic solution<a class="headerlink" href="#testing-a-quadratic-solution" title="Permalink to this headline">¶</a></h3>
<p>The 1D solution from the section <em class="xref std std-ref">wave:pde2</em> can be generalized to
multi dimensions and provides a test case where the exact
solution also fulfills the discrete equations. In 2D we have</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,y,t) = x(L_x-x)y(L_y-y)(1+\frac{1}{2}t)
\thinspace .\]</div>
<p>This solution fulfills the PDE problem if <span class="math">\(I(x,y)={u_{\small\mbox{e}}}(x,y,0)\)</span>,
<span class="math">\(V=\frac{1}{2}{u_{\small\mbox{e}}}(x,y,0)\)</span>, and <span class="math">\(f=2c^2(1+\frac{1}{2}t)(y(L_y-y +
x(L_x-x))\)</span>. With the results <span class="math">\([D_t D_t t]^n=0\)</span> and <span class="math">\([D_t D_t t^2]=2\)</span>,
and</p>
<div class="math">
\[[D_xD_x {u_{\small\mbox{e}}}]^n_{i,j} = [y(L_y-y)(1+\frac{1}{2}t) D_xD_x x(L_x-x)]^n_{i,j}
= y_j(L_y-y_j)(1+\frac{1}{2}t_n)2,\]</div>
<p>with similar calculations for the other terms,
we can easily show that <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfills the discrete equation</p>
<div class="math">
\[[D_t D_t {u_{\small\mbox{e}}} = c^2(D_x D_x {u_{\small\mbox{e}}} + D_y D_y {u_{\small\mbox{e}}} + f]^n_{i,j}
\thinspace .\]</div>
<p>With an
exact solution of the discrete equation we should expect
a numerical error at the level of the machine precision
(as long as <span class="math">\(|{u_{\small\mbox{e}}}|\sim {\cal O}(1)\)</span>).
The <tt class="docutils literal"><span class="pre">test_quadratic</span></tt> function in the
<a class="reference external" href="/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>
program implements this verification as a nose test.</p>
</div>
</div>
<div class="section" id="migrating-loops-to-cython">
<h2>Migrating loops to Cython<a class="headerlink" href="#migrating-loops-to-cython" title="Permalink to this headline">¶</a></h2>
<p id="index-36">Although vectorization can bring down the CPU time dramatically
compared with scalar code, there is still some factor 5-10 to win
in these types of applications
by implementing the finite difference scheme in compiled code,
typically in Fortran, C, or C++. This can quite easily be done by
adding a little extra code to our program. Cython is an extension of
Python that offers the easiest way to nail our Python loops in the
scalar code down to machine code and the efficiency of C.</p>
<p>Cython can be viewed as an extension of Python where variables are
declared with types and functions are marked to be implemented in C.
Migrating Python code to Cython is done by copying the desired code
segments to functions (or classes) and placing them in one or more separate
files with extension <tt class="docutils literal"><span class="pre">.pyx</span></tt>.</p>
<div class="section" id="declaring-variables-and-annotating-the-code">
<h3>Declaring variables and annotating the code<a class="headerlink" href="#declaring-variables-and-annotating-the-code" title="Permalink to this headline">¶</a></h3>
<p>Our starting point is the plain <tt class="docutils literal"><span class="pre">advance_scalar</span></tt> function. We simply take
a copy of this code and put it in a file <tt class="docutils literal"><span class="pre">wave2D_u0_loop_cy.pyx</span></tt>.
The relevant Cython implementation arises from declaring variables with
types and adding some important annotations to speed up array
computing in Cython. Let us first list the code:</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">cimport</span> <span class="nn">cython</span>
<span class="k">ctypedef</span> <span class="n">np</span><span class="o">.</span><span class="n">float64_t</span> <span class="n">DT</span>    <span class="c"># data type</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>  <span class="c"># turn off array bounds check</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>   <span class="c"># turn off negative indices (u[-1,-1])</span>
<span class="k">cpdef</span> <span class="nf">advance</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">DT</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">u</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">DT</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">u_1</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">DT</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">u_2</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">DT</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">f</span><span class="p">,</span>
    <span class="n">double</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">double</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">double</span> <span class="n">dt2</span><span class="p">):</span>

    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">Nx</span><span class="p">,</span> <span class="nf">Ny</span><span class="p">,</span> <span class="nf">i</span><span class="p">,</span> <span class="nf">j</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">-</span><span class="mf">1</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="o">-</span><span class="mf">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
            <span class="n">Cx2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mf">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> \
            <span class="n">Cy2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mf">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mf">1</span><span class="p">])</span> <span class="o">+</span> \
            <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
    <span class="c"># Boundary condition u=0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mf">1</span><span class="p">):</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p id="index-37">This example may act as a recipe on how to transform array-intensive
code with loops into Cython.</p>
<ol class="arabic simple">
<li>Variables are declared with types: for example,
<tt class="docutils literal"><span class="pre">double</span> <span class="pre">v</span></tt> in the argument list and <tt class="docutils literal"><span class="pre">cdef</span> <span class="pre">double</span> <span class="pre">v</span></tt>
for a variable <tt class="docutils literal"><span class="pre">v</span></tt> in the body of the function.
A Python <tt class="docutils literal"><span class="pre">float</span></tt> variable is declared as <tt class="docutils literal"><span class="pre">double</span></tt> for
translation to C by Cython, while an <tt class="docutils literal"><span class="pre">int</span></tt> object is
declared by <tt class="docutils literal"><span class="pre">int</span></tt>.</li>
<li>Arrays need a comprehensive type declaration involving<ul>
<li>the type <tt class="docutils literal"><span class="pre">np.ndarray</span></tt>,</li>
<li>the data type of the elements, here 64-bit floats,
abbreviated as <tt class="docutils literal"><span class="pre">DT</span></tt> through <tt class="docutils literal"><span class="pre">ctypedef</span> <span class="pre">np.float64_t</span> <span class="pre">DT</span></tt>
(instead of <tt class="docutils literal"><span class="pre">DT</span></tt> we could use the full name of the
data type: <tt class="docutils literal"><span class="pre">np.float64_t</span></tt>, which is a Cython-defined type),</li>
<li>the dimensions of the array, here <tt class="docutils literal"><span class="pre">ndim=2</span></tt> and <tt class="docutils literal"><span class="pre">ndim=1</span></tt>,</li>
<li>specification of contiguous memory for the array (<tt class="docutils literal"><span class="pre">mode='c'</span></tt>)</li>
</ul>
</li>
<li>Functions declared with <tt class="docutils literal"><span class="pre">cpdef</span></tt> are translated to C but also
accessible from Python.</li>
<li>In addition to the standard <tt class="docutils literal"><span class="pre">numpy</span></tt> import we also need a special
Cython import of <tt class="docutils literal"><span class="pre">numpy</span></tt>: <tt class="docutils literal"><span class="pre">cimport</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></tt>, to appear <em>after</em>
the standard import.</li>
<li>By default, array indices are checked to be within their legal
limits. To speed up the code one should turn off this feature
for a specific function by placing <tt class="docutils literal"><span class="pre">&#64;cython.boundscheck(False)</span></tt>
above the function header.</li>
<li>Also by default, array indices can be negative (counting from the
end), but this feature has a performance penalty and is therefore
here turned off by writing <tt class="docutils literal"><span class="pre">&#64;cython.wraparound(False)</span></tt> right above
the function header.</li>
</ol>
</div>
<div class="section" id="visual-inspection-of-the-c-translation">
<span id="index-38"></span><h3>Visual inspection of the C translation<a class="headerlink" href="#visual-inspection-of-the-c-translation" title="Permalink to this headline">¶</a></h3>
<p>Cython can visually explain how successfully it can translate a code from
Python to C. The command</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; cython -a wave2D_u0_loop_cy.pyx</span>
</pre></div>
</div>
<p>produces an HTML file <tt class="docutils literal"><span class="pre">wave2D_u0_loop_cy.html</span></tt>, which can be loaded into
a web browser to illustrate which lines of the code that have been
translated to C. Figure <a class="reference internal" href="#wave-2d3d-impl-fig-cython-ma1"><em>Visual illustration of Cython&#8217;s ability to translate Python to C</em></a> shows
the results. Yellow lines indicate the lines that Cython did not manage
to translate to efficient C code and that remain in Python.
For the present code we see that Cython is able to translate all the
loops with array computing to C, which is our primary goal.</p>
<div class="figure" id="wave-2d3d-impl-fig-cython-ma1">
<img alt="_images/wave2D_u0_loop_cy11.png" src="_images/wave2D_u0_loop_cy11.png" style="width: 500px;" />
<p class="caption"><em>Visual illustration of Cython&#8217;s ability to translate Python to C</em></p>
</div>
<p>You can also inspect the generated C code directly, in the file
<tt class="docutils literal"><span class="pre">wave2D_u0_loop_cy.c</span></tt>, but understanding this C code requires
familiarity with writing Python extension modules in C by hand. However,
deep down in the file we can see in detail how the compute-intensive
statements are translated some complex C that is quite different from
what we a human would write, at least with a direct corresponding to
the mathematics in mind.</p>
<span class="target" id="index-39"></span><span class="target" id="index-40"></span></div>
<div class="section" id="building-the-extension-module-1">
<span id="index-41"></span><h3>Building the extension module  (1)<a class="headerlink" href="#building-the-extension-module-1" title="Permalink to this headline">¶</a></h3>
<p>Cython code must be translated to C, compiled, and linked to form what
is known in the Python world as a <em>C extension module</em>.
This is usually done by making a <tt class="docutils literal"><span class="pre">setup.py</span></tt> script, which
is the standard way of building and installing Python software:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">distutils.extension</span> <span class="kn">import</span> <span class="n">Extension</span>
<span class="kn">from</span> <span class="nn">Cython.Distutils</span> <span class="kn">import</span> <span class="n">build_ext</span>

<span class="n">cymodule</span> <span class="o">=</span> <span class="s">&#39;wave2D_u0_loop_cy&#39;</span>
<span class="n">setup</span><span class="p">(</span>
  <span class="n">name</span><span class="o">=</span><span class="n">cymodule</span>
  <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">Extension</span><span class="p">(</span><span class="n">cymodule</span><span class="p">,</span> <span class="p">[</span><span class="n">cymodule</span> <span class="o">+</span> <span class="s">&#39;.pyx&#39;</span><span class="p">],)],</span>
  <span class="n">cmdclass</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;build_ext&#39;</span><span class="p">:</span> <span class="n">build_ext</span><span class="p">},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To translate to C, compile, and build the module <tt class="docutils literal"><span class="pre">wave2D_u0_loop_cy</span></tt>,
run</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python setup.py build_ext --inplace</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">--inplace</span></tt> option makes the extension module available in the
current directory as the file <tt class="docutils literal"><span class="pre">wave2D_u0_loop_cy.so</span></tt>. This
file acts as a normal Python module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">wave2D_u0_loop_cy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">wave2D_u0_loop_cy</span><span class="p">)</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;,</span>
<span class="go"> &#39;__package__&#39;, &#39;__test__&#39;, &#39;advance&#39;, &#39;np&#39;]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">setup.py</span></tt> file makes use of the <tt class="docutils literal"><span class="pre">distutils</span></tt> package in Python
and Cython&#8217;s extension of this package.
These tools know how Python was built on the computer and will
use compatible compiler(s) and options when building other code
in Cython, C, or C++. Quite some experience with building large
program systems is needed to do the build process manually.</p>
<p>When there is no need to link the C code with special libraries,
Cython offers a shortcut for generating and importing the extension
module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pyximport</span><span class="p">;</span> <span class="n">pyximport</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>
</pre></div>
</div>
<p>This makes the <tt class="docutils literal"><span class="pre">setup.py</span></tt> script redundant. However, in the <tt class="docutils literal"><span class="pre">wave2D_u0.py</span></tt>
code we do not use <tt class="docutils literal"><span class="pre">pyximport</span></tt> and require an explicit build process
of this and many other modules.</p>
</div>
<div class="section" id="calling-the-cython-function">
<h3>Calling the Cython function<a class="headerlink" href="#calling-the-cython-function" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">wave2D_u0_loop_cy</span></tt>
module contains our <tt class="docutils literal"><span class="pre">advance</span></tt> function, which we now may call from
the Python program for the wave equation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">wave2D_u0_loop_cy</span>
<span class="n">cython_advance</span> <span class="o">=</span> <span class="n">wave2D_u0_loop_cy</span><span class="o">.</span><span class="n">advance</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>        <span class="c"># time loop</span>
    <span class="n">f_a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>     <span class="c"># precompute, size as u</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">cython_advance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">f_a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                       <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="efficiency-1">
<h3>Efficiency  (1)<a class="headerlink" href="#efficiency-1" title="Permalink to this headline">¶</a></h3>
<p>For a mesh consisting of <span class="math">\(120\times 120\)</span> cells, the scalar Python code
require 1370 CPU time units, the vectorized version requires 5.5,
while the Cython version requires only 1! For a mesh with <span class="math">\(60\times 60\)</span>
cells Cython is about 1000 times faster than the scalar Python code,
and the vectorized version is about 6 times slower than the Cython version.</p>
</div>
</div>
<div class="section" id="migrating-loops-to-fortran">
<h2>Migrating loops to Fortran<a class="headerlink" href="#migrating-loops-to-fortran" title="Permalink to this headline">¶</a></h2>
<p>Instead of relying on Cython&#8217;s (excellent) ability to translate Python to C,
we can invoke a compiled language directly and write the loops ourselves.
Let us start with Fortran 77, because this is a language with more
convenient array handling than C (or plain C++). Or more precisely,
we can with ease program with multi-dimensional indices in the <tt class="docutils literal"><span class="pre">numpy</span></tt>
arrays that are transferred to Fortran, while in C these arrays are
one-dimensional. Let us also mention that
the Fortran compilers
build on 60 years of intensive research on how to optimize loops with
array computations.</p>
<span class="target" id="index-42"></span><div class="section" id="the-fortran-subroutine">
<span id="index-43"></span><h3>The Fortran subroutine<a class="headerlink" href="#the-fortran-subroutine" title="Permalink to this headline">¶</a></h3>
<p>We write a Fortran subroutine <tt class="docutils literal"><span class="pre">advance</span></tt> in a file
<a class="reference external" href="/wave2D_u0/wave2D_u0_loop_f77.f">wave2D_u0_loop_f77.f</a>
for implementing the updating formula
<a href="#equation-wave:2D3D:impl1:2Du0:ueq:discrete">(63)</a> and setting the solution to zero
at the boundaries:</p>
<div class="highlight-fortran"><div class="highlight"><pre>      <span class="k">subroutine </span><span class="nv">advance</span><span class="p">(</span><span class="nv">u</span><span class="p">,</span> <span class="nv">u_1</span><span class="p">,</span> <span class="nv">u_2</span><span class="p">,</span> <span class="nv">f</span><span class="p">,</span> <span class="nv">Cx2</span><span class="p">,</span> <span class="nv">Cy2</span><span class="p">,</span> <span class="nv">dt2</span><span class="p">,</span> <span class="nv">Nx</span><span class="p">,</span> <span class="nv">Ny</span><span class="p">)</span>
      <span class="kt">integer </span><span class="nv">Nx</span><span class="p">,</span> <span class="nv">Ny</span>
      <span class="kt">real</span><span class="o">*</span><span class="mi">8</span> <span class="nv">u</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="nv">Nx</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="nv">Ny</span><span class="p">),</span> <span class="nv">u_1</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="nv">Nx</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="nv">Ny</span><span class="p">),</span> <span class="nv">u_2</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="nv">Nx</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="nv">Ny</span><span class="p">)</span>
      <span class="kt">real</span><span class="o">*</span><span class="mi">8</span> <span class="nv">f</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="nv">Nx</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nv">Ny</span><span class="p">),</span> <span class="nv">Cx2</span><span class="p">,</span> <span class="nv">Cy2</span><span class="p">,</span> <span class="nv">dt2</span>
      <span class="kt">integer </span><span class="nv">i</span><span class="p">,</span> <span class="nv">j</span>
<span class="nv">Cf2py</span> <span class="k">intent</span><span class="p">(</span><span class="nv">in</span><span class="p">,</span> <span class="nv">out</span><span class="p">)</span> <span class="nv">u</span>

<span class="nv">C</span>     <span class="nv">Scheme</span> <span class="nv">at</span> <span class="nv">interior</span> <span class="nv">points</span>
      <span class="k">do </span><span class="nv">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">Ny</span><span class="o">-</span><span class="mi">1</span>
         <span class="k">do </span><span class="nv">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">Nx</span><span class="o">-</span><span class="mi">1</span>
            <span class="nv">u</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nv">u_1</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">-</span> <span class="nv">u_2</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">+</span>
     <span class="p">&amp;</span>      <span class="nv">Cx2</span><span class="o">*</span><span class="p">(</span><span class="nv">u_1</span><span class="p">(</span><span class="nv">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="nv">u_1</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">+</span> <span class="nv">u_1</span><span class="p">(</span><span class="nv">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nv">j</span><span class="p">))</span> <span class="o">+</span>
     <span class="p">&amp;</span>      <span class="nv">Cy2</span><span class="o">*</span><span class="p">(</span><span class="nv">u_1</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="nv">u_1</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">+</span> <span class="nv">u_1</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
     <span class="p">&amp;</span>      <span class="nv">dt2</span><span class="o">*</span><span class="nv">f</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span>
         <span class="k">end do</span>
<span class="k">      end do</span>

<span class="nv">C</span>     <span class="nv">Boundary</span> <span class="nv">conditions</span>
      <span class="nv">j</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">do </span><span class="nv">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Nx</span>
         <span class="nv">u</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">end do</span>
<span class="k">      </span><span class="nv">j</span> <span class="o">=</span> <span class="nv">Ny</span>
      <span class="k">do </span><span class="nv">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Nx</span>
         <span class="nv">u</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">end do</span>
<span class="k">      </span><span class="nv">i</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">do </span><span class="nv">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Ny</span>
         <span class="nv">u</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">end do</span>
<span class="k">      </span><span class="nv">i</span> <span class="o">=</span> <span class="nv">Nx</span>
      <span class="k">do </span><span class="nv">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Ny</span>
         <span class="nv">u</span><span class="p">(</span><span class="nv">i</span><span class="p">,</span><span class="nv">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">end do</span>
<span class="k">      return</span>
<span class="k">      end</span>
</pre></div>
</div>
<p>This code is plain Fortran 77, except for the special <tt class="docutils literal"><span class="pre">Cf2py</span></tt> comment
line, which here specifies that <tt class="docutils literal"><span class="pre">u</span></tt> is both an input argument <em>and</em>
an object to be returned from the <tt class="docutils literal"><span class="pre">advance</span></tt> routine. Or more
precisely, Fortran is not able return an array from a function,
but we need a <em>wrapper code</em> in C for the Fortran subroutine to enable
calling it from Python, and in this wrapper code one can return <tt class="docutils literal"><span class="pre">u</span></tt>
to the calling Python code.
It is not strictly necessary to return <tt class="docutils literal"><span class="pre">u</span></tt> to the calling Python
code since the <tt class="docutils literal"><span class="pre">advance</span></tt> function will modify the elements of <tt class="docutils literal"><span class="pre">u</span></tt>,
but the convention in Python is to get all output from a function
as returned values.</p>
</div>
<div class="section" id="building-the-fortran-module-with-f2py">
<h3>Building the Fortran module with f2py<a class="headerlink" href="#building-the-fortran-module-with-f2py" title="Permalink to this headline">¶</a></h3>
<p>The nice feature of writing loops in Fortran is that the tool <tt class="docutils literal"><span class="pre">f2py</span></tt>
can with very little work produce a C extension module such that
we can call the Fortran version of <tt class="docutils literal"><span class="pre">advance</span></tt> from Python.
The necessary commands to run are</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; f2py -m wave2D_u0_loop_f77 -h wave2D_u0_loop_f77.pyf \</span>
<span class="go">          --overwrite-signature wave2D_u0_loop_f77.f</span>
<span class="go">Terminal&gt; f2py -c wave2D_u0_loop_f77.pyf --build-dir build_f77 \</span>
<span class="go">          -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_f77.f</span>
</pre></div>
</div>
<p>First, <tt class="docutils literal"><span class="pre">f2py</span></tt> interprets the Fortran code and makes a Fortran 90
specification of the extension module in the file
<tt class="docutils literal"><span class="pre">wave2D_u0_loop_f77.pyf</span></tt>. Second, <tt class="docutils literal"><span class="pre">f2py</span></tt> generates all necessary
wrapper code, compiles our Fortran file and the wrapper code,
and finally builds the module.
The build process takes place in the specified subdirectory <tt class="docutils literal"><span class="pre">build_f77</span></tt>
so that files can be inspected if something goes wrong.
The option <tt class="docutils literal"><span class="pre">-DF2PY_REPORT_ON_ARRAY_COPY=1</span></tt> makes <tt class="docutils literal"><span class="pre">f2py</span></tt> write a message
for every array that is copied in the communication between Fortran and Python,
which is very useful for avoiding unnecessary array copying (see below).
The name of the module file
is <tt class="docutils literal"><span class="pre">wave2D_u0_loop_f77.so</span></tt>, and this file can imported as any other
Python module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">wave2D_u0_loop_f77</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">wave2D_u0_loop_f77</span><span class="p">)</span>
<span class="go">[&#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,</span>
<span class="go"> &#39;__version__&#39;, &#39;advance&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wave2D_u0_loop_f77</span><span class="o">.</span><span class="n">__doc__</span>
<span class="go">This module &#39;wave2D_u0_loop_f77&#39; is auto-generated with f2py....</span>
<span class="go">Functions:</span>
<span class="go">  u = advance(u,u_1,u_2,f,x,y,t,cx2,cy2,dt2,</span>
<span class="go">      nx=(shape(u,0)-1),ny=(shape(u,1)-1),n=(len(t)-1))</span>
</pre></div>
</div>
</div>
<div class="section" id="examining-doc-strings">
<h3>Examining doc strings<a class="headerlink" href="#examining-doc-strings" title="Permalink to this headline">¶</a></h3>
<p>Printing the doc strings of the module and its functions is
extremely important after having created a module with <tt class="docutils literal"><span class="pre">f2py</span></tt>,
because <tt class="docutils literal"><span class="pre">f2py</span></tt> makes Python interfaces to the Fortran functions
that are different from how the functions are declared in
the Fortran code (!). The rationale for this behavior is that
<tt class="docutils literal"><span class="pre">f2py</span></tt> creates <em>Pythonic</em> interfaces to that Fortran routines
can be called in the same way as one calls Python functions.
Since output data from Python functions are always returned
to the calling code and this is technically impossible in Fortran.
Also, arrays in Python are passed to Python functions without
their dimensions because that information is packed with the array
data in the array objects, but this is not possible in Fortran.
Therefore, <tt class="docutils literal"><span class="pre">f2py</span></tt> removes array dimensions from the argument list
to a function like <tt class="docutils literal"><span class="pre">advance</span></tt> (!), and it makes it possible to
return objects back to Python. Let us take a closer look at
the documentation <tt class="docutils literal"><span class="pre">f2py</span></tt> has generated for our Fortran <tt class="docutils literal"><span class="pre">advance</span></tt>
subroutine:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">wave2D_u0_loop_f77</span><span class="o">.</span><span class="n">advance</span><span class="o">.</span><span class="n">__doc__</span>
<span class="go">This module &#39;wave2D_u0_loop_f77&#39; is auto-generated with f2py</span>
<span class="go">Functions:</span>
<span class="go">  u = advance(u,u_1,u_2,f,cx2,cy2,dt2,</span>
<span class="go">              nx=(shape(u,0)-1),ny=(shape(u,1)-1))</span>
<span class="go">.</span>
<span class="go">advance - Function signature:</span>
<span class="go">  u = advance(u,u_1,u_2,f,cx2,cy2,dt2,[nx,ny])</span>
<span class="go">Required arguments:</span>
<span class="go">  u : input rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)</span>
<span class="go">  u_1 : input rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)</span>
<span class="go">  u_2 : input rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)</span>
<span class="go">  f : input rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)</span>
<span class="go">  cx2 : input float</span>
<span class="go">  cy2 : input float</span>
<span class="go">  dt2 : input float</span>
<span class="go">Optional arguments:</span>
<span class="go">  nx := (shape(u,0)-1) input int</span>
<span class="go">  ny := (shape(u,1)-1) input int</span>
<span class="go">Return objects:</span>
<span class="go">  u : rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)</span>
</pre></div>
</div>
<p>Here we see that the <tt class="docutils literal"><span class="pre">nx</span></tt>, <tt class="docutils literal"><span class="pre">ny</span></tt>, and <tt class="docutils literal"><span class="pre">n</span></tt> parameters declared in
Fortran are optional arguments that can be omitted when calling
<tt class="docutils literal"><span class="pre">advance</span></tt> from Python. We strongly recommend to print out the
documentation of <em>every</em> Fortran function to be called from Python
and make sure the call syntax is exactly as listed in the
documentation.</p>
<span class="target" id="index-44"></span><span class="target" id="index-45"></span><span class="target" id="index-46"></span></div>
<div class="section" id="how-to-avoid-array-copying">
<span id="index-47"></span><h3>How to avoid array copying<a class="headerlink" href="#how-to-avoid-array-copying" title="Permalink to this headline">¶</a></h3>
<p>Multi-dimensional arrays are stored as a stream of numbers in memory.
For a two-dimensional array consisting of rows and columns there are
two ways of creating such a stream: <em>row-major ordering</em>, which means
that rows are stored consecutively in memory, or <em>column-major
ordering</em>, which means that the columns are stored after each other.
All programming languages inherited from C, including Python, apply
the row-major ordering, but Fortran uses column-major storage.
Thinking of a two-dimensional array as a matrix, it means that Fortran
works with the transposed matrix.</p>
<p>Fortunately, <tt class="docutils literal"><span class="pre">f2py</span></tt> creates extra code so that accessing <tt class="docutils literal"><span class="pre">u(i,j)</span></tt> in
the Fortran subroutine corresponds to the element <tt class="docutils literal"><span class="pre">u[i,j]</span></tt> in the
underlying <tt class="docutils literal"><span class="pre">numpy</span></tt> array (without the extra code, <tt class="docutils literal"><span class="pre">u(i,j)</span></tt> in Fortran
would access <tt class="docutils literal"><span class="pre">u[j,i]</span></tt> in the <tt class="docutils literal"><span class="pre">numpy</span></tt> array).  Technically, <tt class="docutils literal"><span class="pre">f2py</span></tt>
takes a copy of our <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays and reorders the data before
sending the arrays to Fortran. Such copying can be costly. For 2D wave
simulations on a <span class="math">\(60\times 60\)</span> grid the overhead of copying is a
factor of 5, which means that almost the whole performance gain of
Fortran over vectorized <tt class="docutils literal"><span class="pre">numpy</span></tt> code is lost!</p>
<p>To avoid having <tt class="docutils literal"><span class="pre">f2py</span></tt> to copy
arrays with C storage to the corresponding Fortran storage, we can declare
the arrays with Fortran storage:</p>
<div class="highlight-text"><div class="highlight"><pre>order = &#39;Fortran&#39; if version == &#39;f77&#39; else &#39;C&#39;
u   = zeros((Nx+1,Ny+1), order=order)   # solution array
u_1 = zeros((Nx+1,Ny+1), order=order)   # solution at t-dt
u_2 = zeros((Nx+1,Ny+1), order=order)   # solution at t-2*dt
</pre></div>
</div>
<p>In the compile and build step of using <tt class="docutils literal"><span class="pre">f2py</span></tt>, it is recommended to add
an extra option for making <tt class="docutils literal"><span class="pre">f2py</span></tt> report on array copying:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; f2py -c wave2D_u0_loop_f77.pyf --build-dir build_f77 \</span>
<span class="go">          -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_f77.f</span>
</pre></div>
</div>
<p>It can sometimes be a challenge to track down which array that causes
a copying. There are two principal reasons for copying array data:
either the array does not have Fortran storage or the element types do
not match those declared in the Fortran code. The latter cause is
usually effectively eliminated by using <tt class="docutils literal"><span class="pre">real*8</span></tt> data in the Fortran
code and <tt class="docutils literal"><span class="pre">float64</span></tt> (the default <tt class="docutils literal"><span class="pre">float</span></tt> type in <tt class="docutils literal"><span class="pre">numpy</span></tt>) in the arrays
on the Python side. The former reason is more common, and to check
whether an array before a Fortran call has the right storage one can
print the result of <tt class="docutils literal"><span class="pre">isfortran(a)</span></tt>, which is <tt class="docutils literal"><span class="pre">True</span></tt> if the array <tt class="docutils literal"><span class="pre">a</span></tt>
has Fortran storage. A typical problem in the <tt class="docutils literal"><span class="pre">wave2D_u0.py</span></tt> code is
to set</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f_a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>before the call to the Fortran <tt class="docutils literal"><span class="pre">advance</span></tt> routine. This computation creates
a new array with C storage. There are two remedies, either direct insertion
of data in an array with Fortran storage,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f_a</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;Fortran&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">f_a</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>or remaking the <tt class="docutils literal"><span class="pre">f(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])</span></tt> array,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f_a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;Fortran&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="efficiency-2">
<h3>Efficiency  (2)<a class="headerlink" href="#efficiency-2" title="Permalink to this headline">¶</a></h3>
<p>The efficiency of this Fortran code is very similar to the Cython code.
There is usually nothing more to gain, from a computational efficiency
point of view, by implementing the complete Python program in Fortran
or C. That will just be a lot more code for all administering work
that is needed in scientific software, especially if we extend our
sample program <tt class="docutils literal"><span class="pre">wave2D_u0.py</span></tt> to handle a real scientific problem.
Then only a small portion will consist of loops with intensive
array calculations. These can be migrated to Cython or Fortran as
explained, while the rest of the programming can be more conveniently
done in Python.</p>
</div>
</div>
<div class="section" id="migrating-loops-to-c-via-cython">
<h2>Migrating loops to C via Cython<a class="headerlink" href="#migrating-loops-to-c-via-cython" title="Permalink to this headline">¶</a></h2>
<p>The computationally intensive loops can alternatively be implemented
in C code. Just as Fortran calls for care regarding the storage of
two-dimensional arrays, working with two-dimensional arrays in C
is a bit tricky. The reason is that
<tt class="docutils literal"><span class="pre">numpy</span></tt> arrays are viewed as one-dimensional arrays when
transferred to C, while C programmers will think of <tt class="docutils literal"><span class="pre">u</span></tt>, <tt class="docutils literal"><span class="pre">u_1</span></tt>, and
<tt class="docutils literal"><span class="pre">u_2</span></tt> as two dimensional arrays and index them like <tt class="docutils literal"><span class="pre">u[i][j]</span></tt>.
The C code must declare <tt class="docutils literal"><span class="pre">u</span></tt> as <tt class="docutils literal"><span class="pre">double*</span> <span class="pre">u</span></tt> and translate an index
pair <tt class="docutils literal"><span class="pre">[i][j]</span></tt> to a corresponding single index when <tt class="docutils literal"><span class="pre">u</span></tt> is
viewed as one-dimensional. This translation requires knowledge of
how the numbers in <tt class="docutils literal"><span class="pre">u</span></tt> are stored in memory.</p>
<div class="section" id="translating-index-pairs-to-single-indices">
<h3>Translating index pairs to single indices<a class="headerlink" href="#translating-index-pairs-to-single-indices" title="Permalink to this headline">¶</a></h3>
<p>Two-dimensional <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays with the default C storage are stored
row by row. In general, multi-dimensional arrays with C storage are
stored such that the last index has the fastest variation, then the
next last index, and so on, ending up with the slowest variation
in the first index. For a two-dimensional <tt class="docutils literal"><span class="pre">u</span></tt> declared as
<tt class="docutils literal"><span class="pre">zeros((Nx+1,Ny+1))</span></tt> in Python, the individual elements are stored
in the following order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">Ny</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">]</span>
</pre></div>
</div>
<p>Viewing <tt class="docutils literal"><span class="pre">u</span></tt> as one-dimensional, the index pair <span class="math">\((i,j)\)</span> translates
to <tt class="docutils literal"><span class="pre">i*(Ny+1)</span> <span class="pre">+</span> <span class="pre">j</span></tt>. Where a C programmer would naturally write
an index <tt class="docutils literal"><span class="pre">u[i][j]</span></tt>, the indexing must read <tt class="docutils literal"><span class="pre">u[i*(Ny+1)</span> <span class="pre">+</span> <span class="pre">j]</span></tt>.
This is tedious to write, so it can be handy to define a C macro,</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define idx(i,j) (i)*(Ny+1) + j</span>
</pre></div>
</div>
<p>so that we can write <tt class="docutils literal"><span class="pre">u[idx(i,j)]</span></tt>, which reads much better and is
easier to debug. Macros perform simple text substitutions:
<tt class="docutils literal"><span class="pre">idx(hello,world)</span></tt> is expanded to <tt class="docutils literal"><span class="pre">(hello)*(Ny+1)</span> <span class="pre">+</span> <span class="pre">world</span></tt>.
The parenthesis in <tt class="docutils literal"><span class="pre">(i)</span></tt> are essential - with natural mathematical
formula <tt class="docutils literal"><span class="pre">i*(Ny+1)</span> <span class="pre">+</span> <span class="pre">j</span></tt> in the macro definition,
<tt class="docutils literal"><span class="pre">idx(i-1,j)</span></tt> would expand to <tt class="docutils literal"><span class="pre">i-1*(Ny+1)</span> <span class="pre">+</span> <span class="pre">j</span></tt>, which is the wrong
formula. Macros are handy, but requires careful use.</p>
</div>
<div class="section" id="the-complete-c-code">
<h3>The complete C code<a class="headerlink" href="#the-complete-c-code" title="Permalink to this headline">¶</a></h3>
<p>The C version of function <tt class="docutils literal"><span class="pre">advance</span></tt> can be coded as follows.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define idx(i,j) (i)*(Ny+1) + j</span>

<span class="kt">void</span> <span class="nf">advance</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">u_1</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">u_2</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">f</span><span class="p">,</span>
             <span class="kt">double</span> <span class="n">Cx2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">Cy2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dt2</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">Nx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Ny</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="cm">/* Scheme at interior points */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">+</span>
        <span class="n">Cx2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)])</span> <span class="o">+</span>
        <span class="n">Cy2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span> <span class="o">+</span>
        <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)];</span>
        <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/* Boundary conditions */</span>
  <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">Nx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">u</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">Nx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">u</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">Ny</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">u</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">Ny</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">u</span><span class="p">[</span><span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-cython-interface-file">
<h3>The Cython interface file<a class="headerlink" href="#the-cython-interface-file" title="Permalink to this headline">¶</a></h3>
<p>All the code above appears in a file <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave//wave2D_u0/wave2D_u0_loop_c.c">wave2D_u0_loop_c.c</a>.
We need to compile this file together with C wrapper code such that
<tt class="docutils literal"><span class="pre">advance</span></tt> can be called from Python. Cython can be used to interface
our C code. The Cython code, placed in a file with extension <tt class="docutils literal"><span class="pre">.pyx</span></tt>, here
<a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0_loop_c_cy.pyx">wave2D_u0_loop_c_cy.pyx</a>, looks like</p>
<div class="highlight-cython"><div class="highlight"><pre><span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">cimport</span> <span class="nn">cython</span>

<span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;wave2D_u0_loop_c.h&quot;</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">advance</span><span class="p">(</span><span class="n">double</span><span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">double</span><span class="o">*</span> <span class="n">f</span><span class="p">,</span>
                 <span class="n">double</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">double</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">double</span> <span class="n">dt2</span><span class="p">,</span>
                 <span class="nb">int</span> <span class="n">Nx</span><span class="p">,</span> <span class="nb">int</span> <span class="n">Ny</span><span class="p">)</span>

<span class="nd">@cython</span><span class="o">.</span><span class="n">boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython</span><span class="o">.</span><span class="n">wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">advance_cwrap</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">double</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">u</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">double</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">u_1</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">double</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">u_2</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">double</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="n">f</span><span class="p">,</span>
    <span class="n">double</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">double</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">double</span> <span class="n">dt2</span><span class="p">):</span>
    <span class="n">advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">u_1</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">u_2</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="mf">0</span><span class="p">],</span>
            <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">,</span>
            <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="o">-</span><span class="mf">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>Here, we first declare the C functions to be interfaced.
These must also appear in a C header file, <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0_loop_c.h">wave2D_u0_loop_c.h</a>,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">void</span> <span class="nf">advance</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">u_1</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">u_2</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">f</span><span class="p">,</span>
                    <span class="kt">double</span> <span class="n">Cx2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">Cy2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">dt2</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">Nx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Ny</span><span class="p">);</span>
</pre></div>
</div>
<p>The next step is to write a Cython function with Python objects as arguments.
The name <tt class="docutils literal"><span class="pre">advance</span></tt> is already used for the C function so the function
to be called from Python is named <tt class="docutils literal"><span class="pre">advance_cwrap</span></tt>. The contents of
this function is simply a call to the <tt class="docutils literal"><span class="pre">advance</span></tt> version in C. To this end,
the right information from the Python objects must be passed on as
arguments to <tt class="docutils literal"><span class="pre">advance</span></tt>. Arrays are sent with their C pointers to the
first element, obtained in Cython as <tt class="docutils literal"><span class="pre">&amp;u[0,0]</span></tt> (the <tt class="docutils literal"><span class="pre">&amp;</span></tt> takes the
address of a C variable). The <tt class="docutils literal"><span class="pre">Nx</span></tt> and <tt class="docutils literal"><span class="pre">Ny</span></tt> arguments in <tt class="docutils literal"><span class="pre">advance</span></tt> are
easily obtained from the shape of the <tt class="docutils literal"><span class="pre">numpy</span></tt> array <tt class="docutils literal"><span class="pre">u</span></tt>.
Finally, <tt class="docutils literal"><span class="pre">u</span></tt> must be returned such that we can set <tt class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">advance(...)</span></tt>
in Python.</p>
</div>
<div class="section" id="building-the-extension-module-2">
<h3>Building the extension module  (2)<a class="headerlink" href="#building-the-extension-module-2" title="Permalink to this headline">¶</a></h3>
<p>It remains to build the extension module. An appropriate
<tt class="docutils literal"><span class="pre">setup.py</span></tt> file is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">distutils.extension</span> <span class="kn">import</span> <span class="n">Extension</span>
<span class="kn">from</span> <span class="nn">Cython.Distutils</span> <span class="kn">import</span> <span class="n">build_ext</span>

<span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;wave2D_u0_loop_c.c&#39;</span><span class="p">,</span> <span class="s">&#39;wave2D_u0_loop_c_cy.pyx&#39;</span><span class="p">]</span>
<span class="n">module</span> <span class="o">=</span> <span class="s">&#39;wave2D_u0_loop_c_cy&#39;</span>
<span class="n">setup</span><span class="p">(</span>
  <span class="n">name</span><span class="o">=</span><span class="n">module</span><span class="p">,</span>
  <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">Extension</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span>
                         <span class="n">libraries</span><span class="o">=</span><span class="p">[],</span> <span class="c"># C libs to link with</span>
                         <span class="p">)],</span>
  <span class="n">cmdclass</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;build_ext&#39;</span><span class="p">:</span> <span class="n">build_ext</span><span class="p">},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>All we need to specify is the <tt class="docutils literal"><span class="pre">.c</span></tt> file(s) and the <tt class="docutils literal"><span class="pre">.pyx</span></tt> interface
file. Cython is automatically run to generate the necessary wrapper
code. Files are then compiled and linked to an extension module
residing in the file <tt class="docutils literal"><span class="pre">wave2D_u0_loop_c_cy.so</span></tt>. This module can
be imported in Python,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">wave2D_u0_loop_c_cy</span> <span class="kn">as</span> <span class="nn">m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,</span>
<span class="go"> &#39;__test__&#39;, &#39;advance_cwrap&#39;, &#39;np&#39;]</span>
</pre></div>
</div>
<p>The call to the C version of <tt class="docutils literal"><span class="pre">advance</span></tt> can go like this in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">advance</span> <span class="o">=</span> <span class="n">wave2D_u0_loop_c_cy</span><span class="o">.</span><span class="n">advance_cwrap</span>
<span class="n">f_a</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">advance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">f_a</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="efficiency-3">
<h3>Efficiency  (3)<a class="headerlink" href="#efficiency-3" title="Permalink to this headline">¶</a></h3>
<p>In this example, the C and Fortran code runs at the same speed, and there
are no significant differences in the efficiency of the wrapper code.
The overhead implied by the wrapper code is negligible as long as
we do not work with very small meshes and consequently little numerical
work in the <tt class="docutils literal"><span class="pre">advance</span></tt> function.</p>
</div>
</div>
<div class="section" id="migrating-loops-to-c-via-f2py">
<h2>Migrating loops to C via f2py<a class="headerlink" href="#migrating-loops-to-c-via-f2py" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to using Cython for interfacing C code, we can apply
<tt class="docutils literal"><span class="pre">f2py</span></tt>. The C code is the same, just the details of specifying how
it is to be called from Python differ. The <tt class="docutils literal"><span class="pre">f2py</span></tt> tool requires
the call specification to be a Fortran 90 module defined in a <tt class="docutils literal"><span class="pre">.pyf</span></tt>
file. This file was automatically generated when we interfaced a
Fortran subroutine. With a C function we need to write this module
ourselves, or we can use a trick and let <tt class="docutils literal"><span class="pre">f2py</span></tt> generate it for us.
The trick consists in writing the signature of the C function with
Fortran syntax and place it in a Fortran file, here
<tt class="docutils literal"><span class="pre">wave2D_u0_loop_c_f2py_signature.f</span></tt>:</p>
<div class="highlight-fortran"><div class="highlight"><pre>      <span class="k">subroutine </span><span class="nv">advance</span><span class="p">(</span><span class="nv">u</span><span class="p">,</span> <span class="nv">u_1</span><span class="p">,</span> <span class="nv">u_2</span><span class="p">,</span> <span class="nv">f</span><span class="p">,</span> <span class="nv">Cx2</span><span class="p">,</span> <span class="nv">Cy2</span><span class="p">,</span> <span class="nv">dt2</span><span class="p">,</span> <span class="nv">Nx</span><span class="p">,</span> <span class="nv">Ny</span><span class="p">)</span>
<span class="nv">Cf2py</span> <span class="k">intent</span><span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="nv">advance</span>
      <span class="kt">integer </span><span class="nv">Nx</span><span class="p">,</span> <span class="nv">Ny</span><span class="p">,</span> <span class="nv">N</span>
      <span class="kt">real</span><span class="o">*</span><span class="mi">8</span> <span class="nv">u</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="nv">Nx</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="nv">Ny</span><span class="p">),</span> <span class="nv">u_1</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="nv">Nx</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="nv">Ny</span><span class="p">),</span> <span class="nv">u_2</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="nv">Nx</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="nv">Ny</span><span class="p">)</span>
      <span class="kt">real</span><span class="o">*</span><span class="mi">8</span> <span class="nv">f</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="nv">Nx</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="nv">Ny</span><span class="p">),</span> <span class="nv">Cx2</span><span class="p">,</span> <span class="nv">Cy2</span><span class="p">,</span> <span class="nv">dt2</span>
<span class="nv">Cf2py</span> <span class="k">intent</span><span class="p">(</span><span class="nv">in</span><span class="p">,</span> <span class="nv">out</span><span class="p">)</span> <span class="nv">u</span>
<span class="nv">Cf2py</span> <span class="k">intent</span><span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="nv">u</span><span class="p">,</span> <span class="nv">u_1</span><span class="p">,</span> <span class="nv">u_2</span><span class="p">,</span> <span class="nv">f</span><span class="p">,</span> <span class="nv">Cx2</span><span class="p">,</span> <span class="nv">Cy2</span><span class="p">,</span> <span class="nv">dt2</span><span class="p">,</span> <span class="nv">Nx</span><span class="p">,</span> <span class="nv">Ny</span>
      <span class="k">return</span>
<span class="k">      end</span>
</pre></div>
</div>
<p>Since <tt class="docutils literal"><span class="pre">f2py</span></tt> is just concerned with the signature and not the
complete contents of the function body, it can generate the
Fortran 90 module specification:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; f2py -m wave2D_u0_loop_c_f2py \</span>
<span class="go">          -h wave2D_u0_loop_c_f2py.pyf --overwrite-signature \</span>
<span class="go">          wave2D_u0_loop_c_f2py_signature.f</span>
</pre></div>
</div>
<p>The compile and build step is as for the Fortran code, except that we
list C file(s) instead of Fortran file(s):</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; f2py -c wave2D_u0_loop_c_f2py.pyf \</span>
<span class="go">          --build-dir tmp_build_c \</span>
<span class="go">          -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_c.c</span>
</pre></div>
</div>
<p>As when interfacing Fortran code with <tt class="docutils literal"><span class="pre">f2py</span></tt>, we need to print out
the doc string to see the exact call syntax from the Python side.
This doc string is identical for the C and Fortran versions of
<tt class="docutils literal"><span class="pre">advance</span></tt>.</p>
</div>
<div class="section" id="migrating-loops-to-c-via-instant">
<h2>Migrating loops to C via Instant<a class="headerlink" href="#migrating-loops-to-c-via-instant" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id10">
<h2>Migrating loops to C++ via f2py<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>C++ is a much more versatile language than C or Fortran and has over
the last two decades become very popular for numerical computing.
Many will therefore prefer to migrate compute-intensive Python code
to C++. This is, in principle, easy: just write the desired C++ code
and use some tool for interfacing it from Python. A tool like
<a class="reference external" href="http://swig.org/">SWIG</a> can interpret the C++ code and generate
interfaces for Python, Perl, Ruby, Java, and a wide range of
languages. However, SWIG is a comprehensive tool with a correspondingly
non-trivial learning curve. Alternative tools, such as
<a class="reference external" href="http://www.boost.org/doc/libs/1_51_0/libs/python/doc/index.html">Boost Python</a> and <a class="reference external" href="http://riverbankcomputing.co.uk/software/sip/intro">SIP</a>,
are similarly comprehensive.</p>
<p>A technically much easier way of interfacing C++ code is to drop the
possibility to use C++ classes directly from Python, but instead
make a C interface to the C++ code. The C interface can be handled
by <tt class="docutils literal"><span class="pre">f2py</span></tt> as shown in the example with pure C code. Such a solution
means that classes in Python and C++ cannot be mixed and that only
primitive data types like numbers, strings, and arrays can be
transferred between Python and C++. Actually, this is often a very
good solution because it forces the C++ code to work on array data,
which usually gives faster code than if fancy data structures with
classes are used. The arrays coming from Python, and looking like
plain C/C++ arrays, can be efficiently wrapped in more user-friendly
C++ array classes in the C++ code, if desired.</p>
<p><em>Remaining.</em> Use some array class. Key issue: <tt class="docutils literal"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></tt> declaration of C++
function in the C file with the interface we want to wrap.</p>
</div>
<div class="section" id="using-classes-to-implement-a-simulator">
<h2>Using classes to implement a simulator<a class="headerlink" href="#using-classes-to-implement-a-simulator" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>class <tt class="docutils literal"><span class="pre">Mesh</span></tt>, <tt class="docutils literal"><span class="pre">Function</span></tt>, <tt class="docutils literal"><span class="pre">Problem</span></tt>, <tt class="docutils literal"><span class="pre">Solver</span></tt>, <tt class="docutils literal"><span class="pre">Visualizer</span></tt>, <tt class="docutils literal"><span class="pre">File</span></tt></li>
<li>communicate with compiled code by ensuring that
classes work with arrays</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="callbacks-to-python-from-fortran-or-c">
<h2>Callbacks to Python from Fortran or C<a class="headerlink" href="#callbacks-to-python-from-fortran-or-c" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="exercises">
<h1>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h1>
<div class="section" id="project-10-calculus-with-2d-3d-mesh-functions">
<span id="wave-exer-mesh3d-calculus"></span><h2>Project 10: Calculus with 2D/3D mesh functions<a class="headerlink" href="#project-10-calculus-with-2d-3d-mesh-functions" title="Permalink to this headline">¶</a></h2>
<p>The goal of this project is to redo
<a class="reference internal" href="#wave-exer-mesh1d-calculus"><em>Project 5: Calculus with 1D mesh functions</em></a> with 2D and 3D
mesh functions (<span class="math">\(f_{i,j}\)</span> and <span class="math">\(_{fi,j,k}\)</span>).</p>
<p><em>Differentiation.</em> The differentiation results in a discrete gradient
function, which in the 2D case can be represented by a three-dimensional
array <tt class="docutils literal"><span class="pre">df[d,i,j]</span></tt> where <tt class="docutils literal"><span class="pre">d</span></tt> represents the direction of
the derivative and <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> are mesh point counters in 2D
(the 3D counterpart is <tt class="docutils literal"><span class="pre">df[d,i,j,k]</span></tt>).</p>
<p><em>Integration.</em> The integral of a 2D mesh function <span class="math">\(f_{i,j}\)</span> is defined as</p>
<div class="math">
\[F_{i,j} = \int_{y_0}^{y_j} \int_{x_0}^{x_i} f(x,y)dxdy,\]</div>
<p>where <span class="math">\(f(x,y)\)</span> is a function that takes on the values of the
discrete mesh function <span class="math">\(f_{i,j}\)</span> at the mesh points, but can also
be evaluated in between the mesh points. The particular variation
between mesh points can be taken as bilinear, but this is not
important as we will use a product Trapezoidal rule to approximate
the integral over a cell in the mesh and then we only need to
evaluate <span class="math">\(f(x,y)\)</span> at the mesh points.</p>
<p>Suppose <span class="math">\(F_{i,j}\)</span> is computed. The calculation of <span class="math">\(F_{i+1,j}\)</span>
is then</p>
<div class="math">
\[\begin{split}F_{i+1,j} &amp;= F_{i,j} + \int_{x_i}^{x_{i+1}}\int_{y_0}^{y_j} f(x,y)dydx\\
&amp;\approx \Delta x \int_{y_0}^{y_j} f(x_{i+\frac{1}{2}},y)dy\\
&amp; \approx \Delta x \frac{1}{2}\left(
\int_{y_0}^{y_j} f(x_{i},y)dy
+ \int_{y_0}^{y_j} f(x_{i+1},y)dy\right)\end{split}\]</div>
<p>The integrals in the <span class="math">\(y\)</span> direction can be approximated by a Trapezoidal
rule. A similar idea can be used to compute <span class="math">\(F_{i,j+1}\)</span>. Thereafter,
<span class="math">\(F_{i+1,j+1}\)</span> can be computed by adding the integral over the final
corner cell to <span class="math">\(F_{i+1,j} + F_{i,j+1} - F_{i,j}\)</span>. Carry out the
details of these computations and extend the ideas to 3D.
Filename: <tt class="docutils literal"><span class="pre">mesh_calculus_3D.py</span></tt>.</p>
</div>
</div>
<div class="section" id="applications-of-wave-equations">
<span id="wave-app"></span><h1>Applications of wave equations<a class="headerlink" href="#applications-of-wave-equations" title="Permalink to this headline">¶</a></h1>
<p>This section presents a range of wave equation models
for different physical phenomena. Although many wave motion problems
in physics can be modeled by the standard linear wave equation, or a similar
formulation with a system of first-order equations, there are some
exceptions. Perhaps the most important is water waves: these are modeled by
the Laplace equation with time-dependent boundary conditions at
the water surface (long water waves, however, can be approximated
by a standard wave equation, see the section <a class="reference internal" href="#wave-app-sw-2d"><em>The linear shallow water equations</em></a>).
Quantum mechanical waves constitute another example where the waves
are governed by the
Schrodinger
equation and not a standard wave equation.
Many wave phenomena also need to take nonlinear effects into account
when the wave amplitude is significant. Shock waves in the air is
a primary example.</p>
<p>The derivations in the following are very brief. Those with a firm
background in continuum mechanics will probably have enough
information to fill in the details, while other readers will hopefully
get some impression of the physics and approximations involved when
establishing wave equation models.</p>
<div class="section" id="waves-on-a-string">
<span id="wave-app-string"></span><h2>Waves on a string<a class="headerlink" href="#waves-on-a-string" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="wave-app-string-fig">
<img alt="_images/wave_on_string1.png" src="_images/wave_on_string1.png" style="width: 800px;" />
<p class="caption"><em>Discrete string model with point masses connected by elastic strings</em></p>
</div>
<p>Figure <a class="reference internal" href="#wave-app-string-fig"><em>Discrete string model with point masses connected by elastic strings</em></a> shows a model we may use to derive
the equation for waves on a string. The string is modeled as a
set of discrete point masses (at mesh points) with
elastic strings in between. The strings are at a high constant tension <span class="math">\(T\)</span>.
We let the mass at mesh point <span class="math">\(x_i\)</span> be <span class="math">\(m_i\)</span>. The displacement of
this mass point in <span class="math">\(y\)</span> direction is denoted by <span class="math">\(u_i(t)\)</span>.</p>
<p>The motion of mass <span class="math">\(m_i\)</span> is governed by Newton&#8217;s second law of motion.
The position of the mass at time <span class="math">\(t\)</span> is <span class="math">\(x_i\boldsymbol{i} + u_i(t)\boldsymbol{j}\)</span>, where
<span class="math">\(\boldsymbol{i}\)</span> and <span class="math">\(\boldsymbol{j}\)</span> are unit vectors in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> direction, respectively.
The acceleration is then <span class="math">\(u_i''(t)\boldsymbol{j}\)</span>. Two forces are acting
on the mass as indicated in Figure <a class="reference internal" href="#wave-app-string-fig"><em>Discrete string model with point masses connected by elastic strings</em></a>.
The force <span class="math">\(\boldsymbol{T}^{-}\)</span> acting toward the point <span class="math">\(x_{i-1}\)</span> can be decomposed
as</p>
<div class="math">
\[\boldsymbol{T}^{-} = -T\sin\phi\boldsymbol{i} -T\cos\phi\boldsymbol{j},\]</div>
<p>where <span class="math">\(\phi\)</span> is the angle between the force and the
line <span class="math">\(x=x_i\)</span>. Let <span class="math">\(\Delta u_i = u_i - u_{i-1}\)</span> and let
<span class="math">\(\Delta s_i = \sqrt{\Delta u_i^2 + (x_i - x_{i-1})^2}\)</span>
be the distance from mass <span class="math">\(m_{i-1}\)</span> to mass <span class="math">\(m_i\)</span>.
It is seen that <span class="math">\(\cos\phi = \Delta u_i/\Delta s_i\)</span> and <span class="math">\(\sin\phi =
(x_{i}-x_{i-1})/\Delta s\)</span> or <span class="math">\(\Delta x/\Delta s_i\)</span> if we
introduce a constant mesh spacing <span class="math">\(\Delta x = x_i - x_{i-1}\)</span>.
The force can then be written</p>
<div class="math">
\[\boldsymbol{T}^{-} = -T\frac{\Delta x}{\Delta s_i}\boldsymbol{i} - T\frac{\Delta u_i}{\Delta s_i}\boldsymbol{j}
\thinspace .\]</div>
<p>The force <span class="math">\(\boldsymbol{T}^{+}\)</span> acting toward <span class="math">\(x_{i+1}\)</span> can be calculated in a similar way:</p>
<div class="math">
\[\boldsymbol{T}^{+} = T\frac{\Delta x}{\Delta s_{i+1}}\boldsymbol{i} +
            T\frac{\Delta u_{i+1}}{\Delta s_{i+1}}\boldsymbol{j}
\thinspace .\]</div>
<p>Newton&#8217;s second law becomes</p>
<div class="math">
\[m_iu_i''(t)\boldsymbol{j} = \boldsymbol{T}^{+} + \boldsymbol{T}^{-},\]</div>
<p>which gives the component equations</p>
<div class="math" id="equation-wave:app:string:hcomp">
<span class="eqno">(64)</span>\[     T\frac{\Delta x}{\Delta s_i} = T\frac{\Delta x}{\Delta s_{i+1}},\]</div>
<div class="math" id="equation-wave:app:string:vcomp">
<span class="eqno">(65)</span>\[     m_iu_i''(t) = T\frac{\Delta u_{i+1}}{\Delta s_{i+1}} -
                    T\frac{\Delta u_i}{\Delta s_i}\]\[     \thinspace .\]</div>
<p>A basic assumption now is small displacements <span class="math">\(u_i\)</span> and small
displacement gradients <span class="math">\(\Delta u_i/\Delta x\)</span>. For small <span class="math">\(g=\Delta u_i/\Delta x\)</span>
we have that</p>
<div class="math">
\[\Delta s_i = \sqrt{\Delta u_i^2 + \Delta x^2} = \Delta x\sqrt{1 + g^2}
+ \Delta x (1 + \frac{1}{2}g^2 + {\cal O}(g^4) \approx \Delta x
\thinspace .\]</div>
<p>Equation <a href="#equation-wave:app:string:hcomp">(64)</a> is then simply the identity <span class="math">\(T=T\)</span>, while
<a href="#equation-wave:app:string:vcomp">(65)</a> can be written as</p>
<div class="math">
\[m_iu_i''(t) = T\frac{\Delta u_{i+1}}{\Delta x} - T\frac{\Delta u_i}{\Delta x},\]</div>
<p>which upon division by <span class="math">\(\Delta x\)</span> and introducing the density
<span class="math">\(\varrho_i = m_i/\Delta x\)</span> becomes</p>
<div class="math" id="equation-wave:app:string:model0">
<span class="eqno">(66)</span>\[     \varrho_i u_i''(t) = T\frac{1}{\Delta x^2}
     \left( u_{i+1} - 2u_i + u_{i-1}\right)\]\[     \thinspace .\]</div>
<p>We can now choose to approximate <span class="math">\(u_i''\)</span> by a finite difference in time
and get the discretized wave equation,</p>
<div class="math">
\[\varrho_i \frac{1}{\Delta t^2}
\left(u^{n+1}_i - 2u^n_i - u^{n-1}_i\right) =
T\frac{1}{\Delta x^2}
\left( u_{i+1} - 2u_i + u_{i-1}\right),\]</div>
<p>or we may go to the continuum limit <span class="math">\(\Delta x\rightarrow 0\)</span> and
replace <span class="math">\(u_i(t)\)</span> by <span class="math">\(u(x,t)\)</span>, <span class="math">\(\varrho_i\)</span> by <span class="math">\(\varrho(x)\)</span>, and
recognize that the right-hand side of <a href="#equation-wave:app:string:model0">(66)</a>
approaches <span class="math">\(\partial^2 u/\partial x^2\)</span> as <span class="math">\(\Delta x\rightarrow 0\)</span>.
We end up with the continuous model for waves on a string:</p>
<div class="math" id="equation-wave:app:string:model1">
<span class="eqno">(67)</span>\[     \varrho\frac{\partial^2 u}{\partial t^2} = T\frac{\partial^2 u}{\partial x^2}\]\[     \thinspace .\]</div>
<p>Note that the density <span class="math">\(\varrho\)</span> may change along the string, while the
tension <span class="math">\(T\)</span> is a constant. With variable wave velocity <span class="math">\(c(x) = \sqrt{T/\varrho(x)}\)</span> we can write the wave equation in the more standard form</p>
<div class="math" id="equation-wave:app:string:model2">
<span class="eqno">(68)</span>\[     \frac{\partial^2 u}{\partial t^2} = c^2(x)\frac{\partial^2 u}{\partial x^2}\]\[     \thinspace .\]</div>
<p>Because of the way <span class="math">\(\varrho\)</span> enters the equations, the variable wave
velocity does <em>not</em> appear inside the derivatives as in many other
versions of the wave equation. However, most strings of interest have
constant <span class="math">\(\varrho\)</span>.</p>
<p>Normally, the end point of a string are fixed so that the displacement
<span class="math">\(u\)</span> is zero. The boundary conditions are therefore <span class="math">\(u=0\)</span>.</p>
<div class="section" id="damping">
<h3>Damping<a class="headerlink" href="#damping" title="Permalink to this headline">¶</a></h3>
<p>Air resistance and non-elastic effects in the string will contribute
to reduce the amplitudes of the waves so that the motion dies out
after some time. This damping effect can be modeled by a term
<span class="math">\(bu_t\)</span> on the left-hand side of the equation</p>
<div class="math" id="equation-wave:app:string:model1:damping">
<span class="eqno">(69)</span>\[     \varrho\frac{\partial^2 u}{\partial t^2}
     + b\frac{\partial u}{\partial t}  =  T\frac{\partial^2 u}{\partial x^2}\]\[     \thinspace .\]</div>
<p>The parameter <span class="math">\(b\)</span> must normally be determined from physical experiments.</p>
</div>
<div class="section" id="external-forcing">
<h3>External forcing<a class="headerlink" href="#external-forcing" title="Permalink to this headline">¶</a></h3>
<p>It is easy to include an external force acting on the string.
Say we have a vertical force <span class="math">\(\tilde f_i\boldsymbol{j}\)</span> acting on mass <span class="math">\(m_i\)</span>.
This force affects the vertical component of Newton&#8217;s law
and gives rise to an extra term <span class="math">\(\tilde f(x,t)\)</span> on the right-hand side of
<a href="#equation-wave:app:string:model1">(67)</a>. In the model
<a href="#equation-wave:app:string:model2">(68)</a> we would add a term
<span class="math">\(f(x,t) = \tilde f(x,y)/\varrho(x)\)</span>.</p>
</div>
<div class="section" id="modeling-the-tension-via-springs">
<h3>Modeling the tension via springs<a class="headerlink" href="#modeling-the-tension-via-springs" title="Permalink to this headline">¶</a></h3>
<p>We assumed, in the derivation above, that the tension in the string, <span class="math">\(T\)</span>,
was constant. It is easy to check this assumption by modeling the
string segments between the masses as standard springs, where the
force (tension <span class="math">\(T\)</span>) is proportional to the elongation of the spring segment.
Let <span class="math">\(k\)</span> be the spring constant, and set <span class="math">\(T_i=k\Delta \ell\)</span> for the
tension in the spring segment between <span class="math">\(x_{i-1}\)</span> and <span class="math">\(x_i\)</span>, where
<span class="math">\(\Delta\ell\)</span> is the elongation of this segment from the tension-free state.
A basic feature of a string is that it has high tension in the
equilibrium position <span class="math">\(u=0\)</span>. Let the string segment have an elongation
<span class="math">\(\Delta\ell_0\)</span> in the equilibrium position. After deformation of the
string, the elongation is <span class="math">\(\Delta \ell = \Delta \ell_0 + \Delta s_i\)</span>:
<span class="math">\(T_i = k(\Delta \ell_0 + \Delta s_i)\approx k(\Delta \ell_0 + \Delta x)\)</span>.
This shows that <span class="math">\(T_i\)</span> is independent of <span class="math">\(i\)</span>. Moreover, the extra
approximate elongation <span class="math">\(\Delta x\)</span> is very small compared to <span class="math">\(\Delta\ell_0\)</span>,
so we may well set <span class="math">\(T_i = T = k\Delta\ell_0\)</span>. This means that
the tension is completely dominated by the initial tension determined
by the tuning of the string. The additional deformations of the
spring during the vibrations do not introduce significant changes in the
tension.</p>
</div>
</div>
<div class="section" id="waves-on-a-membrane">
<span id="wave-app-membrane"></span><h2>Waves on a membrane<a class="headerlink" href="#waves-on-a-membrane" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="elastic-waves-in-a-rod">
<span id="wave-app-elastic-rod"></span><h2>Elastic waves in a rod<a class="headerlink" href="#elastic-waves-in-a-rod" title="Permalink to this headline">¶</a></h2>
<p>Consider an elastic rod subject to a hammer impact at the end.
This experiment will give rise to an elastic deformation pulse that travels
through the rod. A mathematical model for longitudinal waves along
an elastic rod starts with the general equation for deformations
and stresses in an elastic medium,</p>
<div class="math" id="equation-wave:app:elastic:rod:eqmotion">
<span class="eqno">(70)</span>\[     \varrho\boldsymbol{u}_{tt} = \nabla\cdot\boldsymbol{\sigma} + \varrho\boldsymbol{f},\]</div>
<p>where <span class="math">\(\varrho\)</span> is the density, <span class="math">\(\boldsymbol{u}\)</span> the displacement field, <span class="math">\(\boldsymbol{\sigma}\)</span> the
stress tensor, and <span class="math">\(\boldsymbol{f}\)</span> body forces. The latter has normally no impact
on elastic waves.</p>
<p>For stationary deformation of an elastic rod, one has that
<span class="math">\(\sigma_{xx} = Eu_x\)</span> and all other
stress components are zero. Moreover, <span class="math">\(\boldsymbol{u} = u(x)\boldsymbol{i}\)</span>.
The parameter <span class="math">\(E\)</span> is known as Young&#8217;s modulus.
Assuming that this simple stress and deformation field, which is exact
in the stationary case, is a good approximation in the transient
case with wave motion, <a href="#equation-wave:app:elastic:rod:eqmotion">(70)</a> simplifies
to</p>
<div class="math" id="equation-wave:app:elastic:rod:eq">
<span class="eqno">(71)</span>\[     \varrho\frac{\partial^2 u}{\partial t^2} = \frac{\partial}{\partial x}
     \left( E\frac{\partial u}{\partial x}\right)\]\[     \thinspace .\]</div>
<p>The associated boundary conditions are <span class="math">\(u\)</span> or <span class="math">\(\sigma_{xx}\)</span> known, typically
<span class="math">\(u=0\)</span> for a clamped end and <span class="math">\(\sigma_{xx}=0\)</span> for a free end.</p>
</div>
<div class="section" id="the-acoustic-model-for-seismic-waves">
<span id="wave-app-acoustic-seismic"></span><h2>The acoustic model for seismic waves<a class="headerlink" href="#the-acoustic-model-for-seismic-waves" title="Permalink to this headline">¶</a></h2>
<p>Seismic waves are used to infer properties of subsurface
geological structures. The physical model is a heterogeneous
elastic medium where sound is propagated by small elastic
vibrations. The general mathematical model for deformations
in an elastic medium is based on Newton&#8217;s second law,</p>
<div class="math" id="equation-wave:app:acoustic:seismic:eqmotion">
<span class="eqno">(72)</span>\[     \varrho\boldsymbol{u}_{tt} = \nabla\cdot\boldsymbol{\sigma} + \varrho\boldsymbol{f},\]</div>
<p>and a constitutive law relating <span class="math">\(\boldsymbol{\sigma}\)</span> to <span class="math">\(\boldsymbol{u}\)</span>, often Hooke&#8217;s
generalized law,</p>
<div class="math" id="equation-wave:app:acoustic:seismic:Hooke">
<span class="eqno">(73)</span>\[     \boldsymbol{\sigma} = K\nabla\cdot\boldsymbol{u}\, \boldsymbol{I}  + G(\nabla\boldsymbol{u} + (\nabla\boldsymbol{u})^T - \frac{2}{3}\nabla\cdot\boldsymbol{u}\, \boldsymbol{I})\]\[     \thinspace .\]</div>
<p>Here, <span class="math">\(\boldsymbol{u}\)</span> is the displacement field, <span class="math">\(\boldsymbol{\sigma}\)</span> is the stress tensor,
<span class="math">\(\boldsymbol{I}\)</span> is the identity tensor,
<span class="math">\(\varrho\)</span> is the medium&#8217;s density, <span class="math">\(\boldsymbol{f}\)</span> are body forces (such as gravity),
<span class="math">\(K\)</span> is the medium&#8217;s bulk modulus and <span class="math">\(G\)</span> is the associated shear modulus.
All these quantities may vary in space, while <span class="math">\(\boldsymbol{u}\)</span> and <span class="math">\(\boldsymbol{\sigma}\)</span> will
also show significant variation in time during wave motion.</p>
<p>The acoustic approximation to elastic waves arises from a basic
assumption that the second term in Hooke&#8217;s law, representing the
deformations that give rise to shear stresses, can be neglected.
This assumption can be interpreted as approximating the geological
medium by a fluid.
Neglecting also the body forces <span class="math">\(\boldsymbol{f}\)</span>,
<a href="#equation-wave:app:acoustic:seismic:eqmotion">(72)</a> becomes</p>
<div class="math" id="equation-wave:app:acoustic:seismic:eqmotion2">
<span class="eqno">(74)</span>\[     \varrho\boldsymbol{u}_{tt} = \nabla (K\nabla\cdot\boldsymbol{u} )\]</div>
<p>Introducing <span class="math">\(p\)</span> as a pressure via</p>
<div class="math">
\[p=-K\cdot\nabla\boldsymbol{u},\]</div>
<p>and dividing <a href="#equation-wave:app:acoustic:seismic:eqmotion2">(74)</a> by <span class="math">\(\varrho\)</span>,
we get</p>
<div class="math">
\[\boldsymbol{u}_{tt} = -\frac{1}{\varrho}\nabla p
\thinspace .\]</div>
<p>Taking the divergence of this equation, using <span class="math">\(\nabla\cdot\boldsymbol{u} = -p/K\)</span>,
gives the <em>acoustic approximation to elastic waves</em>:</p>
<div class="math" id="equation-wave:app:acoustic:seismic:accoustic1">
<span class="eqno">(75)</span>\[     p_{tt} = K\nabla\cdot\left(\frac{1}{\varrho}\nabla p\right)
     \thinspace .\]</div>
<p>This is a standard, linear wave equation with variable coefficients.
It is common to add a source term <span class="math">\(s(x,y,z,t)\)</span>
to model the generation of sound waves:</p>
<div class="math" id="equation-wave:app:acoustic:seismic:accoustic">
<span class="eqno">(76)</span>\[     p_{tt} = K\nabla\cdot\left(\frac{1}{\varrho}\nabla p\right) + s
     \thinspace .\]</div>
<p>A common further approximation of <a href="#equation-wave:app:acoustic:seismic:accoustic">(76)</a>
is based on using the chain rule on the right-hand side,</p>
<div class="math">
\[K\nabla\cdot\left(\frac{1}{\varrho}\nabla p\right)
= \frac{K}{\varrho}\nabla^2 p + K\nabla\left(\frac{1}{\varrho}\right)\cdot
\nabla p \approx \frac{K}{\varrho}\nabla^2 p,\]</div>
<p>in that one assumes the relative spatial gradient <span class="math">\(\nabla\varrho^{-1}
= -\varrho^{-2}\nabla\varrho\)</span> to be small. This results
in</p>
<div class="math" id="equation-wave:app:acoustic:seismic:accoustic1">
<span class="eqno">(77)</span>\[     p_{tt} = \frac{K}{\varrho}\nabla^2 p + s
     \thinspace .\]</div>
<p>The acoustic approximations to seismic waves are used for sound
waves in the ground, and the Earth&#8217;s surface is then a boundary
where <span class="math">\(p\)</span> equals the atmospheric pressure <span class="math">\(p_0\)</span> such that the
boundary condition becomes <span class="math">\(p=p_0\)</span>.</p>
<div class="section" id="anisotropy">
<h3>Anisotropy<a class="headerlink" href="#anisotropy" title="Permalink to this headline">¶</a></h3>
<p>Quite often in geological materials,
the effective wave velocity <span class="math">\(c=\sqrt{K/\varrho}\)</span> is different
in different spatial directions because geological layers are
compacted such that the properties in the horizontal and vertical
direction differ. With <span class="math">\(z\)</span> as the vertical coordinate, we can
introduce a vertical wave velocity <span class="math">\(c_z\)</span> and a horizontal
wave velocity <span class="math">\(c_h\)</span>, and
generalize <a href="#equation-wave:app:acoustic:seismic:accoustic1">(77)</a> to</p>
<div class="math" id="equation-wave:app:acoustic:seismic:accoustic1a">
<span class="eqno">(78)</span>\[     p_{tt} = c_z^2 p_{zz} + c_h^2 (p_{xx} + p_{yy}) + s
     \thinspace .\]</div>
</div>
</div>
<div class="section" id="sound-waves-in-liquids-and-gases">
<span id="wave-app-sound"></span><h2>Sound waves in liquids and gases<a class="headerlink" href="#sound-waves-in-liquids-and-gases" title="Permalink to this headline">¶</a></h2>
<p>Sound waves arise from pressure and density variations in fluids.
The starting point of modeling sound waves is the basic
equations for a compressible fluid where we omit viscous (frictional)
forces, body forces (gravity, for instance), and temperature effects:</p>
<div class="math" id="equation-wave:app:sound:cont">
<span class="eqno">(79)</span>\[     \varrho_t + \nabla\cdot (\varrho \boldsymbol{u}) = 0,\]</div>
<div class="math" id="equation-wave:app:sound:Euler">
<span class="eqno">(80)</span>\[     \varrho \boldsymbol{u}_{t} + \varrho \boldsymbol{u}\cdot\nabla\boldsymbol{u} = -\nabla p,\]</div>
<div class="math" id="equation-wave:app:sound:prho">
<span class="eqno">(81)</span>\[     \varrho = \varrho (p)
     \thinspace .\]</div>
<p>These equations are often referred to as the Euler equations for the motion
of a fluid. The parameters involved are the density <span class="math">\(\varrho\)</span>,
the velocity <span class="math">\(\boldsymbol{u}\)</span>,
and the pressure <span class="math">\(p\)</span>. Equation <a href="#equation-wave:app:sound:Euler">(80)</a> reflects
mass balance, <a href="#equation-wave:app:sound:cont">(79)</a> is Newton&#8217;s second law for
a fluid, with frictional and body forces omitted, and
<a href="#equation-wave:app:sound:prho">(81)</a> is a constitutive law relating
density to pressure by thermodynamics considerations.
A typical model
for <a href="#equation-wave:app:sound:prho">(81)</a> is the so-called <a class="reference external" href="http://en.wikipedia.org/wiki/Isentropic_process">isentropic relation</a>, valid for
adiabatic processes where there is not heat transfer:</p>
<div class="math" id="equation-wave:app:sound:prho:formula">
<span class="eqno">(82)</span>\[     \varrho = \varrho_0\left(\frac{p}{p_0}\right)^{1/\gamma}
     \thinspace .\]</div>
<p>Here, <span class="math">\(p_0\)</span> and <span class="math">\(\varrho_0\)</span> are references values for <span class="math">\(p\)</span> and :math:`
varrho`, for instances when the fluid is at rest, and
<span class="math">\(\gamma\)</span> is the ratio of specific heat at constant pressure and
constant volume (<span class="math">\(\gamma = 5/3\)</span> for air).</p>
<p>The key approximation in a mathematical model for sound waves is to
assume that those waves are small perturbations to the density, pressure,
and velocity. We therefore write</p>
<div class="math">
\[\begin{split}p &amp;= p_0 + \hat p,\\
\varrho &amp;= \varrho_0 + \hat\varrho,\\
\boldsymbol{u} &amp;= \hat\boldsymbol{u},\end{split}\]</div>
<p>where we have decomposed the fields in a constant
equilibrium value, corresponding
to <span class="math">\(\boldsymbol{u}=0\)</span>, and a small perturbation marked with a hat symbol.
By inserting these decompositions in <a href="#equation-wave:app:sound:cont">(79)</a> and
(<em class="xref std std-ref">wave:app:sound:Euler</em>, neglecting all product terms of small
perturbations and/or their derivatives, and dropping the hat symbols,
one gets the following linearized PDE system for the small perturbations in
density, pressure, and velocity:</p>
<div class="math">
\[\varrho_t + \varrho_0\nabla\cdot\boldsymbol{u} = 0,\]</div>
<div class="math">
\[\varrho_0\boldsymbol{u}_t = -\nabla p
\thinspace .\]</div>
<p>Now we can eliminate <span class="math">\(\varrho_t\)</span> with the aid of <span class="math">\(\varrho(p)\)</span>,</p>
<div class="math">
\[\varrho_t = \varrho_0 \frac{1}{\gamma}\left(\frac{p}{p_0}\right)^{1/\gamma-1}
\frac{1}{p_0}p_t = \frac{\varrho_0}{\gamma p_0}
\left(\frac{p}{p_0}\right)^{1/\gamma-1}p_t
\thinspace .\]</div>
<p>The product term <span class="math">\(p^{1/gamma -1}p_t\)</span> can be linearized as
<span class="math">\(p_0^{1/gamma -1}p_t\)</span>, resulting in</p>
<div class="math">
\[\varrho_t \approx \frac{\varrho_0}{\gamma p_0} p_t
\thinspace .\]</div>
<p>We then get</p>
<div class="math" id="equation-wave:app:sound:cont:pert">
<span class="eqno">(83)</span>\[     p_t + \gamma p_0\nabla\cdot u = 0,\]</div>
<div class="math" id="equation-wave:app:sound:Euler:pert">
<span class="eqno">(84)</span>\[     \boldsymbol{u}_t = -\frac{1}{\varrho_0}\nabla p,\]\[     \thinspace .\]</div>
<p>Taking the divergence of <a href="#equation-wave:app:sound:Euler:pert">(84)</a> and
differentiating <a href="#equation-wave:app:sound:cont:pert">(83)</a> with respect to time
gives the possibility to easily eliminate <span class="math">\(\nabla\cdot\boldsymbol{u}_t\)</span> and
arrive at a standard, linear wave equation for <span class="math">\(p\)</span>:</p>
<div class="math">
\[p_{tt} = c^2\nabla^2 p,\]</div>
<p>where <span class="math">\(c = \sqrt{\gamma p_0/\varrho_0}\)</span> is the speed of sound in the fluid.</p>
</div>
<div class="section" id="spherical-waves">
<span id="wave-app-spherical"></span><h2>Spherical waves<a class="headerlink" href="#spherical-waves" title="Permalink to this headline">¶</a></h2>
<p>Spherically symmetric three-dimensional
waves propagate in the radial direction <span class="math">\(r\)</span> only so that
<span class="math">\(u = u(r,t)\)</span>. The fully three-dimensional wave equation</p>
<div class="math">
\[\frac{\partial^2u}{\partial t^2}=\nabla\cdot (c^2\nabla u) + f\]</div>
<p>then reduces to the spherically symmetric wave equation</p>
<div class="math">
\[\begin{split}\frac{\partial^2u}{\partial t^2}=\frac{1}{r^2}\frac{\partial}{\partial r}
\left(c^2(r)r^2\frac{\partial u}{\partial t}\right)
+ f(r),\quad r\in (0,R),\ t&gt;0
\thinspace .\end{split}\]</div>
<p>Assume that the wave velocity <span class="math">\(c\)</span> is constant. One can easily show
that the function <span class="math">\(v(r,t) = ru(r,t)\)</span> fulfills a standard wave equation
in Cartesian coordinates. To this end, insert <span class="math">\(u=v/r\)</span> in</p>
<div class="math">
\[\frac{1}{r^2}\frac{\partial}{\partial r}
\left(c^2(r)r^2\frac{\partial u}{\partial t}\right)\]</div>
<p>to obtain</p>
<div class="math">
\[r\left(\frac{d c^2}{dr}\frac{\partial v}{\partial r} +
c^2\frac{\partial^2 v}{\partial r^2}\right) - \frac{d c^2}{dr}v
\thinspace .\]</div>
<p>The two terms in the parenthesis can be combined to</p>
<div class="math">
\[r\frac{\partial}{\partial r}\left( c^2\frac{\partial v}{\partial r}\right),\]</div>
<p>which is recognized as the variable-coefficient Laplace operator in
one Cartesian coordinate. The spherically symmetric wave equation in
terms of <span class="math">\(v(r,t)\)</span> now becomes</p>
<div class="math">
\[\begin{split}\frac{\partial^2u}{\partial t^2}=
\frac{\partial}{\partial r}
\left(c^2(r)\frac{\partial v}{\partial t}
-\frac{1}{r}\frac{d c^2}{dr}v\right) + rf(r),\quad r\in (0,R),\ t&gt;0
\thinspace .\end{split}\]</div>
<p>In the case of constant wave velocity <span class="math">\(c\)</span>, this equation reduces to
the wave equation in a single Cartesian coordinate:</p>
<div class="math" id="equation-wave:app:rsymm:Cart">
<span class="eqno">(85)</span>\[\begin{split}     \frac{\partial^2u}{\partial t^2}=
     \frac{\partial}{\partial r}
     \left(c^2(r)\frac{\partial v}{\partial t}\right)
     + rf(r),\quad r\in (0,R),\ t&gt;0
     \thinspace .\end{split}\]</div>
<p>That is, any program for solving the one-dimensional wave equation
in a Cartesian coordinate system can be used to
solve <a href="#equation-wave:app:rsymm:Cart">(85)</a>, provided the source term is
multiplied by the coordinate, and that we divide the Cartesian mesh
solution by <span class="math">\(r\)</span> to get the spherically symmetric solution.
Moreover, if <span class="math">\(r=0\)</span> is included in the
domain, spherical symmetry demands that <span class="math">\(\partial u/\partial r=0\)</span> at
<span class="math">\(r=0\)</span>, which means that</p>
<div class="math">
\[\frac{\partial u}{\partial r} = \frac{1}{r^2}\left(
r\frac{\partial v}{\partial r} - v\right) = 0,\quad r=0,\]</div>
<p>implying <span class="math">\(v(0,t)=0\)</span> as a necessary condition. For practical applications,
we exclude <span class="math">\(r=0\)</span> from the domain and assume that some boundary
condition is assigned at <span class="math">\(r=\epsilon\)</span>, for some <span class="math">\(\epsilon &gt;0\)</span>.</p>
</div>
<div class="section" id="the-linear-shallow-water-equations">
<span id="wave-app-sw-2d"></span><h2>The linear shallow water equations<a class="headerlink" href="#the-linear-shallow-water-equations" title="Permalink to this headline">¶</a></h2>
<p>The next example considers water waves whose wavelengths are much
lager than the depth and whose wave amplitudes are small. This class
of waves may be generated by catastrophic geophysical events, such as
earthquakes at the sea bottom, landslides moving into water, or
underwater slides (or a combination, as earthquakes frequently release
avalanches of masses). For example, a subsea earthquake will normally
have an extension of many kilometers but lift the water only a few
meters. The wave length will have a size dictated by the earthquake
area, which is much lager than the water depth, and compared to this
wave length, an amplitude of a few meters is very small.
The water is essentially a thin film, and mathematically we can average
the problem in the vertical direction and approximate the 3D
wave phenomenon by 2D PDEs. Instead of a moving water domain in three
space dimensions, we get a horizontal 2D domain with an unknown function
for the surface elevation and the water depth as a variable coefficient
in the PDEs.</p>
<p>Let <span class="math">\(\eta(x,y,t)\)</span> be the elevation of
the water surface, <span class="math">\(H(x,y)\)</span> the water depth corresponding to a flat
surface (<span class="math">\(\eta =0\)</span>), <span class="math">\(u(x,y,t)\)</span> and <span class="math">\(v(x,y,t)\)</span> the
depth-averaged horizontal velocities of the water. Mass and momentum
balance of the water volume give rise to the PDEs involving these
quantities:</p>
<div class="math" id="equation-wave:app:sw:2D:eeq">
<span class="eqno">(86)</span>\[     \eta_t = - (Hu)_x - (Hv)_x\]</div>
<div class="math" id="equation-wave:app:sw:2D:ueq">
<span class="eqno">(87)</span>\[     u_t = -g\eta_x,\]</div>
<div class="math" id="equation-wave:app:sw:2D:veq">
<span class="eqno">(88)</span>\[     v_t = -g\eta_y,\]</div>
<p>where <span class="math">\(g\)</span> is the acceleration of gravity. Equation <a href="#equation-wave:app:sw:2D:eeq">(86)</a>
corresponds to mass balance while the other two are derived from momentum
balance (Newton&#8217;s second law).</p>
<p>The initial conditions associated with
<a href="#equation-wave:app:sw:2D:eeq">(86)</a>-<a href="#equation-wave:app:sw:2D:veq">(88)</a> are <span class="math">\(\eta\)</span>, <span class="math">\(u\)</span>,
and <span class="math">\(v\)</span> prescribed at <span class="math">\(t=0\)</span>. A common condition is to have some water
elevation <span class="math">\(\eta =I(x,y)\)</span> and assume that the surface is at rest:
<span class="math">\(u=v=0\)</span>. A subsea earthquake usually means a sufficiently rapid motion
of the bottom and the water volume to say that the bottom
deformation is mirrored at the water surface as an initial lift <span class="math">\(I(x,y)\)</span>
and that <span class="math">\(u=v=0\)</span>.</p>
<p>Boundary conditions may be <span class="math">\(\eta\)</span> prescribed for incoming, known
waves, or zero normal velocity at reflecting boundaries (steep
mountains, for instance): <span class="math">\(un_x + vn_y =0\)</span>, where <span class="math">\((n_x,n_y)\)</span> is the
outward unit normal to the boundary.  More sophisticated boundary
conditions are needed when waves run up at the shore, and at open
boundaries where we want the waves to leave the computational domain
undisturbed.</p>
<p>Equations <a href="#equation-wave:app:sw:2D:eeq">(86)</a>, <a href="#equation-wave:app:sw:2D:ueq">(87)</a>, and
<a href="#equation-wave:app:sw:2D:veq">(88)</a> can be transformed to a standard, linear
wave equation. First, multiply <a href="#equation-wave:app:sw:2D:ueq">(87)</a> and
<a href="#equation-wave:app:sw:2D:veq">(88)</a> by <span class="math">\(H\)</span>, differentiate <a href="#equation-wave:app:sw:2D:ueq">(87)</a>)
with respect to <span class="math">\(x\)</span> and <a href="#equation-wave:app:sw:2D:veq">(88)</a> with respect to <span class="math">\(y\)</span>.
Second, differentiate <a href="#equation-wave:app:sw:2D:eeq">(86)</a> with respect to <span class="math">\(t\)</span>
and use that <span class="math">\((Hu)_{xt}=(Hu_t)_x\)</span> and <span class="math">\((Hv)_{yt}=(Hv_t)_y\)</span> when <span class="math">\(H\)</span>
is independent of <span class="math">\(t\)</span>. Third, eliminate <span class="math">\((Hu_t)_x\)</span> and <span class="math">\((Hv_t)_y\)</span>
with the aid of the other two differentiated equations. These manipulations
results in a standard, linear wave equation for <span class="math">\(\eta\)</span>:</p>
<div class="math" id="equation-wave:app:sw:2D:eta:2ndoeq">
<span class="eqno">(89)</span>\[     \eta_{tt} = (gH\eta_x)_x + (gH\eta_y)_y = \nabla\cdot (gH\nabla\eta)\]\[     \thinspace .\]</div>
<p>In the case we have an initial non-flat water surface at rest, the
initial conditions become <span class="math">\(\eta =I(x,y)\)</span> and <span class="math">\(\eta_t=0\)</span>.
The latter follows from <a href="#equation-wave:app:sw:2D:eeq">(86)</a> if <span class="math">\(u=v=0\)</span>, or
simply from the fact that the vertical velocity of the surface
is <span class="math">\(\eta_t\)</span>, which is zero for a surface at rest.</p>
<p>The system <a href="#equation-wave:app:sw:2D:eeq">(86)</a>-<a href="#equation-wave:app:sw:2D:veq">(88)</a>
can be extended to handle a time-varying bottom topography, which is
relevant for modeling long waves generated by underwater slides.
In such cases the water depth function <span class="math">\(H\)</span> is also a function of <span class="math">\(t\)</span>,
due to the moving slide,
and one must add a time-derivative term <span class="math">\(H_t\)</span> to the left-hand side
of <a href="#equation-wave:app:sw:2D:eeq">(86)</a>. A moving bottom is best described by
introducing <span class="math">\(z=H_0\)</span> as the still-water level, <span class="math">\(z=B(x,y,t)\)</span> as
the time- and space-varying bottom topography, so that <span class="math">\(H=H_0-B(x,y,t)\)</span>.
In the elimination of <span class="math">\(u\)</span> and <span class="math">\(v\)</span> one may assume that the dependence of
<span class="math">\(H\)</span> on <span class="math">\(t\)</span> can be neglected in the terms <span class="math">\((Hu)_{xt}\)</span> and <span class="math">\((Hv)_{yt}\)</span>.
We then end up with a source term in <a href="#equation-wave:app:sw:2D:eta:2ndoeq">(89)</a>,
because of the moving (accelerating) bottom:</p>
<div class="math" id="equation-wave:app:sw:2D:eta:2ndoeq:Ht">
<span class="eqno">(90)</span>\[     \eta_{tt} = \nabla\cdot(gH\nabla\eta) + B_{tt}\]\[     \thinspace .\]</div>
<p>The reduction of <a href="#equation-wave:app:sw:2D:eta:2ndoeq:Ht">(90)</a> to 1D, for long waves
in a straight channel, or for approximately plane waves in the ocean, is
trivial by assuming no change in <span class="math">\(y\)</span> direction (<span class="math">\(\partial/\partial y=0\)</span>):</p>
<div class="math" id="equation-wave:app:sw:1D:eta:2ndoeq:Ht">
<span class="eqno">(91)</span>\[     \eta_t = (gH\eta_x)_x + B_{tt}\]\[     \thinspace .\]</div>
<div class="section" id="wind-drag-on-the-surface">
<h3>Wind drag on the surface<a class="headerlink" href="#wind-drag-on-the-surface" title="Permalink to this headline">¶</a></h3>
<p>Surface waves are influenced by the drag of the wind, and if the
wind velocity some meters above the surface is <span class="math">\((U,V)\)</span>,
the wind drag gives contributions
<span class="math">\(C_V\sqrt{U^2+V^2}U\)</span> and <span class="math">\(C_V\sqrt{U^2+V^2}V\)</span> to
<a href="#equation-wave:app:sw:2D:ueq">(87)</a> and <a href="#equation-wave:app:sw:2D:veq">(88)</a>, respectively,
on the right-hand sides.</p>
</div>
<div class="section" id="bottom-drag">
<h3>Bottom drag<a class="headerlink" href="#bottom-drag" title="Permalink to this headline">¶</a></h3>
<p>The waves will experience a drag from the bottom, often roughly modeled
by a term similar to the wind drag:
<span class="math">\(C_B\sqrt{u^2+v^2}u\)</span> on the right-hand side of <a href="#equation-wave:app:sw:2D:ueq">(87)</a> and
<span class="math">\(C_B\sqrt{u^2+v^2}v\)</span> on the right-hand side of <a href="#equation-wave:app:sw:2D:veq">(88)</a>.
Note that in this case the PDEs <a href="#equation-wave:app:sw:2D:ueq">(87)</a> and
<a href="#equation-wave:app:sw:2D:veq">(88)</a> become nonlinear and the elimination of <span class="math">\(u\)</span> and <span class="math">\(v\)</span>
to arrive at a 2nd-order wave equation for <span class="math">\(\eta\)</span> is not possible anymore.</p>
</div>
<div class="section" id="effect-of-the-earth-s-rotation">
<h3>Effect of the Earth&#8217;s rotation<a class="headerlink" href="#effect-of-the-earth-s-rotation" title="Permalink to this headline">¶</a></h3>
<p>Long geophysical waves will often be affected by the rotation of the
Earth because of the Coriolis force. This force gives rise to a
term <span class="math">\(fv\)</span> on the right-hand side of <a href="#equation-wave:app:sw:2D:ueq">(87)</a> and
<span class="math">\(-fu\)</span> on the right-hand side of <a href="#equation-wave:app:sw:2D:veq">(88)</a>.
Also in this case one cannot eliminate <span class="math">\(u\)</span> and <span class="math">\(v\)</span> to work with a single
equation for <span class="math">\(\eta\)</span>. The Coriolis parameter is <span class="math">\(f=2\Omega\sin\phi\)</span>,
where <span class="math">\(\Omega\)</span> is the angular velocity of the earth and <span class="math">\(\phi\)</span> is
the latitude.</p>
</div>
</div>
<div class="section" id="waves-in-blood-vessels">
<span id="wave-app-blood"></span><h2>Waves in blood vessels<a class="headerlink" href="#waves-in-blood-vessels" title="Permalink to this headline">¶</a></h2>
<p>The flow of blood in our bodies is basically fluid flow in
a network of pipes. Unlike rigid pipes, the walls in the
blood vessels are elastic and will increase their diameter when the
pressure rises. The elastic forces will then push the wall back
and accelerate the fluid. This interaction between the flow of blood
and the deformation of the vessel wall results in waves traveling along
our blood vessels.</p>
<p>A model for one-dimensional waves along blood vessels can be derived
from averaging the fluid flow over the cross section of the blood
vessels. Let <span class="math">\(x\)</span> be a coordinate along the blood vessel and assume
that all cross sections are circular, though with different radius <span class="math">\(R(x,t)\)</span>.
The main quantities to compute is the cross section
area <span class="math">\(A(x,t)\)</span>, the averaged pressure <span class="math">\(P(x,t)\)</span>, and the total volume
flux <span class="math">\(Q(x,t)\)</span>.
The area of this cross section
is</p>
<div class="math">
\[A(x,t) = 2\pi\int_{0}^{R(x,t)} rdr,\]</div>
<p>Let <span class="math">\(v_x(x,t)\)</span> be the velocity of blood averaged over
the cross section at point <span class="math">\(x\)</span>. The volume flux,
being the total volume of blood passing a cross section per time unit,
becomes</p>
<div class="math">
\[Q(x,t) = A(x,t)v_x(x,t)
\thinspace\]</div>
<p>Mass balance and Newton&#8217;s second law lead to the PDEs</p>
<div class="math" id="equation-wave:app:blood:cont">
<span class="eqno">(92)</span>\[     \frac{\partial A}{\partial t} + \frac{\partial Q}{\partial x} = 0,\]</div>
<div class="math" id="equation-wave:app:blood:mom">
<span class="eqno">(93)</span>\[     \frac{\partial Q}{\partial t} +
     \frac{\gamma+2}{\gamma + 1}
     \frac{\partial}{\partial x}\left(\frac{Q^2}{A}\right)
     + \frac{A}{\varrho}\frac{\partial P}{\partial x}
     = -2\pi (\gamma + 2)\frac{\mu}{\varrho}\frac{Q}{A},\]</div>
<p>where <span class="math">\(\gamma\)</span> is a parameter related to the velocity profile,
<span class="math">\(\varrho\)</span> is the density of blood, and <span class="math">\(\mu\)</span> is the dynamic viscosity
of blood.</p>
<p>We have three unknowns <span class="math">\(A\)</span>, <span class="math">\(Q\)</span>, and <span class="math">\(P\)</span>, and two equations
<a href="#equation-wave:app:blood:cont">(92)</a> and <a href="#equation-wave:app:blood:mom">(93)</a>.
A third equation is needed to relate the flow to
the deformations of the wall. A common form for this equation is</p>
<div class="math" id="equation-wave:app:blood:const">
<span class="eqno">(94)</span>\[     \frac{\partial P}{\partial t} + \frac{1}{C}
     \frac{\partial Q}{\partial x} =0,\]</div>
<p>where <span class="math">\(C\)</span> is the compliance of the wall, given by the constitutive
relation</p>
<div class="math">
\[C = \frac{\partial A}{\partial P} + \frac{\partial A}{\partial t},\]</div>
<p>which require a relationship between <span class="math">\(A\)</span> and <span class="math">\(P\)</span>. One common model
is to view the vessel wall, locally, as a thin elastic tube subject to an
internal pressure. This gives the relation</p>
<div class="math">
\[P=P_0 + \frac{\pi h E}{(1-\nu^2)A_0}(\sqrt{A} - \sqrt{A_0}),\]</div>
<p>where <span class="math">\(P_0\)</span> and <span class="math">\(A_0\)</span> are corresponding reference values when the
wall is not deformed, <span class="math">\(h\)</span> is the
thickness of the wall, and <span class="math">\(E\)</span> and <span class="math">\(\nu\)</span> are Young&#8217;s modulus and
Poisson&#8217;s ratio of the elastic material in the wall.
The derivative becomes</p>
<div class="math">
\[C = \frac{\partial A}{\partial P} =
\frac{2(1-\nu^2)A_0}{\pi h E}\sqrt{A_0} +
2\left(\frac{(1-\nu^2)A_0}{\pi h E}\right)^2(P-P_0)
\thinspace .\]</div>
<p>Another (nonlinear) deformation model of the wall, which has a better
fit with experiments, is</p>
<div class="math">
\[P = P_0\exp{(\beta (A/A_0 - 1))},\]</div>
<p>where <span class="math">\(\beta\)</span> is some parameter to be estimated. This law leads to</p>
<div class="math">
\[C = \frac{\partial A}{\partial P} = \frac{A_0}{\beta P}
\thinspace .\]</div>
<div class="section" id="reduction-to-standard-wave-equation">
<h3>Reduction to standard wave equation<a class="headerlink" href="#reduction-to-standard-wave-equation" title="Permalink to this headline">¶</a></h3>
<p>It is not uncommon to neglect the viscous term on the right-hand side of
<a href="#equation-wave:app:blood:mom">(93)</a> and also the quadratic term
with <span class="math">\(Q^2\)</span> on the left-hand side. The reduced equations
<a href="#equation-wave:app:blood:mom">(93)</a>
and <a href="#equation-wave:app:blood:const">(94)</a> form a first-order
linear wave equation system:</p>
<div class="math">
\[C\frac{\partial P}{\partial t} = - \frac{\partial Q}{\partial x},\]</div>
<div class="math">
\[\frac{\partial Q}{\partial t}
= - \frac{A}{\varrho}\frac{\partial P}{\partial x}
\thinspace .\]</div>
<p>These can be combined into standard 1D wave equation PDE by differentiating
the first equation with respect <span class="math">\(t\)</span> and the second with respect to <span class="math">\(x\)</span>,</p>
<div class="math">
\[\frac{\partial}{\partial t}\left( CC\frac{\partial P}{\partial t}
\right) = \frac{\partial}{\partial x}\left(
\frac{A}{\varrho}\frac{\partial P}{\partial x}\right),\]</div>
<p>which can be approximated by</p>
<div class="math">
\[\frac{\partial^2 Q}{\partial t^2} = c^2\frac{\partial^2 Q}{\partial x^2},\quad
c = \sqrt{\frac{A}{\varrho C}},\]</div>
<p>where the <span class="math">\(A\)</span> and <span class="math">\(C\)</span> in the expression for <span class="math">\(c\)</span> are taken as constant
reference values.</p>
</div>
</div>
<div class="section" id="electromagnetic-waves">
<span id="wave-app-light"></span><h2>Electromagnetic waves<a class="headerlink" href="#electromagnetic-waves" title="Permalink to this headline">¶</a></h2>
<p>Light and radio waves are governed by standard wave equations arising
from Maxwell&#8217;s general equations. When there are no charges and
no currents, as in a vacuum, Maxwell&#8217;s equations take the form</p>
<div class="math">
\[\begin{split}\nabla\cdot\pmb{E} &amp;= 0,\\
\nabla\cdot\pmb{B} &amp;= 0,\\
\nabla\times\pmb{E} &amp;= -\frac{\partial\pmb{B}}{\partial t},\\
\nabla\times\pmb{B} &amp;= \mu_0\epsilon_0\frac{\partial\pmb{E}}{\partial t},\end{split}\]</div>
<p>where <span class="math">\(\epsilon_0=8.854187817620\cdot 10^{-12}\)</span> (F/m)
is the permittivity of free space, also known as the
electric constant, and <span class="math">\(\mu_0=1.2566370614\cdot 10^{-6}\)</span> (H/m)
is the permeability of free space,
also known as the magnetic constant.
Taking the curl of the two last equations and using the
identity</p>
<div class="math">
\[\nabla\times (\nabla\times \pmb{E}) = \nabla(\nabla \cdot \pmb{E})
- \nabla^2\pmb{E} = - \nabla^2\pmb{E}\hbox{ when }\nabla\cdot\pmb{E}=0,\]</div>
<p>immediately gives the wave equation governing the electric and magnetic field:</p>
<div class="math">
\[\frac{\partial^2\pmb{E}}{\partial t^2} =
c^2\frac{\partial^2\pmb{E}}{\partial x^2},\]</div>
<div class="math">
\[\frac{\partial^2\pmb{E}}{\partial t^2} =
c^2\frac{\partial^2\pmb{E}}{\partial x^2},\]</div>
<p>with <span class="math">\(c=1/\sqrt{\mu_0\epsilon_0}\)</span> as the velocity of light.
Each component of <span class="math">\(\pmb{E}\)</span> and <span class="math">\(\pmb{B}\)</span> fulfills a wave equation
and can hence be solved independently.</p>
</div>
</div>
<div class="section" id="exercises-4">
<span id="wave-app-exer"></span><h1>Exercises  (4)<a class="headerlink" href="#exercises-4" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-11-simulate-waves-on-a-non-homogeneous-string">
<span id="wave-app-exer-string-discont"></span><h2>Exercise 11: Simulate waves on a non-homogeneous string<a class="headerlink" href="#exercise-11-simulate-waves-on-a-non-homogeneous-string" title="Permalink to this headline">¶</a></h2>
<p>Simulate waves on a string that consists of two materials with
different density. The tension in the string is constant, but the
density has a jump at the boundary between the materials.
Experiment
with different sizes of the jump to derive a couple of demonstrations
that visualizes the effect on the waves of having a two-material
string.</p>
<p><em>Hint.</em> the section <a class="reference internal" href="#wave-app-string"><em>Waves on a string</em></a>
explains how the density enters the mathematical model. Modify the
<tt class="docutils literal"><span class="pre">wave1D_u0_sv.py</span></tt> code to incorporate the tension and a function
specifying the density.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave1D_u0_sv_discont.py</span></tt>.</p>
</div>
<div class="section" id="exercise-12-simulate-damped-waves-on-a-string">
<span id="wave-app-exer-string-damping"></span><h2>Exercise 12: Simulate damped waves on a string<a class="headerlink" href="#exercise-12-simulate-damped-waves-on-a-string" title="Permalink to this headline">¶</a></h2>
<p>Formulate a mathematical model for damped waves on a string.
Use data from the section <a class="reference internal" href="#wave-pde1-guitar-data"><em>Running a case</em></a>, and
tune the damping parameter so that the string is very close to
the rest state after 15 s. Make a movie of the wave motion.
Filename: <tt class="docutils literal"><span class="pre">wave1D_u0_sv_damping.py</span></tt>.</p>
</div>
<div class="section" id="exercise-13-simulate-elastic-waves-in-a-rod">
<span id="wave-app-exer-rod"></span><h2>Exercise 13: Simulate elastic waves in a rod<a class="headerlink" href="#exercise-13-simulate-elastic-waves-in-a-rod" title="Permalink to this headline">¶</a></h2>
<p>A hammer hits the end of an elastic rod. The exercise is to simulate
the resulting wave motion using the model <a href="#equation-wave:app:elastic:rod:eq">(71)</a>
from the section <a class="reference internal" href="#wave-app-elastic-rod"><em>Elastic waves in a rod</em></a>. Let the rod have length
<span class="math">\(L\)</span> and let the boundary <span class="math">\(x=L\)</span> be stress free so that <span class="math">\(\sigma_{xx}=0\)</span>,
implying that <span class="math">\(\partial u/\partial x=0\)</span>. The left end <span class="math">\(x=0\)</span> is
subject to a strong stress pulse (the hammer), modeled as</p>
<div class="math">
\[\begin{split}\sigma_{xx}(t) = \left\lbrace\begin{array}{ll}
S,&amp; 0 &lt; t \leq t_s,\\
0, &amp; t &gt; t_s
\end{array}\right.\end{split}\]</div>
<p>The corresponding condition on <span class="math">\(u\)</span> becomes <span class="math">\(u_x= S/E\)</span>
for <span class="math">\(t\leq t_s\)</span> and zero afterwards (recall that
<span class="math">\(\sigma_{xx} = Eu_x\)</span>). This is a non-homogeneous
Neumann condition, and you will need to approximate this condition
and combine it with the scheme (the ideas and manipulations follow
closely the handling of a non-zero initial condition
<span class="math">\(u_t=V\)</span> in wave PDEs or the corresponding
second-order ODEs for vibrations).
Filename: <tt class="docutils literal"><span class="pre">wave_rod.py</span></tt>.</p>
</div>
<div class="section" id="exercise-14-explain-why-numerical-noise-occurs">
<span id="wave-app-exer-pulse1d-analysis"></span><h2>Exercise 14: Explain why numerical noise occurs<a class="headerlink" href="#exercise-14-explain-why-numerical-noise-occurs" title="Permalink to this headline">¶</a></h2>
<p>The experiments performed in <a class="reference internal" href="#wave-app-exer-pulse1d"><em>Exercise 8: Send pulse waves through a layered medium</em></a> shows
considerable numerical noise in the form of non-physical waves,
especially for <span class="math">\(s_f=4\)</span> and the plug pulse or the half a &#8220;cosinehat&#8221;
pulse. The noise is much less visible for a Gaussian pulse. Run the
case with the plug and half a &#8220;cosinehat&#8221; pulses for <span class="math">\(s_f=1\)</span>, <span class="math">\(C=0.9,
0.25\)</span>, and <span class="math">\(N_x=40,80,160\)</span>. Use the numerical dispersion relation to
explain the observations.
Filename: <tt class="docutils literal"><span class="pre">pulse1D_analysis.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-15-investigate-harmonic-averaging-in-a-1d-model">
<span id="wave-app-exer-pulse1d-harmonic"></span><h2>Exercise 15: Investigate harmonic averaging in a 1D model<a class="headerlink" href="#exercise-15-investigate-harmonic-averaging-in-a-1d-model" title="Permalink to this headline">¶</a></h2>
<p>Will harmonic averaging of the wave velocity give better numerical
results for the case <span class="math">\(s_f=4\)</span> in <a class="reference internal" href="#wave-app-exer-pulse1d"><em>Exercise 8: Send pulse waves through a layered medium</em></a>?
Filenames: <tt class="docutils literal"><span class="pre">pulse1D_harmonic.pdf</span></tt>, <tt class="docutils literal"><span class="pre">pulse1D_harmonic.py</span></tt>.</p>
</div>
<div class="section" id="exercise-16-test-the-efficiency-of-compiled-loops-in-3d">
<span id="wave-exer-3d-f77-cy-efficiency"></span><h2>Exercise 16: Test the efficiency of compiled loops in 3D<a class="headerlink" href="#exercise-16-test-the-efficiency-of-compiled-loops-in-3d" title="Permalink to this headline">¶</a></h2>
<p>Extend the <tt class="docutils literal"><span class="pre">wave2D_u0.py</span></tt> code and the Cython, Fortran, and C versions to 3D.
Set up an efficiency experiment to determine the relative efficiency of
pure scalar Python code, vectorized code, Cython-compiled loops,
Fortran-compiled loops, and C-compiled loops.
Normalize the CPU time for each mesh by the fastest version.
Filename: <tt class="docutils literal"><span class="pre">wave3D_u0.py</span></tt>.</p>
</div>
<div class="section" id="exercise-17-earthquake-generated-tsunami-in-a-1d-model">
<span id="wave-app-exer-tsunami1d"></span><h2>Exercise 17: Earthquake-generated tsunami in a 1D model<a class="headerlink" href="#exercise-17-earthquake-generated-tsunami-in-a-1d-model" title="Permalink to this headline">¶</a></h2>
<p>A subsea earthquake leads to an immediate lift of the surface, see
Figure <a class="reference internal" href="#wave-app-fig-1d-tsunami-flat"><em>Sketch of initial water surface due to a subsea earthquake</em></a>. The initial surface shape <span class="math">\(I(x)\)</span> is symmetric
around <span class="math">\(x=0\)</span> and will split into two tsunamis, one traveling to the right
and one to the left, as depicted in Figure <a class="reference internal" href="#wave-app-fig-1d-tsunami-2waves"><em>An initial surface elevation is split into two waves</em></a>.
Since the water surface will remain symmetric with respect to <span class="math">\(x=0\)</span>, given that
the outgoing wave to the left does not come back due to reflection,
we insert a boundary <span class="math">\(x=0\)</span> and impose a symmetry condition there: <span class="math">\(\partial\eta\
\partial x =0\)</span>, where <span class="math">\(\eta(x,t)\)</span> is the elevation of the water surface.
We are not interested in what happens with the right-going wave after
it hits the right boundary, so whether we impose
<span class="math">\(\eta =0\)</span> or <span class="math">\(\partial\eta /\partial x=0\)</span> at that boundary is not of importance.</p>
<p>The shape of the initial surface can be taken as a
Gaussian function,</p>
<div class="math">
\[I(x;I_0,I_a,I_m,I_s) =
I_0 + I_a\exp{\left(-\left(\frac{x-I_m}{I_s}\right)^2\right)},\]</div>
<p>with <span class="math">\(I_m=0\)</span> reflecting the location of the peak of <span class="math">\(I(x)\)</span> and
<span class="math">\(I_s\)</span> being a measure of the width of the function <span class="math">\(I(x)\)</span>
(<span class="math">\(I_s\)</span> is <span class="math">\(\sqrt{2}\)</span> times the standard deviation of the familiar
normal distribution curve).</p>
<p>Set up the relevant one-dimensional, linear, wave equation for <span class="math">\(\eta\)</span>,
assuming long waves of small amplitude in comparison with the depth,
as described in the section <a class="reference internal" href="#wave-app-sw-2d"><em>The linear shallow water equations</em></a>. Import the <tt class="docutils literal"><span class="pre">viz</span></tt> method
from the <tt class="docutils literal"><span class="pre">wave1D.py</span></tt> program and make a call to it to solve the
present tsunami problem.  The constant speed of the right-going wave is
<span class="math">\(c=\sqrt{gH}\)</span> and use this quantity to determine a suitable time <span class="math">\(T\)</span>
for when the wave hits the right boundary and the simulation is to be
stopped. An alternative is to check in <tt class="docutils literal"><span class="pre">plot_u</span></tt> if <span class="math">\(u[-2]\)</span> is
significantly different from 0 and then return <tt class="docutils literal"><span class="pre">True</span></tt> to stop
the simulation.</p>
<div class="figure" id="wave-app-fig-1d-tsunami-flat">
<img alt="_images/earthquake_tsunami_flat1.png" src="_images/earthquake_tsunami_flat1.png" style="width: 800px;" />
<p class="caption"><em>Sketch of initial water surface due to a subsea earthquake</em></p>
</div>
<div class="figure" id="wave-app-fig-1d-tsunami-2waves">
<img alt="_images/earthquake_tsunami_2waves1.png" src="_images/earthquake_tsunami_2waves1.png" style="width: 800px;" />
<p class="caption"><em>An initial surface elevation is split into two waves</em></p>
</div>
<p>Filename: <tt class="docutils literal"><span class="pre">tsunami1D_flat.py</span></tt>.</p>
</div>
<div class="section" id="exercise-18-implement-an-open-boundary-condition">
<span id="wave-app-exer-tsunami1d-radiation"></span><h2>Exercise 18: Implement an open boundary condition<a class="headerlink" href="#exercise-18-implement-an-open-boundary-condition" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-48"></span><p id="index-49">To enable the right-going wave in <a class="reference internal" href="#wave-app-exer-tsunami1d"><em>Exercise 17: Earthquake-generated tsunami in a 1D model</em></a>
to leave the computational domain and travel undisturbed through
the boundary, one can in a one-dimensional problem impose the
following condition, called a <em>radiation condition</em> or
<em>open boundary condition</em>:</p>
<div class="math" id="equation-wave:app:exer:tsunami1D:radiation:eq">
<span class="eqno">(95)</span>\[     \frac{\partial\eta}{\partial t} + c\frac{\partial\eta}{\partial x} = 0,\]</div>
<p>at the right boundary <span class="math">\(x=x_R\)</span>. The parameter <span class="math">\(c\)</span> is the wave velocity,
which for the model in <a class="reference internal" href="#wave-app-exer-tsunami1d"><em>Exercise 17: Earthquake-generated tsunami in a 1D model</em></a>
is <span class="math">\(c=\sqrt{gH(x_R)}\)</span>.</p>
<p>Show that <a href="#equation-wave:app:exer:tsunami1D:radiation:eq">(95)</a> accepts
a solution <span class="math">\(\eta = g_R(x-ct)\)</span>, but not <span class="math">\(\eta = g_L(x+ct)\)</span>. This means
that <a href="#equation-wave:app:exer:tsunami1D:radiation:eq">(95)</a> will allow any
right-going wave <span class="math">\(g_R(x-ct)\)</span> pass through the boundary.</p>
<p>The condition <a href="#equation-wave:app:exer:tsunami1D:radiation:eq">(95)</a> can be
discretized by centered differences at the spatial end point <span class="math">\(i=N_x\)</span>,
corresponding to <span class="math">\(x=x_R\)</span>:</p>
<div class="math" id="equation-wave:app:exer:tsunami1D:radiation:eq:op">
<span class="eqno">(96)</span>\[     [D_{2t}\eta + cD_{2x}\eta =0]^n_{N_x}\]\[     \thinspace .\]</div>
<p>Eliminate the fictitious value <span class="math">\(\eta_{N_x+1}^n\)</span> by using
the discrete equation at the same point <span class="math">\((n,N_x)\)</span>.
The equation for the first step, <span class="math">\(\eta_i^1\)</span>, is in principal affected,
but we can then use the condition <span class="math">\(\eta^1_{N_x}=0\)</span> since the wave
has not yet reached the right boundary.</p>
<p>Modify the <tt class="docutils literal"><span class="pre">solver</span></tt> function in the <tt class="docutils literal"><span class="pre">wave1D.py</span></tt> program to
incorporate the condition <a href="#equation-wave:app:exer:tsunami1D:radiation:eq:op">(96)</a>.
Demonstrate that the tsunami travels through the domain and out of
the right boundary without leaving any reflections behind.
Make a nose test for checking that after a certain time <span class="math">\(T\)</span>, the surface is
flat.</p>
<p><em>Remark 1.</em> The condition <a href="#equation-wave:app:exer:tsunami1D:radiation:eq">(95)</a>
works perfectly in 1D when <span class="math">\(c\)</span> is known. In 2D and 3D, however, the
condition reads <span class="math">\(\eta_t + c_x\eta_x + c_y\eta_y=0\)</span>, where <span class="math">\(c_x\)</span> and
<span class="math">\(c_y\)</span> are the wave speeds in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions, and estimating
these components (i.e., the direction of the wave) is often
challenging. Other methods are normally used in 2D and 3D to
let waves move out of a computational domain.</p>
<p><em>Remark 2.</em> A radiation or open boundary condition at the left
boundary takes the same form as <a href="#equation-wave:app:exer:tsunami1D:radiation:eq">(95)</a>,
except that there is a minus sign in front of the <span class="math">\(c\eta_x\)</span>
term. One can easily show that with this sign, the condition accepts
left-going waves of the form <span class="math">\(\eta = g_L(x+ct)\)</span>.
Filename: <tt class="docutils literal"><span class="pre">wave1D_Ropen.py</span></tt>.</p>
</div>
<div class="section" id="exercise-19-earthquake-generated-tsunami-over-a-subsea-hill">
<span id="wave-app-exer-tsunami1d-hill"></span><h2>Exercise 19: Earthquake-generated tsunami over a subsea hill<a class="headerlink" href="#exercise-19-earthquake-generated-tsunami-over-a-subsea-hill" title="Permalink to this headline">¶</a></h2>
<p>We consider the same problem as in <a class="reference internal" href="#wave-app-exer-tsunami1d"><em>Exercise 17: Earthquake-generated tsunami in a 1D model</em></a>, but now there is a hill at the sea
bottom, see Figure <a class="reference internal" href="#wave-app-fig-1d-tsunami-hill"><em>Sketch of an earthquake-generated tsunami passing over a subsea hill</em></a>. The wave speed
<span class="math">\(c=\sqrt{gH(x)} = \sqrt{g(H_0-B(x))}\)</span> will then be reduced in the
shallow water above the hill.</p>
<div class="figure" id="wave-app-fig-1d-tsunami-hill">
<img alt="_images/earthquake_tsunami_hill1.png" src="_images/earthquake_tsunami_hill1.png" style="width: 800px;" />
<p class="caption"><em>Sketch of an earthquake-generated tsunami passing over a subsea hill</em></p>
</div>
<p>One possible form of the
hill is a Gaussian function,</p>
<div class="math" id="equation-wave:app:exer:tsunami1D:hill:Gauss">
<span class="eqno">(97)</span>\[     B(x;B_0,B_a,B_m,B_s) =
     B_0 + B_a\exp{\left(-\left(\frac{x-B_m}{B_s}\right)^2\right)},\]</div>
<p>but many other shapes are also possible, e.g., a &#8220;cosine hat&#8221; where</p>
<div class="math" id="equation-wave:app:exer:tsunami1D:hill:cohat">
<span class="eqno">(98)</span>\[     B(x; B_0, B_a, B_m, B_s) = B_0 + B_a\cos{\left( \pi\frac{x-B_m}{2B_s}\right)},\]</div>
<p>when <span class="math">\(x\in [B_m - B_s, B_m + B_s]\)</span> while <span class="math">\(B=B_0\)</span> outside this
interval.</p>
<p>Also an abrupt construction may be tried:</p>
<div class="math" id="equation-wave:app:exer:tsunami1D:hill:box">
<span class="eqno">(99)</span>\[     B(x; B_0, B_a, B_m, B_s) = B_0 + B_a,\]</div>
<p>for <span class="math">\(x\in [B_m - B_s, B_m + B_s]\)</span> while <span class="math">\(B=B_0\)</span> outside this
interval.</p>
<p>Visualize both the bottom topography and the
water surface elevation (this requires modifying <tt class="docutils literal"><span class="pre">plot_u</span></tt>).
Allow for a flexible choice of bottom shape,
<a href="#equation-wave:app:exer:tsunami1D:hill:Gauss">(97)</a>,
<a href="#equation-wave:app:exer:tsunami1D:hill:cohat">(98)</a>,
<a href="#equation-wave:app:exer:tsunami1D:hill:box">(99)</a>, or <span class="math">\(B(x)=B_0\)</span> (flat)
and see if the waves become
qualitatively different. Also investigate the amount of numerical
noise that is triggered by rapid changes in the bottom function
and a small water gap at the top of the hill, and how this noise
varies with the mesh resolution <span class="math">\(\Delta x\)</span>.
Use either the open boundary condition from
<a class="reference internal" href="#wave-app-exer-tsunami1d-radiation"><em>Exercise 18: Implement an open boundary condition</em></a>, or set <span class="math">\(\eta =0\)</span> at
the right boundary and stop the simulation when the wave hits this
boundary.
Filename: <tt class="docutils literal"><span class="pre">tsunami1D_hill.py</span></tt>.</p>
</div>
<div class="section" id="exercise-20-implement-neumann-conditions-in-2d">
<span id="wave-app-exer-wave2d-neumann"></span><h2>Exercise 20: Implement Neumann conditions in 2D<a class="headerlink" href="#exercise-20-implement-neumann-conditions-in-2d" title="Permalink to this headline">¶</a></h2>
<p>Modify the <a class="reference external" href="/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>
program, which solves the 2D wave equation <span class="math">\(u_{tt}=c^2(u_{xx}+u_{yy})\)</span>
with constant wave velocity <span class="math">\(c\)</span> and <span class="math">\(u=0\)</span> on the boundary, to have
Neumann boundary conditions: <span class="math">\(\partial u/\partial n=0\)</span>.
Include both scalar code (for debugging and reference) and
vectorized code (for speed).</p>
<p>To test the code, use <span class="math">\(u=1.2\)</span> as solution (<span class="math">\(I(x,y)=1.2\)</span>, <span class="math">\(V=f=0\)</span>, and
<span class="math">\(c\)</span> arbitrary), which should be exactly reproduced with any mesh
as long as the stability criterion is satisfied.
Another test is to use the plug-shaped pulse
in the <tt class="docutils literal"><span class="pre">pulse</span></tt> function from the section <a class="reference internal" href="#wave-pde2-software"><em>Building a general 1D wave equation solver</em></a>
and the <a class="reference external" href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py">wave1D_dn_vc.py</a>
program. This pulse
is exactly propagated in 1D if <span class="math">\(c\Delta t/\Delta x=1\)</span>. Check
that also the 2D program can propagate this pulse exactly
in <span class="math">\(x\)</span> direction (<span class="math">\(c\Delta t/\Delta x=1\)</span>, <span class="math">\(\Delta y\)</span> arbitrary)
and <span class="math">\(y\)</span> direction (<span class="math">\(c\Delta t/\Delta y=1\)</span>, <span class="math">\(\Delta x\)</span> arbitrary).
Filename: <tt class="docutils literal"><span class="pre">wave2D_n.py</span></tt>.</p>
</div>
<div class="section" id="exercise-21-implement-a-convergence-test-for-a-2d-code">
<h2>Exercise 21: Implement a convergence test for a 2D code<a class="headerlink" href="#exercise-21-implement-a-convergence-test-for-a-2d-code" title="Permalink to this headline">¶</a></h2>
<p>Use the following manufactured solution to verify a 2D code
for <span class="math">\(u_{tt}=c^2(u_{xx}+u_{yy})\)</span> in the spatial domain
<span class="math">\([0,L_x]\times [0,L_y]\)</span>, with <span class="math">\(\partial u/\partial n\)</span> on the boundary
(cf. <a class="reference internal" href="#wave-app-exer-wave2d-neumann"><em>Exercise 20: Implement Neumann conditions in 2D</em></a>):</p>
<div class="math" id="equation-wave:app:exer:standing:waves">
<span class="eqno">(100)</span>\[     {u_{\small\mbox{e}}}(x,y,t)=\cos(m_xx\pi/L_x)\cos(m_yy\pi/L_y)\cos (\omega t),\]</div>
<p>Here, <span class="math">\(m_x\)</span> and <span class="math">\(m_y\)</span> are freely chosen integers such that
the wave lengths in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions become <span class="math">\(2L_x/m_x\)</span> and
<span class="math">\(2L_y/m_y\)</span>, respectively. The parameter <span class="math">\(\omega\)</span> is calculated
by inserting <a href="#equation-wave:app:exer:standing:waves">(100)</a> in the wave equation.
The solution
<a href="#equation-wave:app:exer:standing:waves">(100)</a> is a <em>standing wave</em>
with <span class="math">\(\partial u/\partial n=0\)</span>.
This <span class="math">\({u_{\small\mbox{e}}}\)</span> is not an exact solution of the discrete equations so the
test must be based on empirical analysis of the convergence.
The error <span class="math">\(E\)</span> is assumed to behave like</p>
<div class="math">
\[E = C_t\Delta t^2 + C_x\Delta x^2 + C_y\Delta y^2,\]</div>
<p>for some constants <span class="math">\(C_t\)</span>, <span class="math">\(C_x\)</span>, and <span class="math">\(C_y\)</span>.
Choose <span class="math">\(\Delta t=F_th\)</span>, <span class="math">\(\Delta x =F_xh\)</span>, and <span class="math">\(\Delta y=F_yh\)</span>, where
<span class="math">\(h\)</span> is a common discretization parameter to be varied (<span class="math">\(h\rightarrow 0\)</span>)
and <span class="math">\(F_t\)</span>, <span class="math">\(F_x\)</span>, and <span class="math">\(F_y\)</span> are freely chosen constant factors
compatible with the stability criterion in 2D. The error can then
be expressed as</p>
<div class="math">
\[E = Ch^2,\]</div>
<p>where <span class="math">\(C=C_xF_t^2 + C_yF_x^2 + C_tF_t^2\)</span>.
Perform experiments with decreasing <span class="math">\(h\)</span>, compute <span class="math">\(E\)</span>, and verify that
<span class="math">\(E/h^2\)</span> is approximately constant.
Filename: <tt class="docutils literal"><span class="pre">wave2D_n2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-22-earthquake-generated-tsunami-over-a-3d-hill">
<span id="wave-app-exer-tsunami2d-hill"></span><h2>Exercise 22: Earthquake-generated tsunami over a 3D hill<a class="headerlink" href="#exercise-22-earthquake-generated-tsunami-over-a-3d-hill" title="Permalink to this headline">¶</a></h2>
<p>This exercise extends <a class="reference internal" href="#wave-app-exer-tsunami1d-hill"><em>Exercise 19: Earthquake-generated tsunami over a subsea hill</em></a>
to a three-dimensional wave phenomenon, governed by the 2D PDE
<a href="#equation-wave:app:sw:2D:eta:2ndoeq">(89)</a>. We assume that the earthquake
arise from a fault along the line <span class="math">\(x=0\)</span> in the <span class="math">\(xy\)</span>-plane so that
the initial lift of the surface can be taken as <span class="math">\(I(x)\)</span> in
<a class="reference internal" href="#wave-app-exer-tsunami1d-hill"><em>Exercise 19: Earthquake-generated tsunami over a subsea hill</em></a>. That is, a plan wave is
propagating to the right, but will experience bending because of
the bottom.</p>
<p>The bottom shape is now a function of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.
An &#8220;elliptic&#8221; Gauss function in two dimensions, with its peak
at <span class="math">\((B_{mx}, B_{my})\)</span>, generalizes
<a href="#equation-wave:app:exer:tsunami1D:hill:Gauss">(97)</a>:</p>
<div class="math" id="equation-wave:app:exer:tsunami2D:hill:Gauss">
<span class="eqno">(101)</span>\[     B(x;B_0,B_a,B_{mx}, B_{my} ,B_s, b) =
     B_0 + B_a\exp{\left(-\left(\frac{x-B_{mx}}{B_s}\right)^2
     -\left(\frac{y-B_{my}}{bB_s}\right)^2\right)},\]</div>
<p>where <span class="math">\(b\)</span> is a scaling parameter: <span class="math">\(b=1\)</span> gives a circular Gaussian
function with circular contour lines, while <span class="math">\(b\neq 1\)</span> gives an elliptic
shape with elliptic contour lines.</p>
<p>The &#8220;cosine hat&#8221; <a href="#equation-wave:app:exer:tsunami1D:hill:cohat">(98)</a> can also be
generalized to</p>
<div class="math" id="equation-wave:app:exer:tsunami2D:hill:cohat">
<span class="eqno">(102)</span>\[     B(x; B_0, B_a, B_{mx}, B_{my}, B_s) =
     B_0 + B_a\cos{\left( \pi\frac{x-B_{mx}}{2B_s}\right)}
     \cos{\left( \pi\frac{y-B_{my}}{2B_s}\right)},\]</div>
<p>when <span class="math">\(0 \leq \sqrt{x^2+y^2} \leq B_s\)</span> and <span class="math">\(B=B_0\)</span> outside this circle.</p>
<p>A box-shaped obstacle means that</p>
<div class="math" id="equation-wave:app:exer:tsunami2D:hill:box">
<span class="eqno">(103)</span>\[     B(x; B_0, B_a, B_m, B_s, b) = B_0 + B_a\]</div>
<p>for <span class="math">\(x\)</span> and <span class="math">\(y\)</span> inside a rectangle</p>
<div class="math">
\[B_{mx}-B_s \leq  x \leq B_{mx} + B_s,\quad
B_{my}-bB_s \leq  y \leq B_{my} + bB_s,\]</div>
<p>and <span class="math">\(B=B_0\)</span> outside this rectangle.
The <span class="math">\(b\)</span> parameter controls the rectangular shape of the cross section of
the box.</p>
<p>Note that the initial condition and the listed bottom shapes are
symmetric around the line <span class="math">\(y=B_{my}\)</span>. We therefore expect the
surface elevation also to be symmetric with respect to this line.
This means that we can halve the computational domain by working
with  <span class="math">\([0,L_x]\times [0, B_{my}]\)</span>. Along the upper boundary, <span class="math">\(y=B_{my}\)</span>,
we must impose the symmetry condition <span class="math">\(\partial \eta/\partial n=0\)</span>.
Such a symmetry condition (<span class="math">\(-\eta_x=0\)</span>)
is also needed at the <span class="math">\(x=0\)</span> boundary because
the initial condition has a symmetry here. At the lower boundary
<span class="math">\(y=0\)</span> we also set a Neumann condition (which becomes <span class="math">\(-\eta_y=0\)</span>).
At the right boundary <span class="math">\(x=L_x\)</span>
one can either implement a radiation (or open boundary) condition
as in <a class="reference internal" href="#wave-app-exer-tsunami1d-radiation"><em>Exercise 18: Implement an open boundary condition</em></a> or just set
<span class="math">\(\eta = 0\)</span> or use a reflecting condition <span class="math">\(\partial\eta/\partial n
=\eta_x =0\)</span>.</p>
<p>Visualize the surface elevation.  Investigate how different hill shapes,
different sizes of the water gap above the hill, and different
resolutions <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span> influence
the numerical quality of the solution.
Filename: <tt class="docutils literal"><span class="pre">tsunami2D_hill.py</span></tt>.</p>
</div>
<div class="section" id="exercise-23-implement-loops-in-compiled-languages">
<span id="wave-app-exer-tsunami2d-hill-compiled"></span><h2>Exercise 23: Implement loops in compiled languages<a class="headerlink" href="#exercise-23-implement-loops-in-compiled-languages" title="Permalink to this headline">¶</a></h2>
<p>Extend the program from <a class="reference internal" href="#wave-app-exer-tsunami2d-hill"><em>Exercise 22: Earthquake-generated tsunami over a 3D hill</em></a> such
that the loops over mesh points, inside the time loop, are
implemented in compiled languages.
Consider implementations in
Cython, Fortran via <tt class="docutils literal"><span class="pre">f2py</span></tt>, C via Cython, C via <tt class="docutils literal"><span class="pre">f2py</span></tt>, C/C++ via Instant,
and C/C++ via <tt class="docutils literal"><span class="pre">scipy.weave</span></tt>.
Perform efficiency experiments to investigate the relative performance
of the various implementations. It is often advantageous to normalize
CPU times by the fastest method on a given mesh.
Filename: <tt class="docutils literal"><span class="pre">tsunami3D_hill_compiled.py</span></tt>.</p>
</div>
<div class="section" id="exercise-24-write-a-complete-program-in-fortran-or-c">
<span id="wave-app-exer-tsunami2d-hill-compiled2"></span><h2>Exercise 24: Write a complete program in Fortran or C<a class="headerlink" href="#exercise-24-write-a-complete-program-in-fortran-or-c" title="Permalink to this headline">¶</a></h2>
<p>As an extension of <a class="reference internal" href="#wave-app-exer-tsunami2d-hill-compiled2"><em>Exercise 24: Write a complete program in Fortran or C</em></a>,
write the whole <tt class="docutils literal"><span class="pre">tsunami3D_hill.py</span></tt> code in Fortran, C, or C++ to check
if there is more to be won with respect to efficiency in large-scale
problems. This exercise will also illustrate the difference in
program development with Fortran/C/C++ and Python.
Filename: <tt class="docutils literal"><span class="pre">tsunami3D_hill.f</span></tt>.</p>
</div>
<div class="section" id="exercise-25-investigate-matplotlib-for-visualization">
<span id="wave-app-exer-tsunami-hill-viz-matplotlib"></span><h2>Exercise 25: Investigate Matplotlib for visualization<a class="headerlink" href="#exercise-25-investigate-matplotlib-for-visualization" title="Permalink to this headline">¶</a></h2>
<p>Play with native Matplotlib code for visualizing 2D
solutions of the wave equation with variable wave velocity.
See if there
are effective ways to visualize both the solution and the wave
velocity.
Filename: <tt class="docutils literal"><span class="pre">tsunami2D_hill_mpl.py</span></tt>.</p>
</div>
<div class="section" id="exercise-26-investigate-visualization-packages">
<span id="wave-app-exer-tsunami-hill-viz-packages"></span><h2>Exercise 26: Investigate visualization packages<a class="headerlink" href="#exercise-26-investigate-visualization-packages" title="Permalink to this headline">¶</a></h2>
<p>Explore one or more of the programs below
for visualizing solutions of 2D or 3D wave equations with variable
wave velocity. Try to visualize
both the solution and the wave velocity in the same plot.</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://code.enthought.com/projects/mayavi/">Mayavi</a></li>
<li><a class="reference external" href="http://www.paraview.org/">Paraview</a></li>
<li><a class="reference external" href="http://www.opendx.org/">OpenDX</a></li>
</ul>
</div></blockquote>
<p>Filename: <tt class="docutils literal"><span class="pre">tsunami2D_hill_mayavi.py</span></tt>.</p>
</div>
<div class="section" id="exercise-27-investigate-harmonic-vs-arithmetic-mean">
<span id="wave-app-exer-tsunami-hill-harmonic"></span><h2>Exercise 27: Investigate harmonic vs arithmetic mean<a class="headerlink" href="#exercise-27-investigate-harmonic-vs-arithmetic-mean" title="Permalink to this headline">¶</a></h2>
<p>In <a class="reference internal" href="#wave-app-exer-tsunami1d-hill"><em>Exercise 19: Earthquake-generated tsunami over a subsea hill</em></a>, investigate if
there is significant difference between the harmonic mean
<a href="#equation-wave:pde2:var:c:mean:harmonic">(30)</a> and the standard
arithmetic mean <a href="#equation-wave:pde2:var:c:mean:arithmetic">(29)</a>.
Use extreme cases for the investigations where the subsea hill is
close to the flat surface. Pay particular attention to the
box-shaped obstruction <a href="#equation-wave:app:exer:tsunami1D:hill:box">(99)</a> since
it has discontinuities.</p>
<p>Repeat the investigations for the case of a box-shaped obstruction
in the 2D model from <a class="reference internal" href="#wave-app-exer-tsunami2d-hill"><em>Exercise 22: Earthquake-generated tsunami over a 3D hill</em></a>.</p>
<p><em>Remark.</em> With a small gap between the obstruction and the free surface,
and with abrupt changes in the bottom shape, the model PDE does not
necessarily describe the wave motion in an accurate or qualitatively correct
way.
Filename: <tt class="docutils literal"><span class="pre">tsunami2D_hill_harmonic.py</span></tt>.</p>
</div>
<div class="section" id="exercise-28-simulate-seismic-waves-in-2d">
<span id="wave-app-exer-seismic2d"></span><h2>Exercise 28: Simulate seismic waves in 2D<a class="headerlink" href="#exercise-28-simulate-seismic-waves-in-2d" title="Permalink to this headline">¶</a></h2>
<p>The goal of this exercise is to simulate seismic waves using the
PDE model <a href="#equation-wave:app:acoustic:seismic:accoustic1a">(78)</a> in a
2D <span class="math">\(xz\)</span> domain with geological layers.
Introduce <span class="math">\(m\)</span> horizontal layers of thickness <span class="math">\(h_i\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>.
Inside layer number <span class="math">\(i\)</span> we have a vertical wave velocity <span class="math">\(c_{z,i}\)</span>
and a horizontal wave velocity <span class="math">\(c_{h,i}\)</span>. Make a program
for simulating such 2D waves. Test it on a case with 3 layers where</p>
<div class="math">
\[c_{z,0}=c_{z,1}=c_{z,2},\quad c_{h,0}=c_{h,2},\quad c_{h,1} \ll c_{h,0}
\thinspace .\]</div>
<p>Let <span class="math">\(s\)</span> be a localized point source at the middle of the Earth&#8217;s surface
(the upper boundary)
and investigate how the resulting wave travels through the medium.
The source can be a localized Gaussian peak that oscillates in
time for some time interval.
Place the boundaries far enough from the expanding wave so that the
boundary conditions do not disturb the wave. Then the type of
boundary condition does not matter, except that we physically need
to have <span class="math">\(p=p_0\)</span>, where <span class="math">\(p_0\)</span> is the atmospheric pressure,
at the upper boundary.
Filename: <tt class="docutils literal"><span class="pre">seismic2D.py</span></tt>.</p>
</div>
<div class="section" id="project-29-modeling-3d-acoustic-waves-in-a-room">
<span id="wave-app-exer-acoustics"></span><h2>Project 29: Modeling 3D acoustic waves in a room<a class="headerlink" href="#project-29-modeling-3d-acoustic-waves-in-a-room" title="Permalink to this headline">¶</a></h2>
<p>The equation for sound waves in air is derived in the section <a class="reference internal" href="#wave-app-sound"><em>Sound waves in liquids and gases</em></a>
and reads</p>
<div class="math">
\[p_{tt} = c^2\nabla^2 p,\]</div>
<p>where <span class="math">\(p(x,y,z,t)\)</span> is the pressure and <span class="math">\(c\)</span>
is the speed of sound, taken as 340 m/s.</p>
<p>However, sound is absorbed in the air due to relaxation of molecules
in the gas. A model for simple relaxation, valid for gases consisting
only of one type of molecules, is a term <span class="math">\(c^2\tau_s\nabla^2 p_t\)</span> in
the PDE, where <span class="math">\(\tau_s\)</span> is the relaxation time. If we generate sound
from, e.g., a loudspeaker in the room, this sound source must also
be added to the governing equation.</p>
<p>The PDE with the mentioned type of damping and source then becomes</p>
<div class="math">
\[p_tt = c^2\nabla^p + c^2\tau_s\nabla^2 p_t + f,\]</div>
<p>where <span class="math">\(f(x,y,z,t)\)</span> is the source term.</p>
<p>The walls can absorb some sound. A possible model is to have a &#8220;wall layer&#8221;
(thicker than the physical wall)
outside the room where <span class="math">\(c\)</span> is changed such that some of the wave energy
is reflected and some is absorbed in the wall. The absorption of
energy can be taken care of by adding a damping term <span class="math">\(bp_t\)</span> in
the equation:</p>
<div class="math">
\[p_tt + bp_t = c^2\nabla^p + c^2\tau_s\nabla^2 p_t + f{\thinspace .}\]</div>
<p>Typically, <span class="math">\(b=0\)</span> in the room and <span class="math">\(b&gt;0\)</span> in the wall. A discontinuity in <span class="math">\(b\)</span>
or <span class="math">\(c\)</span> will give rise to reflections. It can be wise to use a constant
<span class="math">\(c\)</span> in the wall to control reflections because of the discontinuity between
<span class="math">\(c\)</span> in the air and in the wall, while <span class="math">\(b\)</span> is gradually increased
as we go into the wall to avoid reflections because of rapid changes in <span class="math">\(b\)</span>.
At the outer boundary of the wall the condition <span class="math">\(p=0\)</span> or <span class="math">\(\partial p/\partial n=0\)</span> can be imposed. The waves should anyway be approximately dampened
to <span class="math">\(p=0\)</span> this far out in the wall layer.</p>
<p>There are two strategies for discretizing the <span class="math">\(\nabla^2 p_t\)</span> term: using
a center difference between times <span class="math">\(n+1\)</span> and <span class="math">\(n-1\)</span> (if the equation is
sampled at level <span class="math">\(n\)</span>), or use a one-sided difference based on levels <span class="math">\(n\)</span>
and <span class="math">\(n-1\)</span>. The latter has the advantage of not leading to any equation system,
while the former is second-order accurate as the scheme for the
simple wave equation <span class="math">\(p_tt = c^2\nabla^2 p\)</span>. To avoid an equation system,
go for the one-sided difference such that the overall scheme becomes
explicit and only of first order in time.</p>
<p>Develop a 3D solver for the specified PDE and introduce a wall layer.
Test the solver with the method of manufactured solutions. Make some
demonstrations where the wall reflects and absorbs the waves (reflection
because of discontinuity in <span class="math">\(b\)</span> and absorption because of growing <span class="math">\(b\)</span>).
Experiment with the impact of the <span class="math">\(\tau_s\)</span> parameter.
Filename: <tt class="docutils literal"><span class="pre">acoustics.py</span></tt>.</p>
</div>
<div class="section" id="project-30-solve-a-1d-transport-equation">
<span id="wave-app-exer-advec1d"></span><h2>Project 30: Solve a 1D transport equation<a class="headerlink" href="#project-30-solve-a-1d-transport-equation" title="Permalink to this headline">¶</a></h2>
<p>We shall study the wave equation</p>
<div class="math" id="equation-wave:app:exer:advec1D:ueq">
<span class="eqno">(104)</span>\[     u_t + cu_x = 0,\quad x\in (0,L],\ t\in (0, T],\]</div>
<p>with initial condition</p>
<div class="math">
\[u(x,0) = I(x),\quad x\in [0,L],\]</div>
<p>and <em>one</em> periodic boundary condition</p>
<div class="math">
\[u(0,t) = u(L,t)
\thinspace .\]</div>
<p>This boundary condition means that what goes out of the domain at <span class="math">\(x=L\)</span>
comes in at <span class="math">\(x=0\)</span>. Roughly speaking,
we need only one boundary condition because of
the spatial derivative is of first order only.</p>
<p><em>Physical interpretation.</em> The parameter <span class="math">\(c\)</span> can be constant or variable, <span class="math">\(c=c(x)\)</span>. The
equation <a href="#equation-wave:app:exer:advec1D:ueq">(104)</a> arises in <em>transport</em>
problems where a quantity <span class="math">\(u\)</span>, which could be temperature or
concentration of some contaminant, is transported with the velocity
<span class="math">\(c\)</span> of a fluid. In addition to the transport imposed by &#8220;travelling with
the fluid&#8221;, <span class="math">\(u\)</span> may also be transported by diffusion (such as
heat conduction or Fickian diffusion), but we have in
the model <span class="math">\(u_t + cu_x\)</span> assumed that diffusion effects are negligible,
which they often are.</p>
<p>A widely used numerical scheme for <a href="#equation-wave:app:exer:advec1D:ueq">(104)</a>
applies a forward difference in time and a backward difference in
space when <span class="math">\(c&gt;0\)</span>:</p>
<div class="math" id="equation-wave:app:exer:advec1D:u:upwind">
<span class="eqno">(105)</span>\[     [D_t^+ u + cD_x^-u = 0]_i^n\]\[     \thinspace .\]</div>
<p>For <span class="math">\(c&lt;0\)</span> we use a forward difference in space: <span class="math">\([cD_x^+u]_i^n\)</span>.</p>
<p>We shall hereafter assume that <span class="math">\(=c(x)&gt;0\)</span>.</p>
<p>To compute <a href="#equation-wave:app:exer:advec1D:u:avar:sol">(110)</a> we need to integrate
<span class="math">\(1/c\)</span> to obtain <span class="math">\(C\)</span> and then compute the inverse of <span class="math">\(C\)</span>.</p>
<p>The inverse function computation can be easily done if we first think
discretely. Say we have some function <span class="math">\(y=g(x)\)</span> and seeks its inverse.
Plotting <span class="math">\((x_i,y_i)\)</span>, where <span class="math">\(y_i=g(x_i)\)</span> for some mesh points <span class="math">\(x_i\)</span>,
displays <span class="math">\(g\)</span> as a function of <span class="math">\(x\)</span>.
The inverse function is simply <span class="math">\(x\)</span> as a function of <span class="math">\(g\)</span>, i.e., the
curve with points <span class="math">\((y_i,x_i)\)</span>. We can therefore quickly compute points
at the curve of the inverse function. One way of extending these
points to a continuous function is to assume a linear variation
(known as linear interpolation)
between the points (which actually means to draw straight lines between
the points, exactly as done by a plotting program).</p>
<p>The function <tt class="docutils literal"><span class="pre">wrap2callable</span></tt> in <tt class="docutils literal"><span class="pre">scitools.std</span></tt> can take a set of points
and return a continuous function that corresponds to linear
variation between the points. The computation of the inverse of a
function <span class="math">\(g\)</span> on <span class="math">\([0,L]\)</span> can then be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">101</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">resolution</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">wrap2callable</span>
    <span class="n">g_inverse</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">g_inverse</span>
</pre></div>
</div>
<p>To compute <span class="math">\(C(x)\)</span> we need to integrate <span class="math">\(1/c\)</span>, which can be done by
a Trapezoidal rule. Suppose we have computed <span class="math">\(C(x_i)\)</span> and need
to compute <span class="math">\(C(x_{i+1})\)</span>. Using the Trapezoidal rule with <span class="math">\(m\)</span> subintervals
over the integration domain <span class="math">\([x_i,x_{i+1}]\)</span> gives</p>
<div class="math" id="equation-wave:app:exer:advec1D:C:recursion">
<span class="eqno">(106)</span>\[     C(x_{i+1}) = C(x_i) + \int_{x_i}^{x_{i+1}} \frac{dx}{c}
     \approx h\left(
     \frac{1}{2}\frac{1}{c(x_i)} + \frac{1}{2}\frac{1}{c(x_{i+1})}
     + \sum_{j=1}^{m-1} \frac{1}{c(x_i + jh)}\right),\]</div>
<p>where <span class="math">\(h=(x_{i+1}-x_i)/m\)</span> is the length of the subintervals used
for the integral over <span class="math">\([x_i,x_{i+1}]\)</span>.
We observe that <a href="#equation-wave:app:exer:advec1D:C:recursion">(106)</a> is a
<em>difference equation</em> which we can solve by repeatedly
applying <a href="#equation-wave:app:exer:advec1D:C:recursion">(106)</a> for
<span class="math">\(i=0,1,\ldots,N_x-1\)</span> if a mesh <span class="math">\(x_0,x_,\ldots,x_{N_x}\)</span> is prescribed.
Note that <span class="math">\(C(0)=0\)</span>.</p>
<p><em>a)</em> Show that under the assumption of <span class="math">\(a=\hbox{const}\)</span>,</p>
<div class="math" id="equation-wave:app:exer:advec1D:uexact">
<span class="eqno">(107)</span>\[     u(x,t) = I(x - ct)\]</div>
<p>fulfills the PDE as well as the initial and boundary condition
(provided <span class="math">\(I(0)=I(L)\)</span>).</p>
<p><em>b)</em> Set up a computational algorithm and implement it in a function.
Assume <span class="math">\(a\)</span> is constant and positive.</p>
<p><em>c)</em> Test implementation by using the remarkable property that
the numerical solution is exact at the mesh points if
<span class="math">\(\Delta t = c^{-1}\Delta x\)</span>.</p>
<p><em>d)</em> Make a movie comparing the numerical and exact solution for the
following two choices of initial conditions:</p>
<div class="math" id="equation-wave:app:exer:advec1D:I:sin">
<span class="eqno">(108)</span>\[      I(x) = \left\lbrack\sin\left(\pi\frac{x}{L}\right)\right\rbrack^{2n}\]</div>
<p>where <span class="math">\(n\)</span> is an integer, typically <span class="math">\(n=5\)</span>,
and</p>
<div class="math" id="equation-wave:app:exer:advec1D:I:gauss">
<span class="eqno">(109)</span>\[     I(x) = \exp{\left( -\frac{(x-L/2)^2}{2\sigma2}\right)} \thinspace .\]</div>
<p>Choose <span class="math">\(\Delta t = c^{-1}\Delta x, 0.9c^{-1}\Delta x, 0.5c^{-1}\Delta x\)</span>.</p>
<p><em>e)</em> The performance of the suggested numerical scheme can be investigated
by analyzing the numerical dispersion relation.
Analytically, we have that the <em>Fourier component</em></p>
<div class="math">
\[u(x,t) = e^{i(kx-\omega t)},\]</div>
<p>is a solution of the PDE if <span class="math">\(\omega = kc\)</span>. This is the <em>analytical
dispersion relation</em>. A complete solution of the PDE can be built by
adding up such Fourier components with different amplitudes, where the
initial condition <span class="math">\(I\)</span> determines the amplitudes. The solution <span class="math">\(u\)</span> is
then represented by a Fourier series.</p>
<p>A similar discrete Fourier component at <span class="math">\((x_p,t_n)\)</span> is</p>
<div class="math">
\[u_p^q = e^{i(kp\Delta x -\tilde\omega n\Delta t)},\]</div>
<p>where in general <span class="math">\(\tilde\omega\)</span> is a function of <span class="math">\(k\)</span>, <span class="math">\(\Delta t\)</span>, and
<span class="math">\(\Delta x\)</span>, and differs from the exact <span class="math">\(\omega =kc\)</span>.</p>
<p>Insert the discrete Fourier component in the numerical scheme and
derive an expression for <span class="math">\(\tilde\omega\)</span>, i.e.,
the discrete dispersion relation. Show in particular that if
the <span class="math">\(\Delta t/(c\Delta x)=1\)</span>, the discrete solution coincides with the
exact solution at the mesh points, regardless of the mesh resolution (!).
Show that if the stability condition</p>
<div class="math">
\[\frac{\Delta t}{c\Delta x}\leq 1,\]</div>
<p>the discrete Fourier component cannot grow (i.e., <span class="math">\(\tilde\omega\)</span> is real).</p>
<p><em>f)</em> Write a test for your implementation where you try to use information
from the numerical dispersion relation.</p>
<p><em>g)</em> Set up a computational algorithm for the variable
coefficient case and implement it in a function.
Make a test that the function works for constant <span class="math">\(a\)</span>.</p>
<p><em>h)</em> It can be shown that
for an observer moving with velocity <span class="math">\(c(x)\)</span>, <span class="math">\(u\)</span> is constant.
This can be used to derive an exact solution when <span class="math">\(a\)</span> varies
with <span class="math">\(x\)</span>. Show first that</p>
<div class="math" id="equation-wave:app:exer:advec1D:u:avar:sol">
<span class="eqno">(110)</span>\[     u(x,t) = f(C(x) - t),\]</div>
<p>where</p>
<div class="math">
\[C'(x) = \frac{1}{c(x)},\]</div>
<p>is a solution of <a href="#equation-wave:app:exer:advec1D:ueq">(104)</a> for any
differentiable function <span class="math">\(f\)</span>.</p>
<p><em>Solution.</em> Let <span class="math">\(\xi = C(x) - t\)</span>.
We have that</p>
<div class="math">
\[u_t = f'(\xi)(-1),\]</div>
<p>while</p>
<div class="math">
\[u_x = f'(\xi)C'(x) = f'(\xi)\frac{1}{c(x)},\]</div>
<p>implying that <span class="math">\(au_x = f'(\xi)\)</span>. Then we have <span class="math">\(u_t + cu_x= -f'(\xi) +
f'(\xi) = 0\)</span>.</p>
<p><em>i)</em> Use the initial condition to show that an exact solution is</p>
<div class="math">
\[u(x,t) = I(C^{-1}(C(x)-t)),\]</div>
<p>with <span class="math">\(C^{-1}\)</span> being the inverse function of <span class="math">\(C = \int c^{1}dx\)</span>.
Since <span class="math">\(C(x)\)</span> is an integral <span class="math">\(\int_0^x (1/c)dx\)</span>,
<span class="math">\(C(x)\)</span> is monotonically increasing and there exists hence an
inverse function <span class="math">\(C^{-1}\)</span> with values in <span class="math">\([0,L]\)</span>.</p>
<p><em>Solution.</em> In general we have <span class="math">\(u(x,t) = f(C(x)-t)\)</span> and the solution is
of this form with <span class="math">\(f(\xi)=I(C^{-1}(\xi))\)</span>.
Moreover, at <span class="math">\(t=0\)</span> we have
<span class="math">\(I(C^{-1}(C(x)))=I(x)\)</span>, which is the required initial condition.</p>
<p><em>j)</em> Implement a function for computing <span class="math">\(C(x_i)\)</span> and one for computing
<span class="math">\(C^{-1}(x)\)</span> for any <span class="math">\(x\)</span>. Use these two functions for computing
the exact solution <span class="math">\(I(C^{-1}(C(x)-t))\)</span>.
End up with a function <tt class="docutils literal"><span class="pre">u_exact_variable_c(x,</span> <span class="pre">n,</span> <span class="pre">c,</span> <span class="pre">I)</span></tt> that returns
the value of <span class="math">\(I(C^{-1}(C(x)-t_n))\)</span>.</p>
<p><em>k)</em> Make movies showing a comparison of the numerical and exact solutions
for the two initial conditions
<a href="#equation-wave:app:exer:advec1D:I:sin">(108)</a> and <a href="#equation-wave:app:exer:advec1D:I:gauss">(109)</a>.
Choose <span class="math">\(\Delta t = \Delta x /\max_{0,L} c(x)\)</span>
and the velocity of the medium as</p>
<ol class="arabic simple">
<li><span class="math">\(c(x) = 1 + \epsilon\sin(k\pi x/L)\)</span>, <span class="math">\(\epsilon &lt;1\)</span>,</li>
<li><span class="math">\(c(x) = 1 + I(x)\)</span>, where <span class="math">\(I\)</span> is given by
<a href="#equation-wave:app:exer:advec1D:I:sin">(108)</a> or <a href="#equation-wave:app:exer:advec1D:I:gauss">(109)</a>.</li>
</ol>
<p>The PDE <span class="math">\(u_t + cu_x=0\)</span> expresses that the initial condition <span class="math">\(I(x)\)</span>
is transported with velocity <span class="math">\(c(x)\)</span>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">advec1D.py</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite difference methods for wave motion</a></li>
<li><a class="reference internal" href="#finite-difference-methods-for-waves-on-a-string">Finite difference methods for waves on a string</a><ul>
<li><a class="reference internal" href="#discretizing-the-domain">Discretizing the domain</a><ul>
<li><a class="reference internal" href="#uniform-meshes">Uniform meshes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-discrete-solution">The discrete solution</a></li>
<li><a class="reference internal" href="#fulfilling-the-equation-at-the-mesh-points">Fulfilling the equation at the mesh points</a></li>
<li><a class="reference internal" href="#replacing-derivatives-by-finite-differences">Replacing derivatives by finite differences</a><ul>
<li><a class="reference internal" href="#algebraic-version-of-the-pde">Algebraic version of the PDE</a></li>
<li><a class="reference internal" href="#algebraic-version-of-the-initial-conditions">Algebraic version of the initial conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#formulating-a-recursive-algorithm">Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#sketch-of-an-implementation">Sketch of an implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-1">Verification  (1)</a><ul>
<li><a class="reference internal" href="#a-slightly-generalized-model-problem">A slightly generalized model problem</a></li>
<li><a class="reference internal" href="#using-an-analytical-solution-of-physical-significance">Using an analytical solution of physical significance</a></li>
<li><a class="reference internal" href="#manufactured-solution">Manufactured solution</a></li>
<li><a class="reference internal" href="#constructing-an-exact-solution-of-the-discrete-equations">Constructing an exact solution of the discrete equations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-1">Implementation  (1)</a><ul>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a></li>
<li><a class="reference internal" href="#verification-exact-quadratic-solution">Verification: exact quadratic solution</a></li>
<li><a class="reference internal" href="#visualization-animating">Visualization: animating <span class="math">\(u(x,t)\)</span></a><ul>
<li><a class="reference internal" href="#visualization-via-scitools">Visualization via SciTools</a></li>
<li><a class="reference internal" href="#making-movie-files">Making movie files</a></li>
<li><a class="reference internal" href="#skipping-frames-for-animation-speed">Skipping frames for animation speed</a></li>
<li><a class="reference internal" href="#visualization-via-matplotlib">Visualization via Matplotlib</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-a-case">Running a case</a></li>
<li><a class="reference internal" href="#the-benefits-of-scaling">The benefits of scaling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vectorization">Vectorization</a><ul>
<li><a class="reference internal" href="#operations-on-slices-of-arrays">Operations on slices of arrays</a></li>
<li><a class="reference internal" href="#finite-difference-schemes-expressed-as-slices">Finite difference schemes expressed as slices</a></li>
<li><a class="reference internal" href="#verification-2">Verification  (2)</a></li>
<li><a class="reference internal" href="#efficiency-measurements">Efficiency measurements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-1">Exercises  (1)</a><ul>
<li><a class="reference internal" href="#exercise-1-simulate-a-standing-wave">Exercise 1: Simulate a standing wave</a></li>
<li><a class="reference internal" href="#exercise-2-add-storage-of-solution-in-a-user-action-function">Exercise 2: Add storage of solution in a user action function</a></li>
<li><a class="reference internal" href="#exercise-3-use-a-class-for-the-user-action-function">Exercise 3: Use a class for the user action function</a></li>
<li><a class="reference internal" href="#exercise-4-compare-several-courant-numbers-in-one-movie">Exercise 4: Compare several Courant numbers in one movie</a></li>
<li><a class="reference internal" href="#project-5-calculus-with-1d-mesh-functions">Project 5: Calculus with 1D mesh functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generalization-reflecting-boundaries">Generalization: reflecting boundaries</a><ul>
<li><a class="reference internal" href="#neumann-boundary-condition">Neumann boundary condition</a></li>
<li><a class="reference internal" href="#discretization-of-derivatives-at-the-boundary">Discretization of derivatives at the boundary</a></li>
<li><a class="reference internal" href="#implementation-of-neumann-conditions">Implementation of Neumann conditions</a></li>
<li><a class="reference internal" href="#index-set-notation">Index set notation</a></li>
<li><a class="reference internal" href="#alternative-implementation-via-ghost-cells">Alternative implementation via ghost cells</a><ul>
<li><a class="reference internal" href="#idea">Idea</a></li>
<li><a class="reference internal" href="#implementation-2">Implementation  (2)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#generalization-variable-wave-velocity">Generalization: variable wave velocity</a><ul>
<li><a class="reference internal" href="#the-model-pde-with-a-variable-coefficient">The model PDE with a variable coefficient</a></li>
<li><a class="reference internal" href="#discretizing-the-variable-coefficient">Discretizing the variable coefficient</a></li>
<li><a class="reference internal" href="#computing-the-coefficient-between-mesh-points">Computing the coefficient between mesh points</a></li>
<li><a class="reference internal" href="#how-a-variable-coefficient-affects-the-stability">How a variable coefficient affects the stability</a></li>
<li><a class="reference internal" href="#neumann-condition-and-a-variable-coefficient">Neumann condition and a variable coefficient</a></li>
<li><a class="reference internal" href="#implementation-of-variable-coefficients">Implementation of variable coefficients</a></li>
<li><a class="reference internal" href="#a-more-general-model-pde-with-variable-coefficients">A more general model PDE with variable coefficients</a></li>
<li><a class="reference internal" href="#generalization-damping">Generalization: damping</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-a-general-1d-wave-equation-solver">Building a general 1D wave equation solver</a><ul>
<li><a class="reference internal" href="#user-action-function-as-a-class">User action function as a class</a></li>
<li><a class="reference internal" href="#collection-of-initial-conditions">Collection of initial conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-2">Exercises  (2)</a><ul>
<li><a class="reference internal" href="#problem-6-explore-the-effect-of-boundary-conditions">Problem 6: Explore the effect of boundary conditions</a></li>
<li><a class="reference internal" href="#problem-7-explore-symmetry-boundary-conditions">Problem 7: Explore symmetry boundary conditions</a></li>
<li><a class="reference internal" href="#exercise-8-send-pulse-waves-through-a-layered-medium">Exercise 8: Send pulse waves through a layered medium</a></li>
<li><a class="reference internal" href="#exercise-9-compare-discretizations-of-a-neumann-condition">Exercise 9: Compare discretizations of a Neumann condition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-continuous-and-discrete-solutions">Analysis of the continuous and discrete solutions</a><ul>
<li><a class="reference internal" href="#properties-of-the-solution-of-the-wave-equation">Properties of the solution of the wave equation</a></li>
<li><a class="reference internal" href="#more-precise-definition-of-fourier-representations">More precise definition of Fourier representations</a></li>
<li><a class="reference internal" href="#analysis-of-the-finite-difference-scheme">Analysis of the finite difference scheme</a></li>
<li><a class="reference internal" href="#extending-the-analysis-to-2d-and-3d">Extending the analysis to 2D and 3D</a></li>
</ul>
</li>
<li><a class="reference internal" href="#finite-difference-methods-for-2d-and-3d-wave-equations">Finite difference methods for 2D and 3D wave equations</a><ul>
<li><a class="reference internal" href="#multi-dimensional-wave-equations">Multi-dimensional wave equations</a></li>
<li><a class="reference internal" href="#mesh">Mesh</a></li>
<li><a class="reference internal" href="#discretization">Discretization</a><ul>
<li><a class="reference internal" href="#discretizing-the-pdes">Discretizing the PDEs</a></li>
<li><a class="reference internal" href="#handling-boundary-conditions-where-is-known">Handling boundary conditions where is <span class="math">\(u\)</span> known</a></li>
<li><a class="reference internal" href="#discretizing-the">Discretizing the <span class="math">\(\partial u/\partial n = 0\)</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-3">Implementation  (3)</a><ul>
<li><a class="reference internal" href="#scalar-computations">Scalar computations</a><ul>
<li><a class="reference internal" href="#domain-and-mesh">Domain and mesh</a></li>
<li><a class="reference internal" href="#stability-limit">Stability limit</a></li>
<li><a class="reference internal" href="#solution-arrays">Solution arrays</a></li>
<li><a class="reference internal" href="#computing-the-solution">Computing the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vectorized-computations">Vectorized computations</a></li>
<li><a class="reference internal" href="#verification-3">Verification  (3)</a><ul>
<li><a class="reference internal" href="#testing-a-quadratic-solution">Testing a quadratic solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#migrating-loops-to-cython">Migrating loops to Cython</a><ul>
<li><a class="reference internal" href="#declaring-variables-and-annotating-the-code">Declaring variables and annotating the code</a></li>
<li><a class="reference internal" href="#visual-inspection-of-the-c-translation">Visual inspection of the C translation</a></li>
<li><a class="reference internal" href="#building-the-extension-module-1">Building the extension module  (1)</a></li>
<li><a class="reference internal" href="#calling-the-cython-function">Calling the Cython function</a></li>
<li><a class="reference internal" href="#efficiency-1">Efficiency  (1)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#migrating-loops-to-fortran">Migrating loops to Fortran</a><ul>
<li><a class="reference internal" href="#the-fortran-subroutine">The Fortran subroutine</a></li>
<li><a class="reference internal" href="#building-the-fortran-module-with-f2py">Building the Fortran module with f2py</a></li>
<li><a class="reference internal" href="#examining-doc-strings">Examining doc strings</a></li>
<li><a class="reference internal" href="#how-to-avoid-array-copying">How to avoid array copying</a></li>
<li><a class="reference internal" href="#efficiency-2">Efficiency  (2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#migrating-loops-to-c-via-cython">Migrating loops to C via Cython</a><ul>
<li><a class="reference internal" href="#translating-index-pairs-to-single-indices">Translating index pairs to single indices</a></li>
<li><a class="reference internal" href="#the-complete-c-code">The complete C code</a></li>
<li><a class="reference internal" href="#the-cython-interface-file">The Cython interface file</a></li>
<li><a class="reference internal" href="#building-the-extension-module-2">Building the extension module  (2)</a></li>
<li><a class="reference internal" href="#efficiency-3">Efficiency  (3)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#migrating-loops-to-c-via-f2py">Migrating loops to C via f2py</a></li>
<li><a class="reference internal" href="#migrating-loops-to-c-via-instant">Migrating loops to C via Instant</a></li>
<li><a class="reference internal" href="#id10">Migrating loops to C++ via f2py</a></li>
<li><a class="reference internal" href="#using-classes-to-implement-a-simulator">Using classes to implement a simulator</a></li>
<li><a class="reference internal" href="#callbacks-to-python-from-fortran-or-c">Callbacks to Python from Fortran or C</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises">Exercises</a><ul>
<li><a class="reference internal" href="#project-10-calculus-with-2d-3d-mesh-functions">Project 10: Calculus with 2D/3D mesh functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#applications-of-wave-equations">Applications of wave equations</a><ul>
<li><a class="reference internal" href="#waves-on-a-string">Waves on a string</a><ul>
<li><a class="reference internal" href="#damping">Damping</a></li>
<li><a class="reference internal" href="#external-forcing">External forcing</a></li>
<li><a class="reference internal" href="#modeling-the-tension-via-springs">Modeling the tension via springs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#waves-on-a-membrane">Waves on a membrane</a></li>
<li><a class="reference internal" href="#elastic-waves-in-a-rod">Elastic waves in a rod</a></li>
<li><a class="reference internal" href="#the-acoustic-model-for-seismic-waves">The acoustic model for seismic waves</a><ul>
<li><a class="reference internal" href="#anisotropy">Anisotropy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sound-waves-in-liquids-and-gases">Sound waves in liquids and gases</a></li>
<li><a class="reference internal" href="#spherical-waves">Spherical waves</a></li>
<li><a class="reference internal" href="#the-linear-shallow-water-equations">The linear shallow water equations</a><ul>
<li><a class="reference internal" href="#wind-drag-on-the-surface">Wind drag on the surface</a></li>
<li><a class="reference internal" href="#bottom-drag">Bottom drag</a></li>
<li><a class="reference internal" href="#effect-of-the-earth-s-rotation">Effect of the Earth&#8217;s rotation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#waves-in-blood-vessels">Waves in blood vessels</a><ul>
<li><a class="reference internal" href="#reduction-to-standard-wave-equation">Reduction to standard wave equation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#electromagnetic-waves">Electromagnetic waves</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-4">Exercises  (4)</a><ul>
<li><a class="reference internal" href="#exercise-11-simulate-waves-on-a-non-homogeneous-string">Exercise 11: Simulate waves on a non-homogeneous string</a></li>
<li><a class="reference internal" href="#exercise-12-simulate-damped-waves-on-a-string">Exercise 12: Simulate damped waves on a string</a></li>
<li><a class="reference internal" href="#exercise-13-simulate-elastic-waves-in-a-rod">Exercise 13: Simulate elastic waves in a rod</a></li>
<li><a class="reference internal" href="#exercise-14-explain-why-numerical-noise-occurs">Exercise 14: Explain why numerical noise occurs</a></li>
<li><a class="reference internal" href="#exercise-15-investigate-harmonic-averaging-in-a-1d-model">Exercise 15: Investigate harmonic averaging in a 1D model</a></li>
<li><a class="reference internal" href="#exercise-16-test-the-efficiency-of-compiled-loops-in-3d">Exercise 16: Test the efficiency of compiled loops in 3D</a></li>
<li><a class="reference internal" href="#exercise-17-earthquake-generated-tsunami-in-a-1d-model">Exercise 17: Earthquake-generated tsunami in a 1D model</a></li>
<li><a class="reference internal" href="#exercise-18-implement-an-open-boundary-condition">Exercise 18: Implement an open boundary condition</a></li>
<li><a class="reference internal" href="#exercise-19-earthquake-generated-tsunami-over-a-subsea-hill">Exercise 19: Earthquake-generated tsunami over a subsea hill</a></li>
<li><a class="reference internal" href="#exercise-20-implement-neumann-conditions-in-2d">Exercise 20: Implement Neumann conditions in 2D</a></li>
<li><a class="reference internal" href="#exercise-21-implement-a-convergence-test-for-a-2d-code">Exercise 21: Implement a convergence test for a 2D code</a></li>
<li><a class="reference internal" href="#exercise-22-earthquake-generated-tsunami-over-a-3d-hill">Exercise 22: Earthquake-generated tsunami over a 3D hill</a></li>
<li><a class="reference internal" href="#exercise-23-implement-loops-in-compiled-languages">Exercise 23: Implement loops in compiled languages</a></li>
<li><a class="reference internal" href="#exercise-24-write-a-complete-program-in-fortran-or-c">Exercise 24: Write a complete program in Fortran or C</a></li>
<li><a class="reference internal" href="#exercise-25-investigate-matplotlib-for-visualization">Exercise 25: Investigate Matplotlib for visualization</a></li>
<li><a class="reference internal" href="#exercise-26-investigate-visualization-packages">Exercise 26: Investigate visualization packages</a></li>
<li><a class="reference internal" href="#exercise-27-investigate-harmonic-vs-arithmetic-mean">Exercise 27: Investigate harmonic vs arithmetic mean</a></li>
<li><a class="reference internal" href="#exercise-28-simulate-seismic-waves-in-2d">Exercise 28: Simulate seismic waves in 2D</a></li>
<li><a class="reference internal" href="#project-29-modeling-3d-acoustic-waves-in-a-room">Project 29: Modeling 3D acoustic waves in a room</a></li>
<li><a class="reference internal" href="#project-30-solve-a-1d-transport-equation">Project 30: Solve a 1D transport equation</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/main_wave.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">Finite difference methods for wave motion</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>