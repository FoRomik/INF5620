.. Automatically generated reST file from Doconce source
   (https://github.com/hplgit/doconce/)

Finite difference methods for wave motion
=========================================

:Author: Hans Petter Langtangen
:Date: Sep 25, 2013

This is still a **preliminary version**.






.. Externaldocuments: ../decay/main_decay, ../bin/main_vib





.. !split



A very wide range of physical processes lead to wave motion, where
signals are propagated through a medium in space and time, normally
with little or no permanent movement of the medium itself.
The shape of the signals may undergo changes as they travel through
matter, but usually not so much that the signals cannot be recognized
at some later point in space and time.
Many types of wave motion can be described by the equation
:math:`u_{tt}=\nabla\cdot (c^2\nabla u) + f`, which we will solve
in the forthcoming text by finite difference methods.

.. _wave:string:

Simulation of waves on a string
===============================

.. index::
   single: waves; on a string


.. index::
   single: wave equation; 1D


We begin our study of wave equations by simulating one-dimensional
waves on a string, say on a guitar or violin string.
Let the string in the deformed state
coincide with the interval
:math:`[0,L]` on the :math:`x` axis, and let :math:`u(x,t)` be the displacement at
time :math:`t` in the :math:`y` direction of a point initially at :math:`x`.
The displacement function :math:`u` is governed by the mathematical model


.. math::
   :label: wave:pde1
        
        \frac{\partial^2 u}{\partial t^2} =
        c^2 \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]
        
        



.. math::
   :label: wave:pde1:ic:u
          
        u(x,0) = I(x), \quad x\in [0,L]
        
        



.. math::
   :label: wave:pde1:ic:ut
          
        \frac{\partial}{\partial t}u(x,0) = 0, \quad x\in [0,L]
        
        



.. math::
   :label: wave:pde1:bc:0
          
        u(0,t)  = 0, \quad  t\in (0,T]
        
        



.. math::
   :label: wave:pde1:bc:L
          
        u(L,t)  = 0, \quad  t\in (0,T]
        
        

The constant :math:`c` and the function :math:`I(x)` must be prescribed.

Equation :eq:`wave:pde1` is known as the one-dimensional
*wave equation*. Since this PDE contains a second-order derivative
in time, we need *two initial conditions*, here :eq:`wave:pde1:ic:u`
specifying the initial shape of the string, :math:`I(x)`, and
:eq:`wave:pde1:ic:ut` reflecting that the initial velocity of the
string is zero. In addition, PDEs need *boundary conditions*, here
:eq:`wave:pde1:bc:0` and :eq:`wave:pde1:bc:L`, specifying that
the string is fixed at the ends, i.e., that the displacement :math:`u` is zero.

The solution :math:`u(x,t)` varies in space and time and describes waves that
are moving with velocity :math:`c` to the left and right.

.. raw:: html
        
        <div>
        <video  loop controls width='640' height='365' preload='none'>
        <source src='mov-wave/guitar_C0.8/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
        <source src='mov-wave/guitar_C0.8/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
        </video>
        </div>
        <p><em>Example of waves on a string.</em></p>



Sometimes we will use a more compact notation for the partial derivatives
to save space:


.. math::
        
        u_t = \frac{\partial u}{\partial t}, \quad
        u_{tt} = \frac{\partial^2 u}{\partial t^2},
        

and similar expressions
for derivatives with respect to other variables. Then the
wave equation can be written compactly as :math:`u_{tt} = c^2u_{xx}`.



.. index::
   single: wave equation; 1D, finite difference method


The PDE problem :eq:`wave:pde1`-:eq:`wave:pde1:bc:L` will now be
discretized in space and time by a finite difference method.


.. index::
   single: mesh; finite differences


.. _wave:string:mesh:

Discretizing the domain
-----------------------

The temporal domain :math:`[0,T]` is represented by a finite number of mesh points


.. math::
        
        0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T \thinspace . 

Similarly, the spatial domain :math:`[0,L]` is replaced by a set of mesh points


.. math::
        
        0 = x_0 < x_1 < x_2 < \cdots < x_{N_x-1} < x_{N_x} = L \thinspace . 

One may view the mesh as two-dimensional in the :math:`x,t` plane, consisting
of points :math:`(x_i, t_n)`, with :math:`i=0,\ldots,N_x` and :math:`n=0,\ldots,N_t`.



Uniform meshes
~~~~~~~~~~~~~~

For uniformly distributed mesh points we can introduce the constant
mesh spacings :math:`\Delta t` and :math:`\Delta x`. We have that


.. math::
        
        x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
        t_i = n\Delta t,\ n=0,\ldots,N_t{\thinspace .}
        

We also have that :math:`\Delta x = x_i-x_{i-1}`, :math:`i=1,\ldots,N_x`, and
:math:`\Delta t = t_n - t_{n-1}`, :math:`n=1,\ldots,N_t`. Figure :ref:`wave:pde1:fig:mesh`
displays a mesh in the :math:`x,t` plane with :math:`N_t=5`, :math:`N_x=5`, and constant
mesh spacings.

.. _wave:string:numerical:sol:

The discrete solution
---------------------


.. index::
   single: stencil; 1D wave equation


.. index:: mesh function


The solution :math:`u(x,t)` is sought at the mesh points. We introduce
the mesh function :math:`u_i^n`, which approximates the exact
solution at the
mesh point :math:`(x_i,t_n)` for :math:`i=0,\ldots,N_x` and :math:`n=0,\ldots,N_t`.
Using the finite difference method, we shall
develop algebraic equations for computing the mesh function.
The circles in Figure
:ref:`wave:pde1:fig:mesh` illustrate neighboring mesh points where
values of :math:`u^n_i` are connected through an algebraic equation. In this
particular case, :math:`u_2^1`, :math:`u_1^2`, :math:`u_2^2`, :math:`u_3^2`, and :math:`u_2^3` are
connected in an algebraic equation associated with the center point
:math:`(2,2)`. The term *stencil* is often used about the algebraic equation
at a mesh point, and the geometry of a typical stencil is
illustrated in Figure :ref:`wave:pde1:fig:mesh`. One also often refers
to the algebraic equations as *discrete equations*,
*(finite) difference equations* or a *finite difference
scheme*.


.. _wave:pde1:fig:mesh:

.. figure:: wave_PDE_Dirichlet_n_interior.png
   :width: 500

   *Mesh in space and time for a 1D wave equation*



.. _wave:string:samplingPDE:

Fulfilling the equation at the mesh points
------------------------------------------

For a numerical solution by the finite difference method, we relax
the condition that :eq:`wave:pde1` holds at all points in
the space-time domain :math:`(0,L)\times (0,T]` to the requirement that the PDE is
fulfilled at the *interior* mesh points:


.. math::
   :label: wave:pde1:step2
        
        \frac{\partial^2}{\partial t^2} u(x_i, t_n) =
        c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),
        
        

for :math:`i=1,\ldots,N_x-1` and :math:`n=1,\ldots,N_t-1`. For :math:`n=0` we have
the initial conditions :math:`u=I(x)` and :math:`u_t=0`,
and at the boundaries :math:`i=0,N_x` we
have the boundary condition :math:`u=0`.

.. _wave:string:fd:

Replacing derivatives by finite differences
-------------------------------------------

The second-order derivatives can be replaced by central
differences. The most widely used difference approximation of
the second-order derivative is


.. math::
         \frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
        \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}

It is convenient to introduce the finite difference operator notation


.. math::
         [D_tD_t u]^n_i = \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}
        A similar approximation of the second-order derivative in the $x$
        direction reads
        !bt
         \frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
        \frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
        \thinspace .
        


Algebraic version of the PDE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can now replace the derivatives in :eq:`wave:pde1:step2`
and get


.. math::
   :label: wave:pde1:step3b
        
        \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
        c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},
        
        

or written more compactly using the operator notation:


.. math::
   :label: wave:pde1:step3a
        
        [D_tD_t u = c^2 D_xD_x]^{n}_i
        \thinspace .
        
        


Algebraic version of the initial conditions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We also need to replace the derivative in the initial condition
:eq:`wave:pde1:ic:ut` by a finite difference approximation.
A centered difference of the type

.. math::
        
        \frac{\partial}{\partial t} u(x_i,t_n)\approx
        \frac{u^1_i - u^{-1}_i}{2\Delta t} = [D_{2t} u]^0_i,
        

seems appropriate. In operator notation the initial condition is
written as

.. math::
         [D_{2t} u]^n_i = 0,\quad n=0 \thinspace . 

Writing out this equation and ordering the terms give

.. math::
   :label: wave:pde1:step3c
        
        u^{n-1}_i=u^{n+1}_i,\quad i=0,\ldots,N_x,\ n=0\thinspace .
        
        

The other initial condition can be computed by


.. math::
         u_i^0 = I(x_i),\quad i=0,\ldots,N_x{\thinspace .}



.. _wave:string:alg:

Formulating a recursive algorithm
---------------------------------

We assume that :math:`u^n_i` and
:math:`u^{n-1}_i` are already computed for :math:`i=0,\ldots,N_x`.
The only unknown quantity in :eq:`wave:pde1:step3b` is
therefore :math:`u^{n+1}_i`, which we can solve for:


.. math::
   :label: wave:pde1:step4
        
        u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
        \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),
        
        

where we have introduced the parameter

.. math::
        
        C = c\frac{\Delta t}{\Delta x},
        

known as the (dimensionless) *Courant number*. We see that the
discrete version of the PDE features only one parameter, :math:`C`,
which is therefore the key parameter that governs the
quality of the numerical solution. Both the primary
physical parameter :math:`c` and the numerical parameters :math:`\Delta x` and :math:`\Delta t`
are lumped together in :math:`C`.

Given that :math:`u^{n-1}_i` and :math:`u^n_i` are computed for :math:`i=0,\ldots,N_x`,
we find new values at the next time level by applying the formula
:eq:`wave:pde1:step4` for :math:`i=1,\ldots,N_x-1`. Figure
:ref:`wave:pde1:fig:mesh` illustrates the points that are used to
compute :math:`u^3_2`. For the boundary points, :math:`i=0` and :math:`i=N_x`, we apply
the boundary conditions :math:`u_i^{n+1}=0`.


A problem with :eq:`wave:pde1:step4` arises when :math:`n=0` since the
formula for :math:`u^1_i` involves :math:`u^{-1}_i`, which is an undefined
quantity outside the time mesh (and the time domain). However, we can
use the initial condition :eq:`wave:pde1:step3c` in combination with
:eq:`wave:pde1:step4` when :math:`n=0` to arrive at a special formula for
:math:`u_i^1`:


.. math::
   :label: wave:pde1:step4:1
        
        u_i^1 = u^0_i - \frac{1}{2}
        C^2\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right)
        \thinspace .
        
        

Figure :ref:`wave:pde1:fig:stencil:u1` illustrates how :eq:`wave:pde1:step4:1`
connects four instead of five points: :math:`u^1_2`, :math:`u_1^0`, :math:`u_2^0`, and :math:`u_3^0`.


.. _wave:pde1:fig:stencil:u1:

.. figure:: wave_PDE_Dirichlet_n0_interior.png
   :width: 500

   *Modified stencil for the first time step*


We can now summarize the computational algorithm:

1. Compute :math:`u^0_i=I(x_i)` for :math:`i=0,\ldots,N_x`

2. Compute :math:`u^1_i` by :eq:`wave:pde1:step4:1` and set :math:`u_i^1=0`
   for the boundary points :math:`i=0` and :math:`i=N_x`, for :math:`n=1,2,\ldots,N-1`,

3. For each time level :math:`n=1,2,\ldots,N_t-1`

  1. apply :eq:`wave:pde1:step4` to find :math:`u^{n+1}_i` for :math:`i=1,\ldots,N_x-1`

  2. set :math:`u^{n+1}_i=0` for the boundary points :math:`i=0`, :math:`i=N_x`.


The algorithm essentially consists of moving
a finite difference stencil through all the mesh points, which is
illustrated by an animation in a `web page <http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/index.html>`_
or a `movie file <http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.flv>`_.


.. _wave:string:impl:

Sketch of an implementation
---------------------------

In a Python implementation of this algorithm, we use the array
elements ``u[i]`` to store :math:`u^{n+1}_i`, ``u_1[i]`` to store :math:`u^n_i`, and
``u_2[i]`` to store :math:`u^{n-1}_i`. Our naming convention is use ``u`` for the
unknown new spatial field to be computed, ``u_1`` as the solution at
one time step back in time, ``u_2`` as the solution two time steps back
in time and so forth.

The algorithm only needs to access the
three most recent time levels, so we need only three arrays for
:math:`u_i^{n+1}`, :math:`u_i^n`, and :math:`u_i^{n-1}`, :math:`i=0,\ldots,N_x`.  Storing all
the solutions in a two-dimensional array of size :math:`(N_x+1)\times (N_t+1)`
would be possible in this simple one-dimensional PDE problem, but is
normally out of the question in three-dimensional (3D) and large
two-dimensional (2D) problems. We shall therefore in all our programs
for solving PDEs have the unknown in memory at as few time levels as
possible.

The following Python snippet realizes the steps in the computational
algorithm.


.. code-block:: python

        # Given mesh points as arrays x and t (x[i], t[n])
        dx = x[1] - x[0]
        dt = t[1] - t[0]
        C = c*dt/dx            # Courant number
        Nt = len(t)-1
        C2 = C**2              # Help variable in the scheme
        
        # Set initial condition u(x,0) = I(x)
        for i in range(0, Nx+1):
            u_1[i] = I(x[i])
        
        # Apply special formula for first step, incorporating du/dt=0
        for i in range(1, Nx):
            u[i] = u_1[i] - 0.5*C**2(u_1[i+1] - 2*u_1[i] + u_1[i-1])
        u[0] = 0;  u[Nx] = 0   # Enforce boundary conditions
        
        # Switch variables before next step
        u_2[:], u_1[:] = u_1, u
        
        for n in range(1, Nt):
            # Update all inner mesh points at time t[n+1]
            for i in range(1, Nx):
                u[i] = 2u_1[i] - u_2[i] - \ 
                       C**2(u_1[i+1] - 2*u_1[i] + u_1[i-1])
        
            # Insert boundary conditions
            u[0] = 0;  u[Nx] = 0
        
            # Switch variables before next step
            u_2[:], u_1[:] = u_1, u


Verification  (1)
=================

Before implementing the algorithm, it is convenient to add a source
term to the PDE :eq:`wave:pde1`
since it gives us more freedom in finding test problems for
verification. In particular, the source term allows us to use
*manufactured solutions* for software testing, where we simply choose some
function as solution, fit the corresponding source term, and define
boundary and initial conditions consistent with the chosen
solution. Such solutions
will seldom fulfill the initial condition :eq:`wave:pde1:ic:ut` so
we need to generalize this condition to :math:`u_t=V(x)`.

.. _wave:pde2:fd:

A slightly generalized model problem
------------------------------------

We now address the following extended initial-boundary value problem
for one-dimensional wave phenomena:


.. math::
   :label: wave:pde2
        
        u_{tt} = c^2 u_{xx} + f(x,t), \quad x\in (0,L),\ t\in (0,T]
        
        



.. math::
   :label: wave:pde2:ic:u
          
        u(x,0) = I(x), \quad x\in [0,L]
        
        



.. math::
   :label: wave:pde2:ic:ut
          
        u_t(x,0) = V(x), \quad x\in [0,L]
        
        



.. math::
   :label: wave:pde2:bc:0
          
        u(0,t)  = 0, \quad  t>0
        
        



.. math::
   :label: wave:pde2:bc:L
          
        u(L,t)  = 0, \quad  t>0
        
        



Sampling the PDE at :math:`(x_i,t_n)` and using the same finite difference
approximations as above, yields


.. math::
   :label: wave:pde2:fdop
        
        [D_tD_t u = c^2 D_xD_x + f]^{n}_i
        \thinspace .
        
        

Writing this out and solving for the unknown :math:`u^{n+1}_i` results in


.. math::
   :label: wave:pde2:step3b
        
        u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
        (u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i
        
        \thinspace .
        


The equation for the first time step must be rederived. The discretization
of the initial condition :math:`u_t = V(x)` at :math:`t=0`
becomes


.. math::
         [D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,

which, when inserted in :eq:`wave:pde2:step3b` for :math:`n=0`, gives
the special formula


.. math::
   :label: wave:pde2:step3c
        
        u^{1}_i = u^0_i - \Delta t V_i + \frac{1}{2}
        C^2
        \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \frac{1}{2}\Delta t^2 f^n_i
        
        \thinspace .
        


.. _wave:pde2:fd:standing:waves:

Using an analytical solution of physical significance
-----------------------------------------------------

Many wave problems feature sinusoidal oscillations in time
and space. For example, the original PDE problem
:eq:`wave:pde1`-:eq:`wave:pde1:bc:L` allows a solution


.. math::
   :label: wave:pde2:test:ue
        
        {u_{\small\mbox{e}}}(x,y,t)) = A\sin\left(\frac{\pi}{L}x\right)
        \cos\left(\frac{\pi}{L}ct\right){\thinspace .}
        
        

This :math:`{u_{\small\mbox{e}}}` fulfills the PDE with :math:`f=0`, boundary conditions
:math:`{u_{\small\mbox{e}}}(0,t)={u_{\small\mbox{e}}}(L,0)=0`, as well as initial
conditions :math:`I(x)=A\sin\left(\frac{\pi}{L}x\right)` and :math:`V=0`.

It is common to use such exact solutions of physical interest
to verify implementations. However, the numerical
solution :math:`u^n_i` will only be an approximation to :math:`{u_{\small\mbox{e}}}(x_i,t_n)`.
We no have knowledge of the precise size of the error in
this approximation, and therefore we can never know if discrepancies
between the computed :math:`u^n_i` and :math:`{u_{\small\mbox{e}}}(x_i,t_n)` are caused
by mathematical approximations or programming errors.
In particular, if a plot of the computed solution :math:`u^n_i` and
the exact one \eq:ref:`wave:pde2:test:ue` looks similar, many
are attempted to claim that the implementation works, but
there can still be serious programming errors although color
plots look nice.

The only way to use exact physical solutions like
:eq:`wave:pde2:test:ue` for serious and thorough verification is to
run a series of finer and finer meshes, measure the integrated error
in each mesh, and from this information estimate the convergence
rate. If these rates are very close to 2, we have strong evidence that
the implementation works.

.. _wave:pde2:fd:MMS:

Manufactured solution
---------------------

One problem with the exact solution :eq:`wave:pde2:test:ue` is
that it requires a simplification (:math:`V=0, f=0`) of the implemented problem
:eq:`wave:pde2`-:eq:`wave:pde2:bc:L`. An advantage of using
a manufactured solution is that we can test all terms in the
PDE problem. The idea of this approach is to set up some chosen
solution and fit the source term, boundary conditions, and initial
conditions to be compatible with the chosen solution.
Given that our boundary conditions in the implementation are
:math:`u(0,t)=u(L,t)=0`, we must choose a solution that fulfills these
conditions. One example is


.. math::
         {u_{\small\mbox{e}}}(x,t) = x(L-x)\sin t{\thinspace .}

Inserted in the PDE :math:`u_{tt}=c^2u_{xx}+f` we get


.. math::
         -x(L-x)\sin t = -2\sin t + f\quad\Rightarrow f = (2 - x(L-x))\sin t{\thinspace .}

The initial conditions become


.. math::
        
        u(x,0) =& I(x) = 0,\\ 
        u_t(x,0) &= V(x) = (2 - x(L-x))\cos t{\thinspace .}
        


To verify the code, we run a series of refined meshes and compute
the convergence rates. In more detail, we keep :math:`\Delta t/\Delta x`
constant for each mesh, implying that :math:`C` is also constant throughout
the experiments. A common discretization parameter
:math:`h = \Delta t` is introduced. For a given :math:`C` (and :math:`c`), :math:`\Delta x
ch/C`. We choose an initial time cell size :math:`h_0` and run
experiments with decreasing :math:`h`: :math:`h_i=2^{-i}h_0`, :math:`i=1,2,\ldots,m`.
Halving the cell size in each experiment is not necessary, but common.
For each experiment we must record a scalar measure of the error.
As will be shown later, it is expected that such error measures
are proportional to :math:`h^2`.
A standard choice of error measure
is the :math:`\ell^2` or :math:`\ell^\infty` norm of
the error mesh function :math:`e^n_i`:


.. math::
        
        ||e^n_i||_{\ell^2} = \left( \Delta t\Delta x\sum_{n=0}^{N_t}\sum_{i=0}^{N_x}
        (e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,
        
        



.. math::
          
        ||e^n_i||_{\ell^\infty} = \max_{i,n} |e^i_n|{\thinspace .}
        

In Python, one can compute :math:`\sum_{i}(e^{n+1}_i)^2` at each time step
and accumulate the value in some sum variable, say ``e2_sum``.  At the
final time step one can do ``sqrt(dt*dx*e2_sum)``.  For the
:math:`\ell^\infty` norm one must compare the maximum error at a time level
(``e.max()``) with the global maximum over the time domain: ``e_max =
max(e_max, e.max())``.

An alternative error measure
is to use a spatial norm at one time step only, e.g.,
the end time :math:`T`:


.. math::
        
        ||e^n_i||_{\ell^2} = \left( \Delta x\sum_{i=0}^{N_x}
        (e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,
        
        



.. math::
          
        ||e^n_i||_{\ell^\infty} = \max_{0\leq i\leq N_x} |e^i_{n}|{\thinspace .}
        


Let :math:`E_i` be the error measure in experiment (mesh) number :math:`i` and
let :math:`h_i` be the corresponding discretization parameter (:math:`h`).
We expect an error model :math:`E_i = Ch_i^r`, here with :math:`r=0`. To
estimate :math:`r`, we can compare two consecutive
experiments and compute


.. math::
         r_i = \frac{\ln E_{i+1}/E_{i}}{\ln h_{i+1}/h_{i}},\quad i=0,\ldots,m-1{\thinspace .}
        

We should observe that :math:`r_i` approaches :math:`2` as :math:`i` increases.

The next section describes a method of manufactured solutions where
do not need to compute error measures and check that they converge
as expected as the mesh is refined.

.. _wave:pde2:fd:verify:quadratic:

Constructing an exact solution of the discrete equations
--------------------------------------------------------

For verification purposes we shall use a solution that is quadratic in space
and linear in time. More specifically, our choice of the manufactured
solution is

.. math::
   :label: wave:pde2:fd:verify:quadratic:uex
        
        {u_{\small\mbox{e}}} (x,t) = x(L-x)(1+\frac{1}{2}t),
        
        

which by insertion in the PDE leads to :math:`f(x,t)=2(1+t)c^2`. This :math:`{u_{\small\mbox{e}}}`
fulfills the boundary conditions and is compatible with :math:`I(x)=x(L-x)`
and :math:`V(x)=\frac{1}{2}x(L-x)`.

A key feature of the chosen :math:`{u_{\small\mbox{e}}}` is that it is also *an exact
solution of the discrete equations*. To realize this very important
result, we first establish the results

.. math::
        
        \lbrack D_tD_t t^2\rbrack^n = \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
        = (n+1)^2 -n^2 + (n-1)^2 = 2,
        



.. math::
          
        \lbrack D_tD_t t\rbrack^n = \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
        = \frac{((n+1) -n + (n-1))\Delta t}{\Delta t^2} = 0
        \thinspace .
        

Hence,

.. math::
         [D_tD_t {u_{\small\mbox{e}}}]^n_i = x_i(L-x_i)[D_tD_t (1+\frac{1}{2}t)]^n =
        x_i(L-x_i)\frac{1}{2}[D_tD_t t]^n = 0,

and

.. math::
        
        \lbrack D_xD_x {u_{\small\mbox{e}}}\rbrack^n_i &=
        (1+\frac{1}{2}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i =
        (1+\frac{1}{2}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\ 
        &= -2(1+\frac{1}{2}t_n)
        \thinspace .
        

Now, :math:`f^n_i = 2(1+\frac{1}{2}t_n)c^2` and we get


.. math::
         [D_tD_t {u_{\small\mbox{e}}} - c^2D_xD_x{u_{\small\mbox{e}}} - f]^n_i = 0 - c^2(-1)2(1 + \frac{1}{2}t_n
        + 2(1+\frac{1}{2}t_n)c^2 = 0{\thinspace .}


Moreover, :math:`{u_{\small\mbox{e}}}(x_i,0)=I(x_i)`,
:math:`\partial {u_{\small\mbox{e}}}/\partial t = V(x_i)` at :math:`t=0`, and
:math:`{u_{\small\mbox{e}}}(x_0,t)={u_{\small\mbox{e}}}(x_{N_x},0)=0`. Also the modified scheme for the
first time step is fulfilled by :math:`{u_{\small\mbox{e}}}(x_i,t_n)`.

Therefore, the exact solution :math:`{u_{\small\mbox{e}}}(x,t)=x(L-x)(1+t/2)`
of the PDE problem is also an exact solution of the discrete problem.
We can use this result to check that the computed :math:`u^n_i` vales from
an implementation equals :math:`{u_{\small\mbox{e}}}(x_i,t_n)` within machine precision,
*regardless of the mesh spacings* :math:`\Delta x` and :math:`\Delta t`!
Nevertheless, there might be stability
restrictions on :math:`\Delta x` and :math:`\Delta t`, so the test can only be
run for a mesh that is compatible with the stability criterion (which
in the present case is :math:`C\leq 1`, to be derived later).



.. note::
   A product of quadratic or linear expressions in the various
   independent variables, as shown above, will often fulfill both the
   continuous and discrete PDE problem and can therefore be very useful
   solutions for verifying implementations.  However, for 1D wave
   equations of the type :math:`u_t=c^2u_{xx}` we shall see that there is always
   another much more powerful way of generating exact
   solutions (just set :math:`C=1`).


.. !split

.. _wave:pde1:impl:

Implementation  (1)
===================

.. index::
   single: wave equation; 1D, implementation


This section present the complete computational algorithm, its
implementation in Python code, animation of the solution,
and verification of the implementation.

A real implementation of the basic computational algorithm
from the sections :ref:`wave:string:alg` and :ref:`wave:string:impl` can be
encapsulated in a function,
taking all the input data for the problem as arguments.  The physical
input data consists of :math:`c`, :math:`I(x)`, :math:`V(x)`, :math:`f(x,t)`, :math:`L`, and :math:`T`.
The numerical input is the mesh parameters :math:`\Delta t` and :math:`\Delta x`.
One possibility is to specify :math:`N_x` and the Courant number :math:`C=c\Delta
t/\Delta x`.  The latter is convenient to prescribe instead of :math:`\Delta
t` when performing numerical investigations, because the numerical
accuracy depends directly on :math:`C`.

The solution at all spatial points at a new time level is stored in an
array ``u`` (of length :math:`N_x+1`). We need to decide what do to with
this solution, e.g., visualize the curve, analyze the values, or write
the array to file for later use. The decision what to do is left to
the user in a suppled function

.. code-block:: python

        def user_action(u, x, t, n):

where ``u`` is the solution at the spatial points ``x`` at time ``t[n]``.

.. _wave:pde1:impl:solver:

Making a solver function
------------------------

A first attempt at a solver function is listed below.


.. code-block:: python

        from numpy import *
        
        def solver(I, V, f, c, L, Nx, C, T, user_action=None):
            """Solve u_tt=c^2*u_xx + f on (0,L)x(0,T]."""
            x = linspace(0, L, Nx+1)     # Mesh points in space
            dx = x[1] - x[0]
            dt = C*dx/c
            Nt = int(round(T/dt))
            t = linspace(0, Nt*dt, Nt+1) # Mesh points in time
            C2 = C**2                    # Help variable in the scheme
            if f is None or f == 0 :
                f = lambda x, t: 0
            if V is None or V == 0:
                V = lambda x: 0
        
            u   = zeros(Nx+1)   # Solution array at new time level
            u_1 = zeros(Nx+1)   # Solution at 1 time level back
            u_2 = zeros(Nx+1)   # Solution at 2 time levels back
        
            import time;  t0 = time.clock()  # for measuring CPU time
        
            # Load initial condition into u_1
            for i in range(0,Nx+1):
                u_1[i] = I(x[i])
        
            if user_action is not None:
                user_action(u_1, x, t, 0)
        
            # Special formula for first time step
            n = 0
            for i in range(1, Nx):
                u[i] = u_1[i] + dt*V(x[i]) + \ 
                       0.5*C2*(u_1[i-1] - 2*u_1[i] + u_1[i+1]) + \ 
                       0.5*dt**2*f(x[i], t[n])
            u[0] = 0;  u[Nx] = 0
        
            if user_action is not None:
                user_action(u, x, t, 1)
        
            # Switch variables before next step
            u_2[:], u_1[:] = u_1, u
        
            for n in range(1, Nt):
                # Update all inner points at time t[n+1]
                for i in range(1, Nx):
                    u[i] = - u_2[i] + 2*u_1[i] + \ 
                             C2*(u_1[i-1] - 2*u_1[i] + u_1[i+1]) + \ 
                             dt**2*f(x[i], t[n])
        
                # Insert boundary conditions
                u[0] = 0;  u[Nx] = 0
                if user_action is not None:
                    if user_action(u, x, t, n+1):
                        break
        
                # Switch variables before next step
                u_2[:], u_1[:] = u_1, u
        
            cpu_time = t0 - time.clock()
            return u, x, t, cpu_time



.. Too trivial here:

.. Checking that a solution :math:`u^n_i` stays constant throughout some

.. time steps is often of considerable help in tracking down bugs

.. in an implementation. A constant solution :math:`{u_{\small\mbox{e}}} = Q` fulfills

.. the PDE problem :eq:`wave:pde2`-:eq:`wave:pde2:bc:L`

.. if :math:`I(x)=Q`, :math:`V=0`, :math:`u(0,t)=u(L,t)=Q`, and :math:`f=0`


.. _wave:pde1:impl:verify:quadratic:

Verification: exact quadratic solution
--------------------------------------


.. index:: nose tests


.. index:: unit testing


.. index::
   single: software testing; nose


We use the test problem derived in the section :ref:`wave:pde2:fd` for
verification. Here is a function realizing this verification as a
.. cite

nose test:


.. code-block:: python

        import nose.tools as nt
        
        def test_quadratic():
            """Check that u(x,t)=x(L-x)(1+t/2) is exactly reproduced."""
            def exact_solution(x, t):
                return x*(L-x)*(1 + 0.5*t)
        
            def I(x):
                return exact_solution(x, 0)
        
            def V(x):
                return 0.5*exact_solution(x, 0)
        
            def f(x, t):
                return 2*(1 + 0.5*t)*c**2
        
            L = 2.5
            c = 1.5
            Nx = 3  # Very coarse mesh
            C = 0.75
            T = 18
        
            u, x, t, cpu = solver(I, V, f, c, L, Nx, C, T)
            u_e = exact_solution(x, t[-1])
            diff = abs(u - u_e).max()
            nt.assert_almost_equal(diff, 0, places=14)


.. _wave:pde1:impl:animate:

Visualization: animating the solution
-------------------------------------

Now that we have verified the implementation it is time to do a
real computation where we also display the evolution of the waves
on the screen.

Visualization via SciTools
~~~~~~~~~~~~~~~~~~~~~~~~~~

The following ``viz`` function defines a ``user_action``
callback function for plotting the solution at each time level:


.. code-block:: python

        def viz(I, V, f, c, L, Nx, C, T, umin, umax, animate=True):
            """Run solver and visualize u at each time level."""
            import scitools.std as plt
            import time, glob, os
        
            def plot_u(u, x, t, n):
                """user_action function for solver."""
                plt.plot(x, u, 'r-',
                         xlabel='x', ylabel='u',
                         axis=[0, L, umin, umax],
                         title='t=%f' % t[n], show=True)
                # Let the initial condition stay on the screen for 2
                # seconds, else insert a pause of 0.2 s between each plot
                time.sleep(2) if t[n] == 0 else time.sleep(0.2)
                plt.savefig('frame_%04d.png' % n)  # for movie making
        
            # Clean up old movie frames
            for filename in glob.glob('frame_*.png'):
                os.remove(filename)
        
            user_action = plot_u if animate else None
            u, x, t, cpu = solver(I, V, f, c, L, Nx, C, T, user_action)
        
            # Make movie files
            fps = 4  # Frames per second
            plt.movie('frame_*.png', encoder='html', fps=fps,
                      output_file='movie.html')
            codec2ext = dict(flv='flv', libx64='mp4', libvpx='webm',
                             libtheora='ogg')
            filespec = 'frame_%04d.png'
            movie_program = 'avconv'  # or 'ffmpeg'
            for codec in codec2ext:
                ext = codec2ext[codec]
                cmd = '%(movie_program)s -r %(fps)d -i %(filespec)s '\ 
                      '-vcodec %(codec)s movie.%(ext)s' % vars()
                os.system(cmd)

A function inside another function, like ``plot_u`` in the above code
segment, has access to *and remembers* all the local variables
in the surrounding code inside the ``viz`` function (!). This is known
in computer science as a *closure* and is very convenient to
program with. For example,
the ``plt`` and ``time`` modules defined outside ``plot_u`` are accessible for
``plot_u`` when
the function is called (as ``user_action``) in the ``solver`` function.
Some may think, however, that a class instead of a closure is a cleaner
and easier-to-understand implementation of
the user action function, see the section :ref:`wave:pde2:software`.

Making movie files
~~~~~~~~~~~~~~~~~~

Several hardcopies of the animation are made from the
``frame_*.png`` files. The first movie, made by the SciTools function
``plt.movie`` creates a ``movie.html`` file with a movie player
for displaying the ``frame_*.png`` files. This movie player can
be generated from the command line too


.. code-block:: console

        Terminal> scitools movie encoder=html output_file=movie.html \ 
                  fps=4 frame_*.png

We also use
the ``avconv`` (or ``ffmpeg``) programs to make movie files in modern
formats: Flash, MP4, Webm, and Ogg.
A typical ``avconv`` (or ``ffmpeg``) commands for creating a movie file
look like


.. code-block:: console

        Terminal> avconv -r 4 -i frame_%04d.png -vcodec libtheora movie.ogg

The different formats require
different encoders to be installed: Flash applies ``flv``,
WebM applies ``libvpx``, and MP4 applies ``libx64``.
Players like ``vlc``, ``mplayer``,
``gxine``, and ``totem`` can be used to play these movie files.

Note that padding the frame counter with zeros in the ``frame_*.png``
files, as specified by the ``%04d`` format, is essential so that the wildcard
notation ``frame_*.png`` expands to the correct set of files.


Skipping frames for animation speed
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes the time step is small and :math:`T` is large, leading to an
inconveniently large number of plot files and a slow animation on the
screen. The solution to such a problem is to decide on a total number
of frames in the animation, ``num_frames``, and plot the solution only at
every ``every`` frame. The total number of time levels (i.e., maximum
possible number of frames) is the length of ``t``, ``t.size``, and if we
want ``num_frames``, we need to plot every ``t.size/num_frames`` frame:


.. code-block:: python

        every = int(t.size/float(num_frames))
        if n % every == 0 or n == t.size-1:
            st.plot(x, u, 'r-', ...)

The initial condition (``n=0``) is natural to include,
and as ``n % every == 0`` will very seldom be true for the
very final frame, we also ensure that ``n == t.size-1`` and hence
the final frame is included.

A simple choice of numbers may illustrate the formulas: say we have
801 frames in total (``t.size``) and we allow only 60 frames to be
plotted. Then we need to plot every 801/60 frame, which with integer
division yields 13 as ``every``. Using the mod function, ``n % every``,
this operation is zero every time ``n`` can be divided by 13 without a
remainder. That is, the ``if`` test is true when ``n`` equals :math:`0, 13, 26,
39, ..., 780, 801`. The associated code is included in the ``plot_u``
function in the file `wave1D_u0_sv.py <http://tinyurl.com/jvzzcfn/wave/wave1D_u0_sv.py>`_.

Visualization via Matplotlib
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The previous code based on the ``plot`` interface from ``scitools.std``
can be run with Matplotlib as the visualization backend, but if one
desires to program directly with Matplotlib, quite different code
is needed. Matplotlib's interactive mode must be turned on:


.. code-block:: python

        import matplotlib.pyplot as plt
        plt.ion()  # interactive mode on

The most
commonly used animation technique with Matplotlib
is to update the data in the plot at each time level:


.. code-block:: python

        # Make a first plot
        lines = plt.plot(t, u)
        # call plt.axis, plt.xlabel, plt.ylabel, etc. as desired
        
        # At later time levels
        lines[0].set_ydata(u)
        plt.legend('t=%g' % t[n])
        plt.draw()  # make updated plot
        plt.savefig(...)


An alternative is to rebuild the plot at every time level:


.. code-block:: python

        plt.clf()        # delete any previous curve(s)
        plt.axis([...])
        plt.plot(t, u)
        # plt.xlabel, plt.legend and other decorations
        plt.draw()
        plt.savefig(...)

Many prefer to work with figure and axis objects as in MATLAB:



.. code-block:: python

        fig = plt.figure()
        ...
        fig.clf()
        ax = fig.gca()
        ax.axis(...)
        ax.plot(t, u)
        # ax.set_xlabel, ax.legend and other decorations
        plt.draw()
        fig.savefig(...)


.. _wave:pde1:guitar:data:

Running a case
--------------

The first demo of our 1D wave equation solver concerns vibrations of a
string that is initially deformed to a triangular shape, like when picking
a guitar string:


.. math::
   :label: wave:pde1:guitar:I
        
        I(x) = \left\lbrace
        \begin{array}{ll}
        ax/x_0, & x < x_0,\\ 
        a(L-x)/(L-x_0), & \hbox{otherwise}
        \end{array}\right.
        
        

We choose :math:`L=75` cm, :math:`x_0=0.8L`, :math:`a=5` mm, :math:`N_x=50`, and a time frequency
:math:`\nu = 440` Hz. The relation between the wave speed :math:`c` and :math:`\nu` is
:math:`c=\nu\lambda`, where :math:`\lambda` is the wavelength, taken as :math:`2L` because
the longest wave on the string form half a wavelength. There is no
external force, so :math:`f=0`, and the string is at rest initially so
that :math:`V=0`. A function setting
these physical parameters and calling ``viz`` for this case goes as follows:


.. code-block:: python

        def guitar(C):
            """Triangular wave (pulled guitar string)."""
            L = 0.75
            x0 = 0.8*L
            a = 0.005
            freq = 440
            wavelength = 2*L
            c = freq*wavelength
            omega = 2*pi*freq
            num_periods = 1
            T = 2*pi/omega*num_periods
            Nx = 50
        
            def I(x):
                return a*x/x0 if x < x0 else a/(L-x0)*(L-x)
        
            umin = -1.2*a;  umax = -umin
            cpu = viz(I, 0, 0, c, L, Nx, C, T, umin, umax, animate=True)

The associated program has the name `wave1D_u0_s.py <http://tinyurl.com/jvzzcfn/wave/wave1D_u0_s.py>`_. Run
the program and watch the `movie of the vibrating string <http://tinyurl.com/k3sdbuv/pub/mov-wave/guitar_C0.8/index.html>`_.

The benefits of scaling
-----------------------

The previous example demonstrated that quite some work is needed
with establishing relevant physical parameters for a case. By *scaling*
the mathematical problem we can often reduce the need to estimate
physical parameters dramatically. A scaling consists of introducing new
independent and dependent variables, with the aim that the absolute
value of these vary between 0 and 1:

.. math::
         \bar x = \frac{x}{L},\quad \bar t = \frac{c}{L}t,\quad
        \bar u = \frac{u}{a}
        \thinspace .
        

Replacing old by new variables in the PDE, using :math:`f=0`,
and dropping the bars, results in the *scaled equation*
:math:`u_{tt} = u_{xx}`. This equation has no physical parameter (!).

If we have a program implemented for the physical wave equation with
dimensions, we can obtain the dimensionless, scaled version by
setting :math:`c=1`. The initial condition
corresponds to :eq:`wave:pde1:guitar:I`, but with setting
:math:`a=1`, :math:`L=1`, and :math:`x_0\in [0,1]`. This means that we only need to
decide on the :math:`x_0` value as a fraction of unity, because
the scaled problem corresponds to setting all
other parameters to unity! In the code we can just set
``a=c=L=1``, ``x0=0.8``, and there is no need to calculate with
wavelengths and frequencies to estimate :math:`c`.

The only non-trivial parameter to estimate in the scaled problem
is the final end time of the simulation, or more precisely, how it relates
to periods in periodic solutions in time, since we often want to
express the end time as a certain number of periods.
Suppose as :math:`u` behaves as :math:`\sin (\omega t)` in time in variables
with dimension. The corresponding period is :math:`P=2\pi/\omega`.
The frequency :math:`\omega` is related to the wavelength :math:`\lambda` of the waves
through the relations :math:`\omega = kc` and :math:`k=2\pi/\lambda`, giving
:math:`\omega = 2\pi c/\lambda` and :math:`P=\lambda/c`. It remains to estimate :math:`\lambda`.
With :math:`u(x,t)=F(x)\sin\omega t` we find from :math:`u_{tt}=c^2u_{xx}`
that :math:`c^2F'' + \omega^2F=0`, and the boundary conditions demand
:math:`F(0)=F(L)=0`. The solution is :math:`F(x)=\sin(x\pi/L)`, which has
wavelength :math:`\lambda = 2\pi/(\pi/L)=2L`. One period is therefore
given by :math:`P=2L/c`. The dimensionless period is :math:`\bar P=Pc/L = 2`.


.. _wave:pde1:impl:vec:

Vectorization
=============


.. index:: vectorization


The computational algorithm for solving the wave equation visits one
mesh point at a time and evaluates a formula for the new value :math:`u_i^{n+1}`
at
that point. Technically, this is implemented by a loop over array
elements in a program. Such loops may run slowly in Python (and
similar interpreted languages such as R and MATLAB).
One technique for speeding up loops is to
perform operations on entire arrays instead of working with one element
at a time. This is referred to as *vectorization*, *vector computing*,
or *array computing*.
Operations on whole arrays are possible if the computations
involving each element is independent of each other and therefore can,
at least in principle, be performed simultaneously.
Vectorization not only speeds up the code on serial computers, but it
also makes it easy to exploit parallel computing.


.. _wave:pde1:impl:vec:slices:basics:

Operations on slices of arrays
------------------------------


.. index:: scalar code


.. index:: array slices


.. index:: slice


Efficient computing with ``numpy`` arrays demands that we avoid loops
and compute with entire arrays at once (or at least large portions of them).
Consider this calculation of differences :math:`d_i = u_{i+1}-u_i`:

.. code-block:: python

        n = u.size
        for i in range(0, n-1):
            d[i] = u[i+1] - u[i]

All the differences here are independent of each other.
The computation of ``d`` can therefore alternatively be done by
subtracting the array :math:`(u_0,u_1,\ldots,u_{n-1})` from
the array where the elements are shifted one index upwards:
:math:`(u_1,u_2,\ldots,u_n)`, see Figure :ref:`wave:pde1:vec:fig1`.
The former subset of the array can be
expressed by ``u[0:n-1]``,
``u[0:-1]``, or just
``u[:-1]``, meaning from index 0 up to,
but not including, the last element (``-1``). The latter subset
is obtained by ``u[1:n]`` or ``u[1:]``,
meaning from index 1 and the rest of the array.
The computation of ``d`` can now be done without an explicit Python loop:

.. code-block:: python

        d = u[1:] - u[:-1]

or with explicit limits if desired:

.. code-block:: python

        d = u[1:n] - u[0:n-1]

Indices with a colon, going from an index to (but not including) another
index are called *slices*. With ``numpy`` arrays, the computations
are still done by loops, but in efficient, compiled, highly optimized code
in C or Fortran. Such array operations can also easily be distributed
among many processors on parallel computers. We say that the *scalar code*
above, working on an element (a scalar) at a time, has been replaced by
an equivalent *vectorized code*. The process of vectorizing code is called
*vectorization*.


.. _wave:pde1:vec:fig1:

.. figure:: vectorized_diff.png
   :width: 400

   *Illustration of subtracting two slices of two arrays*




.. admonition:: Test the understanding

   Newcomers to vectorization are encouraged to choose
   a small array ``u``, say with five elements,
   and simulate with pen and paper
   both the loop version and the vectorized version.


Finite difference schemes basically contains differences between array
elements with shifted indices. Consider the updating formula


.. code-block:: python

        for i in range(1, n-1):
            u2[i] = u[i-1] - 2*u[i] + u[i+1]

The vectorization consists of replacing the loop by arithmetics on
slices of arrays of length ``n-2``:


.. code-block:: python

        u2 = u[:-2] - 2*u[1:-1] + u[2:]
        u2 = u[0:n-2] - 2*u[1:n-1] + u[2:n]   # alternative

Note that ``u2`` here gets length ``n-2``. If ``u2`` is already an array of
length ``n`` and we want to use the formula to update all the "inner"
elements of ``u2``, as we will when solving a 1D wave equation, we can write

.. code-block:: python

        u2[1:-1]  = u[:-2] - 2*u[1:-1] + u[2:]
        u2[1:n-1] = u[0:n-2] - 2*u[1:n-1] + u[2:n]   # alternative

Pen and paper calculations with a small array will demonstrate what is
actually going on. The expression on the right-hand side are done in the
following steps, involving temporary arrays with intermediate results,
since we can only work with two arrays at a time in
arithmetic expressions:

.. code-block:: python

        temp1 = 2*u[1:-1]
        temp2 = u[0:-2] - temp1
        temp3 = temp2 + u[2:]
        u2[1:-1] = temp3


We can extend the previous example to a formula with an additional term computed
by calling a function:

.. code-block:: python

        def f(x):
            return x**2 + 1
        
        for i in range(1, n-1):
            u2[i] = u[i-1] - 2*u[i] + u[i+1] + f(x[i])

Assuming ``u2``, ``u``, and ``x`` all have length ``n``, the vectorized
version becomes

.. code-block:: python

        u2[1:-1] = u[:-2] - 2*u[1:-1] + u[2:] + f(x[1:-1])


.. _wave:pde1:impl:vec:slices:fdm:

Finite difference schemes expressed as slices
---------------------------------------------

We now have the necessary tools to vectorize the algorithm for
the wave equation. There are three loops: one for the initial condition,
one for the first time step, and finally the loop that is repeated for
all subsequent time levels. Since only the latter is repeated a potentially
large number of times, we limit the efforts of vectorizing the code
to this loop:

.. code-block:: python

        for i in range(1, Nx):
            u[i] = 2*u_1[i] - u_2[i] + \ 
                   C2*(u_1[i-1] - 2*u_1[i] + u_1[i+1])

The vectorized version becomes


.. code-block:: python

        u[1:-1] = - u_2[1:-1] + 2*u_1[1:-1] + \ 
                  C2*(u_1[:-2] - 2*u_1[1:-1] + u_1[2:])

or

.. code-block:: python

        u[1:Nx] = 2*u_1[1:Nx]- u_2[1:Nx] + \ 
                  C2*(u_1[0:Nx-1] - 2*u_1[1:Nx] + u_1[2:Nx+1])


.. We may vectorize the other loops regarding the initial condition and

.. the first time step, but the effect will hardly be

.. noticeable in long time simulations.


The program
`wave1D_u0_sv.py <http://tinyurl.com/jvzzcfn/wave/wave1D_u0_sv.py>`_
contains a new version of the function ``solver`` where both the scalar
and the vectorized loops are included (the argument ``version`` is
set to ``scalar`` or ``vectorized``, respectively).


.. _wave:pde1:impl:vec:verify:quadratic:

Verification  (2)
-----------------


.. index:: lambda function (Python)


We may reuse the quadratic solution :math:`{u_{\small\mbox{e}}}(x,t)=x(L-x)(1+\frac{1}{2}t)` for
verifying also the vectorized code. A nose test can now test
both the scalar and the vectorized version. Moreover, we may
use a ``user_action`` function that compares the computed and exact
solution at each time level and performs a test:


.. code-block:: python

        def test_quadratic():
            """
            Check the scalar and vectorized versions work for
            a quadratic u(x,t)=x(L-x)(1+t/2) that is exactly reproduced.
            """
            # The following function must work for x as array or scalar
            exact_solution = lambda x, t: x*(L - x)*(1 + 0.5*t)
            I = lambda x: exact_solution(x, 0)
            V = lambda x: 0.5*exact_solution(x, 0)
            # f is a scalar (zeros_like(x) works for scalar x too)
            f = lambda x, t: zeros_like(x) + 2*c**2*(1 + 0.5*t)
        
            L = 2.5
            c = 1.5
            Nx = 3  # Very coarse mesh
            C = 1
            T = 18  # Long time integration
        
            def assert_no_error(u, x, t, n):
                u_e = exact_solution(x, t[n])
                diff = abs(u - u_e).max()
                nt.assert_almost_equal(diff, 0, places=13)
        
            solver(I, V, f, c, L, Nx, C, T,
                   user_action=assert_no_error, version='scalar')
            solver(I, V, f, c, L, Nx, C, T,
                   user_action=assert_no_error, version='vectorized')




.. admonition:: Lambda functions

   The code segment above demonstrates how to achieve very
   compact code with the use of lambda functions for the various
   input parameters that require a Python function. In essence,
   
   
   .. code-block:: python
   
           f = lambda x, t: L*(x-t)**2
   
   is equivalent to
   
   
   .. code-block:: python
   
           def f(x, t):
               return L(x-t)**2
   
   Note that lambda functions can just contain a single expression and no
   statements.
   
   One advantage with lambda functions is that they can be used directly
   in calls:
   
   
   .. code-block:: python
   
           solver(I=lambda x: sin(pi*x/L), V=0, f=0, ...)


Efficiency measurements
-----------------------

Running the ``wave1D_u0_sv.py`` code with the previous string vibration example
for :math:`N_x=50,100,200,400,800`, and measuring the CPU time
(see the ``run_efficiency_experiments`` function), shows that the vectorized
code runs substantially faster: the scalar code uses approximately
a factor :math:`N_x/5` more time!


.. ===== Profiling code ===== better in 2D


.. ======= Storing simulation data =======

.. plain files, NUumPyDB, XDMF, joblib, exercises with retrieval and comparison


.. ======= Programming with classes =======

.. can integrate data storage and check pointing, or maybe do it later in 2D

.. with Cython, Fortran and C? Might have a very simple version here and

.. then a new, more sophisticated version in 2D.

.. Think about grabbing out all soft eng and

.. present in short course. Need to be self-contained.



Exercises  (1)
==============



.. --- begin exercise ---


.. _wave:exer:standingwave:

Exercise 1: Simulate a standing wave
------------------------------------

The purpose of this exercise is to simulate standing waves on :math:`[0,L]`
and illustrate the error in the simulation.
Standing waves arise from an initial condition


.. math::
         u(x,0)= A \sin\left(\frac{\pi}{L}mx\right),

where :math:`m` is an integer and :math:`A` is a freely chosen amplitude.
The corresponding exact solution can be computed and reads


.. math::
         {u_{\small\mbox{e}}}(x,t) =  A\sin\left(\frac{\pi}{L}mx\right)
        \cos\left(\frac{\pi}{L}mct\right){\thinspace .}
        



*a)* Explain that for a function :math:`\sin kx\cos \omega t` the wave length
in space is :math:`\lambda = 2\pi /k` and the period in time is :math:`P=2\pi/\omega`.
Use these expressions to find the wave length in space and period in
time of :math:`{u_{\small\mbox{e}}}` above.

*b)* Import the ``solver`` function ``wave1D_u0_s.py`` into a new file
where the ``viz`` function is reimplemented such that it
plots either the numerical *and* the exact solution, *or* the error.

*c)* Make animations where you illustrate how the error
:math:`e^n_i ={u_{\small\mbox{e}}}(x_i, t_n)- u^n_i`
develops and increases in time. Also make animations of
:math:`u` and :math:`{u_{\small\mbox{e}}}` simultaneously.

.. --- begin hint in exercise ---


*Hint 1.* Quite long time simulations are needed in order to display significant
discrepancies between the numerical and exact solution.

.. --- end hint in exercise ---


.. --- begin hint in exercise ---


*Hint 2.* A possible set of parameters is :math:`L=12`, :math:`m=9`, :math:`c=2`, :math:`A=1`, :math:`N_x=80`,
:math:`C=0.8`. The error mesh function :math:`e^n` can be simulated for 10 periods,
while 20-30 periods are needed to show significant differences between
the curves for the numerical and exact solution.

.. --- end hint in exercise ---


Filename: ``wave_standing.py``.

.. Closing remarks for this Exercise


Remarks
~~~~~~~

The important
parameters for numerical quality are :math:`C` and :math:`k\Delta x`, where
:math:`C=c\Delta t/\Delta x` is the Courant number and :math:`k` is defined above
(:math:`k\Delta x` is proportional to how many mesh points we have per wave length
in space, see the section :ref:`wave:pde1:num:dispersion` for explanation).


.. --- end exercise ---





.. --- begin exercise ---


.. _wave:exer:store:list:

Exercise 2: Add storage of solution in a user action function
-------------------------------------------------------------

Extend the ``plot_u`` function in the file ``wave1D_u0_s.py`` to also store
the solutions ``u`` in a list.
To this end, declare ``all_u`` as
an empty list in the ``viz`` function, outside ``plot_u``, and perform
an append operation inside the ``plot_u`` function. Note that a
function, like ``plot_u``, inside another function, like ``viz``,
remembers all local variables in ``viz`` function, including ``all_u``,
even when ``plot_u`` is called (as ``user_action``) in the ``solver`` function.
Test both ``all_u.append(u)`` and ``all_u.append(u.copy())``.
Why does one of these constructions fail to store the solution correctly?
Let the ``viz`` function return the ``all_u`` list
converted to a two-dimensional ``numpy`` array.
Filename: ``wave1D_u0_s_store.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:exer:store:list:class:

Exercise 3: Use a class for the user action function
----------------------------------------------------

Redo :ref:`wave:exer:store:list` using a class for the
user action function. That is, define a class ``Action`` where
the ``all_u`` list is an attribute, and implement the user action
function as a method (the special method ``__call__`` is a natural
choice). The class versions avoids that the user action function
depends on parameters defined outside the function (such as ``all_u``
in :ref:`wave:exer:store:list`).
Filename: ``wave1D_u0_s2c.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:exer:multiple:C:

Exercise 4: Compare several Courant numbers in one movie
--------------------------------------------------------

The goal of this exercise is to make movies where several curves,
corresponding to different Courant numbers, are visualized.
Import the ``solver`` function from the ``wave1D_u0_s`` movie
in a new file ``wave_compare.py``. Reimplement the ``viz`` function
such that it can take a list of ``C`` values as argument
and create a movie with solutions corresponding to the given ``C``
values. The ``plot_u`` function must be changed to store the solution
in an array (see :ref:`wave:exer:store:list` or
:ref:`wave:exer:store:list:class` for details), ``solver`` must be
computed for each value of the Courant number, and finally
one must run through each time step and plot all the spatial
solution curves in one figure and store it in a file.

The challenge in such a visualization is to ensure that the curves in
one plot corresponds to the same time point. The easiest remedy is to
keep the time and space resolution constant and change the wave
velocity :math:`c` to change the Courant number.
Filename: ``wave_numerics_comparison.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:exer:mesh1D:calculus:

Project 5: Calculus with 1D mesh functions
------------------------------------------

This project explores integration and differentiation of
mesh functions, both with scalar and vectorized implementations.
We are given a mesh function :math:`f_i` on a spatial one-dimensional
mesh :math:`x_i=i\Delta x`, :math:`i=0,\ldots,N_x`, over the interval :math:`[a,b]`.


*a)* Define the discrete derivative of :math:`f_i` by using centered
differences at internal mesh points and one-sided differences
at the end points. Implement a scalar version of
the computation in a Python function and supply a nose test
for the linear case :math:`f(x)=4x-2.5` where the discrete derivative should
be exact.

*b)* Vectorize the implementation of the discrete derivative.
Extend the nose test to check the validity of the implementation.

*c)* To compute the discrete integral :math:`F_i` of :math:`f_i`, we assume that
the mesh function :math:`f_i` varies linearly between the mesh points.
Let :math:`f(x)` be such a linear interpolant of :math:`f_i`. We then
have


.. math::
         F_i = \int_{x_0}^{x_i} f(x) dx{\thinspace .}

The exact integral of a piecewise linear function :math:`f(x)` is
given by the Trapezoidal rule. S
how that if :math:`F_{i}` is already computed, we can find :math:`F_{i+1}`
from


.. math::
         F_{i+1} = F_i + \frac{1}{2}(f_i + f_{i+1})\Delta x{\thinspace .}

Make a function for a scalar implementation of the discrete integral
as a mesh function. That is, the function should return
:math:`F_i` for :math:`i=0,\ldots,N_x`.
For a nose test one can use the fact that the above defined
discrete integral of a linear
function (say :math:`f(x)=4x-2.5`) is exact.

*d)* Vectorize the implementation of the discrete integral.
Extend the nose test to check the validity of the implementation.

.. --- begin hint in exercise ---


*Hint.* Interpret the recursive formula for :math:`F_{i+1}` as a sum.
Make an array with each element of the sum and use the "cumsum"
(``numpy.cumsum``) operation to compute the accumulative sum:
``numpy.cumsum([1,3,5])`` is ``[1,4,9]``.

.. --- end hint in exercise ---


*e)* Create a class ``MeshCalculus`` that can integrate and differentiate
mesh functions. The class can just define some methods that call
the previously implemented Python functions. Here is an example
on the usage:


.. code-block:: python

        import numpy as np
        calc = MeshCalculus(vectorized=True)
        x = np.linspace(0, 1, 11)        # mesh
        f = np.exp(x)                    # mesh function
        df = calc.differentiate(f, x)    # discrete derivative
        F = calc.integrate(f, x)         # discrete anti-derivative


Filename: ``mesh_calculus_1D.py``.

.. --- end exercise ---



.. !split

.. _wave:pde2:Neumann:

Generalization: reflecting boundaries
=====================================

The boundary condition :math:`u=0` makes :math:`u` change sign at the boundary,
while the condition :math:`u_x=0` perfectly reflects the wave, see
a `web page <http://tinyurl.com/k3sdbuv/pub/mov-wave/demo_BC_gaussian/index.html>`_
or a `movie file <http://tinyurl.com/k3sdbuv/pub/mov-wave/demo_BC_gaussian/movie.flv>`_
for demonstration.
Our next task is to explain how to implement the boundary
condition :math:`u_x=0`, which is
more complicated to express numerically and also to implement than
a given value of :math:`u`.
We shall present two methods for implementing :math:`u_x=0`
in a finite difference scheme, one based on deriving a modified
stencil at the boundary, and another one based on extending the mesh
with ghost cells and ghost points.


.. _wave:pde2:Neumann:bc:

Neumann boundary condition
--------------------------


.. index:: Neumann conditions


.. index:: Dirichlet conditions


.. index:: homogeneous Neumann conditions


.. index:: homogeneous Dirichlet conditions


When a wave hits a boundary and is to be reflected back, one applies
the condition


.. math::
   :label: wave:pde1:Neumann:0
        
         \frac{\partial u}{\partial n} \equiv \boldsymbol{n}\cdot\nabla u = 0
        
        \thinspace .
        

The derivative :math:`\partial /\partial n` is in the
outward normal direction from a general boundary.
For a 1D domain :math:`[0,L]`,
we have that


.. math::
        
        \left.\frac{\partial}{\partial n}\right\vert_{x=L} =
        \frac{\partial}{\partial x},\quad
        \left.\frac{\partial}{\partial n}\right\vert_{x=0} = -
        \frac{\partial}{\partial x}{\thinspace .}
        




.. admonition:: Boundary condition terminology

   Boundary conditions
   that specify the value of :math:`\partial u/\partial n`,
   or shorter :math:`u_n`, are known as
   `Neumann <http://en.wikipedia.org/wiki/Neumann_boundary_condition>`_ conditions, while `Dirichlet conditions <http://en.wikipedia.org/wiki/Dirichlet_conditions>`_
   refer to specifications of :math:`u`.
   When the values are zero (:math:`\partial u/\partial n=0` or :math:`u=0`) we speak
   about *homogeneous* Neumann or Dirichlet conditions.


.. _wave:pde2:Neumann:discr:

Discretization of derivatives at the boundary
---------------------------------------------

How can we incorporate the condition :eq:`wave:pde1:Neumann:0`
in the finite difference scheme?  Since we have used central
differences in all the other approximations to derivatives in the
scheme, it is tempting to implement :eq:`wave:pde1:Neumann:0` at
:math:`x=0` and :math:`t=t_n` by the difference


.. math::
   :label: wave:pde1:Neumann:0:cd
        
        \frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
        \thinspace .
        
        

The problem is that :math:`u_{-1}^n` is not a :math:`u` value that is being
computed since the point is outside the mesh. However, if we combine
:eq:`wave:pde1:Neumann:0:cd` with the scheme
.. :eq:`wave:pde1:step4`

for :math:`i=0`,


.. math::
   :label: wave:pde1:Neumann:0:scheme
        
        u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
        \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),
        
        

we can eliminate the fictitious value :math:`u_{-1}^n`. We see that
:math:`u_{-1}^n=u_1^n` from :eq:`wave:pde1:Neumann:0:cd`, which
can be used in :eq:`wave:pde1:Neumann:0:scheme` to
arrive at a modified scheme for the boundary point :math:`u_0^{n+1}`:


.. math::
        
        u^{n+1}_i = -u^{n-1}_i  + 2u^n_i + 2C^2
        \left(u^{n}_{i+1}-u^{n}_{i}\right),\quad i=0 \thinspace . 

Figure :ref:`wave:pde1:fig:Neumann:stencil` visualizes this equation
for computing :math:`u^3_0` in terms of :math:`u^2_0`, :math:`u^1_0`, and
:math:`u^2_1`.


.. index::
   single: stencil; Neumann boundary



.. _wave:pde1:fig:Neumann:stencil:

.. figure:: wave_PDE_Neumann_n_left.png
   :width: 500

   *Modified stencil at a boundary with a Neumann condition*


Similarly, :eq:`wave:pde1:Neumann:0` applied at :math:`x=L`
is discretized by a central difference


.. math::
   :label: wave:pde1:Neumann:0:cd2
        
        \frac{u_{N_x+1}^n - u_{N_x-1}^n}{2\Delta x} = 0
        \thinspace .
        
        

Combined with the scheme for :math:`i=N_x` we get a modified scheme for
the boundary value :math:`u_{N_x}^{n+1}`:


.. math::
        
        u^{n+1}_i = -u^{n-1}_i + 2u^n_i + 2C^2
        \left(u^{n}_{i-1}-u^{n}_{i}\right),\quad i=N_x \thinspace . 


The modification of the scheme at the boundary is also required for
the special formula for the first time step. How the stencil moves
through the mesh and is modified at the boundary can be illustrated
by an animation
in a `web page <http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/index.html>`_
or a `movie file <http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.flv>`_.




.. _wave:pde2:Neumann:impl:

Implementation of Neumann conditions
------------------------------------

The implementation of the special formulas for the boundary points
can benefit from using the general formula for the interior points
also at the boundaries,
but replacing :math:`u_{i-1}^n` by :math:`u_{i+1}^n` when computing
:math:`u_i^{n+1}` for :math:`i=0` and
:math:`u_{i+1}^n` by :math:`u_{i-1}^n` for :math:`i=N_x`. This is achieved by
just replacing the index
:math:`i-1` by :math:`i+1` for :math:`i=0` and :math:`i+1` by :math:`i-1` for
:math:`i=N_x`. In a program, we introduce variables to hold the value of
the offset indices: ``im1`` for ``i-1`` and ``ip1`` for ``i+1``.
It is now just a manner of defining ``im1`` and ``ip1`` properly
for the internal points and the boundary points.
The coding for the latter reads


.. code-block:: python

        i = 0
        ip1 = i+1
        im1 = ip1  # i-1 -> i+1
        u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])
        
        i = Nx
        im1 = i-1
        ip1 = im1  # i+1 -> i-1
        u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])


We can in fact create one loop over both the internal and boundary
points and use only one updating formula:


.. code-block:: python

        for i in range(0, Nx+1):
            ip1 = i+1 if i < Nx else i-1
            im1 = i-1 if i > 0  else i+1
            u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])


The program `wave1D_dn0.py <http://tinyurl.com/jvzzcfn/wave/wave1D_dn0.py>`_
contains a complete implementation of the 1D wave equation with
boundary conditions :math:`u_x = 0` at :math:`x=0` and :math:`x=L`.

.. _wave:indexset:

Index set notation
------------------


.. index:: index set notation


We shall introduce a special notation for index sets, consisting of
writing :math:`x_i`, :math:`i\in{\mathcal{I}_x}`, instead of :math:`i=0,\ldots,N_x`.
Obviously, :math:`{\mathcal{I}_x}` must be the set :math:`{\mathcal{I}_x} =\{0,\ldots,N_x\}`, but it
is often advantageous to have a symbol for this set rather than
specifying all its elements. This saves writing and makes
specification of algorithms and implementation of computer code easier.

The first index in the set will be denoted :math:`{{\mathcal{I^0}_x}}`
and the last :math:`{\mathcal{I^{-1}_x}}`. Sometimes we need to count from the second
element in the set, and the notation :math:`{{\mathcal{I^+}_x}}` is then used.
Correspondingly, :math:`{{\mathcal{I^-}_x}}` means :math:`\{0,\ldots,N_x-1\}`.  All the
indices corresponding to inner grid points are
:math:`{{\mathcal{I^i}_x}}=\{1,\ldots,N_x-1\}`.  For the time domain we find it
natural to explicitly use 0 as the first index, so we will usually
write :math:`n=0` and :math:`t_0` rather than :math:`n={\mathcal{I}_t}^0`. We also avoid notation
like :math:`x_{{\mathcal{I^{-1}_x}}}` and will instead use :math:`x_i`, :math:`i={\mathcal{I^{-1}_x}}`.

The Python code associated with index sets applies the following
conventions:


==================  ==================  
     Notation             Python        
==================  ==================  
:math:`{\mathcal{I}_x}`         ``Ix``              
:math:`{{\mathcal{I^0}_x}}`  ``Ix[0]``           
:math:`{\mathcal{I^{-1}_x}}`  ``Ix[-1]``          
:math:`{{\mathcal{I^-}_x}}`  ``Ix[:-1]``         
:math:`{{\mathcal{I^+}_x}}`  ``Ix[1:]``          
:math:`{{\mathcal{I^i}_x}}`  ``Ix[1:-1]``        
==================  ==================  

An important feature of the index set notation is that it
keeps our formulas and code independent of how
we count mesh points. For example, the notation :math:`i\in{\mathcal{I}_x}` or :math:`i={{\mathcal{I^0}_x}}`
remains the same whether :math:`{\mathcal{I}_x}` is defined as above or as starting at 1,
i.e., :math:`{\mathcal{I}_x}=\{1,\ldots,Q\}`. Similarly, we can in the code define
``Ix=range(Nx+1)`` or ``Ix=range(1,Q)``, and expressions
like ``Ix[0]`` and ``Ix[1:-1]`` remain correct. One application where
the index set notation is convenient is
conversion of code from a language where arrays has base index 0 (e.g.,
Python and C) to languages where the base index is 1 (e.g., MATLAB and
Fortran). Another important application is implementation of
Neumann conditions via ghost points (see next section).

For the current problem setting in the :math:`x,t` plane, we work with
the index sets


.. math::
        
        {\mathcal{I}_x} = \{0,\ldots,N_x\},\quad {\mathcal{I}_t} = \{0,\ldots,N_t\},
        

defined in Python as


.. code-block:: python

        Ix = range(0, Nx+1)
        It = range(0, Nt+1)


A finite difference scheme can with the index set notation be specified as


.. math::
        
        u^{n+1}_i &= -u^{n-1}_i  + 2u^n_i + C^2
        \left(u^{n}_{i+1}-2u^{n}_{i}+u^{n}_{i-1}\right),
        \quad i\in{{\mathcal{I^i}_x}},\ n\in{{\mathcal{I^i}_t}},\\ 
        u_i &= 0,
        \quad i={{\mathcal{I^0}_x}},\ n\in{{\mathcal{I^i}_t}},\\ 
        u_i &= 0,
        \quad i={\mathcal{I^{-1}_x}},\ n\in{{\mathcal{I^i}_t}},
        

and implemented by code like


.. code-block:: python

        for n in It[1:-1]:
            for i in Ix[1:-1]:
                u[i] = - u_2[i] + 2*u_1[i] + \ 
                       C2*(u_1[i-1] - 2*u_1[i] + u_1[i+1])
            i = Ix[0];  u[i] = 0
            i = Ix[-1]; u[i] = 0



.. note::
   The program `wave1D_dn.py <http://tinyurl.com/jvzzcfn/wave/wave1D_dn.py>`_
   applies the index set notation and
   solves the 1D wave equation :math:`u_{tt}=c^2u_{xx}+f(x,t)` with
   quite general boundary and initial conditions:
   
     * :math:`x=0`: :math:`u=U_0(t)` or :math:`u_x=0`
   
     * :math:`x=L`: :math:`u=U_L(t)` or :math:`u_x=0`
   
     * :math:`t=0`: :math:`u=I(x)`
   
     * :math:`t=0`: :math:`u_t=I(x)`
   
   The program combines Dirichlet and Neumann conditions, scalar and vectorized
   implementation of schemes, and the index notation into one piece of code.
   A lot of test examples are also included in the program:
   
    * A rectangular plug profile as initial condition (easy to use as
      test example as the rectangle should jump one cell per time
      step when :math:`C=1`, without any numerical errors).
   
    * A Gaussian function as initial condition.
   
    * A triangular profile as initial condition, which resembles the
      typical initial shape of a guitar string.
   
    * A sinusoidal variation of :math:`u` at :math:`x=0` and either :math:`u=0` or
      :math:`u_x=0` at :math:`x=L`.
   
    * An exact analytical solution :math:`u(x,t)=\cos(m\pi t/L)\sin(\frac{1}{2}m\pi x/L)`, which can be used for convergence rate tests.


.. _wave:pde1:Neumann:ghost:

Alternative implementation via ghost cells
------------------------------------------

Idea
~~~~

Instead of modifying the scheme at the boundary, we can introduce
extra points outside the domain such that the fictitious values
:math:`u_{-1}^n` and :math:`u_{N_x+1}^n`
are defined in the mesh.
Adding the intervals :math:`[-\Delta x,0]` and :math:`[L, L+\Delta x]`,
often referred to as *ghost cells*, to the mesh gives us all the
needed mesh points, corresponding to :math:`i=-1,0,\ldots,N_x,N_x+1`.
The extra points :math:`i=-1` and :math:`i=N_x+1` are known as *ghost points*,
and values at these points, :math:`u_{-1}^n` and :math:`u_{N_x+1}^n`, are
called *ghost values*.

The important idea is
to ensure that we always have

.. math::
         u_{-1}^n = u_{1}^n\hbox{ and } u_{N_x-1}^n = u_{N_x+1}^n,

because then
the application of the standard scheme at a boundary point :math:`i=0` or :math:`i=N_x`
will be correct and guarantee that the solution is compatible with the
boundary condition :math:`u_x=0`.

Implementation  (2)
~~~~~~~~~~~~~~~~~~~

The ``u`` array now needs extra elements corresponding to the ghost cells
and points. Two new point values are needed:


.. code-block:: python

        u   = zeros(Nx+3)

The arrays ``u_1`` and ``u_2`` must be defined accordingly.

Unfortunately, a major indexing problem arises with ghost cells.
The reason is that Python indices *must* start
at 0 and ``u[-1]`` will always mean the last element in ``u``.
This fact gives, apparently, a mismatch between the mathematical
indices :math:`i=-1,0,\ldots,N_x+1` and the Python indices running over
``u``: ``0,..,Nx+2``. One remedy is to change the mathematical notation
of the scheme, as in


.. math::
         u^{n+1}_i = \cdots,\quad i=1,\ldots,N_x+1,

meaning that the ghost points correspond to :math:`i=0` and :math:`i=N_x+1`.
A better solution is to use the ideas of the section :ref:`wave:indexset`:
we hide the specific index value in an index set and operate with
inner and boundary points using the index set notation.

To this end, we define ``u`` with proper length and ``Ix`` to be the corresponding
indices for the real physical points:


.. code-block:: python

        u = zeros(Nx+3)
        Ix = range(1, u.shape[0]-1)

That is, the boundary points have indices ``Ix[0]`` and ``Ix[-1]`` (as before).
We first update the solution at all physical mesh points (i.e., interior
points in the mesh extended with ghost cells):


.. code-block:: python

        for i in Ix:
            u[i] = - u_2[i] + 2*u_1[i] + \ 
                   C2*(u_1[i-1] - 2*u_1[i] + u_1[i+1])

It remains to update the ghost points. For a boundary condition :math:`u_x=0`,
the ghost value must equal to the value at the associated inner mesh
point. Computer code makes this statement precise:


.. code-block:: python

        i = Ix[0]          # x=0 boundary
        u[i-1] = u[i+1]
        i = Ix[-1]         # x=L boundary
        u[i-1] = u[i+1]


The physical solution to be plotted is now in ``u[1:-1]``, so this slice is
the quantity to be returned from a solver function.
A complete implementation appears in the program
`wave1D_dn0_ghost.py <http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn0_ghost.py>`_.


.. warning::
    We have to be careful with how the spatial and temporal mesh
    points are stored. Say we let ``x`` be the physical mesh points,
    
    
    .. code-block:: python
    
            x = linspace(0, L, Nx+1)
    
    "Standard coding" of the initial condition,
    
    
    .. code-block:: python
    
            for i in Ix:
                u_1[i] = I(x[i])
    
    becomes wrong, since ``u_1`` and ``x`` have different lengths and the index ``i``
    corresponds to two different mesh points. In fact, ``x[i]`` corresponds
    to ``u[1+i]``. A correct implementation is
    
    
    .. code-block:: python
    
            for i in Ix:
                u_1[i] = I(x[i-Ix[0]])
    
    Similarly, a source term usually coded as ``f(x[i], t[n])`` is incorrect
    if ``x`` is defined to be the physical points.
    
    An alternative remedy is to let ``x`` also cover the ghost points such that
    ``u[i]`` is the value at ``x[i]``. This is the recommended approach.


The ghost cell is only added to the boundary where we have a Neumann
condition. Suppose we have a Dirichlet condition at :math:`x=L` and
a homogeneous Neumann condition at :math:`x=0`. The relevant implementation
then becomes


.. code-block:: python

        u = zeros(Nx+2)
        Ix = range(0, u.shape[0]-1)
        ...
        for i in Ix[:-1]:
            u[i] = - u_2[i] + 2*u_1[i] + \ 
                   C2*(u_1[i-1] - 2*u_1[i] + u_1[i+1]) + \ 
                   dt2*f(x[i], t[n])
        i = Ix[-1]
        u[i] = U_0       # set Dirichlet value
        i = Ix[0]
        u[i-1] = u[i+1]  # update ghost value

The physical solution to be plotted is now in ``u[1:]``.


.. _wave:pde2:var:c:

Generalization: variable wave velocity
======================================

Our next generalization of the 1D wave equation :eq:`wave:pde1` or
:eq:`wave:pde2` is to allow for a variable wave velocity :math:`c`:
:math:`c=c(x)`, usually motivated by wave motion in a domain composed of
different physical media with different properties for
propagating waves and hence different wave velocities :math:`c`.
Figure


.. _wave:pde1:fig:pulse1:two:media:

.. figure:: pulse1_in_two_media.png
   :width: 800

   *Left: wave entering another medium; right: transmitted and reflected wave*



The model PDE with a variable coefficient
-----------------------------------------

Instead of working with the squared quantity :math:`c^2(x)` we
shall for notational convenience introduce :math:`q(x) = c^2(x)`.
A 1D wave equation with variable wave velocity often takes the form


.. math::
   :label: wave:pde2:var:c:pde
        
        \frac{\partial^2 u}{\partial t^2} =
        \frac{\partial}{\partial x}\left( q(x)
        \frac{\partial u}{\partial x}\right) + f(x,t)
        
        \thinspace .
        

This equation sampled at a mesh point :math:`(x_i,t_n)` reads

.. math::
        
        \frac{\partial^2 }{\partial t^2} u(x_i,t_n) =
        \frac{\partial}{\partial x}\left( q(x_i)
        \frac{\partial}{\partial x} u(x_i,t_n)\right) + f(x_i,t_n),
        

where the only new term is

.. math::
        
        \frac{\partial}{\partial x}\left( q(x_i)
        \frac{\partial}{\partial x} u(x_i,t_n)\right) = \left[
        \frac{\partial}{\partial x}\left( q(x)
        \frac{\partial u}{\partial x}\right)\right]^n_i
        \thinspace .
        


.. _wave:pde2:var:c:ideas:

Discretizing the variable coefficient
-------------------------------------

The principal idea is to first discretize the outer derivative.
Define

.. math::
         \phi = q(x)
        \frac{\partial u}{\partial x},
        

and use a centered derivative around :math:`x=x_i` for the derivative of :math:`\phi`:

.. math::
        
        \left[\frac{\partial\phi}{\partial x}\right]^n_i
        \approx \frac{\phi_{i+\frac{1}{2}} - \phi_{i-\frac{1}{2}}}{\Delta x}
        = [D_x\phi]^n_i
        \thinspace .
        

Then discretize

.. math::
        
        \phi_{i+\frac{1}{2}}  = q_{i+\frac{1}{2}}
        \left[\frac{\partial u}{\partial x}\right]^n_{i+\frac{1}{2}}
        \approx q_{i+\frac{1}{2}} \frac{u^n_{i+1} - u^n_{i}}{\Delta x}
        = [q D_x u]_{i+\frac{1}{2}}^n
        \thinspace .
        

Similarly,

.. math::
        
        \phi_{i-\frac{1}{2}}  = q_{i-\frac{1}{2}}
        \left[\frac{\partial u}{\partial x}\right]^n_{i-\frac{1}{2}}
        \approx q_{i-\frac{1}{2}} \frac{u^n_{i} - u^n_{i-1}}{\Delta x}
        = [q D_x u]_{i-\frac{1}{2}}^n
        \thinspace .
        

These intermediate results are now combined to

.. math::
   :label: wave:pde2:var:c:formula
        
        \left[
        \frac{\partial}{\partial x}\left( q(x)
        \frac{\partial u}{\partial x}\right)\right]^n_i
        \approx \frac{1}{\Delta x^2}
        \left( q_{i+\frac{1}{2}} \left({u^n_{i+1} - u^n_{i}}\right)
        - q_{i-\frac{1}{2}} \left({u^n_{i} - u^n_{i-1}}\right)\right)
        
        \thinspace .
        

With operator notation we can write the discretization as

.. math::
   :label: wave:pde2:var:c:formula:op
        
        \left[
        \frac{\partial}{\partial x}\left( q(x)
        \frac{\partial u}{\partial x}\right)\right]^n_i
        \approx [D_xq D_x u]^n_i
        
        \thinspace .
        




.. admonition:: Remark

   Many are tempted to use the chain rule on the
   term :math:`\frac{\partial}{\partial x}\left( q(x)
   \frac{\partial u}{\partial x}\right)`, but this is not a good idea
   when discretizing such a term.


.. Needs some better explanation here - maybe the exact solution of a

.. poisson type problem (piecewise linear solution) failes if we use

.. the chain rule?



.. _wave:pde2:var:c:means:

Computing the coefficient between mesh points
---------------------------------------------

If :math:`q` is a known function of :math:`x`, we can easily evaluate
:math:`q_{i+\frac{1}{2}}` simply as :math:`q(x_{i+\frac{1}{2}})` with
:math:`x_{i+\frac{1}{2}} = x_i + \frac{1}{2}\Delta x`.
However, in many cases :math:`c`, and hence :math:`q`,
is only known as a discrete function, often at the mesh points :math:`x_i`.
Evaluating :math:`q` between two mesh points :math:`x_i` and :math:`x_{i+1}` can then
be done by averaging in three ways:


.. index:: geometric mean

.. index:: arithmetic mean

.. index:: harmonic average


.. index::
   single: averaging; geometric

.. index::
   single: averaging; arithmetic

.. index::
   single: averaging; harmonic



.. math::
   :label: wave:pde2:var:c:mean:arithmetic
        
        q_{i+\frac{1}{2}} \approx
        \frac{1}{2}\left( q_{i} + q_{i+1}\right) =
        [\overline{q}^{x}]_i,
        \quad \hbox{(arithmetic mean)}
        
        



.. math::
   :label: wave:pde2:var:c:mean:harmonic
          
        q_{i+\frac{1}{2}} \approx
        2\left( \frac{1}{q_{i}} + \frac{1}{q_{i+1}}\right)^{-1},
        \quad \hbox{(harmonic mean)}
        
        



.. math::
   :label: wave:pde2:var:c:mean:geometric
          
        q_{i+\frac{1}{2}} \approx
        \left(q_{i}q_{i+1}\right)^{1/2},
        \quad \hbox{(geometric mean)}
        
        

The arithmetic mean in :eq:`wave:pde2:var:c:mean:arithmetic` is by
far the most commonly used averaging technique.

With the operator notation from :eq:`wave:pde2:var:c:mean:arithmetic`
we can specify the discretization of the complete variable-coefficient
wave equation in a compact way:

.. math::
   :label: wave:pde2:var:c:scheme:op
        
        \lbrack D_tD_t u = D_x\overline{q}^{x}D_x u + f\rbrack^{n}_i
        \thinspace .
        
        

From this notation we immediately see what kind of differences that
each term is approximated with. The notation :math:`\overline{q}^{x}`
also specifies that the variable coefficient is approximated by
an arithmetic mean, the definition being
:math:`[\overline{q}^{x}]_{i+\frac{1}{2}}=(q_i+q_{i+1})/2`.
With the notation :math:`[D_xq D_x u]^n_i`,
we specify that :math:`q` is evaluated directly, as a function,
between the mesh points:
:math:`q(x_{i-\frac{1}{2}})` and :math:`q(x_{i+\frac{1}{2}})`.

Before any implementation, it remains to solve
:eq:`wave:pde2:var:c:scheme:op` with respect to :math:`u_i^{n+1}`:


.. math::
        
        u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber
        



.. math::
          
        \quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
        \frac{1}{2}(q_{i} + q_{i+1})(u_{i+1}^n - u_{i}^n) -
        \frac{1}{2}(q_{i} + q_{i-1})(u_{i}^n - u_{i-1}^n)\right)
        + \nonumber
        



.. math::
   :label: wave:pde2:var:c:scheme:impl
          
         \quad \Delta t^2 f^n_i
        \thinspace .
        
        



.. _wave:pde2:var:c:stability:

How a variable coefficient affects the stability
------------------------------------------------

The stability criterion derived in the section :ref:`wave:pde1:stability`
reads :math:`\Delta t\leq \Delta x/c`. If :math:`c=c(x)`, the criterion will depend
on the spatial location. We must therefore choose a :math:`\Delta t` that
is small enough such that no mesh cell has :math:`\Delta x/c(x) >\Delta t`.
That is, we must use the largest :math:`c` value in the criterion:


.. math::
        
        \Delta t \leq \beta \frac{\Delta x}{\max_{x\in [0,L]}c(x)}
        \thinspace .
        

The parameter :math:`\beta` is included as a safety factor: in some problems with a
significantly varying :math:`c` it turns out that one must choose :math:`\beta <1` to
have stable solutions (:math:`\beta =0.9` may act as an all-round value).

.. _wave:pde2:var:c:Neumann:

Neumann condition and a variable coefficient
--------------------------------------------

Consider a Neumann condition :math:`\partial u/\partial x=0` at :math:`x=L=N_x\Delta x`,
discretized as


.. math::
         \frac{u_{i+1}^{n} - u_{i-1}^n}{2\Delta x} = 0\quad u_{i+1}^n = u_{i-1}^n,
        

for :math:`i=N_x`. Using the scheme :eq:`wave:pde2:var:c:scheme:impl`
at the end point :math:`i=N_x` with :math:`u_{i+1}^n=u_{i-1}^n` results in


.. math::
        
        u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber
        



.. math::
          
        \quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
        q_{i+\frac{1}{2}}(u_{i-1}^n - u_{i}^n) -
        q_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right)
        + \nonumber
        



.. math::
          
         \quad \Delta t^2 f^n_i
        



.. math::
          
        = - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
        (q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}})(u_{i-1}^n - u_{i}^n) +
        \Delta t^2 f^n_i
        



.. math::
   :label: wave:pde2:var:c:scheme:impl:Neumann
          
        \approx - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
        2q_{i}(u_{i-1}^n - u_{i}^n) + \Delta t^2 f^n_i
        \thinspace .
        
        

Here we used the approximation


.. math::
        
        q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}} =
        q_i + \left(\frac{dq}{dx}\right)_i \Delta x
        + \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots
        +\nonumber
        



.. math::
          
        \quad q_i - \left(\frac{dq}{dx}\right)_i \Delta x
        + \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots\nonumber
        



.. math::
          
        = 2q_i + 2\left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + {\cal O}(\Delta x^4)
        \nonumber
        



.. math::
          
        \approx 2q_i
        \thinspace .
        


An alternative derivation may apply the arithmetic mean of :math:`q` in
:eq:`wave:pde2:var:c:scheme:impl`, leading to the term


.. math::
         (q_i + \frac{1}{2}(q_{i+1}+q_{i-1}))(u_{i-1}^n-u_i^n){\thinspace .}

Since :math:`\frac{1}{2}(q_{i+1}+q_{i-1}) = q_i + {\cal O}(\Delta x^2)`,
we end up with :math:`2q_i(u_{i-1}^n-u_i^n)` for :math:`i=N_x` as we did above.

A common technique in implementations of :math:`\partial u/\partial x=0`
boundary conditions is to assume :math:`dq/dx=0` as well. This implies
:math:`q_{i+1}=q_{i-1}` and :math:`q_{i+1/2}=q_{i-1/2}` for :math:`i=N_x`.
The implications for the scheme are



.. math::
        
        u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber
        



.. math::
          
        \quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
        q_{i+\frac{1}{2}}(u_{i-1}^n - u_{i}^n) -
        q_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right)
        + \nonumber
        



.. math::
          
         \quad \Delta t^2 f^n_i
        



.. math::
   :label: wave:pde2:var:c:scheme:impl:Neumann2
          
        = - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
        2q_{i-\frac{1}{2}}(u_{i-1}^n - u_{i}^n) +
        \Delta t^2 f^n_i
        \thinspace .
        
        


.. _wave:pde2:var:c:impl:

Implementation of variable coefficients
---------------------------------------

The implementation of the scheme with a variable wave velocity
may assume that :math:`c` is available as an array ``c[i]`` at
the spatial mesh points. The following loop is a straightforward
implementation of the scheme :eq:`wave:pde2:var:c:scheme:impl`:


.. code-block:: python

        for i in range(1, Nx):
            u[i] = - u_2[i] + 2*u_1[i] + \ 
                   C2*(0.5*(q[i] + q[i+1])*(u_1[i+1] - u_1[i])  - \ 
                       0.5*(q[i] + q[i-1])*(u_1[i] - u_1[i-1])) + \ 
                   dt2*f(x[i], t[n])

The coefficient ``C2`` is now defined as ``(dt/dx)**2`` and *not* as the
squared Courant number since the wave velocity is variable and appears
inside the parenthesis.

With Neumann conditions :math:`u_x=0` at the
boundary, we need to combine this scheme with the discrete
version of the boundary condition, as shown in the section :ref:`wave:pde2:var:c:Neumann`.
Nevertheless, it would be convenient to reuse the formula for the
interior points and just modify the indices ``ip1=i+1`` and ``im1=i-1``
as we did in the section :ref:`wave:pde2:Neumann:impl`. Assuming
:math:`dq/dx=0` at the boundaries, we can implement the scheme at
the boundary with the following code.



.. code-block:: python

        i = 0
        ip1 = i+1
        im1 = ip1
        u[i] = - u_2[i] + 2*u_1[i] + \ 
               C2*(0.5*(q[i] + q[ip1])*(u_1[ip1] - u_1[i])  - \ 
                   0.5*(q[i] + q[im1])*(u_1[i] - u_1[im1])) + \ 
               dt2*f(x[i], t[n])


With ghost cells we can just reuse the formula for the interior
points also at the boundary, provided that the ghost values of both
:math:`u` and :math:`q` are correctly updated to ensure :math:`u_x=0` and :math:`q_x=0`.

A vectorized version of the scheme with a variable coefficient
at internal points in the mesh becomes


.. code-block:: python

        u[1:-1] = - u_2[1:-1] + 2*u_1[1:-1] + \ 
                  C2*(0.5*(q[1:-1] + q[2:])*(u_1[2:] - u_1[1:-1]) -
                      0.5*(q[1:-1] + q[:-2])*(u_1[1:-1] - u_1[:-2])) + \ 
                  dt2*f(x[1:-1], t[n])



A more general model PDE with variable coefficients
---------------------------------------------------

Sometimes a wave PDE has a variable coefficient also in front of
the time-derivative term:


.. math::
   :label: wave:pde2:var:c:pde2
        
        \varrho(x)\frac{\partial^2 u}{\partial t^2} =
        \frac{\partial}{\partial x}\left( q(x)
        \frac{\partial u}{\partial x}\right) + f(x,t)
        
        \thinspace .
        

A natural scheme is


.. math::
        
        [\varrho D_tD_t u = D_x\overline{q}^xD_x u + f]^n_i
        \thinspace .
        

We realize that the :math:`\varrho` coefficient poses no particular
difficulty because the only value :math:`\varrho_i^n` enters the formula
above (when written out). There is hence no need for any averaging
of :math:`\varrho`. Often, :math:`\varrho` will be moved to the right-hand side,
also without any difficulty:


.. math::
        
        [D_tD_t u = \varrho^{-1}D_x\overline{q}^xD_x u + f]^n_i
        \thinspace .
        


Generalization: damping
-----------------------

Waves die out by two mechanisms. In 2D and 3D the energy of the wave
spreads out in space, and energy conservation then requires
the amplitude to decrease. This effect is not present in 1D.
Damping is another cause of amplitude reduction. For example,
the vibrations of a string die out because of damping due to
air resistance and non-elastic effects in the string.

The simplest way of including damping is to add a first-order derivative
to the equation (in the same way as friction forces enter a vibrating
mechanical system):

.. math::
   :label: wave:pde3
        
        \frac{\partial^2 u}{\partial t^2} + b\frac{\partial u}{\partial t} =
        c^2\frac{\partial^2 u}{\partial x^2}
         + f(x,t),
        
        

where :math:`b \geq 0` is a prescribed damping coefficient.

A typical discretization of :eq:`wave:pde3` in terms of centered
differences reads


.. math::
   :label: wave:pde3:fd
        
        [D_tD_t u + bD_{2t}u = c^2D_xD_x u + f]^n_i
        \thinspace .
        
        

Writing out the equation and solving for the unknown :math:`u^{n+1}_i`
gives the scheme


.. math::
   :label: wave:pde3:fd2
        
        u^{n+1}_i = (1 + \frac{1}{2}b\Delta t)^{-1}((\frac{1}{2}b\Delta t -1)
        u^{n-1}_i + 2u^n_i + C^2
        \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \Delta t^2 f^n_i),
        
        

for :math:`i\in{{\mathcal{I^i}_x}}` and :math:`n\geq 1`.
New equations must be derived for :math:`u^1_i`, and for boundary points in case
of Neumann conditions.

The damping is very small in many wave phenomena and then only evident
for very long time simulations. This makes the standard wave equation
without damping relevant for a lot of applications.


.. _wave:pde2:software:

Building a general 1D wave equation solver
==========================================

The program `wave1D_dn_vc.py <http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py>`_
is a fairly general code for 1D wave propagation problems that
targets the following initial-boundary value problem


.. math::
   :label: wave:pde2:software:ueq
        
        u_t = (c^2(x)u_x)_x + f(x,t),\quad x\in (0,L),\ t\in (0,T]
        
        



.. math::
          
        u(x,0) = I(x),\quad x\in [0,L]
        



.. math::
          
        u_t(x,0) = V(t),\quad x\in [0,L]
        



.. math::
          
        u(0,t) = U_0(t)\hbox{ or } u_x(0,t)=0,\quad t\in (0,T]
        



.. math::
   :label: wave:pde2:software:bcL
          
        u(L,t) = U_L(t)\hbox{ or } u_x(L,t)=0,\quad t\in (0,T]
        
        


The ``solver`` function is a natural extension of the simplest
``solver`` function in the initial ``wave1D_u0_s.py`` program,
extended with Neumann boundary conditions (:math:`u_x=0`),
a possibly time-varying boundary condition on :math:`u` (:math:`U_0(t)`, :math:`U_L(t)`),
and a variable wave velocity. The different code segments needed
to make these extensions are shown and commented upon in the
preceding text.

The vectorization is only applied inside the time loop, not for the
initial condition or the first time steps, since this initial work
is negligible for long time simulations in 1D problems.

The following sections explain various more advanced programming
techniques applied in the general 1D wave equation solver.

User action function as a class
-------------------------------

A useful feature in the ``wave1D_dn_vc.py`` program is the specification of
the ``user_action`` function as a class. Although the ``plot_u``
function in the ``viz`` function of previous ``wave1D*.py`` programs
remembers the local variables in the ``viz`` function, it is a
cleaner solution to store the needed variables together with
the function, which is exactly what a class offers.

A class for flexible plotting, cleaning up files, and making a movie
files like function ``viz`` and ``plot_u`` did can be coded as follows:


.. code-block:: python

        class PlotSolution:
            """
            Class for the user_action function in solver.
            Visualizes the solution only.
            """
            def __init__(self,
                         casename='tmp',    # Prefix in filenames
                         umin=-1, umax=1,   # Fixed range of y axis
                         pause_between_frames=None,  # Movie speed
                         backend='matplotlib',       # or 'gnuplot'
                         screen_movie=True, # Show movie on screen?
                         title='',          # Extra message in title
                         every_frame=1):    # Show every_frame frame
                self.casename = casename
                self.yaxis = [umin, umax]
                self.pause = pause_between_frames
                module = 'scitools.easyviz.' + backend + '_'
                exec('import %s as plt' % module)
                self.plt = plt
                self.screen_movie = screen_movie
                self.title = title
                self.every_frame = every_frame
        
                # Clean up old movie frames
                for filename in glob('frame_*.png'):
                    os.remove(filename)
        
            def __call__(self, u, x, t, n):
                if n % self.every_frame != 0:
                    return
                title = 't=%f' % t[n]
                if self.title:
                    title = self.title + ' ' + title
                self.plt.plot(x, u, 'r-',
                             xlabel='x', ylabel='u',
                             axis=[x[0], x[-1],
                                   self.yaxis[0], self.yaxis[1]],
                             title=title,
                             show=self.screen_movie)
                # pause
                if t[n] == 0:
                    time.sleep(2)  # let initial condition stay 2 s
                else:
                    if self.pause is None:
                        pause = 0.2 if u.size < 100 else 0
                    time.sleep(pause)
        
                self.plt.savefig('%s_frame_%04d.png' % (self.casename, n))

Understanding this class requires quite some familiarity with Python
in general and class programming in particular.

.. Since all the plot frames are to be collected in a separate subdirectory,

.. we demand a (logical) "casename" from the user that is used as

.. subdirectory name in the ``make_movie_file`` method. The statements

.. in this method perform actions normally done in the operating

.. system, but the Python interface via ``shutil.rmtree``, ``os.mkdir``,

.. ``os.chdir``, etc., works on all platforms where Python works.


The constructor shows how we can flexibly import the plotting engine
as (typically) ``scitools.easyviz.gnuplot_`` or
``scitools.easyviz.matplotlib_`` (note the trailing underscore).
With the ``screen_movie`` parameter
we can suppress displaying each movie frame on the screen.
Alternatively, for slow movies associated with
fine meshes, one can set
``every_frame`` to, e.g., 10, causing every 10 frames to be shown.

The ``__call__`` method makes ``PlotSolution`` instances behave like
functions, so we can just pass an instance, say ``p``, as the
``user_action`` argument in the ``solver`` function, and any call to
``user_action`` will be a call to ``p.__call__``.

Pulse propagation in two media
------------------------------

The function ``pulse`` in ``wave1D_dn_vc.py`` demonstrates wave motion in
heterogeneous media where :math:`c` varies. One can specify an interval
where the wave velocity is decreased by a factor ``slowness_factor``
(or increased by making this factor less than one).
Four types of initial conditions are available: a rectangular pulse (``plug``),
a Gaussian function (``gaussian``), a "cosine hat" consisting of one
period of the cosine function (``cosinehat``), and half a period of
a "cosine hat" (``half-cosinehat``). These peak-shaped initial
conditions can be placed in the middle (``loc='center'``) or at
the left end (``loc='left'``) of the domain. The ``pulse``
function is a flexible tool for playing around with various wave
shapes and location of a medium with a different wave velocity:


.. code-block:: python

        def pulse(C=1, Nx=200, animate=True, version='vectorized', T=2,
                  loc='center', pulse_tp='gaussian', slowness_factor=2,
                  medium=[0.7, 0.9], every_frame=1, sigma=0.05):
            """
            Various peaked-shaped initial conditions on [0,1].
            Wave velocity is decreased by the slowness_factor inside
            medium. The loc parameter can be 'center' or 'left',
            depending on where the initial pulse is to be located.
            The sigma parameter governs the width of the pulse.
            """
            # Use scaled parameters: L=1 for domain length, c_0=1
            # for wave velocity outside the domain.
            L = 1.0
            c_0 = 1.0
            if loc == 'center':
                xc = L/2
            elif loc == 'left':
                xc = 0
        
            if pulse_tp in ('gaussian','Gaussian'):
                def I(x):
                    return exp(-0.5*((x-xc)/sigma)**2)
            elif pulse_tp == 'plug':
                def I(x):
                    return 0 if abs(x-xc) > sigma else 1
            elif pulse_tp == 'cosinehat':
                def I(x):
                    # One period of a cosine
                    w = 2
                    a = w*sigma
                    return 0.5*(1 + cos(pi*(x-xc)/a)) \ 
                           if xc - a <= x <= xc + a else 0
        
            elif pulse_tp == 'half-cosinehat':
                def I(x):
                    # Half a period of a cosine
                    w = 4
                    a = w*sigma
                    return cos(pi*(x-xc)/a) \ 
                           if xc - 0.5*a <= x <= xc + 0.5*a else 0
            else:
                raise ValueError('Wrong pulse_tp="%s"' % pulse_tp)
        
            def c(x):
                return c_0/slowness_factor \ 
                       if medium[0] <= x <= medium[1] else c_0
        
            umin=-0.5; umax=1.5*I(xc)
            casename = '%s_Nx%s_sf%s' % \ 
                       (pulse_tp, Nx, slowness_factor)
            action = PlotMediumAndSolution(
                medium, casename=casename, umin=umin, umax=umax,
                every_frame=every_frame, screen_movie=animate)
        
            solver(I=I, V=None, f=None, c=c, U_0=None, U_L=None,
                   L=L, Nx=Nx, C=C, T=T,
                   user_action=action, version=version,
                   dt_safety_factor=1)

The ``PlotMediumAndSolution`` class used here is a subclass of
``PlotSolution`` where the medium with reduced :math:`c` value,
as specified by the ``medium`` interval,
is visualized in the plots.

The reader is encouraged to play around with the ``pulse`` function:


        >>> import wave1D_dn_vc as w
        >>> w.pulse(loc='left', pulse_tp='cosinehat', Nx=50, every_frame=10)

To easily kill the graphics by Ctrl-C and restart a new simulation it might be
easier to run the above two statements from the command line
with


.. code-block:: console

        Terminal> python -c 'import wave1D_dn_vc as w; w.pulse(...)'





Exercises  (2)
==============



.. --- begin exercise ---


.. _wave:exer:standingwave:damped:uex:

Exercise 6: Find the analytical solution to a damped wave equation
------------------------------------------------------------------

Consider the wave equation with damping :eq:`wave:pde3`.
The goal is to find an exact solution to a wave problem with damping.
A starting point is the standing wave solution from
:ref:`wave:exer:standingwave`. It becomes necessary to
include a damping term :math:`e^{-ct}` and also have both a sine and cosine
component in time:


.. math::
         {u_{\small\mbox{e}}}(x,t) =  e^{-\beta t}
        \sin kx \left( A\cos\omega t
        + B\sin\omega t\right)
        {\thinspace .}
        

Find :math:`k` from the boundary conditions
:math:`u(0,t)=u(L,t)=0`. Then use the PDE to find constraints on
:math:`\beta`, :math:`\omega`, :math:`A`, and :math:`B`.
Set up a complete initial-boundary value problem
and its solution.
Filename: ``damped_waves.pdf``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:exer:symmetry:bc:

Problem 7: Explore symmetry boundary conditions
-----------------------------------------------

Consider the simple "plug" wave where :math:`\Omega = [-L,L]` and


.. math::
         I(x) = \left\lbrace\begin{array}{ll}
        1, & x\in [-\delta, \delta],\\ 
        0, & \hbox{otherwise}
        \end{array}\right.
        

for some number :math:`0 < \delta < L`. The other initial condition is
:math:`u_t(x,0)=0` and there is no source term :math:`f`.
The boundary conditions can be set to :math:`u=0`.
The solution to this problem is symmetric around :math:`x=0`.
This means that we can simulate the wave process in only the half
of the domain :math:`[0,L]`.


*a)* Argue why the symmetry boundary condition
is :math:`u_x=0` at :math:`x=0`.

.. --- begin hint in exercise ---


*Hint.* Symmetry of a function about :math:`x=x_0` means that
:math:`f(x_0+h) = f(x_0-h)`.

.. --- end hint in exercise ---


*b)* Perform simulations of the complete wave problem from
on :math:`[-L,L]`. Thereafter, utilize the
symmetry of the solution and run a simulation
in half of the domain :math:`[0,L]`, using a boundary condition
at :math:`x=0`. Compare the two solutions and
make sure that they are the same.

*c)* Prove the symmetry property of the solution
by setting up the complete initial-boundary value problem
and showing that if :math:`u(x,t)` is a solution, then also :math:`u(-x,t)`
is a solution.

Filename: ``wave1D_symmetric``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:pulse1D:

Exercise 8: Send pulse waves through a layered medium
-----------------------------------------------------

Use the ``pulse`` function in ``wave1D_dn_vc.py`` to investigate
sending a pulse, located with its peak at :math:`x=0`, through the
medium to the right where it hits another medium for :math:`x\in [0.7,0.9]`
where the wave velocity is decreased by a factor :math:`s_f`.
Report what happens with a Gaussian pulse, a "cosine hat" pulse,
half a "cosine hat" pulse, and a plug pulse for resolutions
:math:`N_x=40,80,160`, and :math:`s_f=2,4`.  Use :math:`C=1`
in the medium outside :math:`[0.7,0.9]`. Simulate until :math:`T=2`.
Filename: ``pulse1D.py``.

.. --- end exercise ---





.. --- begin exercise ---


Exercise 9: Compare discretizations of a Neumann condition
----------------------------------------------------------

We have a 1D wave equation with variable wave velocity:
:math:`u_t=(qu_x)_x`.
A Neumann condition :math:`u_x` at :math:`x=0, L` can be
discretized as shown in :eq:`wave:pde2:var:c:scheme:impl:Neumann`
and :eq:`wave:pde2:var:c:scheme:impl:Neumann2`.

The aim of this exercise is to examine the rate of the numerical
error when using different ways of discretizing the Neumann condition.
As test problem, :math:`q=1+(x-L/2)^4` can be used, with :math:`f(x,t)`
adapted such that the solution has a simple form, say
:math:`u(x,t)=\cos (\pi x/L)\cos (\omega t)` for some :math:`\omega = \sqrt{q}\pi/L`.


*a)* Perform numerical experiments and find the convergence rate of the
error using
the approximation
and :eq:`wave:pde2:var:c:scheme:impl:Neumann2`.

*b)* Switch to :math:`q(x)=\cos(\pi x/L)`, which is symmetric at :math:`x=0,L`,
and check the convergence rate
of the scheme
:eq:`wave:pde2:var:c:scheme:impl:Neumann2`. Now,
:math:`q_{i-1/2}` is a 2nd-order approximation to :math:`q_i`,
:math:`q_{i-1/2}=q_i + 0.25q_i''\Delta x^2 + \cdots`, because :math:`q_i'=0`
for :math:`i=N_x` (a similar argument can be applied to the case :math:`i=0`).

*c)* A third discretization can be based on a simple and convenient,
but less accurate, one-sided difference:
:math:`u_{i}-u_{i-1}=0` at :math:`i=N_x` and :math:`u_{i+1}-u_i=0` at :math:`i=0`.
Derive the resulting scheme in detail and implement it.
Run experiments to establish the rate of convergence.

*d)* A fourth technique is to view the scheme as


.. math::
         [D_tD_tu]^n_i = \frac{1}{\Delta x}\left(
        [qD_xu]_{i+\frac{1}{2}}^n - [qD_xu]_{i-\frac{1}{2}}^n\right)
        + [f]_i^n,

and place the boundary at :math:`x_{i+\frac{1}{2}}`, :math:`i=N_x`, instead of
exactly at the physical boundary. With this idea,
we can just set :math:`[qD_xu]_{i+\frac{1}{2}}^n=0`. Derive the complete scheme
using this technique. The implementation of the boundary condition at
:math:`L-\Delta x/2` is :math:`{\mathcal{O}(\Delta x^2)}` accurate, but the interesting question
is what impact the movement of the boundary has on the convergence
rate (compute the errors as usual over the entire mesh).

.. --- end exercise ---



.. !split

.. 2DO


.. Explain the concepts of stability, convergence and consistence

.. in trunc and state here too.

.. Explain the relation between von Neumann stability analysis and

.. dispersion relations.


.. _wave:pde1:analysis:

Analysis of the difference equations
====================================

.. _wave:pde1:properties:

Properties of the solution of the wave equation
-----------------------------------------------

.. index::
   single: wave equation; 1D, analytical properties


The wave equation


.. math::
         \frac{\partial^2 u}{\partial t^2} =
        c^2 \frac{\partial^2 u}{\partial x^2}
        

has solutions of the form


.. math::
   :label: wave:pde1:gensol
        
        u(x,t) = g_R(x-ct) + g_L(x+ct),
        
        

for any functions :math:`g_R` and :math:`g_L` sufficiently smooth to be differentiated
twice. The result follows from inserting :eq:`wave:pde1:gensol`
in the wave equation. A function of the form :math:`g_R(x-ct)` represents a
signal
moving to the right in time with constant velocity :math:`c`.
This feature can be explained as follows.
At time :math:`t=0` the signal looks like :math:`g_R(x)`. Introducing a
moving :math:`x` axis with coordinates :math:`\xi = x-ct`, we see the function
:math:`g_R(\xi)` is "at rest"
in the :math:`\xi` coordinate system, and the shape is always
the same. Say the :math:`g_R(\xi)` function has a peak at :math:`\xi=0`. This peak
is located at :math:`x=ct`, which means that it moves with the velocity
:math:`dx/dt=c` in the :math:`x` coordinate system. Similarly, :math:`g_L(x+ct)`
is a function initially with shape :math:`g_L(x)` that moves in the negative
:math:`x` direction with constant velocity :math:`c` (introduce :math:`\xi=x+ct`,
look at the point :math:`\xi=0`, :math:`x=-ct`, which has velocity :math:`dx/dt=-c`).

With the particular initial conditions


.. math::
        
        u(x,0)=I(x),\quad \frac{\partial}{\partial t}u(x,0) =0,
        

we get, with :math:`u` as in :eq:`wave:pde1:gensol`,


.. math::
        
        g_R(x) + g_L(x) = I(x),\quad -cg_R'(x) + cg_L'(x) = 0,
        

which have the solution :math:`g_R=g_L=I/2`, and consequently


.. math::
   :label: wave:pde1:gensol2
        
        u(x,t) = \frac{1}{2} I(x-ct) + \frac{1}{2} I(x+ct) \thinspace .
        
        

The interpretation of :eq:`wave:pde1:gensol2` is that
the initial shape of :math:`u` is split into two parts, each with the same
shape as :math:`I` but half
of the initial amplitude. One part is traveling to the left and the
other one to the right.

.. raw:: html
        
        <div>
        <video  loop controls width='640' height='365' preload='none'>
        <source src='mov-wave/demo_BC_gaussian/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
        <source src='mov-wave/demo_BC_gaussian/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
        </video>
        </div>
        <p><em>Splitting of the initial profile into two waves.</em></p>



The solution has two important physical features: constant amplitude
of the left and right wave, and constant velocity of these two waves.
It turns out that the numerical solution will also preserve the
constant amplitude, but the velocity depends on the mesh parameters
:math:`\Delta t` and :math:`\Delta x`.

The solution :eq:`wave:pde1:gensol2` will be influenced by
boundary conditions when the parts
:math:`\frac{1}{2} I(x-ct)` and :math:`\frac{1}{2} I(x+ct)` hit the boundaries and get, e.g.,
reflected back into the domain. However, when :math:`I(x)` is nonzero
only in a small part in the middle
of the spatial domain :math:`[0,L]`, which means that the
boundaries are placed far away from the initial disturbance of :math:`u`,
the solution :eq:`wave:pde1:gensol2` is very clearly observed
in a simulation.

.. plug!


A useful representation of solutions of wave equations is a linear
combination of sine and/or cosine waves. Such a sum of waves is a
solution if the governing PDE is linear and each sine or cosine
wave fulfills the
equation.  To ease analytical calculations by hand we shall work with
complex exponential functions instead of real-valued sine or cosine
functions. The real part of complex expressions will typically be
taken as the physical relevant quantity (whenever a physical relevant
quantity is strictly needed).
The idea now is to build :math:`I(x)` of complex wave components
:math:`e^{ikx}`:

.. math::
   :label: wave:Fourier:I
         I(x) \approx \sum_{k\in K} b_k e^{ikx} \thinspace .
        
        

Here, :math:`k` is the frequency of a component,
:math:`K` is some set of all the discrete
:math:`k` values needed to approximate :math:`I(x)` well,
and :math:`b_k` are
constants that must be determined. We will very seldom
need to compute the :math:`b_k` coefficients: most of the insight
we look for and the understanding of the numerical methods we want to
establish, come from
investigating how the PDE and the scheme treat a single
component :math:`e^{ikx}` wave.

Letting the number of :math:`k` values in :math:`K` tend to infinity makes the sum
:eq:`wave:Fourier:I` converge to :math:`I(x)`, and this sum is known as a
*Fourier series* representation of :math:`I(x)`.  Looking at
:eq:`wave:pde1:gensol2`, we see that the solution :math:`u(x,t)`, when
:math:`I(x)` is represented as in :eq:`wave:Fourier:I`, is also built of
basic complex exponential wave components of the form :math:`e^{ik(x\pm
ct)}` according to


.. math::
   :label: wave:Fourier:u1
        
        u(x,t) = \frac{1}{2} \sum_{k\in K} b_k e^{ik(x - ct)}
        + \frac{1}{2} \sum_{k\in K} b_k e^{ik(x + ct)} \thinspace .
        
        

It is common to introduce the frequency in time :math:`\omega = kc` and
assume that :math:`u(x,t)` is a sum of basic wave components
written as :math:`e^{ikx -\omega t}`.
(Observe that inserting such a wave component in the governing PDE reveals that
:math:`\omega^2 = k^2c^2`, or :math:`\omega \pm kc`, reflecting the
two solutions: one (:math:`+kc`) traveling to the right and the other (:math:`-kc`)
traveling to the left.)

.. _wave:pde1:Fourier:

More precise definition of Fourier representations
--------------------------------------------------

.. index:: Fourier series


.. index:: Fourier transform


.. index:: discrete Fourier transform


The quick intuitive introduction above to representing a function by a sum
of sine and cosine waves suffices as background for the forthcoming
material on analyzing a single wave component. However, to understand
all details of how different wave components sum up to the analytical
and numerical solution, a more precise mathematical treatment is helpful
and therefore summarized below.

It is well known that periodic functions can be represented by
Fourier series. A generalization of the Fourier series idea to
non-periodic functions defined on the real line is the *Fourier transform*:



.. math::
   :label: wave:pde1:Fourier:I
        
        I(x) = \int_{-\infty}^\infty A(k)e^{ikx}dk,
         
        



.. math::
   :label: wave:pde1:Fourier:A
          
        A(k) = \int_{-\infty}^\infty I(x)e^{-ikx}dx{\thinspace .}
        
        

The function :math:`A(k)` reflects the weight of each wave component :math:`e^{ikx}`
in an infinite sum of such wave components. That is, :math:`A(k)`
reflects the frequency content in the function :math:`I(x)`. Fourier transforms
are particularly fundamental for analyzing and understanding time-varying
signals.

The solution of the linear 1D wave PDE can be expressed as


.. math::
         u(x,t) = \int_{-\infty}^\infty A(k)e^{i(kx-\omega(k)t)}dx{\thinspace .}


In a finite difference method, we represent :math:`u` by a mesh function
:math:`u^n_q`, where :math:`n` counts temporal mesh points and :math:`q` counts
the spatial ones (the usual counter for spatial points, :math:`i`, is
here already used as imaginary unit). Similarly, :math:`I(x)` is approximated by
the mesh function :math:`I_q`, :math:`q=0,\ldots,N_x`.
On a mesh, it does not make sense to work with wave
components :math:`e^{ikx}` for very large :math:`k`, because the shortest possible
sine or cosine wave that can be represented on a mesh with spacing :math:`\Delta x`
is the wave with wavelength :math:`2\Delta x` (the sine/cosine signal jumps
up and down between each mesh point). The corresponding :math:`k` value is
:math:`k=2\pi /(2\Delta x) = \pi/\Delta x`, known as the *Nyquist frequency*.
Within the range of
relevant frequencies :math:`(0,\pi/\Delta x]` one defines
the `discrete Fourier transform <http://en.wikipedia.org/wiki/Discrete_Fourier_transform>`_, using :math:`N_x+1` discrete frequencies:


.. math::
        
        I_q = \frac{1}{N_x+1}\sum_{k=0}^{N_x} A_k e^{i2\pi k j/(N_x+1)},\quad
        i=0,\ldots,N_x,
        



.. math::
          
        A_k = \sum_{q=0}^{N_x} I_q e^{-i2\pi k q/(N_x+1)},
        \quad k=0,\ldots,N_x+1{\thinspace .}
        

The :math:`A_k` values is the discrete Fourier transform of the :math:`I_q` values,
and the latter are the inverse discrete Fourier transform of the :math:`A_k`
values.

The discrete Fourier transform is efficiently computed by the
*Fast Fourier transform* algorithm. For a real function :math:`I(x)`
the relevant Python code for computing and plotting
the discrete Fourier transform appears in the example below.


.. code-block:: python

        import numpy as np
        from numpy import sin
        
        def I(x):
            return sin(2*pi*x) + 0.5*sin(4*pi*x) + 0.1*sin(6*pi*x)
        
        # Mesh
        L = 10; Nx = 100
        x = np.linspace(0, L, Nx+1)
        dx = L/float(Nx)
        
        # Discrete Fourier transform
        A = np.fft.rfft(I(x))
        A_amplitude = np.abs(A)
        
        # Compute the corresponding frequencies
        freqs = np.linspace(0, pi/dx, A_amplitude.size)
        
        import matplotlib.pyplot as plt
        plt.plot(freqs, A_amplitude)
        plt.show()


.. _wave:pde1:stability:

Stability
---------


.. index::
   single: wave equation; 1D, exact numerical solution


The scheme


.. math::
   :label: wave:pde1:analysis:scheme
        
        [D_tD_t u = c^2 D_xD_x u]^n_q
        
        

for the wave equation :math:`u_t = c^2u_{xx}` allows basic wave components


.. math::
         u^n_q=e^{i(kx_q - \tilde\omega t_n)} 

as solution, but it turns out that
the frequency in time, :math:`\tilde\omega`, is not equal to
the exact :math:`\omega = kc`.  The idea now is to study how the scheme treats
an arbitrary wave component with a given :math:`k`. We ask two key
questions:

 * How accurate is :math:`\tilde\omega`
   compared to :math:`\omega`?

 * Does the amplitude of such a wave component
   preserve its (unit) amplitude, as it should,
   or does it get amplified or damped in time (due to a complex :math:`\tilde\omega`)?

The following analysis will answer these questions.
Note the need for using :math:`q` as counter for the mesh point in :math:`x` direction
since :math:`i` is already used as the imaginary unit (in this analysis).

.. We use :math:`p` because we can then naturally continue with :math:`q` and :math:`r` as indices

.. in the :math:`y` and :math:`z` directions.


Preliminary results
~~~~~~~~~~~~~~~~~~~

A key result needed in the investigations is the finite difference
approximation of a second-order derivative acting on a complex
wave component:


.. math::
        
        [D_tD_t e^{i\omega t}]^n = -\frac{4}{\Delta t^2}\sin^2\left(
        \frac{\omega\Delta t}{2}\right)e^{i\omega n\Delta t}
        \thinspace .
        

By just changing symbols (:math:`\omega\rightarrow k`,
:math:`t\rightarrow x`, :math:`n\rightarrow q`) it follows that


.. math::
        
        [D_xD_x e^{ikx}]_q = -\frac{4}{\Delta x^2}\sin^2\left(
        \frac{k\Delta x}{2}\right)e^{ikq\Delta x} \thinspace .
        


Numerical wave propagation
~~~~~~~~~~~~~~~~~~~~~~~~~~

Inserting a basic wave component :math:`u^n_q=e^{i(kx_q-\tilde\omega t_n)}` in
:eq:`wave:pde1:analysis:scheme` results in the need to
evaluate two expressions:


.. math::
        
        \lbrack D_tD_t e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q = \lbrack D_tD_t e^{-i\tilde\omega t}\rbrack^ne^{ikq\Delta x}\nonumber
        



.. math::
          = -\frac{4}{\Delta t^2}\sin^2\left(
        \frac{\tilde\omega\Delta t}{2}\right)e^{-i\tilde\omega n\Delta t}e^{ikq\Delta x}
        



.. math::
          
        \lbrack D_xD_x e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q = \lbrack D_xD_x e^{ikx}\rbrack_q e^{-i\tilde\omega n\Delta t}\nonumber
        



.. math::
          = -\frac{4}{\Delta x^2}\sin^2\left(
        \frac{k\Delta x}{2}\right)e^{ikq\Delta x}e^{-i\tilde\omega n\Delta t} \thinspace . 

Then the complete scheme,


.. math::
        
        \lbrack D_tD_t e^{ikx}e^{-i\tilde\omega t} = c^2D_xD_x e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q
        

leads to the following equation for the unknown numerical
frequency :math:`\tilde\omega`
(after dividing by :math:`-e^{ikx}e^{-i\tilde\omega t}`):


.. math::
        
        \frac{4}{\Delta t^2}\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
        = c^2 \frac{4}{\Delta x^2}\sin^2\left(\frac{k\Delta x}{2}\right),
        

or


.. math::
   :label: wave:pde1:analysis:sineq1
        
        \sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
        = C^2\sin^2\left(\frac{k\Delta x}{2}\right),
        
        

where


.. index:: Courant number



.. math::
        
        C = \frac{c\Delta t}{\Delta x}
        

is the Courant number.
Taking the square root of :eq:`wave:pde1:analysis:sineq1` yields


.. math::
   :label: wave:pde1:analysis:sineq2
        
        \sin\left(\frac{\tilde\omega\Delta t}{2}\right)
        = C\sin\left(\frac{k\Delta x}{2}\right),
        
        

Since the exact :math:`\omega` is real it is reasonable to look for a real
solution :math:`\tilde\omega` of :eq:`wave:pde1:analysis:sineq2`.
The right-hand side of
:eq:`wave:pde1:analysis:sineq2` must then be in :math:`[-1,1]` because
the sine function on the left-hand side has values in :math:`[-1,1]`
for real :math:`\tilde\omega`. The sine function on
the right-hand side can attain the value 1 when


.. math::
        
        \frac{k\Delta x}{2} = m\frac{\pi}{2},\quad m\in\mathbb{Z}
        \thinspace .
        

With :math:`m=1` we have :math:`k\Delta x = \pi`, which means that
the wavelength :math:`\lambda = 2\pi/k` becomes :math:`2\Delta x`. This is
the absolutely shortest wavelength that can be represented on the mesh:
the wave jumps up and down between each mesh point. Larger values of :math:`|m|`
are irrelevant since these correspond to :math:`k` values whose
waves are too short to be represented
on a mesh with spacing :math:`\Delta x`.
For the shortest possible wave in the mesh, :math:`\sin\left(k\Delta x/2\right)=1`,
and we must require


.. index:: stability criterion


.. index::
   single: wave equation; 1D, stability



.. math::
   :label: wave:pde1:stability:crit
        
        C\leq 1 \thinspace .
        
        


Consider a right-hand side in :eq:`wave:pde1:analysis:sineq2` of
magnitude larger
than unity. The solution :math:`\tilde\omega` of :eq:`wave:pde1:analysis:sineq2`
.. see the chapter :ref:`sec:ode:o:eq1:analysis`

must then be a complex number
:math:`\tilde\omega = \tilde\omega_r + i\tilde\omega_i` because
the sine function is larger than unity for a complex argument.
One can show that for any :math:`\omega_i`  there will also be a
corresponding solution with :math:`-\omega_i`. The component with :math:`\omega_i>0`
gives an amplification factor :math:`e^{\omega_it}` that grows exponentially
in time. We cannot allow this and must therefore require :math:`C\leq 1`
as a *stability criterion*.



.. admonition:: Remark

   For smoother wave components with longer wave lengths per length :math:`\Delta x`,
   :eq:`wave:pde1:stability:crit` can in theory be relaxed. However,
   small round-off errors are always present in a numerical solution and these
   vary arbitrarily from mesh point to mesh point and can be viewed as
   unavoidable noise with wavelength :math:`2\Delta x`. As explained, :math:`C>1`
   will for this very small noise lead to exponential growth of
   the shortest possible wave component in the mesh. This noise will
   therefore grow with time and destroy the whole solution.


.. _wave:pde1:num:dispersion:

Numerical dispersion relation
-----------------------------

Equation :eq:`wave:pde1:analysis:sineq2` can be solved with respect
to :math:`\tilde\omega`:


.. math::
   :label: wave:pde1:disprel
        
        \tilde\omega = \frac{2}{\Delta t}
        \sin^{-1}\left( C\sin\left(\frac{k\Delta x}{2}\right)\right) \thinspace .
        
        

The relation between the numerical frequency :math:`\tilde\omega` and
the other parameters :math:`k`, :math:`c`, :math:`\Delta x`, and :math:`\Delta t` is called
a *numerical dispersion relation*. Correspondingly,
:math:`\omega =kc` is the *analytical dispersion relation*.

The special case :math:`C=1` deserves attention since then the right-hand side
of :eq:`wave:pde1:disprel` reduces to


.. math::
         \frac{2}{\Delta t}\frac{k\Delta x}{2} = \frac{1}{\Delta t}
        \frac{\omega\Delta x}{c} = \frac{\omega}{C} = \omega \thinspace . 

That is, :math:`\tilde\omega = \omega` and the numerical solution is exact
at all mesh points regardless of :math:`\Delta x` and :math:`\Delta t`!
This implies that the numerical solution method is also an analytical
solution method, at least for computing :math:`u` at discrete points (the
numerical method says nothing about the
variation of :math:`u` *between* the mesh points, and employing the
common linear interpolation for extending the discrete solution
gives a curve that deviates from the exact one).

For a closer examination of the error in the numerical dispersion
relation when :math:`C<1`, we can study
:math:`\tilde\omega -\omega`, :math:`\tilde\omega/\omega`, or the similar
error measures in wave velocity: :math:`\tilde c - c` and :math:`\tilde c/c`,
where :math:`c=\omega /k` and :math:`\tilde c = \tilde\omega /k`.
It appears that the most convenient expression to work with is :math:`\tilde c/c`:


.. math::
        
        \frac{\tilde c}{c} = \frac{1}{Cp}{\sin}^{-1}\left(C\sin p\right),
        

with :math:`p=k\Delta x/2` as a non-dimensional measure of the spatial frequency.
In essence, :math:`p` tells how many spatial mesh points we have per
wave length in space of the wave component with frequency :math:`k` (the wave
length is :math:`2\pi/k`). That is, :math:`p` reflects how well the
spatial variation of the wave component
is resolved in the mesh. Wave components with wave length
less than :math:`2\Delta x` (:math:`2\pi/k < 2\Delta x`) are not visible in the mesh,
so it does not make sense to have :math:`p>\pi/2`.

We may introduce the function :math:`r(C, p)=\tilde c/c` for further investigation
of numerical errors in the wave velocity:


.. math::
   :label: wave:pde1:disprel2
        
        r(C, p) = \frac{1}{Cp}{\sin}^{-1}\left(C\sin p\right), \quad C\in (0,1],\ p\in (0,\pi/2] \thinspace .
        
        

This function is very well suited for plotting since it combines several
parameters in the problem into a dependence on two non-dimensional
numbers, :math:`C` and :math:`p`.


.. _wave:pde1:fig:disprel:

.. figure:: disprel.png
   :width: 600

   *The fractional error in the wave velocity for different Courant numbers*


Defining


.. code-block:: python

        def r(C, p):
            return 2/(C*p)*asin(C*sin(p))

we can plot :math:`r(C,p)` as a function of :math:`p` for various values of
:math:`C`, see Figure :ref:`wave:pde1:fig:disprel`. Note that the shortest
waves have the most erroneous velocity, and that short waves move
more slowly than they should.

With ``sympy`` we can also easily make a Taylor series expansion in the
discretization parameter :math:`p`:


.. code-block:: text


        >>> C, p = symbols('C p')
        >>> rs = r(C, p).series(p, 0, 7)
        >>> print rs
        1 - p**2/6 + p**4/120 - p**6/5040 + C**2*p**2/6 -
        C**2*p**4/12 + 13*C**2*p**6/720 + 3*C**4*p**4/40 -
        C**4*p**6/16 + 5*C**6*p**6/112 + O(p**7)
        >>> # Factorize each term and drop the remainder O(...) term
        >>> rs_factored = [factor(term) for term in rs.lseries(p)]
        >>> rs_factored = sum(rs_factored)
        >>> print rs_factored
        p**6*(C - 1)*(C + 1)*(225*C**4 - 90*C**2 + 1)/5040 +
        p**4*(C - 1)*(C + 1)*(3*C - 1)*(3*C + 1)/120 +
        p**2*(C - 1)*(C + 1)/6 + 1

We see that :math:`C=1` makes all the terms in ``rs_factored`` vanish, except
the last one.
Since we already know that the numerical solution is exact for :math:`C=1`, the
remaining terms in the Taylor series expansion
will also contain factors of :math:`C-1` and cancel for :math:`C=1`.

From the ``rs_factored`` expression above we also see that the leading
order terms in the error of this series expansion are


.. math::
        
        \frac{1}{6}\left(\frac{k\Delta x}{2}\right)^2(C^2-1)
        = \frac{k^2}{24}\left( c^2\Delta t^2 - \Delta x^2\right),
        

pointing to an error :math:`{\mathcal{O}(\Delta t^2, \Delta x^2)}`, which is
compatible with the errors in the difference approximations (:math:`D_tD_t`
and :math:`D_xD_x`).

.. 2DO

.. Test that the exact solution is there for :math:`K=\{ 1, 3, 7\}`! Give the

.. :math:`k` values on the command line.



.. _wave:pde1:analysis:2D3D:

Extending the analysis to 2D and 3D
-----------------------------------

The typical analytical solution of a 2D wave equation


.. math::
         u_{tt} = c^2(u_{xx} + u_{yy}), 

is a wave traveling in the direction of :math:`\boldsymbol{k} = k_x\boldsymbol{i} + k_y\boldsymbol{j}`, where
:math:`\boldsymbol{i}` and :math:`\boldsymbol{j}` are unit vectors in the :math:`x` and :math:`y` directions, respectively.
Such a wave can be expressed by


.. math::
         u(x,y,t) = g(k_xx + k_yy - kct) 

for some twice differentiable function :math:`g`, or with :math:`\omega =kc`, :math:`k=|\boldsymbol{k}|`:


.. math::
         u(x,y,t) = g(k_xx + k_yy - \omega t){\thinspace .} 

We can in particular build a solution by adding complex Fourier components
of the form


.. math::
        
        \exp{(i(k_xx + k_yy - \omega t))}
        \thinspace .
        


A discrete 2D wave equation can be written as

.. math::
   :label: wave:pde1:analysis:scheme2D
        
        \lbrack D_tD_t u = c^2(D_xD_x u + D_yD_y u)\rbrack^n_{q,r}
        \thinspace .
        
        

This equation admits a Fourier component

.. math::
   :label: wave:pde1:analysis:numsol2D
        
        u^n_{q,r} = \exp{\left( i(k_x q\Delta x + k_y r\Delta y
        - \tilde\omega n\Delta t)\right)},
        
        

as solution. Letting the operators :math:`D_tD_t`, :math:`D_xD_x`, and :math:`D_yD_y`
act on :math:`u^n_{q,r}` from :eq:`wave:pde1:analysis:numsol2D` transforms
:eq:`wave:pde1:analysis:scheme2D` to

.. math::
        
        \frac{4}{\Delta t^2}\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
        = c^2 \frac{4}{\Delta x^2}\sin^2\left(\frac{k_x\Delta x}{2}\right)
        + c^2 \frac{4}{\Delta y^2}\sin^2\left(\frac{k_y\Delta y}{2}\right) \thinspace . 

or

.. math::
        
        \sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
        = C_x^2\sin^2 p_x
        + C_y^2\sin^2 p_y, 

where we have eliminated the factor 4 and introduced the symbols


.. math::
         C_x = \frac{c^2\Delta t^2}{\Delta x^2},\quad
        C_y = \frac{c^2\Delta t^2}{\Delta y^2}, \quad
        p_x = \frac{k_x\Delta x}{2},\quad
        p_y = \frac{k_y\Delta y}{2}{\thinspace .}
        

For a real-valued :math:`\tilde\omega` the right-hand side
must be less than or equal to unity in absolute value, requiring in general
that


.. math::
   :label: wave:pde1:analysis:2DstabC
        
        C_x^2 + C_y^2 \leq 1 \thinspace .
        
        

This gives the stability criterion, more commonly expressed directly
in an inequality for the time step:


.. math::
   :label: wave:pde1:analysis:2Dstab
        
        \Delta t \leq \frac{1}{c} \left( \frac{1}{\Delta x^2} +
        \frac{1}{\Delta y^2}\right)^{-{1/2}}
        
        

A similar, straightforward analysis for the 3D case leads to


.. math::
        
        \Delta t \leq \frac{1}{c}\left( \frac{1}{\Delta x^2} +
        \frac{1}{\Delta y^2} + \frac{1}{\Delta z^2}\right)^{-{1/2}}
        

In the case of a variable coefficient :math:`c^2=c^2(\boldsymbol{x})`, we must use
the worst-case value


.. math::
        
        \bar c = \sqrt{\max_{\boldsymbol{x}\in\Omega} c^2(\boldsymbol{x})}
        

in the stability criteria. Often, especially in the variable wave
velocity case, it is wise to introduce a safety factor :math:`\beta\in (0,1]` too:


.. math::
        
        \Delta t \leq \beta \frac{1}{\bar c}
        \left( \frac{1}{\Delta x^2} +
        \frac{1}{\Delta y^2} + \frac{1}{\Delta z^2}\right)^{-{1/2}}
        



The exact numerical dispersion relations in 2D and 3D becomes, for constant :math:`c`,


.. math::
        
        \tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(
        \left( C_x^2\sin^2 p_x + C_y^2\sin^ p_y\right)^{\frac{1}{2}}\right),
        



.. math::
          
        \tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(
        \left( C_x^2\sin^2 p_x + C_y^2\sin^ p_y + C_z^2\sin^ p_z\right)^{\frac{1}{2}}\right){\thinspace .}
        


We can visualize the numerical dispersion error in 2D much like we did
in 1D. To this end, we need to reduce the number of parameters in
:math:`\tilde\omega`. The direction of the wave is parameterized by the
polar angle :math:`\theta`, which means that


.. math::
         k_x = k\sin\theta,\quad k_y=k\cos\theta{\thinspace .}

A simplification is to set :math:`\Delta x=\Delta y=h`.
Then :math:`C_x=C_y=c\Delta t/h`, which we call :math:`C`. Also,


.. math::
         p_x=\frac{1}{2} kh\cos\theta,\quad p_y=\frac{1}{2} kh\sin\theta{\thinspace .}

The numerical frequency :math:`\tilde\omega`
is now a function of three parameters:

  * :math:`C` reflecting the number cells a wave is displaced during a time step

  * :math:`kh` reflecting the number of cells per wave length in space

  * :math:`\theta` expressing the direction of the wave

We want to visualize the error in the numerical frequency. To avoid having
:math:`\Delta t` as a free parameter in :math:`\tilde\omega`, we work with
:math:`\tilde c/c`, because the fraction :math:`2/\Delta t` is then rewritten as


.. math::
         \frac{2}{kc\Delta t} = \frac{2}{2kc\Delta t h/h} =
        \frac{1}{Ckh},

and


.. math::
         \frac{\tilde c}{c} = \frac{1}{Ckh}
        \sin^{-1}\left(C\left(\sin^2 (\frac{1}{2}kh\cos\theta)
        + \sin^2(\frac{1}{2}kh\sin\theta) \right)^{\frac{1}{2}}\right){\thinspace .}
        

We want to visualize this quantity as a function of
:math:`kh` and :math:`\theta` for some values of :math:`C\leq 1`. It is
instructive
to make color contour plots of :math:`1-\tilde c/c` in
*polar coordinates* with :math:`\theta` as the angular coordinate and
:math:`kh` as the radial coordinate.

The stability criterion :eq:`wave:pde1:analysis:2DstabC`
becomes :math:`C\leq C_{\max} = 1/\sqrt{2}` in the present 2D case with the
:math:`C` defined above. Let us plot :math:`1-\tilde c/c` in polar coordinates
for :math:`C_{\max}, 0.9C_{\max}, 0.5C_{\max}, 0.2C_{\max}`.
The program below does the somewhat tricky
work in Matplotlib, and the result appears
in Figure :ref:`wave:pde1:fig:disprel2D`. From the figure we clearly
see that the maximum :math:`C` value gives the best results, and that
waves whose propagation direction makes an angle of 45 degrees with
an axis are the most accurate.


.. code-block:: python

        def dispersion_relation_2D(kh, theta, C):
            arg = C*sqrt(sin(0.5*kh*cos(theta))**2 +
                         sin(0.5*kh*sin(theta))**2)
            c_frac = 2./(C*kh)*arcsin(arg)
        
            return c_frac
        
        from numpy import exp, sin, cos, linspace, \ 
             pi, meshgrid, arcsin, sqrt
        r = kh = linspace(0.001, pi, 101)
        theta = linspace(0, 2*pi, 51)
        r, theta = meshgrid(r, theta)
        
        # Make 2x2 filled contour plots for 4 values of C
        import matplotlib.pyplot as plt
        C_max = 1/sqrt(2)
        C = [[C_max, 0.9*C_max], [0.5*C_max, 0.2*C_max]]
        fix, axes = plt.subplots(2, 2, subplot_kw=dict(polar=True))
        for row in range(2):
            for column in range(2):
                error = 1 - dispersion_relation_2D(
                    kh, theta, C[row][column])
                print error.min(), error.max()
                cax = axes[row][column].contourf(
                    theta, r, error, 50, vmin=0, vmax=0.36)
                axes[row][column].set_xticks([])
                axes[row][column].set_yticks([])
        
        # Add colorbar to the last plot
        cbar = plt.colorbar(cax)
        cbar.ax.set_ylabel('error in wave velocity')
        plt.savefig('disprel2D.png')
        plt.savefig('disprel2D.pdf')
        plt.show()



.. _wave:pde1:fig:disprel2D:

.. figure:: disprel2D.png
   :width: 600

   *Error in numerical dispersion in 2D*



.. !split

.. _wave:2D3D:

Finite difference methods for 2D and 3D wave equations
======================================================

A natural next step is to consider extensions of the methods for
various
variants of the one-dimensional wave equation to two-dimensional (2D) and
three-dimensional (3D) versions of the wave equation.

.. _wave:2D3D:models:

Multi-dimensional wave equations
--------------------------------

The general wave equation in :math:`d` space dimensions, with constant
wave velocity :math:`c`,
can be written in the compact form


.. math::
   :label: wave:2D3D:model1
        
        \frac{\partial^2 u}{\partial t^2} = c^2\nabla^2 u\hbox{ for }\boldsymbol{x}\in\Omega\subset\mathbb{R}^d,\ t\in (0,T] \thinspace .
        
        

In a 2D problem (:math:`d=2`),


.. math::
         \nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
        \frac{\partial^2 u}{\partial y^2} ,

while in three space dimensions (:math:`d=3`),


.. math::
         \nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
        \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}
        \thinspace . 


Many applications involve variable coefficients, and the general
wave equation in :math:`d` dimensions is in this case written as


.. math::
   :label: wave:2D3D:model2
        
        \varrho\frac{\partial^2 u}{\partial t^2} = \nabla\cdot (q\nabla u) + f\hbox{ for }\boldsymbol{x}\in\Omega\subset\mathbb{R}^d,\ t\in (0,T],
        
        

which in 2D becomes


.. math::
        
        \varrho(x,y)
        \frac{\partial^2 u}{\partial t^2} =
        \frac{\partial}{\partial x}\left( q(x,y)
        \frac{\partial u}{\partial x}\right)
        +
        \frac{\partial}{\partial y}\left( q(x,y)
        \frac{\partial u}{\partial y}\right)
        + f(x,y,t)
        \thinspace .
        

To save some writing and space we may use the index notation, where
subscript :math:`t`, :math:`x`, :math:`y`, or :math:`z` means differentiation with respect
to that coordinate. For example,


.. math::
        
        \frac{\partial^2 u}{\partial t^2} &= u_{tt},\\ 
        \frac{\partial}{\partial y}\left( q(x,y)
        \frac{\partial u}{\partial y}\right) &= (q u_y)_y
        \thinspace .
        

The 3D versions of the
two model PDEs, with and without variable coefficients,
can with now with the aid of the index notation for differentiation
be stated as


.. math::
   :label: wave:2D3D:model1:v2
        
        u_{tt} = c^2(u_{xx} + u_{yy} + u_{zz}) + f,
        
        



.. math::
   :label: wave:2D3D:model2:v2
          
        \varrho u_{tt} = (q u_x)_x + (q u_z)_z + (q u_z)_z + f
        
        \thinspace .
        


At *each point* of the boundary :math:`\partial\Omega` of :math:`\Omega` we need
*one* boundary condition involving the unknown :math:`u`.
The boundary conditions are of three principal types:

 1. :math:`u` is prescribed (:math:`u=0` or a known time variation for
    an incoming wave),

 2. :math:`\partial u/\partial n = \boldsymbol{n}\cdot\nabla u` prescribed
    (zero for reflecting boundaries),

 3. an open boundary condition (also called radiation condition)
    is specified to let waves travel undisturbed out of the domain,
    see :ref:`wave:app:exer:tsunami1D:radiation` for details.

All the listed wave equations with *second-order* derivatives in
time need *two* initial conditions:

 1. :math:`u=I`,

 2. :math:`u_t = V`.

.. _wave:2D3D:mesh:

Mesh
----

We introduce a mesh in time and in space. The mesh in time consists
of time points


.. math::
         t_0=0 < t_1 <\cdots < t_{N_t},


often with a constant
spacing :math:`\Delta t= t_{n+1}-t_{n}`, :math:`n\in{{\mathcal{I^-}_t}}`.

Finite difference methods are easy to implement on simple
rectangle- or box-shaped
domains. More complicated shapes of the domain
require substantially more advanced techniques and
implementational efforts. On a rectangle- or box-shaped domain
mesh points are introduced separately in the various space directions:


.. math::
        
        &x_0 < x_1 <\cdots < x_{N_x}  \hbox{ in }x \hbox{ direction},\\ 
        &y_0 < y_1 <\cdots < y_{N_y}  \hbox{ in }y \hbox{ direction},\\ 
        &z_0 < z_1 <\cdots < z_{N_z}  \hbox{ in }z \hbox{ direction}{\thinspace .}
        

We can write a general mesh point as :math:`(x_i,y_j,z_k,t_n)`, with
:math:`i\in{\mathcal{I}_x}`, :math:`j\in{\mathcal{I}_y}`, :math:`k\in{\mathcal{I}_z}`, and :math:`n\in{\mathcal{I}_t}`.

It is a very common choice to use constant mesh spacings:
:math:`\Delta x = x_{i+1}-x_{i}`, :math:`i\in{{\mathcal{I^-}_x}}`,
:math:`\Delta y = y_{j+1}-y_{j}`, :math:`j\in{{\mathcal{I^-}_y}}`, and
:math:`\Delta z = z_{k+1}-z_{k}`, :math:`k\in{{\mathcal{I^-}_z}}`.
With equal mesh spacings one often introduces
:math:`h = \Delta x = \Delta y =\Delta z`.

The unknown :math:`u` at mesh point :math:`(x_i,y_j,z_k,t_n)` is denoted by
:math:`u^{n}_{i,j,k}`. In 2D problems we just skip the :math:`z` coordinate
(by assuming no variation in that direction: :math:`\partial/\partial z=0`)
and write :math:`u^n_{i,j}`.


.. _wave:2D3D:models:

Discretization
--------------

Two- and three-dimensional wave equations are easily discretized by
assembling building blocks for discretization of
1D wave equations, because the multi-dimensional versions just contain
terms of the same type that occurs in 1D.

Discretizing the PDEs
~~~~~~~~~~~~~~~~~~~~~

Equation :eq:`wave:2D3D:model1:v2` can be discretized as


.. math::
        
        [D_tD_t u = c^2(D_xD_x u + D_yD_yu + D_zD_z u) + f]^n_{i,j,k}
        \thinspace .
        

A 2D version might be instructive to write out in detail:


.. math::
        
        [D_tD_t u = c^2(D_xD_x u + D_yD_yu) + f]^n_{i,j,k},
        

which becomes


.. math::
        
        \frac{u^{n+1}_{i,j} - 2u^{n}_{i,j} + u^{n-1}_{i,j}}{\Delta t^2}
        = c^2
        \frac{u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}}{\Delta x^2}
        + c^2
        \frac{u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}}{\Delta y^2}
        + f^n_{i,j},
        

Assuming as usual that all values at the time levels :math:`n` and :math:`n-1`
are known, we can solve for the only unknown :math:`u^{n+1}_{i,j}`. The
result can be compactly written as


.. math::
   :label: wave:2D3D:models:unp1
        
        u^{n+1}_{i,j} = 2u^n_{i,j} + u^{n-1}_{i,j} + c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}{\thinspace .}
        
        


As in the 1D case, we need to develop a special formula for :math:`u^1_{i,j}`
where we combine the general scheme for :math:`u^{n+1}_{i,j}`, when :math:`n=0`,
with the discretization of the initial condition:


.. math::
         [D_{2t}u = V]^0_{i,j}\quad\Rightarrow\quad u^{-1}_{i,j} = u^1_{i,j} - 2\Delta t V_{i,j}
        \thinspace .
        

The result becomes, in compact form,


.. math::
   :label: wave:2D3D:models:u1
        
        u^{n+1}_{i,j} = u^n_{i,j} -2\Delta V_{i,j} + \frac{1}{2}
        c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}{\thinspace .}
        
        


The PDE :eq:`wave:2D3D:model2:v2`
with variable coefficients is discretized term by term using
the corresponding elements from the 1D case:


.. math::
        
        [\varrho D_tD_t u = (D_x\overline{q}^x D_x u +
        D_y\overline{q}^y D_yu + D_z\overline{q}^z D_z u) + f]^n_{i,j,k}
        \thinspace .
        

When written out and solved for the unknown :math:`u^{n+1}_{i,j,k}`, one gets the
scheme


.. math::
        
        u^{n+1}_{i,j,k} &= - u^{n-1}_{i,j,k}  + 2u^{n}_{i,j,k} + \\ 
        &= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i+1,j,k})(u^{n}_{i+1,j,k} - u^{n}_{i,j,k}) - \\ 
        &\qquad\quad \frac{1}{2}(q_{i-1,j,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i-1,j,k})) + \\ 
        &= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i,j+1,k})(u^{n}_{i,j+1,k} - u^{n}_{i,j,k}) - \\ 
        &\qquad\quad\frac{1}{2}(q_{i,j-1,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j-1,k})) + \\ 
        &= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i,j,k+1})(u^{n}_{i,j,k+1} - u^{n}_{i,j,k}) -\\ 
        &\qquad\quad \frac{1}{2}(q_{i,j,k-1} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j,k-1})) + \\ 
        + &\qquad \Delta t^2 f^n_{i,j,k}
        \thinspace .
        


Also here we need to develop a special formula for :math:`u^1_{i,j,k}`
by combining the scheme for :math:`n=0` with the discrete initial condition,
which is just a matter of inserting
:math:`u^{-1}_{i,j,k}=u^1_{i,j,k} - 2\Delta tV_{i,j,k}` in the scheme
and solving for :math:`u^1_{i,j,k}`.

Handling boundary conditions where is :math:`u` known
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The schemes listed above are valid for the internal points in the mesh.
After updating these, we need to visit all the mesh points at the
boundaries and set the prescribed :math:`u` value.

Discretizing the Neumann condition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The condition :math:`\partial u/\partial n = 0` was implemented in 1D by
discretizing it with a :math:`D_{2x}u` centered difference, and thereafter
eliminating the fictitious :math:`u` point outside the mesh by using the
general scheme at the boundary point. Alternatively, one can introduce
ghost cells and update a ghost value to for use in the Neumann
condition. Exactly the same ideas are reused in multi dimensions.

Consider  :math:`\partial u/\partial n = 0`
at a boundary :math:`y=0`. The normal direction is then in :math:`-y` direction,
so

.. math::
         \frac{\partial u}{\partial n} = -\frac{\partial u}{\partial y},

and we set


.. math::
         [-D_{2y} u = 0]^n_{i,0}\quad\Rightarrow\quad \frac{u^n_{i,1}-u^n_{i,-1}}{2\Delta y} = 0
        \thinspace .
        

From this it follows that :math:`u^n_{i,-1}=u^n_{i,1}`.
The discretized PDE at the boundary point :math:`(i,0)` reads


.. math::
        
        \frac{u^{n+1}_{i,0} - 2u^{n}_{i,0} + u^{n-1}_{i,0}}{\Delta t^2}
        = c^2
        \frac{u^{n}_{i+1,0} - 2u^{n}_{i,0} + u^{n}_{i-1,0}}{\Delta x^2}
        + c^2
        \frac{u^{n}_{i,1} - 2u^{n}_{i,0} + u^{n}_{i,-1}}{\Delta y^2}
        + f^n_{i,j},
        

We can then just insert :math:`u^1_{i,1}` for :math:`u^n_{i,-1}` in this equation
and then solve for the boundary value :math:`u^{n+1}_{i,0}` as done in 1D.

From these calculations, we see a pattern:
the general scheme applies at the boundary :math:`j=0` too if we just
replace :math:`j-1` by :math:`j+1`. Such a pattern is particularly useful for
implementations. The details follow from the explained 1D case
in the section :ref:`wave:pde2:Neumann:impl`.

The alternative approach to eliminating fictitious values outside the
mesh is to have :math:`u^n_{i,-1}` available as a ghost value.  The mesh is
extended with one extra line (2D) or plane (3D) of ghost cells at a
Neumann boundary. In the present example it means that we need a line
ghost cells below the :math:`y` axis.  The ghost values must be updated
according to :math:`u^{n+1}_{i,-1}=u^{n+1}_{i,1}`.




.. !split

.. _wave:2D3D:impl:

Implementation  (3)
===================


.. index::
   single: wave equation; 2D, implementation


We shall now describe in detail various Python implementations
for solving a standard 2D, linear wave equation with constant
wave velocity and :math:`u=0` on the
boundary. The wave equation is to be solved
in the space-time domain :math:`\Omega\times (0,T]`,
where :math:`\Omega = [0,L_x]\times [0,L_y]` is a rectangular spatial
domain. More precisely,
the complete initial-boundary value problem is defined by


.. math::
        
        u_t = c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad (x,y)\in \Omega,\ t\in (0,T],
        



.. math::
          
        u(x,y,0) = I(x,y),\quad (x,y)\in\Omega,
        



.. math::
          
        u_t(x,y,0) = V(x,y),\quad (x,y)\in\Omega,
        



.. math::
          
        u = 0,\quad (x,y)\in\partial\Omega,\ t\in (0,T],
        

where :math:`\partial\Omega` is the boundary of :math:`\Omega`, in this case
the four sides of the rectangle :math:`[0,L_x]\times [0,L_y]`:
:math:`x=0`, :math:`x=L_x`, :math:`y=0`, and :math:`y=L_y`.

The PDE is discretized as

.. math::
         [D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j},
        

which leads to an explicit updating formula to be implemented in a
program:


.. math::
        
        u^{n+1} = -u^{n-1}_{i,j} + 2u^n_{i,j} + \nonumber
        



.. math::
   :label: wave:2D3D:impl1:2Du0:ueq:discrete
          
        \quad C_x^2(
        u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}) + C_y^2
        (u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}) + \Delta t^2 f_{i,j}^n,
        
        

for all interior mesh points :math:`i\in{{\mathcal{I^i}_x}}` and
:math:`j\in{{\mathcal{I^i}_y}}`, and for :math:`n\in{{\mathcal{I^+}_t}}`.
The constants :math:`C_x` and :math:`C_y` are defined as


.. math::
         C_x = c\frac{\Delta t}{\Delta x},\quad C_x = c\frac{\Delta t}{\Delta y}
        \thinspace .
        


At the boundary we simply set :math:`u^{n+1}_{i,j}=0` for
:math:`i=0`, :math:`j=0,\ldots,N_y`; :math:`i=N_x`, :math:`j=0,\ldots,N_y`;
:math:`j=0`, :math:`i=0,\ldots,N_x`; and :math:`j=N_y`, :math:`i=0,\ldots,N_x`.
For the first step, :math:`n=0`, :eq:`wave:2D3D:impl1:2Du0:ueq:discrete`
is combined with the discretization of the initial condition :math:`u_t=V`,
:math:`[D_{2t} u = V]^0_{i,j}` to obtain a special formula for
:math:`u^1_{i,j}` at the interior mesh points:


.. math::
        
        u^{1} = u^0_{i,j} + \Delta t V_{i,j} + \nonumber
        



.. math::
   :label: wave:2D3D:impl1:2Du0:ueq:discrete
          
        \quad \frac{1}{2}C_x^2(
        u^{0}_{i+1,j} - 2u^{0}_{i,j} + u^{0}_{i-1,j}) + \frac{1}{2}C_y^2
        (u^{0}_{i,j+1} - 2u^{0}_{i,j} + u^{0}_{i,j-1}) + \frac{1}{2}\Delta t^2f_{i,j}^n,
        
        


The algorithm is very similar to the one in 1D:

1. Set initial condition :math:`u^0_{i,j}=I(x_i,y_j)`

2. Compute :math:`u^1_{i,j}` from :eq:`wave:2D3D:impl1:2Du0:ueq:discrete`

3. Set :math:`u^1_{i,j}=0` for the boundaries :math:`i=0,N_x`, :math:`j=0,N_y`

4. For :math:`n=1,2,\ldots,N_t`:

 1. Find :math:`u^{n+1}_{i,j}` from :eq:`wave:2D3D:impl1:2Du0:ueq:discrete`
    for all internal mesh points, :math:`i\in{{\mathcal{I^i}_x}}`, :math:`j\in{{\mathcal{I^i}_y}}`

 2. Set :math:`u^{n+1}_{i,j}=0` for the boundaries :math:`i=0,N_x`, :math:`j=0,N_y`


.. _wave2D3D:impl:scalar:

Scalar computations
-------------------

The ``solver`` function for a 2D case with constant wave velocity and
:math:`u=0` as boundary condition follows the setup from the similar
function for the 1D case in ``wave1D_u0_s.py``, but there are
a few necessary extensions. The code is in the program
`wave2D_u0.py <http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0.py>`_.

Domain and mesh
~~~~~~~~~~~~~~~

The spatial domain is now :math:`[0,L_x]\times [0,L_y]`, specified
by the arguments ``Lx`` and ``Ly``. Similarly, the number of mesh
points in the :math:`x` and :math:`y` directions,
:math:`N_x` and :math:`N_y`, become the arguments ``Nx`` and ``Ny``.
In multi-dimensional problems it makes less sense to specify a
Courant number as the wave velocity is a vector and the mesh spacings
may differ in the various spatial directions.
We therefore give :math:`\Delta t` explicitly. The signature of
the ``solver`` function is then


.. code-block:: python

        def solver(I, V, f, c, Lx, Ly, Nx, Ny, dt, T,
                   user_action=None, version='scalar'):

Key parameters used in the calculations are created as

.. code-block:: python

        x = linspace(0, Lx, Nx+1)                  # mesh points in x dir
        y = linspace(0, Ly, Ny+1)                  # mesh points in y dir
        dx = x[1] - x[0]
        dy = y[1] - y[0]
        Nt = int(round(T/float(dt)))
        t = linspace(0, N*dt, N+1)                 # mesh points in time
        Cx2 = (c*dt/dx)**2;  Cy2 = (c*dt/dy)**2    # help variables
        dt2 = dt**2


Solution arrays
~~~~~~~~~~~~~~~

We store :math:`u^{n+1}_{i,j}`, :math:`u^{n}_{i,j}`, and
:math:`u^{n-1}_{i,j}` in three two-dimensional arrays,


.. code-block:: python

        u   = zeros((Nx+1,Ny+1))   # solution array
        u_1 = zeros((Nx+1,Ny+1))   # solution at t-dt
        u_2 = zeros((Nx+1,Ny+1))   # solution at t-2*dt

where :math:`u^{n+1}_{i,j}` corresponds to ``u[i,j]``,
:math:`u^{n}_{i,j}` to ``u_1[i,j]``, and
:math:`u^{n-1}_{i,j}` to ``u_2[i,j]``


.. index:: index set notation


Index sets
~~~~~~~~~~

It is also convenient to introduce the index sets (cf. The section :ref:`wave:indexset`)


.. code-block:: python

        Ix = range(0, u.shape[0])
        Iy = range(0, u.shape[1])
        It = range(0, t.shape[0])


Computing the solution
~~~~~~~~~~~~~~~~~~~~~~

Inserting the initial
condition ``I`` in ``u_1`` and making a callback to the user in terms of
the ``user_action`` function is a straightforward generalization of
the 1D code from the section :ref:`wave:string:impl`:


.. code-block:: python

        for i in Ix:
            for j in Iy:
                u_1[i,j] = I(x[i], y[j])
        
        if user_action is not None:
            user_action(u_1, x, xv, y, yv, t, 0)

The ``user_action`` function has additional arguments compared to the
1D case. The arguments ``xv`` and ``yv`` fact will be commented
upon in the section :ref:`wave2D3D:impl:vectorized`.

The key finite difference formula :eq:`wave:2D3D:models:unp1`
for updating the solution at
a time level is implemented in a separate function as


.. code-block:: python

        def advance_scalar(u, u_1, u_2, f, x, y, t, n, Cx2, Cy2, dt,
                           V=None, step1=False):
            Ix = range(0, u.shape[0]);  Iy = range(0, u.shape[1])
            dt2 = dt**2
            if step1:
                Cx2 = 0.5*Cx2;  Cy2 = 0.5*Cy2; dt2 = 0.5*dt2
                D1 = 1;  D2 = 0
            else:
                D1 = 2;  D2 = 1
            for i in Ix[1:-1]:
                for j in Iy[1:-1]:
                    u_xx = u_1[i-1,j] - 2*u_1[i,j] + u_1[i+1,j]
                    u_yy = u_1[i,j-1] - 2*u_1[i,j] + u_1[i,j+1]
                    u[i,j] = D1*u_1[i,j] - D2*u_2[i,j] + \ 
                             Cx2*u_xx + Cy2*u_yy + dt2*f(x[i], y[j], t[n])
                    if step1:
                        u[i,j] += dt*V(x[i], y[j])
            # Boundary condition u=0
            j = Iy[0]
            for i in Ix: u[i,j] = 0
            j = Iy[-1]
            for i in Ix: u[i,j] = 0
            i = Ix[0]
            for j in Iy: u[i,j] = 0
            i = Ix[-1]
            for j in Iy: u[i,j] = 0
            return u

The ``step1`` variable has been introduced to allow the formula to be
reused for first step :math:`u^1_{i,j}`:


.. code-block:: python

        u = advance_scalar(u, u_1, u_2, f, x, y, t,
                           n, Cx2, Cy2, dt, V, step1=True)

Below, we will make many alternative implementations of the
``advance_scalar`` function to speed up the code since most of
the CPU time in simulations is spent in this function.


.. _wave2D3D:impl:vectorized:

Vectorized computations
-----------------------

The scalar code above turns out to be extremely slow for large 2D
meshes, and probably useless in 3D beyond debugging of small test cases.
Vectorization is therefore a must for multi-dimensional
finite difference computations in Python. For example,
with a mesh consisting of :math:`30\times 30` cells, vectorization
brings down the CPU time by a factor of 70 (!).

In the vectorized case we must be able to evaluate user-given functions
like :math:`I(x,y)` and :math:`f(x,y,t)`, provided as Python functions ``I(x,y)``
and ``f(x,y,t)``, for the entire mesh in one array operation.
Having the one-dimensional coordinate arrays ``x`` and ``y`` is not
sufficient: these must be extended to vectorized versions,


.. code-block:: python

        from numpy import newaxis
        xv = x[:,newaxis]
        yv = y[newaxis,:]
        # or
        xv = x.reshape((x.size, 1))
        yv = y.reshape((1, y.size))

This is a standard required technique when evaluating functions over
a 2D mesh, say ``sin(xv)*cos(xv)``, which then gives a result with shape
``(Nx+1,Ny+1)``.

With the ``xv`` and ``yv`` arrays for vectorized computing,
setting the initial condition is just a matter of


.. code-block:: python

        u_1[:,:] = I(xv, yv)

One could also have written ``u_1 = I(xv, yv)`` and let ``u_1`` point
to a new object, but vectorized operations often makes use of
direct insertion in the original array through ``u_1[:,:]`` because
sometimes not all of the array is to be filled by such a function
evaluation. This is the case with the computational scheme for :math:`u^{n+1}_{i,j}`:


.. code-block:: python

        def advance_vectorized(u, u_1, u_2, f_a, Cx2, Cy2, dt,
                               V=None, step1=False):
            dt2 = dt**2
            if step1:
                Cx2 = 0.5*Cx2;  Cy2 = 0.5*Cy2; dt2 = 0.5*dt2
                D1 = 1;  D2 = 0
            else:
                D1 = 2;  D2 = 1
            u_xx = u_1[:-2,1:-1] - 2*u_1[1:-1,1:-1] + u_1[2:,1:-1]
            u_yy = u_1[1:-1,:-2] - 2*u_1[1:-1,1:-1] + u_1[1:-1,2:]
            u[1:-1,1:-1] = D1*u_1[1:-1,1:-1] - D2*u_2[1:-1,1:-1] + \ 
                           Cx2*u_xx + Cy2*u_yy + dt2*f_a[1:-1,1:-1]
            if step1:
                u[1:-1,1:-1] += dt*V[1:-1, 1:-1]
            # Boundary condition u=0
            j = 0
            u[:,j] = 0
            j = u.shape[1]-1
            u[:,j] = 0
            i = 0
            u[i,:] = 0
            i = u.shape[0]-1
            u[i,:] = 0
            return u


Array slices in 2D are more complicated to understand than those in
1D, but the logic from 1D applies to each dimension separately.
For example, when doing :math:`u^{n}_{i,j} - u^{n}_{i-1,j}` for :math:`i\in{{\mathcal{I^+}_x}}`,
we just keep ``j`` constant and make a slice in the first index:
``u_1[1:,j] - u_1[:-1,j]``, exactly as in 1D. The ``1:`` slice
specifies all the indices :math:`i=1,2,\ldots,N_x` (up to the last
valid index),
while ``:-1`` specifies the relevant indices for the second term:
:math:`0,1,\ldots,N_x-1` (up to, but not including the last index).

In the above code segment, the situation is slightly more complicated,
because each displaced slice in one direction is
accompanied by a ``1:-1`` slice in the other direction. The reason is
that we only work with the internal points for the index that is
kept constant in a difference.

The boundary conditions along the four sides makes use of
a slice consisting of all indices along a boundary:


.. code-block:: python

        u[: ,0] = 0
        u[:,Ny] = 0
        u[0 ,:] = 0
        u[Nx,:] = 0


The ``f`` function is in the above vectorized update of ``u`` first computed
as an array over all mesh points:

.. code-block:: text


        f_a = f(xv, yv, t[n])

We could, alternatively, used the call ``f(xv, yv, t[n])[1:-1,1:-1]``
in the last term of the update statement, but other implementations
in compiled languages benefit from having ``f`` available in an array
rather than calling our Python function ``f(x,y,t)`` for
every point.

Also in the ``advance_vectorized`` function we have introduced a
boolean ``step1`` to reuse the formula for the first time step
in the same way as we did with ``advance_scalar``.
We refer to the ``solver`` function in ``wave2D_u0.py``
for the details on how the overall algorithm is implemented.

The callback function now has the arguments
``u, x, xv, y, yv, t, n``. The inclusion of ``xv`` and ``yv`` makes it
easy to, e.g., compute an exact 2D solution in the callback function
and compute errors, through an expression like
``u - exact_solution(xv, yv, t[n])``.

.. _wave2D3D:impl:verify:

Verification  (3)
-----------------

Testing a quadratic solution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The 1D solution from the section :ref:`wave:pde2:fd:verify:quadratic` can be
generalized to multi-dimensions and provides a test case where the
exact solution also fulfills the discrete equations such that we know
(to machine precision) what numbers the solver function should
produce. In 2D we use the following generalization of
:eq:`wave:pde2:fd:verify:quadratic:uex`:


.. math::
   :label: wave2D3D:impl:verify:quadratic
        
        {u_{\small\mbox{e}}}(x,y,t) = x(L_x-x)y(L_y-y)(1+\frac{1}{2}t)
        \thinspace .
        
        

This solution fulfills the PDE problem if :math:`I(x,y)={u_{\small\mbox{e}}}(x,y,0)`,
:math:`V=\frac{1}{2}{u_{\small\mbox{e}}}(x,y,0)`, and :math:`f=2c^2(1+\frac{1}{2}t)(y(L_y-y) +
x(L_x-x))`. To show that :math:`{u_{\small\mbox{e}}}` also solves the discrete equations,
we start with the general results :math:`[D_t D_t 1]^n=0`, :math:`[D_t D_t t]^n=0`,
and :math:`[D_t D_t t^2]=2`, and use these to compute


.. math::
         [D_xD_x {u_{\small\mbox{e}}}]^n_{i,j} = [y(L_y-y)(1+\frac{1}{2}t) D_xD_x x(L_x-x)]^n_{i,j}
        = y_j(L_y-y_j)(1+\frac{1}{2}t_n)2{\thinspace .}
        

A similar calculation must be carried out for the :math:`[D_yD_y
{u_{\small\mbox{e}}}]^n_{i,j}` and :math:`[D_tD_t {u_{\small\mbox{e}}}]^n_{i,j}` terms.  One must also show
that the quadratic solution fits the special formula for
:math:`u^1_{i,j}`. The details are left as :ref:`wave:exer:quadratic:2D`.
The ``test_quadratic`` function in the
`wave2D_u0.py <http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0.py>`_
program implements this verification as a nose test.


.. _wave2D3D:impl:Cython:

Migrating loops to Cython
=========================


.. index:: Cython


Although vectorization can bring down the CPU time dramatically
compared with scalar code, there is still some factor 5-10 to win
in these types of applications
by implementing the finite difference scheme in compiled code,
typically in Fortran, C, or C++. This can quite easily be done by
adding a little extra code to our program. Cython is an extension of
Python that offers the easiest way to nail our Python loops in the
scalar code down to machine code and the efficiency of C.

Cython can be viewed as an extended Python language where variables are
declared with types and where functions are marked to be implemented in C.
Migrating Python code to Cython is done by copying the desired code
segments to functions (or classes) and placing them in one or more separate
files with extension ``.pyx``.

Declaring variables and annotating the code
-------------------------------------------

Our starting point is the plain ``advance_scalar`` function for a scalar
implementation of the updating algorithm for new values
:math:`u^{n+1}_{i,j}`:


.. code-block:: python

        def advance_scalar(u, u_1, u_2, f, x, y, t, n, Cx2, Cy2, dt,
                           V=None, step1=False):
            Ix = range(0, u.shape[0]);  Iy = range(0, u.shape[1])
            dt2 = dt**2
            if step1:
                Cx2 = 0.5*Cx2;  Cy2 = 0.5*Cy2; dt2 = 0.5*dt2
                D1 = 1;  D2 = 0
            else:
                D1 = 2;  D2 = 1
            for i in Ix[1:-1]:
                for j in Iy[1:-1]:
                    u_xx = u_1[i-1,j] - 2*u_1[i,j] + u_1[i+1,j]
                    u_yy = u_1[i,j-1] - 2*u_1[i,j] + u_1[i,j+1]
                    u[i,j] = D1*u_1[i,j] - D2*u_2[i,j] + \ 
                             Cx2*u_xx + Cy2*u_yy + dt2*f(x[i], y[j], t[n])
                    if step1:
                        u[i,j] += dt*V(x[i], y[j])
            # Boundary condition u=0
            j = Iy[0]
            for i in Ix: u[i,j] = 0
            j = Iy[-1]
            for i in Ix: u[i,j] = 0
            i = Ix[0]
            for j in Iy: u[i,j] = 0
            i = Ix[-1]
            for j in Iy: u[i,j] = 0
            return u


We simply take
a copy of this function and put it in a file ``wave2D_u0_loop_cy.pyx``.
The relevant Cython implementation arises from declaring variables with
types and adding some important annotations to speed up array
computing in Cython. Let us first list the complete code in the
``.pyx`` file:


.. code-block:: cython

        import numpy as np
        cimport numpy as np
        cimport cython
        ctypedef np.float64_t DT    # data type
        
        @cython.boundscheck(False)  # turn off array bounds check
        @cython.wraparound(False)   # turn off negative indices (u[-1,-1])
        cpdef advance(
            np.ndarray[DT, ndim=2, mode='c'] u,
            np.ndarray[DT, ndim=2, mode='c'] u_1,
            np.ndarray[DT, ndim=2, mode='c'] u_2,
            np.ndarray[DT, ndim=2, mode='c'] f,
            double Cx2, double Cy2, double dt2):
        
            cdef int Nx, Ny, i, j
            cdef double u_xx, u_yy
            Nx = u.shape[0]-1
            Ny = u.shape[1]-1
            for i in range(1, Nx):
                for j in range(1, Ny):
                    u_xx = u_1[i-1,j] - 2*u_1[i,j] + u_1[i+1,j]
                    u_yy = u_1[i,j-1] - 2*u_1[i,j] + u_1[i,j+1]
                    u[i,j] = 2*u_1[i,j] - u_2[i,j] + \
                             Cx2*u_xx + Cy2*u_yy + dt2*f[i,j]
            # Boundary condition u=0
            j = 0
            for i in range(0, Nx+1): u[i,j] = 0
            j = Ny
            for i in range(0, Nx+1): u[i,j] = 0
            i = 0
            for j in range(0, Ny+1): u[i,j] = 0
            i = Nx
            for j in range(0, Ny+1): u[i,j] = 0
            return u



.. index:: declaration of variables in Cython


This example may act as a recipe on how to transform array-intensive
code with loops into Cython.

1. Variables are declared with types: for example,
   ``double v`` in the argument list instead of just ``v``, and ``cdef double v``
   for a variable ``v`` in the body of the function.
   A Python ``float`` object is declared as ``double`` for
   translation to C by Cython, while an ``int`` object is
   declared by ``int``.

2. Arrays need a comprehensive type declaration involving

   * the type ``np.ndarray``,

   * the data type of the elements, here 64-bit floats,
     abbreviated as ``DT`` through ``ctypedef np.float64_t DT``
     (instead of ``DT`` we could use the full name of the
     data type: ``np.float64_t``, which is a Cython-defined type),

   * the dimensions of the array, here ``ndim=2`` and ``ndim=1``,

   * specification of contiguous memory for the array (``mode='c'``).


3. Functions declared with ``cpdef`` are translated to C but also
   accessible from Python.

4. In addition to the standard ``numpy`` import we also need a special
   Cython import of ``numpy``: ``cimport numpy as np``, to appear *after*
   the standard import.

5. By default, array indices are checked to be within their legal
   limits. To speed up the code one should turn off this feature
   for a specific function by placing ``@cython.boundscheck(False)``
   above the function header.

6. Also by default, array indices can be negative (counting from the
   end), but this feature has a performance penalty and is therefore
   here turned off by writing ``@cython.wraparound(False)`` right above
   the function header.

7. The use of index sets ``Ix`` and ``Iy`` in the scalar code cannot be
   successfully translated to C, and constructions like ``Ix[1:-1]``
   involve negative indices, which are now turned off, so loops
   should use ``for i in xrange`` or ``for i in range``.

Visual inspection of the C translation
--------------------------------------


.. index:: cython -a (Python-C translation in HTML)


Cython can visually explain how successfully it can translate a code from
Python to C. The command


.. code-block:: console

        Terminal> cython -a wave2D_u0_loop_cy.pyx

produces an HTML file ``wave2D_u0_loop_cy.html``, which can be loaded into
a web browser to illustrate which lines of the code that have been
translated to C. Figure :ref:`wave:2D3D:impl:fig:cython:ma1` shows
the illustrated code. Yellow lines indicate the lines that Cython did not manage
to translate to efficient C code and that remain in Python.
For the present code we see that Cython is able to translate all the
loops with array computing to C, which is our primary goal.


.. _wave:2D3D:impl:fig:cython:ma1:

.. figure:: wave2D_u0_loop_cy1.png
   :width: 500

   *Visual illustration of Cython's ability to translate Python to C*


You can also inspect the generated C code directly, as it appears
in the file ``wave2D_u0_loop_cy.c``. Nevertheless,
understanding this C code requires some
familiarity with writing Python extension modules in C by hand.
Deep down in the file we can see in detail how the compute-intensive
statements are translated some complex C code that is quite different from
what we a human would write (at least if a direct correspondence to
the mathematics was in mind).


Building the extension module  (1)
----------------------------------


.. index:: C extension module


.. index:: setup.py


.. index:: distutils


Cython code must be translated to C, compiled, and linked to form what
is known in the Python world as a *C extension module*.
This is usually done by making a ``setup.py`` script, which
is the standard way of building and installing Python software.
For an extension module arising from Cython code, the following
``setup.py`` script is all we need to build and install the module:


.. code-block:: python

        from distutils.core import setup
        from distutils.extension import Extension
        from Cython.Distutils import build_ext
        
        cymodule = 'wave2D_u0_loop_cy'
        setup(
          name=cymodule
          ext_modules=[Extension(cymodule, [cymodule + '.pyx'],)],
          cmdclass={'build_ext': build_ext},
        )

We run the script by


.. code-block:: console

        Terminal> python setup.py build_ext --inplace

The ``--inplace`` option makes the extension module available in the
current directory as the file ``wave2D_u0_loop_cy.so``. This
file acts as a normal Python module that can be imported and inspected:


        >>> import wave2D_u0_loop_cy
        >>> dir(wave2D_u0_loop_cy)
        ['__builtins__', '__doc__', '__file__', '__name__',
         '__package__', '__test__', 'advance', 'np']

The important output from the ``dir`` function is our Cython function
``advance`` (the module also features the imported ``numpy`` module under
the name ``np`` as well as many standard Python objects with double
underscores in their names).

The ``setup.py`` file makes use of the ``distutils`` package in Python
and Cython's extension of this package.
These tools know how Python was built on the computer and will
use compatible compiler(s) and options when building other code
in Cython, C, or C++. Quite some experience with building large
program systems is needed to do the build process manually, so using
a ``setup.py`` script is strongly recommended.



.. admonition:: Simplified build of a Cython module

   When there is no need to link the C code with special libraries,
   Cython offers a shortcut for generating and importing the extension
   module:
   
   
   .. code-block:: python
   
           import pyximport; pyximport.install()
   
   This makes the ``setup.py`` script redundant. However, in the ``wave2D_u0.py``
   code we do not use ``pyximport`` and require an explicit build process
   of this and many other modules.


Calling the Cython function from Python
---------------------------------------

The ``wave2D_u0_loop_cy``
module contains our ``advance`` function, which we now may call from
the Python program for the wave equation:


.. code-block:: python

        import wave2D_u0_loop_cy
        advance = wave2D_u0_loop_cy.advance
        ...
        for n in It[1:-1:                  # time loop
            f_a[:,:] = f(xv, yv, t[n])     # precompute, size as u
            u = advance(u, u_1, u_2, f_a, x, y, t, Cx2, Cy2, dt2)


Efficiency  (1)
~~~~~~~~~~~~~~~

For a mesh consisting of :math:`120\times 120` cells, the scalar Python code
require 1370 CPU time units, the vectorized version requires 5.5,
while the Cython version requires only 1! For a smaller mesh with
:math:`60\times 60` cells Cython is about 1000 times faster than the scalar
Python code, and the vectorized version is about 6 times slower than
the Cython version.

.. In 3D these numbers are even more favorable.


Migrating loops to Fortran
==========================

Instead of relying on Cython's (excellent) ability to translate Python to C,
we can invoke a compiled language directly and write the loops ourselves.
Let us start with Fortran 77, because this is a language with more
convenient array handling than C (or plain C++). Or more precisely,
we can with ease program with the same multi-dimensional indices
in the Fortran code as in the ``numpy``
arrays in the Python code, while in C these arrays are
one-dimensional and requires us to reduce multi-dimensional indices
to a single index.

.. Fortran compilers

.. build on 60 years of intensive research on how to optimize loops with

.. array computations.


The Fortran subroutine
----------------------


.. index:: wrapper code


.. index:: Fortran subroutine


We write a Fortran subroutine ``advance`` in a file
`wave2D_u0_loop_f77.f <http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0_loop_f77.f>`_
for implementing the updating formula
:eq:`wave:2D3D:impl1:2Du0:ueq:discrete` and setting the solution to zero
at the boundaries:


.. code-block:: fortran

              subroutine advance(u, u_1, u_2, f, Cx2, Cy2, dt2, Nx, Ny)
              integer Nx, Ny
              real*8 u(0:Nx,0:Ny), u_1(0:Nx,0:Ny), u_2(0:Nx,0:Ny)
              real*8 f(0:Nx, 0:Ny), Cx2, Cy2, dt2
              integer i, j
        Cf2py intent(in, out) u
        
        C     Scheme at interior points
              do j = 1, Ny-1
                 do i = 1, Nx-1
                    u(i,j) = 2*u_1(i,j) - u_2(i,j) +
             &      Cx2*(u_1(i-1,j) - 2*u_1(i,j) + u_1(i+1,j)) +
             &      Cy2*(u_1(i,j-1) - 2*u_1(i,j) + u_1(i,j+1)) +
             &      dt2*f(i,j)
                 end do
              end do
        
        C     Boundary conditions
              j = 0
              do i = 0, Nx
                 u(i,j) = 0
              end do
              j = Ny
              do i = 0, Nx
                 u(i,j) = 0
              end do
              i = 0
              do j = 0, Ny
                 u(i,j) = 0
              end do
              i = Nx
              do j = 0, Ny
                 u(i,j) = 0
              end do
              return
              end

This code is plain Fortran 77, except for the special ``Cf2py`` comment
line, which here specifies that ``u`` is both an input argument *and*
an object to be returned from the ``advance`` routine. Or more
precisely, Fortran is not able return an array from a function,
but we need a *wrapper code* in C for the Fortran subroutine to enable
calling it from Python, and in this wrapper code one can return ``u``
to the calling Python code.



.. admonition:: Remark

   It is not strictly necessary to return ``u`` to the calling Python
   code since the ``advance`` function will modify the elements of ``u``,
   but the convention in Python is to get all output from a function
   as returned values. That is, the right way of calling the above
   Fortran subroutine from Python is
   
   
   .. code-block:: python
   
           u = advance(u, u_1, u_2, f, Cx2, Cy2, dt2)
   
   The less encouraged style, which works and resembles the way the
   Fortran subroutine is called from Fortran, reads
   
   
   .. code-block:: python
   
           advance(u, u_1, u_2, f, Cx2, Cy2, dt2)


Building the Fortran module with f2py
-------------------------------------

The nice feature of writing loops in Fortran is that the tool ``f2py``
can with very little work produce a C extension module such that
we can call the Fortran version of ``advance`` from Python.
The necessary commands to run are


.. code-block:: console

        Terminal> f2py -m wave2D_u0_loop_f77 -h wave2D_u0_loop_f77.pyf \ 
                  --overwrite-signature wave2D_u0_loop_f77.f
        Terminal> f2py -c wave2D_u0_loop_f77.pyf --build-dir build_f77 \ 
                  -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_f77.f

The first command asks ``f2py`` to interpret the Fortran code and make
a Fortran 90
specification of the extension module in the file
``wave2D_u0_loop_f77.pyf``. The second command makes
``f2py`` generate all necessary
wrapper code, compile our Fortran file and the wrapper code,
and finally build the module.
The build process takes place in the specified subdirectory ``build_f77``
so that files can be inspected if something goes wrong.
The option ``-DF2PY_REPORT_ON_ARRAY_COPY=1`` makes ``f2py`` write a message
for every array that is copied in the communication between Fortran and Python,
which is very useful for avoiding unnecessary array copying (see below).
The name of the module file
is ``wave2D_u0_loop_f77.so``, and this file can be imported and inspected
as any other
Python module:


        >>> import wave2D_u0_loop_f77
        >>> dir(wave2D_u0_loop_f77)
        ['__doc__', '__file__', '__name__', '__package__',
         '__version__', 'advance']
        >>> print wave2D_u0_loop_f77.__doc__
        This module 'wave2D_u0_loop_f77' is auto-generated with f2py....
        Functions:
          u = advance(u,u_1,u_2,f,cx2,cy2,dt2,
              nx=(shape(u,0)-1),ny=(shape(u,1)-1))





.. admonition:: Examine the doc strings

   Printing the doc strings of the module and its functions is
   extremely important after having created a module with ``f2py``,
   because ``f2py`` makes Python interfaces to the Fortran functions
   that are different from how the functions are declared in
   the Fortran code (!). The rationale for this behavior is that
   ``f2py`` creates *Pythonic* interfaces such that Fortran routines
   can be called in the same way as one calls Python functions.
   Output data from Python functions is always returned
   to the calling code, but this is technically impossible in Fortran.
   Also, arrays in Python are passed to Python functions without
   their dimensions because that information is packed with the array
   data in the array objects, but this is not possible in Fortran.
   Therefore, ``f2py`` removes array dimensions from the argument list,
   and ``f2py`` makes it possible to
   return objects back to Python.


Let us follow the advice of examining the doc strings
and take a close look at
the documentation ``f2py`` has generated for our Fortran ``advance``
subroutine:


        >>> print wave2D_u0_loop_f77.advance.__doc__
        This module 'wave2D_u0_loop_f77' is auto-generated with f2py
        Functions:
          u = advance(u,u_1,u_2,f,cx2,cy2,dt2,
                      nx=(shape(u,0)-1),ny=(shape(u,1)-1))
        .
        advance - Function signature:
          u = advance(u,u_1,u_2,f,cx2,cy2,dt2,[nx,ny])
        Required arguments:
          u : input rank-2 array('d') with bounds (nx + 1,ny + 1)
          u_1 : input rank-2 array('d') with bounds (nx + 1,ny + 1)
          u_2 : input rank-2 array('d') with bounds (nx + 1,ny + 1)
          f : input rank-2 array('d') with bounds (nx + 1,ny + 1)
          cx2 : input float
          cy2 : input float
          dt2 : input float
        Optional arguments:
          nx := (shape(u,0)-1) input int
          ny := (shape(u,1)-1) input int
        Return objects:
          u : rank-2 array('d') with bounds (nx + 1,ny + 1)

Here we see that the ``nx`` and ``ny`` parameters declared in
Fortran are optional arguments that can be omitted when calling
``advance`` from Python.

We strongly recommend to print out the
documentation of *every* Fortran function to be called from Python
and make sure the call syntax is exactly as listed in the
documentation.


How to avoid array copying
--------------------------


.. index:: row-major ordering


.. index:: column-major ordering


.. index:: Fortran array storage


.. index:: C/Python array storage


Multi-dimensional arrays are stored as a stream of numbers in memory.
For a two-dimensional array consisting of rows and columns there are
two ways of creating such a stream: *row-major ordering*, which means
that rows are stored consecutively in memory, or *column-major
ordering*, which means that the columns are stored one after each other.
All programming languages inherited from C, including Python, apply
the row-major ordering, but Fortran uses column-major storage.
Thinking of a two-dimensional array in Python or C
as a matrix, it means that Fortran
works with the transposed matrix.

Fortunately, ``f2py`` creates extra code so that accessing ``u(i,j)`` in
the Fortran subroutine corresponds to the element ``u[i,j]`` in the
underlying ``numpy`` array (without the extra code, ``u(i,j)`` in Fortran
would access ``u[j,i]`` in the ``numpy`` array).  Technically, ``f2py``
takes a copy of our ``numpy`` array and reorders the data before
sending the array to Fortran. Such copying can be costly. For 2D wave
simulations on a :math:`60\times 60` grid the overhead of copying is a
factor of 5, which means that almost the whole performance gain of
Fortran over vectorized ``numpy`` code is lost!

To avoid having ``f2py`` to copy
arrays with C storage to the corresponding Fortran storage, we declare
the arrays with Fortran storage:


.. code-block:: python

        order = 'Fortran' if version == 'f77' else 'C'
        u   = zeros((Nx+1,Ny+1), order=order)   # solution array
        u_1 = zeros((Nx+1,Ny+1), order=order)   # solution at t-dt
        u_2 = zeros((Nx+1,Ny+1), order=order)   # solution at t-2*dt



In the compile and build step of using ``f2py``, it is recommended to add
an extra option for making ``f2py`` report on array copying:


.. code-block:: console

        Terminal> f2py -c wave2D_u0_loop_f77.pyf --build-dir build_f77 \ 
                  -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_f77.f


It can sometimes be a challenge to track down which array that causes
a copying. There are two principal reasons for copying array data:
either the array does not have Fortran storage or the element types do
not match those declared in the Fortran code. The latter cause is
usually effectively eliminated by using ``real*8`` data in the Fortran
code and ``float64`` (the default ``float`` type in ``numpy``) in the arrays
on the Python side. The former reason is more common, and to check
whether an array before a Fortran call has the right storage one can
print the result of ``isfortran(a)``, which is ``True`` if the array ``a``
has Fortran storage.

Let us look at an example where we face problems with array storage.
A typical problem in the ``wave2D_u0.py`` code is
to set


.. code-block:: python

        f_a = f(xv, yv, t[n])

before the call to the Fortran ``advance`` routine. This computation creates
a new array with C storage. An undesired copy of ``f_a`` will be produced
when sending ``f_a`` to a Fortran routine.
There are two remedies, either direct insertion
of data in an array with Fortran storage,

.. code-block:: python

        f_a = zeros((Nx+1, Ny+1), order='Fortran')
        ...
        f_a[:,:] = f(xv, yv, t[n])

or remaking the ``f(xv, yv, t[n])`` array,

.. code-block:: python

        f_a = asarray(f(xv, yv, t[n]), order='Fortran')

The former remedy is most efficient if the ``asarray`` operation is to
be performed a large number of times.

Efficiency  (2)
~~~~~~~~~~~~~~~

The efficiency of this Fortran code is very similar to the Cython code.
There is usually nothing more to gain, from a computational efficiency
point of view, by implementing the *complete* Python program in Fortran
or C. That will just be a lot more code for all administering work
that is needed in scientific software, especially if we extend our
sample program ``wave2D_u0.py`` to handle a real scientific problem.
Then only a small portion will consist of loops with intensive
array calculations. These can be migrated to Cython or Fortran as
explained, while the rest of the programming can be more conveniently
done in Python.


Migrating loops to C via Cython
===============================

The computationally intensive loops can alternatively be implemented
in C code. Just as Fortran calls for care regarding the storage of
two-dimensional arrays, working with two-dimensional arrays in C
is a bit tricky. The reason is that
``numpy`` arrays are viewed as one-dimensional arrays when
transferred to C, while C programmers will think of ``u``, ``u_1``, and
``u_2`` as two dimensional arrays and index them like ``u[i][j]``.
The C code must declare ``u`` as ``double* u`` and translate an index
pair ``[i][j]`` to a corresponding single index when ``u`` is
viewed as one-dimensional. This translation requires knowledge of
how the numbers in ``u`` are stored in memory.

Translating index pairs to single indices
-----------------------------------------

Two-dimensional ``numpy`` arrays with the default C storage are stored
row by row. In general, multi-dimensional arrays with C storage are
stored such that the last index has the fastest variation, then the
next last index, and so on, ending up with the slowest variation
in the first index. For a two-dimensional ``u`` declared as
``zeros((Nx+1,Ny+1))`` in Python, the individual elements are stored
in the following order:


.. code-block:: python

        u[0,0], u[0,1], u[0,2], ..., u[0,Ny], u[1,0], u[1,1], ...,
        u[1,Ny], u[2,0], ..., u[Nx,0], u[Nx,1], ..., u[Nx, Ny]


Viewing ``u`` as one-dimensional, the index pair :math:`(i,j)` translates
to :math:`i(N_y+1)+j`. So, where a C programmer would naturally write
an index ``u[i][j]``, the indexing must read ``u[i*(Ny+1) + j]``.
This is tedious to write, so it can be handy to define a C macro,


.. code-block:: c

        #define idx(i,j) (i)*(Ny+1) + j

so that we can write ``u[idx(i,j)]``, which reads much better and is
easier to debug.



.. admonition:: Be careful with macro definitions

   Macros just perform simple text substitutions:
   ``idx(hello,world)`` is expanded to ``(hello)*(Ny+1) + world``.
   The parenthesis in ``(i)`` are essential - using the natural mathematical
   formula ``i*(Ny+1) + j`` in the macro definition,
   ``idx(i-1,j)`` would expand to ``i-1*(Ny+1) + j``, which is the wrong
   formula. Macros are handy, but requires careful use.
   In C++, inline functions are safer and replace the need for macros.


The complete C code
-------------------

The C version of our function ``advance`` can be coded as follows.


.. code-block:: c

        #define idx(i,j) (i)*(Ny+1) + j
        
        void advance(double* u, double* u_1, double* u_2, double* f,
        	     double Cx2, double Cy2, double dt2,
        	     int Nx, int Ny)
        {
          int i, j;
          /* Scheme at interior points */
          for (i=1; i<=Nx-1; i++) {
            for (j=1; j<=Ny-1; j++) {
                u[idx(i,j)] = 2*u_1[idx(i,j)] - u_2[idx(i,j)] +
                Cx2*(u_1[idx(i-1,j)] - 2*u_1[idx(i,j)] + u_1[idx(i+1,j)]) +
                Cy2*(u_1[idx(i,j-1)] - 2*u_1[idx(i,j)] + u_1[idx(i,j+1)]) +
                dt2*f[idx(i,j)];
        	}
            }
          }
          /* Boundary conditions */
          j = 0;  for (i=0; i<=Nx; i++) u[idx(i,j)] = 0;
          j = Ny; for (i=0; i<=Nx; i++) u[idx(i,j)] = 0;
          i = 0;  for (j=0; j<=Ny; j++) u[idx(i,j)] = 0;
          i = Nx; for (j=0; j<=Ny; j++) u[idx(i,j)] = 0;
        }


The Cython interface file
-------------------------

All the code above appears in a file `wave2D_u0_loop_c.c <http://tinyurl.com/jvzzcfn/wave//wave2D_u0/wave2D_u0_loop_c.c>`_.
We need to compile this file together with C wrapper code such that
``advance`` can be called from Python. Cython can be used to generate
appropriate wrapper code.
The relevant Cython code for interfacing C is
placed in a file with extension ``.pyx``. Here this file, called
`wave2D_u0_loop_c_cy.pyx <http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0_loop_c_cy.pyx>`_, looks like


.. code-block:: cython

        import numpy as np
        cimport numpy as np
        cimport cython
        
        cdef extern from "wave2D_u0_loop_c.h":
            void advance(double* u, double* u_1, double* u_2, double* f,
                         double Cx2, double Cy2, double dt2,
                         int Nx, int Ny)
        
        @cython.boundscheck(False)
        @cython.wraparound(False)
        def advance_cwrap(
            np.ndarray[double, ndim=2, mode='c'] u,
            np.ndarray[double, ndim=2, mode='c'] u_1,
            np.ndarray[double, ndim=2, mode='c'] u_2,
            np.ndarray[double, ndim=2, mode='c'] f,
            double Cx2, double Cy2, double dt2):
            advance(&u[0,0], &u_1[0,0], &u_2[0,0], &f[0,0],
                    Cx2, Cy2, dt2,
                    u.shape[0]-1, u.shape[1]-1)
            return u

We first declare the C functions to be interfaced.
These must also appear in a C header file, `wave2D_u0_loop_c.h <http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0_loop_c.h>`_,


.. code-block:: c++

        extern void advance(double* u, double* u_1, double* u_2, double* f,
        		    double Cx2, double Cy2, double dt2,
        		    int Nx, int Ny);

The next step is to write a Cython function with Python objects as arguments.
The name ``advance`` is already used for the C function so the function
to be called from Python is named ``advance_cwrap``. The contents of
this function is simply a call to the ``advance`` version in C. To this end,
the right information from the Python objects must be passed on as
arguments to ``advance``. Arrays are sent with their C pointers to the
first element, obtained in Cython as ``&u[0,0]`` (the ``&`` takes the
address of a C variable). The ``Nx`` and ``Ny`` arguments in ``advance`` are
easily obtained from the shape of the ``numpy`` array ``u``.
Finally, ``u`` must be returned such that we can set ``u = advance(...)``
in Python.

Building the extension module  (2)
----------------------------------

It remains to build the extension module. An appropriate
``setup.py`` file is


.. code-block:: python

        from distutils.core import setup
        from distutils.extension import Extension
        from Cython.Distutils import build_ext
        
        sources = ['wave2D_u0_loop_c.c', 'wave2D_u0_loop_c_cy.pyx']
        module = 'wave2D_u0_loop_c_cy'
        setup(
          name=module,
          ext_modules=[Extension(module, sources,
                                 libraries=[], # C libs to link with
                                 )],
          cmdclass={'build_ext': build_ext},
        )

All we need to specify is the ``.c`` file(s) and the ``.pyx`` interface
file. Cython is automatically run to generate the necessary wrapper
code. Files are then compiled and linked to an extension module
residing in the file ``wave2D_u0_loop_c_cy.so``. Here is a
session with running ``setup.py``
and examining the resulting module in Python


.. code-block:: console

        Terminal> python setup.py build_ext --inplace
        Terminal> python
        >>> import wave2D_u0_loop_c_cy as m
        >>> dir(m)
        ['__builtins__', '__doc__', '__file__', '__name__', '__package__',
         '__test__', 'advance_cwrap', 'np']

The call to the C version of ``advance`` can go like this in Python:


.. code-block:: python

        import wave2D_u0_loop_c_cy
        advance = wave2D_u0_loop_c_cy.advance_cwrap
        ...
        f_a[:,:] = f(xv, yv, t[n])
        u = advance(u, u_1, u_2, f_a, Cx2, Cy2, dt2)


Efficiency  (3)
~~~~~~~~~~~~~~~

In this example, the C and Fortran code runs at the same speed, and there
are no significant differences in the efficiency of the wrapper code.
The overhead implied by the wrapper code is negligible as long as
we do not work with very small meshes and consequently little numerical
work in the ``advance`` function.

Migrating loops to C via f2py
=============================

An alternative to using Cython for interfacing C code is to apply
``f2py``. The C code is the same, just the details of specifying how
it is to be called from Python differ. The ``f2py`` tool requires
the call specification to be a Fortran 90 module defined in a ``.pyf``
file. This file was automatically generated when we interfaced a
Fortran subroutine. With a C function we need to write this module
ourselves, or we can use a trick and let ``f2py`` generate it for us.
The trick consists in writing the signature of the C function with
Fortran syntax and place it in a Fortran file, here
``wave2D_u0_loop_c_f2py_signature.f``:


.. code-block:: fortran

              subroutine advance(u, u_1, u_2, f, Cx2, Cy2, dt2, Nx, Ny)
        Cf2py intent(c) advance
              integer Nx, Ny, N
              real*8 u(0:Nx,0:Ny), u_1(0:Nx,0:Ny), u_2(0:Nx,0:Ny)
              real*8 f(0:Nx, 0:Ny), Cx2, Cy2, dt2
        Cf2py intent(in, out) u
        Cf2py intent(c) u, u_1, u_2, f, Cx2, Cy2, dt2, Nx, Ny
              return
              end

Note that we need a special ``f2py`` instruction, through a ``Cf2py``
comment line, for telling that all the function arguments are
C variables. We also need to specify that the function is actually
in C: ``intent(c) advance``.

Since ``f2py`` is just concerned with the function signature and not the
complete contents of the function body, it can easily generate the
Fortran 90 module specification based solely on the signature above:


.. code-block:: console

        Terminal> f2py -m wave2D_u0_loop_c_f2py \ 
                  -h wave2D_u0_loop_c_f2py.pyf --overwrite-signature \ 
                  wave2D_u0_loop_c_f2py_signature.f

The compile and build step is as for the Fortran code, except that we
list C files instead of Fortran files:


.. code-block:: console

        Terminal> f2py -c wave2D_u0_loop_c_f2py.pyf \ 
                  --build-dir tmp_build_c \ 
                  -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_c.c

As when interfacing Fortran code with ``f2py``, we need to print out
the doc string to see the exact call syntax from the Python side.
This doc string is identical for the C and Fortran versions of
``advance``.

.. No worries with transposed storage, copy of arrays can only take

.. place if the type don't match


.. ===== Migrating loops to C via Instant =====


Migrating loops to C++ via f2py
-------------------------------

C++ is a much more versatile language than C or Fortran and has over
the last two decades become very popular for numerical computing.
Many will therefore prefer to migrate compute-intensive Python code
to C++. This is, in principle, easy: just write the desired C++ code
and use some tool for interfacing it from Python. A tool like
`SWIG <http://swig.org/>`_ can interpret the C++ code and generate
interfaces for a wide range of
languages, including Python, Perl, Ruby, and Java.
However, SWIG is a comprehensive tool with a correspondingly
steep learning curve. Alternative tools, such as
`Boost Python <http://www.boost.org/doc/libs/1_51_0/libs/python/doc/index.html>`_, `SIP <http://riverbankcomputing.co.uk/software/sip/intro>`_,
and `Shiboken <http://qt-project.org/wiki/Category:LanguageBindings::PySide::Shiboken>`_
are similarly comprehensive. Simpler tools include
`PyBindGen <http://code.google.com/p/pybindgen/>`_,

.. More tools for interfacing C++ from Python


A technically much easier way of interfacing C++ code is to drop the
possibility to use C++ classes directly from Python, but instead
make a C interface to the C++ code. The C interface can be handled
by ``f2py`` as shown in the example with pure C code. Such a solution
means that classes in Python and C++ cannot be mixed and that only
primitive data types like numbers, strings, and arrays can be
transferred between Python and C++. Actually, this is often a very
good solution because it forces the C++ code to work on array data,
which usually gives faster code than if fancy data structures with
classes are used. The arrays coming from Python, and looking like
plain C/C++ arrays, can be efficiently wrapped in more user-friendly
C++ array classes in the C++ code, if desired.

.. __Remaining.__

.. Use some array class. Key issue: ``extern "C"`` declaration of C++

.. function in the C file with the interface we want to wrap.


Using classes to implement a simulator
======================================

 * Introduce classes ``Mesh``, ``Function``, ``Problem``, ``Solver``, ``Visualizer``,
   ``File``
.. communicate with compiled code by ensuring that classes work with arrays

.. ===== Callbacks to Python from Fortran or C =====

.. 5631 projects:

.. Drop f_a, call py from f77

.. Call py with cpdef f from Cython, but hardcode function name

.. As above, but transfer function to Cython

.. Instant

.. test_quadratic for all

.. Think of extensions: Neumann with modified stencil or ghost cells,

.. variable coefficients, damping, ...


Exercises  (3)
==============



.. --- begin exercise ---


.. _wave:exer:quadratic:2D:

Exercise 10: Check that a solution fulfills the discrete model
--------------------------------------------------------------

Carry out all mathematical details to show that
:eq:`wave2D3D:impl:verify:quadratic` is indeed a solution of the
discrete model for a 2D wave equation with :math:`u=0` on the boundary.
One must check the boundary conditions, the initial conditions,
the general discrete equation at a time level and the special
version of this equation for the first time level.
Filename: ``check_quadratic_solution.pdf``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:exer:mesh3D:calculus:

Project 11: Calculus with 2D/3D mesh functions
----------------------------------------------

The goal of this project is to redo
:ref:`wave:exer:mesh1D:calculus` with 2D and 3D
mesh functions (:math:`f_{i,j}` and :math:`_{fi,j,k}`).

*Differentiation.* The differentiation results in a discrete gradient
function, which in the 2D case can be represented by a three-dimensional
array ``df[d,i,j]`` where ``d`` represents the direction of
the derivative and ``i`` and ``j`` are mesh point counters in 2D
(the 3D counterpart is ``df[d,i,j,k]``).

*Integration.* The integral of a 2D mesh function :math:`f_{i,j}` is defined as


.. math::
         F_{i,j} = \int_{y_0}^{y_j} \int_{x_0}^{x_i} f(x,y)dxdy,

where :math:`f(x,y)` is a function that takes on the values of the
discrete mesh function :math:`f_{i,j}` at the mesh points, but can also
be evaluated in between the mesh points. The particular variation
between mesh points can be taken as bilinear, but this is not
important as we will use a product Trapezoidal rule to approximate
the integral over a cell in the mesh and then we only need to
evaluate :math:`f(x,y)` at the mesh points.

Suppose :math:`F_{i,j}` is computed. The calculation of :math:`F_{i+1,j}`
is then


.. math::
        
        F_{i+1,j} &= F_{i,j} + \int_{x_i}^{x_{i+1}}\int_{y_0}^{y_j} f(x,y)dydx\\ 
        &\approx \Delta x \int_{y_0}^{y_j} f(x_{i+\frac{1}{2}},y)dy\\ 
        & \approx \Delta x \frac{1}{2}\left(
        \int_{y_0}^{y_j} f(x_{i},y)dy
        + \int_{y_0}^{y_j} f(x_{i+1},y)dy\right)
        

The integrals in the :math:`y` direction can be approximated by a Trapezoidal
rule. A similar idea can be used to compute :math:`F_{i,j+1}`. Thereafter,
:math:`F_{i+1,j+1}` can be computed by adding the integral over the final
corner cell to :math:`F_{i+1,j} + F_{i,j+1} - F_{i,j}`. Carry out the
details of these computations and extend the ideas to 3D.
Filename: ``mesh_calculus_3D.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:wave2D:Neumann:

Exercise 12: Implement Neumann conditions in 2D
-----------------------------------------------

Modify the `wave2D_u0.py <http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0.py>`_
program, which solves the 2D wave equation :math:`u_{tt}=c^2(u_{xx}+u_{yy})`
with constant wave velocity :math:`c` and :math:`u=0` on the boundary, to have
Neumann boundary conditions: :math:`\partial u/\partial n=0`.
Include both scalar code (for debugging and reference) and
vectorized code (for speed).

To test the code, use :math:`u=1.2` as solution (:math:`I(x,y)=1.2`, :math:`V=f=0`, and
:math:`c` arbitrary), which should be exactly reproduced with any mesh
as long as the stability criterion is satisfied.
Another test is to use the plug-shaped pulse
in the ``pulse`` function from the section :ref:`wave:pde2:software`
and the `wave1D_dn_vc.py <http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py>`_
program. This pulse
is exactly propagated in 1D if :math:`c\Delta t/\Delta x=1`. Check
that also the 2D program can propagate this pulse exactly
in :math:`x` direction (:math:`c\Delta t/\Delta x=1`, :math:`\Delta y` arbitrary)
and :math:`y` direction (:math:`c\Delta t/\Delta y=1`, :math:`\Delta x` arbitrary).
Filename: ``wave2D_dn.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:exer:3D:f77:cy:efficiency:

Exercise 13: Test the efficiency of compiled loops in 3D
--------------------------------------------------------

Extend the ``wave2D_u0.py`` code and the Cython, Fortran, and C versions to 3D.
Set up an efficiency experiment to determine the relative efficiency of
pure scalar Python code, vectorized code, Cython-compiled loops,
Fortran-compiled loops, and C-compiled loops.
Normalize the CPU time for each mesh by the fastest version.
Filename: ``wave3D_u0.py``.

.. --- end exercise ---



.. !split

.. _wave:app:

Applications of wave equations
==============================

This section presents a range of wave equation models
for different physical phenomena. Although many wave motion problems
in physics can be modeled by the standard linear wave equation, or a similar
formulation with a system of first-order equations, there are some
exceptions. Perhaps the most important is water waves: these are modeled by
the Laplace equation with time-dependent boundary conditions at
the water surface (long water waves, however, can be approximated
by a standard wave equation, see the section :ref:`wave:app:sw:2D`).
Quantum mechanical waves constitute another example where the waves
are governed by the
Schrodinger
equation and not a standard wave equation.
Many wave phenomena also need to take nonlinear effects into account
when the wave amplitude is significant. Shock waves in the air is
a primary example.

The derivations in the following are very brief. Those with a firm
background in continuum mechanics will probably have enough
information to fill in the details, while other readers will hopefully
get some impression of the physics and approximations involved when
establishing wave equation models.

.. _wave:app:string:

Waves on a string
-----------------


.. _wave:app:string:fig:

.. figure:: wave_on_string.png
   :width: 800

   *Discrete string model with point masses connected by elastic strings*


Figure :ref:`wave:app:string:fig` shows a model we may use to derive
the equation for waves on a string. The string is modeled as a
set of discrete point masses (at mesh points) with
elastic strings in between. The strings are at a high constant tension :math:`T`.
We let the mass at mesh point :math:`x_i` be :math:`m_i`. The displacement of
this mass point in :math:`y` direction is denoted by :math:`u_i(t)`.

The motion of mass :math:`m_i` is governed by Newton's second law of motion.
The position of the mass at time :math:`t` is :math:`x_i\boldsymbol{i} + u_i(t)\boldsymbol{j}`, where
:math:`\boldsymbol{i}` and :math:`\boldsymbol{j}` are unit vectors in the :math:`x` and :math:`y` direction, respectively.
The acceleration is then :math:`u_i''(t)\boldsymbol{j}`. Two forces are acting
on the mass as indicated in Figure :ref:`wave:app:string:fig`.
The force :math:`\boldsymbol{T}^{-}` acting toward the point :math:`x_{i-1}` can be decomposed
as


.. math::
         \boldsymbol{T}^{-} = -T\sin\phi\boldsymbol{i} -T\cos\phi\boldsymbol{j}, 

where :math:`\phi` is the angle between the force and the
line :math:`x=x_i`. Let :math:`\Delta u_i = u_i - u_{i-1}` and let
:math:`\Delta s_i = \sqrt{\Delta u_i^2 + (x_i - x_{i-1})^2}`
be the distance from mass :math:`m_{i-1}` to mass :math:`m_i`.
It is seen that :math:`\cos\phi = \Delta u_i/\Delta s_i` and :math:`\sin\phi =
(x_{i}-x_{i-1})/\Delta s` or :math:`\Delta x/\Delta s_i` if we
introduce a constant mesh spacing :math:`\Delta x = x_i - x_{i-1}`.
The force can then be written


.. math::
         \boldsymbol{T}^{-} = -T\frac{\Delta x}{\Delta s_i}\boldsymbol{i} - T\frac{\Delta u_i}{\Delta s_i}\boldsymbol{j}
        \thinspace .
        

The force :math:`\boldsymbol{T}^{+}` acting toward :math:`x_{i+1}` can be calculated in a similar way:


.. math::
         \boldsymbol{T}^{+} = T\frac{\Delta x}{\Delta s_{i+1}}\boldsymbol{i} +
                    T\frac{\Delta u_{i+1}}{\Delta s_{i+1}}\boldsymbol{j}
        \thinspace .
        

Newton's second law becomes


.. math::
         m_iu_i''(t)\boldsymbol{j} = \boldsymbol{T}^{+} + \boldsymbol{T}^{-},

which gives the component equations


.. math::
   :label: wave:app:string:hcomp
        
        T\frac{\Delta x}{\Delta s_i} = T\frac{\Delta x}{\Delta s_{i+1}},
        
        



.. math::
   :label: wave:app:string:vcomp
          
        m_iu_i''(t) = T\frac{\Delta u_{i+1}}{\Delta s_{i+1}} -
                       T\frac{\Delta u_i}{\Delta s_i}
        
        \thinspace .
        


A basic reasonable assumption for a string
is small displacements :math:`u_i` and small
displacement gradients :math:`\Delta u_i/\Delta x`. For small :math:`g=\Delta u_i/\Delta x`
we have that


.. math::
         \Delta s_i = \sqrt{\Delta u_i^2 + \Delta x^2} = \Delta x\sqrt{1 + g^2}
        + \Delta x (1 + \frac{1}{2}g^2 + {\cal O}(g^4) \approx \Delta x
        \thinspace .
        

Equation :eq:`wave:app:string:hcomp` is then simply the identity :math:`T=T`, while
:eq:`wave:app:string:vcomp` can be written as


.. math::
        
        m_iu_i''(t) = T\frac{\Delta u_{i+1}}{\Delta x} - T\frac{\Delta u_i}{\Delta x},
        

which upon division by :math:`\Delta x` and introducing the density
:math:`\varrho_i = m_i/\Delta x` becomes


.. math::
   :label: wave:app:string:model0
        
        \varrho_i u_i''(t) = T\frac{1}{\Delta x^2}
        \left( u_{i+1} - 2u_i + u_{i-1}\right)
        
        \thinspace .
        

We can now choose to approximate :math:`u_i''` by a finite difference in time
and get the discretized wave equation,


.. math::
        
        \varrho_i \frac{1}{\Delta t^2}
        \left(u^{n+1}_i - 2u^n_i - u^{n-1}_i\right) =
        T\frac{1}{\Delta x^2}
        \left( u_{i+1} - 2u_i + u_{i-1}\right){\thinspace .}
        

On the other hand, we may go to the continuum limit :math:`\Delta x\rightarrow 0` and
replace :math:`u_i(t)` by :math:`u(x,t)`, :math:`\varrho_i` by :math:`\varrho(x)`, and
recognize that the right-hand side of :eq:`wave:app:string:model0`
approaches :math:`\partial^2 u/\partial x^2` as :math:`\Delta x\rightarrow 0`.
We end up with the continuous model for waves on a string:


.. math::
   :label: wave:app:string:model1
        
        \varrho\frac{\partial^2 u}{\partial t^2} = T\frac{\partial^2 u}{\partial x^2}
        
        \thinspace .
        

Note that the density :math:`\varrho` may change along the string, while the
tension :math:`T` is a constant. With variable wave velocity :math:`c(x) = \sqrt{T/\varrho(x)}` we can write the wave equation in the more standard form


.. math::
   :label: wave:app:string:model2
        
        \frac{\partial^2 u}{\partial t^2} = c^2(x)\frac{\partial^2 u}{\partial x^2}
        
        \thinspace .
        

Because of the way :math:`\varrho` enters the equations, the variable wave
velocity does *not* appear inside the derivatives as in many other
versions of the wave equation. However, most strings of interest have
constant :math:`\varrho`.

The end point of a string are fixed so that the displacement
:math:`u` is zero. The boundary conditions are therefore :math:`u=0`.


Damping
~~~~~~~

Air resistance and non-elastic effects in the string will contribute
to reduce the amplitudes of the waves so that the motion dies out
after some time. This damping effect can be modeled by a term
:math:`bu_t` on the left-hand side of the equation


.. math::
   :label: wave:app:string:model1:damping
        
        \varrho\frac{\partial^2 u}{\partial t^2}
        + b\frac{\partial u}{\partial t}  =  T\frac{\partial^2 u}{\partial x^2}
        
        \thinspace .
        

The parameter :math:`b` must normally be determined from physical experiments.

External forcing
~~~~~~~~~~~~~~~~

It is easy to include an external force acting on the string.
Say we have a vertical force :math:`\tilde f_i\boldsymbol{j}` acting on mass :math:`m_i`.
This force affects the vertical component of Newton's law
and gives rise to an extra term :math:`\tilde f(x,t)` on the right-hand side of
:eq:`wave:app:string:model1`. In the model
:eq:`wave:app:string:model2` we would add a term
:math:`f(x,t) = \tilde f(x,y)/\varrho(x)`.

Modeling the tension via springs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We assumed, in the derivation above, that the tension in the string, :math:`T`,
was constant. It is easy to check this assumption by modeling the
string segments between the masses as standard springs, where the
force (tension :math:`T`) is proportional to the elongation of the spring segment.
Let :math:`k` be the spring constant, and set :math:`T_i=k\Delta \ell` for the
tension in the spring segment between :math:`x_{i-1}` and :math:`x_i`, where
:math:`\Delta\ell` is the elongation of this segment from the tension-free state.
A basic feature of a string is that it has high tension in the
equilibrium position :math:`u=0`. Let the string segment have an elongation
:math:`\Delta\ell_0` in the equilibrium position. After deformation of the
string, the elongation is :math:`\Delta \ell = \Delta \ell_0 + \Delta s_i`:
:math:`T_i = k(\Delta \ell_0 + \Delta s_i)\approx k(\Delta \ell_0 + \Delta x)`.
This shows that :math:`T_i` is independent of :math:`i`. Moreover, the extra
approximate elongation :math:`\Delta x` is very small compared to :math:`\Delta\ell_0`,
so we may well set :math:`T_i = T = k\Delta\ell_0`. This means that
the tension is completely dominated by the initial tension determined
by the tuning of the string. The additional deformations of the
spring during the vibrations do not introduce significant changes in the
tension.

.. _wave:app:membrane:

Waves on a membrane
-------------------

.. _wave:app:elastic:rod:

Elastic waves in a rod
----------------------

Consider an elastic rod subject to a hammer impact at the end.
This experiment will give rise to an elastic deformation pulse that travels
through the rod. A mathematical model for longitudinal waves along
an elastic rod starts with the general equation for deformations
and stresses in an elastic medium,


.. math::
   :label: wave:app:elastic:rod:eqmotion
        
        \varrho\boldsymbol{u}_{tt} = \nabla\cdot\boldsymbol{\sigma} + \varrho\boldsymbol{f},
        
        

where :math:`\varrho` is the density, :math:`\boldsymbol{u}` the displacement field, :math:`\boldsymbol{\sigma}` the
stress tensor, and :math:`\boldsymbol{f}` body forces. The latter has normally no impact
on elastic waves.

For stationary deformation of an elastic rod, one has that
:math:`\sigma_{xx} = Eu_x`, with all other
stress components being zero. Moreover, :math:`\boldsymbol{u} = u(x)\boldsymbol{i}`.
The parameter :math:`E` is known as Young's modulus.
Assuming that this simple stress and deformation field, which is exact
in the stationary case, is a good approximation in the transient
case with wave motion, :eq:`wave:app:elastic:rod:eqmotion` simplifies
to


.. math::
   :label: wave:app:elastic:rod:eq
        
        \varrho\frac{\partial^2 u}{\partial t^2} = \frac{\partial}{\partial x}
        \left( E\frac{\partial u}{\partial x}\right)
        
        \thinspace .
        


The associated boundary conditions are :math:`u` or :math:`\sigma_{xx}=Eu_x` known,
typically
:math:`u=0` for a clamped end and :math:`\sigma_{xx}=0` for a free end.

.. _wave:app:acoustic:seismic:

The acoustic model for seismic waves
------------------------------------

Seismic waves are used to infer properties of subsurface
geological structures. The physical model is a heterogeneous
elastic medium where sound is propagated by small elastic
vibrations. The general mathematical model for deformations
in an elastic medium is based on Newton's second law,


.. math::
   :label: wave:app:acoustic:seismic:eqmotion
        
        \varrho\boldsymbol{u}_{tt} = \nabla\cdot\boldsymbol{\sigma} + \varrho\boldsymbol{f},
        
        

and a constitutive law relating :math:`\boldsymbol{\sigma}` to :math:`\boldsymbol{u}`, often Hooke's
generalized law,


.. math::
   :label: wave:app:acoustic:seismic:Hooke
        
        \boldsymbol{\sigma} = K\nabla\cdot\boldsymbol{u}\, \boldsymbol{I}  + G(\nabla\boldsymbol{u} + (\nabla\boldsymbol{u})^T - \frac{2}{3}\nabla\cdot\boldsymbol{u}\, \boldsymbol{I})
        
        \thinspace .
        

Here, :math:`\boldsymbol{u}` is the displacement field, :math:`\boldsymbol{\sigma}` is the stress tensor,
:math:`\boldsymbol{I}` is the identity tensor,
:math:`\varrho` is the medium's density, :math:`\boldsymbol{f}` are body forces (such as gravity),
:math:`K` is the medium's bulk modulus and :math:`G` is the shear modulus.
All these quantities may vary in space, while :math:`\boldsymbol{u}` and :math:`\boldsymbol{\sigma}` will
also show significant variation in time during wave motion.

The acoustic approximation to elastic waves arises from a basic
assumption that the second term in Hooke's law, representing the
deformations that give rise to shear stresses, can be neglected.
This assumption can be interpreted as approximating the geological
medium by a fluid.
Neglecting also the body forces :math:`\boldsymbol{f}`,
:eq:`wave:app:acoustic:seismic:eqmotion` becomes


.. math::
   :label: wave:app:acoustic:seismic:eqmotion2
        
        \varrho\boldsymbol{u}_{tt} = \nabla (K\nabla\cdot\boldsymbol{u} )
        
        

Introducing :math:`p` as a pressure via


.. math::
   :label: wave:app:acoustic:seismic:eqmotion3
        
        p=-K\nabla\cdot\boldsymbol{u},
        
        

and dividing :eq:`wave:app:acoustic:seismic:eqmotion2` by :math:`\varrho`,
we get


.. math::
        
        \boldsymbol{u}_{tt} = -\frac{1}{\varrho}\nabla p
        \thinspace .
        

Taking the divergence of this equation, using :math:`\nabla\cdot\boldsymbol{u} = -p/K`
from :eq:`wave:app:acoustic:seismic:eqmotion3`,
gives the *acoustic approximation to elastic waves*:


.. math::
   :label: wave:app:acoustic:seismic:accoustic1
        
        p_{tt} = K\nabla\cdot\left(\frac{1}{\varrho}\nabla p\right)
        \thinspace .
        
        

This is a standard, linear wave equation with variable coefficients.
It is common to add a source term :math:`s(x,y,z,t)`
to model the generation of sound waves:


.. math::
   :label: wave:app:acoustic:seismic:accoustic
        
        p_{tt} = K\nabla\cdot\left(\frac{1}{\varrho}\nabla p\right) + s
        \thinspace .
        
        


A common additional approximation of :eq:`wave:app:acoustic:seismic:accoustic`
is based on using the chain rule on the right-hand side,


.. math::
        
        K\nabla\cdot\left(\frac{1}{\varrho}\nabla p\right)
        = \frac{K}{\varrho}\nabla^2 p + K\nabla\left(\frac{1}{\varrho}\right)\cdot
        \nabla p \approx \frac{K}{\varrho}\nabla^2 p,
        

under the assumption that
the relative spatial gradient :math:`\nabla\varrho^{-1}
= -\varrho^{-2}\nabla\varrho` is small. This approximation results
in the simplified equation


.. math::
   :label: wave:app:acoustic:seismic:accoustic1
        
        p_{tt} = \frac{K}{\varrho}\nabla^2 p + s
        \thinspace .
        
        


The acoustic approximations to seismic waves are used for sound
waves in the ground, and the Earth's surface is then a boundary
where :math:`p` equals the atmospheric pressure :math:`p_0` such that the
boundary condition becomes :math:`p=p_0`.

Anisotropy
~~~~~~~~~~

Quite often in geological materials,
the effective wave velocity :math:`c=\sqrt{K/\varrho}` is different
in different spatial directions because geological layers are
compacted such that the properties in the horizontal and vertical
direction differ. With :math:`z` as the vertical coordinate, we can
introduce a vertical wave velocity :math:`c_z` and a horizontal
wave velocity :math:`c_h`, and
generalize :eq:`wave:app:acoustic:seismic:accoustic1` to


.. math::
   :label: wave:app:acoustic:seismic:accoustic1a
        
        p_{tt} = c_z^2 p_{zz} + c_h^2 (p_{xx} + p_{yy}) + s
        \thinspace .
        
        



.. _wave:app:sound:

Sound waves in liquids and gases
--------------------------------

Sound waves arise from pressure and density variations in fluids.
The starting point of modeling sound waves is the basic
equations for a compressible fluid where we omit viscous (frictional)
forces, body forces (gravity, for instance), and temperature effects:


.. math::
   :label: wave:app:sound:cont
        
        \varrho_t + \nabla\cdot (\varrho \boldsymbol{u}) = 0,
        
        



.. math::
   :label: wave:app:sound:Euler
          
        \varrho \boldsymbol{u}_{t} + \varrho \boldsymbol{u}\cdot\nabla\boldsymbol{u} = -\nabla p,
        
        



.. math::
   :label: wave:app:sound:prho
          
        \varrho = \varrho (p)
        \thinspace .
        
        

These equations are often referred to as the Euler equations for the motion
of a fluid. The parameters involved are the density :math:`\varrho`,
the velocity :math:`\boldsymbol{u}`,
and the pressure :math:`p`. Equation :eq:`wave:app:sound:Euler` reflects
mass balance, :eq:`wave:app:sound:cont` is Newton's second law for
a fluid, with frictional and body forces omitted, and
:eq:`wave:app:sound:prho` is a constitutive law relating
density to pressure by thermodynamics considerations.
A typical model
for :eq:`wave:app:sound:prho` is the so-called `isentropic relation <http://en.wikipedia.org/wiki/Isentropic_process>`_, valid for
adiabatic processes where there is no heat transfer:


.. math::
   :label: wave:app:sound:prho:formula
        
        \varrho = \varrho_0\left(\frac{p}{p_0}\right)^{1/\gamma}
        \thinspace .
        
        

Here, :math:`p_0` and :math:`\varrho_0` are references values for :math:`p` and :math:`
\varrho` when the fluid is at rest, and
:math:`\gamma` is the ratio of specific heat at constant pressure and
constant volume (:math:`\gamma = 5/3` for air).

The key approximation in a mathematical model for sound waves is to
assume that these waves are small perturbations to the density, pressure,
and velocity. We therefore write


.. math::
        
        p &= p_0 + \hat p,\\ 
        \varrho &= \varrho_0 + \hat\varrho,\\ 
        \boldsymbol{u} &= \hat\boldsymbol{u},
        

where we have decomposed the fields in a constant
equilibrium value, corresponding
to :math:`\boldsymbol{u}=0`, and a small perturbation marked with a hat symbol.
By inserting these decompositions in :eq:`wave:app:sound:cont` and
:eq:`wave:app:sound:Euler`, neglecting all product terms of small
perturbations and/or their derivatives, and dropping the hat symbols,
one gets the following linearized PDE system for the small perturbations in
density, pressure, and velocity:


.. math::
        
        \varrho_t + \varrho_0\nabla\cdot\boldsymbol{u} = 0,
        



.. math::
          
        \varrho_0\boldsymbol{u}_t = -\nabla p
        \thinspace .
        

Now we can eliminate :math:`\varrho_t` by differentiating the relation :math:`\varrho(p)`,


.. math::
         \varrho_t = \varrho_0 \frac{1}{\gamma}\left(\frac{p}{p_0}\right)^{1/\gamma-1}
        \frac{1}{p_0}p_t = \frac{\varrho_0}{\gamma p_0}
        \left(\frac{p}{p_0}\right)^{1/\gamma-1}p_t
        \thinspace .
        

The product term :math:`p^{1/\gamma -1}p_t` can be linearized as
:math:`p_0^{1/\gamma -1}p_t`, resulting in


.. math::
         \varrho_t \approx \frac{\varrho_0}{\gamma p_0} p_t
        \thinspace . 

We then get


.. math::
   :label: wave:app:sound:cont:pert
        
        p_t + \gamma p_0\nabla\cdot\boldsymbol{u} = 0,
        
        



.. math::
   :label: wave:app:sound:Euler:pert
          
        \boldsymbol{u}_t = -\frac{1}{\varrho_0}\nabla p,
        
        \thinspace .
        

Taking the divergence of :eq:`wave:app:sound:Euler:pert` and
differentiating :eq:`wave:app:sound:cont:pert` with respect to time
gives the possibility to easily eliminate :math:`\nabla\cdot\boldsymbol{u}_t` and
arrive at a standard, linear wave equation for :math:`p`:


.. math::
        
        p_{tt} = c^2\nabla^2 p,
        

where :math:`c = \sqrt{\gamma p_0/\varrho_0}` is the speed of sound in the fluid.

.. Challenge: have p_0(z) and varrho_0(z) and gravity - perhaps exercise?


.. !split


.. _wave:app:spherical:

Spherical waves
---------------

Spherically symmetric three-dimensional
waves propagate in the radial direction :math:`r` only so that
:math:`u = u(r,t)`. The fully three-dimensional wave equation


.. math::
         \frac{\partial^2u}{\partial t^2}=\nabla\cdot (c^2\nabla u) + f 

then reduces to the spherically symmetric wave equation


.. math::
        
        \frac{\partial^2u}{\partial t^2}=\frac{1}{r^2}\frac{\partial}{\partial r}
        \left(c^2(r)r^2\frac{\partial u}{\partial t}\right)
        + f(r,t),\quad r\in (0,R),\ t>0
        \thinspace .
        

One can easily show
that the function :math:`v(r,t) = ru(r,t)` fulfills a standard wave equation
in Cartesian coordinates if :math:`c` is constant. To this end, insert :math:`u=v/r` in


.. math::
         \frac{1}{r^2}\frac{\partial}{\partial r}
        \left(c^2(r)r^2\frac{\partial u}{\partial t}\right) 

to obtain


.. math::
         r\left(\frac{d c^2}{dr}\frac{\partial v}{\partial r} +
        c^2\frac{\partial^2 v}{\partial r^2}\right) - \frac{d c^2}{dr}v
        \thinspace .
        

The two terms in the parenthesis can be combined to

.. math::
         r\frac{\partial}{\partial r}\left( c^2\frac{\partial v}{\partial r}\right),
        

which is recognized as the variable-coefficient Laplace operator in
one Cartesian coordinate. The spherically symmetric wave equation in
terms of :math:`v(r,t)` now becomes


.. math::
        
        \frac{\partial^2v}{\partial t^2}=
        \frac{\partial}{\partial r}
        \left(c^2(r)\frac{\partial v}{\partial r}\right)
        -\frac{1}{r}\frac{d c^2}{dr}v + rf(r,t),\quad r\in (0,R),\ t>0
        \thinspace .
        

In the case of constant wave velocity :math:`c`, this equation reduces to
the wave equation in a single Cartesian coordinate called :math:`r`:


.. math::
   :label: wave:app:rsymm:Cart
        
        \frac{\partial^2v}{\partial t^2}=
        c^2 \frac{\partial^2 v}{\partial r^2}
        + rf(r,t),\quad r\in (0,R),\ t>0
        \thinspace .
        
        

That is, any program for solving the one-dimensional wave equation
in a Cartesian coordinate system can be used to
solve :eq:`wave:app:rsymm:Cart`, provided the source term is
multiplied by the coordinate, and that we divide the Cartesian mesh
solution by :math:`r` to get the spherically symmetric solution.
Moreover, if :math:`r=0` is included in the
domain, spherical symmetry demands that :math:`\partial u/\partial r=0` at
:math:`r=0`, which means that


.. math::
         \frac{\partial u}{\partial r} = \frac{1}{r^2}\left(
        r\frac{\partial v}{\partial r} - v\right) = 0,\quad r=0,
        

implying :math:`v(0,t)=0` as a necessary condition. For practical applications,
we exclude :math:`r=0` from the domain and assume that some boundary
condition is assigned at :math:`r=\epsilon`, for some :math:`\epsilon >0`.


.. _wave:app:sw:2D:

The linear shallow water equations
----------------------------------

The next example considers water waves whose wavelengths are much
lager than the depth and whose wave amplitudes are small. This class
of waves may be generated by catastrophic geophysical events, such as
earthquakes at the sea bottom, landslides moving into water, or
underwater slides (or a combination, as earthquakes frequently release
avalanches of masses). For example, a subsea earthquake will normally
have an extension of many kilometers but lift the water only a few
meters. The wave length will have a size dictated by the earthquake
area, which is much lager than the water depth, and compared to this
wave length, an amplitude of a few meters is very small.
The water is essentially a thin film, and mathematically we can average
the problem in the vertical direction and approximate the 3D
wave phenomenon by 2D PDEs. Instead of a moving water domain in three
space dimensions, we get a horizontal 2D domain with an unknown function
for the surface elevation and the water depth as a variable coefficient
in the PDEs.

Let :math:`\eta(x,y,t)` be the elevation of
the water surface, :math:`H(x,y)` the water depth corresponding to a flat
surface (:math:`\eta =0`), :math:`u(x,y,t)` and :math:`v(x,y,t)` the
depth-averaged horizontal velocities of the water. Mass and momentum
balance of the water volume give rise to the PDEs involving these
quantities:


.. math::
   :label: wave:app:sw:2D:eeq
        
        \eta_t = - (Hu)_x - (Hv)_x
        
        



.. math::
   :label: wave:app:sw:2D:ueq
          
        u_t = -g\eta_x,
        
        



.. math::
   :label: wave:app:sw:2D:veq
          
        v_t = -g\eta_y,
        
        

where :math:`g` is the acceleration of gravity. Equation :eq:`wave:app:sw:2D:eeq`
corresponds to mass balance while the other two are derived from momentum
balance (Newton's second law).

The initial conditions associated with
:eq:`wave:app:sw:2D:eeq`-:eq:`wave:app:sw:2D:veq` are :math:`\eta`, :math:`u`,
and :math:`v` prescribed at :math:`t=0`. A common condition is to have some water
elevation :math:`\eta =I(x,y)` and assume that the surface is at rest:
:math:`u=v=0`. A subsea earthquake usually means a sufficiently rapid motion
of the bottom and the water volume to say that the bottom
deformation is mirrored at the water surface as an initial lift :math:`I(x,y)`
and that :math:`u=v=0`.

Boundary conditions may be :math:`\eta` prescribed for incoming, known
waves, or zero normal velocity at reflecting boundaries (steep
mountains, for instance): :math:`un_x + vn_y =0`, where :math:`(n_x,n_y)` is the
outward unit normal to the boundary.  More sophisticated boundary
conditions are needed when waves run up at the shore, and at open
boundaries where we want the waves to leave the computational domain
undisturbed.

Equations :eq:`wave:app:sw:2D:eeq`, :eq:`wave:app:sw:2D:ueq`, and
:eq:`wave:app:sw:2D:veq` can be transformed to a standard, linear
wave equation. First, multiply :eq:`wave:app:sw:2D:ueq` and
:eq:`wave:app:sw:2D:veq` by :math:`H`, differentiate :eq:`wave:app:sw:2D:ueq`)
with respect to :math:`x` and :eq:`wave:app:sw:2D:veq` with respect to :math:`y`.
Second, differentiate :eq:`wave:app:sw:2D:eeq` with respect to :math:`t`
and use that :math:`(Hu)_{xt}=(Hu_t)_x` and :math:`(Hv)_{yt}=(Hv_t)_y` when :math:`H`
is independent of :math:`t`. Third, eliminate :math:`(Hu_t)_x` and :math:`(Hv_t)_y`
with the aid of the other two differentiated equations. These manipulations
results in a standard, linear wave equation for :math:`\eta`:


.. math::
   :label: wave:app:sw:2D:eta:2ndoeq
        
        \eta_{tt} = (gH\eta_x)_x + (gH\eta_y)_y = \nabla\cdot (gH\nabla\eta)
        
        \thinspace .
        



In the case we have an initial non-flat water surface at rest, the
initial conditions become :math:`\eta =I(x,y)` and :math:`\eta_t=0`.
The latter follows from :eq:`wave:app:sw:2D:eeq` if :math:`u=v=0`, or
simply from the fact that the vertical velocity of the surface
is :math:`\eta_t`, which is zero for a surface at rest.

The system :eq:`wave:app:sw:2D:eeq`-:eq:`wave:app:sw:2D:veq`
can be extended to handle a time-varying bottom topography, which is
relevant for modeling long waves generated by underwater slides.
In such cases the water depth function :math:`H` is also a function of :math:`t`,
due to the moving slide,
and one must add a time-derivative term :math:`H_t` to the left-hand side
of :eq:`wave:app:sw:2D:eeq`. A moving bottom is best described by
introducing :math:`z=H_0` as the still-water level, :math:`z=B(x,y,t)` as
the time- and space-varying bottom topography, so that :math:`H=H_0-B(x,y,t)`.
In the elimination of :math:`u` and :math:`v` one may assume that the dependence of
:math:`H` on :math:`t` can be neglected in the terms :math:`(Hu)_{xt}` and :math:`(Hv)_{yt}`.
We then end up with a source term in :eq:`wave:app:sw:2D:eta:2ndoeq`,
because of the moving (accelerating) bottom:


.. math::
   :label: wave:app:sw:2D:eta:2ndoeq:Ht
        
        \eta_{tt} = \nabla\cdot(gH\nabla\eta) + B_{tt}
        
        \thinspace .
        


The reduction of :eq:`wave:app:sw:2D:eta:2ndoeq:Ht` to 1D, for long waves
in a straight channel, or for approximately plane waves in the ocean, is
trivial by assuming no change in :math:`y` direction (:math:`\partial/\partial y=0`):


.. math::
   :label: wave:app:sw:1D:eta:2ndoeq:Ht
        
        \eta_t = (gH\eta_x)_x + B_{tt}
        
        \thinspace .
        


Wind drag on the surface
~~~~~~~~~~~~~~~~~~~~~~~~

Surface waves are influenced by the drag of the wind, and if the
wind velocity some meters above the surface is :math:`(U,V)`,
the wind drag gives contributions
:math:`C_V\sqrt{U^2+V^2}U` and :math:`C_V\sqrt{U^2+V^2}V` to
:eq:`wave:app:sw:2D:ueq` and :eq:`wave:app:sw:2D:veq`, respectively,
on the right-hand sides.

Bottom drag
~~~~~~~~~~~

The waves will experience a drag from the bottom, often roughly modeled
by a term similar to the wind drag:
:math:`C_B\sqrt{u^2+v^2}u` on the right-hand side of :eq:`wave:app:sw:2D:ueq` and
:math:`C_B\sqrt{u^2+v^2}v` on the right-hand side of :eq:`wave:app:sw:2D:veq`.
Note that in this case the PDEs :eq:`wave:app:sw:2D:ueq` and
:eq:`wave:app:sw:2D:veq` become nonlinear and the elimination of :math:`u` and :math:`v`
to arrive at a 2nd-order wave equation for :math:`\eta` is not possible anymore.

Effect of the Earth's rotation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Long geophysical waves will often be affected by the rotation of the
Earth because of the Coriolis force. This force gives rise to a
term :math:`fv` on the right-hand side of :eq:`wave:app:sw:2D:ueq` and
:math:`-fu` on the right-hand side of :eq:`wave:app:sw:2D:veq`.
Also in this case one cannot eliminate :math:`u` and :math:`v` to work with a single
equation for :math:`\eta`. The Coriolis parameter is :math:`f=2\Omega\sin\phi`,
where :math:`\Omega` is the angular velocity of the earth and :math:`\phi` is
the latitude.



.. !split


.. _wave:app:blood:

Waves in blood vessels
----------------------

The flow of blood in our bodies is basically fluid flow in
a network of pipes. Unlike rigid pipes, the walls in the
blood vessels are elastic and will increase their diameter when the
pressure rises. The elastic forces will then push the wall back
and accelerate the fluid. This interaction between the flow of blood
and the deformation of the vessel wall results in waves traveling along
our blood vessels.

A model for one-dimensional waves along blood vessels can be derived
from averaging the fluid flow over the cross section of the blood
vessels. Let :math:`x` be a coordinate along the blood vessel and assume
that all cross sections are circular, though with different radius :math:`R(x,t)`.
The main quantities to compute is the cross section
area :math:`A(x,t)`, the averaged pressure :math:`P(x,t)`, and the total volume
flux :math:`Q(x,t)`.
The area of this cross section
is


.. math::
        
        A(x,t) = 2\pi\int_{0}^{R(x,t)} rdr,
        

Let :math:`v_x(x,t)` be the velocity of blood averaged over
the cross section at point :math:`x`. The volume flux,
being the total volume of blood passing a cross section per time unit,
becomes

.. math::
        
        Q(x,t) = A(x,t)v_x(x,t)
        \thinspace
        


Mass balance and Newton's second law lead to the PDEs


.. math::
   :label: wave:app:blood:cont
        
        \frac{\partial A}{\partial t} + \frac{\partial Q}{\partial x} = 0,
        
        



.. math::
   :label: wave:app:blood:mom
          
        \frac{\partial Q}{\partial t} +
        \frac{\gamma+2}{\gamma + 1}
        \frac{\partial}{\partial x}\left(\frac{Q^2}{A}\right)
        + \frac{A}{\varrho}\frac{\partial P}{\partial x}
        = -2\pi (\gamma + 2)\frac{\mu}{\varrho}\frac{Q}{A},
        
        

where :math:`\gamma` is a parameter related to the velocity profile,
:math:`\varrho` is the density of blood, and :math:`\mu` is the dynamic viscosity
of blood.

We have three unknowns :math:`A`, :math:`Q`, and :math:`P`, and two equations
:eq:`wave:app:blood:cont` and :eq:`wave:app:blood:mom`.
A third equation is needed to relate the flow to
the deformations of the wall. A common form for this equation is


.. math::
   :label: wave:app:blood:const
        
        \frac{\partial P}{\partial t} + \frac{1}{C}
        \frac{\partial Q}{\partial x} =0,
        
        

where :math:`C` is the compliance of the wall, given by the constitutive
relation


.. math::
        
        C = \frac{\partial A}{\partial P} + \frac{\partial A}{\partial t},
        

which require a relationship between :math:`A` and :math:`P`. One common model
is to view the vessel wall, locally, as a thin elastic tube subject to an
internal pressure. This gives the relation


.. math::
         P=P_0 + \frac{\pi h E}{(1-\nu^2)A_0}(\sqrt{A} - \sqrt{A_0}),
        

where :math:`P_0` and :math:`A_0` are corresponding reference values when the
wall is not deformed, :math:`h` is the
thickness of the wall, and :math:`E` and :math:`\nu` are Young's modulus and
Poisson's ratio of the elastic material in the wall.
The derivative becomes


.. math::
        
        C = \frac{\partial A}{\partial P} =
        \frac{2(1-\nu^2)A_0}{\pi h E}\sqrt{A_0} +
        2\left(\frac{(1-\nu^2)A_0}{\pi h E}\right)^2(P-P_0)
        \thinspace .
        

Another (nonlinear) deformation model of the wall, which has a better
fit with experiments, is


.. math::
         P = P_0\exp{(\beta (A/A_0 - 1))},

where :math:`\beta` is some parameter to be estimated. This law leads to


.. math::
        
        C = \frac{\partial A}{\partial P} = \frac{A_0}{\beta P}
        \thinspace .
        


*Reduction to standard wave equation.* It is not uncommon to neglect the viscous term on the right-hand side of
:eq:`wave:app:blood:mom` and also the quadratic term
with :math:`Q^2` on the left-hand side. The reduced equations
:eq:`wave:app:blood:mom`
and :eq:`wave:app:blood:const` form a first-order
linear wave equation system:


.. math::
        
        C\frac{\partial P}{\partial t} = - \frac{\partial Q}{\partial x},
        



.. math::
          
        \frac{\partial Q}{\partial t}
        = - \frac{A}{\varrho}\frac{\partial P}{\partial x}
        \thinspace .
        

These can be combined into standard 1D wave equation PDE by differentiating
the first equation with respect :math:`t` and the second with respect to :math:`x`,

.. math::
         \frac{\partial}{\partial t}\left( CC\frac{\partial P}{\partial t}
        \right) = \frac{\partial}{\partial x}\left(
        \frac{A}{\varrho}\frac{\partial P}{\partial x}\right),

which can be approximated by

.. math::
        
        \frac{\partial^2 Q}{\partial t^2} = c^2\frac{\partial^2 Q}{\partial x^2},\quad
        c = \sqrt{\frac{A}{\varrho C}},
        

where the :math:`A` and :math:`C` in the expression for :math:`c` are taken as constant
reference values.

.. _wave:app:light:

Electromagnetic waves
---------------------

Light and radio waves are governed by standard wave equations arising
from Maxwell's general equations. When there are no charges and
no currents, as in a vacuum, Maxwell's equations take the form


.. math::
        
        \nabla\cdot\pmb{E} &= 0,\\ 
        \nabla\cdot\pmb{B} &= 0,\\ 
        \nabla\times\pmb{E} &= -\frac{\partial\pmb{B}}{\partial t},\\ 
        \nabla\times\pmb{B} &= \mu_0\epsilon_0\frac{\partial\pmb{E}}{\partial t},
        

where :math:`\epsilon_0=8.854187817620\cdot 10^{-12}` (F/m)
is the permittivity of free space, also known as the
electric constant, and :math:`\mu_0=1.2566370614\cdot 10^{-6}` (H/m)
is the permeability of free space,
also known as the magnetic constant.
Taking the curl of the two last equations and using the
identity

.. math::
         \nabla\times (\nabla\times \pmb{E}) = \nabla(\nabla \cdot \pmb{E})
        - \nabla^2\pmb{E} = - \nabla^2\pmb{E}\hbox{ when }\nabla\cdot\pmb{E}=0,
        

immediately gives the wave equation governing the electric and magnetic field:

.. math::
        
        \frac{\partial^2\pmb{E}}{\partial t^2} =
        c^2\frac{\partial^2\pmb{E}}{\partial x^2},
        



.. math::
          
        \frac{\partial^2\pmb{E}}{\partial t^2} =
        c^2\frac{\partial^2\pmb{E}}{\partial x^2},
        

with :math:`c=1/\sqrt{\mu_0\epsilon_0}` as the velocity of light.
Each component of :math:`\pmb{E}` and :math:`\pmb{B}` fulfills a wave equation
and can hence be solved independently.


.. _wave:app:exer:

Exercises  (4)
==============



.. --- begin exercise ---


.. _wave:app:exer:string:discont:

Exercise 14: Simulate waves on a non-homogeneous string
-------------------------------------------------------

Simulate waves on a string that consists of two materials with
different density. The tension in the string is constant, but the
density has a jump at the middle of the string.  Experiment with
different sizes of the jump and produce animations that visualize the
effect of the jump on the wave motion.

.. --- begin hint in exercise ---


*Hint.* According to the section :ref:`wave:app:string`,
the density enters the mathematical model as :math:`\varrho` in
:math:`\varrho u_{tt} = Tu_{xx}`, where :math:`T` is the string tension. Modify, e.g., the
``wave1D_u0_sv.py`` code to incorporate the tension and two density values.
Make a mesh function ``rho`` with density values at each spatial mesh point.
A value for the tension may be 150 N. Corresponding density values can
be computed from the wave velocity estimations in the ``guitar`` function
in the ``wave1D_u0_sv.py`` file.

.. --- end hint in exercise ---

Filename: ``wave1D_u0_sv_discont.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:string:damping:

Exercise 15: Simulate damped waves on a string
----------------------------------------------

Formulate a mathematical model for damped waves on a string.
Use data from the section :ref:`wave:pde1:guitar:data`, and
tune the damping parameter so that the string is very close to
the rest state after 15 s. Make a movie of the wave motion.
Filename: ``wave1D_u0_sv_damping.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:rod:

Exercise 16: Simulate elastic waves in a rod
--------------------------------------------

A hammer hits the end of an elastic rod. The exercise is to simulate
the resulting wave motion using the model :eq:`wave:app:elastic:rod:eq`
from the section :ref:`wave:app:elastic:rod`. Let the rod have length
:math:`L` and let the boundary :math:`x=L` be stress free so that :math:`\sigma_{xx}=0`,
implying that :math:`\partial u/\partial x=0`. The left end :math:`x=0` is
subject to a strong stress pulse (the hammer), modeled as


.. math::
         \sigma_{xx}(t) = \left\lbrace\begin{array}{ll}
        S,& 0 < t \leq t_s,\\ 
        0, & t > t_s
        \end{array}\right.
        

The corresponding condition on :math:`u` becomes :math:`u_x= S/E`
for :math:`t\leq t_s` and zero afterwards (recall that
:math:`\sigma_{xx} = Eu_x`). This is a non-homogeneous
Neumann condition, and you will need to approximate this condition
and combine it with the scheme (the ideas and manipulations follow
closely the handling of a non-zero initial condition
:math:`u_t=V` in wave PDEs or the corresponding
second-order ODEs for vibrations).
Filename: ``wave_rod.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:spherical:

Exercise 17: Simulate spherical waves
-------------------------------------

Implement a model for spherically symmetric waves using the method
described in the section :ref:`wave:app:spherical`. The boundary condition
at :math:`r=0` must be :math:`\partial u/\partial r=0`, while the condition at
:math:`r=R` can either be :math:`u=0` or a radiation condition as described
in :ref:`wave:app:exer:radiationBC`. The :math:`u=0` condition is
sufficient if :math:`R` is so large that the amplitude of the spherical
wave has become insignificant. Make movie(s) of the case where the source
term is located around :math:`r=0` and sends out pulses


.. math::
         f(r,t) = \left\lbrace\begin{array}{ll}
        Q\exp{(-\frac{r^2}{2\Delta r^2})}\sin\omega t,& \sin\omega t\geq 0\\ 
        0, & \sin\omega t < 0
        \end{array}\right.
        

Here, :math:`Q` and :math:`\omega` are constants to be chosen.

.. --- begin hint in exercise ---


*Hint.* Use the program ``wave1D_u0_sv.py`` as a starting point. Let ``solver``
compute the :math:`v` function and then set :math:`u=v/r`. However,
:math:`u=v/r` for :math:`r=0` requires special treatment. One possibility is
to compute ``u[1:] = v[1:]/r[1:]`` and then set ``u[0]=u[1]``. The latter
makes it evident that :math:`\partial u/\partial r = 0` in a plot.

.. --- end hint in exercise ---

Filename: ``wave1D_spherical.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:pulse1D:analysis:

Exercise 18: Explain why numerical noise occurs
-----------------------------------------------

The experiments performed in :ref:`wave:app:exer:pulse1D` shows
considerable numerical noise in the form of non-physical waves,
especially for :math:`s_f=4` and the plug pulse or the half a "cosinehat"
pulse. The noise is much less visible for a Gaussian pulse. Run the
case with the plug and half a "cosinehat" pulses for :math:`s_f=1`, :math:`C=0.9,
0.25`, and :math:`N_x=40,80,160`. Use the numerical dispersion relation to
explain the observations.
Filename: ``pulse1D_analysis.pdf``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:pulse1D:harmonic:

Exercise 19: Investigate harmonic averaging in a 1D model
---------------------------------------------------------

Harmonic means are often used if the wave velocity is non-smooth or
discontinuous.  Will harmonic averaging of the wave velocity give less
numerical noise for the case :math:`s_f=4` in :ref:`wave:app:exer:pulse1D`?
Filenames: ``pulse1D_harmonic.pdf``, ``pulse1D_harmonic.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:radiationBC:

Problem 20: Implement open boundary conditions
----------------------------------------------


.. index:: radiation condition


.. index:: open boundary condition


To enable a wave to leave the computational domain and travel
undisturbed through
the boundary :math:`x=L`, one can in a one-dimensional problem impose the
following condition, called a *radiation condition* or
*open boundary condition*:


.. math::
   :label: wave:app:exer:radiationBC:eq
        
        \frac{\partial u}{\partial t} + c\frac{\partial u}{\partial x} = 0{\thinspace .}
        
        

The parameter :math:`c` is the wave velocity.

Show that :eq:`wave:app:exer:radiationBC:eq` accepts
a solution :math:`u = g_R(x-ct)`, but not :math:`u = g_L(x+ct)`. This means
that :eq:`wave:app:exer:radiationBC:eq` will allow any
right-going wave :math:`g_R(x-ct)` to pass through the boundary.

A corresponding open boundary condition for a left-going wave
through :math:`x=0` is


.. math::
   :label: wave:app:exer:radiationBC:eqL
        
        \frac{\partial u}{\partial t} + c\frac{\partial u}{\partial x} = 0{\thinspace .}
        
        


The condition :eq:`wave:app:exer:radiationBC:eq`
can be
discretized by centered differences at the spatial end point :math:`i=N_x`,
corresponding to :math:`x=x_R`:


.. math::
   :label: wave:app:exer:radiationBC:eq:op
        
        [D_{2t}u + cD_{2x}u =0]^n_{N_x}
        
        \thinspace .
        

Eliminate the fictitious value :math:`u_{N_x+1}^n` by using
the discrete equation at the same point.
The equation for the first step, :math:`u_i^1`, is in principal affected,
but we can then use the condition :math:`u_{N_x}=0` since the wave
has not yet reached the right boundary.

A corresponding open boundary condition for a left-going wave
through :math:`x=0` is


.. math::
   :label: wave:app:exer:radiationBC:eq:opL
        
        \frac{\partial u}{\partial t} + c\frac{\partial u}{\partial x} = 0{\thinspace .}
        
        

Implement a solver that incorporates the conditions
:eq:`wave:app:exer:radiationBC:eq:op` and
:eq:`wave:app:exer:radiationBC:eq:opL`.  Start with some
peak-shaped Gaussian function in the middle of the domain as :math:`I(x)`
and demonstrate that waves travel undisturbed out of the domain at
:math:`x=L` and :math:`x=0`.  Make a nose test for checking that the surface is
flat after a certain time.

*Remark.* The condition :eq:`wave:app:exer:radiationBC:eq`
works perfectly in 1D when :math:`c` is known. In 2D and 3D, however, the
condition reads :math:`u_t + c_x u_x + c_y u_y=0`, where :math:`c_x` and
:math:`c_y` are the wave speeds in the :math:`x` and :math:`y` directions. Estimating
these components (i.e., the direction of the wave) is often
challenging. Other methods are normally used in 2D and 3D to
let waves move out of a computational domain.
Filename: ``wave1D_open_BC.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:tsunami1D:hill:

Problem 21: Earthquake-generated tsunami over a subsea hill
-----------------------------------------------------------

A subsea earthquake leads to an immediate lift of the water surface, see
Figure :ref:`wave:app:fig:1D:tsunami:flat`.  The lifted water surface
splits into two
tsunamis, one traveling to the right and one to the left, as depicted
in Figure :ref:`wave:app:fig:1D:tsunami:2waves`.  Since tsunamis are
normally very long waves, compared to the depth, with a small
amplitude, compared to the wave length, the wave equation model
described in the section :ref:`wave:app:sw:2D` is relevant:


.. math::
         \eta_{tt} = (gH(x)\eta_x)_x,

where :math:`g` is the acceleration of gravity, and :math:`H(x)` is the still water depth.


.. _wave:app:fig:1D:tsunami:flat:

.. figure:: earthquake_tsunami_flat.png
   :width: 800

   *Sketch of initial water surface due to a subsea earthquake*



.. _wave:app:fig:1D:tsunami:2waves:

.. figure:: earthquake_tsunami_2waves.png
   :width: 800

   *An initial surface elevation is split into two waves*



To simulate the right-going tsunami, we can impose
a symmetry boundary at :math:`x=0`: :math:`\partial\eta\ \partial x =0`.
We then simulate the wave motion
in :math:`[0,L]`. Unless the ocean ends at :math:`x=L`, the waves should travel
undisturbed through the boundary :math:`x=L`. A radiation condition
as explained in :ref:`wave:app:exer:radiationBC` can be
used for this purpose. Alternatively, one can just stop the simulations
before the wave hits the boundary at :math:`x=L`. In that case it does not
matter what kind of boundary condition we use
at :math:`x=L`. Imposing :math:`\eta =0` and stopping the simulations when
:math:`|\eta_i^n| > \epsilon`, :math:`i=N_x-1`, is a possibility (:math:`\epsilon` is a
small parameter).

The shape of the initial surface can be taken as a
Gaussian function,


.. math::
        
        I(x;I_0,I_a,I_m,I_s) =
        I_0 + I_a\exp{\left(-\left(\frac{x-I_m}{I_s}\right)^2\right)},
        

with :math:`I_m=0` reflecting the location of the peak of :math:`I(x)` and
:math:`I_s` being a measure of the width of the function :math:`I(x)`
(:math:`I_s` is :math:`\sqrt{2}` times the standard deviation of the familiar
normal distribution curve).

Now we extend the problem with a hill at the sea
bottom, see Figure :ref:`wave:app:fig:1D:tsunami:hill`. The wave speed
:math:`c=\sqrt{gH(x)} = \sqrt{g(H_0-B(x))}` will then be reduced in the
shallow water above the hill.


.. _wave:app:fig:1D:tsunami:hill:

.. figure:: earthquake_tsunami_hill.png
   :width: 800

   *Sketch of an earthquake-generated tsunami passing over a subsea hill*


One possible form of the
hill is a Gaussian function,


.. math::
   :label: wave:app:exer:tsunami1D:hill:Gauss
        
        B(x;B_0,B_a,B_m,B_s) =
        B_0 + B_a\exp{\left(-\left(\frac{x-B_m}{B_s}\right)^2\right)},
        
        

but many other shapes are also possible, e.g., a "cosine hat" where


.. math::
   :label: wave:app:exer:tsunami1D:hill:cohat
        
        B(x; B_0, B_a, B_m, B_s) = B_0 + B_a\cos{\left( \pi\frac{x-B_m}{2B_s}\right)},
        
        

when :math:`x\in [B_m - B_s, B_m + B_s]` while :math:`B=B_0` outside this
interval.

Also an abrupt construction may be tried:

.. math::
   :label: wave:app:exer:tsunami1D:hill:box
        
        B(x; B_0, B_a, B_m, B_s) = B_0 + B_a,
        
        

for :math:`x\in [B_m - B_s, B_m + B_s]` while :math:`B=B_0` outside this
interval.

The `wave1D_dn_vc.py <http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn_vc.py>`_
program can be used as starting point for the implementation.
Visualize both the bottom topography and the
water surface elevation in
the same plot.
Allow for a flexible choice of bottom shape:
:eq:`wave:app:exer:tsunami1D:hill:Gauss`,
:eq:`wave:app:exer:tsunami1D:hill:cohat`,
:eq:`wave:app:exer:tsunami1D:hill:box`, or :math:`B(x)=B_0` (flat).

The purpose of this problem is to explore the quality of the numerical
solution :math:`\eta^n_i` for different shapes of the bottom obstruction.
The "cosine hat" and the box-shaped hills have abrupt changes in the
derivative of :math:`H(x)` and are more likely to generate numerical noise
than the smooth Gaussian shape of the hill. Investigate if this is true.
Filenames: ``tsunami1D_hill.py``, ``tsunami1D_hill.pdf``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:tsunami2D:hill:

Problem 22: Earthquake-generated tsunami over a 3D hill
-------------------------------------------------------

This problem extends :ref:`wave:app:exer:tsunami1D:hill`
to a three-dimensional wave phenomenon, governed by the 2D PDE
:eq:`wave:app:sw:2D:eta:2ndoeq`. We assume that the earthquake
arise from a fault along the line :math:`x=0` in the :math:`xy`-plane so that
the initial lift of the surface can be taken as :math:`I(x)` in
:ref:`wave:app:exer:tsunami1D:hill`. That is, a plane wave is
propagating to the right, but will experience bending because of
the bottom.

The bottom shape is now a function of :math:`x` and :math:`y`.
An "elliptic" Gaussian function in two dimensions, with its peak
at :math:`(B_{mx}, B_{my})`, generalizes
:eq:`wave:app:exer:tsunami1D:hill:Gauss`:


.. math::
   :label: wave:app:exer:tsunami2D:hill:Gauss
        
        B(x;B_0,B_a,B_{mx}, B_{my} ,B_s, b) =
        B_0 + B_a\exp{\left(-\left(\frac{x-B_{mx}}{B_s}\right)^2
        -\left(\frac{y-B_{my}}{bB_s}\right)^2\right)},
        
        

where :math:`b` is a scaling parameter: :math:`b=1` gives a circular Gaussian
function with circular contour lines, while :math:`b\neq 1` gives an elliptic
shape with elliptic contour lines.

The "cosine hat" :eq:`wave:app:exer:tsunami1D:hill:cohat` can also be
generalized to


.. math::
   :label: wave:app:exer:tsunami2D:hill:cohat
        
        B(x; B_0, B_a, B_{mx}, B_{my}, B_s) =
        B_0 + B_a\cos{\left( \pi\frac{x-B_{mx}}{2B_s}\right)}
        \cos{\left( \pi\frac{y-B_{my}}{2B_s}\right)},
        
        

when :math:`0 \leq \sqrt{x^2+y^2} \leq B_s` and :math:`B=B_0` outside this circle.

A box-shaped obstacle means that

.. math::
   :label: wave:app:exer:tsunami2D:hill:box
        
        B(x; B_0, B_a, B_m, B_s, b) = B_0 + B_a
        
        

for :math:`x` and :math:`y` inside a rectangle

.. math::
         B_{mx}-B_s \leq  x \leq B_{mx} + B_s,\quad
        B_{my}-bB_s \leq  y \leq B_{my} + bB_s,
        

and :math:`B=B_0` outside this rectangle.
The :math:`b` parameter controls the rectangular shape of the cross section of
the box.

Note that the initial condition and the listed bottom shapes are
symmetric around the line :math:`y=B_{my}`. We therefore expect the surface
elevation also to be symmetric with respect to this line.  This means
that we can halve the computational domain by working with
:math:`[0,L_x]\times [0, B_{my}]`. Along the upper boundary, :math:`y=B_{my}`, we
must impose the symmetry condition :math:`\partial \eta/\partial n=0`.  Such
a symmetry condition (:math:`-\eta_x=0`) is also needed at the :math:`x=0`
boundary because the initial condition has a symmetry here. At the
lower boundary :math:`y=0` we also set a Neumann condition (which becomes
:math:`-\eta_y=0`).  The wave motion is to be simulated until the wave hits
the reflecting boundaries where :math:`\partial\eta/\partial n =\eta_x =0`
(one can also set :math:`\eta =0` - the particular condition does not matter
as long as the simulation is stopped before the wave is influenced
by the boundary condition).

Visualize the surface elevation.  Investigate how different hill shapes,
different sizes of the water gap above the hill, and different
resolutions :math:`\Delta x = \Delta y = h` and :math:`\Delta t` influence
the numerical quality of the solution.
Filenames: ``tsunami2D_hill.py``, ``tsunami2D_hill.pdf``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:tsunami:hill:viz:matplotlib:

Problem 23: Investigate Matplotlib for visualization
----------------------------------------------------

Play with native Matplotlib code for visualizing 2D
solutions of the wave equation with variable wave velocity.
See if there
are effective ways to visualize both the solution and the wave
velocity.
Filename: ``tsunami2D_hill_mpl.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:tsunami:hill:viz:packages:

Problem 24: Investigate visualization packages
----------------------------------------------

Create some fancy 3D visualization of the water waves *and* the subsea hill
in :ref:`wave:app:exer:tsunami2D:hill`.
Try to make the hill transparent. Possible visualization tools are

  * `Mayavi <http://code.enthought.com/projects/mayavi/>`_

  * `Paraview <http://www.paraview.org/>`_

  * `OpenDX <http://www.opendx.org/>`_

Filename: ``tsunami2D_hill_viz.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:tsunami2D:hill:compiled:

Problem 25: Implement loops in compiled languages
-------------------------------------------------

Extend the program from :ref:`wave:app:exer:tsunami2D:hill` such
that the loops over mesh points, inside the time loop, are
implemented in compiled languages.
Consider implementations in
Cython, Fortran via ``f2py``, C via Cython, C via ``f2py``, C/C++ via Instant,
and C/C++ via ``scipy.weave``.
Perform efficiency experiments to investigate the relative performance
of the various implementations. It is often advantageous to normalize
CPU times by the fastest method on a given mesh.
Filename: ``tsunami2D_hill_compiled.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:seismic2D:

Exercise 26: Simulate seismic waves in 2D
-----------------------------------------

The goal of this exercise is to simulate seismic waves using the
PDE model :eq:`wave:app:acoustic:seismic:accoustic1a` in a
2D :math:`xz` domain with geological layers.
Introduce :math:`m` horizontal layers of thickness :math:`h_i`, :math:`i=0,\ldots,m-1`.
Inside layer number :math:`i` we have a vertical wave velocity :math:`c_{z,i}`
and a horizontal wave velocity :math:`c_{h,i}`. Make a program
for simulating such 2D waves. Test it on a case with 3 layers where


.. math::
         c_{z,0}=c_{z,1}=c_{z,2},\quad c_{h,0}=c_{h,2},\quad c_{h,1} \ll c_{h,0}
        \thinspace .
        

Let :math:`s` be a localized point source at the middle of the Earth's surface
(the upper boundary)
and investigate how the resulting wave travels through the medium.
The source can be a localized Gaussian peak that oscillates in
time for some time interval.
Place the boundaries far enough from the expanding wave so that the
boundary conditions do not disturb the wave. Then the type of
boundary condition does not matter, except that we physically need
to have :math:`p=p_0`, where :math:`p_0` is the atmospheric pressure,
at the upper boundary.
Filename: ``seismic2D.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:acoustics:

Project 27: Model 3D acoustic waves in a room
---------------------------------------------

The equation for sound waves in air is derived in the section :ref:`wave:app:sound`
and reads


.. math::
         p_{tt} = c^2\nabla^2 p,

where :math:`p(x,y,z,t)` is the pressure and :math:`c`
is the speed of sound, taken as 340 m/s.

.. air at a room temperature 20 C, :math:`p_0` is reference pressure in the

.. air, typically 1 atm (approximately :math:`10^5` Pa), and :math:`\varrho_0` is

.. the density of air, taken as :math:`1.225\mbox{ kg/m}^3`.

However, sound is absorbed in the air due to relaxation of molecules
in the gas. A model for simple relaxation, valid for gases consisting
only of one type of molecules, is a term :math:`c^2\tau_s\nabla^2 p_t` in
the PDE, where :math:`\tau_s` is the relaxation time. If we generate sound
from, e.g., a loudspeaker in the room, this sound source must also
be added to the governing equation.

The PDE with the mentioned type of damping and source then becomes


.. math::
        
        p_tt = c^2\nabla^p + c^2\tau_s\nabla^2 p_t + f,
        

where :math:`f(x,y,z,t)` is the source term.

The walls can absorb some sound. A possible model is to have a "wall layer"
(thicker than the physical wall)
outside the room where :math:`c` is changed such that some of the wave energy
is reflected and some is absorbed in the wall. The absorption of
energy can be taken care of by adding a damping term :math:`bp_t` in
the equation:


.. math::
        
        p_tt + bp_t = c^2\nabla^p + c^2\tau_s\nabla^2 p_t + f{\thinspace .}
        

Typically, :math:`b=0` in the room and :math:`b>0` in the wall. A discontinuity in :math:`b`
or :math:`c` will give rise to reflections. It can be wise to use a constant
:math:`c` in the wall to control reflections because of the discontinuity between
:math:`c` in the air and in the wall, while :math:`b` is gradually increased
as we go into the wall to avoid reflections because of rapid changes in :math:`b`.
At the outer boundary of the wall the condition :math:`p=0` or :math:`\partial p/\partial n=0` can be imposed. The waves should anyway be approximately dampened
to :math:`p=0` this far out in the wall layer.

There are two strategies for discretizing the :math:`\nabla^2 p_t` term: using
a center difference between times :math:`n+1` and :math:`n-1` (if the equation is
sampled at level :math:`n`), or use a one-sided difference based on levels :math:`n`
and :math:`n-1`. The latter has the advantage of not leading to any equation system,
while the former is second-order accurate as the scheme for the
simple wave equation :math:`p_tt = c^2\nabla^2 p`. To avoid an equation system,
go for the one-sided difference such that the overall scheme becomes
explicit and only of first order in time.

Develop a 3D solver for the specified PDE and introduce a wall layer.
Test the solver with the method of manufactured solutions. Make some
demonstrations where the wall reflects and absorbs the waves (reflection
because of discontinuity in :math:`b` and absorption because of growing :math:`b`).
Experiment with the impact of the :math:`\tau_s` parameter.
Filename: ``acoustics.py``.

.. --- end exercise ---





.. --- begin exercise ---


.. _wave:app:exer:advec1D:

Project 28: Solve a 1D transport equation
-----------------------------------------

We shall study the wave equation


.. math::
   :label: wave:app:exer:advec1D:ueq
        
        u_t + cu_x = 0,\quad x\in (0,L],\ t\in (0, T],
        
        

with initial condition


.. math::
        
        u(x,0) = I(x),\quad x\in [0,L],
        

and *one* periodic boundary condition


.. math::
        
        u(0,t) = u(L,t)
        \thinspace .
        

This boundary condition means that what goes out of the domain at :math:`x=L`
comes in at :math:`x=0`. Roughly speaking,
we need only one boundary condition because of
the spatial derivative is of first order only.

*Physical interpretation.* The parameter :math:`c` can be constant or variable, :math:`c=c(x)`. The
equation :eq:`wave:app:exer:advec1D:ueq` arises in *transport*
problems where a quantity :math:`u`, which could be temperature or
concentration of some contaminant, is transported with the velocity
:math:`c` of a fluid. In addition to the transport imposed by "travelling with
the fluid", :math:`u` may also be transported by diffusion (such as
heat conduction or Fickian diffusion), but we have in
the model :math:`u_t + cu_x` assumed that diffusion effects are negligible,
which they often are.


A widely used numerical scheme for :eq:`wave:app:exer:advec1D:ueq`
applies a forward difference in time and a backward difference in
space when :math:`c>0`:


.. math::
   :label: wave:app:exer:advec1D:u:upwind
        
        [D_t^+ u + cD_x^-u = 0]_i^n
        
        \thinspace .
        

For :math:`c<0` we use a forward difference in space: :math:`[cD_x^+u]_i^n`.







We shall hereafter assume that :math:`=c(x)>0`.




To compute :eq:`wave:app:exer:advec1D:u:avar:sol` we need to integrate
:math:`1/c` to obtain :math:`C` and then compute the inverse of :math:`C`.

The inverse function computation can be easily done if we first think
discretely. Say we have some function :math:`y=g(x)` and seeks its inverse.
Plotting :math:`(x_i,y_i)`, where :math:`y_i=g(x_i)` for some mesh points :math:`x_i`,
displays :math:`g` as a function of :math:`x`.
The inverse function is simply :math:`x` as a function of :math:`g`, i.e., the
curve with points :math:`(y_i,x_i)`. We can therefore quickly compute points
at the curve of the inverse function. One way of extending these
points to a continuous function is to assume a linear variation
(known as linear interpolation)
between the points (which actually means to draw straight lines between
the points, exactly as done by a plotting program).

The function ``wrap2callable`` in ``scitools.std`` can take a set of points
and return a continuous function that corresponds to linear
variation between the points. The computation of the inverse of a
function :math:`g` on :math:`[0,L]` can then be done by


.. code-block:: python

        def inverse(g, domain, resolution=101):
            x = linspace(domain[0], domain[L], resolution)
            y = g(x)
            from scitools.std import wrap2callable
            g_inverse = wrap2callable((y, x))
            return g_inverse


To compute :math:`C(x)` we need to integrate :math:`1/c`, which can be done by
a Trapezoidal rule. Suppose we have computed :math:`C(x_i)` and need
to compute :math:`C(x_{i+1})`. Using the Trapezoidal rule with :math:`m` subintervals
over the integration domain :math:`[x_i,x_{i+1}]` gives


.. math::
   :label: wave:app:exer:advec1D:C:recursion
        
        C(x_{i+1}) = C(x_i) + \int_{x_i}^{x_{i+1}} \frac{dx}{c}
        \approx h\left(
        \frac{1}{2}\frac{1}{c(x_i)} + \frac{1}{2}\frac{1}{c(x_{i+1})}
        + \sum_{j=1}^{m-1} \frac{1}{c(x_i + jh)}\right),
        
        

where :math:`h=(x_{i+1}-x_i)/m` is the length of the subintervals used
for the integral over :math:`[x_i,x_{i+1}]`.
We observe that :eq:`wave:app:exer:advec1D:C:recursion` is a
*difference equation* which we can solve by repeatedly
applying :eq:`wave:app:exer:advec1D:C:recursion` for
:math:`i=0,1,\ldots,N_x-1` if a mesh :math:`x_0,x_,\ldots,x_{N_x}` is prescribed.
Note that :math:`C(0)=0`.





.. Idea: one thing at a time: no f2py intro for du/dn, just u=0 to make it

.. simple


.. 1D open boundary cond, try u=0 and du/dn=0 combination too

.. 1D correction terms


.. migrate to compiled: idea is to keep it very simple (u=0 cond), or maybe

.. do it in 1D? No, better in 2D, but have f(x,y) as an array (no callback)

.. 2D

.. 2D code simple, u=0, constant coeff

.. 2D visualization with mayavi2, matplotlib, gnuplot (scitools), + mpeg/avi

.. 2D code vectorized

.. 2D code cython

.. 2D code f2py

.. 2D code instant


.. Exer: f2py w/callback to Python for f and inlet U_0


.. 3D

.. 3D code vectorized

.. 3D code cython

.. main point: visualization with paraview or similar


.. apps:

.. shallow water, 1D and 2D

.. string

.. pipe

.. 3D acoustic

.. elastic in the ground, div u

.. blood 1D



*a)* Show that under the assumption of :math:`a=\hbox{const}`,


.. math::
   :label: wave:app:exer:advec1D:uexact
        
        u(x,t) = I(x - ct)
        
        

fulfills the PDE as well as the initial and boundary condition
(provided :math:`I(0)=I(L)`).

*b)* Set up a computational algorithm and implement it in a function.
Assume :math:`a` is constant and positive.

*c)* Test implementation by using the remarkable property that
the numerical solution is exact at the mesh points if
:math:`\Delta t = c^{-1}\Delta x`.

*d)* Make a movie comparing the numerical and exact solution for the
following two choices of initial conditions:


.. math::
   :label: wave:app:exer:advec1D:I:sin
        
         I(x) = \left\lbrack\sin\left(\pi\frac{x}{L}\right)\right\rbrack^{2n}
        
        

where :math:`n` is an integer, typically :math:`n=5`,
and


.. math::
   :label: wave:app:exer:advec1D:I:gauss
        
        I(x) = \exp{\left( -\frac{(x-L/2)^2}{2\sigma2}\right)} \thinspace .
        
        

Choose :math:`\Delta t = c^{-1}\Delta x, 0.9c^{-1}\Delta x, 0.5c^{-1}\Delta x`.

*e)* The performance of the suggested numerical scheme can be investigated
by analyzing the numerical dispersion relation.
Analytically, we have that the *Fourier component*


.. math::
         u(x,t) = e^{i(kx-\omega t)},

is a solution of the PDE if :math:`\omega = kc`. This is the *analytical
dispersion relation*. A complete solution of the PDE can be built by
adding up such Fourier components with different amplitudes, where the
initial condition :math:`I` determines the amplitudes. The solution :math:`u` is
then represented by a Fourier series.

A similar discrete Fourier component at :math:`(x_p,t_n)` is


.. math::
         u_p^q = e^{i(kp\Delta x -\tilde\omega n\Delta t)},

where in general :math:`\tilde\omega` is a function of :math:`k`, :math:`\Delta t`, and
:math:`\Delta x`, and differs from the exact :math:`\omega =kc`.

Insert the discrete Fourier component in the numerical scheme and
derive an expression for :math:`\tilde\omega`, i.e.,
the discrete dispersion relation. Show in particular that if
the :math:`\Delta t/(c\Delta x)=1`, the discrete solution coincides with the
exact solution at the mesh points, regardless of the mesh resolution (!).
Show that if the stability condition


.. math::
         \frac{\Delta t}{c\Delta x}\leq 1,

the discrete Fourier component cannot grow (i.e., :math:`\tilde\omega` is real).

*f)* Write a test for your implementation where you try to use information
from the numerical dispersion relation.

*g)* Set up a computational algorithm for the variable
coefficient case and implement it in a function.
Make a test that the function works for constant :math:`a`.

*h)* It can be shown that
for an observer moving with velocity :math:`c(x)`, :math:`u` is constant.
This can be used to derive an exact solution when :math:`a` varies
with :math:`x`. Show first that


.. math::
   :label: wave:app:exer:advec1D:u:avar:sol
        
        u(x,t) = f(C(x) - t),
        
        

where


.. math::
         C'(x) = \frac{1}{c(x)},

is a solution of :eq:`wave:app:exer:advec1D:ueq` for any
differentiable function :math:`f`.


.. --- begin solution of exercise ---

*Solution.* Let :math:`\xi = C(x) - t`.
We have that

.. math::
         u_t = f'(\xi)(-1),

while

.. math::
         u_x = f'(\xi)C'(x) = f'(\xi)\frac{1}{c(x)},

implying that :math:`au_x = f'(\xi)`. Then we have :math:`u_t + cu_x= -f'(\xi) +
f'(\xi) = 0`.

.. --- end solution of exercise ---


*i)* Use the initial condition to show that an exact solution is


.. math::
         u(x,t) = I(C^{-1}(C(x)-t)),

with :math:`C^{-1}` being the inverse function of :math:`C = \int c^{1}dx`.
Since :math:`C(x)` is an integral :math:`\int_0^x (1/c)dx`,
:math:`C(x)` is monotonically increasing and there exists hence an
inverse function :math:`C^{-1}` with values in :math:`[0,L]`.


.. --- begin solution of exercise ---

*Solution.* In general we have :math:`u(x,t) = f(C(x)-t)` and the solution is
of this form with :math:`f(\xi)=I(C^{-1}(\xi))`.
Moreover, at :math:`t=0` we have
:math:`I(C^{-1}(C(x)))=I(x)`, which is the required initial condition.

.. --- end solution of exercise ---


*j)* Implement a function for computing :math:`C(x_i)` and one for computing
:math:`C^{-1}(x)` for any :math:`x`. Use these two functions for computing
the exact solution :math:`I(C^{-1}(C(x)-t))`.
End up with a function ``u_exact_variable_c(x, n, c, I)`` that returns
the value of :math:`I(C^{-1}(C(x)-t_n))`.

*k)* Make movies showing a comparison of the numerical and exact solutions
for the two initial conditions
:eq:`wave:app:exer:advec1D:I:sin` and :eq:`wave:app:exer:advec1D:I:gauss`.
Choose :math:`\Delta t = \Delta x /\max_{0,L} c(x)`
and the velocity of the medium as

1. :math:`c(x) = 1 + \epsilon\sin(k\pi x/L)`, :math:`\epsilon <1`,

2. :math:`c(x) = 1 + I(x)`, where :math:`I` is given by
   :eq:`wave:app:exer:advec1D:I:sin` or :eq:`wave:app:exer:advec1D:I:gauss`.

The PDE :math:`u_t + cu_x=0` expresses that the initial condition :math:`I(x)`
is transported with velocity :math:`c(x)`.

Filename: ``advec1D.py``.

.. --- end exercise ---


