<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study Guide: Introduction to Finite Element Methods">
<meta name="keywords" content="approximation of general vectors,Galerkin method,projection,approximation of functions,approximation by sines,collocation method (approximation),approximation collocation,Lagrange (interpolating) polynomial,sparse matrices,mass matrix,mass lumping,lumped mass matrix,finite element, definition,dof map,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,Midpoint rule,Trapezoidal rule,Simpson's rule,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,isoparametric mapping,mapping of reference cells isoparametric mapping,trial function,test function,trial space,test space,integration by parts">







<!-- reveal.js: http://lab.hakim.se/reveal-js/ -->

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/reveal.min.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
-->

<script>
document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
</script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .reveal .alert-text-small   { font-size: 80%;  }
    .reveal .alert-text-large   { font-size: 130%; }
    .reveal .alert-text-normal  { font-size: 90%;  }
    .reveal .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
             -webkit-border-radius: 14px; -moz-border-radius: 14px;
             border-radius:14px
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .reveal .alert-block {padding-top:14px; padding-bottom:14px}
     .reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
     /*.reveal .alert li {margin-top: 1em}*/
     .reveal .alert-block p+p {margin-top:5px}
     /*.reveal .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
     .reveal .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
     .reveal .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
     .reveal .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body>
<div class="reveal">

<!-- Any section element inside the <div class="slides"> container
     is displayed as a slide -->

<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}

\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    



<section>
<!-- ------------------- main content ---------------------- -->


<title>Study Guide: Introduction to Finite Element Methods</title>

<center><h1>Study Guide: Introduction to Finite Element Methods</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>&nbsp;<br>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>&nbsp;<br>
<center><h4>Nov 29, 2013</h4></center> <!-- date -->
<p>

</section>


<section>

<h2>Why finite elements?  <a name="___sec0"></a></h2>

<p>

<ul>
 <p><li> Can with ease solve PDEs in domains with <em>complex geometry</em></li>
 <p><li> Can with ease provide higher-order approximations</li>
 <p><li> Has (in simpler stationary problems) a rigorus mathematical
   analysis framework (not much considered here)
<!-- The theoretical framework is not powerful enough to uncover the -->
<!-- serious limitations of the method in time-dependent problems -->
<!-- and the necessary adjustments) --></li>
</ul>
<p>


</section>


<section>

<h3>Domain for flow around a dolphin  <a name="___sec1"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_mesh.png" align="bottom" width=400,></p></center>

<p>

</section>


<section>

<h3>The flow  <a name="___sec2"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_flow.gif" align="bottom" width=400,></p></center>

<p>

</section>


<section>

<h3>Basic ingredients of the finite element method  <a name="___sec3"></a></h3>

<p>

<ul>
 <p><li> Transform the PDE problem to a <em>variational form</em></li>
 <p><li> Define function approximation over <em>finite elements</em></li>
 <p><li> Use a machinery to derive <em>linear systems</em></li>
 <p><li> Solve linear systems</li>
</ul>
<p>


</section>


<section>

<h3>Our learning strategy  <a name="___sec4"></a></h3>

<p>

<ul>
 <p><li> Start with approximation of functions, not PDEs</li>
 <p><li> Introduce finite element <em>approximations</em></li>
 <p><li> See later how this is applied to PDEs</li>
</ul>
<p>

Reason: the finite element method has many concepts and a jungle of details.
This strategy minimizes the mixing of ideas, concepts, and technical details.

<p>

</section>


<section>

<h2>Approximation in vector spaces  <a name="___sec5"></a></h2>

<p>
<center><p><img src="fig-fem/vecapprox_plane.png" align="bottom" width=300></p></center>

<p>

</section>


<section>

<h3>Approximation set-up  <a name="___sec6"></a></h3>

<p>
General idea of finding an approximation \( u(x) \) to some given \( f(x) \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
 u(x) = \sum_{i=0}^N c_i\baspsi_i(x)
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>


<p>
where

<p>

<ul>
 <p><li> \( \baspsi_i(x) \) are prescribed functions</li>
 <p><li> \( c_i \), \( i=0,\ldots,N \) are unknown coefficients to be determined</li>
</ul>
<p>


</section>


<section>

<h3>How to determine the coefficients?  <a name="___sec7"></a></h3>

<p>
We shall address three approaches:

<p>

<ul>
 <p><li> The least squares method</li>
 <p><li> The projection (or Galerkin) method</li>
 <p><li> The interpolation (or collocation) method</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal"><b>Underlying motivation for our notation.</b>
Our mathematical framework for doing this is phrased in a way such
that it becomes easy to understand and use the <a href="http://fenicsproject.org" target="_self">FEniCS</a> software package for finite element computing.
</div>


<p>

</section>


<section>

<h3>Approximation of planar vectors; problem <a name="fem:approx:vec:plane"></a></h3>

<p>
Given a vector \( \f = (3,5) \), find an approximation
to \( \f \) directed along a given line.

<p>
<center><p><img src="fig-fem/vecapprox_plane.png" align="bottom" width=300></p></center>

<p>

</section>


<section>

<h3>Approximation of planar vectors; vector space terminology  <a name="___sec9"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
V = \mbox{span}\,\{ \psib_0\}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \psib_0 \) is a basis vector in the space \( V \)</li>
 <p><li> Seek \( \u = c_0\psib_0\in V \)</li>
 <p><li> Determine \( c_0 \) such that \( \u \) is the "best" approximation to \( \f \)</li>
 <p><li> Visually, "best" is obvious</li>
</ul>
<p>

Define

<p>

<ul>
 <p><li> the error \( \e = \f - \u \)</li>
 <p><li> the (Eucledian) scalar product of two vectors: \( (\u,\v) \)</li>
 <p><li> the norm of \( \e \): \( ||\e|| = \sqrt{(\e, \e)} \)</li>
</ul>
<p>


</section>


<section>

<h3>The least squares method; principle  <a name="___sec10"></a></h3>

<p>

<ul>
 <p><li> Idea: find \( c_0 \) such that \( ||\e|| \) is minimized</li>
 <p><li> Actually, we always minimize \( E=||\e||^2 \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_0} = 0
\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The least squares method; calculations  <a name="___sec11"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
E(c_0) = (\e,\e) = (\f,\f) - 2c_0(\f,\psib_0) + c_0^2(\psib_0,\psib_0)
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\psib_0) + 2c_0 (\psib_0,\psib_0) = 0
\tag{2}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = \frac{(\f,\psib_0)}{(\psib_0,\psib_0)}
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = \frac{3a + 5b}{a^2 + b^2}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Observation for later: the vanishing derivative <a href="#mjx-eqn-2">(2)</a>
can be alternatively written as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\e, \psib_0) = 0
\tag{4}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The projection (or Galerkin) method  <a name="___sec12"></a></h3>

<p>

<ul>
 <p><li> Backgrund: minimizing \( ||\e||^2 \) implies that \( \e \) is
   orthogonal to <em>any</em> vector \( \v \) in the space \( V \)
   (visually clear, but can easily be computed too)</li>
 <p><li> Alternative idea: demand \( (\e, \v) = 0,\quad\forall\v\in V \)</li>
 <p><li> Equivalent statement: \( (\e, \psib_0)=0 \) (see notes for why)</li>
 <p><li> Insert \( \e = \f - c_0\psib_0 \) and solve for \( c_0 \)</li>
 <p><li> Same equation for \( c_0 \) and hence same solution as in the least squares
   method</li>
</ul>
<p>


</section>


<section>

<h3>Approximation of general vectors <a name="fem:approx:vec:Np1dim"></a></h3>

<p>
Given a vector \( \f \), find an approximation \( \u\in V \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\psib_0,\ldots,\psib_N\}
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> We have a set of linearly independent basis vectors
   \( \psib_0,\ldots,\psib_N \)</li>
 <p><li> Any \( \u\in V \) can then be written as \( \u = \sum_{j=0}^Nc_j\psib_j \)</li>
</ul>
<p>


</section>


<section>

<h3>The least squares method  <a name="___sec14"></a></h3>

<p>
Idea: find \( c_0,\ldots,c_N \) such that \( E= ||\e||^2 \) is minimized, \( \e=\f-\u \).

<p>
<p>&nbsp;<br>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\psib_j,\f -\sum_jc_j\psib_j)
\nonumber\\ 
&= (\f,\f) - 2\sum_{j=0}^Nc_j(\f,\psib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)
\end{align*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\end{equation*}
$$
<p>&nbsp;<br>


<p>
After some work we end up with a <em>linear system</em>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j=0}^N A_{i,j}c_j &= b_i,\quad i=0,\ldots,N\\ 
A_{i,j} &= (\psib_i,\psib_j)\\ 
b_i &= (\psib_i, \f)
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The projection (or Galerkin) method  <a name="___sec15"></a></h3>

<p>
Can be shown that minimizing \( ||\e|| \) implies that
\( \e \) is orthogonal to all \( \v\in V \):

<p>
<p>&nbsp;<br>
$$
(\e,\v)=0,\quad \forall\v\in V
$$
<p>&nbsp;<br>

which implies that \( \e \) most be orthogonal to each basis vector:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\e,\psib_i)=0,\quad i=0,\ldots,N
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>


<p>
This orthogonality condition is the principle of the projection
(or Galerkin) method. Leads to
the same linear system as in the least squares method.

<p>

</section>


<section>

<h2>Approximation of functions <a name="fem:approx:global"></a></h2>

<p>
Let \( V \) be a <em>function space</em> spanned by a set of <em>basis functions</em>
\( \baspsi_0,\ldots,\baspsi_N \),

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\baspsi_0,\ldots,\baspsi_N\}
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Find \( u\in V \) as a linear
combination of the basis functions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u = \sum_{j\in\If} c_j\baspsi_j,\quad\If = \{0,1,\ldots,N\}
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The least squares method <a name="fem:approx:LS"></a></h3>

<p>

<ul>
 <p><li> Extend the ideas from the vector case: minimize the (square) norm
   of the error.</li>
 <p><li> What norm? \( (f,g) = \int_\Omega f(x)g(x)\, dx \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
E = (e,e) = (f-u,f-u) = (f(x)-\sum_{j\in\If} c_j\baspsi_j(x), f(x)-\sum_{j\in\If} c_j\baspsi_j(x))
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
E(c_0,\ldots,c_N) = (f,f) -2\sum_{j\in\If} c_j(f,\baspsi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\baspsi_p,\baspsi_q)
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=\in\If
\end{equation*}
$$
<p>&nbsp;<br>


<p>
After computations <em>identical to the vector case</em>, we get a linear system

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j\in\If}^N A_{i,j}c_j &= b_i,\quad i\in\If
\tag{8}\\ 
A_{i,j} &= (\baspsi_i,\baspsi_j)
\tag{9}\\ 
b_i &= (f,\baspsi_i)
\tag{10}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The projection (or Galerkin) method  <a name="___sec18"></a></h3>

<p>
As before, minimizing \( (e,e) \) is equivalent to the projection (or Galerkin)
method

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(e,v)=0,\quad\forall v\in V
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>

which means, as before,

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(e,\baspsi_i)=0,\quad i\in\If
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>


<p>
With the same algebra as in the multi-dimensional vector case,
we get the same linear system as arose from the least squares method.

<p>

</section>


<section>

<h3>Example: linear approximation; problem <a name="fem:approx:global:linear"></a></h3>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b>Problem.</b>
Approximate a parabola \( f(x) = 10(x-1)^2 - 1 \) by a straight line.
</div>


<p>
<p>&nbsp;<br>
$$
\begin{equation*} V = \hbox{span}\,\{1, x\}  \end{equation*}
$$
<p>&nbsp;<br>

That is, \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=x \), and \( N=1 \).
We seek

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
u=c_0\baspsi_0(x) + c_1\baspsi_1(x) = c_0 + c_1x
\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example: linear approximation; solution  <a name="___sec20"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_1^21\cdot 1\, dx = 1\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_1^2 1\cdot x\, dx = 3/2\\ 
A_{1,0} &= A_{0,1} = 3/2\\ 
A_{1,1} &= (\baspsi_1,\baspsi_1) = \int_1^2 x\cdot x\,dx = 7/3
\end{align}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align}
b_1 &= (f,\baspsi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3\\ 
b_2 &= (f,\baspsi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3
\end{align}
$$
<p>&nbsp;<br>

Solution of 2x2 linear system:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = -38/3,\quad c_1 = 10,\quad u(x) = 10x - \frac{38}{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example: linear approximation; plot  <a name="___sec21"></a></h3>

<p>
<center><p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Implementation of the least squares method; ideas <a name="fem:approx:global:LS:code"></a></h3>

<p>
Consider symbolic computation of the linear system,
where

<p>

<ul>
 <p><li> \( f(x) \) is given as a <code>sympy</code> expression <code>f</code> (involving
   the symbol <code>x</code>),</li>
 <p><li> <code>psi</code> is a list of \( \sequencei{\baspsi} \),</li>
 <p><li> <code>Omega</code> is a 2-tuple/list holding the domain \( \Omega \)</li>
</ul>
<p>

Carry out the integrations, solve the linear system, and
return \( u(x)=\sum_jc_j\baspsi_j(x) \)

<p>

</section>


<section>

<h3>Implementation of the least squares method; symbolic code  <a name="___sec23"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #447fcf; text-decoration: underline">sympy</span> <span style="color: #6ab825; font-weight: bold">as</span> <span style="color: #447fcf; text-decoration: underline">sp</span>

<span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">least_squares</span><span style="color: #d0d0d0">(f,</span> <span style="color: #d0d0d0">psi,</span> <span style="color: #d0d0d0">Omega):</span>
    <span style="color: #d0d0d0">N</span> <span style="color: #d0d0d0">=</span> <span style="color: #24909d">len</span><span style="color: #d0d0d0">(psi)</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">1</span>
    <span style="color: #d0d0d0">A</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.zeros((N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #d0d0d0">b</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.zeros((N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">):</span>
        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">j</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(i,</span> <span style="color: #d0d0d0">N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">):</span>
            <span style="color: #d0d0d0">A[i,j]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.integrate(psi[i]*psi[j],</span>
                                  <span style="color: #d0d0d0">(x,</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]))</span>
            <span style="color: #d0d0d0">A[j,i]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A[i,j]</span>
        <span style="color: #d0d0d0">b[i,</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.integrate(psi[i]*f,</span> <span style="color: #d0d0d0">(x,</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]))</span>
    <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A.LUsolve(b)</span>
    <span style="color: #d0d0d0">u</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">0</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(psi)):</span>
        <span style="color: #d0d0d0">u</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">c[i,</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]*psi[i]</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">c</span>
</pre></div>
<p>
Observe: symmetric coefficient matrix so we can halve the integrations.

<p>

</section>


<section>

<h3>Implementation of the least squares method; numerical code  <a name="___sec24"></a></h3>

<p>

<ul>
 <p><li> Symbolic integration may be impossible and/or very slow</li>
 <p><li> Turn to pure numerical computations in those cases</li>
 <p><li> Supply Python functions <code>f(x)</code>, <code>psi(x,i)</code>, and a mesh <code>x</code></li>
</ul>
<p>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">least_squares_numerical</span><span style="color: #d0d0d0">(f,</span> <span style="color: #d0d0d0">psi,</span> <span style="color: #d0d0d0">N,</span> <span style="color: #d0d0d0">x,</span>
                            <span style="color: #d0d0d0">integration_method=</span><span style="color: #ed9d13">&#39;scipy&#39;</span><span style="color: #d0d0d0">,</span>
                            <span style="color: #d0d0d0">orthogonal_basis=</span><span style="color: #24909d">False</span><span style="color: #d0d0d0">):</span>
    <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #447fcf; text-decoration: underline">scipy.integrate</span>
    <span style="color: #d0d0d0">A</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">np.zeros((N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #d0d0d0">b</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">np.zeros(N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)</span>
    <span style="color: #d0d0d0">Omega</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[x[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">x[-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]]</span>
    <span style="color: #d0d0d0">dx</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">x[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">x[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>

    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">):</span>
        <span style="color: #d0d0d0">j_limit</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">i+</span><span style="color: #3677a9">1</span> <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">orthogonal_basis</span> <span style="color: #6ab825; font-weight: bold">else</span> <span style="color: #d0d0d0">N+</span><span style="color: #3677a9">1</span>
        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">j</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(i,</span> <span style="color: #d0d0d0">j_limit):</span>
            <span style="color: #6ab825; font-weight: bold">print</span> <span style="color: #ed9d13">&#39;(%d,%d)&#39;</span> <span style="color: #d0d0d0">%</span> <span style="color: #d0d0d0">(i,</span> <span style="color: #d0d0d0">j)</span>
            <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">integration_method</span> <span style="color: #d0d0d0">==</span> <span style="color: #ed9d13">&#39;scipy&#39;</span><span style="color: #d0d0d0">:</span>
                <span style="color: #d0d0d0">A_ij</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">scipy.integrate.quad(</span>
                    <span style="color: #6ab825; font-weight: bold">lambda</span> <span style="color: #d0d0d0">x:</span> <span style="color: #d0d0d0">psi(x,i)*psi(x,j),</span>
                    <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">epsabs=</span><span style="color: #3677a9">1E-9</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">epsrel=</span><span style="color: #3677a9">1E-9</span><span style="color: #d0d0d0">)[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
            <span style="color: #6ab825; font-weight: bold">elif</span> <span style="color: #d0d0d0">...</span>
            <span style="color: #d0d0d0">A[i,j]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A[j,i]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A_ij</span>

        <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">integration_method</span> <span style="color: #d0d0d0">==</span> <span style="color: #ed9d13">&#39;scipy&#39;</span><span style="color: #d0d0d0">:</span>
            <span style="color: #d0d0d0">b_i</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">scipy.integrate.quad(</span>
                <span style="color: #6ab825; font-weight: bold">lambda</span> <span style="color: #d0d0d0">x:</span> <span style="color: #d0d0d0">f(x)*psi(x,i),</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span>
                <span style="color: #d0d0d0">epsabs=</span><span style="color: #3677a9">1E-9</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">epsrel=</span><span style="color: #3677a9">1E-9</span><span style="color: #d0d0d0">)[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
        <span style="color: #6ab825; font-weight: bold">elif</span> <span style="color: #d0d0d0">...</span>
        <span style="color: #d0d0d0">b[i]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">b_i</span>

    <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">b/np.diag(A)</span> <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">orthogonal_basis</span> <span style="color: #6ab825; font-weight: bold">else</span> <span style="color: #d0d0d0">np.linalg.solve(A,</span> <span style="color: #d0d0d0">b)</span>
    <span style="color: #d0d0d0">u</span> <span style="color: #d0d0d0">=</span> <span style="color: #24909d">sum</span><span style="color: #d0d0d0">(c[i]*psi(x,</span> <span style="color: #d0d0d0">i)</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">c</span>
</pre></div>
<p>

</section>


<section>

<h3>Implementation of the least squares method; plotting  <a name="___sec25"></a></h3>

<p>
Compare \( f \) and \( u \) visually:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">comparison_plot</span><span style="color: #d0d0d0">(f,</span> <span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">Omega,</span> <span style="color: #d0d0d0">filename=</span><span style="color: #ed9d13">&#39;tmp.pdf&#39;</span><span style="color: #d0d0d0">):</span>
    <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #999999; font-style: italic"># Turn f and u to ordinary Python functions</span>
    <span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.lambdify([x],</span> <span style="color: #d0d0d0">f,</span> <span style="color: #d0d0d0">modules=</span><span style="color: #ed9d13">&quot;numpy&quot;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #d0d0d0">u</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.lambdify([x],</span> <span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">modules=</span><span style="color: #ed9d13">&quot;numpy&quot;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #d0d0d0">resolution</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">401</span>  <span style="color: #999999; font-style: italic"># no of points in plot</span>
    <span style="color: #d0d0d0">xcoor</span>  <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">linspace(Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">resolution)</span>
    <span style="color: #d0d0d0">exact</span>  <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">f(xcoor)</span>
    <span style="color: #d0d0d0">approx</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">u(xcoor)</span>
    <span style="color: #d0d0d0">plot(xcoor,</span> <span style="color: #d0d0d0">approx)</span>
    <span style="color: #d0d0d0">hold(</span><span style="color: #ed9d13">&#39;on&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #d0d0d0">plot(xcoor,</span> <span style="color: #d0d0d0">exact)</span>
    <span style="color: #d0d0d0">legend([</span><span style="color: #ed9d13">&#39;approximation&#39;</span><span style="color: #d0d0d0">,</span> <span style="color: #ed9d13">&#39;exact&#39;</span><span style="color: #d0d0d0">])</span>
    <span style="color: #d0d0d0">savefig(filename)</span>
</pre></div>
<p>
All code in module <a href="http://tinyurl.com/jvzzcfn/fem/approx1D.py" target="_self"><tt>approx1D.py</tt></a>

<p>

</section>


<section>

<h3>Implementation of the least squares method; application  <a name="___sec26"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">approx1D</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #d0d0d0">*</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">10</span><span style="color: #d0d0d0">*(x-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">-</span><span style="color: #3677a9">1</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">least_squares(f=f,</span> <span style="color: #d0d0d0">psi=[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">x],</span> <span style="color: #d0d0d0">Omega=[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">])</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">comparison_plot(f,</span> <span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">Omega=[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">])</span>
</pre></div>
<p>
<center><p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Perfect approximation; parabola approximating parabola <a name="fem:approx:global:exact"></a></h3>

<p>

<ul>
 <p><li> What if we add \( \baspsi_2=x^2 \) to the space \( V \)?</li>
 <p><li> That is, approximating a parabola by any parabola?</li>
 <p><li> (Hopefully we get the exact parabola!)</li>
</ul>
<p>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">approx1D</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #d0d0d0">*</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">10</span><span style="color: #d0d0d0">*(x-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">-</span><span style="color: #3677a9">1</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">least_squares(f=f,</span> <span style="color: #d0d0d0">psi=[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">x,</span> <span style="color: #d0d0d0">x**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega=[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">])</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #6ab825; font-weight: bold">print</span> <span style="color: #d0d0d0">u</span>
<span style="color: #3677a9">10</span><span style="color: #d0d0d0">*x**</span><span style="color: #3677a9">2</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">20</span><span style="color: #d0d0d0">*x</span> <span style="color: #d0d0d0">+</span> <span style="color: #3677a9">9</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #6ab825; font-weight: bold">print</span> <span style="color: #d0d0d0">sp.expand(f)</span>
<span style="color: #3677a9">10</span><span style="color: #d0d0d0">*x**</span><span style="color: #3677a9">2</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">20</span><span style="color: #d0d0d0">*x</span> <span style="color: #d0d0d0">+</span> <span style="color: #3677a9">9</span>
</pre></div>
<p>

</section>


<section>

<h3>Perfect approximation; the general result  <a name="___sec28"></a></h3>

<p>

<ul>
 <p><li> What if we use \( \psi_i(x)=x^i \) for \( i=0,\ldots,N=40 \)?</li>
 <p><li> The output from <code>least_squares</code> is \( c_i=0 \) for \( i>2 \)</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal"><b>General result.</b>
If \( f\in V \), least squares and projection/Galerkin give \( u=f \).
</div>


<p>

</section>


<section>

<h3>Perfect approximation; proof of the general result  <a name="___sec29"></a></h3>

<p>
If \( f\in V \), \( f=\sum_{j\in\If}d_j\baspsi_j \), for
some  \( \sequencei{d} \). Then

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
b_i = (f,\baspsi_i) = \sum_{j\in\If}d_j(\baspsi_j, \baspsi_i)
= \sum_{j\in\If} d_jA_{i,j}
\end{equation*}
$$
<p>&nbsp;<br>

The linear system \( \sum_j A_{i,j}c_j = b_i \), \( i\in\If \), is then

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\sum_{j\in\If}c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},\quad i\in\If
\end{equation*}
$$
<p>&nbsp;<br>

which implies that \( c_i=d_i \) for \( i\in\If \) and \( u \) is identical to \( f \).

<p>

</section>


<section>

<h3>Finite-precision/numerical computations <a name="fem:approx:global:illconditioning"></a></h3>

<p>
The previous computations were symbolic. What if we solve the
linear system numerically with standard arrays?

<p>
<table border="1">
<tr><td align="center"><b>        exact         </b></td> <td align="center"><b>  <code>sympy</code>  </b></td> <td align="center"><b> <code>numpy32</code> </b></td> <td align="center"><b> <code>numpy64</code> </b></td> </tr>
<tr><td align="right">   9                       </td> <td align="right">   9.62                    </td> <td align="right">   5.57                    </td> <td align="right">   8.98                    </td> </tr>
<tr><td align="right">   -20                     </td> <td align="right">   -23.39                  </td> <td align="right">   -7.65                   </td> <td align="right">   -19.93                  </td> </tr>
<tr><td align="right">   10                      </td> <td align="right">   17.74                   </td> <td align="right">   -4.50                   </td> <td align="right">   9.96                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -9.19                   </td> <td align="right">   4.13                    </td> <td align="right">   -0.26                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   5.25                    </td> <td align="right">   2.99                    </td> <td align="right">   0.72                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.18                    </td> <td align="right">   -1.21                   </td> <td align="right">   -0.93                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -2.48                   </td> <td align="right">   -0.41                   </td> <td align="right">   0.73                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   1.81                    </td> <td align="right">   -0.013                  </td> <td align="right">   -0.36                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.66                   </td> <td align="right">   0.08                    </td> <td align="right">   0.11                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.12                    </td> <td align="right">   0.04                    </td> <td align="right">   -0.02                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.001                  </td> <td align="right">   -0.02                   </td> <td align="right">   0.002                   </td> </tr>
</table>
<p>

<ul>
  <p><li> Column 2: <code>sympy.mpmath.fp.matrix</code> and <code>sympy.mpmath.fp.lu_solve</code></li>
  <p><li> Column 3: <code>numpy</code> arrays with <code>numpy.float32</code> entries</li>
  <p><li> Column 4: <code>numpy</code> arrays with <code>numpy.float64</code> entries</li>
</ul>
<p>


</section>


<section>

<h3>Ill-conditioning (1)  <a name="___sec31"></a></h3>

<p>
Observations:

<p>

<ul>
 <p><li> Significant round-off errors in the numerical computations (!)</li>
 <p><li> But if we plot the approximations they look good (!)</li>
</ul>
<p>

Problem: The basis functions \( x^i \) become almost linearly dependent for
large \( N \).

<p>
<center><p><img src="fig-fem/ill_conditioning.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Ill-conditioning (2)  <a name="___sec32"></a></h3>

<p>

<ul>
  <p><li> Almost linearly dependent basis functions give almost singular matrices</li>
  <p><li> Such matrices are said to be <em>ill conditioned</em>, and Gaussian elimination
    is severely affected by round-off errors</li>
  <p><li> The basis \( 1, x, x^2, x^3, x^4, \ldots \) is a bad basis</li>
  <p><li> Polynomials are fine as basis, but the more orthogonal they are,
    \( (\baspsi_i,\baspsi_j)\approx 0 \), the better</li>
</ul>
<p>


</section>


<section>

<h3>Fourier series approximation; problem and code <a name="fem:approx:global:Fourier"></a></h3>

<p>
Consider

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">N</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">3</span>
<span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">sympy</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #d0d0d0">sin,</span> <span style="color: #d0d0d0">pi</span>
<span style="color: #d0d0d0">psi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[sin(pi*(i+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)*x)</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)]</span>
<span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">10</span><span style="color: #d0d0d0">*(x-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)**</span><span style="color: #3677a9">2</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">1</span>
<span style="color: #d0d0d0">Omega</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">least_squares(f,</span> <span style="color: #d0d0d0">psi,</span> <span style="color: #d0d0d0">Omega)</span>
<span style="color: #d0d0d0">comparison_plot(f,</span> <span style="color: #d0d0d0">u,</span> <span style="color: #d0d0d0">Omega)</span>
</pre></div>
<p>

</section>


<section>

<h3>Fourier series approximation; plot  <a name="___sec34"></a></h3>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-fem/parabola_ls_sines4_12.png" align="bottom" width=800,></p></center>

<p>

</section>


<section>

<h3>Fourier series approximation; improvements  <a name="___sec35"></a></h3>

<p>

<ul>
 <p><li> Considerably improvement by \( N=11 \)</li>
 <p><li> But always discrepancy of \( f(0)-u(0)=9 \) at \( x=0 \), because all the
   \( \baspsi_i(0)=0 \) and hence \( u(0)=0 \)</li>
 <p><li> Possible remedy: add a term that leads to correct boundary values</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
u(x) = f(0)(1-x) + xf(1) + \sum_{j\in\If} c_j\baspsi_j(x)
\end{equation}
$$
<p>&nbsp;<br>

The extra term ensures \( u(0)=f(0) \) and \( u(1)=f(1) \) and
is a strikingly good help to get a good
approximation!

<p>

</section>


<section>

<h3>Fourier series approximation; final results  <a name="___sec36"></a></h3>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-fem/parabola_ls_sines4_12_wfterm.png" align="bottom" width=800,></p></center>

<p>

</section>


<section>

<h3>Orthogonal basis functions  <a name="___sec37"></a></h3>

<p>
This choice of sine functions as basis functions is popular because

<p>

<ul>
 <p><li> the basis functions are orthogonal: \( (\baspsi_i,\baspsi_j)=0 \)</li>
 <p><li> implying that \( A_{i,j} \) is a diagonal matrix</li>
 <p><li> implying that we can solve for \( c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx \)</li>
</ul>
<p>

In general for an orthogonal basis, \( A_{i,j} \) is diagonal and we can
easily solve for \( c_i \):

<p>
<p>&nbsp;<br>
$$
c_i = \frac{b_i}{A_{i,i}} = \frac{(f,\baspsi_i)}{(\baspsi_i,\baspsi_i)}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The collocation or interpolation method; ideas and math <a name="fem:approx:global:interp"></a></h3>

<p>
Here is another idea for approximating \( f(x) \) by \( u(x)=\sum_jc_j\baspsi_j \):

<p>

<ul>
 <p><li> Force \( u(\xno{i}) = f(\xno{i}) \) at some selected <em>collocation</em> points
   \( \sequencei{x} \)</li>
 <p><li> Then \( u \) interpolates \( f \)</li>
 <p><li> The method is known as <em>interpolation</em> or <em>collocation</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i})
\quad i\in\If,N
\end{equation}
$$
<p>&nbsp;<br>


<p>
This is a linear system with no need for integration:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If\\ 
A_{i,j} &= \baspsi_j(\xno{i})\\ 
b_i &= f(\xno{i})
\end{align}
$$
<p>&nbsp;<br>


<p>
No symmetric matrix: \( \baspsi_j(\xno{i})\neq \baspsi_i(\xno{j}) \) in general

<p>

</section>


<section>

<h3>The collocation or interpolation method; implementation  <a name="___sec39"></a></h3>

<p>
<code>points</code> holds the interpolation/collocation points

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">interpolation</span><span style="color: #d0d0d0">(f,</span> <span style="color: #d0d0d0">psi,</span> <span style="color: #d0d0d0">points):</span>
    <span style="color: #d0d0d0">N</span> <span style="color: #d0d0d0">=</span> <span style="color: #24909d">len</span><span style="color: #d0d0d0">(psi)</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">1</span>
    <span style="color: #d0d0d0">A</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.zeros((N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #d0d0d0">b</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.zeros((N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #999999; font-style: italic"># Turn psi and f into Python functions</span>
    <span style="color: #d0d0d0">psi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[sp.lambdify([x],</span> <span style="color: #d0d0d0">psi[i])</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)]</span>
    <span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.lambdify([x],</span> <span style="color: #d0d0d0">f)</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">):</span>
        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">j</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">):</span>
            <span style="color: #d0d0d0">A[i,j]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">psi[j](points[i])</span>
        <span style="color: #d0d0d0">b[i,</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">f(points[i])</span>
    <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A.LUsolve(b)</span>
    <span style="color: #d0d0d0">u</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">0</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(psi)):</span>
        <span style="color: #d0d0d0">u</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">c[i,</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]*psi[i](x)</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">u</span>
</pre></div>
<p>

</section>


<section>

<h3>The collocation or interpolation method; approximating a parabola by linear functions  <a name="___sec40"></a></h3>

<p>

<ul>
 <p><li> Potential difficulty: how to choose \( \xno{i} \)?</li>
 <p><li> The results are sensitive to the points!</li>
</ul>
<p>

\( (4/3,5/3) \) vs \( (1,2) \):

<p>
<center><p><img src="fig-fem/parabola_inter.png" align="bottom" width=700,></p></center>

<p>

</section>


<section>

<h3>Lagrange polynomials; motivation and ideas <a name="fem:approx:global:Lagrange"></a></h3>

<p>
Motivation:

<p>

<ul>
 <p><li> The interpolation/collocation method avoids integration</li>
 <p><li> With a diagonal matrix \( A_{i,j} = \baspsi_j(\xno{i}) \) we
   can solve the linear system by hand</li>
</ul>
<p>

The <em>Lagrange interpolating polynomials</em> \( \baspsi_j \) have the property that

<p>
<p>&nbsp;<br>
$$ \baspsi_i(\xno{j}) =\delta_{ij},\quad \delta_{ij} =
\left\lbrace\begin{array}{ll}
1, & i=j\\ 
0, & i\neq j
\end{array}\right.
$$
<p>&nbsp;<br>


<p>
Hence, \( c_i = f(x_i) \) and

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \sum_{j\in\If} f(\xno{i})\baspsi_i(x)
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Lagrange polynomials and interpolation/collocation look convenient</li>
 <p><li> Lagrange polynomials are very much used in the finite element method</li>
</ul>
<p>


</section>


<section>

<h3>Lagrange polynomials; formula and code  <a name="___sec42"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\baspsi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N}
\tag{13}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">Lagrange_polynomial</span><span style="color: #d0d0d0">(x,</span> <span style="color: #d0d0d0">i,</span> <span style="color: #d0d0d0">points):</span>
    <span style="color: #d0d0d0">p</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">1</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">k</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(points)):</span>
        <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">k</span> <span style="color: #d0d0d0">!=</span> <span style="color: #d0d0d0">i:</span>
            <span style="color: #d0d0d0">p</span> <span style="color: #d0d0d0">*=</span> <span style="color: #d0d0d0">(x</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">points[k])/(points[i]</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">points[k])</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">p</span>
</pre></div>
<p>

</section>


<section>

<h3>Lagrange polynomials; successful example  <a name="___sec43"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_ls_interp_sin_4.png" align="bottom" width=800,></p></center>

<p>

</section>


<section>

<h3>Lagrange polynomials; a less successful example  <a name="___sec44"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_interp_abs_8_15.png" align="bottom" width=800,></p></center>

<p>

</section>


<section>

<h3>Lagrange polynomials; oscillatory behavior  <a name="___sec45"></a></h3>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-fem/Lagrange_basis_12.png" align="bottom" width=500></p></center>

<p>
Problem: strong oscillations near the boundaries for larger \( N \) values.

<p>

</section>


<section>

<h3>Lagrange polynomials; remedy for strong oscillations  <a name="___sec46"></a></h3>

<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N
\end{equation}
$$
<p>&nbsp;<br>

on an interval \( [a,b] \).

<p>

</section>


<section>

<h3>Lagrange polynomials; recalculation with Chebyshev nodes  <a name="___sec47"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800,></p></center>

<p>

</section>


<section>

<h3>Lagrange polynomials; less oscillations with Chebyshev nodes  <a name="___sec48"></a></h3>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-fem/Lagrange_basis_Cheb_12.png" align="bottom" width=500></p></center>

<p>

</section>


<section>

<h2>Finite element basis functions <a name="fem:approx:fe"></a></h2>

<p>

</section>


<section>

<h3>The basis functions have so far been global: \( \baspsi_i(x) \neq 0 \) almost everywhere  <a name="___sec50"></a></h3>

<p>
<center><p><img src="fig-fem/u_example_sin.png" align="bottom" width=500></p></center>

<p>

</section>


<section>

<h3>In the finite element method we use basis functions with local support  <a name="___sec51"></a></h3>

<p>

<ul>
 <p><li> <em>Local support</em>: \( \baspsi_i(x) \neq 0 \) for \( x \) in a
   small subdomain of \( \Omega \)</li>
 <p><li> Typically hat-shaped</li>
 <p><li> \( u(x) \) based on these \( \baspsi_i \) is a piecewise polynomial
   defined over many (small) subdomains</li>
 <p><li> We introduce \( \basphi_i \) as the name of these finite element hat
   functions (and for now choose \( \baspsi_i=\basphi_i \))</li>
</ul>
<p>

<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=350></p></center>

<p>

</section>


<section>

<h3>The linear combination of hat functions is a piecewise linear function  <a name="___sec52"></a></h3>

<p>
<center><p><img src="fig-fem/u_example_fe2.png" align="bottom" width=500></p></center>

<p>

</section>


<section>

<h3>Elements and nodes <a name="fem:approx:fe:def:elements:nodes"></a></h3>

<p>
Split \( \Omega \) into non-overlapping subdomains called <em>elements</em>:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(N_e)}
\end{equation}
$$
<p>&nbsp;<br>


<p>
On each element, introduce points called <em>nodes</em>: \( \xno{0},\ldots,\xno{N_n} \)

<p>

<ul>
 <p><li> The finite element basis functions are named \( \basphi_i(x) \)</li>
 <p><li> \( \basphi_i=1 \) at node \( i \) and 0 at all other nodes</li>
 <p><li> \( \basphi_i \) is a Lagrange polynomial on each element</li>
 <p><li> For nodes at the boundary between two elements, \( \basphi_i \) is made
   up of a Lagrange polynomial over each element</li>
</ul>
<p>


</section>


<section>

<h3>Example on elements with two nodes (P1 elements)  <a name="___sec54"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D.png" align="bottom" width=500></p></center>

<p>
Data structure: <code>nodes</code> holds coordinates or nodes, <code>elements</code> holds the
node numbers in each element

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1.2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2.4</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">3.6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">4.8</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">5</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">elements</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">3</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">4</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">4</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">5</span><span style="color: #d0d0d0">]]</span>
</pre></div>
<p>

</section>


<section>

<h3>Illustration of two basis functions on the mesh  <a name="___sec55"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>

</section>


<section>

<h3>Example on elements with three nodes (P2 elements)  <a name="___sec56"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_P2.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.125</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.25</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.375</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.5</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.625</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.75</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.875</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1.0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">elements</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">4</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">4</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">5</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">6</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">7</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">8</span><span style="color: #d0d0d0">]]</span>
</pre></div>
<p>

</section>


<section>

<h3>Some corresponding basis functions (P2 elements)  <a name="___sec57"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p></center>

<p>

</section>


<section>

<h3>Examples on elements with four nodes per element (P3 elements)  <a name="___sec58"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_d4_stretched.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">d</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">3</span>  <span style="color: #999999; font-style: italic"># d+1 nodes per element</span>
<span style="color: #d0d0d0">num_elements</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">4</span>
<span style="color: #d0d0d0">num_nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">num_elements*d</span> <span style="color: #d0d0d0">+</span> <span style="color: #3677a9">1</span>
<span style="color: #d0d0d0">nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[i*</span><span style="color: #3677a9">0.5</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(num_nodes)]</span>
<span style="color: #d0d0d0">elements</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[i*d+j</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">j</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(d+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)]</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(num_elements)]</span>
</pre></div>
<p>

</section>


<section>

<h3>Some corresponding basis functions (P3 elements)  <a name="___sec59"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600></p></center>

<p>

</section>


<section>

<h3>The numbering does not need to be regular from left to right  <a name="___sec60"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_random_numbering.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">1.5</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">5.5</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">4.2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.3</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2.2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">3.1</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">elements</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">4</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">5</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">4</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">5</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">]]</span>
</pre></div>
<p>

</section>


<section>

<h3>Interpretation of the coefficients \( c_i \)  <a name="___sec61"></a></h3>

<p>
Important property: \( c_i \)
is the value of \( u \) at node \( i \), \( \xno{i} \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) =
c_i\basphi_i(\xno{i}) = c_i
\tag{14}
\end{equation}
$$
<p>&nbsp;<br>


<p>
because \( \basphi_j(\xno{i}) =0 \) if \( i\neq j \)

<p>

</section>


<section>

<h3>Properties of the basis functions  <a name="___sec62"></a></h3>

<p>

<ul>
 <p><li> \( \basphi_i(x) \neq 0 \) only on those elements that contain global node \( i \)</li>
 <p><li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) if and only if \( i \) and \( j \) are global node
   numbers in the same element</li>
</ul>
<p>

Since \( A_{i,j}=\int\basphi_i\basphi_j\dx \),
<em>most of the elements in the coefficient matrix will be zero</em>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_im1.png" align="bottom" width=350></p></center>

<p>

</section>


<section>

<h3>How to construct quadratic \( \basphi_i \) (P2 elements)  <a name="___sec63"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=350></p></center>

<p>

<ol>
<p><li> Associate Lagrange polynomials with the nodes in an element</li>
<p><li> When the polynomial is 1 on the element boundary, combine it
   with the polynomial in the neighboring element</li>
</ol>
<p>


</section>


<section>

<h3>Example on linear \( \basphi_i \) (P1 elements)  <a name="___sec64"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=350></p></center>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1}\\ 
(x - \xno{i-1})/h
& \xno{i-1} \leq x < \xno{i}\\ 
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1}\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{15}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example on cubic \( \basphi_i \) (P3 elements)  <a name="___sec65"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=350,></p></center>

<p>

</section>


<section>

<h2>Calculating the linear system for \( c_i \) <a name="fem:approx:global:linearsystem"></a></h2>

<p>

</section>


<section>

<h3>Computing a specific matrix entry (1)  <a name="___sec67"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=300></p></center>

<p>
\( A_{2,3}=\int_\Omega\basphi_2\basphi_3 dx \): \( \basphi_2\basphi_3\neq 0 \)
only over element 2. There,

<p>
<p>&nbsp;<br>
$$ \basphi_3(x) = (x-x_2)/h,\quad \basphi_2(x) = 1- (x-x_2)/h$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
A_{2,3} = \int_\Omega \basphi_2\basphi_{3}\dx =
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right) \frac{x - x_{2}}{h}
 \dx = \frac{h}{6}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Computing a specific matrix entry (2)  <a name="___sec68"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$ A_{2,2} =
\int_{\xno{1}}^{\xno{2}}
\left(\frac{x - \xno{1}}{h}\right)^2\dx +
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right)^2\dx
= \frac{h}{3}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Calculating a general row in the matrix; figure  <a name="___sec69"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_im1.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$ A_{i,i-1} = \int_\Omega \basphi_i\basphi_{i-1}\dx = \hbox{?}$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Calculating a general row in the matrix; details  <a name="___sec70"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,i-1} &= \int_\Omega \basphi_i\basphi_{i-1}\dx\\ 
&=
\underbrace{\int_{\xno{i-2}}^{\xno{i-1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_i=0} +
\int_{\xno{i-1}}^{\xno{i}} \basphi_i\basphi_{i-1}\dx +
\underbrace{\int_{\xno{i}}^{\xno{i+1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_{i-1}=0}\\ 
&= \int_{\xno{i-1}}^{\xno{i}}
\underbrace{\left(\frac{x - x_{i}}{h}\right)}_{\basphi_i(x)}
\underbrace{\left(1 - \frac{x - \xno{i-1}}{h}\right)}_{\basphi_{i-1}(x)} \dx =
\frac{h}{6}
\end{align*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( A_{i,i+1}=A_{i,i-1} \) due to symmetry</li>
 <p><li> \( A_{i,i}=h/3 \) (same calculation as for \( A_{2,2} \))</li>
 <p><li> \( A_{0,0}=A_{N,N}=h/3 \) (only one element)</li>
</ul>
<p>


</section>


<section>

<h3>Calculation of the right-hand side  <a name="___sec71"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_f.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i(x)f(x)\dx
= \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)\dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)
\dx
\tag{16}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Need a specific \( f(x) \) to do more...

<p>

</section>


<section>

<h3>Specific example with two elements; linear system and solution  <a name="___sec72"></a></h3>

<p>

<ul>
 <p><li> \( f(x)=x(1-x) \) on \( \Omega=[0,1] \)</li>
 <p><li> Two equal-sized elements \( [0,0.5] \) and \( [0.5,1] \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\ 
1 & 4 & 1\\ 
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\ 
12 - 14h\\ 
10 -17h
\end{array}\right)
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*} c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2
\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Specific example with two elements; plot  <a name="___sec73"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)\end{equation*}
$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-fem/fe_p1_x2_2e.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Specific example: what about four elements?  <a name="___sec74"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p1_x2_2e_4e.png" align="bottom" width=800,></p></center>

<p>

</section>


<section>

<h2>Assembly of elementwise computations <a name="fem:approx:fe:elementwise"></a></h2>

<p>

</section>


<section>

<h3>Split the integrals into elementwise integrals  <a name="___sec76"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A_{i,j} = \int_\Omega\basphi_i\basphi_jdx =
\sum_{e} \int_{\Omega^{(e)}} \basphi_i\basphi_jdx,\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_jdx
\tag{17}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
 <p><li> \( A^{(e)}_{i,j}\neq 0 \) if and only if \( i \) and \( j \) are nodes in element
   \( e \) (otherwise no overlap between the basis functions)</li>
 <p><li> all the nonzero elements in \( A^{(e)}_{i,j} \) are collected in an
   <em>element matrix</em></li>
</ul>
<p>


</section>


<section>

<h3>The element matrix  <a name="___sec77"></a></h3>

<p>
<p>&nbsp;<br>
$$
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)}dx,
\quad r,s\in\Ifd=\{0,\ldots,d\}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( r,s \) run over <em>local node numbers</em> in an element; \( i,j \) run
   over <em>global node numbers</em></li>
 <p><li> \( i=q(e,r) \): mapping of local node number \( r \) in element
   \( e \) to the global node number \( i \) (math equivalent to <code>i=elements[e][r]</code>)</li>
 <p><li> Add \( \tilde A^{(e)}_{r,s} \) into the global \( A_{i,j} \)
   (<em>assembly</em>)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s\in\Ifd
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Illustration of the matrix assembly: regularly numbered P1 elements  <a name="___sec78"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_regular_2x2/fe_assembly_regular_2x2.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html" target="_self">Animation</a>

<p>

</section>


<section>

<h3>Illustration of the matrix assembly: regularly numbered P3 elements  <a name="___sec79"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_regular_4x4/fe_assembly_regular_4x4.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html" target="_self">Animation</a>

<p>

</section>


<section>

<h3>Illustration of the matrix assembly: irregularly numbered P1 elements  <a name="___sec80"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_irregular/fe_assembly_irregular.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html" target="_self">Animation</a>

<p>

</section>


<section>

<h3>Assembly of the right-hand side  <a name="___sec81"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_i = \int_\Omega f(x)\basphi_i(x)dx =
\sum_{e} \int_{\Omega^{(e)}} f(x)\basphi_i(x)dx,\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)dx
\end{equation}
$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
  <p><li> \( b_i^{(e)}\neq 0 \) if and only if global node \( i \) is a node in element \( e \)
    (otherwise \( \basphi_i=0 \))</li>
  <p><li> The \( d+1 \) nonzero \( b_i^{(e)} \) can be collected in an <em>element vector</em>
    \( \tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\} \), \( r\in\Ifd \)</li>
</ul>
<p>

Assembly:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r,s\in\Ifd
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h2>Mapping to a reference element <a name="fem:approx:fe:mapping"></a></h2>

<p>
Instead of computing

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int_{x_L}^{x_R}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
\end{equation*}
$$
<p>&nbsp;<br>

we now map \( [x_L, x_R] \) to
a standardized reference element domain \( [-1,1] \) with local coordinate \( X \)

<p>

</section>


<section>

<h3>Affine mapping  <a name="___sec83"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
x = \half (x_L + x_R) + \half (x_R - x_L)X
\tag{18}
\end{equation}
$$
<p>&nbsp;<br>

or rewritten as
<p>&nbsp;<br>
$$
\begin{equation}
x = x_m + {\half}hX, \qquad x_m=(x_L+x_R)/2
\tag{19}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Integral transformation  <a name="___sec84"></a></h3>

<p>
Reference element integration: just change integration variable
from \( x \) to \( X \). Introduce local basis function

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int\limits_{-1}^1 \refphi_r(X)\refphi_s(X)\underbrace{\frac{dx}{dX}}_{\det J = h/2}dX
= \int\limits_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int\limits_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
\tag{20}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Advantages of the reference element  <a name="___sec85"></a></h3>

<p>

<ul>
  <p><li> Always the same domain for integration: \( [-1,1] \)</li>
  <p><li> We only need formulas for \( \refphi_r(X) \) over one element
    (no piecewise polynomial definition)</li>
  <p><li> \( \refphi_r(X) \) is the same for all elements: no dependence on
    element length and location, which is "factored out"
    in the mapping and \( \det J \)</li>
</ul>
<p>


</section>


<section>

<h3>Standardized basis functions for P1 elements  <a name="___sec86"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\tag{21}\\ 
\refphi_1(X) &= \half (1 + X)
\tag{22}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Standardized basis functions for P2 elements  <a name="___sec87"></a></h3>

<p>
P2 elements:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (X-1)X\\ 
\refphi_1(X) &= 1 - X^2\\ 
\refphi_2(X) &= \half (X+1)X
\end{align}
$$
<p>&nbsp;<br>


<p>
Easy to generalize to arbitrary order!

<p>

</section>


<section>

<h3>Integration over a reference element; element matrix <a name="fem:approx:fe:intg:ref"></a></h3>

<p>
P1 elements and \( f(x)=x(1-x) \).

<p>
<p>&nbsp;<br>
$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1-X)\half(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3}
\tag{23}\\ 
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1+X)\half(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6}\\ 
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0}
\tag{24}\\ 
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1+X)\half(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\tag{25}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Integration over a reference element; element vector  <a name="___sec89"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\half(1-X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \half h x_{m}^{2} + \half h x_{m}
\tag{26}\\ 
\tilde b^{(e)}_{1}
&= \int_{-1}^1 f(x(X))\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\half(1+X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\half h x_{m}^{2} + \half h x_{m}
\end{align}
$$
<p>&nbsp;<br>


<p>
\( x_m \): element midpoint.

<p>

</section>


<section>

<h3>Tedious calculations! Let's use symbolic software  <a name="___sec90"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #447fcf; text-decoration: underline">sympy</span> <span style="color: #6ab825; font-weight: bold">as</span> <span style="color: #447fcf; text-decoration: underline">sp</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">x,</span> <span style="color: #d0d0d0">x_m,</span> <span style="color: #d0d0d0">h,</span> <span style="color: #d0d0d0">X</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.symbols(</span><span style="color: #ed9d13">&#39;x x_m h X&#39;</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">sp.integrate(h/</span><span style="color: #3677a9">8</span><span style="color: #d0d0d0">*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-X)**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">(X,</span> <span style="color: #d0d0d0">-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
<span style="color: #d0d0d0">h/</span><span style="color: #3677a9">3</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">sp.integrate(h/</span><span style="color: #3677a9">8</span><span style="color: #d0d0d0">*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">+X)*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-X),</span> <span style="color: #d0d0d0">(X,</span> <span style="color: #d0d0d0">-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
<span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">x_m</span> <span style="color: #d0d0d0">+</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">*X</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">b_0</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.integrate(h/</span><span style="color: #3677a9">4</span><span style="color: #d0d0d0">*x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x)*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-X),</span> <span style="color: #d0d0d0">(X,</span> <span style="color: #d0d0d0">-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #6ab825; font-weight: bold">print</span> <span style="color: #d0d0d0">b_0</span>
<span style="color: #d0d0d0">-h**</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">24</span> <span style="color: #d0d0d0">+</span> <span style="color: #d0d0d0">h**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">*x_m/</span><span style="color: #3677a9">6</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">h**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">12</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">h*x_m**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">2</span> <span style="color: #d0d0d0">+</span> <span style="color: #d0d0d0">h*x_m/</span><span style="color: #3677a9">2</span>
</pre></div>
<p>
Can printe out in LaTeX too (convenient for copying into reports):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #6ab825; font-weight: bold">print</span> <span style="color: #d0d0d0">sp.latex(b_0,</span> <span style="color: #d0d0d0">mode=</span><span style="color: #ed9d13">&#39;plain&#39;</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">-</span> \<span style="color: #d0d0d0">frac{</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">}{</span><span style="color: #3677a9">24</span><span style="color: #d0d0d0">}</span> <span style="color: #d0d0d0">h^{</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">}</span> <span style="color: #d0d0d0">+</span> \<span style="color: #d0d0d0">frac{</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">}{</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">}</span> <span style="color: #d0d0d0">h^{</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">}</span> <span style="color: #d0d0d0">x_{m}</span>
<span style="color: #d0d0d0">-</span> \<span style="color: #d0d0d0">frac{</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">}{</span><span style="color: #3677a9">12</span><span style="color: #d0d0d0">}</span> <span style="color: #d0d0d0">h^{</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">}</span> <span style="color: #d0d0d0">-</span> \<span style="color: #d0d0d0">half</span> <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">x_{m}^{</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">}</span>
<span style="color: #d0d0d0">+</span> \<span style="color: #d0d0d0">half</span> <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">x_{m}</span>
</pre></div>
<p>

</section>


<section>

<h2>Implementation  <a name="___sec91"></a></h2>

<p>

<ul>
 <p><li> Coming functions appear in <a href="http://tinyurl.com/jvzzcfn/fem/fe_approx1D.py" target="_self"><tt>fe_approx1D.py</tt></a></li>
 <p><li> Functions can operate in symbolic or numeric mode</li>
 <p><li> The code documents all steps in finite element calculations!</li>
</ul>
<p>


</section>


<section>

<h3>Compute finite element basis functions in the reference element  <a name="___sec92"></a></h3>

<p>
Let \( \refphi_r(X) \) be a Lagrange polynomial of degree <code>d</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #447fcf; text-decoration: underline">sympy</span> <span style="color: #6ab825; font-weight: bold">as</span> <span style="color: #447fcf; text-decoration: underline">sp</span>
<span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #447fcf; text-decoration: underline">numpy</span> <span style="color: #6ab825; font-weight: bold">as</span> <span style="color: #447fcf; text-decoration: underline">np</span>

<span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">phi_r</span><span style="color: #d0d0d0">(r,</span> <span style="color: #d0d0d0">X,</span> <span style="color: #d0d0d0">d):</span>
    <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #24909d">isinstance</span><span style="color: #d0d0d0">(X,</span> <span style="color: #d0d0d0">sp.Symbol):</span>
        <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Rational(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">d)</span>  <span style="color: #999999; font-style: italic"># node spacing</span>
        <span style="color: #d0d0d0">nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">*i*h</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">1</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(d+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)]</span>
    <span style="color: #6ab825; font-weight: bold">else</span><span style="color: #d0d0d0">:</span>
        <span style="color: #999999; font-style: italic"># assume X is numeric: use floats for nodes</span>
        <span style="color: #d0d0d0">nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">np.linspace(-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">d+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">Lagrange_polynomial(X,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">nodes)</span>

<span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">Lagrange_polynomial</span><span style="color: #d0d0d0">(x,</span> <span style="color: #d0d0d0">i,</span> <span style="color: #d0d0d0">points):</span>
    <span style="color: #d0d0d0">p</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">1</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">k</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(points)):</span>
        <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">k</span> <span style="color: #d0d0d0">!=</span> <span style="color: #d0d0d0">i:</span>
            <span style="color: #d0d0d0">p</span> <span style="color: #d0d0d0">*=</span> <span style="color: #d0d0d0">(x</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">points[k])/(points[i]</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">points[k])</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">p</span>

<span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">basis</span><span style="color: #d0d0d0">(d=</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">):</span>
    <span style="color: #ed9d13">&quot;&quot;&quot;Return the complete basis.&quot;&quot;&quot;</span>
    <span style="color: #d0d0d0">X</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;X&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #d0d0d0">phi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[phi_r(r,</span> <span style="color: #d0d0d0">X,</span> <span style="color: #d0d0d0">d)</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(d+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)]</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">phi</span>
</pre></div>
<p>

</section>


<section>

<h3>Compute the element matrix  <a name="___sec93"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">element_matrix</span><span style="color: #d0d0d0">(phi,</span> <span style="color: #d0d0d0">Omega_e,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">True</span><span style="color: #d0d0d0">):</span>
    <span style="color: #d0d0d0">n</span> <span style="color: #d0d0d0">=</span> <span style="color: #24909d">len</span><span style="color: #d0d0d0">(phi)</span>
    <span style="color: #d0d0d0">A_e</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.zeros((n,</span> <span style="color: #d0d0d0">n))</span>
    <span style="color: #d0d0d0">X</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;X&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">symbolic:</span>
        <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;h&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #6ab825; font-weight: bold">else</span><span style="color: #d0d0d0">:</span>
        <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">Omega_e[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">Omega_e[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
    <span style="color: #d0d0d0">detJ</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">2</span>  <span style="color: #999999; font-style: italic"># dx/dX</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">s</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(r,</span> <span style="color: #d0d0d0">n):</span>
            <span style="color: #d0d0d0">A_e[r,s]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.integrate(phi[r]*phi[s]*detJ,</span> <span style="color: #d0d0d0">(X,</span> <span style="color: #d0d0d0">-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
            <span style="color: #d0d0d0">A_e[s,r]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A_e[r,s]</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">A_e</span>
</pre></div>
<p>

</section>


<section>

<h3>Example on symbolic vs numeric element matrix  <a name="___sec94"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">fe_approx1D</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #d0d0d0">*</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">phi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">basis(d=</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">phi</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">2</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">X/</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">2</span> <span style="color: #d0d0d0">+</span> <span style="color: #d0d0d0">X/</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">element_matrix(phi,</span> <span style="color: #d0d0d0">Omega_e=[</span><span style="color: #3677a9">0.1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.2</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">True</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">[h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">element_matrix(phi,</span> <span style="color: #d0d0d0">Omega_e=[</span><span style="color: #3677a9">0.1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.2</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">False</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">0.0333333333333333</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.0166666666666667</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">0.0166666666666667</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.0333333333333333</span><span style="color: #d0d0d0">]</span>
</pre></div>
<p>

</section>


<section>

<h3>Compute the element vector  <a name="___sec95"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">element_vector</span><span style="color: #d0d0d0">(f,</span> <span style="color: #d0d0d0">phi,</span> <span style="color: #d0d0d0">Omega_e,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">True</span><span style="color: #d0d0d0">):</span>
    <span style="color: #d0d0d0">n</span> <span style="color: #d0d0d0">=</span> <span style="color: #24909d">len</span><span style="color: #d0d0d0">(phi)</span>
    <span style="color: #d0d0d0">b_e</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.zeros((n,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #999999; font-style: italic"># Make f a function of X</span>
    <span style="color: #d0d0d0">X</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;X&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">symbolic:</span>
        <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;h&#39;</span><span style="color: #d0d0d0">)</span>
    <span style="color: #6ab825; font-weight: bold">else</span><span style="color: #d0d0d0">:</span>
        <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">Omega_e[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">Omega_e[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
    <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">(Omega_e[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span> <span style="color: #d0d0d0">+</span> <span style="color: #d0d0d0">Omega_e[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">])/</span><span style="color: #3677a9">2</span> <span style="color: #d0d0d0">+</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">*X</span>  <span style="color: #999999; font-style: italic"># mapping</span>
    <span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">f.subs(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">x)</span>  <span style="color: #999999; font-style: italic"># substitute mapping formula for x</span>
    <span style="color: #d0d0d0">detJ</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">2</span>  <span style="color: #999999; font-style: italic"># dx/dX</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
        <span style="color: #d0d0d0">b_e[r]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.integrate(f*phi[r]*detJ,</span> <span style="color: #d0d0d0">(X,</span> <span style="color: #d0d0d0">-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">b_e</span>
</pre></div>
<p>
Note <code>f.subs('x', x)</code>: replace <code>x</code> by \( x(X) \) such that <code>f</code> contains <code>X</code>

<p>

</section>


<section>

<h3>Fallback on numerical integration if symbolic integration fails  <a name="___sec96"></a></h3>

<p>

<ul>
  <p><li> Element matrix: only polynomials and <code>sympy</code> always succeeds</li>
  <p><li> Element vector: \( \int f\refphi \dx \) can fail
    (<code>sympy</code> then returns an <code>Integral</code> object instead of a number)</li>
</ul>
<p>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">element_vector</span><span style="color: #d0d0d0">(f,</span> <span style="color: #d0d0d0">phi,</span> <span style="color: #d0d0d0">Omega_e,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">True</span><span style="color: #d0d0d0">):</span>
        <span style="color: #d0d0d0">...</span>
        <span style="color: #d0d0d0">I</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.integrate(f*phi[r]*detJ,</span> <span style="color: #d0d0d0">(X,</span> <span style="color: #d0d0d0">-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>  <span style="color: #999999; font-style: italic"># try...</span>
        <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #24909d">isinstance</span><span style="color: #d0d0d0">(I,</span> <span style="color: #d0d0d0">sp.Integral):</span>
            <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">Omega_e[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">Omega_e[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>  <span style="color: #999999; font-style: italic"># Ensure h is numerical</span>
            <span style="color: #d0d0d0">detJ</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">2</span>
            <span style="color: #d0d0d0">integrand</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.lambdify([X],</span> <span style="color: #d0d0d0">f*phi[r]*detJ)</span>
            <span style="color: #d0d0d0">I</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.mpmath.quad(integrand,</span> <span style="color: #d0d0d0">[-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">])</span>
        <span style="color: #d0d0d0">b_e[r]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">I</span>
        <span style="color: #d0d0d0">...</span>
</pre></div>
<p>

</section>


<section>

<h3>Linear system assembly and solution  <a name="___sec97"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">assemble</span><span style="color: #d0d0d0">(nodes,</span> <span style="color: #d0d0d0">elements,</span> <span style="color: #d0d0d0">phi,</span> <span style="color: #d0d0d0">f,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">True</span><span style="color: #d0d0d0">):</span>
    <span style="color: #d0d0d0">N_n,</span> <span style="color: #d0d0d0">N_e</span> <span style="color: #d0d0d0">=</span> <span style="color: #24909d">len</span><span style="color: #d0d0d0">(nodes),</span> <span style="color: #24909d">len</span><span style="color: #d0d0d0">(elements)</span>
    <span style="color: #d0d0d0">zeros</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.zeros</span> <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">symbolic</span> <span style="color: #6ab825; font-weight: bold">else</span> <span style="color: #d0d0d0">np.zeros</span>
    <span style="color: #d0d0d0">A</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">zeros((N_n,</span> <span style="color: #d0d0d0">N_n))</span>
    <span style="color: #d0d0d0">b</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">zeros((N_n,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">))</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">e</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N_e):</span>
        <span style="color: #d0d0d0">Omega_e</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[nodes[elements[e][</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]],</span> <span style="color: #d0d0d0">nodes[elements[e][-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]]]</span>

        <span style="color: #d0d0d0">A_e</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">element_matrix(phi,</span> <span style="color: #d0d0d0">Omega_e,</span> <span style="color: #d0d0d0">symbolic)</span>
        <span style="color: #d0d0d0">b_e</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">element_vector(f,</span> <span style="color: #d0d0d0">phi,</span> <span style="color: #d0d0d0">Omega_e,</span> <span style="color: #d0d0d0">symbolic)</span>

        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(elements[e])):</span>
            <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">s</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(elements[e])):</span>
                <span style="color: #d0d0d0">A[elements[e][r],elements[e][s]]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">A_e[r,s]</span>
            <span style="color: #d0d0d0">b[elements[e][r]]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">b_e[r]</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">A,</span> <span style="color: #d0d0d0">b</span>
</pre></div>
<p>

</section>


<section>

<h3>Linear system solution  <a name="___sec98"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">symbolic:</span>
    <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A.LUsolve(b)</span>           <span style="color: #999999; font-style: italic"># sympy arrays, symbolic Gaussian elim.</span>
<span style="color: #6ab825; font-weight: bold">else</span><span style="color: #d0d0d0">:</span>
    <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">np.linalg.solve(A,</span> <span style="color: #d0d0d0">b)</span>  <span style="color: #999999; font-style: italic"># numpy arrays, numerical solve</span>
</pre></div>
<p>
Note: the symbolic computation of <code>A</code> and <code>b</code> and the symbolic
solution can be very tedious.

<p>

</section>


<section>

<h3>Example on computing symbolic approximations  <a name="___sec99"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">h,</span> <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.symbols(</span><span style="color: #ed9d13">&#39;h x&#39;</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">h,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">elements</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">]]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">phi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">basis(d=</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">A,</span> <span style="color: #d0d0d0">b</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">assemble(nodes,</span> <span style="color: #d0d0d0">elements,</span> <span style="color: #d0d0d0">phi,</span> <span style="color: #d0d0d0">f,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">True</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">A</span>
<span style="color: #d0d0d0">[h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span>   <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">b</span>
<span style="color: #d0d0d0">[</span>     <span style="color: #d0d0d0">h**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">6</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">h**</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">12</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>      <span style="color: #d0d0d0">h**</span><span style="color: #3677a9">2</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">7</span><span style="color: #d0d0d0">*h**</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">5</span><span style="color: #d0d0d0">*h**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">6</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">17</span><span style="color: #d0d0d0">*h**</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">12</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A.LUsolve(b)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">c</span>
<span style="color: #d0d0d0">[</span>                           <span style="color: #d0d0d0">h**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">12</span><span style="color: #d0d0d0">*(</span><span style="color: #3677a9">7</span><span style="color: #d0d0d0">*h**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">12</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">35</span><span style="color: #d0d0d0">*h**</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">72</span><span style="color: #d0d0d0">)/(</span><span style="color: #3677a9">7</span><span style="color: #d0d0d0">*h)]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">7</span><span style="color: #d0d0d0">*(</span><span style="color: #3677a9">4</span><span style="color: #d0d0d0">*h**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">7</span> <span style="color: #d0d0d0">-</span> <span style="color: #3677a9">23</span><span style="color: #d0d0d0">*h**</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">/</span><span style="color: #3677a9">21</span><span style="color: #d0d0d0">)/(</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h)]</span>
</pre></div>
<p>

</section>


<section>

<h3>Example on computing numerical approximations  <a name="___sec100"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">nodes</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.5</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">elements</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">]]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">phi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">basis(d=</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">A,</span> <span style="color: #d0d0d0">b</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">assemble(nodes,</span> <span style="color: #d0d0d0">elements,</span> <span style="color: #d0d0d0">phi,</span> <span style="color: #d0d0d0">f,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">False</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">A</span>
<span style="color: #d0d0d0">[</span> <span style="color: #3677a9">0.166666666666667</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.0833333333333333</span><span style="color: #d0d0d0">,</span>                  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">0.0833333333333333</span><span style="color: #d0d0d0">,</span>  <span style="color: #3677a9">0.333333333333333</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.0833333333333333</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>                 <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.0833333333333333</span><span style="color: #d0d0d0">,</span>  <span style="color: #3677a9">0.166666666666667</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">b</span>
<span style="color: #d0d0d0">[</span>          <span style="color: #3677a9">0.03125</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">0.104166666666667</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>          <span style="color: #3677a9">0.03125</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">A.LUsolve(b)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">c</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">0.0416666666666666</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span> <span style="color: #3677a9">0.291666666666667</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span><span style="color: #3677a9">0.0416666666666666</span><span style="color: #d0d0d0">]</span>
</pre></div>
<p>

</section>


<section>

<h3>The structure of the coefficient matrix <a name="fem:approx:fe:A:structure"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">d=</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">;</span> <span style="color: #d0d0d0">N_e=</span><span style="color: #3677a9">8</span><span style="color: #d0d0d0">;</span> <span style="color: #d0d0d0">Omega=[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span>  <span style="color: #999999; font-style: italic"># 8 linear elements on [0,1]</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">phi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">basis(d)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">nodes,</span> <span style="color: #d0d0d0">elements</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">mesh_symbolic(N_e,</span> <span style="color: #d0d0d0">d,</span> <span style="color: #d0d0d0">Omega)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">A,</span> <span style="color: #d0d0d0">b</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">assemble(nodes,</span> <span style="color: #d0d0d0">elements,</span> <span style="color: #d0d0d0">phi,</span> <span style="color: #d0d0d0">f,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">True</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">&gt;&gt;&gt;</span> <span style="color: #d0d0d0">A</span>
<span style="color: #d0d0d0">[h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span>   <span style="color: #3677a9">0</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">[</span>  <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>     <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span>   <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">6</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">]</span>
</pre></div>
<p>
Note: do this by hand to understand what is going on!

<p>

</section>


<section>

<h3>General result: the coefficient matrix is sparse  <a name="___sec102"></a></h3>

<p>

<ul>
 <p><li> Sparse = most of the entries are zeros</li>
 <p><li> Below: P1 elements</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Exemplifying the sparsity for P2 elements  <a name="___sec103"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 & 0\\ 
  0 & 0 & 2 & 16 & 2 & 0 & 0 & 0 & 0\\ 
  0 & 0 & - 1 & 2 & 8 & 2 & - 1 & 0 & 0\\ 
  0 & 0 & 0 & 0 & 2 & 16 & 2 & 0 & 0\\ 
  0 & 0 & 0 & 0 & - 1 & 2 & 8 & 2 & - 1
  \\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Matrix sparsity pattern for regular/random numbering of P1 elements  <a name="___sec104"></a></h3>

<p>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>
<p>

<center><p><img src="fig-fem/sparsity_pattern_1D_30.png" align="bottom" width=800></p></center>

<p>

</section>


<section>

<h3>Matrix sparsity pattern for regular/random numbering of P3 elements  <a name="___sec105"></a></h3>

<p>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>
<p>

<center><p><img src="fig-fem/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p></center>

<p>

</section>


<section>

<h3>Sparse matrix storage and solution <a name="fem:approx:fe:impl:sparse"></a></h3>

<p>
The minimum storage requirements for the coefficient matrix \( A_{i,j} \):

<p>

<ul>
 <p><li> P1 elements: only 3 nonzero entires per row</li>
 <p><li> P2 elements: only 5 nonzero entires per row</li>
 <p><li> P3 elements: only 7 nonzero entires per row</li>
 <p><li> It is important to utilize sparse storage and sparse solvers</li>
 <p><li> In Python: <code>scipy.sparse</code> package</li>
</ul>
<p>


</section>


<section>

<h3>Approximate \( f\sim x^9 \) by various elements; code  <a name="___sec107"></a></h3>

<p>
Compute a mesh with \( N_e \) elements, basis functions of
degree \( d \), and approximate a given symbolic expression
\( f(x) \) by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #447fcf; text-decoration: underline">sympy</span> <span style="color: #6ab825; font-weight: bold">as</span> <span style="color: #447fcf; text-decoration: underline">sp</span>
<span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">fe_approx1D</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #d0d0d0">approximate</span>
<span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">)</span>

<span style="color: #d0d0d0">approximate(f=x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x)**</span><span style="color: #3677a9">8</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">False</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">d=</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">N_e=</span><span style="color: #3677a9">4</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">approximate(f=x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x)**</span><span style="color: #3677a9">8</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">False</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">d=</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">N_e=</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">approximate(f=x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x)**</span><span style="color: #3677a9">8</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">False</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">d=</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">N_e=</span><span style="color: #3677a9">8</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">approximate(f=x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x)**</span><span style="color: #3677a9">8</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">symbolic=</span><span style="color: #24909d">False</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">d=</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">N_e=</span><span style="color: #3677a9">4</span><span style="color: #d0d0d0">)</span>
</pre></div>
<p>

</section>


<section>

<h3>Approximate \( f\sim x^9 \) by various elements; plot  <a name="___sec108"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p1_p2_x9_248e.png" align="bottom" width=800,></p></center>

<p>

</section>


<section>

<h2>Comparison of finite element and finite difference approximation <a name="fem:approx:fe:fd"></a></h2>

<p>

<ul>
 <p><li> Finite difference approximation of a function \( f(x) \): simply
   choose \( u_i = f(x_i) \) (interpolation)</li>
 <p><li> Galerkin/projection and least squares method:
   must derive and solve a linear system</li>
 <p><li> What is <em>really</em> the difference in \( u \)?</li>
</ul>
<p>


</section>


<section>

<h3>Interpolation/collocation with finite elements  <a name="___sec110"></a></h3>

<p>
Let \( \{\xno{i}\}_{i\in\If} \) be the nodes in the mesh.
Collocation means

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i})=f(\xno{i}),\quad i\in\If,
\end{equation}
$$
<p>&nbsp;<br>

which translates to

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} c_j \basphi_j(\xno{i}) = f(\xno{i}),$$
<p>&nbsp;<br>

but \( \basphi_j(\xno{i})=0 \) if \( i\neq j \) so the sum collapses to one
term \( c_i\basphi_i(\xno{i}) = c_i \), and we have the result

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_i = f(\xno{i})
\end{equation}
$$
<p>&nbsp;<br>


<p>
Same result as the standard finite difference approach, but finite elements
define \( u \) also <em>between</em> the \( \xno{i} \) points

<p>

</section>


<section>

<h3>Galerkin/project and least squares vs collocation/interpolation or finite differences  <a name="___sec111"></a></h3>

<p>

<ul>
 <p><li> Scope: work with P1 elements</li>
 <p><li> Use projection/Galerkin or least squares (equivalent)</li>
 <p><li> Interpret the resulting linear system as finite difference equations</li>
</ul>
<p>

The P1 finite element machinery results in a linear system where
equation no \( i \) is

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{h}{6}(u_{i-1} + 4u_i + u_{i+1}) = (f,\basphi_i)
\tag{27}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Note:

<p>

<ul>
  <p><li> We have used \( u_i \) for \( c_i \) to make notation similar to
    finite differences</li>
  <p><li> The finite difference counterpart is just \( u_i=f_i \)</li>
</ul>
<p>


</section>


<section>

<h3>Expressing the left-hand side in finite difference operator notation  <a name="___sec112"></a></h3>

<p>
Rewrite the left-hand side of finite element equation no \( i \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
h(u_i + \frac{1}{6}(u_{i-1} - 2u_i + u_{i+1})) = [h(u + \frac{h^2}{6}D_x D_x u)]_i
\end{equation}
$$
<p>&nbsp;<br>

This is the standard finite difference approximation of

<p>
<p>&nbsp;<br>
$$ h(u + \frac{h^2}{6}u'')$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Treating the right-hand side; Trapezoidal rule  <a name="___sec113"></a></h3>

<p>
<p>&nbsp;<br>
$$ (f,\basphi_i) = \int_{\xno{i-1}}^{\xno{i}} f(x)\frac{1}{h} (x - \xno{i-1}) dx
+ \int_{\xno{i}}^{\xno{i+1}} f(x)\frac{1}{h}(1 - (x - x_{i})) dx
$$
<p>&nbsp;<br>

Cannot do much unless we specialize \( f \) or use <em>numerical integration</em>.

<p>
Trapezoidal rule using the nodes:

<p>
<p>&nbsp;<br>
$$ (f,\basphi_i) = \int_\Omega f\basphi_i dx\approx h\half(
f(\xno{0})\basphi_i(\xno{0}) + f(\xno{N})\basphi_i(\xno{N}))
+ h\sum_{j=1}^{N-1} f(\xno{j})\basphi_i(\xno{j})
$$
<p>&nbsp;<br>

\( \basphi_i(\xno{j})=\delta_{ij} \), so this formula collapses to one term:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,\basphi_i) \approx hf(\xno{i}),\quad i=1,\ldots,N-1\thinspace.
\end{equation}
$$
<p>&nbsp;<br>


<p>
Same result as in collocation (interpolation)
and the finite difference method!

<p>

</section>


<section>

<h3>Treating the right-hand side; Simpson's rule  <a name="___sec114"></a></h3>

<p>
<p>&nbsp;<br>
$$ \int_\Omega g(x)dx \approx \frac{h}{6}\left( g(\xno{0}) +
2\sum_{j=1}^{N-1} g(\xno{j})
+ 4\sum_{j=0}^{N-1} g(\xno{j+\half}) + f(\xno{2N})\right),
$$
<p>&nbsp;<br>

Our case: \( g=f\basphi_i \). The sums collapse because \( \basphi_i=0 \) at most of
the points.

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,\basphi_i) \approx \frac{h}{3}(f_{i-\half} + f_i + f_{i+\half})
\end{equation}
$$
<p>&nbsp;<br>


<p>
Conclusions:

<p>

<ul>
  <p><li> While the finite difference method just samples \( f \) at \( x_i \),
    the finite element method applies an average (smoothing) of \( f \) around \( x_i \)</li>
  <p><li> On the left-hand side we have a term \( \sim hu'' \), and \( u'' \)
    also contribute to smoothing</li>
  <p><li> There is some inherent smoothing in the finite element
    method</li>
</ul>
<p>


</section>


<section>

<h3>Finite element approximation vs finite differences  <a name="___sec115"></a></h3>

<p>
With Trapezoidal integration of \( (f,\basphi_i) \), the finite element
metod essentially solve

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u + \frac{h^2}{6} u'' = f,\quad u'(0)=u'(L)=0,
\end{equation}
$$
<p>&nbsp;<br>

by the finite difference method

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[u + \frac{h^2}{6} D_x D_x u = f]_i
\end{equation}
$$
<p>&nbsp;<br>


<p>
With Simpson integration of \( (f,\basphi_i) \) we essentially solve

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[u + \frac{h^2}{6} D_x D_x u = \bar f]_i,
\end{equation}
$$
<p>&nbsp;<br>

where
<p>&nbsp;<br>
$$ \bar f_i = \frac{1}{3}(f_{i-1/2} + f_i + f_{i+1/2}) $$
<p>&nbsp;<br>


<p>
Note: as \( h\rightarrow 0 \), \( hu''\rightarrow 0 \) and \( \bar f_i\rightarrow f_i \).

<p>

</section>


<section>

<h3>Making finite elements behave as finite differences  <a name="___sec116"></a></h3>

<p>

<ul>
 <p><li> Can we adjust the finite element method so that we do not
   get the extra \( hu'' \) smoothing term and averaging of \( f \)?</li>
 <p><li> This is sometimes important in time-dependent problems to incorporate good
   properties of finite differences into finite elements</li>
</ul>
<p>

Result:

<p>

<ul>
 <p><li> Compute all integrals by the Trapezoidal method and P1 elements</li>
 <p><li> Specifically, the coefficient matrix becomes diagonal ("lumped") -
   no linear system (!)</li>
 <p><li> Loss of accuracy? The Trapezoidal rule has error \( \Oof{h^2} \),
   the same as the approximation error in P1 elements</li>
</ul>
<p>


</section>


<section>

<h2>Limitations of the nodes and element concepts <a name="fem:approx:fe:limitations"></a></h2>

<p>
So far,

<p>

<ul>
 <p><li> <em>Nodes</em>: points for defining \( \basphi_i \) and computing \( u \) values</li>
 <p><li> <em>Elements</em>: subdomain (containing a few nodes)</li>
 <p><li> This is a common notion of nodes and elements</li>
</ul>
<p>

One problem:

<p>

<ul>
 <p><li> Our algorithms need nodes at the element boundaries</li>
 <p><li> This is often not desirable, so we need to throw the <code>nodes</code> and
   <code>elements</code> arrays away and find a more generalized element concept</li>
</ul>
<p>


</section>


<section>

<h2>A generalized element concept <a name="fem:approx:fe:element"></a></h2>

<p>

<ul>
 <p><li> We introduce <em>cell</em> for the subdomain that we up to now called element</li>
 <p><li> A cell has <em>vertices</em> (interval end points)</li>
 <p><li> <em>Nodes</em> are, almost as before,
   points where we want to compute unknown functions</li>
 <p><li> <em>Degrees of freedom</em> is what the \( c_j \) represent (usually function values
   at nodes)</li>
</ul>
<p>


</section>


<section>

<h3>The concept of a finite element  <a name="___sec119"></a></h3>

<p>

<ol>
 <p><li> a <em>reference cell</em> in a local reference coordinate system</li>
 <p><li> a set of <em>basis functions</em> \( \refphi_r \) defined on the cell</li>
 <p><li> a set of <em>degrees of freedom</em> (e.g., function values)
    that uniquely determine
    the basis functions such that \( \refphi_r=1 \) for degree of freedom
    number \( r \) and \( \refphi_r=0 \) for all other degrees of freedom</li>
 <p><li> a mapping between local and global degree of freedom numbers (<em>dof map</em>)</li>
 <p><li> a geometric <em>mapping</em> of the reference cell onto to cell in the physical
    domain: \( [-1,1]\ \Rightarrow\ [x_L,x_R] \)</li>
</ol>
<p>


</section>


<section>

<h3>Implementation; basic data structures <a name="fem:approx:fe:element:impl"></a></h3>

<p>

<ul>
  <p><li> Cell vertex coordinates: <code>vertices</code> (equals <code>nodes</code> for P1 elements)</li>
  <p><li> Element vertices: <code>cell[e][r]</code> holds global vertex number of
    local vertex no <code>r</code> in element <code>e</code> (same as <code>elements</code> for P1 elements)</li>
  <p><li> <code>dof_map[e,r]</code> maps local dof <code>r</code> in element <code>e</code> to global dof
    number (same as <code>elements</code> for Pd elements)</li>
</ul>
<p>

The assembly process now applies <code>dof_map</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">A[dof_map[e][r],</span> <span style="color: #d0d0d0">dof_map[e][s]]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">A_e[r,s]</span>
<span style="color: #d0d0d0">b[dof_map[e][r]]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">b_e[r]</span>
</pre></div>
<p>

</section>


<section>

<h3>Implementation; example with P2 elements  <a name="___sec121"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_P2.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">vertices</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.4</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">cells</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">]]</span>
<span style="color: #d0d0d0">dof_map</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">4</span><span style="color: #d0d0d0">]]</span>
</pre></div>
<p>

</section>


<section>

<h3>Implementation; example with P0 elements  <a name="___sec122"></a></h3>

<p>
Example: Same mesh, but \( u \) is piecewise constant in each cell (P0 element).
Same <code>vertices</code> and <code>cells</code>, but

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">dof_map</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]]</span>
</pre></div>
<p>
May think of one node in the middle of each element.

<p>
<div class="alert alert-block alert-block alert-text-normal"><b></b>
We will hereafter work with <code>cells</code>, <code>vertices</code>, and <code>dof_map</code>.
</div>


<p>

</section>


<section>

<h3>Example on doing the algorithmic steps  <a name="___sec123"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #999999; font-style: italic"># Use modified fe_approx1D module</span>
<span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">fe_approx1D_numint</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #d0d0d0">*</span>

<span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.Symbol(</span><span style="color: #ed9d13">&#39;x&#39;</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">x*(</span><span style="color: #3677a9">1</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">x)</span>

<span style="color: #d0d0d0">N_e</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">10</span>
<span style="color: #999999; font-style: italic"># Create mesh with P3 (cubic) elements</span>
<span style="color: #d0d0d0">vertices,</span> <span style="color: #d0d0d0">cells,</span> <span style="color: #d0d0d0">dof_map</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">mesh_uniform(N_e,</span> <span style="color: #d0d0d0">d=</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">Omega=[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">])</span>

<span style="color: #999999; font-style: italic"># Create basis functions on the mesh</span>
<span style="color: #d0d0d0">phi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[basis(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(dof_map[e])-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">e</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(N_e)]</span>

<span style="color: #999999; font-style: italic"># Create linear system and solve it</span>
<span style="color: #d0d0d0">A,</span> <span style="color: #d0d0d0">b</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">assemble(vertices,</span> <span style="color: #d0d0d0">cells,</span> <span style="color: #d0d0d0">dof_map,</span> <span style="color: #d0d0d0">phi,</span> <span style="color: #d0d0d0">f)</span>
<span style="color: #d0d0d0">c</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">np.linalg.solve(A,</span> <span style="color: #d0d0d0">b)</span>

<span style="color: #999999; font-style: italic"># Make very fine mesh and sample u(x) on this mesh for plotting</span>
<span style="color: #d0d0d0">x_u,</span> <span style="color: #d0d0d0">u</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">u_glob(c,</span> <span style="color: #d0d0d0">vertices,</span> <span style="color: #d0d0d0">cells,</span> <span style="color: #d0d0d0">dof_map,</span>
                <span style="color: #d0d0d0">resolution_per_element=</span><span style="color: #3677a9">51</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">plot(x_u,</span> <span style="color: #d0d0d0">u)</span>
</pre></div>
<p>

</section>


<section>

<h3>Approximating a parabola by P0 elements  <a name="___sec124"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p0_x2_4e_8e.png" align="bottom" width=800></p></center>

<p>
The <code>approximate</code> function automates the steps in the previous slide:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">fe_approx1D_numint</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #d0d0d0">*</span>
<span style="color: #d0d0d0">x=sp.Symbol(</span><span style="color: #ed9d13">&quot;x&quot;</span><span style="color: #d0d0d0">)</span>
<span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">N_e</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #3677a9">4</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">8</span><span style="color: #d0d0d0">:</span>
    <span style="color: #d0d0d0">approximate(x*(</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">-x),</span> <span style="color: #d0d0d0">d=</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">N_e=N_e,</span> <span style="color: #d0d0d0">Omega=[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">])</span>
</pre></div>
<p>

</section>


<section>

<h3>Computing the error of the approximation; principles <a name="fem:approx:fe:element:impl:error"></a></h3>

<p>
<p>&nbsp;<br>
$$ L^2 \hbox{ error: }\quad ||e||_{L^2} =
\left(\int_{\Omega} e^2 dx\right)^{1/2}$$
<p>&nbsp;<br>


<p>
Accurate approximation of the integral:

<p>

<ul>
 <p><li> Sample \( u(x) \) at many points in each element (call <code>u_glob</code>, returns <code>x</code> and <code>u</code>)</li>
 <p><li> Use the Trapezoidal rule based on the samples</li>
 <p><li> It is important to integrate \( u \) accurately <em>over the elements</em></li>
 <p><li> (In a finite difference method we would just sample the mesh point values)</li>
</ul>
<p>


</section>


<section>

<h3>Computing the error of the approximation; details  <a name="___sec126"></a></h3>

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Note.</b>
We need a version of the Trapezoidal rule valid
for non-uniformly spaced points:

<p>
<p>&nbsp;<br>
$$ \int_\Omega g(x) dx \approx \sum_{j=0}^{n-1} \half(g(x_j) +
g(x_{j+1}))(x_{j+1}-x_j)$$
<p>&nbsp;<br>
</div>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #999999; font-style: italic"># Given c, compute x and u values on a very fine mesh</span>
<span style="color: #d0d0d0">x,</span> <span style="color: #d0d0d0">u</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">u_glob(c,</span> <span style="color: #d0d0d0">vertices,</span> <span style="color: #d0d0d0">cells,</span> <span style="color: #d0d0d0">dof_map,</span>
              <span style="color: #d0d0d0">resolution_per_element=</span><span style="color: #3677a9">101</span><span style="color: #d0d0d0">)</span>
<span style="color: #999999; font-style: italic"># Compute the error on the very fine mesh</span>
<span style="color: #d0d0d0">e</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">f(x)</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">u</span>
<span style="color: #d0d0d0">e2</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">e**</span><span style="color: #3677a9">2</span>
<span style="color: #999999; font-style: italic"># Vectorized Trapezoidal rule</span>
<span style="color: #d0d0d0">E</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">np.sqrt(</span><span style="color: #3677a9">0.5</span><span style="color: #d0d0d0">*np.sum((e2[:-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]</span> <span style="color: #d0d0d0">+</span> <span style="color: #d0d0d0">e2[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">:])*(x[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">:]</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">x[:-</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]))</span>
</pre></div>
<p>

</section>


<section>

<h3>How does the error depend on \( h \) and \( d \)?  <a name="___sec127"></a></h3>

<p>
Theory and experiments show that the least squares or projection/Galerkin
method in combination with Pd elements of equal length \( h \) has an error

<p>
<p>&nbsp;<br>
$$
\begin{equation}
||e||_{L^2} = Ch^{d+1}
\tag{28}
\end{equation}
$$
<p>&nbsp;<br>

where \( C \) depends on \( f \), but not on \( h \) or \( d \).

<p>

</section>


<section>

<h3>Cubic Hermite polynomials; definition  <a name="___sec128"></a></h3>

<p>

<ul>
 <p><li> Can we construct \( \basphi_i(x) \) with continuous derivatives? Yes!</li>
</ul>
<p>

Consider a reference cell \( [-1,1] \). We introduce two nodes, \( X=-1 \) and \( X=1 \).
The degrees of freedom are

<p>

<ul>
  <p><li> 0: value of function at \( X=-1 \)</li>
  <p><li> 1: value of first derivative at \( X=-1 \)</li>
  <p><li> 2: value of function at \( X=1 \)</li>
  <p><li> 3: value of first derivative at \( X=1 \)</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal"><b></b>
Derivatives as unknowns ensure the same \( \basphi_i'(x) \) value at nodes
and thereby continuous derivatives.
</div>


<p>

</section>


<section>

<h3>Cubic Hermite polynomials; derivation  <a name="___sec129"></a></h3>

<p>
4 constraints on \( \refphi_r \) (1 for dof \( r \), 0 for all others):

<p>

<ul>
  <p><li> \( \refphi_0(\Xno{0}) = 1 \), \( \refphi_0(\Xno{1}) = 0 \),
    \( \refphi_0'(\Xno{0}) = 0 \), \( \refphi_0'(\Xno{1}) = 0 \)</li>
  <p><li> \( \refphi_1'(\Xno{0}) = 1 \), \( \refphi_1'(\Xno{1}) = 0 \),
    \( \refphi_1(\Xno{0}) = 0 \), \( \refphi_1(\Xno{1}) = 0 \)</li>
  <p><li> \( \refphi_2(\Xno{1}) = 1 \), \( \refphi_2(\Xno{0}) = 0 \),
    \( \refphi_2'(\Xno{0}) = 0 \), \( \refphi_2'(\Xno{1}) = 0 \)</li>
  <p><li> \( \refphi_3'(\Xno{1}) = 1 \), \( \refphi_3'(\Xno{0}) = 0 \),
    \( \refphi_3(\Xno{0}) = 0 \), \( \refphi_3(\Xno{1}) = 0 \)</li>
</ul>
<p>

This gives 4 linear, coupled
equations <em>for each</em> \( \refphi_r \) to determine the 4
coefficients in the cubic polynomial

<p>

</section>


<section>

<h3>Cubic Hermite polynomials; result  <a name="___sec130"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= 1 - \frac{3}{4}(X+1)^2 + \frac{1}{4}(X+1)^3\\ 
\refphi_1(X) &= -(X+1)(1 - \half(X+1))^2\\ 
\refphi_2(X) &= \frac{3}{4}(X+1)^2 - \half(X+1)^3\\ 
\refphi_3(X) &= -\half(X+1)(\half(X+1)^2 - (X+1))\\ 
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h2>Numerical integration  <a name="___sec131"></a></h2>

<p>

<ul>
 <p><li> \( \int_\Omega f\basphi_idx \) must in general be computed by numerical integration</li>
 <p><li> Numerical integration is often used for the matrix too</li>
</ul>
<p>

Common form of a numerical integration rule:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx \sum_{j=0}^M w_jg(\bar X_j),
\end{equation}
$$
<p>&nbsp;<br>

where

<p>

<ul>
 <p><li> \( \bar X_j \) are <em>integration points</em></li>
 <p><li> \( w_j \) are <em>integration weights</em></li>
</ul>
<p>

Different rules correspond to different choices of points and weights

<p>

</section>


<section>

<h3>The Midpoint rule  <a name="___sec132"></a></h3>

<p>
Simplest possibility: the Midpoint rule,

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx 2g(0),\quad \bar X_0=0,\ w_0=2,
\end{equation}
$$
<p>&nbsp;<br>


<p>
Exact for linear integrands

<p>

</section>


<section>

<h3>Newton-Cotes rules <a name="fem:approx:fe:numint1"></a></h3>

<p>

<ul>
 <p><li> Idea: use a fixed, uniformly distributed set of points in \( [-1,1] \)</li>
 <p><li> The points often coincides with nodes</li>
 <p><li> Very useful for making \( \basphi_i\basphi_j=0 \) and get diagonal
   ("mass") matrices ("lumping")</li>
</ul>
<p>

The Trapezoidal rule:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx g(-1) + g(1),\quad \bar X_0=-1,\ \bar X_1=1,\ w_0=w_1=1,
 \tag{29}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Simpson's rule:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx \frac{1}{3}\left(g(-1) + 4g(0)
+ g(1)\right),
\end{equation}
$$
<p>&nbsp;<br>

where

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\bar X_0=-1,\ \bar X_1=0,\ \bar X_2=1,\ w_0=w_2=\frac{1}{3},\ w_1=\frac{4}{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Gauss-Legendre rules with optimized points  <a name="___sec134"></a></h3>

<p>

<ul>
 <p><li> Optimize the location of points to get higher accuracy</li>
 <p><li> Gauss-Legendre rules (quadrature) adjust points and weights to
   integrate polynomials exactly</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align}
M=1&:\quad \bar X_0=-\frac{1}{\sqrt{3}},\ 
\bar X_1=\frac{1}{\sqrt{3}},\ w_0=w_1=1\\ 
M=2&:\quad \bar X_0=-\sqrt{\frac{3}{{5}}},\ \bar X_0=0,\ 
\bar X_2= \sqrt{\frac{3}{{5}}},\ w_0=w_2=\frac{5}{9},\ w_1=\frac{8}{9}
\end{align}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( M=1 \): integrates 3rd degree polynomials exactly</li>
 <p><li> \( M=2 \): integrates 5th degree polynomials exactly</li>
 <p><li> In general, \( M \)-point rule integrates a polynomial
   of degree \( 2M+1 \) exactly.</li>
</ul>
<p>

See <a href="http://tinyurl.com/jvzzcfn/fem/numint.py" target="_self"><tt>numint.py</tt></a> for a large collection of Gauss-Legendre rules.

<p>

</section>


<section>

<h2>Approximation of functions in 2D <a name="fem:approx:2D"></a></h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Extensibility of 1D ideas.</b>
All the concepts and algorithms developed for approximation of 1D functions
\( f(x) \) can readily be extended to 2D functions \( f(x,y) \) and 3D functions
\( f(x,y,z) \). Key formulas stay the same.
</div>


<p>
Inner product in 2D:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,g) = \int_\Omega f(x,y)g(x,y) dx dy
\end{equation}
$$
<p>&nbsp;<br>


<p>
Least squares and project/Galerkin lead to a linear system

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If\\ 
A_{i,j} &= (\baspsi_i,\baspsi_j)\\ 
b_i &= (f,\baspsi_i)
\end{align*}
$$
<p>&nbsp;<br>


<p>
Challenge: How to construct 2D basis functions \( \baspsi_i(x,y) \)?

<p>

</section>


<section>

<h3>2D basis functions as tensor products of 1D functions <a name="fem:approx:2D:global"></a></h3>

<p>
Use a 1D basis for \( x \) variation and a similar for \( y \) variation:

<p>
<p>&nbsp;<br>
$$
\begin{align}
V_x &= \mbox{span}\{ \hat\baspsi_0(x),\ldots,\hat\baspsi_{N_x}(x)\}
\tag{30}\\ 
V_y &= \mbox{span}\{ \hat\baspsi_0(y),\ldots,\hat\baspsi_{N_y}(y)\}
\tag{31}
\end{align}
$$
<p>&nbsp;<br>


<p>
The 2D vector space can be defined as a <em>tensor product</em> \( V = V_x\otimes V_y \)
with basis functions

<p>
<p>&nbsp;<br>
$$
\baspsi_{p,q}(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y)
\quad p\in\Ix,q\in\Iy\tp
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Tensor products  <a name="___sec137"></a></h3>

<p>
Given two vectors \( a=(a_0,\ldots,a_M) \) and \( b=(b_0,\ldots,b_N) \)
their <em>outer tensor product</em>, also called the <em>dyadic product</em>,
is \( p=a\otimes b \), defined through

<p>
<p>&nbsp;<br>
$$ p_{i,j}=a_ib_j,\quad i=0,\ldots,M,\ j=0,\ldots,N\tp$$
<p>&nbsp;<br>

Note: \( p \) has two indices (as a matrix or two-dimensional array)

<p>
Example: 2D basis as tensor product of 1D spaces,

<p>
<p>&nbsp;<br>
$$ \baspsi_{p,q}(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y),
\quad p\in\Ix,q\in\Iy$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Double or single index?  <a name="___sec138"></a></h3>

<p>
The 2D basis can employ a double index and double sum:

<p>
<p>&nbsp;<br>
$$ u = \sum_{p\in\Ix}\sum_{q\in\Iy} c_{p,q}\baspsi_{p,q}(x,y)
$$
<p>&nbsp;<br>


<p>
Or just a single index:

<p>
<p>&nbsp;<br>
$$ u = \sum_{j\in\If} c_j\baspsi_j(x,y)$$
<p>&nbsp;<br>

with

<p>
<p>&nbsp;<br>
$$
\baspsi_i(x,y) = \hat\baspsi_p(x)\hat\baspsi_q(y),
\quad i=p N_y + q\hbox{ or } i=q N_x + p
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example on 2D (bilinear) basis functions; formulas  <a name="___sec139"></a></h3>

<p>
In 1D we use the basis

<p>
<p>&nbsp;<br>
$$ \{ 1, x \} $$
<p>&nbsp;<br>


<p>
2D tensor product (all combinations):

<p>
<p>&nbsp;<br>
$$ \baspsi_{0,0}=1,\quad \baspsi_{1,0}=x, \quad \baspsi_{0,1}=y,
\quad \baspsi_{1,1}=xy
$$
<p>&nbsp;<br>

or with a single index:

<p>
<p>&nbsp;<br>
$$ \baspsi_0=1,\quad \baspsi_1=x, \quad \baspsi_2=y,\quad\baspsi_3 =xy
$$
<p>&nbsp;<br>


<p>
See notes for details of a hand-calculation.

<p>

</section>


<section>

<h3>Example on 2D (bilinear) basis functions; plot  <a name="___sec140"></a></h3>

<p>
Quadratic \( f(x,y) = (1+x^2)(1+2y^2) \) (left), bilinear \( u \) (right):

<p>
<center><p><img src="fig-fem/approx2D_bilinear.png" align="bottom" width=800></p></center>

<p>

</section>


<section>

<h3>Implementation; principal changes to the 1D code <a name="fem:approx:2D:global:code"></a></h3>

<p>
Very small modification of <code>approx1D.py</code>:

<p>

<ul>
 <p><li> <code>Omega = [[0, L_x], [0, L_y]]</code></li>
 <p><li> Symbolic integration in 2D</li>
 <p><li> Construction of 2D (tensor product) basis functions</li>
</ul>
<p>


</section>


<section>

<h3>Implementation; 2D integration  <a name="___sec142"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #447fcf; text-decoration: underline">sympy</span> <span style="color: #6ab825; font-weight: bold">as</span> <span style="color: #447fcf; text-decoration: underline">sp</span>

<span style="color: #d0d0d0">integrand</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">psi[i]*psi[j]</span>
<span style="color: #d0d0d0">I</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.integrate(integrand,</span>
                 <span style="color: #d0d0d0">(x,</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">][</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">][</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]),</span>
                 <span style="color: #d0d0d0">(y,</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">][</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">][</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]))</span>

<span style="color: #999999; font-style: italic"># Fall back on numerical integration if symbolic integration</span>
<span style="color: #999999; font-style: italic"># was unsuccessful</span>
<span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #24909d">isinstance</span><span style="color: #d0d0d0">(I,</span> <span style="color: #d0d0d0">sp.Integral):</span>
    <span style="color: #d0d0d0">integrand</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.lambdify([x,y],</span> <span style="color: #d0d0d0">integrand)</span>
    <span style="color: #d0d0d0">I</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">sp.mpmath.quad(integrand,</span>
                       <span style="color: #d0d0d0">[Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">][</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">][</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]],</span>
                       <span style="color: #d0d0d0">[Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">][</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">Omega[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">][</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]])</span>
</pre></div>
<p>

</section>


<section>

<h3>Implementation; 2D basis functions  <a name="___sec143"></a></h3>

<p>
Tensor product of 1D "Taylor-style" polynomials \( x^i \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">taylor</span><span style="color: #d0d0d0">(x,</span> <span style="color: #d0d0d0">y,</span> <span style="color: #d0d0d0">Nx,</span> <span style="color: #d0d0d0">Ny):</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">[x**i*y**j</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(Nx+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">j</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(Ny+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)]</span>
</pre></div>
<p>
Tensor product of 1D sine functions \( \sin((i+1)\pi x) \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">def</span> <span style="color: #447fcf">sines</span><span style="color: #d0d0d0">(x,</span> <span style="color: #d0d0d0">y,</span> <span style="color: #d0d0d0">Nx,</span> <span style="color: #d0d0d0">Ny):</span>
    <span style="color: #6ab825; font-weight: bold">return</span> <span style="color: #d0d0d0">[sp.sin(sp.pi*(i+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)*x)*sp.sin(sp.pi*(j+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)*y)</span>
            <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">i</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(Nx+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)</span> <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">j</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(Ny+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)]</span>
</pre></div>
<p>
Complete code in
<a href="http://tinyurl.com/jvzzcfn/fem/fe_approx2D.py" target="_self"><tt>approx2D.py</tt></a>

<p>

</section>


<section>

<h3>Implementation; application  <a name="___sec144"></a></h3>

<p>
\( f(x,y) = (1+x^2)(1+2y^2) \)

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%">&gt;&gt;&gt; from approx2D import *
&gt;&gt;&gt; f = (1+x**2)*(1+2*y**2)
&gt;&gt;&gt; psi = taylor(x, y, 1, 1)
&gt;&gt;&gt; Omega = [[0, 2], [0, 2]]
&gt;&gt;&gt; u, c = least_squares(f, psi, Omega)
&gt;&gt;&gt; print u
8*x*y - 2*x/3 + 4*y/3 - 1/9
&gt;&gt;&gt; print sp.expand(f)
2*x**2*y**2 + x**2 + 2*y**2 + 1
</pre></div>
<p>

</section>


<section>

<h3>Implementation; trying a perfect expansion  <a name="___sec145"></a></h3>

<p>
Add higher powers to the basis such that \( f\in V \):

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%">&gt;&gt;&gt; psi = taylor(x, y, 2, 2)
&gt;&gt;&gt; u, c = least_squares(f, psi, Omega)
&gt;&gt;&gt; print u
2*x**2*y**2 + x**2 + 2*y**2 + 1
&gt;&gt;&gt; print u-f
0
</pre></div>
<p>
Expected: \( u=f \) when \( f\in V \)

<p>

</section>


<section>

<h3>Generalization to 3D <a name="fem:approx:3D:global"></a></h3>

<p>
Key idea:

<p>
<p>&nbsp;<br>
$$ V = V_x\otimes V_y\otimes V_z$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Repeated outer tensor product of multiple vectors.</b>

<p>
<p>&nbsp;<br>
$$
\begin{align*}
a^{(q)} &= (a^{(q)}_0,\ldots,a^{(q)}_{N_q}),\quad q=0,\ldots,m\\ 
p &= a^{(0)}\otimes\cdots\otimes a^{(m)}\\ 
p_{i_0,i_1,\ldots,i_m} &= a^{(0)}_{i_1}a^{(1)}_{i_1}\cdots a^{(m)}_{i_m}
\end{align*}
$$
<p>&nbsp;<br>


<p>
</div>


<p>
<p>&nbsp;<br>
$$
\begin{align*}
\baspsi_{p,q,r}(x,y,z) &= \hat\baspsi_p(x)\hat\baspsi_q(y)\hat\baspsi_r(z)\\ 
u(x,y,z) &= \sum_{p\in\Ix}\sum_{q\in\Iy}\sum_{r\in\Iz} c_{p,q,r}
\baspsi_{p,q,r}(x,y,z)
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h2>Finite elements in 2D and 3D  <a name="___sec147"></a></h2>

<p>
The two great advantages of the finite element method:

<p>

<ul>
  <p><li> Can handle complex-shaped domains in 2D and 3D</li>
  <p><li> Can easily provide higher-order polynomials in the approximation</li>
</ul>
<p>

Finite elements in 1D: mostly for learning, insight, debugging

<p>

</section>


<section>

<h3>Examples on cell types  <a name="___sec148"></a></h3>

<p>
2D:

<p>

<ul>
 <p><li> triangles</li>
 <p><li> quadrilaterals</li>
</ul>
<p>

3D:

<p>

<ul>
 <p><li> tetrahedra</li>
 <p><li> hexahedra</li>
</ul>
<p>


</section>


<section>

<h3>Rectangular domain with 2D P1 elements  <a name="___sec149"></a></h3>

<p>
<center><p><img src="fig-fem/mesh2D_rect_P1.png" align="bottom" width=800></p></center>

<p>

</section>


<section>

<h3>Deformed geometry with 2D P1 elements  <a name="___sec150"></a></h3>

<p>
<center><p><img src="fig-fem/mesh2D_quarter_circle.png" align="bottom" width=600></p></center>

<p>

</section>


<section>

<h3>Rectangular domain with 2D Q1 elements  <a name="___sec151"></a></h3>

<p>
<center><p><img src="fig-fem/mesh2D_rect_Q1.png" align="bottom" width=500></p></center>

<p>

</section>


<section>

<h3>Basis functions over triangles in the physical domain  <a name="___sec152"></a></h3>

<p>
The P1 triangular 2D element: \( u \) is linear \( ax + by + c \) over each
triangular cell

<p>
<center><p><img src="fig-fem/demo2D_4x3r.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Basic features of 2D P1 elements  <a name="___sec153"></a></h3>

<p>

<ul>
 <p><li> \( \basphi_r(X,Y) \) is a linear function over each element</li>
 <p><li> Cells = triangles</li>
 <p><li> Vertices = corners of the cells</li>
 <p><li> Nodes = vertices</li>
 <p><li> Degrees of freedom = function values at the nodes</li>
</ul>
<p>


</section>


<section>

<h3>Linear mapping of reference element onto general triangular cell  <a name="___sec154"></a></h3>

<p>
<center><p><img src="fig-fem/ElmT3n2D_map.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>\( \basphi_i \): pyramid shape, composed of planes  <a name="___sec155"></a></h3>

<p>

<ul>
 <p><li> \( \basphi_i(X,Y) \) varies linearly over an element</li>
 <p><li> \( \basphi_i=1 \) at vertex (node) \( i \), 0 at all other vertices (nodes)</li>
</ul>
<p>

<center><p><img src="fig-fem/demo2D_basisfunc.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Element matrices and vectors  <a name="___sec156"></a></h3>

<p>

<ul>
 <p><li> As in 1D, the contribution from one cell to the matrix involves
   just a few numbers, collected in the element matrix and vector</li>
 <p><li> \( \basphi_i\basphi_j\neq 0 \) only if \( i \) and \( j \) are
   degrees of freedom (vertices/nodes) in the same element</li>
 <p><li> The 2D P1 has a \( 3\times 3 \) element matrix</li>
</ul>
<p>


</section>


<section>

<h3>Basis functions over triangles in the reference cell  <a name="___sec157"></a></h3>

<p>
<center><p><img src="fig-fem/fenics-book/elements/P1_2d.png" align="bottom" width=100></p></center>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X,Y) &= 1 - X - Y\\ 
\refphi_1(X,Y) &= X\\ 
\refphi_2(X,Y) &= Y
\end{align}
$$
<p>&nbsp;<br>


<p>
Higher-degree \( \refphi_r \) introduce more nodes (dof = node values)

<p>

</section>


<section>

<h3>2D P1, P2, P3, P4, P5, and P6 elements  <a name="___sec158"></a></h3>

<p>
<center><p><img src="fig-fem/fenics-book/elements/P1-6_2d.png" align="bottom" width=320></p></center>

<p>

</section>


<section>

<h3>P1 elements in 1D, 2D, and 3D  <a name="___sec159"></a></h3>

<p>
<center><p><img src="fig-fem/fenics-book/elements/P1-1d2d3d.png" align="bottom" width=320></p></center>

<p>

</section>


<section>

<h3>P2 elements in 1D, 2D, and 3D  <a name="___sec160"></a></h3>

<p>
<center><p><img src="fig-fem/fenics-book/elements/P2-1d2d3d.png" align="bottom" width=320></p></center>

<p>

<ul>
 <p><li> Interval, triangle, tetrahedron: <em>simplex</em> element
   (plural quick-form: <em>simplices</em>)</li>
 <p><li> Side of the cell is called <em>face</em></li>
 <p><li> Thetrahedron has also <em>edges</em></li>
</ul>
<p>


</section>


<section>

<h3>Affine mapping of the reference cell; formula  <a name="___sec161"></a></h3>

<p>
Mapping of local \( \X = (X,Y) \) coordinates in the reference cell to
global, physical \( \x = (x,y) \) coordinates:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\x = \sum_{r} \refphi_r^{(1)}(\X)\xdno{q(e,r)}
\tag{32}
\end{equation}
$$
<p>&nbsp;<br>


<p>
where

<p>

<ul>
  <p><li> \( r \) runs over the local vertex numbers in the cell</li>
  <p><li> \( \xdno{i} \) are the \( (x,y) \) coordinates of vertex \( i \)</li>
  <p><li> \( \refphi_r^{(1)} \) are P1 basis functions</li>
</ul>
<p>

This mapping preserves the straight/planar faces and edges.

<p>

</section>


<section>

<h3>Affine mapping of the reference cell; figure  <a name="___sec162"></a></h3>

<p>
<center><p><img src="fig-fem/ElmT3n2D_map.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Isoparametric mapping of the reference cell  <a name="___sec163"></a></h3>

<p>
Idea: Use the basis functions
of the element (not only the P1 functions)
to map the element

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\x = \sum_{r} \refphi_r(\X)\xdno{q(e,r)}
\tag{33}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Advantage: higher-order polynomial basis functions now map the
reference cell to a <em>curved</em> triangle or tetrahedron.

<p>
<center><p><img src="fig-fem/ElmT6n2D_map.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Computing integrals  <a name="___sec164"></a></h3>

<p>
Integrals must be transformed from \( \Omega^{(e)} \) (physical cell)
to \( \tilde\Omega^r \) (reference cell):

<p>
<p>&nbsp;<br>
$$
\begin{align}
\int_{\Omega^{(e)}}\basphi_i (\x) \basphi_j (\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) \refphi_j (\X)
\det J\, \dX\\ 
\int_{\Omega^{(e)}}\basphi_i (\x) f(\x) \dx &=
\int_{\tilde\Omega^r} \refphi_i (\X) f(\x(\X)) \det J\, \dX
\end{align}
$$
<p>&nbsp;<br>

where \( \dx = dx dy \) or \( \dx = dxdydz \) and \( \det J \) is the determinant of the
Jacobian of the mapping \( \x(\X) \).

<p>
<p>&nbsp;<br>
$$
\begin{equation}
J = \left[\begin{array}{cc}
\frac{\partial x}{\partial X} & \frac{\partial x}{\partial Y}\\ 
\frac{\partial y}{\partial X} & \frac{\partial y}{\partial Y}
\end{array}\right], \quad
\det J = \frac{\partial x}{\partial X}\frac{\partial y}{\partial Y}
- \frac{\partial x}{\partial Y}\frac{\partial y}{\partial X}
\tag{34}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Affine mapping
<a href="#mjx-eqn-32">(32)</a>: \( \det J=2\Delta \), \( \Delta = \hbox{cell volume} \)

<p>
!slide

<h3>Remark on going from 1D to 2D/3D  <a name="___sec165"></a></h3>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b></b>
Finite elements in 2D and 3D builds on the same
<em>ideas</em> and <em>concepts</em> as in 1D, but there is simply much
more to compute because the
specific mathematical formulas in 2D and 3D are more complicated
and the book keeping with dof maps also gets more complicated.
The manual work is tedious, lengthy, and error-prone
so automation by the computer is a must.
</div>


<p>

</section>


<section>

<h2>Differential equation models <a name="fem:deq:1D:models"></a></h2>

<p>
Our aim is to extend the ideas for approximating \( f \) by \( u \), or solving

<p>
<p>&nbsp;<br>
$$ u = f $$
<p>&nbsp;<br>


<p>
to real differential equations like[[[

<p>
<p>&nbsp;<br>
$$ -u'' + bu = f,\quad u(0)=1,\ u'(L)=D $$
<p>&nbsp;<br>


<p>
Three methods are addressed:

<p>

<ol>
<p><li> least squares</li>
<p><li> Galerkin/projection</li>
<p><li> collocation (interpolation)</li>
</ol>
<p>

Method 2 will be totally dominating!

<p>

</section>


<section>

<h3>Abstract differential equation  <a name="___sec167"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\mathcal{L}(u) = 0,\quad x\in\Omega  \end{equation}
$$
<p>&nbsp;<br>


<p>
Examples (1D problems):

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mathcal{L}(u) &= \frac{d^2u}{dx^2} - f(x),
\tag{35}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(x)\frac{du}{dx}\right) + f(x),
\tag{36}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(u)\frac{du}{dx}\right) - au + f(x),
\tag{37}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(u)\frac{du}{dx}\right) + f(u,x)
\tag{38}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Abstract boundary conditions  <a name="___sec168"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
{\cal B}_0(u)=0,\ x=0,\quad {\cal B}_1(u)=0,\ x=L
\end{equation}
$$
<p>&nbsp;<br>


<p>
Examples:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mathcal{B}_i(u) &= u - g,\quad &\hbox{Dirichlet condition}\\ 
\mathcal{B}_i(u) &= -\dfc \frac{du}{dx} - g,\quad &\hbox{Neumann condition}\\ 
\mathcal{B}_i(u) &= -\dfc \frac{du}{dx} - h(u-g),\quad &\hbox{Robin condition}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Reminder about notation  <a name="___sec169"></a></h3>

<p>

<ul>
 <p><li> \( \uex(x) \) is the symbol for the <em>exact</em> solution
   of \( \mathcal{L}(\uex)=0 \)</li>
 <p><li> \( u(x) \) denotes an <em>approximate</em> solution</li>
 <p><li> We seek \( u\in V \)</li>
 <p><li> \( V = \hbox{span}\{ \baspsi_0(x),\ldots,\baspsi_N(x)\} \), \( V \) has basis \( \sequencei{\baspsi} \)</li>
 <p><li> \( \If =\{0,\ldots,N\} \) is an index set</li>
 <p><li> \( u(x) = \sum_{j\in\If} c_j\baspsi_j(x) \)</li>
 <p><li> Inner product: \( (u,v) = \int_\Omega uv\dx \)</li>
 <p><li> Norm: \( ||u||=\sqrt{(u,u)} \)</li>
</ul>
<p>


</section>


<section>

<h3>New topics  <a name="___sec170"></a></h3>

<p>
Much is similar to approximating a function (solving \( u=f \)), but
two new topics are needed:

<p>

<ul>
 <p><li> Variational formulation of the differential equation problem
   (including integration by parts)</li>
 <p><li> Handling of boundary conditions</li>
</ul>
<p>


</section>


<section>

<h3>Residual-minimizing principles <a name="fem:deq:1D:residual:min"></a></h3>

<p>

<ul>
 <p><li> When solving \( u=f \) we knew the error \( e=f-u \) and could
   use principles for minimizing the error</li>
 <p><li> When solving \( \mathcal{L}(\uex)=0 \) we do not know \( \uex \) and
   cannot work with the error \( e=\uex - u \)</li>
 <p><li> We only have the <em>error in the equation</em>: the residual \( R \)</li>
</ul>
<p>

Inserting \( u=\sum_jc_j\baspsi_j \) in \( \mathcal{L}=0 \) gives
a residual

<p>
<p>&nbsp;<br>
$$
\begin{equation}
R = \mathcal{L}(u) = \mathcal{L}(\sum_j c_j \baspsi_j) \neq 0
\end{equation}
$$
<p>&nbsp;<br>


<p>
Goal: minimize \( R \) wrt \( \sequencei{c} \) (and hope it makes a small \( e \) too)

<p>
<p>&nbsp;<br>
$$ R=R(c_0,\ldots,c_N; x)$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The least squares method  <a name="___sec172"></a></h3>

<p>
Idea: minimize

<p>
<p>&nbsp;<br>
$$
\begin{equation}
E = ||R||^2 = (R,R) = \int_{\Omega} R^2 dx
\end{equation}
$$
<p>&nbsp;<br>


<p>
Minimization wrt \( \sequencei{c} \) implies

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial E}{\partial c_i} =
\int_{\Omega} 2R\frac{\partial R}{\partial c_i} dx = 0\quad
\Leftrightarrow\quad (R,\frac{\partial R}{\partial c_i})=0,\quad
i\in\If
\tag{39}
\end{equation}
$$
<p>&nbsp;<br>


<p>
\( N+1 \) equations for \( N+1 \) unknowns \( \sequencei{c} \)

<p>

</section>


<section>

<h3>The Galerkin method  <a name="___sec173"></a></h3>

<p>
Idea: make \( R \) orthogonal to \( V \),

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in V
\tag{40}
\end{equation}
$$
<p>&nbsp;<br>


<p>
This implies

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,\baspsi_i)=0,\quad i\in\If
\tag{41}
\end{equation}
$$
<p>&nbsp;<br>


<p>
\( N+1 \) equations for \( N+1 \) unknowns \( \sequencei{c} \)

<p>

</section>


<section>

<h3>The Method of Weighted Residuals  <a name="___sec174"></a></h3>

<p>
Generalization of the Galerkin method: demand \( R \)
orthogonal to some space \( W \), possibly \( W\neq V \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in W
\tag{42}
\end{equation}
$$
<p>&nbsp;<br>


<p>
If \( \{w_0,\ldots,w_N\} \) is a basis for \( W \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,w_i)=0,\quad i\in\If
\tag{43}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( N+1 \) equations for \( N+1 \) unknowns \( \sequencei{c} \)</li>
 <p><li> Weighted residual with \( w_i = \partial R/\partial c_i \) gives
   least squares</li>
</ul>
<p>


</section>


<section>

<h3>Terminology: test and trial Functions  <a name="___sec175"></a></h3>

<p>

<ul>
 <p><li> \( \baspsi_j \) used in \( \sum_jc_j\baspsi_j \) is called <em>trial function</em></li>
 <p><li> \( \baspsi_i \) or \( w_i \) used as weight in Galerkin's method is called <em>test function</em></li>
</ul>
<p>


</section>


<section>

<h3>The collocation method  <a name="___sec176"></a></h3>

<p>
Idea: demand \( R=0 \) at \( N+1 \) points

<p>
<p>&nbsp;<br>
$$
\begin{equation}
R(\xno{i}; c_0,\ldots,c_N)=0,\quad i\in\If
\tag{44}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Note: The collocation method is a weighted residual method with
delta functions as weights

<p>
<p>&nbsp;<br>
$$ 0 = \int_\Omega R(x;c_0,\ldots,c_N)
\delta(x-\xno{i})\dx = R(\xno{i}; c_0,\ldots,c_N)$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\hbox{property of } \delta(x):\quad
\int_{\Omega} f(x)\delta (x-\xno{i}) dx = f(\xno{i}),\quad \xno{i}\in\Omega
\tag{45}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-fem/delta_func_weight.png" align="bottom" width=200></p></center>

<p>

</section>


<section>

<h2>Examples on using the principles <a name="fem:deq:1D:ex:sines"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b>Goal.</b>
Exemplify the least squares, Galerkin, and collocation methods
in a simple 1D problem with global basis functions.
</div>


<p>

</section>


<section>

<h3>The first model problem  <a name="___sec178"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=0
\tag{46}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Basis functions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\baspsi_i(x) = \sinL{i},\quad i\in\If
\tag{47}
\end{equation}
$$
<p>&nbsp;<br>


<p>
The residual:

<p>
<p>&nbsp;<br>
$$
\begin{align}
R(x;c_0,\ldots,c_N) &= u''(x) + f(x),\nonumber\\ 
&= \frac{d^2}{dx^2}\left(\sum_{j\in\If} c_j\baspsi_j(x)\right)
+ f(x),\nonumber\\ 
&= -\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)
\tag{48}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Boundary conditions  <a name="___sec179"></a></h3>

<p>
Since \( u(0)=u(L)=0 \) we must ensure that
all \( \baspsi_i(0)=\baspsi_i(L)=0 \). Then

<p>
<p>&nbsp;<br>
$$ u(0) = \sum_jc_j\baspsi_j(0) = 0,\quad u(L) = \sum_jc_j\baspsi_j(L) $$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( u \) known: Dirichlet boundary condition</li>
 <p><li> \( u' \) known: Neumann boundary condition</li>
 <p><li> Must have \( \baspsi_i=0 \) where Dirichlet conditions apply</li>
</ul>
<p>


</section>


<section>

<h3>The least squares method; principle  <a name="___sec180"></a></h3>

<p>
<p>&nbsp;<br>
$$
(R,\frac{\partial R}{\partial c_i}) = 0,\quad i\in\If
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial R}{\partial c_i} =
\frac{\partial}{\partial c_i}
\left(\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\right)
= \baspsi_i''(x)  \end{equation}
$$
<p>&nbsp;<br>


<p>
Because:
<p>&nbsp;<br>
$$
\frac{\partial}{\partial c_i}\left(c_0\baspsi_0'' + c_1\baspsi_1'' + \cdots +
c_{i-1}\baspsi_{i-1}'' + \color{blue}{c_i\baspsi_{i}''} + c_{i+1}\baspsi_{i+1}''
+ \cdots + c_N\baspsi_N'' \right) = \baspsi_{i}''
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The least squares method; equation system  <a name="___sec181"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\sum_j c_j \baspsi_j'' + f,\baspsi_i'')=0,\quad i\in\If
\end{equation}
$$
<p>&nbsp;<br>


<p>
Rearrangement:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j\in\If}(\baspsi_i'',\baspsi_j'')c_j = -(f,\baspsi_i''),\quad i\in\If  \end{equation}
$$
<p>&nbsp;<br>


<p>
This is a linear system

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \sum_{j\in\If}A_{i,j}c_j = b_i,\quad i\in\If
\end{equation*}
$$
<p>&nbsp;<br>

with

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{i,j} &= (\baspsi_i'',\baspsi_j'')\nonumber\\ 
& = \pi^4(i+1)^2(j+1)^2L^{-4}\int_0^L \sinL{i}\sinL{j}\, dx\nonumber\\ 
&= \left\lbrace
\begin{array}{ll} {1\over2}L^{-3}\pi^4(i+1)^4 & i=j  \\ 0, & i\neq j
\end{array}\right.
\\ 
b_i &= -(f,\baspsi_i'') = (i+1)^2\pi^2L^{-2}\int_0^Lf(x)\sinL{i}\, dx
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Orthogonality of the basis functions gives diagonal matrix  <a name="___sec182"></a></h3>

<p>
Useful property:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int\limits_0^L \sinL{i}\sinL{j}\, dx = \delta_{ij},\quad
\quad\delta_{ij} = \left\lbrace
\begin{array}{ll} \half L & i=j  \\ 0, & i\neq j
\end{array}\right.
\end{equation}
$$
<p>&nbsp;<br>


<p>
\( \Rightarrow\ (\baspsi_i'',\baspsi_j'') = \delta_{ij} \), i.e.,
diagonal \( A_{i,j} \), and we can easily solve for \( c_i \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_i = \frac{2L}{\pi^2(i+1)^2}\int_0^Lf(x)\sinL{i}\, dx
\tag{49}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Least squares method; solution  <a name="___sec183"></a></h3>

<p>
Let's <code>sympy</code> do the work (\( f(x)=2 \)):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">sympy</span> <span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #d0d0d0">*</span>
<span style="color: #6ab825; font-weight: bold">import</span> <span style="color: #447fcf; text-decoration: underline">sys</span>

<span style="color: #d0d0d0">i,</span> <span style="color: #d0d0d0">j</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">symbols(</span><span style="color: #ed9d13">&#39;i j&#39;</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">integer=</span><span style="color: #24909d">True</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">x,</span> <span style="color: #d0d0d0">L</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">symbols(</span><span style="color: #ed9d13">&#39;x L&#39;</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">f</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">2</span>
<span style="color: #d0d0d0">a</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">*L/(pi**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">*(i+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)**</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">)</span>
<span style="color: #d0d0d0">c_i</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">a*integrate(f*sin((i+</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">)*pi*x/L),</span> <span style="color: #d0d0d0">(x,</span> <span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #d0d0d0">L))</span>
<span style="color: #d0d0d0">c_i</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">simplify(c_i)</span>
<span style="color: #6ab825; font-weight: bold">print</span> <span style="color: #d0d0d0">c_i</span>
</pre></div>
<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_i = 4 \frac{L^{2} \left(\left(-1\right)^{i} + 1\right)}{\pi^{3}
\left(i^{3} + 3 i^{2} + 3 i + 1\right)},\quad
u(x) = \sum_{k=0}^{N/2} \frac{8L^2}{\pi^3(2k+1)^3}\sinL{2k}\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>
Fast decay: \( c_2 = c_0/27 \), \( c_4=c_0/125 \) - only one term might be good enough:

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) \approx \frac{8L^2}{\pi^3}\sin\left(\pi\frac{x}{L}\right)\tp  \end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The Galerkin method; principle  <a name="___sec184"></a></h3>

<p>
\( R=u''+f \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
(u''+f,v)=0,\quad \forall v\in V,
\end{equation*}
$$
<p>&nbsp;<br>

or

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(u'',v) = -(f,v),\quad\forall v\in V  \end{equation}
$$
<p>&nbsp;<br>


<p>
This is a <em>variational formulation</em> of the differential equation problem.

<p>
\( \forall v\in V \) means for all basis functions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\sum_{j\in\If} c_j\baspsi_j'', \baspsi_i)=-(f,\baspsi_i),\quad i\in\If  \end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The Galerkin method; solution  <a name="___sec185"></a></h3>

<p>
Since \( \baspsi_i''\propto \baspsi_i \),
Galerkin's method gives the same linear system and the same solution
as the least squares method (in this particular example).

<p>

</section>


<section>

<h3>The collocation method  <a name="___sec186"></a></h3>

<p>
\( R=0 \) (i.e.,the differential equation) must be satisfied at \( N+1 \) points:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\sum_{j\in\If} c_j\baspsi_j''(\xno{i}) = f(\xno{i}),\quad i\in\If
\end{equation}
$$
<p>&nbsp;<br>


<p>
This is a linear system \( \sum_j A_{i,j}=b_i \) with entries

<p>
<p>&nbsp;<br>
$$
\begin{equation*} A_{i,j}=-\baspsi_j''(\xno{i})=
(j+1)^2\pi^2L^{-2}\sin\left((j+1)\pi \frac{x_i}{L}\right),
\quad b_i=2
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Choose: \( N=0 \), \( x_0=L/2 \)

<p>
<p>&nbsp;<br>
$$ c_0=2L^2/\pi^2 $$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Comparison of the methods  <a name="___sec187"></a></h3>

<p>

<ul>
 <p><li> Exact solution: \( u(x)=x(L-x) \)</li>
 <p><li> Galerkin or least squares (\( N=0 \)): \( u(x)=8L^2\pi^{-3}\sin (\pi x/L) \)</li>
 <p><li> Collocation method (\( N=0 \)): \( u(x)=2L^2\pi^{-2}\sin (\pi x/L) \).</li>
 <p><li> Max error in Galerkin/least sq.: \( -0.008L^2 \)</li>
 <p><li> Max error in collocation: \( 0.047L^2 \)</li>
</ul>
<p>


</section>


<section>

<h2>Useful techniques  <a name="___sec188"></a></h2>

<p>

</section>


<section>

<h3>Integration by parts <a name="fem:deq:1D:varform"></a></h3>

<p>
Second-order derivatives will hereafter be integrated by parts

<p>
<p>&nbsp;<br>
$$
\begin{align}
\int_0^L u''(x)v(x) dx &= - \int_0^Lu'(x)v'(x)dx
+ [vu']_0^L\nonumber\\ 
&= - \int_0^Lu'(x)v'(x) dx
+ u'(L)v(L) - u'(0)v(0)
\tag{50}
\end{align}
$$
<p>&nbsp;<br>


<p>
Motivation:

<p>

<ul>
 <p><li> Lowers the order of derivatives</li>
 <p><li> Gives more symmetric forms (incl. matrices)</li>
 <p><li> Enables easy handling of Neumann boundary conditions</li>
 <p><li> Finite element basis functions \( \basphi_i \) have discontinuous
   derivatives (at cell boundaries) and are not suited for
   terms with \( \basphi_i'' \)</li>
</ul>
<p>

<h3>Boundary function; principles  <a name="___sec190"></a></h3>
<a name="fem:deq:1D:essBC:Bfunc"></a>

<p>

<ul>
 <p><li> What about nonzero Dirichlet conditions? Say \( u(L)=D \)</li>
 <p><li> We always require \( \baspsi_i(L)=0 \) (i.e., \( \baspsi_i=0 \) where Dirichlet conditions applies)</li>
 <p><li> Problem: \( u(L) = \sum_j c_j\baspsi_j(L)=\sum_j c_j\cdot 0=0\neq D \) - always</li>
 <p><li> Solution: \( u(x) = B(x) + \sum_j c_j\baspsi_j(x) \)</li>
 <p><li> \( B(x) \): user-constructed boundary function that fulfills the Dirichlet
   conditions</li>
 <p><li> If \( u(L)=D \), \( B(L)=D \)</li>
 <p><li> No restrictions of how \( B(x) \) varies in the interior of \( \Omega \)</li>
</ul>
<p>


</section>


<section>

<h3>Boundary function; example (1)  <a name="___sec191"></a></h3>

<p>
Dirichlet conditions: \( u(0)=C \) and \( u(L)=D \). Choose for example

<p>
<p>&nbsp;<br>
$$ B(x) = \frac{1}{L}(C(L-x) + Dx):\qquad B(0)=C,\ B(L)=D  $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x),
\tag{51}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u(0) = B(0)= C,\quad u(L) = B(L) = D $$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Boundary function; example (2)  <a name="___sec192"></a></h3>

<p>
Dirichlet condition: \( u(L)=D \). Choose for example

<p>
<p>&nbsp;<br>
$$ B(x) = D:\qquad B(L)=D  $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x),
\tag{51}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u(L) = B(L) = D $$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Impact of the boundary function on the space where we seek the solution  <a name="___sec193"></a></h3>

<p>

<ul>
 <p><li> \( \sequencei{\baspsi} \) is a basis for \( V \)</li>
 <p><li> \( \sum_{j\in\If}c_j\baspsi_j(x)\in V \)</li>
 <p><li> But \( u\not\in V \)!</li>
 <p><li> Reason: say \( u(0)=C \) and \( u\in V \) (any \( v\in V \) has \( v(0)=C \), then
   \( 2u\not\in V \) because \( 2u(0)=2C \)</li>
 <p><li> When \( u(x) = B(x) + \sum_{j\in\If}c_j\baspsi_j(x) \), \( B \neq 0 \),
   \( B\not\in V \) (in general) and
   \( u\not\in V \), but \( (u-B)\in V \) since \( \sum_{j}c_j\baspsi_j\in V \)</li>
</ul>
<p>


</section>


<section>

<h3>Abstract notation for variational formulations <a name="fem:deq:1D:varform:abstract"></a></h3>

<p>
The finite element literature (and much FEniCS documentation)
applies an abstract notation for the variational formulation:

<p>
<div class="alert alert-block alert-block alert-text-normal"><b></b>
Find \( (u-B)\in V \) such that

<p>
<p>&nbsp;<br>
$$ a(u,v) = L(v)\quad \forall v\in V $$
<p>&nbsp;<br>
</div>


<p>

</section>


<section>

<h3>Example on abstract notation  <a name="___sec195"></a></h3>

<p>
<p>&nbsp;<br>
$$ -u''=f, \quad u'(0)=C,\ u(L)=D,\quad u=D + \sum_jc_j\baspsi_j$$
<p>&nbsp;<br>


<p>
Variational formulation:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} u' v'dx = \int_{\Omega} fvdx\quad - v(0)C
\hbox{or}\quad (u',v') = (f,v) - v(0)C
\quad\forall v\in V
$$
<p>&nbsp;<br>


<p>
Abstract formulation: finn \( (u-B)\in V \) such that

<p>
<p>&nbsp;<br>
$$ a(u,v) = L(v)\quad \forall v\in V$$
<p>&nbsp;<br>


<p>
We identify

<p>
<p>&nbsp;<br>
$$ a(u,v) = (u',v'),\quad L(v) = (f,v) -v(0)C  $$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Bilinear and linear forms  <a name="___sec196"></a></h3>

<p>

<ul>
 <p><li> \( a(u,v) \) is a <em>bilinear form</em></li>
 <p><li> \( L(v) \) is a <em>linear form</em></li>
</ul>
<p>

Linear form means

<p>
<p>&nbsp;<br>
$$ L(\alpha_1 v_1 + \alpha_2 v_2)
=\alpha_1 L(v_1) + \alpha_2 L(v_2),
$$
<p>&nbsp;<br>


<p>
Bilinear form means
<p>&nbsp;<br>
$$
\begin{align*}
a(\alpha_1 u_1 + \alpha_2 u_2, v) &= \alpha_1 a(u_1,v) + \alpha_2 a(u_2, v),
\\ 
a(u, \alpha_1 v_1 + \alpha_2 v_2) &= \alpha_1 a(u,v_1) + \alpha_2 a(u, v_2)
\end{align*}
$$
<p>&nbsp;<br>


<p>
In nonlinear problems: Find \( (u-B)\in V \) such that \( F(u;v)=0\ \forall v\in V \)

<p>

</section>


<section>

<h3>The linear system associated with abstract form  <a name="___sec197"></a></h3>

<p>
<p>&nbsp;<br>
$$ a(u,v) = L(v)\quad \forall v\in V\quad\Leftrightarrow\quad
a(u,\baspsi_i) = L(\baspsi_i)\quad i\in\If$$
<p>&nbsp;<br>


<p>
We can now derive the corresponding linear system once and for all:

<p>
<p>&nbsp;<br>
$$  a(\sum_{j\in\If} c_j \baspsi_j,\baspsi_i)c_j = L(\baspsi_i)\quad i\in\If$$
<p>&nbsp;<br>


<p>
Because of linearity,

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} \underbrace{a(\baspsi_j,\baspsi_i)}_{A_{i,j}}c_j =
\underbrace{L(\baspsi_i)}_{b_i}\quad i\in\If$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-block alert-text-normal"><b></b>
Given \( a(u,v) \) and \( L(v) \) in a problem, we can immediately generate
the linear system:

<p>
<p>&nbsp;<br>
$$ A_{i,j} = a(\baspsi_j,\baspsi_i),\quad
b_i = L(\baspsi_i) $$
<p>&nbsp;<br>
</div>


<p>

</section>


<section>

<h3>Equivalence with minimization problem  <a name="___sec198"></a></h3>

<p>
If \( a(u,v)=a(v,u) \),

<p>
<p>&nbsp;<br>
$$ a(u,v)=L(v)\quad\forall v\in V,$$
<p>&nbsp;<br>


<p>
is equivalent to minimizing the functional

<p>
<p>&nbsp;<br>
$$ F(v) = {\half}a(v,v) - L(v) $$
<p>&nbsp;<br>

over all functions \( v\in V \). That is,

<p>
<p>&nbsp;<br>
$$ F(u)\leq F(v)\quad \forall v\in V\tp $$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Much used in the early days of finite elements</li>
 <p><li> Still much used in structural analysis and elasticity</li>
 <p><li> Not as general as Galerkin's method (since \( a(u,v)=a(v,u) \))</li>
</ul>
<p>


</section>


<section>

<h2>Examples on variational formulations <a name="fem:deq:1D:varform:ex"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b>Goal.</b>
Derive variational formulations for many prototype differential
equations in 1D that include

<p>

<ul>
 <p><li> variable coefficients</li>
 <p><li> mixed Dirichlet and Neumann conditions</li>
 <p><li> nonlinear coefficients</li>
</ul>
<p>
</div>


<p>

</section>


<section>

<h3>Variable coefficient; problem  <a name="___sec200"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u(L)=D
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Variable coefficient \( \dfc(x) \)</li>
 <p><li> <em>Nonzero</em> Dirichlet conditions at \( x=0 \) <em>and</em> \( x=L \)</li>
 <p><li> Must have \( \baspsi_i(0)=\baspsi_i(L)=0 \)</li>
 <p><li> \( V = \hbox{span}\{\baspsi_0,\ldots,\baspsi_N\} \)</li>
 <p><li> \( v\in V \): \( v(0)=v(L)=0 \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_i(x)
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ B(x) = C + \frac{1}{L}(D-C)x$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Variable coefficient; variational formulation (1)  <a name="___sec201"></a></h3>

<p>
<p>&nbsp;<br>
$$ R = -\frac{d}{dx}\left( a\frac{du}{dx}\right) -f $$
<p>&nbsp;<br>


<p>
Galerkin's method:

<p>
<p>&nbsp;<br>
$$
(R, v) = 0,\quad \forall v\in V,
$$
<p>&nbsp;<br>


<p>
or with integrals:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} \left(\frac{d}{dx}\left( \dfc\frac{du}{dx}\right) -f\right)v \dx = 0,\quad \forall v\in V \tp
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Variable coefficient; variational formulation (2)  <a name="___sec202"></a></h3>

<p>
Integration by parts:

<p>
<p>&nbsp;<br>
$$ -\int_{\Omega} \frac{d}{dx}\left( \dfc(x)\frac{du}{dx}\right) v \dx
= \int_{\Omega} \dfc(x)\frac{du}{dx}\frac{dv}{dx}\dx -
\left[\dfc\frac{du}{dx}v\right]_0^L
\tp
$$
<p>&nbsp;<br>


<p>
Boundary terms vanish since \( v(0)=v(L)=0 \)

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Variational formulation.</b>

<p>
Find \( (u-B)\in V \) such that

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} \dfc(x)\frac{du}{dx}\frac{dv}{dx}dx = \int_{\Omega} f(x)vdx,\quad
\forall v\in V,
$$
<p>&nbsp;<br>


<p>
Compact notation:

<p>
<p>&nbsp;<br>
$$ \underbrace{(\dfc u',v')}_{a(u,v)} = \underbrace{(f,v)}_{L(v)},
\quad \forall v\in V $$
<p>&nbsp;<br>
</div>


<p>

</section>


<section>

<h3>Variable coefficient; linear system (the easy way)  <a name="___sec203"></a></h3>

<p>
With

<p>
<p>&nbsp;<br>
$$ a(u,v) = (\dfc u', v),\quad L(v) = (f,v) $$
<p>&nbsp;<br>


<p>
we can just use the formula for the linear system:

<p>
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,j} &= a(\baspsi_j,\baspsi_i) = (\dfc \baspsi_j', \baspsi_i')
= \int_\Omega \dfc \baspsi_j' \baspsi_i'\dx =
\int_\Omega \baspsi_i' \dfc \baspsi_j'\dx = a(\baspsi_i,\baspsi_j) = A_{j,i}\\ 
b_i &= (f,\baspsi_i) = \int_\Omega f\baspsi_i\dx
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Variable coefficient; linear system (full derivation)  <a name="___sec204"></a></h3>

<p>
\( v=\baspsi_i \) and \( u=B + \sum_jc_j\baspsi_j \):

<p>
<p>&nbsp;<br>
$$
(\dfc B' + \dfc \sum_{j\in\If} c_j \baspsi_j', \baspsi_i') =
(f,\baspsi_i), \quad i\in\If \tp
$$
<p>&nbsp;<br>


<p>
Reorder to form linear system:

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} (\dfc\baspsi_j', \baspsi_i')c_j  =
(f,\baspsi_i) + (a(D-C)L^{-1}, \baspsi_i'), \quad i\in\If
\tp
$$
<p>&nbsp;<br>


<p>
This is \( \sum_j A_{i,j}c_j=b_i \) with

<p>
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,j} &= (a\baspsi_j', \baspsi_i') = \int_{\Omega} \dfc(x)\baspsi_j'(x)
\baspsi_i'(x)\dx\\ 
b_i &= (f,\baspsi_i) + (a(D-C)L^{-1},\baspsi_i')=
\int_{\Omega} \left(f(x)\baspsi_i(x) + \dfc(x)\frac{D-C}{L}\baspsi_i'(x)\right) \dx
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>First-order derivative in the equation and boundary condition; problem  <a name="___sec205"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u'(L)=E
\end{equation}
$$
<p>&nbsp;<br>


<p>
New features:

<p>

<ul>
 <p><li> first-order derivative \( u' \) in the equation</li>
 <p><li> boundary condition with \( u' \): \( u'(L)=E \)</li>
</ul>
<p>

Initial steps:

<p>

<ul>
 <p><li> Must force \( \baspsi_i(0)=0 \) because of Dirichlet condition at \( x=0 \)</li>
 <p><li> Boundary function: \( B(x)=C(L-x) \) or just \( B(x)=C \)</li>
 <p><li> No requirements on \( \baspsi_i(L) \) (no Dirichlet condition at \( x=L \))</li>
</ul>
<p>


</section>


<section>

<h3>First-order derivative in the equation and boundary condition; details  <a name="___sec206"></a></h3>

<p>
<p>&nbsp;<br>
$$ u = C + \sum_{j\in\If} c_j \baspsi_i(x)$$
<p>&nbsp;<br>


<p>
Galerkin's method: multiply by \( v \), integrate over \( \Omega \), integrate
by parts.

<p>
<p>&nbsp;<br>
$$  (-u'' + bu' - f, v) = 0,\quad\forall v\in V$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ (u',v') + (bu',v) = (f,v) + [u' v]_0^L, \quad\forall v\in V$$
<p>&nbsp;<br>


<p>
Now, \( [u' v]_0^L = u'(L)v(L) = E v(L) \) because \( v(0)=0 \) and \( u'(L)=E \):

<p>
<p>&nbsp;<br>
$$ (u'v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>First-order derivative in the equation and boundary condition; observations  <a name="___sec207"></a></h3>

<p>
<p>&nbsp;<br>
$$ (u'v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V,$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
  <p><li> The boundary term can be used to implement Neumann conditions</li>
  <p><li> Forgetting the boundary term implies the condition \( u'=0 \) (!)</li>
  <p><li> Such conditions are called <em>natural boundary conditions</em></li>
</ul>
<p>


</section>


<section>

<h3>First-order derivative in the equation and boundary condition; abstract notation  <a name="___sec208"></a></h3>

<p>
Abstract notation:

<p>
<p>&nbsp;<br>
$$ a(u,v)=L(v)\quad\forall v\in V$$
<p>&nbsp;<br>


<p>
Here:

<p>
<p>&nbsp;<br>
$$
\begin{align*}
a(u,v)&=(u',v') + (bu',v)\\ 
L(v)&= (f,v) + E v(L)
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>First-order derivative in the equation and boundary condition; linear system  <a name="___sec209"></a></h3>

<p>
Insert \( u=C+\sum_jc_j\baspsi_j \) and \( v=\baspsi_i \):

<p>
<p>&nbsp;<br>
$$
\sum_{j\in\If}
\underbrace{((\baspsi_j',\baspsi_i') + (b\baspsi_j',\baspsi_i))}_{A_{i,j}}
c_j =
\underbrace{(f,\baspsi_i) + E \baspsi_i(L)}_{b_i}
$$
<p>&nbsp;<br>


<p>
Observation: \( A_{i,j} \) is not symmetric because of the term

<p>
<p>&nbsp;<br>
$$
(b\baspsi_j',\baspsi_i)=\int_{\Omega} b\baspsi_j'\baspsi_i dx
 \neq \int_{\Omega} b \baspsi_i' \baspsi_jdx = (\baspsi_i',b\baspsi_j)
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Terminology: natural and essential boundary conditions  <a name="___sec210"></a></h3>

<p>
<p>&nbsp;<br>
$$ (u',v') + (bu',v) = (f,v) + u'(L)v(L) - u'(0)v(0)$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Note: forgetting the boundary terms implies \( u'(L)=u'(0)=0 \)
   (unless prescribe a Dirichlet condition)</li>
 <p><li> Conditions on \( u' \) are simply inserted in the variational form
   and called <em>natural conditions</em></li>
 <p><li> Conditions on \( u \) at \( x=0 \) requires modifying \( V \) (through \( \baspsi_i(0)=0 \))
   and are known as <em>essential conditions</em></li>
</ul>
<p>

<div class="alert alert-block alert-notice alert-text-normal"><b>Lesson learned.</b>
It is easy to forget the boundary term when integrating by parts.
That mistake may prescribe a condition on \( u' \)!
</div>


<p>

</section>


<section>

<h3>Nonlinear coefficient; problem  <a name="___sec211"></a></h3>

<p>
Problem:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-(\dfc(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( V \): basis \( \sequencei{\baspsi} \) with \( \baspsi_i(0)=0 \) because of \( u(0)=0 \)</li>
 <p><li> How does the nonlinear coefficients \( \dfc(u) \) and \( f(u) \)
   impact the variational formulation?</li>
 <p><li> (Not much!)</li>
</ul>
<p>


</section>


<section>

<h3>Nonlinear coefficient; variational formulation  <a name="___sec212"></a></h3>

<p>
Galerkin: multiply by \( v \), integrate, integrate by parts

<p>
<p>&nbsp;<br>
$$ \int_0^L \dfc(u)\frac{du}{dx}\frac{dv}{dx}\dx =
\int_0^L f(u)v\dx + [\dfc(u)vu']_0^L\quad\forall v\in V
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \dfc(u(0))v(0)u'(0)=0 \) since \( v(0) \)</li>
 <p><li> \( \dfc(u(L))v(L)u'(L) = \dfc(u(L))v(L)E \) since \( u'(L)=E \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$ \int_0^L \dfc(u)\frac{du}{dx}\frac{dv}{dx}v\dx =
\int_0^L f(u)v\dx + \dfc(u(L))v(L)E\quad\forall v\in V
$$
<p>&nbsp;<br>


<p>
or

<p>
<p>&nbsp;<br>
$$ (\dfc(u)u', v') = (f(u),v) + \dfc(u(L))v(L)E\quad\forall v\in V
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Nonlinear coefficient; where does the nonlinearity cause challenges?  <a name="___sec213"></a></h3>

<p>

<ul>
 <p><li> Abstract notation: no \( a(u,v) \) and \( L(v) \) because \( a \) and \( L \) are nonlinear</li>
 <p><li> Instead: \( F(u;v)=0\ \forall v\in V \)</li>
 <p><li> What about forming a linear system? We get a <em>nonlinear</em> system of
   algebraic equations</li>
 <p><li> Must use methods like Picard iteration or Newton's method to solve
   nonlinear algebraic equations</li>
 <p><li> But: the variational formulation was not much affected by nonlinearities</li>
</ul>
<p>


</section>


<section>

<h3>Computing with Dirichlet and Neumann conditions; problem  <a name="___sec214"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
-u''(x)=f(x),\quad x\in \Omega=[0,1],\quad u'(0)=C,\ u(1)=D
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Use a <em>global</em> polynomial basis \( \baspsi_i\sim x^i \) on \( [0,1] \)</li>
 <p><li> Because of \( u(1)=D \): \( \baspsi_i(1)=0 \)</li>
 <p><li> Basis: \( \baspsi_i(x)=(1-x)^{i+1} \), \( i\in\If \)</li>
 <p><li> \( B(x)=Dx \)</li>
</ul>
<p>


</section>


<section>

<h3>Computing with Dirichlet and Neumann conditions; details  <a name="___sec215"></a></h3>

<p>
<p>&nbsp;<br>
$$ A_{i,j} = (\baspsi_j',\baspsi_i') = \int_{0}^1 \baspsi_i'(x)\baspsi_j'(x)dx
= \int_0^1 (i+1)(j+1)(1-x)^{i+j} dx,
$$
<p>&nbsp;<br>


<p>
Choose \( f(x)=2 \):

<p>
<p>&nbsp;<br>
$$
\begin{align*}
b_i &= (2,\baspsi_i) - (D,\baspsi_i') -C\baspsi_i(0)\\ 
&= \int_0^1 \left( 2(1-x)^{i+1} - D(i+1)(1-x)^i\right)dx  -C\baspsi_i(0)
\end{align*}
$$
<p>&nbsp;<br>


<p>
Can easily do the integrals with <code>sympy</code>. \( N=1 \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\left(\begin{array}{cc}
1 & 1\\ 
1 & 4/3
\end{array}\right)
\left(\begin{array}{c}
c_0\\ 
c_1
\end{array}\right)
=
\left(\begin{array}{c}
-C+D+1\\ 
2/3 -C + D
\end{array}\right)
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ c_0=-C+D+2, \quad c_1=-1,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u(x) = 1 -x^2 + D + C(x-1)\quad\hbox{(exact solution)} $$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>When the numerical method is exact  <a name="___sec216"></a></h3>

<p>
Assume that apart from boundary conditions,
\( \uex \) lies in the same space \( V \) as where we seek \( u \):

<p>
<p>&nbsp;<br>
$$
\begin{align*}
u &= B + F,\quad F\in V
a(B+F, v) &= L(v)\quad\forall v\in V
\uex & = B + E,\quad E\in V
a(B+E, v) &= L(v)\quad\forall v\in V
\end{align*}
$$
<p>&nbsp;<br>


<p>
Subtract: \( a(F-E,v)=0\ \Rightarrow\ E=F \) and \( u = \uex \)

<p>

</section>


<section>

<h2>Computing with finite elements <a name="fem:deq:1D:fem1"></a></h2>

<p>
Tasks:

<p>

<ul>
 <p><li> Address the model problem \( -u''(x)=2 \), \( u(0)=u(L)=0 \)</li>
 <p><li> Uniform finite element mesh with P1 elements</li>
 <p><li> Show all finite element computations in detail</li>
</ul>
<p>


</section>


<section>

<h3>Variational formulation, finite element mesh, and basis  <a name="___sec218"></a></h3>

<p>
<p>&nbsp;<br>
$$ -u''(x) = 2,\quad x\in (0,L),\ u(0)=u(L)=0,$$
<p>&nbsp;<br>


<p>
Variational formulation:

<p>
<p>&nbsp;<br>
$$ (u',v') = (2,v)\quad\forall v\in V  $$
<p>&nbsp;<br>


<p>
Since \( u(0)=0 \) and \( u(L)=0 \), we must force

<p>
<p>&nbsp;<br>
$$ v(0)=v(L)=0,\quad \baspsi_i(0)=\baspsi_i(L)=0$$
<p>&nbsp;<br>


<p>
Use finite element basis, but exclude \( \basphi_0 \) and \( \basphi_{N_n} \)
since these are not 0 on the boundary:

<p>
<p>&nbsp;<br>
$$ \baspsi_i=\basphi_{i+1},\quad i=0,\ldots,N=N_n-2$$
<p>&nbsp;<br>


<p>
Introduce index mapping \( \nu(j) \): \( \baspsi_i = \basphi_{\nu(i)} \)

<p>
<p>&nbsp;<br>
$$ u = \sum_{j\in\If}c_j\basphi_{\nu(i)},\quad i=0,\ldots,N,\quad \nu(j) = j+1$$
<p>&nbsp;<br>


<p>
Irregular numbering: more complicated \( \nu(j) \) table

<p>

</section>


<section>

<h3>Computation in the global physical domain; formulas  <a name="___sec219"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i,j}=\int_0^L\basphi_{i+1}'(x)\basphi_{j+1}'(x) dx,\quad
b_i=\int_0^L2\basphi_{i+1}(x) dx
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Many will prefer to change indices to obtain a
\( \basphi_i'\basphi_j' \) product: \( i+1\rightarrow i \), \( j+1\rightarrow j \)

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i-1,j-1}=\int_0^L\basphi_{i}'(x)\basphi_{j}'(x) \dx,\quad
b_{i-1}=\int_0^L2\basphi_{i}(x) \dx
\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Computation in the global physical domain; details  <a name="___sec220"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_dphi_2_3.png" align="bottom" width=400></p></center>

<p>
<p>&nbsp;<br>
$$ \basphi_i = \pm h^{-1} $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ A_{i-1,i-1} = h^{-2}2h = 2h^{-1},\quad
A_{i-1,i-2} = h^{-1}(-h^{-1})h = -h^{-1},\quad A_{i-1,i}=A_{i-1,i-2}$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ b_{i-1} = 2({\half}h + {\half}h) = 2h$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Computation in the global physical domain; linear system  <a name="___sec221"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
2 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 2
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
2h \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
2h
\end{array}
\right)
\tag{53}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Comparison with a finite difference discretization  <a name="___sec222"></a></h3>

<p>

<ul>
 <p><li> Recall: \( c_i = u(\xno{i+1})\equiv u_{i+1} \)</li>
 <p><li> Write out a general equation at node \( i-1 \), expressed by \( u_i \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
-\frac{1}{h}u_{i-1} + \frac{2}{h}u_{i} - \frac{1}{h}u_{i+1} = 2h
\tag{54}
\end{equation}
$$
<p>&nbsp;<br>


<p>
The standard finite difference method for \( -u''=2 \) is

<p>
<p>&nbsp;<br>
$$ -\frac{1}{h^2}u_{i-1} + \frac{2}{h^2}u_{i} - \frac{1}{h^2}u_{i+1} = 2 $$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-block alert-text-normal"><b></b>
The finite element method and the finite difference method are
identical <em>in this example</em>.
</div>


<p>
(Remains to study the equations involving boundary values)

<p>

</section>


<section>

<h3>Cellwise computations; formulas <a name="fem:deq:1D:comp:elmwise"></a></h3>

<p>

<ul>
 <p><li> Repeat the previous example, but apply the cellwise algorithm</li>
 <p><li> Work with one cell at a time</li>
 <p><li> Transform physical cell to reference cell \( X\in [-1,1] \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
A_{i-1,j-1}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) \dx
= \int_{-1}^1 \frac{d}{dx}\refphi_r(X)\frac{d}{dx}\refphi_s(X)
\frac{h}{2} \dX,
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ \refphi_0(X)=\half(1-X),\quad\refphi_1(X)=\half(1+X)$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ \frac{d\refphi_0}{dX} = -\half,\quad  \frac{d\refphi_1}{dX} = \half $$
<p>&nbsp;<br>


<p>
From the chain rule

<p>
<p>&nbsp;<br>
$$ \frac{d\refphi_r}{dx} = \frac{d\refphi_r}{dX}\frac{dX}{dx}
= \frac{2}{h}\frac{d\refphi_r}{dX}$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Cellwise computations; details  <a name="___sec224"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i-1,j-1}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) \dx
= \int_{-1}^1 \frac{2}{h}\frac{d\refphi_r}{dX}\frac{2}{h}\frac{d\refphi_s}{dX}
\frac{h}{2} \dX = \tilde A_{r,s}^{(e)}
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
b_{i-1}^{(e)} = \int_{\Omega^{(e)}} 2\basphi_i(x) \dx =
\int_{-1}^12\refphi_r(X)\frac{h}{2} \dX = \tilde b_{r}^{(e)},
\quad i=q(e,r),\ r=0,1
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Must run through all \( r,s=0,1 \) and \( r=0,1 \) and compute each entry in
the element matrix and vector:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1\\ 
1
\end{array}\right)\tp
\tag{55}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Example:

<p>
<p>&nbsp;<br>
$$ \tilde A^{(e)}_{0,1} =
\int_{-1}^1 \frac{2}{h}\frac{d\refphi_0}{dX}\frac{2}{h}\frac{d\refphi_1}{dX}
\frac{h}{2} \dX
= \frac{2}{h}(-\half)\frac{2}{h}\half\frac{h}{2} \int_{-1}^1\dX
= -\frac{1}{h}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Cellwise computations; details of boundary cells  <a name="___sec225"></a></h3>

<p>

<ul>
 <p><li> The boundary cells involve only one unknown</li>
 <p><li> \( \Omega^{(0)} \): left node value known,
   only a contribution from right node</li>
 <p><li> \( \Omega^{(N_e)} \): right node value known,
   only a contribution from left node</li>
</ul>
<p>

For \( e=0 \) and \( =N_e \):

<p>
<p>&nbsp;<br>
$$
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{r}
1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1
\end{array}\right)
$$
<p>&nbsp;<br>


<p>
Only one degree of freedom ("node") in these cells (\( r=0 \) counts the only dof)

<p>

</section>


<section>

<h3>Cellwise computations; assembly  <a name="___sec226"></a></h3>

<p>
4 P1 elements:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">vertices</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">0.5</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1.5</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">]</span>
<span style="color: #d0d0d0">cells</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">3</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">3</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">4</span><span style="color: #d0d0d0">]]</span>
<span style="color: #d0d0d0">dof_map</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">[[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">1</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">,</span> <span style="color: #3677a9">2</span><span style="color: #d0d0d0">],</span> <span style="color: #d0d0d0">[</span><span style="color: #3677a9">2</span><span style="color: #d0d0d0">]]</span>       <span style="color: #999999; font-style: italic"># only 1 dof in elm 0, 3</span>
</pre></div>
<p>
Python code for the assembly algorithm:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #999999; font-style: italic"># Ae[e][r,s]: element matrix, be[e][r]: element vector</span>
<span style="color: #999999; font-style: italic"># A[i,j]: coefficient matrix, b[i]: right-hand side</span>

<span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">e</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(Ae)):</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(Ae[e].shape[</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]):</span>
        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">s</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(Ae[e].shape[</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]):</span>
            <span style="color: #d0d0d0">A[dof_map[e,r],dof_map[e,s]]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">Ae[e][i,j]</span>
        <span style="color: #d0d0d0">b[dof_map[e,r]]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">be[e][i,j]</span>
</pre></div>
<p>
Result: same linear system as arose from computations in the physical domain

<p>

</section>


<section>

<h3>General construction of a boundary function <a name="fem:deq:1D:essBC:Bfunc"></a></h3>

<p>

<ul>
  <p><li> Now we address nonzero Dirichlet conditions</li>
  <p><li> \( B(x) \) is not always easy to construct (extend to the interior of \( \Omega \)),
    especially not in 2D and 3D</li>
  <p><li> With finite element \( \basphi_i \), \( B(x) \) can be constructed in
    a completely general way</li>
  <p><li> \( \Ifb \): set of indices with nodes where \( u \) is known</li>
  <p><li> \( U_i \): Dirichlet value of \( u \) at node \( i \), \( i\in\Ifb \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
B(x) = \sum_{j\in\Ifb} U_j\basphi_j(x)
\end{equation}
$$
<p>&nbsp;<br>


<p>
Suppose we have a Dirichlet condition \( u(\xno{k})=U_k \), \( k\in\Ifb \):

<p>
<p>&nbsp;<br>
$$
u(\xno{k}) = \sum_{j\in\Ifb} U_j\underbrace{\basphi_j(x)}_{\neq 0
\hbox{ only for }j=k} +
\sum_{j\in\If} c_j\underbrace{\basphi_{\nu(j)}(\xno{k})}_{=0,\ k\not\in\If}
= U_k $$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example with two Dirichlet values; variational formulation  <a name="___sec228"></a></h3>

<p>
<p>&nbsp;<br>
$$ -u''=2, \quad u(0)=C,\ u(L)=D  $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ \int_0^L u'v'\dx = \int_0^L2v\dx\quad\forall v\in V$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ (u',v') = (2,v)\quad\forall v\in V$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example with two Dirichlet values; boundary function  <a name="___sec229"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
B(x) = \sum_{j\in\Ifb} U_j\basphi_j(x)
\end{equation}
$$
<p>&nbsp;<br>


<p>
Here \( \Ifb = \{0,N_n\} \), \( U_0=C \), \( U_{N_n}=D \),

<p>
<p>&nbsp;<br>
$$ \baspsi_i = \basphi_{\nu(i)}, \quad \nu(i)=i+1,\quad i\in\If =
\{0,\ldots,N=N_n-2\} $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = C\basphi_0(x) + D\basphi_{N_n}(x)
+ \sum_{j\in\If}c_j\basphi_{\nu(j)}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example with two Dirichlet values; details  <a name="___sec230"></a></h3>

<p>
Insert \( u = B + \sum_j c_j\baspsi_j \) in variational formulation:

<p>
<p>&nbsp;<br>
$$ (u',v') = (2,v)\quad\Rightarrow\quad (\sum_jc_j\baspsi_j',\baspsi_i')
= (2-B',\baspsi_i)\quad \forall v\in V$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align*}
u(x) &= \underbrace{C\cdot\basphi_0 + D\basphi_{N_n}}_{B(x)}
+ \sum_{j\in\If} c_j\basphi_{j+1}\\ 
&= C\cdot\basphi_0 + D\basphi_{N_n} + c_0\basphi_1 + c_1\basphi_2 +\cdots
+ c_N\basphi_{N_n-1}
\end{align*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
A_{i-1,j-1} = \int_0^L \basphi_i'(x)\basphi_j'(x) \dx,\quad
b_{i-1} = \int_0^L (f(x) - C\basphi_{0}'(x) - D\basphi_{N_n}'(x))
\basphi_i(x) \dx
$$
<p>&nbsp;<br>

for \( i,j = 1,\ldots,N+1=N_n-1 \).

<p>
New boundary terms from \( -\int B'\basphi_i\dx \): \( C/2 \) for \( i=1 \)
and \( -D/2 \) for \( i=N_n-1 \)

<p>

</section>


<section>

<h3>Example with two Dirichlet values; cellwise computations  <a name="___sec231"></a></h3>

<p>

<ul>
 <p><li> Element matrices as in the previous example (with \( u=0 \) on the boundary)</li>
 <p><li> New element vector in the first and last cell</li>
</ul>
<p>

From the last cell:

<p>
<p>&nbsp;<br>
$$
\tilde b_0^{(N_e)} = \int_{-1}^1 \left(f - D\frac{2}{h}
\frac{d\refphi_1}{dX}\right)
\refphi_0\frac{h}{2} \dX
= (\frac{h}{2}(2 - D\frac{2}{h}\half)
\int_{-1}^1 \refphi_0 \dX =  h - D/2
$$
<p>&nbsp;<br>


<p>
From the first cell:

<p>
<p>&nbsp;<br>
$$
\tilde b_0^{(0)} = \int_{-1}^1 \left(f - C\frac{2}{h}
\frac{d\refphi_0}{dX}\right)
\refphi_1\frac{h}{2} \dX
= (\frac{h}{2}(2 + C\frac{2}{h}\half)
\int_{-1}^1 \refphi_1 \dX =  h + C/2\tp
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Modification of the linear system; ideas <a name="fem:deq:1D:fem:essBC:Bfunc:modsys"></a></h3>

<p>

<ul>
 <p><li> Method 1: incorporate Dirichlet values through a \( B(x) \) function
   and demand \( \baspsi_i=0 \) where Dirichlet values apply</li>
 <p><li> Method 2: drop \( B(x) \), drop demands to \( \baspsi_i \), just assemble
   as if there were no Dirichlet conditions, and modify the linear
   system instead</li>
</ul>
<p>

Method 2: always \( \baspsi_i = \basphi_i \) and

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \sum_{j\in\If}c_j\basphi_j(x),\quad \If=\{0,\ldots,N=N_n\}
\tag{56}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Attractive way of incorporating Dirichlet conditions.</b>
\( u \) is treated as unknown at all boundaries when computing entires
in the linear system
</div>


<p>

</section>


<section>

<h3>Modification of the linear system; original system  <a name="___sec233"></a></h3>

<p>
<p>&nbsp;<br>
$$ -u''=2,\quad u(0)=0,\ u(L)=D$$
<p>&nbsp;<br>


<p>
Assemble as if there were no Dirichlet conditions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
h \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
h
\end{array}
\right)
\tag{57}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Modification of the linear system; row replacement  <a name="___sec234"></a></h3>

<p>

<ul>
 <p><li> Dirichlet condition \( u(\xno{k})= U_k \) means \( c_k=U_k \) (since \( c_k=u(\xno{k}) \))</li>
 <p><li> Replace first row by \( c_0=0 \)</li>
 <p><li> Replace last row by \( c_N=D \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
h & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & h
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
D
\end{array}
\right)
\tag{58}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Modification of the linear system; element matrix/vector  <a name="___sec235"></a></h3>

<p>
In cell 0 we know \( u \) for local node (degree of freedom) \( r=0 \).
Replace the first cell equation by \( \tilde c_0 = 0 \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(0)} =
A = \frac{1}{h}\left(\begin{array}{rr}
h & 0\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(0)} = \left(\begin{array}{c}
0\\ 
h
\end{array}\right)
\tag{59}
\end{equation}
$$
<p>&nbsp;<br>


<p>
In cell \( N_e \) we know \( u \) for local node \( r=1 \). Replace the last
equation in the cell system by \( \tilde c_1=D \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(N_e)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
0 & h
\end{array}\right),\quad
\tilde b^{(N_e)} = \left(\begin{array}{c}
h\\ 
D
\end{array}\right)
\tag{60}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Symmetric modification of the linear system; algorithm  <a name="___sec236"></a></h3>

<p>

<ul>
 <p><li> The modification above destroys symmetry of the matrix:
   e.g., \( A_{0,1}\neq A_{1,0} \)</li>
 <p><li> Symmetry is often important in 2D and 3D (faster computations)</li>
 <p><li> A more complex modification can preserve symmetry!</li>
</ul>
<p>

Algorithm for incorporating \( c_i=U_i \) in a symmetric way:

<p>

<ol>
<p><li> Subtract column \( i \) times \( U_i \) from the right-hand side</li>
<p><li> Zero out column and row no \( i \)</li>
<p><li> Place 1 on the diagonal</li>
<p><li> Set \( b_i=U_i \)</li>
</ol>
<p>


</section>


<section>

<h3>Symmetric modification of the linear system; example  <a name="___sec237"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
0 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & 0 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h +D/h\\ 
D
\end{array}
\right)
\tag{61}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Symmetric modification of the linear system; element level  <a name="___sec238"></a></h3>

<p>
Symmetric modification applied to \( \tilde A^{(N_e)} \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(N_e)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 0\\ 
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h + D/h\\ 
D
\end{array}\right)
\tag{62}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Boundary conditions: specified derivative <a name="fem:deq:1D:BC:nat"></a></h3>

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Neumann conditions.</b>
How can we incorporate \( u'(0)=C \) with finite elements?
</div>


<p>
<p>&nbsp;<br>
$$ -u''=f,\quad u'(0)=C,\ u(L)=D$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \baspsi_i(L)=0 \) because of Dirichlet condition \( u(L)=D \)</li>
 <p><li> No demand to \( \baspsi_i(0) \)</li>
</ul>
<p>


</section>


<section>

<h3>The variational formulation  <a name="___sec240"></a></h3>

<p>
Galerkin's method:

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\int_0^L(u''(x)+f(x))\baspsi_i(x) dx = 0,\quad i\in\If
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Integration of \( u''\baspsi_i \) by parts:

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\int_0^Lu'(x)\baspsi_i'(x) \dx -(u'(L)\baspsi_i(L) - u'(0)\baspsi_i(0)) -
\int_0^L f(x)\baspsi_i(x) \dx =0, \quad i\in\If
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( u'(L){\baspsi_i(L)}=0 \) since \( \baspsi_i(L)=0 \)</li>
 <p><li> \( u'(0)\baspsi_i(0) = C\baspsi_i(0) \) since \( u'(0)=C \)</li>
</ul>
<p>


</section>


<section>

<h3>Method 1: Boundary function and exclusion of Dirichlet degrees of freedom  <a name="___sec241"></a></h3>

<p>

<ul>
 <p><li> \( \baspsi_i = \basphi_i \), \( i\in\If =\{0,\ldots,N=N_n-1\} \)</li>
 <p><li> \( B(x)=D\basphi_{N_n}(x) \), \( u= B + \sum_{j=0}^N c_j\basphi_j \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
\int_0^Lu'(x)\basphi_i'(x) dx  =
\int_0^L f(x)\basphi_i(x) dx - C\basphi_i(0),\quad i\in\If
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j=0}^{N=N_n-1}\left(
\int_0^L \basphi_i'(x)\basphi_j'(x) dx \right)c_j =
\int_0^L\left(f(x)\basphi_i(x) -D\basphi_N'(x)\basphi_i(x)\right) dx
 - C\basphi_i(0)
\tag{63}
\end{equation}
$$
<p>&nbsp;<br>

for \( i=0,\ldots,N=N_n-1 \).

<p>

</section>


<section>

<h3>Method 2: Use all \( \basphi_i \) and insert the Dirichlet condition in the linear system  <a name="___sec242"></a></h3>

<p>

<ul>
 <p><li> Now \( \baspsi_i=\basphi_i \), \( i=0,\ldots,N=N_n \)</li>
 <p><li> \( \basphi_N(L)\neq 0 \), so \( u'(L)\basphi_N(L)\neq 0 \)</li>
 <p><li> However, the term \( u'(L)\basphi_N(L) \) in \( b_N \) <em>will be erased</em> when
   we insert the Dirichlet value in \( b_N=D \)</li>
</ul>
<p>

We can forget about the term \( u'(L)\basphi_i(L) \)!

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Result.</b>
Boundary terms \( u'\basphi_i \) at points \( \xno{i} \) where Dirichlet values apply
can always be forgotten.
</div>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
u(x) = \sum_{j=0}^{N=N_n} c_j\basphi_j(x)
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j=0}^{N=N_n}\left(
\int_0^L \basphi_i'(x)\basphi_j'(x) dx \right)c_j =
\int_0^L f(x)\basphi_i(x)\basphi_i(x) dx - C\basphi_i(0)
\tag{63}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Assemble entries for \( i=0,\ldots,N=N_n \) and then
modify the last equation to \( c_N=D \)

<p>

</section>


<section>

<h3>How the Neumann condition impacts the element matrix and vector  <a name="___sec243"></a></h3>

<p>
The extra term \( C\basphi_0(0) \) affects only the element vector from the
first cells since \( \basphi_0=0 \) on all other cells.

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(0)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(0)} = \left(\begin{array}{c}
h - C\\ 
h
\end{array}\right)
\tag{65}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h2>The finite element algorithm  <a name="___sec244"></a></h2>

<p>
The differential equation problem defines the integrals in the variational
formulation.

<p>
Request these functions from the user:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">integrand_lhs(phi,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">s,</span> <span style="color: #d0d0d0">x)</span>
<span style="color: #d0d0d0">boundary_lhs(phi,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">s,</span> <span style="color: #d0d0d0">x)</span>
<span style="color: #d0d0d0">integrand_rhs(phi,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">x)</span>
<span style="color: #d0d0d0">boundary_rhs(phi,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">x)</span>
</pre></div>
<p>
Must also have a mesh with <code>vertices</code>, <code>cells</code>, and <code>dof_map</code>

<p>

</section>


<section>

<h3>Python pseudo code; the element matrix and vector  <a name="___sec245"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #d0d0d0">&lt;Declare</span> <span style="color: #6ab825; font-weight: bold">global</span> <span style="color: #d0d0d0">matrix,</span> <span style="color: #6ab825; font-weight: bold">global</span> <span style="color: #d0d0d0">rhs:</span> <span style="color: #d0d0d0">A,</span> <span style="color: #d0d0d0">b&gt;</span>

<span style="color: #999999; font-style: italic"># Loop over all cells</span>
<span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">e</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(cells)):</span>

    <span style="color: #999999; font-style: italic"># Compute element matrix and vector</span>
    <span style="color: #d0d0d0">n</span> <span style="color: #d0d0d0">=</span> <span style="color: #24909d">len</span><span style="color: #d0d0d0">(dof_map[e])</span>  <span style="color: #999999; font-style: italic"># no of dofs in this element</span>
    <span style="color: #d0d0d0">h</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">vertices[cells[e][</span><span style="color: #3677a9">1</span><span style="color: #d0d0d0">]]</span> <span style="color: #d0d0d0">-</span> <span style="color: #d0d0d0">vertices[cells[e][</span><span style="color: #3677a9">0</span><span style="color: #d0d0d0">]]</span>
    <span style="color: #d0d0d0">&lt;Declare</span> <span style="color: #d0d0d0">element</span> <span style="color: #d0d0d0">matrix,</span> <span style="color: #d0d0d0">element</span> <span style="color: #d0d0d0">vector:</span> <span style="color: #d0d0d0">A_e,</span> <span style="color: #d0d0d0">b_e&gt;</span>

    <span style="color: #999999; font-style: italic"># Integrate over the reference cell</span>
    <span style="color: #d0d0d0">points,</span> <span style="color: #d0d0d0">weights</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">&lt;numerical</span> <span style="color: #d0d0d0">integration</span> <span style="color: #d0d0d0">rule&gt;</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">X,</span> <span style="color: #d0d0d0">w</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">zip</span><span style="color: #d0d0d0">(points,</span> <span style="color: #d0d0d0">weights):</span>
        <span style="color: #d0d0d0">phi</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">&lt;basis</span> <span style="color: #d0d0d0">functions</span> <span style="color: #d0d0d0">+</span> <span style="color: #d0d0d0">derivatives</span> <span style="color: #d0d0d0">at</span> <span style="color: #d0d0d0">X&gt;</span>
        <span style="color: #d0d0d0">detJ</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">h/</span><span style="color: #3677a9">2</span>
        <span style="color: #d0d0d0">x</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">&lt;affine</span> <span style="color: #d0d0d0">mapping</span> <span style="color: #6ab825; font-weight: bold">from</span> <span style="color: #447fcf; text-decoration: underline">X</span><span style="color: #d0d0d0">&gt;</span>
        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
            <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">s</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
                <span style="color: #d0d0d0">A_e[r,s]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">integrand_lhs(phi,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">s,</span> <span style="color: #d0d0d0">x)*detJ*w</span>
            <span style="color: #d0d0d0">b_e[r]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">integrand_rhs(phi,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">x)*detJ*w</span>

    <span style="color: #999999; font-style: italic"># Add boundary terms</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">s</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
            <span style="color: #d0d0d0">A_e[r,s]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">boundary_lhs(phi,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">s,</span> <span style="color: #d0d0d0">x)*detJ*w</span>
        <span style="color: #d0d0d0">b_e[r]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">boundary_rhs(phi,</span> <span style="color: #d0d0d0">r,</span> <span style="color: #d0d0d0">x)*detJ*w</span>
</pre></div>
<p>

</section>


<section>

<h3>Python pseudo code; boundary conditions and assembly  <a name="___sec246"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%"><span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">e</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(</span><span style="color: #24909d">len</span><span style="color: #d0d0d0">(cells)):</span>
    <span style="color: #d0d0d0">...</span>

    <span style="color: #999999; font-style: italic"># Incorporate essential boundary conditions</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
        <span style="color: #d0d0d0">global_dof</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">dof_map[e][r]</span>
        <span style="color: #6ab825; font-weight: bold">if</span> <span style="color: #d0d0d0">global_dof</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #d0d0d0">essbc_dofs:</span>
            <span style="color: #999999; font-style: italic"># dof r is subject to an essential condition</span>
            <span style="color: #d0d0d0">value</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">essbc_docs[global_dof]</span>
            <span style="color: #999999; font-style: italic"># Symmetric modification</span>
            <span style="color: #d0d0d0">b_e</span> <span style="color: #d0d0d0">-=</span> <span style="color: #d0d0d0">value*A_e[:,r]</span>
            <span style="color: #d0d0d0">A_e[r,:]</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">0</span>
            <span style="color: #d0d0d0">A_e[:,r]</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">0</span>
            <span style="color: #d0d0d0">A_e[r,r]</span> <span style="color: #d0d0d0">=</span> <span style="color: #3677a9">1</span>
            <span style="color: #d0d0d0">b_e[r]</span> <span style="color: #d0d0d0">=</span> <span style="color: #d0d0d0">value</span>

    <span style="color: #999999; font-style: italic"># Assemble</span>
    <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">r</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
        <span style="color: #6ab825; font-weight: bold">for</span> <span style="color: #d0d0d0">s</span> <span style="color: #6ab825; font-weight: bold">in</span> <span style="color: #24909d">range</span><span style="color: #d0d0d0">(n):</span>
            <span style="color: #d0d0d0">A[dof_map[e][r],</span> <span style="color: #d0d0d0">dof_map[e][r]]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">A_e[r,s]</span>
        <span style="color: #d0d0d0">b[dof_map[e][r]</span> <span style="color: #d0d0d0">+=</span> <span style="color: #d0d0d0">b_e[r]</span>

<span style="color: #d0d0d0">&lt;solve</span> <span style="color: #d0d0d0">linear</span> <span style="color: #d0d0d0">system&gt;</span>
</pre></div>
<p>

</section>


<section>

<h2>Variational formulations in 2D and 3D <a name="fem:deq:2D:varform"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b></b>
How to do integration by parts is the major difference when moving to
2D and 3D.
</div>


<p>

</section>


<section>

<h3>Integration by parts  <a name="___sec248"></a></h3>

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Rule for multi-dimensional integration by parts.</b>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\int_{\Omega} \nabla\cdot (a(\x)\nabla u) v\dx =
\int_{\Omega} a(\x)\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} a\frac{\partial u}{\partial n} v \ds
\tag{66}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \int_\Omega ()\dx \): area (2D) or volume (3D) integral</li>
 <p><li> \( \int_{\partial\Omega} ()\ds \): line(2D) or surface (3D) integral</li>
</ul>
<p>
</div>


<p>

<ul>
 <p><li> \( \partial\Omega_N \): Neumann conditions
   \( -a\frac{\partial u}{\partial n} = g \)</li>
 <p><li> \( \partial\Omega_D \): Dirichlet conditions
   \( u = u_0 \)</li>
 <p><li> \( v\in V \) must vanish on \( \partial\Omega_D \) (in method 1)</li>
</ul>
<p>


</section>


<section>

<h3>Example on integration by parts; problem  <a name="___sec249"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\v\cdot\nabla u + \alpha u &= \nabla\cdot\left( a\nabla u\right) + f,
\quad & \x\in\Omega\\ 
u &= u_0,\quad &\x\in\partial\Omega_D\\ 
-a\frac{\partial u}{\partial n} &= g,\quad &\x\in\partial\Omega_N
\end{align}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Known: \( a \), \( \alpha \), \( f \), \( u_0 \), and \( g \).</li>
 <p><li> Second-order PDE: must have <em>exactly one boundary condition at each
   point of the boundary</em></li>
</ul>
<p>

Method 1 with boundary function and \( \baspsi_i=0 \) on \( \partial\Omega_D \):

<p>
<p>&nbsp;<br>
$$ u(\x) = B(\x) + \sum_{j\in\If} c_j\baspsi_j(\x),\quad B(\x)=u_0(\x)  $$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example on integration by parts; details (1)  <a name="___sec250"></a></h3>

<p>
Galerkin's method: multiply by \( v\in V \) and integrate over \( \Omega \),

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
\int_{\Omega} \nabla\cdot\left( a\nabla u\right)\dx + \int_{\Omega}fv \dx
$$
<p>&nbsp;<br>


<p>
Integrate second-order term by parts:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} \nabla\cdot\left( a\nabla u\right) v \dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds,
$$
<p>&nbsp;<br>


<p>
Resulting variational form:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
+ \int_{\Omega} fv \dx
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Example on integration by parts; details (2)  <a name="___sec251"></a></h3>

<p>
Note: \( v\neq 0 \) only on \( \partial\Omega_N \):

<p>
<p>&nbsp;<br>
$$ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
= \int_{\partial\Omega_N} \underbrace{a\frac{\partial u}{\partial n}}_{-g} v\ds
= -\int_{\partial\Omega_N} gv\ds
$$
<p>&nbsp;<br>


<p>
The final variational form:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v \dx
- \int_{\partial\Omega_N} g v\ds
+ \int_{\Omega} fv \dx
$$
<p>&nbsp;<br>


<p>
Or with inner product notation:

<p>
<p>&nbsp;<br>
$$
(\v\cdot\nabla u, v) + (\alpha u,v) =
- (a\nabla u,\nabla v) - (g,v)_{N} + (f,v)
$$
<p>&nbsp;<br>


<p>
\( (g,v)_{N} \): line or surface integral over \( \partial\Omega_N \).

<p>

</section>


<section>

<h3>Example on integration by parts; linear system  <a name="___sec252"></a></h3>

<p>
<p>&nbsp;<br>
$$ u = B + \sum_{j\in\If} c_j\baspsi_j,\quad B = u_0  $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
A_{i,j} = (\v\cdot\nabla \baspsi_j, \baspsi_i) +
(\alpha \baspsi_j ,\baspsi_i) + (a\nabla \baspsi_j,\nabla \baspsi_i)
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
b_i = (g,\baspsi_i)_{N} + (f,\baspsi_i) -
(\v\cdot\nabla u_0, \baspsi_i) + (\alpha u_0 ,\baspsi_i) +
(a\nabla u_0,\nabla \baspsi_i)
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Transformation to a reference cell in 2D/3D (1)  <a name="___sec253"></a></h3>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b></b>
We want to compute an integral in the physical domain
by integrating over the reference cell.
</div>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{{\Omega}^{(e)}} a(\x)\nabla\basphi_i\cdot\nabla\basphi_j\dx
\end{equation}
$$
<p>&nbsp;<br>


<p>
Mapping from reference to physical coordinates:

<p>
<p>&nbsp;<br>
$$ \x(\X) $$
<p>&nbsp;<br>


<p>
with Jacobian \( J \),

<p>
<p>&nbsp;<br>
$$ J_{i,j}=\frac{\partial x_j}{\partial X_i} $$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \dx \rightarrow \det J\dX \).</li>
 <p><li> Must express \( \nabla\basphi_i \) by an expression with \( \refphi_r \), \( i=q(e,r) \): \( \nabla\refphi_r(\X) \)</li>
 <p><li> We want \( \nabla_{\x}\refphi_r(\X) \) (derivatives wrt \( \x \))</li>
 <p><li> What we readily have is \( \nabla_{\X}\refphi_r(\X) \) (derivative wrt \( \X \))</li>
 <p><li> Need to transform \( \nabla_{\X}\refphi_r(\X) \) to \( \nabla_{\x}\refphi_r(\X) \)</li>
</ul>
<p>


</section>


<section>

<h3>Transformation to a reference cell in 2D/3D (2)  <a name="___sec254"></a></h3>

<p>
Can derive

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\nabla_{\X}\refphi_r &= J\cdot\nabla_{\x}\basphi_i\\ 
\nabla_{\x}\basphi_i &= \nabla_{\x}\refphi_r(\X)
= J^{-1}\cdot\nabla_{\X}\refphi_r(\X)
\end{align*}
$$
<p>&nbsp;<br>


<p>
Integral transformation from physical to reference coordinates:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega^{(e)}} a(\x)\nabla_{\x}\basphi_i\cdot\nabla_{\x}\basphi_j\dx =
\int_{\tilde\Omega^r} a(\x(\X))(J^{-1}\cdot\nabla_{\X}\refphi_r)\cdot
(J^{-1}\cdot\nabla\refphi_s)\det J\dX
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Numerical integration  <a name="___sec255"></a></h3>

<p>
Numerical integration over reference cell triangles and tetrahedra:

<p>
<p>&nbsp;<br>
$$ \int_{\tilde\Omega^r} g\dX = \sum_{j=0}^{n-1} w_j g(\bar\X_j)$$
<p>&nbsp;<br>


<p>
Module <a href="http://tinyurl.com/jvzzcfn/fem/numint.py" target="_self"><tt>numint.py</tt></a> contains different rules:

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "native" -->
<div class="highlight" style="background: #202020"><pre style="line-height: 125%">&gt;&gt;&gt; import numint
&gt;&gt;&gt; x, w = numint.quadrature_for_triangles(num_points=3)
&gt;&gt;&gt; x
[(0.16666666666666666, 0.16666666666666666),
 (0.66666666666666666, 0.16666666666666666),
 (0.16666666666666666, 0.66666666666666666)]
&gt;&gt;&gt; w
[0.16666666666666666, 0.16666666666666666, 0.16666666666666666]
</pre></div>
<p>

<ul>
 <p><li> Triangle: rules with \( n=1,3,4,7 \) integrate exactly polynomials of degree \( 1,2,3,4 \), resp.</li>
 <p><li> Tetrahedron: rules with \( n=1,4,5,11 \) integrate exactly polynomials of degree \( 1,2,3,4 \), resp.</li>
</ul>
<p>


</section>


<section>

<h2>Time-dependent problems <a name="fem:deq:timedep"></a></h2>

<p>

<ul>
 <p><li> So far: used the finite element framework for discretizing in space</li>
 <p><li> What about \( u_t = u_{xx} + f \)?</li>

<ol>
  <p><li> Use finite differences in time to obtain a set of recursive spatial problems</li>
  <p><li> Solve the spatial problems by the finite element method</li>
</ol>
<p>

</ul>
<p>


</section>


<section>

<h3>Example: diffusion problem  <a name="___sec257"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\frac{\partial u}{\partial t} &= \dfc\nabla^2 u + f(\x, t),\quad
&\x\in\Omega, t\in (0,T]
\tag{67}\\ 
u(\x, 0) & = I(\x),\quad &\x\in\Omega
\tag{68}\\ 
\frac{\partial u}{\partial n} &= 0,\quad &\x\in\partial\Omega,\ t\in (0,T]
\tag{69}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>A Forward Euler scheme; ideas  <a name="___sec258"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[D_t^+ u = \dfc\nabla^2 u + f]^n,\quad n=1,2,\ldots,N_t-1
\end{equation}
$$
<p>&nbsp;<br>


<p>
Solving wrt \( u^{n+1} \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = u^n + \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)
\tag{70}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( u^n = \sum_jc_j^n\baspsi_j\, \in V \),
   \( u^{n+1} = \sum_jc_j^{n+1}\baspsi_j\,\in V \)</li>
 <p><li> Compute \( u^0 \) from \( I \)</li>
 <p><li> Compute \( u^{n+1} \) from \( u^n \) by solving the PDE for \( u^{n+1} \)
   at each time level</li>
</ul>
<p>


</section>


<section>

<h3>A Forward Euler scheme; stages in the discretization  <a name="___sec259"></a></h3>

<p>

<ul>
 <p><li> \( \uex(\x,t) \): exact solution of the space-and time-continuous problem</li>
 <p><li> \( \uex^n(\x) \): exact solution of time-discrete problem (after applying
   a finite difference scheme in time)</li>
 <p><li> \( \uex^n(\x)\approx u^n = \sum_{j\in\If}c_j^n\baspsi_j = \)
   solution of the time- and space-discrete problem
   (after applying a Galerkin method in space)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial \uex}{\partial t} = \dfc\nabla^2 \uex + f(\x, t)
\tag{71}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\uex^{n+1} = \uex^n + \Delta t \left( \dfc\nabla^2 \uex^n + f(\x, t_n)\right)
\tag{72}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\uex^n \approx u^n = \sum_{j=0}^{N} c_j^{n}\baspsi_j(\x),\quad
\uex^{n+1} \approx u^{n+1} = \sum_{j=0}^{N} c_j^{n+1}\baspsi_j(\x)
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ R = u^{n+1} - u^n - \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>A Forward Euler scheme; weighted residual (or Galerkin) principle  <a name="___sec260"></a></h3>

<p>
<p>&nbsp;<br>
$$ R = u^{n+1} - u^n - \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)$$
<p>&nbsp;<br>


<p>
The weighted residual principle:

<p>
<p>&nbsp;<br>
$$ \int_\Omega Rw\dx = 0,\quad \forall w\in W$$
<p>&nbsp;<br>


<p>
results in

<p>
<p>&nbsp;<br>
$$
\int_\Omega
\left\lbrack
u^{n+1} - u^n - \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)
\right\rbrack w \dx =0, \quad \forall w \in W
$$
<p>&nbsp;<br>


<p>
Galerkin: \( W=V \), \( w=v \)

<p>

</section>


<section>

<h3>A Forward Euler scheme; integration by parts  <a name="___sec261"></a></h3>

<p>
Isolating the unknown \( u^{n+1} \) on the left-hand side:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} u^{n+1}\baspsi_i\dx = \int_{\Omega}
\left\lbrack u^n - \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)
\right\rbrack v\dx
$$
<p>&nbsp;<br>


<p>
Integration by parts of \( \int\dfc(\nabla^2 u^n) v\dx \):

<p>
<p>&nbsp;<br>
$$ \int_{\Omega}\dfc(\nabla^2 u^n)v \dx =
-\int_{\Omega}\dfc\nabla u^n\cdot\nabla v\dx +
\underbrace{\int_{\partial\Omega}\dfc\frac{\partial u^n}{\partial n}v \dx}_{=0\quad\Leftarrow\quad\partial u^n/\partial n=0}
$$
<p>&nbsp;<br>


<p>
Variational form:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} u^{n+1} v\dx =
\int_{\Omega} u^n v\dx -
\Delta t \int_{\Omega}\dfc\nabla u^n\cdot\nabla v\dx +
\Delta t\int_{\Omega}f^n v\dx,\quad\forall v\in V
\tag{73}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>New notation for the solution at the most recent time levels  <a name="___sec262"></a></h3>

<p>

<ul>
 <p><li> \( u \) and <code>u</code>: the spatial unknown function to be computed</li>
 <p><li> \( u_1 \) and <code>u_1</code>: the spatial function at the previous time level \( t-\Delta t \)</li>
 <p><li> \( u_2 \) and <code>u_2</code>: the spatial function at \( t-2\Delta t \)</li>
 <p><li> This new notation gives close correspondance between code and math</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} u v\dx =
\int_{\Omega} u_1 v\dx -
\Delta t \int_{\Omega}\dfc\nabla u_1\cdot\nabla v\dx +
\Delta t\int_{\Omega}f^n v\dx
\tag{74}
\end{equation}
$$
<p>&nbsp;<br>


<p>
or shorter

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(u, \baspsi_i) = (u_1,v) -
\Delta t (\dfc\nabla u_1,\nabla v) +
(f^n, v)
\tag{75}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Deriving the linear systems  <a name="___sec263"></a></h3>

<p>

<ul>
 <p><li> \( u = \sum_{j=0}^{N}c_j\baspsi_j(\x) \)</li>
 <p><li> \( u_1 = \sum_{j=0}^{N} c_{1,j}\baspsi_j(\x) \)</li>
 <p><li> \( \forall v\in V \): for \( v=\baspsi_i \), \( i=0,\ldots,N \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$


<p>
Insert these in

<p>
$$
<p>&nbsp;<br>
(u, \baspsi_i) = (u_1,\baspsi_i) -
\Delta t (\dfc\nabla u_1,\nabla\baspsi_i) +
(f^n,\baspsi_i)
<p>&nbsp;<br>
$$


<p>
and order terms as matrix-vector products:

<p>
$$
<p>&nbsp;<br>
\begin{equation}
\sum_{j=0}^{N} \underbrace{(\baspsi_i,\baspsi_j)}_{M_{i,j}} c_j =
\sum_{j=0}^{N} \underbrace{(\baspsi_i,\baspsi_j)}_{M_{i,j}} c_{1,j}
-\Delta t \sum_{j=0}^{N}
\underbrace{(\nabla\baspsi_i,\dfc\nabla\baspsi_j)}_{K_{i,j}} c_{1,j}
+ (f^n,\baspsi_i),\quad i=0,\ldots,N
\end{equation}
$$


<p>

</section>


<section>

<h3>Structure of the linear systems  <a name="___sec264"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
Mc = Mc_1 - \Delta t Kc_1 + f
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align*}
M &= \{M_{i,j}\},\quad M_{i,j}=(\baspsi_i,\baspsi_j),\quad i,j\in\If\\ 
K &= \{K_{i,j}\},\quad K_{i,j}=(\nabla\baspsi_i,\dfc\nabla\baspsi_j),\quad i,j\in\If\\ 
f &= \{(f(\x,t_n),\baspsi_i)\}_{i\in\If}\\ 
c &= \{c_i\}_{i\in\If}\\ 
c_1 &= \{c_{1,i}\}_{i\in\If}
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Computational algorithm  <a name="___sec265"></a></h3>

<p>

<ol>
<p><li> Compute \( M \) and \( K \).</li>
<p><li> Initialize \( u^0 \) by either interpolation or projection</li>
<p><li> For \( n=1,2,\ldots,N_t \):</li>

<ol>
  <p><li> compute \( b = Mc_1 - \Delta t Kc_1 + f \)</li>
  <p><li> solve \( Mc = b \)</li>
  <p><li> set \( c_1 = c \)</li>
</ol>
<p>

</ol>
<p>

Initial condition:

<p>

<ul>
 <p><li> Either interpolation: \( c_{1,j} = I(\x_j) \) (finite elements)</li>
 <p><li> Or projection: solve \( \sum_j M_{i,j}c_{1,j} = (I,\baspsi_i) \), \( i\in\If \)</li>
</ul>
<p>


</section>


<section>

<h3>Comparing P1 elements with the finite difference method; ideas <a name="fem:deq:diffu:FE:fdvsP1fe"></a></h3>

<p>

<ul>
 <p><li> P1 elements in 1D</li>
 <p><li> Uniform mesh on \( [0,L] \) with cell length \( h \)</li>
 <p><li> No Dirichlet conditions: \( \baspsi_i=\basphi_i \), \( i=0,\ldots,N=N_n \)</li>
 <p><li> Have found formulas for \( M \) and \( K \) at the element level</li>
 <p><li> Have assembled the global matrices</li>
 <p><li> Have developed corresponding finite difference operator formulas</li>
 <p><li> \( M \): \( h[D_t^+(u - \frac{1}{6}h^2D_xD_x u)]^n_i \)</li>
 <p><li> \( K \): \( h[\dfc D_xD_x u]^n_i \)</li>
</ul>
<p>


</section>


<section>

<h3>Comparing P1 elements with the finite difference method; results  <a name="___sec267"></a></h3>

<p>
Diffusion equation with finite elements is equivalent to

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[D_t^+(u - \frac{1}{6}h^2D_xD_x u) = \dfc D_xD_x u + f]^n_i
\tag{76}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Can lump the mass matrix by Trapezoidal integration and get
the standard finite difference scheme

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[D_t^+u  = \dfc D_xD_x u + f]^n_i
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Discretization in time by a Backward Euler scheme <a name="fem:deq:diffu:analysis:FE"></a></h3>

<p>
Backward Euler scheme in time:

<p>
<p>&nbsp;<br>
$$
[D_t^- u = \dfc\nabla^2 u + f(\x, t)]^n
\tp
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\uex^{n} - \Delta t \left( \dfc\nabla^2 \uex^n + f(\x, t_{n})\right) =
\uex^{n-1}
\tag{77}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ \uex^n \approx u^n = \sum_{j=0}^{N} c_j^{n}\baspsi_j(\x),\quad
\uex^{n+1} \approx u^{n+1} = \sum_{j=0}^{N} c_j^{n+1}\baspsi_j(\x)$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>The variational form of the time-discrete problem  <a name="___sec269"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} \left( u^{n}v
+ \Delta t \dfc\nabla u^n\cdot\nabla v\right)\dx
= \int_{\Omega} u^{n-1}  v\dx -
\Delta t\int_{\Omega}f^n v\dx,\quad\forall v\in V
\tag{78}
\end{equation}
$$
<p>&nbsp;<br>


<p>
or

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(u,v)
+ \Delta t (\dfc\nabla u,\nabla v)
= (u_1,v) +
\Delta t (f^n,\baspsi_i)
\tag{79}
\end{equation}
$$
<p>&nbsp;<br>


<p>
The linear system: insert \( u=\sum_j c_j\baspsi_i \) and \( u_1=\sum_j c_{1,j}\baspsi_i \),

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(M + \Delta t \dfc K)c = Mc_1 + f
\tag{80}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Calculations with P1 elements in 1D  <a name="___sec270"></a></h3>

<p>
Can interpret the resulting equation system as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[D_t^-(u - \frac{1}{6}h^2D_xD_x u) = \dfc D_xD_x u + f]^n_i
\tag{81}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Lumped mass matrix (by Trapezoidal integration) gives a standard
finite difference method:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[D_t^- u = \dfc D_xD_x u + f]^n_i
\tag{82}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h2>Dirichlet boundary conditions <a name="fem:deq:diffu:Dirichlet"></a></h2>

<p>
Dirichlet condition at \( x=0 \) and Neumann condition at \( x=L \):

<p>
<p>&nbsp;<br>
$$
\begin{align}
u(\x,t) &= u_0(\x,t),\quad & \x\in\partial\Omega_D\\ 
-\dfc\frac{\partial}{\partial n} u(\x,t) &= g(\x,t),\quad
& \x\in\partial{\Omega}_N
\end{align}
$$
<p>&nbsp;<br>


<p>
Forward Euler in time, Galerkin's method, and integration by parts:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_\Omega u^{n+1}v\dx =
\int_\Omega (u^n - \Delta t\dfc\nabla u^n\cdot\nabla v)\dx -
\Delta t\int_{\partial\Omega_N} gv\ds,\quad \forall v\in V
\end{equation}
$$
<p>&nbsp;<br>


<p>
Requirement: \( v=0 \) on \( \partial\Omega_D \)

<p>

</section>


<section>

<h3>Boundary function  <a name="___sec272"></a></h3>

<p>
<p>&nbsp;<br>
$$ u^n(\x) = u_0(\x,t_n) + \sum_{j\in\If}c_j^n\baspsi_j(\x)$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align*}
\sum_{j\in\If} \left(\int_\Omega \baspsi_i\baspsi_j\dx\right)
c^{n+1}_j &= \sum_{j\in\If}
\left(\int_\Omega\left( \baspsi_i\baspsi_j -
\Delta t\dfc\nabla \baspsi_i\cdot\nabla\baspsi_j\right)\dx\right) c_j^n - \\ 
&\quad  \int_\Omega\left( u_0(\x,t_{n+1}) - u_0(\x,t_n)
+ \Delta t\dfc\nabla u_0(\x,t_n)\cdot\nabla
\baspsi_i\right)\dx \\ 
& \quad  + \Delta t\int_\Omega f\baspsi_i\dx -
\Delta t\int_{\partial\Omega_N} g\baspsi_i\ds,
\quad i\in\If
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Finite element basis functions  <a name="___sec273"></a></h3>

<p>

<ul>
 <p><li> \( B(\x,t_n)=\sum_{j\in\Ifb} U_j^n\basphi_j \)</li>
 <p><li> \( \baspsi_i = \basphi_{\nu(j)} \), \( j\in\If \)</li>
 <p><li> \( \nu(j) \), \( j\in\If \), are the node numbers corresponding to all
   nodes without a Dirichlet condition</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align*}
u^n &= \sum_{j\in\Ifb} U_j^n\basphi_j + \sum_{j\in\If}c_{1,j}\basphi_{\nu(j)},\\ 
u^{n+1} &= \sum_{j\in\Ifb} U_j^{n+1}\basphi_j +
\sum_{j\in\If}c_{j}\basphi_{\nu(j)}
\end{align*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align*}
\sum_{j\in\If} \left(\int_\Omega \basphi_i\basphi_j\dx\right)
c_j &= \sum_{j\in\If}
\left(\int_\Omega\left( \basphi_i\basphi_j -
\Delta t\dfc\nabla \basphi_i\cdot\nabla\basphi_j\right)\dx\right) c_{1,j}
- \\ 
&\quad  \sum_{j\in\Ifb}\int_\Omega\left( \basphi_i\basphi_j(U_j^{n+1} - U_j^n)
+ \Delta t\dfc\nabla \basphi_i\cdot\nabla
\basphi_jU_j^n\right)\dx \\ 
&\quad + \Delta t\int_\Omega f\basphi_i\dx -
\Delta t\int_{\partial\Omega_N} g\basphi_i\ds,
\quad i\in\If
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Modification of the linear system; the raw system  <a name="___sec274"></a></h3>

<p>

<ul>
 <p><li> Drop boundary function</li>
 <p><li> Compute as if there are not Dirichlet conditions</li>
 <p><li> Modify the linear system to incorporate Dirichlet conditions</li>
 <p><li> \( \If \) holds the indices of all nodes \( \{0,1,\ldots,N=N_n\} \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align*}
\sum_{j\in\If}
\biggl(\underbrace{\int_\Omega \basphi_i\basphi_j\dx}_{M_{i,j}}\biggr)
c_j &= \sum_{j\in\If}
\biggl(\underbrace{\int_\Omega \basphi_i\basphi_j \dx}_{M_{i,j}} -
\Delta t\underbrace{\int_\Omega
\dfc\nabla \basphi_i\cdot\nabla\basphi_j\dx}_{K_{i,j}}\biggr) c_{1,j}
\\ 
&\quad \underbrace{-\Delta t\int_\Omega f\basphi_i\dx -
\Delta t\int_{\partial\Omega_N} g\basphi_i\ds}_{f_i},\quad i\in\If
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Modification of the linear system; setting Dirichlet conditions  <a name="___sec275"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
Mc = b,\quad b = Mc_1 - \Delta t Kc_1 + \Delta t f
\end{equation}
$$
<p>&nbsp;<br>


<p>
For each \( k \) where a Dirichlet condition applies,
\( u(\xno{k},t_{n+1})=U_k^{n+1} \),

<p>

<ul>
 <p><li> set row \( k \) in \( M \) to zero and 1 on the diagonal:
   \( M_{k,j}=0 \), \( j\in\If \), \( M_{k,k}=1 \)</li>
 <p><li> \( b_k = U_k^{n+1} \)</li>
</ul>
<p>

Or apply the slightly more complicated modification which
preserves symmetry of \( M \)

<p>

</section>


<section>

<h3>Modification of the linear system; Backward Euler example  <a name="___sec276"></a></h3>

<p>
Backward Euler discretization in time gives a more complicated
coefficient matrix:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
Ac=b,\quad A = M + \Delta t K,\quad b = Mc_1 + \Delta t f\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Set row \( k \) to zero and 1 on the diagonal:
   \( M_{k,j}=0 \), \( j\in\If \), \( M_{k,k}=1 \)</li>
 <p><li> Set row \( k \) to zero: \( K_{k,j}=0 \), \( j\in\If \)</li>
 <p><li> \( b_k = U_k^{n+1} \)</li>
</ul>
<p>

Observe: \( A_{k,k} = M_{k,k} + \Delta t K_{k,k} = 1 + 0 \), so
\( c_k = U_k^{n+1} \)

<p>

</section>


<section>

<h2>Analysis of the discrete equations <a name="fem:deq:diffu:anal"></a></h2>

<p>
The diffusion equation \( u_t = \dfc u_{xx} \) allows a (Fourier)
wave component

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u = \Aex^n e^{ikx},\quad \Aex = e^{-\dfc k^2\Delta t}
\tag{83}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Numerical schemes often allow the similar solution

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u^n_q = A^n e^{ikx}
\tag{84}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( A \): amplification factor to be computed</li>
 <p><li> How good is this \( A \) compared to the exact one?</li>
</ul>
<p>


</section>


<section>

<h3>Handy formulas  <a name="___sec278"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align*}
[D_t^+ A^n e^{ikq\Delta x}]^n &= A^n e^{ikq\Delta x}\frac{A-1}{\Delta t},\\ 
[D_t^- A^n e^{ikq\Delta x}]^n &= A^n e^{ikq\Delta x}\frac{1-A^{-1}}{\Delta t},\\ 
[D_t A^n e^{ikq\Delta x}]^{n+\half} &= A^{n+\half} e^{ikq\Delta x}\frac{A^{\half}-A^{-\half}}{\Delta t} = A^ne^{ikq\Delta x}\frac{A-1}{\Delta t},\\ 
[D_xD_x A^ne^{ikq\Delta x}]_q &= -A^n \frac{4}{\Delta x^2}\sin^2\left(\frac{k\Delta x}{2}\right)\tp
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section>

<h3>Amplification factor for the Forward Euler method; results  <a name="___sec279"></a></h3>

<p>
Introduce \( p=k\Delta x/2 \) and \( C=\dfc\Delta t/\Delta x^2 \):

<p>
<p>&nbsp;<br>
$$ A = 1 - 4C\frac{\sin^2 p}{1 + \underbrace{\frac{2}{3}\sin^2 p}_{\hbox{from }M}}$$
<p>&nbsp;<br>


<p>
(See notes for details)

<p>
Stability: \( |A|\leq 1 \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
C\leq \frac{5}{6}\quad\Rightarrow\quad \Delta t\leq \frac{5\Delta x^2}{6\dfc}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Finite differences: \( C\leq {\half} \), so finite elements improves
stability (for this PDE)

<p>

</section>


<section>

<h3>Amplification factor for the Forward Euler method; plot  <a name="___sec280"></a></h3>

<p>
<center><p><img src="fig-fem/diffu_A_factors2_FE.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Amplification factor for the Backward Euler method; results  <a name="___sec281"></a></h3>

<p>
<p>&nbsp;<br>
$$
A = \left( 1 + 4C\frac{\sin^2 p}{1 + \frac{2}{3}\sin^2 p}\right)^{-1}
\hbox{ (unconditionally stable)}
$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-fem/diffu_A_factors2_BE.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Amplification factors for smaller time steps; Forward Euler  <a name="___sec282"></a></h3>

<p>
<center><p><img src="fig-fem/diffu_A_factors2_fine_FE.png" align="bottom" width=400></p></center>

<p>

</section>


<section>

<h3>Amplification factors for smaller time steps; Backward Euler  <a name="___sec283"></a></h3>

<p>
<center><p><img src="fig-fem/diffu_A_factors2_fine_BE.png" align="bottom" width=400></p></center>


</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.min.js"></script>

<script>

// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
controls: true,
progress: true,
history: true,
center: true,
theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

// Optional libraries used to extend on reveal.js
dependencies: [
{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
{ src: 'reveal.js/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
{ src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
// { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]
});
</script>


</body>
</html>
