<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to computing with finite difference methods">
<meta name="keywords" content="decay ODE,exponential decay,mesh,grid,mesh function,finite differences,forward difference,finite differences forward,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward difference,finite differences backward,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,centered difference,finite differences centered,averaging arithmetic,weighted average,theta-rule,$\theta$-rule,$\theta$-rule,finite difference operator notation,operator notation, finite differences,directory,folder,doc strings,printf format,format string syntax (Python),representative (mesh function),array arithmetics,array computing,continuous function norms,norm continuous,discrete function norms,mesh function norms,norm discrete (mesh function),error norms,scalar computing,PNG plot,PDF plot,EPS plot,viewing graphics files,cropping images,user interfaces to programs,command-line arguments,reading the command line,list comprehension,option-value pairs (command line),command-line options and values,reading the command line,convergence rate,dictionary,verification,modules,test block (in modules),importing modules,doctests,software testing doctests,unit testing,software testing nose,software testing nose w/doctests,unit testing,software testing unit testing (class-based),problem class,solver class,wrapper (code),visualizer class,problem class,solver class,visualizer class,numerical experiments,scientific experiments,script,Unix wildcard notation,wildcard notation (Unix),stability,amplification factor,A-stable methods,L-stable methods,error amplification factor,error global,consistency,stability,convergence,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order scheme,Taylor-series methods (for ODEs),Adams-Bashforth scheme, 2nd-order,Adams-Bashforth scheme, 3rd order,Runge-Kutta, 4th-order scheme,RK4,adaptive time stepping,Dormand-Prince Runge-Kutta 4-5 method,population dynamics,logistic model,radioactive decay,terminal velocity,geometric mean,averaging geometric,scaling">



<style type="text/css">
    /* blueish style */

    /* Color definitions:  http://www.december.com/html/spec/color0.html
       CSS examples:       http://www.w3schools.com/css/css_examples.asp */

    body {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #000000;
    }
    h1 { font-size: 1.8em; color: #1e36ce; }
    h2 { font-size: 1.5em; color: #1e36ce; }
    h3 { color: #1e36ce; }
    a { color: #1e36ce; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #bababa;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #f8f8f8;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods  ',
               1,
               'decay:basics',
               'decay:basics'),
              (' A basic model for exponential decay ',
               2,
               'decay:model',
               'decay:model'),
              (' The Forward Euler scheme ',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              (' Step 1: Discretizing the domain ', 3, None, '___sec3'),
              (' Step 2: Fulfilling the equation at discrete time points ',
               3,
               None,
               '___sec4'),
              (' Step 3: Replacing derivatives by finite differences ',
               3,
               None,
               '___sec5'),
              (' Step 4: Formulating a recursive algorithm ',
               3,
               None,
               '___sec6'),
              (' The Backward Euler scheme ',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              (' The Crank-Nicolson scheme ',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              (' The unifying $\\theta$-rule ',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              (' Constant time step ', 2, None, '___sec10'),
              (' Compact operator notation for finite differences ',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              (' Implementation ', 1, 'decay:impl1', 'decay:impl1'),
              (' Making a solver function ', 2, 'decay:py1', 'decay:py1'),
              (' Function for computing the numerical solution ',
               3,
               None,
               '___sec14'),
              (' Integer division ', 3, None, '___sec15'),
              (' Doc strings ', 3, None, '___sec16'),
              (' Formatting of numbers ', 3, None, '___sec17'),
              (' Running the program ', 3, None, '___sec18'),
              (' Verifying the implementation ', 2, None, '___sec19'),
              (' Running a few algorithmic steps by hand ',
               3,
               None,
               '___sec20'),
              (' Comparison with an exact discrete solution ',
               3,
               None,
               '___sec21'),
              (' Computing the numerical error as a mesh function ',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              (' Computing the norm of the numerical error ',
               2,
               'decay:computing:error:norm',
               'decay:computing:error:norm'),
              (' Scalar computing ', 3, None, '___sec24'),
              (' Plotting solutions ', 2, 'decay:plotting', 'decay:plotting'),
              (' Plotting multiple curves ', 3, None, '___sec26'),
              (' Experiments with computing and plotting ',
               3,
               None,
               '___sec27'),
              (' Combining plot files ', 3, None, '___sec28'),
              (' Plotting with SciTools ', 3, None, '___sec29'),
              (' Creating command-line interfaces ',
               2,
               'decay:commandline',
               'decay:commandline'),
              (' Reading a sequence of command-line arguments ',
               3,
               None,
               '___sec31'),
              (' Working with an argument parser ', 3, None, '___sec32'),
              (' Creating a graphical web user interface ',
               2,
               None,
               '___sec33'),
              (' Making a compute function ', 3, None, '___sec34'),
              (' Generating the user interface ', 3, None, '___sec35'),
              (' Running the web application ', 3, None, '___sec36'),
              (' Computing convergence rates ',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              (' Estimating $r$ ', 3, None, '___sec38'),
              (' Implementation ', 3, None, '___sec39'),
              (' Debugging via convergence rates ', 3, None, '___sec40'),
              (' Memory-saving implementation ', 2, None, '___sec41'),
              (' Software engineering ', 1, None, '___sec42'),
              (' Making a module ',
               2,
               'decay:prog:se:module',
               'decay:prog:se:module'),
              (' Prefixing imported functions by the module name ',
               2,
               'decay:prog:se:import',
               'decay:prog:se:import'),
              (' Doctests ',
               2,
               'decay:prog:se:doctest',
               'decay:prog:se:doctest'),
              (' Unit testing with nose ',
               2,
               'decay:prog:se:nose',
               'decay:prog:se:nose'),
              (' Basic use of nose ', 3, None, '___sec47'),
              (' Alternative assert statements ', 3, None, '___sec48'),
              (' Applying nose ', 3, None, '___sec49'),
              (' Installation of nose ', 3, None, '___sec50'),
              (' Using nose to test modules with doctests ',
               3,
               None,
               '___sec51'),
              (' Classical class-based unit testing ',
               2,
               'decay:prog:se:unittest',
               'decay:prog:se:unittest'),
              (' Basic use of unittest ', 3, None, '___sec53'),
              (' Demonstration of unittest ', 3, None, '___sec54'),
              (' Implementing simple problem and solver classes ',
               2,
               'decay:prog:se:class',
               'decay:prog:se:class'),
              (' The problem class ', 3, None, '___sec56'),
              (' The solver class ', 3, None, '___sec57'),
              (' The visualizer class ', 3, None, '___sec58'),
              (' Combing the objects ', 3, None, '___sec59'),
              (' Improving the problem and solver classes ',
               2,
               'decay:prog:se:class2',
               'decay:prog:se:class2'),
              (' A generic class for parameters ', 3, None, '___sec61'),
              (' The problem class ', 3, None, '___sec62'),
              (' The solver class ', 3, None, '___sec63'),
              (' The visualizer class ', 3, None, '___sec64'),
              (' Performing scientific experiments ',
               1,
               'decay:experiments',
               'decay:experiments'),
              (' Software ', 2, None, '___sec66'),
              (' Combining plot files ', 2, None, '___sec67'),
              (' Interpreting output from other programs ',
               2,
               None,
               '___sec68'),
              (' Making a report ',
               2,
               'decay:exper:report',
               'decay:exper:report'),
              (' Plain HTML ', 3, None, '___sec70'),
              (' HTML with MathJax ', 3, None, '___sec71'),
              (' LaTeX ', 3, None, '___sec72'),
              (' Sphinx ', 3, None, '___sec73'),
              (' Markdown ', 3, None, '___sec74'),
              (' Wiki formats ', 3, None, '___sec75'),
              (' Doconce ', 3, None, '___sec76'),
              (' Worked example ', 3, None, '___sec77'),
              (' Publishing a complete project ',
               2,
               'decay:exper:github',
               'decay:exper:github'),
              (' Exercises and Problems ', 1, None, '___sec79'),
              (" Exercise 1: Derive schemes for Newton's law of cooling ",
               2,
               'decay:app:exer:cooling:schemes',
               'decay:app:exer:cooling:schemes'),
              (" Exercise 2: Implement schemes for Newton's law of cooling ",
               2,
               'decay:app:exer:cooling:py',
               'decay:app:exer:cooling:py'),
              (' Exercise 3: Find time of murder from body temperature ',
               2,
               'decay:app:exer:cooling:murder',
               'decay:app:exer:cooling:murder'),
              (' Exercise 4: Experiment with integer division ',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              (' Exercise 5: Experiment with wrong computations ',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              (' Exercise 6: Plot the error function ',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              (' Exercise 7: Compare methods for a given time mesh ',
               2,
               'decay:exer:plot:dtconst',
               'decay:exer:plot:dtconst'),
              (' Exercise 8: Change formatting of numbers and debug ',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              (' Problem 9: Write a doctest ',
               2,
               'decay:exer:doctest1',
               'decay:exer:doctest1'),
              (' Problem 10: Write a nose test ',
               2,
               'decay:exer:nosetest1',
               'decay:exer:nosetest1'),
              (' Problem 11: Make a module ',
               2,
               'decay:exer:module1',
               'decay:exer:module1'),
              (' Exercise 12: Make use of a class implementation ',
               2,
               'decay:exer:decay_class:exper',
               'decay:exer:decay_class:exper'),
              (' Exercise 13: Generalize a class implementation ',
               2,
               'decay:exer:decay_class2',
               'decay:exer:decay_class2'),
              (' Exercise 14: Generalize an advanced class implementation ',
               2,
               'decay:exer:decay_class3',
               'decay:exer:decay_class3'),
              (' Analysis of finite difference equations ',
               1,
               'decay:analysis',
               'decay:analysis'),
              (' Experimental investigation of oscillatory solutions ',
               2,
               None,
               '___sec95'),
              (' Exact numerical solution ', 2, None, '___sec96'),
              (' Stability ', 2, None, '___sec97'),
              (' Comparing amplification factors ', 2, None, '___sec98'),
              (' Series expansion of amplification factors ',
               2,
               None,
               '___sec99'),
              (' The fraction of numerical and exact amplification factors ',
               2,
               None,
               '___sec100'),
              (' The global error at a point ',
               2,
               'decay:analysis:gobal:error',
               'decay:analysis:gobal:error'),
              (' Integrated errors ', 2, None, '___sec102'),
              (' Truncation error ', 2, None, '___sec103'),
              (' Consistency, stability, and convergence ',
               2,
               None,
               '___sec104'),
              (' Exercises ', 1, None, '___sec105'),
              (' Exercise 15: Visualize the accuracy of finite differences $u=e^{-at}$ ',
               2,
               'decay:analysis:exer:fd:exp:plot',
               'decay:analysis:exer:fd:exp:plot'),
              (' Exercise 16: Explore the $\\theta$-rule for exponential growth ',
               2,
               'decay:analysis:exer:growth',
               'decay:analysis:exer:growth'),
              (' Model extensions ', 1, None, '___sec108'),
              (' Generalization: including a variable coefficient ',
               2,
               None,
               '___sec109'),
              (' Generalization: including a source term ',
               2,
               'decay:source',
               'decay:source'),
              (' Schemes ', 3, None, '___sec111'),
              (' Implementation of the generalized model problem ',
               2,
               'decay:general',
               'decay:general'),
              (' Deriving the $\\theta$-rule formula ', 3, None, '___sec113'),
              (' The Python code ', 3, None, '___sec114'),
              (' Coding of variable coefficients ', 3, None, '___sec115'),
              (' Verifying a constant solution ',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              (' Verification via manufactured solutions ',
               2,
               'decay:MMS',
               'decay:MMS'),
              (' Extension to systems of ODEs ', 2, None, '___sec118'),
              (' General first-order ODEs ', 1, None, '___sec119'),
              (' Generic form ', 2, None, '___sec120'),
              (' The $\\theta$-rule ', 2, None, '___sec121'),
              (' An implicit 2-step backward scheme ', 2, None, '___sec122'),
              (' Leapfrog schemes ', 2, None, '___sec123'),
              (' The ordinary Leapfrog scheme ', 3, None, '___sec124'),
              (' The filtered Leapfrog scheme ', 3, None, '___sec125'),
              (' The 2nd-order Runge-Kutta scheme ', 2, None, '___sec126'),
              (' A 2nd-order Taylor-series method ', 2, None, '___sec127'),
              (' The 2nd- and 3rd-order Adams-Bashforth schemes ',
               2,
               None,
               '___sec128'),
              (' 4th-order Runge-Kutta scheme ',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              (' The Odespy software ', 2, None, '___sec130'),
              (' Example: Runge-Kutta methods  ', 2, None, '___sec131'),
              (' Remark about using the $\\theta$-rule in Odespy ',
               3,
               None,
               '___sec132'),
              (' Example: Adaptive Runge-Kutta methods  ',
               2,
               'decay:fd2:adaptiveRK',
               'decay:fd2:adaptiveRK'),
              (' Exercises ', 1, None, '___sec134'),
              (' Exercise 17: Experiment with precision in tests and the size of $u$ ',
               2,
               'decay:fd2:exer:precision',
               'decay:fd2:exer:precision'),
              (' Exercise 18: Implement the 2-step backward scheme ',
               2,
               'decay:fd2:exer:bw2',
               'decay:fd2:exer:bw2'),
              (' Exercise 19: Implement the 2nd-order Adams-Bashforth scheme ',
               2,
               'decay:fd2:exer:AB2',
               'decay:fd2:exer:AB2'),
              (' Exercise 20: Implement the 3rd-order Adams-Bashforth scheme ',
               2,
               'decay:fd2:exer:AB3',
               'decay:fd2:exer:AB3'),
              (' Exercise 21: Analyze explicit 2nd-order methods ',
               2,
               'decay:exer:RK2:Taylor:analysis',
               'decay:exer:RK2:Taylor:analysis'),
              (' Problem 22: Implement and investigate the Leapfrog scheme ',
               2,
               'decay:fd2:exer:leapfrog1',
               'decay:fd2:exer:leapfrog1'),
              (' Problem 23: Make a unified implementation of many schemes ',
               2,
               'decay:fd2:exer:uni',
               'decay:fd2:exer:uni'),
              (' Applications of exponential decay models ',
               1,
               'decay:app',
               'decay:app'),
              (' Scaling ', 2, 'decay:app:scaling', 'decay:app:scaling'),
              (' Evolution of a population ',
               2,
               'decay:app:pop',
               'decay:app:pop'),
              (' Compound interest and inflation ',
               2,
               'decay:app:interest',
               'decay:app:interest'),
              (' Radioactive Decay ',
               2,
               'decay:app:nuclear',
               'decay:app:nuclear'),
              (' Deterministic model ', 3, None, '___sec147'),
              (' Stochastic model ', 3, None, '___sec148'),
              (' Relation between stochastic and deterministic models ',
               3,
               None,
               '___sec149'),
              (" Newton's law of cooling ",
               2,
               'decay:app:Newton:cooling',
               'decay:app:Newton:cooling'),
              (' Decay of atmospheric pressure with altitude ',
               2,
               'decay:app:atm',
               'decay:app:atm'),
              (' Multiple atmospheric layers ', 3, None, '___sec152'),
              (' Simplification: $L=0$ ', 3, None, '___sec153'),
              (' Simplification: one-layer model ', 3, None, '___sec154'),
              (' Compaction of sediments ',
               2,
               'decay:app:sediment',
               'decay:app:sediment'),
              (' Vertical motion of a body in a viscous fluid ',
               2,
               'decay:app:drag',
               'decay:app:drag'),
              (' Overview of forces ', 3, None, '___sec157'),
              (' Equation of motion ', 3, None, '___sec158'),
              (' Terminal velocity ', 3, None, '___sec159'),
              (' A Crank-Nicolson scheme ', 3, None, '___sec160'),
              (' Physical data ', 3, None, '___sec161'),
              (' Verification ', 3, None, '___sec162'),
              (' Scaling ', 3, None, '___sec163'),
              (' Decay ODEs from solving a PDE by Fourier expansions ',
               2,
               'decay:app:diffusion:Fourier',
               'decay:app:diffusion:Fourier'),
              (' Exercises and Projects ', 1, None, '___sec165'),
              (' Exercise 24: Simulate an oscillating cooling process ',
               2,
               'decay:app:exer:cooling:osc',
               'decay:app:exer:cooling:osc'),
              (' Exercise 25: Radioactive decay of Carbon-14 ',
               2,
               'decay:app:exer:radio:C14',
               'decay:app:exer:radio:C14'),
              (' Exercise 26: Simulate stochastic radioactive decay ',
               2,
               'decay:app:exer:stoch:nuclear',
               'decay:app:exer:stoch:nuclear'),
              (' Exercise 27: Radioactive decay of two substances ',
               2,
               'decay:app:exer:radio:twosubst',
               'decay:app:exer:radio:twosubst'),
              (' Exercise 28: Simulate the pressure drop in the atmosphere ',
               2,
               'decay:app:exer:atm1',
               'decay:app:exer:atm1'),
              (' Exercise 29: Make a program for vertical motion in a fluid ',
               2,
               'decay:app:exer:drag:prog',
               'decay:app:exer:drag:prog'),
              (' Project 30: Simulate parachuting ',
               2,
               'decay:app:exer:parachute',
               'decay:app:exer:parachute'),
              (' Exercise 31: Formulate vertical motion in the atmosphere ',
               2,
               'decay:app:exer:drag:atm1',
               'decay:app:exer:drag:atm1'),
              (' Exercise 32: Simulate vertical motion in the atmosphere ',
               2,
               'decay:app:exer:drag:atm2',
               'decay:app:exer:drag:atm2'),
              (' Exercise 33: Compute $y=|x|$ by solving an ODE ',
               2,
               'decay:app:exer:signum',
               'decay:app:exer:signum'),
              (' Exercise 34: Simulate growth of a fortune with random interest rate ',
               2,
               'decay:app:exer:interest',
               'decay:app:exer:interest'),
              (' Exercise 35: Simulate a population in a changing environment ',
               2,
               'decay:app:exer:pop:at',
               'decay:app:exer:pop:at'),
              (' Exercise 36: Simulate logistic growth ',
               2,
               'decay:app:exer:pop:logistic1',
               'decay:app:exer:pop:logistic1'),
              (' Exercise 37: Rederive the equation for continuous compound interest ',
               2,
               'decay:app:exer:interest:derive',
               'decay:app:exer:interest:derive'),
              (' Bibliography ', 1, None, '___sec180')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\If}{\mathcal{I}}     % for FEM
\newcommand{\Ifd}{\mathcal{I}_d}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0002"></a>
<!-- begin top navigation -->
<a href="._part0001_main_decay.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0003_main_decay.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end top navigation -->

<p>
<!-- !split -->

<h2>Implementation <a name="decay:impl1"></a></h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Goal.</b>
We want make a computer program for solving
$$
u'(t) = -au(t),\quad t\in (0,T], \quad u(0)=I,
$$

by finite difference methods. The program should also display
the numerical solution as a curve on the
screen, preferably together with the
exact solution. We shall also be concerned with program testing,
user interfaces, and computing convergence rates.
</div>
<p>
All programs referred to in this section are found in the
<a href="http://tinyurl.com/jvzzcfn/decay"><tt>src/decay</tt></a> directory (we use the classical
Unix term <em>directory</em> for what many others nowadays call <em>folder</em>).

<p>
<b>Mathematical problem.</b>
We want to explore the Forward Euler scheme, the
Backward Euler, and the Crank-Nicolson schemes applied to our model problem.
From an implementational point of view, it is advantageous to
implement the \( \theta \)-rule
$$
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
$$

since it can generate the three other schemes by various of
choices of \( \theta \): \( \theta=0 \) for Forward Euler, \( \theta =1 \) for
Backward Euler, and \( \theta =1/2 \) for Crank-Nicolson.
Given \( a \), \( u^0=I \), \( T \), and \( \Delta t \),
our task is to use the \( \theta \)-rule to
compute \( u^1, u^2,\ldots,u^{N_t} \), where \( t_{N_t}=N_t\Delta t \), and
\( N_t \) the closest integer to \( T/\Delta t \).

<p>
<b>Computer Language: Python.</b>
Any programming language can be used to generate the \( u^{n+1} \) values from
the formula above. However, in this document we shall mainly make use of
Python of several reasons:

<p>

<ul>
  <li> Python has a very clean, readable syntax (often known as
    "executable pseudo-code").</li>
  <li> Python code is very similar to MATLAB code (and MATLAB has a
    particularly widespread use for scientific computing).</li>
  <li> Python is a full-fledged, very powerful programming language.</li>
  <li> Python is similar to, but much simpler to work with and
    results in more reliable code than C++.</li>
  <li> Python has a rich set of modules for scientific computing, and its
    popularity in scientific computing is rapidly growing.</li>
  <li> Python was made for being combined with compiled languages
    (C, C++, Fortran) to reuse existing numerical software and to
    reach high computational performance of new implementations.</li>
  <li> Python has extensive support for administrative task
    needed when doing large-scale computational investigations.</li>
  <li> Python has extensive support for graphics (visualization,
    user interfaces, web applications).</li>
  <li> FEniCS, a very powerful tool for solving PDEs by
    the finite element method, is most human-efficient to operate
    from Python.</li>
</ul>

Learning Python is easy. Many newcomers to the language will probably
learn enough from the forthcoming examples to perform their own computer
experiments. The examples start with simple Python code and gradually
make use of more powerful constructs as we proceed. As long as it is
not inconvenient for the problem at hand, our Python code is made as
close as possible to MATLAB code for easy transition between the two
languages.

<p>
Readers who feel the Python examples are too hard to follow will probably
benefit from read a tutorial, e.g.,

<p>

<ul>
  <li> <a href="http://docs.python.org/2/tutorial/">The Official Python Tutorial</a></li>
  <li> <a href="http://www.tutorialspoint.com/python/">Python Tutorial on tutorialspoint.com</a></li>
  <li> <a href="http://www.learnpython.org/">Interactive Python tutorial site</a></li>
  <li> <a href="http://en.wikibooks.org/wiki/A_Beginner's_Python_Tutorial">A Beginner's Python Tutorial</a></li>
</ul>

The author also has a book <a href="._part0009_main_decay.html#Langtangen_2012">[1]</a> that introduces
scientific programming with Python.

<h3>Making a solver function <a name="decay:py1"></a></h3>

<p>
We choose to have an array <code>u</code> for storing the \( u^n \) values, \( n=0,1,\ldots,N_t \).
The algorithmic steps are

<p>

<ol>
 <li> initialize \( u^0 \)</li>
 <li> for \( t=t_n \), \( n=1,2,\ldots,N_t \): compute \( u_n \) using
    the \( \theta \)-rule formula</li>
</ol>

<h4>Function for computing the numerical solution  <a name="___sec14"></a></h4>

<p>
The following Python function takes the input data of the problem
(\( I \), \( a \), \( T \), \( \Delta t \), \( \theta \)) as arguments and returns two arrays with
the solution \( u^0,\ldots,u^{N_t} \) and the mesh points \( t_0,\ldots,t_{N_t} \),
respectively:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, a, T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(T<span style="color: #666666">/</span>dt)            <span style="color: #408080; font-style: italic"># no of time intervals</span>
    T <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt                 <span style="color: #408080; font-style: italic"># adjust T to fit time step dt</span>
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># array of u[n] values</span>
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)  <span style="color: #408080; font-style: italic"># time mesh</span>

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I                  <span style="color: #408080; font-style: italic"># assign initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):    <span style="color: #408080; font-style: italic"># n=0,1,...,Nt-1</span>
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>
<p>
The <code>numpy</code> library contains a lot of functions for array computing. Most
of the function names are similar to what is found
in the alternative scientific computing language MATLAB. Here
we make use of

<p>

<ul>
 <li> <code>zeros(Nt+1)</code> for creating an array of a size <code>Nt+1</code>
   and initializing the elements to zero</li>
 <li> <code>linspace(0, T, Nt+1)</code> for creating an array with <code>Nt+1</code> coordinates uniformly
   distributed between <code>0</code> and <code>T</code></li>
</ul>

The <code>for</code> loop deserves a comment, especially for newcomers to Python.
The construction <code>range(0, Nt, s)</code> generates all integers from <code>0</code> to <code>Nt</code>
in steps of <code>s</code>, <em>but not including</em> <code>Nt</code>. Omitting <code>s</code> means <code>s=1</code>.
For example, <code>range(0, 6, 3)</code>
gives <code>0</code> and <code>3</code>, while <code>range(0, Nt)</code> generates <code>0</code>, <code>1</code>, ..., <code>Nt-1</code>.
Our loop implies the following assignments to <code>u[n+1]</code>: <code>u[1]</code>, <code>u[2]</code>, ...,
<code>u[Nt]</code>, which is what we want since <code>u</code> has length <code>Nt+1</code>.
The first index in Python arrays or lists is <em>always</em> <code>0</code> and the
last is then <code>len(u)-1</code>. The length of an array <code>u</code> is obtained by
<code>len(u)</code> or <code>u.size</code>.

<p>
To compute with the <code>solver</code> function, we need to <em>call</em> it. Here
is a sample call:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=2</span>, T<span style="color: #666666">=8</span>, dt<span style="color: #666666">=0.8</span>, theta<span style="color: #666666">=1</span>)
</pre></div>

<h4>Integer division  <a name="___sec15"></a></h4>

<p>
The shown implementation of the <code>solver</code> may face problems and
wrong results if <code>T</code>, <code>a</code>, <code>dt</code>, and <code>theta</code> are given as integers,
see <a href="._part0005_main_decay.html#decay:exer:intdiv">Exercise 4: Experiment with integer division</a> and <a href="._part0005_main_decay.html#decay:exer:decay1err">Exercise 5: Experiment with wrong computations</a>.
The problem is related to <em>integer division</em> in Python (as well as
in Fortran, C, C++, and many other computer languages): <code>1/2</code> becomes <code>0</code>,
while <code>1.0/2</code>, <code>1/2.0</code>, or <code>1.0/2.0</code> all become <code>0.5</code>. It is enough
that at least the nominator or the denominator is a real number
(i.e., a <code>float</code> object)
to ensure correct mathematical division. Inserting
a conversion <code>dt = float(dt)</code>
guarantees that <code>dt</code> is
<code>float</code> and avoids problems in <a href="._part0005_main_decay.html#decay:exer:decay1err">Exercise 5: Experiment with wrong computations</a>.

<p>
Another problem with computing \( N_t=T/\Delta t \) is that we should
round \( N_t \) to the nearest integer. With <code>Nt = int(T/dt)</code> the <code>int</code>
operation picks the largest integer smaller than <code>T/dt</code>. Correct
mathematical rounding as known from school is obtained by
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
</pre></div>
<p>
The complete version of our improved, safer <code>solver</code> function then becomes

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, a, T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)            <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))     <span style="color: #408080; font-style: italic"># no of time intervals</span>
    T <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt                 <span style="color: #408080; font-style: italic"># adjust T to fit time step dt</span>
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># array of u[n] values</span>
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)  <span style="color: #408080; font-style: italic"># time mesh</span>

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I                  <span style="color: #408080; font-style: italic"># assign initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):    <span style="color: #408080; font-style: italic"># n=0,1,...,Nt-1</span>
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>

<h4>Doc strings  <a name="___sec16"></a></h4>

<p>
Right below the header line in the <code>solver</code> function there is a
Python string enclosed in triple double quotes <code>"""</code>.
The purpose of this string object is to document what the function
does and what the arguments are. In this case the necessary
documentation do not span more than one line, but with triple double
quoted strings the text may span several lines:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, a, T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve</span>

<span style="color: #BA2121; font-style: italic">        u&#39;(t) = -a*u(t),</span>

<span style="color: #BA2121; font-style: italic">    with initial condition u(0)=I, for t in the time interval</span>
<span style="color: #BA2121; font-style: italic">    (0,T]. The time interval is divided into time steps of</span>
<span style="color: #BA2121; font-style: italic">    length dt.</span>

<span style="color: #BA2121; font-style: italic">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span style="color: #BA2121; font-style: italic">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span style="color: #BA2121; font-style: italic">    Nicolson method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #666666">...</span>
</pre></div>
<p>
Such documentation strings appearing right after the header of
a function are called <em>doc strings</em>. There are tools that can automatically
produce nicely formatted documentation by extracting the definition of
functions and the contents of doc strings.

<p>
It is strongly recommended to equip any function whose purpose
is not obvious with a doc string. Nevertheless, the forthcoming
text deviates from this rule if the function is explained in the text.

<h4>Formatting of numbers  <a name="___sec17"></a></h4>

<p>
Having computed the discrete solution <code>u</code>, it is natural to look at
the numbers:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Write out a table of t and u values:</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(t)):
    <span style="color: #008000; font-weight: bold">print</span> t[i], u[i]
</pre></div>
<p>
This compact <code>print</code> statement gives unfortunately quite ugly output
because the <code>t</code> and <code>u</code> values are not aligned in nicely formatted columns.
To fix this problem, we recommend to use the <em>printf format</em>, supported most
programming languages inherited from C. Another choice is
Python's recent <em>format string syntax</em>.

<p>
Writing <code>t[i]</code> and <code>u[i]</code> in two nicely formatted columns is done like
this with the printf format:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%6.3f</span><span style="color: #BA2121"> u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t[i], u[i])
</pre></div>
<p>
The percentage signs signify "slots" in the text where the variables
listed at the end of the statement are inserted. For each "slot" one
must specify a format for how the variable is going to appear in the
string: <code>s</code> for pure text, <code>d</code> for an integer, <code>g</code> for a real number
written as compactly as possible, <code>9.3E</code> for scientific notation with
three decimals in a field of width 9 characters (e.g., <code>-1.351E-2</code>),
or <code>.2f</code> for standard decimal notation with two decimals
formatted with minimum width. The printf syntax provides a quick way
of formatting tabular output of numbers with full control of the
layout.

<p>
The alternative <em>format string syntax</em> looks like
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;t={t:6.3f} u={u:g}&#39;</span><span style="color: #666666">.</span>format(t<span style="color: #666666">=</span>t[i], u<span style="color: #666666">=</span>u[i])
</pre></div>
<p>
As seen, this format allows logical names in the "slots" where
<code>t[i]</code> and <code>u[i]</code> are to be inserted. The "slots" are surrounded
by curly braces, and the logical name is followed by a colon and
then the printf-like specification of how to format real numbers,
integers, or strings.

<h4>Running the program  <a name="___sec18"></a></h4>

<p>
The function and main program shown above must be placed in a file,
say with name <a href="http://tinyurl.com/jvzzcfn/decay/decay_v1.py"><tt>decay_v1.py</tt></a> (<code>v1</code> stands for "version 1" - we shall make
numerous different versions of this program).  Make sure you
write the code with a suitable text editor (Gedit, Emacs, Vim,
Notepad++, or similar).  The program is run by executing the file this
way:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay_v1.py
</pre></div>
<p>
The text <code>Terminal></code> just indicates a prompt in a
Unix/Linux or DOS terminal window. After this prompt, which will look
different in your terminal window, depending on the terminal application
and how it is set up, commands like <code>python decay_v1.py</code> can be issued.
These commands are interpreted by the operating system.

<p>
We strongly recommend to run Python programs within the IPython shell.
First start IPython by typing <code>ipython</code> in the terminal window.
Inside the IPython shell, our program <code>decay_v1.py</code> is run by the command
<code>run decay_v1.py</code>:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; ipython

In <span style="color: #666666">[</span>1<span style="color: #666666">]</span>: run decay_v1.py
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 0.000 <span style="color: #19177C">u</span><span style="color: #666666">=</span>1
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 0.800 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.384615
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 1.600 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.147929
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 2.400 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.0568958
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 3.200 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.021883
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 4.000 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.00841653
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 4.800 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.00323713
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 5.600 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.00124505
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 6.400 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.000478865
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 7.200 <span style="color: #19177C">u</span><span style="color: #666666">=</span>0.000184179
<span style="color: #19177C">t</span><span style="color: #666666">=</span> 8.000 <span style="color: #19177C">u</span><span style="color: #666666">=</span>7.0838e-05

In <span style="color: #666666">[</span>2<span style="color: #666666">]</span>:
</pre></div>
<p>
The advantage of running programs in IPython are many: previous commands
are easily recalled with the up arrow, <code>%pdb</code> turns on debugging so that
variables can be examined if the program
aborts due to an exception, output of commands are stored in variables,
programs and statements can be profiled,
any operating system command can be executed, modules can be loaded
automatically and other customizations can be performed when starting
IPython -- to mention a few of the most
useful features.

<p>
Although running programs in IPython is strongly recommended, most
execution examples in the forthcoming text use the standard
Python shell with prompt <code>>>></code> and run programs through
a typesetting like

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python programname
</pre></div>
<p>
The reason is that such typesetting
makes the text more compact in the vertical direction
than showing sessions with IPython syntax.

<p>
<!-- Explain running programs in IPython -->
<!-- Prompt: maybe just something with Unix to promote virtual Ubuntu -->

<h3>Verifying the implementation  <a name="___sec19"></a></h3>

<p>
It is easy to make mistakes while deriving and implementing numerical
algorithms, so we should never believe in the printed \( u \) values before
they have been thoroughly verified. The most obvious idea is to compare
the computed solution with the exact solution, when that exists,
but there will always be a discrepancy between these two solutions
because of the numerical approximations. The challenging question is whether
we have the mathematically correct discrepancy or if we have another,
maybe small, discrepancy due to both an approximation error
and an error in the implementation.

<p>
The purpose of <em>verifying</em> a program is to bring evidence for the
property that there are no errors in the implementation. To avoid
mixing unavoidable approximation errors and undesired
implementation errors, we should
try to make tests where we have some exact computation of the
discrete solution or at least parts of it.
Examples will show how this can be done.

<h4>Running a few algorithmic steps by hand  <a name="___sec20"></a></h4>

<p>
The simplest approach to produce a correct reference for the discrete
solution \( u \) of finite difference equations is to compute a few
steps of the algorithm by hand. Then we can compare the hand
calculations with numbers produced by the program.

<p>
A straightforward approach is to use a calculator and
compute \( u^1 \), \( u^2 \), and \( u^3 \). With \( I=0.1 \), \( \theta=0.8 \),
and \( \Delta t =0.8 \) we get

<p>
$$ A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035$$

$$
\begin{align*}
u^1 &= AI=0.0298245614035,\\ 
u^2 &= Au^1= 0.00889504462912,\\ 
u^3 &=Au^2= 0.00265290804728
\end{align*}
$$


<p>
Comparison of these manual calculations with the result of the
<code>solver</code> function is carried out in the function

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">verify_three_steps</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compare three steps with known manual computations.&quot;&quot;&quot;</span>
    theta <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>; a <span style="color: #666666">=</span> <span style="color: #666666">2</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
    u_by_hand <span style="color: #666666">=</span> array([I,
                       <span style="color: #666666">0.0298245614035</span>,
                       <span style="color: #666666">0.00889504462912</span>,
                       <span style="color: #666666">0.00265290804728</span>])

    Nt <span style="color: #666666">=</span> <span style="color: #666666">3</span>  <span style="color: #408080; font-style: italic"># number of time steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, T<span style="color: #666666">=</span>Nt<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)

    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>  <span style="color: #408080; font-style: italic"># tolerance for comparing floats</span>
    difference <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u <span style="color: #666666">-</span> u_by_hand)<span style="color: #666666">.</span>max()
    success <span style="color: #666666">=</span> difference <span style="color: #666666">&lt;=</span> tol
    <span style="color: #008000; font-weight: bold">return</span> success
</pre></div>
<p>
The main program, where we call the <code>solver</code> function and print <code>u</code>,
is now put in a separate function <code>main</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=2</span>, T<span style="color: #666666">=8</span>, dt<span style="color: #666666">=0.8</span>, theta<span style="color: #666666">=1</span>)
    <span style="color: #408080; font-style: italic"># Write out a table of t and u values:</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(t)):
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%6.3f</span><span style="color: #BA2121"> u=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t[i], u[i])
        <span style="color: #408080; font-style: italic"># or print &#39;t={t:6.3f} u={u:g}&#39;.format(t=t[i], u=u[i])</span>
</pre></div>
<p>
The main program in the file may now first run the verification test
and then go on with the real simulation (<code>main()</code>) only if the test is passed:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> verify_three_steps():
    main()
<span style="color: #008000; font-weight: bold">else</span>:
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Bug in the implementation!&#39;</span>
</pre></div>
<p>
Since the verification test is always done, future errors introduced
accidentally in the program have a good chance of being detected.

<p>
<!-- Note: the admon function needs a raw string to handle \theta (\t, \b, etc) -->

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Caution: choice of parameter values.</b>
For the choice of values of parameters in verification tests one should
stay away from integers, especially 0 and 1, as these can
simplify formulas too much for test purposes. For example, with
\( \theta =1 \) the nominator in the formula for \( u^n \) will be the same for
all \( a \) and \( \Delta t \) values. One should therefore choose more
"arbitrary" values, say \( \theta =0.8 \) and \( I=0.1 \).
</div>
<p>
It is essential that verification tests can be automatically run
at <em>any</em> time. For this purpose,
there are test frameworks and corresponding programming
rules that allow us to request running through a suite of test cases
(see the section <a href="._part0003_main_decay.html#decay:prog:se:nose">Unit testing with nose</a>),
but in this very early stage of program development we just implement
and run the verification in our own code so that every detail is
visible and understood.

<p>
The complete program including the <code>verify_three_steps*</code> functions is
found in the file <a href="http://tinyurl.com/jvzzcfn/decay/decay_verf1.py"><tt>decay_verf1.py</tt></a> (<code>verf1</code> is a short name for "verification,
version 1").

<h4>Comparison with an exact discrete solution  <a name="___sec21"></a></h4>

<p>
Sometimes it is possible to find a closed-form
<em>exact discrete solution</em> that fulfills the discrete finite
difference equations. The implementation can then be verified against
the exact discrete solution. This is usually the best technique for
verification.

<p>
<!-- Not so limited, will later guess that linear functions and MMS can -->
<!-- be used in the discrete eqs as well! -->

<p>
Define
$$ A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}\tp  $$

Manual computations with the \( \theta \)-rule results in
$$
\begin{align*}
u^0 &= I,\\ 
u^1 &= Au^0 = AI,\\ 
u^2 &= Au^1 = A^2I,\\ 
&\vdots\\ 
u^n &= A^nu^{n-1} = A^nI \tp 
\end{align*}
$$

We have then established the exact discrete solution as
$$
\begin{equation}
u^n = IA^n
\tag{30}
\tp 
\end{equation}
$$


<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Caution.</b>
One should be conscious about the different meanings of the notation
on the left- and right-hand side
of <a href="#mjx-eqn-30">(30)</a>: on the left, \( n \) in \( u^n \)
is a superscript reflecting a counter
of mesh points (\( t_n \)), while on the right, \( n \)
is the power in the exponentiation \( A^n \).
</div>
<p>
Comparison of the exact discrete solution and the computed
solution is done in the following function:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">verify_exact_discrete_solution</span>():

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">exact_discrete_solution</span>(n, I, a, theta, dt):
        A <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)
        <span style="color: #008000; font-weight: bold">return</span> I<span style="color: #666666">*</span>A<span style="color: #666666">**</span>n

    theta <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>; a <span style="color: #666666">=</span> <span style="color: #666666">2</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; dt <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">8/</span>dt)  <span style="color: #408080; font-style: italic"># no of steps</span>
    u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, T<span style="color: #666666">=</span>Nt<span style="color: #666666">*</span>dt, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
    u_de <span style="color: #666666">=</span> array([exact_discrete_solution(n, I, a, theta, dt)
                  <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nt<span style="color: #666666">+1</span>)])
    difference <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_de <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()  <span style="color: #408080; font-style: italic"># max deviation</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>  <span style="color: #408080; font-style: italic"># tolerance for comparing floats</span>
    success <span style="color: #666666">=</span> difference <span style="color: #666666">&lt;=</span> tol
    <span style="color: #008000; font-weight: bold">return</span> success
</pre></div>
<p>
The complete program is found in the file <a href="http://tinyurl.com/jvzzcfn/decay/decay_verf2.py"><tt>decay_verf2.py</tt></a> (<code>verf2</code> is a short name for "verification,
version 2").

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Local functions.</b>
One can define a function inside another function, here called
a <em>local function</em> (also known as <em>closure</em>) inside a <em>parent function</em>.
A local function is invisible outside the parent function.
A convenient property is that any local function has access to all
variables defined in the parent function, also if we send the
local function to some other function as argument (!).
In the present example, it means that the local function
<code>exact_discrete_solution</code> does not need its five arguments as the
values can alternatively be accessed through the local variables defined
in the parent function <code>verify_exact_discrete_solution</code>. We can send
such an <code>exact_discrete_solution</code> without arguments to any other
function and <code>exact_discrete_solution</code> will still have access to
<code>n</code>, <code>I</code>, <code>a</code>, and so forth defined in its parent function.
</div>
<h3>Computing the numerical error as a mesh function <a name="decay:computing:error"></a></h3>

<p>
Now that we have evidence for a correct implementation, we are in a
position to compare the computed \( u^n \) values in the <code>u</code> array with
the exact \( u \) values at the mesh points, in order to study the error
in the numerical solution.

<p>
Let us first make a function for the analytical solution \( \uex(t)=Ie^{-at} \)
of the model problem:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">exact_solution</span>(t, I, a):
    <span style="color: #008000; font-weight: bold">return</span> I<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)
</pre></div>
<p>
A natural way to compare the exact and discrete solutions is to
calculate their difference as a mesh function:

<p>
$$
\begin{equation}
e^n = \uex(t_n) - u^n,\quad n=0,1,\ldots,N_t \tp 
\end{equation}
$$

We may view \( \uex^n = \uex(t_n) \) as the representation of \( \uex(t) \)
as a mesh function rather than a continuous function defined for all
\( t\in [0,T] \) (\( \uex^n \) is often called the <em>representative</em> of
\( \uex \) on the mesh). Then, \( e^n = \uex^n - u^n \) is clearly
the difference of two mesh functions. This interpretation of \( e^n \)
is natural when programming.

<p>
The error mesh function \( e^n \) can be computed by

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u, t <span style="color: #666666">=</span> solver(I, a, T, dt, theta)  <span style="color: #408080; font-style: italic"># Numerical sol.</span>
u_e <span style="color: #666666">=</span> exact_solution(t, I, a)      <span style="color: #408080; font-style: italic"># Representative of exact sol.</span>
e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
</pre></div>
<p>
Note that the mesh functions <code>u</code> and <code>u_e</code> are represented by arrays
and associated with the points in the array <code>t</code>.

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Array arithmetics.</b>
The last statements

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_e <span style="color: #666666">=</span> exact_solution(t, I, a)
e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
</pre></div>
<p>
are primary examples of array arithmetics: <code>t</code> is an
array of mesh points that we pass to <code>exact_solution</code>. This function
evaluates <code>-a*t</code>, which is a scalar times an array, meaning that
the scalar is multiplied with each array element.
The result is an array, let us call it <code>tmp1</code>. Then
<code>exp(tmp1)</code> means applying the exponential function to each element in
<code>tmp</code>, resulting an array, say <code>tmp2</code>. Finally, <code>I*tmp2</code> is computed
(scalar times array) and <code>u_e</code> refers to this array returned from
<code>exact_solution</code>. The expression <code>u_e - u</code> is the difference between
two arrays, resulting in a new array referred to by <code>e</code>.
</div>
<h3>Computing the norm of the numerical error <a name="decay:computing:error:norm"></a></h3>

<p>
Instead of working with the error \( e^n \) on the entire mesh, we
often want one number expressing the size of the error.
This is obtained by taking the norm of the error function.

<p>
Let us first define norms of a function \( f(t) \)
defined for all \( t\in [0,T] \).
Three common norms are

<p>
$$
\begin{align}
||f||_{L^2} &= \left( \int_0^T f(t)^2 dt\right)^{1/2},
\tag{31}\\ 
||f||_{L^1} &= \int_0^T |f(t)| dt,
\tag{32}\\ 
||f||_{L^\infty} &= \max_{t\in [0,T]}|f(t)|\tp
\tag{33}
\end{align}
$$

The \( L^2 \) norm <a href="#mjx-eqn-31">(31)</a> ("L-two norm")
has nice mathematical properties and
is the most popular norm. It is a generalization
of the well-known Eucledian norm of vectors to functions.
The \( L^\infty \) is also called the max norm or the supremum norm.
In fact, there is a whole family of norms,

<p>
$$
\begin{equation}
||f||_{L^p} = \left(\int_0^T f(t)^pdt\right)^{1/p},
\end{equation}
$$

with \( p \) real. In particular,
\( p=1 \) corresponds to the \( L^1 \) norm above while \( p=\infty \) is the
\( L^\infty \) norm.

<p>
Numerical computations involving mesh functions need corresponding norms.
Given a set of function values, \( f^n \), and some associated mesh points, \( t_n \),
a numerical integration rule can be used to calculate the \( L^2 \) and
\( L^1 \) norms defined above. Imagining that the mesh function is extended
to vary linearly between the mesh points, the Trapezoidal rule is
in fact an exact integration rule. A possible modification of the \( L^2 \)
norm for a mesh function \( f^n \) on a uniform mesh with spacing \( \Delta t \)
is therefore the well-known Trapezoidal integration formula

<p>
$$ ||f^n|| = \left(\Delta t\left(\frac{1}{2}(f^0)^2 + \frac{1}{2}(f^{N_t})^2
+ \sum_{n=1}^{N_t-1} (f^n)^2\right)\right)^{1/2} $$

A common approximation of this expression, motivated by the
convenience of having a simpler formula, is

<p>
$$ ||f^n||_{\ell^2} = \left(\Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2} \tp$$

This is called the discrete \( L^2 \) norm and denoted by \( \ell^2 \).
The error in \( ||f||_{\ell^2}^2 \) compared with the Trapezoidal
integration formula
is \( \Delta t((f^0)^2 + (f^{N_t})^2)/2 \), which means perturbed weights
at the end points of the mesh function, and the error goes to zero as
\( \Delta t\rightarrow 0 \). As long as we are consistent and
stick to one kind of integration
rule for the norm of a mesh function, the details and accuracy of this
rule is not of concern.

<p>
The three discrete norms for a mesh function \( f^n \), corresponding to
the \( L^2 \), \( L^1 \), and \( L^\infty \) norms of \( f(t) \) defined above, are
defined by

<p>
$$
\begin{align}
||f^n||_{\ell^2} & \left( \Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2},
\tag{34}\\ 
||f^n||_{\ell^1} & \Delta t\sum_{n=0}^{N_t} |f^n|
\tag{35}\\ 
||f^n||_{\ell^\infty} & \max_{0\leq n\leq N_t}|f^n|\tp
\tag{36}
\end{align}
$$


<p>
Note that the \( L^2 \), \( L^1 \), \( \ell^2 \), and \( \ell^1 \) norms depend on the
length of the interval of interest (think of \( f=1 \), then the
norms are proportional to \( \sqrt{T} \) or \( T \)). In some applications it
is convenient to think of a mesh function as just a vector of function
values and neglect the information of the mesh points. Then we can
replace \( \Delta t \) by \( T/N_t \) and drop \( T \). Moreover, it is convenient
to divide by the total length of the vector, \( N_t+1 \), instead of \( N_t \).
This reasoning gives rise to the <em>vector norms</em> for a vector
\( f=(f_0,\ldots,f_{N}) \):

<p>
$$
\begin{align}
||f||_2 &= \left( \frac{1}{N+1}\sum_{n=0}^{N} (f_n)^2\right)^{1/2},
\tag{37}\\ 
||f||_1 &= \frac{1}{N+1}\sum_{n=0}^{N} |f_n|
\tag{38}\\ 
||f||_{\ell^\infty} &= \max_{0\leq n\leq N}|f_n|\tp
\tag{39}
\end{align}
$$

Here we have used the common vector component notation with subscripts
(\( f_n \)) and \( N \) as length. We will mostly work with mesh functions
and use the discrete \( \ell^2 \)
norm <a href="#mjx-eqn-34">(34)</a> or the max norm \( \ell^\infty \)
<a href="#mjx-eqn-36">(36)</a>, but the corresponding vector norms
<a href="#mjx-eqn-37">(37)</a>-<a href="#mjx-eqn-39">(39)</a> are also much used
in numerical computations, so it is important to know the different
norms and the relations between them.

<p>
A single number that expresses the size of the numerical error
will be taken as \( ||e^n||_{\ell^2} \) and called \( E \):

<p>
$$
\begin{equation}
E = \sqrt{\Delta t\sum_{n=0}^{N_t} (e^n)^2}
\tag{40}
\end{equation}
$$

The corresponding Python code, using array arithmetics, reads

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span><span style="color: #008000">sum</span>(e<span style="color: #666666">**2</span>))
</pre></div>
<p>
The <code>sum</code> function comes from <code>numpy</code> and computes the sum of the elements
of an array. Also the <code>sqrt</code> function is from <code>numpy</code> and computes the
square root of each element in the array argument.

<h4>Scalar computing  <a name="___sec24"></a></h4>

<p>
Instead of doing array computing <code>sqrt(dt*sum(e**2))</code> we can compute with
one element at a time:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(u)     <span style="color: #408080; font-style: italic"># length of u array (alt: u.size)</span>
u_e <span style="color: #666666">=</span> zeros(m)
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
    u_e[i] <span style="color: #666666">=</span> exact_solution(t, a, I)
    t <span style="color: #666666">=</span> t <span style="color: #666666">+</span> dt
e <span style="color: #666666">=</span> zeros(m)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
    e[i] <span style="color: #666666">=</span> u_e[i] <span style="color: #666666">-</span> u[i]
s <span style="color: #666666">=</span> <span style="color: #666666">0</span>  <span style="color: #408080; font-style: italic"># summation variable</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
    s <span style="color: #666666">=</span> s <span style="color: #666666">+</span> e[i]<span style="color: #666666">**2</span>
error <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span>s)
</pre></div>
<p>
Such element-wise computing, often called <em>scalar</em> computing, takes
more code, is less readable, and runs much slower than what we
can achieve with array computing.

<h3>Plotting solutions <a name="decay:plotting"></a></h3>

<p>
Having the <code>t</code> and <code>u</code> arrays, the approximate solution <code>u</code> is visualized
by the intuitive command <code>plot(t, u)</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
plot(t, u)
show()
</pre></div>

<h4>Plotting multiple curves  <a name="___sec26"></a></h4>

<p>
It will be illustrative to also plot \( \uex(t) \) for comparison. Doing a
<code>plot(t, u_e)</code> is not exactly what we want: the <code>plot</code> function draws
straight lines between the discrete points <code>(t[n], u_e[n])</code> while
\( \uex(t) \) varies as an exponential function between the mesh points.
The technique for showing the "exact" variation of \( \uex(t) \) between
the mesh points is to introduce a very fine mesh for \( \uex(t) \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)      <span style="color: #408080; font-style: italic"># fine mesh</span>
u_e <span style="color: #666666">=</span> exact_solution(t_e, I, a)
plot(t_e, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>)            <span style="color: #408080; font-style: italic"># blue line for u_e</span>
plot(t,   u,   <span style="color: #BA2121">&#39;r--o&#39;</span>)          <span style="color: #408080; font-style: italic"># red dashes w/circles</span>
</pre></div>
<p>
With more than one curve in the plot we need to associate each curve
with a legend. We also want appropriate names on the axis, a title,
and a file containing the plot as an image for inclusion in reports.
The Matplotlib package (<code>matplotlib.pyplot</code>) contains functions for
this purpose. The names of the functions are similar to the plotting
functions known from MATLAB.  A complete plot session then becomes

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

figure()                          <span style="color: #408080; font-style: italic"># create new plot</span>
t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)        <span style="color: #408080; font-style: italic"># fine mesh for u_e</span>
u_e <span style="color: #666666">=</span> exact_solution(t_e, I, a)
plot(t,   u,   <span style="color: #BA2121">&#39;r--o&#39;</span>)            <span style="color: #408080; font-style: italic"># red dashes w/circles</span>
plot(t_e, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>)              <span style="color: #408080; font-style: italic"># blue line for exact sol.</span>
legend([<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>])
xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
title(<span style="color: #BA2121">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, dt))
savefig(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (theta, dt))
show()
</pre></div>
<p>
Note that <code>savefig</code> here creates a PNG file whose name reflects the
values of \( \theta \) and \( \Delta t \) so that we can easily distinguish
files from different runs with \( \theta \) and \( \Delta t \).

<p>
A bit more sophisticated and easy-to-read filename can be generated
by mapping the \( \theta \) value to acronyms for the three common
schemes: FE (Forward Euler, \( \theta=0 \)), BE (Backward Euler, \( \theta=1 \)),
CN (Crank-Nicolson, \( \theta=0.5 \)). A Python dictionary is ideal for such
a mapping from numbers to strings:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">theta2name <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #BA2121">&#39;FE&#39;</span>, <span style="color: #666666">1</span>: <span style="color: #BA2121">&#39;BE&#39;</span>, <span style="color: #666666">0.5</span>: <span style="color: #BA2121">&#39;CN&#39;</span>}
savefig(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
</pre></div>

<h4>Experiments with computing and plotting  <a name="___sec27"></a></h4>

<p>
Let us wrap up the computation of the error measure and all the
plotting statements in a function <code>explore</code>. This function
can be called for various \( \theta \) and \( \Delta t \) values
to see how the error varies with the method and the mesh resolution:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">explore</span>(I, a, T, dt, theta<span style="color: #666666">=0.5</span>, makeplot<span style="color: #666666">=</span><span style="color: #008000">True</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Run a case with the solver, compute error measure,</span>
<span style="color: #BA2121; font-style: italic">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    u, t <span style="color: #666666">=</span> solver(I, a, T, dt, theta)    <span style="color: #408080; font-style: italic"># Numerical solution</span>
    u_e <span style="color: #666666">=</span> exact_solution(t, I, a)
    e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
    E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span><span style="color: #008000">sum</span>(e<span style="color: #666666">**2</span>))
    <span style="color: #008000; font-weight: bold">if</span> makeplot:
        figure()                         <span style="color: #408080; font-style: italic"># create new plot</span>
        t_e <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, <span style="color: #666666">1001</span>)       <span style="color: #408080; font-style: italic"># fine mesh for u_e</span>
        u_e <span style="color: #666666">=</span> exact_solution(t_e, I, a)
        plot(t,   u,   <span style="color: #BA2121">&#39;r--o&#39;</span>)           <span style="color: #408080; font-style: italic"># red dashes w/circles</span>
        plot(t_e, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>)             <span style="color: #408080; font-style: italic"># blue line for exact sol.</span>
        legend([<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>])
        xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
        title(<span style="color: #BA2121">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, dt))
        theta2name <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #BA2121">&#39;FE&#39;</span>, <span style="color: #666666">1</span>: <span style="color: #BA2121">&#39;BE&#39;</span>, <span style="color: #666666">0.5</span>: <span style="color: #BA2121">&#39;CN&#39;</span>}
        savefig(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
        savefig(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">.pdf&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
        savefig(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">.eps&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt))
        show()
    <span style="color: #008000; font-weight: bold">return</span> E
</pre></div>
<p>
The <code>figure()</code> call is key here: without it, a new <code>plot</code> command will
draw the new pair of curves in the same plot window, while we want
the different pairs to appear in separate windows and files.
Calling <code>figure()</code> ensures this.

<p>
The <code>explore</code> function stores the plot in three different image file formats:
PNG, PDF, and EPS (Encapsulated PostScript). The PNG format is aimed
at being included in HTML files, the PDF format in pdfLaTeX documents,
and the EPS format in LaTeX documents. Frequently used viewers for these
image files on Unix systems are <code>gv</code> (comes with Ghostscript)
for the PDF and EPS formats and
<code>display</code> (from the ImageMagick) suite for PNG files:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; gv BE_0.5.pdf
Terminal&gt; gv BE_0.5.eps
Terminal&gt; display BE_0.5.png
</pre></div>
<p>
The complete code containing the functions above
resides in the file <a href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py"><tt>decay_plot_mpl.py</tt></a>.
Running this program results in
<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay_plot_mpl.py
0.0   0.40:    2.105E-01
0.0   0.04:    1.449E-02
0.5   0.40:    3.362E-02
0.5   0.04:    1.887E-04
1.0   0.40:    1.030E-01
1.0   0.04:    1.382E-02
</pre></div>
<p>
We observe that reducing \( \Delta t \) by a factor of 10 increases the
accuracy for all three methods (\( \theta \) values). We also see that
the combination of \( \theta=0.5 \) and a small time step \( \Delta t =0.04 \)
gives a much more accurate solution, and that \( \theta=0 \) and \( \theta=1 \)
with \( \Delta t = 0.4 \) result in the least accurate solutions.

<p>
Figure <a href="#decay:fig:FE1">6</a> demonstrates that the numerical solution for
\( \Delta t=0.4 \) clearly lies below the exact curve, but that the
accuracy improves considerably by reducing the time step by a factor
of 10.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  The Forward Euler scheme for two values of the time step. <a name="decay:fig:FE1"></a> </p></center>
<p><img src="fig-decay/FE1.png" align="bottom" width=600,></p>
</center>

<h4>Combining plot files  <a name="___sec28"></a></h4>

<p>
Mounting two PNG files, as done in the figure, is easily done by the
<a href="http://www.imagemagick.org/script/montage.php"><tt>montage</tt></a> program
from the ImageMagick suite:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; montage -background white -geometry 100% -tile 2x1 <span style="color: #BB6622; font-weight: bold">\ </span>
          FE_0.4.png FE_0.04.png FE1.png
Terminal&gt; convert -trim FE1.png FE1.png
</pre></div>
<p>
The <code>-geometry</code> argument is used to specify the size of the image, and here
we preserve the individual sizes of the images. The <code>-tile HxV</code> option
specifies <code>H</code> images in the horizontal direction and <code>V</code> images in
the vertical direction. A series of image files to be combined are then listed,
with the name of the resulting combined image, here <code>FE1.png</code> at the end.
The <code>convert -trim</code> command removes surrounding white areas in the figure
(an operation usually known as <em>cropping</em> in image manipulation programs).

<p>
For \LaTeX{} reports it is not recommended to use <code>montage</code> and PNG files
as the result has too low resolution. Instead, plots should be made
in the PDF format and combined using the <code>pdftk</code>, <code>pdfnup</code>, and <code>pdfcrop</code> tools
(on Linux/Unix):

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; pdftk FE_0.4.png FE_0.04.png output tmp.pdf
Terminal&gt; pdfnup --nup 2x1 tmp.pdf     <span style="color: #408080; font-style: italic"># output in tmp-nup.pdf</span>
Terminal&gt; pdfcrop tmp-nup.pdf FE1.png  <span style="color: #408080; font-style: italic"># output in FE1.png</span>
</pre></div>
<p>
Here, <code>pdftk</code> combines images into a multi-page PDF file, <code>pdfnup</code>
combines the images in individual pages to a table of images (pages),
and <code>pdfcrop</code> removes white margins in the resulting combined image file.

<p>
The behavior of the two other schemes is shown in Figures <a href="#decay:fig:BE1">7</a>
and <a href="#decay:fig:CN1">8</a>. Crank-Nicolson is obviously the most accurate
scheme from this visual point of view.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  The Backward Euler scheme for two values of the time step. <a name="decay:fig:BE1"></a> </p></center>
<p><img src="fig-decay/BE1.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  The Crank-Nicolson scheme for two values of the time step. <a name="decay:fig:CN1"></a> </p></center>
<p><img src="fig-decay/CN1.png" align="bottom" width=600></p>
</center>

<h4>Plotting with SciTools  <a name="___sec29"></a></h4>

<p>
The <a href="http://code.google.com/p/scitools">SciTools package</a> provides a
unified plotting interface, called Easyviz, to many different plotting
packages, including Matplotlib, Gnuplot, Grace, MATLAB,
VTK, OpenDX, and VisIt. The syntax is very similar to that of
Matplotlib and MATLAB. In fact, the plotting commands shown above look
the same in SciTool's Easyviz interface, apart from the import
statement, which reads

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
</pre></div>
<p>
This statement performs a <code>from numpy import *</code> as well as an import
of the most common pieces of the Easyviz (<code>scitools.easyviz</code>) package,
along with some additional numerical functionality.

<p>
With Easyviz one can
merge several plotting commands into a single one
using keyword arguments:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">plot(t,   u,   <span style="color: #BA2121">&#39;r--o&#39;</span>,           <span style="color: #408080; font-style: italic"># red dashes w/circles</span>
     t_e, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>,             <span style="color: #408080; font-style: italic"># blue line for exact sol.</span>
     legend<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>],
     xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t&#39;</span>,
     ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u&#39;</span>,
     title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, dt),
     savefig<span style="color: #666666">=</span><span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">_</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> (theta2name[theta], dt),
     show<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
The <a href="http://tinyurl.com/jvzzcfn/decay/decay_plot_st.py"><tt>decay_plot_st.py</tt></a> file
contains such a demo.

<p>
By default, Easyviz employs Matplotlib for plotting, but <a href="http://www.gnuplot.info/">Gnuplot</a> and <a href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a> are viable alternatives:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend gnuplot
Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend grace
</pre></div>
<p>
The backend used for creating plots (and numerous other options)
can be permanently set in SciTool's configuration file.

<p>
All the Gnuplot windows are launched without any need to kill one before
the next one pops up (as is the case with Matplotlib) and one can
press the key 'q' anywhere in a plot window to kill it.
Another advantage of Gnuplot is the automatic choice of sensible
and distinguishable line types in black-and-white PDF and PostScript
files.

<p>
Regarding functionality for annotating plots with title, labels on the
axis, legends, etc., we refer to the documentation of Matplotlib and
SciTools for more detailed information on the syntax. The hope is that
the programming syntax explained so far suffices for understanding the
code and learning more from a combination of the forthcoming examples
and other resources such as books and web pages.

<p>
<div class="alert alert-block alert-question alert-text-normal"><b>Test the understanding.</b>
<a href="._part0005_main_decay.html#decay:app:exer:cooling:py">Exercise 2: Implement schemes for Newton's law of cooling</a> asks you to implement
a solver for a problem that is slightly different from the
one above. You may use the <code>solver</code> and <code>explore</code> functions
explained above as a starting point. Apply the new solver
to <a href="._part0005_main_decay.html#decay:app:exer:cooling:murder">Exercise 3: Find time of murder from body temperature</a>.
</div>
<h3>Creating command-line interfaces <a name="decay:commandline"></a></h3>

<p>
It is good programming practice to let programs read input from the user
rather than require the user to edit the source code when trying out
new values of input parameters.
Reading input from the command line is a simple and flexible way of interacting
with the user. Python stores all the command-line arguments in
the list <code>sys.argv</code>, and there are, in principle, two ways of programming with
command-line arguments in Python:

<p>

<ul>
 <li> Decide upon a sequence of parameters on the command line and read
   their values directly from the <code>sys.argv[1:]</code> list (<code>sys.argv[0]</code> is
   the just program name).</li>
 <li> Use option-value pairs (<code>--option value</code>) on
   the command line to override default values of input parameters,
   and utilize the <code>argparse.ArgumentParser</code> tool to interact with
   the command line.</li>
</ul>

Both strategies will be illustrated next.

<h4>Reading a sequence of command-line arguments  <a name="___sec31"></a></h4>

<p>
The <a href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py"><tt>decay_plot_mpl.py</tt></a>
program needs the following input data: \( I \), \( a \), \( T \), an option to
turn the plot on or off (<code>makeplot</code>), and a list of \( \Delta t \) values.

<p>
The simplest way of reading this input from the command line is to say
that the first four command-line arguments correspond to the first
four points in the list above, in that order, and that the rest of the
command-line arguments are the \( \Delta t \) values.  The input given for
<code>makeplot</code> can be a string among <code>'on'</code>, <code>'off'</code>, <code>'True'</code>, and
<code>'False'</code>. The code for reading this input is most conveniently put in
a function:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_command_line</span>():
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(sys<span style="color: #666666">.</span>argv) <span style="color: #666666">&lt;</span> <span style="color: #666666">6</span>:
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Usage: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> I a T on/off dt1 dt2 dt3 ...&#39;</span> <span style="color: #666666">%</span> \ 
              sys<span style="color: #666666">.</span>argv[<span style="color: #666666">0</span>]; sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># abort</span>

    I <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
    a <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">2</span>])
    T <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">3</span>])
    makeplot <span style="color: #666666">=</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">4</span>] <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #BA2121">&#39;on&#39;</span>, <span style="color: #BA2121">&#39;True&#39;</span>)
    dt_values <span style="color: #666666">=</span> [<span style="color: #008000">float</span>(arg) <span style="color: #008000; font-weight: bold">for</span> arg <span style="color: #AA22FF; font-weight: bold">in</span> sys<span style="color: #666666">.</span>argv[<span style="color: #666666">5</span>:]]

    <span style="color: #008000; font-weight: bold">return</span> I, a, T, makeplot, dt_values
</pre></div>
<p>
One should note the following about the constructions in the program above:

<p>

<ul>
  <li> Everything on the command line ends up in a <em>string</em> in
    the list <code>sys.argv</code>. Explicit conversion to, e.g., a <code>float</code> object is
    required if the string as a number we want to compute with.</li>
  <li> The value of <code>makeplot</code> is determined from a boolean expression,
    which becomes <code>True</code> if the command-line argument is either <code>'on'</code> or
    <code>'True'</code>, and <code>False</code> otherwise.</li>
  <li> It is easy to build the list of \( \Delta t \) values: we simply run through
    the rest of the list, <code>sys.argv[5:]</code>, convert each command-line argument
    to <code>float</code>, and collect these <code>float</code> objects in a list, using the
    compact and convenient <em>list comprehension</em> syntax in Python.</li>
</ul>

The loops over \( \theta \) and \( \Delta t \) values can be coded in a <code>main</code> function:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    I, a, T, makeplot, dt_values <span style="color: #666666">=</span> read_command_line()
    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>:
        <span style="color: #008000; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values:
            E <span style="color: #666666">=</span> explore(I, a, T, dt, theta, makeplot)
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%3.1f</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%6.2f</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%12.3E</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, dt, E)
</pre></div>
<p>
The complete program can be found in <a href="http://tinyurl.com/jvzzcfn/decay/decay_cml.py"><tt>decay_cml.py</tt></a>.

<h4>Working with an argument parser  <a name="___sec32"></a></h4>

<p>
Python's <code>ArgumentParser</code> tool in the <code>argparse</code> module makes it
easy to create a professional command-line interface to any
program. The documentation of <a href="http://docs.python.org/library/argparse.html"><tt>ArgumentParser</tt></a> demonstrates its
versatile applications, so we shall here just list an example
containing basic features.  On the command line we want to
specify option-value pairs for \( I \), \( a \), and \( T \), e.g., <code>--a 3.5 --I 2
--T 2</code>. Including <code>--makeplot</code> turns the plot on and excluding this
option turns the plot off.  The \( \Delta t \) values can be given as
<code>--dt 1 0.5 0.25 0.1 0.01</code>.  Each parameter must have a sensible
default value so that we specify the option on the command line only
when the default value is not suitable.

<p>
We introduce a function for defining the mentioned command-line options:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">define_command_line_options</span>():
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">argparse</span>
    parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser()
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--I&#39;</span>, <span style="color: #BA2121">&#39;--initial_condition&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>,
                        default<span style="color: #666666">=1.0</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&#39;initial condition, u(0)&#39;</span>,
                        metavar<span style="color: #666666">=</span><span style="color: #BA2121">&#39;I&#39;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--a&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>,
                        default<span style="color: #666666">=1.0</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&#39;coefficient in ODE&#39;</span>,
                        metavar<span style="color: #666666">=</span><span style="color: #BA2121">&#39;a&#39;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--T&#39;</span>, <span style="color: #BA2121">&#39;--stop_time&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>,
                        default<span style="color: #666666">=1.0</span>, help<span style="color: #666666">=</span><span style="color: #BA2121">&#39;end time of simulation&#39;</span>,
                        metavar<span style="color: #666666">=</span><span style="color: #BA2121">&#39;T&#39;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--makeplot&#39;</span>, action<span style="color: #666666">=</span><span style="color: #BA2121">&#39;store_true&#39;</span>,
                        help<span style="color: #666666">=</span><span style="color: #BA2121">&#39;display plot or not&#39;</span>)
    parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--dt&#39;</span>, <span style="color: #BA2121">&#39;--time_step_values&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>,
                        default<span style="color: #666666">=</span>[<span style="color: #666666">1.0</span>], help<span style="color: #666666">=</span><span style="color: #BA2121">&#39;time step values&#39;</span>,
                        metavar<span style="color: #666666">=</span><span style="color: #BA2121">&#39;dt&#39;</span>, nargs<span style="color: #666666">=</span><span style="color: #BA2121">&#39;+&#39;</span>, dest<span style="color: #666666">=</span><span style="color: #BA2121">&#39;dt_values&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> parser
</pre></div>
<p>
Each command-line option is defined through the <code>parser.add_argument</code>
method. Alternative options, like the short <code>--I</code> and the more
explaining version <code>--initial_condition</code> can be defined. Other arguments
are <code>type</code> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <code>-h</code> or <code>--help</code> is
included. The <code>metavar</code> argument specifies the value associated with
the option when the help string is printed. For example, the option for
\( I \) has this help output:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay_argparse.py -h
  ...
  --I I, --initial_condition I
                        initial condition, u<span style="color: #666666">(</span>0<span style="color: #666666">)</span>
  ...
</pre></div>
<p>
The structure of this output is

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  --I metavar, --initial_condition metavar
                        help-string
</pre></div>
<p>
The <code>--makeplot</code> option is a pure flag without any value, implying a
true value if the flag is present and otherwise a false value. The
<code>action='store_true'</code> makes an option for such a flag.

<p>
Finally, the <code>--dt</code> option demonstrates how to allow for more than one
value (separated by blanks) through the <code>nargs='+'</code> keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the <code>dist</code> keyword argument, which for the <code>--dt</code> option is
<code>dt_values</code>. Without the <code>dest</code> argument, the value of an option <code>--opt</code>
is stored as the attribute <code>opt</code>.

<p>
The code below demonstrates how to read the command line and extract
the values for each option:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_command_line</span>():
    parser <span style="color: #666666">=</span> define_command_line_options()
    args <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args()
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;I={}, a={}, T={}, makeplot={}, dt_values={}&#39;</span><span style="color: #666666">.</span>format(
        args<span style="color: #666666">.</span>I, args<span style="color: #666666">.</span>a, args<span style="color: #666666">.</span>T, args<span style="color: #666666">.</span>makeplot, args<span style="color: #666666">.</span>dt_values)
    <span style="color: #008000; font-weight: bold">return</span> args<span style="color: #666666">.</span>I, args<span style="color: #666666">.</span>a, args<span style="color: #666666">.</span>T, args<span style="color: #666666">.</span>makeplot, args<span style="color: #666666">.</span>dt_values
</pre></div>
<p>
The <code>main</code> function remains the same as in the <code>decay_cml.py</code> code based
on reading from <code>sys.argv</code> directly. A complete program featuring the
demo above of <code>ArgumentParser</code> appears in the file <a href="http://tinyurl.com/jvzzcfn/decay/decay_argparse.py"><tt>decay_argparse.py</tt></a>.

<h3>Creating a graphical web user interface  <a name="___sec33"></a></h3>

<p>
The Python package <a href="https://github.com/hplgit/parampool">Parampool</a>
can be used to automatically generate a web-based <em>graphical user interface</em>
(GUI) for our simulation program. Although the programming technique
dramatically simplifies the efforts to create a GUI, the forthcoming
material on equipping our <code>decay_mod</code> module with a GUI is quite technical
and of significantly less importance than knowing how to make
a command-line interface (the section <a href="#decay:commandline">Creating command-line interfaces</a>).
There is no danger in jumping right to the section <a href="#decay:convergence:rate">Computing convergence rates</a>.

<h4>Making a compute function  <a name="___sec34"></a></h4>

<p>
The first step is to identify a function
that performs the computations and that takes the necessary input
variables as arguments. This is called the <em>compute function</em> in
Parampool terminology. We may start with a copy of the basic file
<a href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py"><tt>decay_plot_mpl.py</tt></a>,
which has a <code>main</code> function displayed in
the section <a href="#decay:plotting">Plotting solutions</a> for carrying out simulations and plotting
for a series of \( \Delta t \) values. Now we want to control and view the same
experiments from a web GUI.

<p>
To tell Parampool what type of input data we have,
we assign default values of the right type to all arguments in the
main function and call it <code>main_GUI</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main_GUI</span>(I<span style="color: #666666">=1.0</span>, a<span style="color: #666666">=.2</span>, T<span style="color: #666666">=4.0</span>,
         dt_values<span style="color: #666666">=</span>[<span style="color: #666666">1.25</span>, <span style="color: #666666">0.75</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0.1</span>],
         theta_values<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>]):
</pre></div>
<p>
The compute function must return the HTML code we want for displaying
the result in a web page. Here we want to show plots of the numerical
and exact solution for different methods and \( \Delta t \) values.
The plots can be organized in a table with \( \theta \) (methods) varying
through the columns and \( \Delta t \) varying through the rows.
Assume now that a new version of the <code>explore</code> function
not only returns the error <code>E</code> but also HTML code containing the
plot. Then we can write the <code>main_GUI</code> function as

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main_GUI</span>(I<span style="color: #666666">=1.0</span>, a<span style="color: #666666">=.2</span>, T<span style="color: #666666">=4.0</span>,
         dt_values<span style="color: #666666">=</span>[<span style="color: #666666">1.25</span>, <span style="color: #666666">0.75</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0.1</span>],
         theta_values<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>]):
    <span style="color: #408080; font-style: italic"># Build HTML code for web page. Arrange plots in columns</span>
    <span style="color: #408080; font-style: italic"># corresponding to the theta values, with dt down the rows</span>
    theta2name <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #BA2121">&#39;FE&#39;</span>, <span style="color: #666666">1</span>: <span style="color: #BA2121">&#39;BE&#39;</span>, <span style="color: #666666">0.5</span>: <span style="color: #BA2121">&#39;CN&#39;</span>}
    html_text <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;&lt;table&gt;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>
    <span style="color: #008000; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values:
        html_text <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;&lt;tr&gt;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>
        <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> theta_values:
            E, html <span style="color: #666666">=</span> explore(I, a, T, dt, theta, makeplot<span style="color: #666666">=</span><span style="color: #008000">True</span>)
            html_text <span style="color: #666666">+=</span> <span style="color: #BA2121">&quot;&quot;&quot;</span>
<span style="color: #BA2121">&lt;td&gt;</span>
<span style="color: #BA2121">&lt;center&gt;&lt;b&gt;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, error: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&lt;/b&gt;&lt;/center&gt;&lt;br&gt;</span>
<span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"></span>
<span style="color: #BA2121">&lt;/td&gt;</span>
<span style="color: #BA2121">&quot;&quot;&quot;</span> <span style="color: #666666">%</span> (theta2name[theta], dt, E, html)
        html_text <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;&lt;/tr&gt;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>
    html_text <span style="color: #666666">+=</span> <span style="color: #BA2121">&#39;&lt;/table&gt;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span>
    <span style="color: #008000; font-weight: bold">return</span> html_text
</pre></div>
<p>
Rather than creating plot files and showing the plot on the screen,
the new version of the <code>explore</code> function makes a string with the PNG code of
the plot and embeds that string in HTML code. This action is
conveniently performed by Parampool's <code>save_png_to_str</code> function:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #666666">...</span>
<span style="color: #408080; font-style: italic"># plot</span>
plt<span style="color: #666666">.</span>plot(t, u, r<span style="color: #666666">-</span><span style="color: #BA2121">&#39;)</span>
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
<span style="color: #666666">...</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parampool.utils</span> <span style="color: #008000; font-weight: bold">import</span> save_png_to_str
html_text <span style="color: #666666">=</span> save_png_to_str(plt, plotwidth<span style="color: #666666">=400</span>)
</pre></div>
<p>
Note that we now write <code>plt.plot</code>, <code>plt.xlabel</code>, etc.
The <code>html_text</code> string is long and contains all the characters that
build up the PNG file of the current plot. The new <code>explore</code>
function can make use of the above code snippet and return
<code>html_text</code> along with <code>E</code>.

<h4>Generating the user interface  <a name="___sec35"></a></h4>

<p>
The web GUI is automatically generated by
the following code, placed in a file <a href="http://tinyurl.com/jvzzcfn/decay/decay_GUI_generate.py"><tt>decay_GUI_generate.py</tt></a>

<p>

<!-- code=python (from !bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">parampool.generator.flask</span> <span style="color: #008000; font-weight: bold">import</span> generate
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay_GUI</span> <span style="color: #008000; font-weight: bold">import</span> main
generate(main,
         output_controller<span style="color: #666666">=</span><span style="color: #BA2121">&#39;decay_GUI_controller.py&#39;</span>,
         output_template<span style="color: #666666">=</span><span style="color: #BA2121">&#39;decay_GUI_view.py&#39;</span>,
         output_model<span style="color: #666666">=</span><span style="color: #BA2121">&#39;decay_GUI_model.py&#39;</span>)
</pre></div>
<p>
Running the <code>decay_GUI_generate.py</code> program results in three new
files whose names are specified in the call to <code>generate</code>:

<p>

<ol>
 <li> <code>decay_GUI_model.py</code> defines HTML widgets to be used to set
    input data in the web interface,</li>
 <li> <code>templates/decay_GUI_views.py</code> defines the layout of the web page,</li>
 <li> <code>decay_GUI_controller.py</code> runs the web application.</li>
</ol>

We only need to run the last program, and there is no need to look into
these files.

<h4>Running the web application  <a name="___sec36"></a></h4>

<p>
The web GUI is started by

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay_GUI_controller.py
</pre></div>
<p>
Open a web browser at the location <code>127.0.0.1:5000</code>. Input fields for
<code>I</code>, <code>a</code>, <code>T</code>, <code>dt_values</code>, and <code>theta_values</code> are presented.
Setting the latter two to <code>[1.25, 0.5]</code> and <code>[1, 0.5]</code>,
respectively, and pressing <em>Compute</em> results in four plots, see
Figure <a href="#decay:fig:GUI">9</a>. With the techniques demonstrated here, one
can easily create a tailored web GUI for a particular type of application
and use it to interactively explore physical and numerical effects.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Automatically generated graphical web interface. <a name="decay:fig:GUI"></a> </p></center>
<p><img src="fig-decay/decay_GUI.png" align="bottom" width=800></p>
</center>

<h3>Computing convergence rates <a name="decay:convergence:rate"></a></h3>

<p>
We expect that the error \( E \) in the numerical solution is
reduced if the mesh size \( \Delta t \) is decreased. More specifically,
many numerical methods obey a power-law relation between \( E \) and
\( \Delta t \):

<p>
$$
\begin{equation}
E = C\Delta t^r,
\tag{41}
\end{equation}
$$

where \( C \) and \( r \) are (usually unknown) constants independent of \( \Delta t \).
The formula <a href="#mjx-eqn-41">(41)</a> is viewed as an asymptotic model valid for
sufficiently small \( \Delta t \). How small is normally hard to estimate
without doing numerical estimations of \( r \).

<p>
The parameter \( r \) is known as the <em>convergence rate</em>. For example,
if the convergence rate is 2, halving \( \Delta t \) reduces the error by
a factor of 4. Diminishing \( \Delta t \) then has a greater impact on
the error compared with methods that have \( r=1 \). For a given value of \( r \),
we refer to the method as of \( r \)-th order. First- and second-order
methods are most common in scientific computing.

<h4>Estimating \( r \)  <a name="___sec38"></a></h4>

<p>
There are two alternative ways of estimating \( C \) and \( r \) based on a set of
\( m \) simulations with corresponding pairs \( (\Delta t_i, E_i) \), \( i=0,\ldots,m-1 \),
and \( \Delta t_{i} < \Delta t_{i-1} \) (i.e., decreasing cell size).

<p>

<ol>
 <li> Take the logarithm of <a href="#mjx-eqn-41">(41)</a>, \( \ln E = r\ln \Delta t + \ln C \),
    and fit a straight line to the data points \( (\Delta t_i, E_i) \),
    \( i=0,\ldots,m-1 \).</li>
 <li> Consider two consecutive experiments, \( (\Delta t_i, E_i) \) and
    \( (\Delta t_{i-1}, E_{i-1}) \). Dividing the equation
    \( E_{i-1}=C\Delta t_{i-1}^r \) by \( E_{i}=C\Delta t_{i}^r \) and solving
    for \( r \) yields</li>
</ol>

$$
\begin{equation}
r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}
\tag{42}
\end{equation}
$$

for \( i=1,\ldots,m-1 \).

<p>
The disadvantage of method 1 is that <a href="#mjx-eqn-41">(41)</a> might not be valid
for the coarsest meshes (largest \( \Delta t \) values). Fitting a line
to all the data points is then misleading.  Method 2 computes
convergence rates for pairs of experiments and allows us to see
if the sequence \( r_i \) converges to some value as \( i\rightarrow m-2 \).
The final \( r_{m-2} \) can then be taken as the convergence rate.
If the coarsest meshes have a differing rate, the corresponding
time steps are probably too large for <a href="#mjx-eqn-41">(41)</a> to be valid.
That is, those time steps lie outside the asymptotic range of
\( \Delta t \) values where the error behaves like <a href="#mjx-eqn-41">(41)</a>.

<h4>Implementation  <a name="___sec39"></a></h4>

<p>
It is straightforward to extend the <code>main</code> function in the program
<code>decay_argparse.py</code> with statements for computing \( r_0, r_1, \ldots, r_{m-2} \)
from <a href="#mjx-eqn-41">(41)</a>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> log

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    I, a, T, makeplot, dt_values <span style="color: #666666">=</span> read_command_line()
    r <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># estimated convergence rates</span>
    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>:
        E_values <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values:
            E <span style="color: #666666">=</span> explore(I, a, T, dt, theta, makeplot<span style="color: #666666">=</span><span style="color: #008000">False</span>)
            E_values<span style="color: #666666">.</span>append(E)

        <span style="color: #408080; font-style: italic"># Compute convergence rates</span>
        m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(dt_values)
        r[theta] <span style="color: #666666">=</span> [log(E_values[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>E_values[i])<span style="color: #666666">/</span>
                    log(dt_values[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>dt_values[i])
                    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, m, <span style="color: #666666">1</span>)]

    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> r:
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">Pairwise convergence rates for theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">:&#39;</span> <span style="color: #666666">%</span> theta
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39; &#39;</span><span style="color: #666666">.</span>join([<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> r_ <span style="color: #008000; font-weight: bold">for</span> r_ <span style="color: #AA22FF; font-weight: bold">in</span> r[theta]])
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
The program containing this <code>main</code> function is called <a href="http://tinyurl.com/jvzzcfn/decay/decay_convrate.py"><tt>decay_convrate.py</tt></a>.

<p>
The <code>r</code> object is a <em>dictionary of lists</em>. The keys in this
dictionary are the \( \theta \) values. For example,
<code>r[1]</code> holds the list of the \( r_i \) values corresponding to
\( \theta=1 \). In the loop <code>for theta in r</code>, the loop variable <code>theta</code>
takes on the values of the keys in the dictionary <code>r</code> (in an
undetermined ordering). We could simply do a <code>print r[theta]</code>
inside the loop, but this would typically yield output of
the convergence rates with 16 decimals:

<p>

<!-- code=text (from !bc dat) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">[1.331919482274763, 1.1488178494691532, ...]
</pre></div>
<p>
Instead, we format each number with 2 decimals, using a list
comprehension to turn the list of numbers, <code>r[theta]</code>, into
a list of formatted strings. Then we join these strings
with a space in between to get a sequence of rates on one line
in the terminal window. More generally, <code>d.join(list)</code> joins the
strings in the list <code>list</code> to one string, with <code>d</code>
as delimiter between <code>list[0]</code>, <code>list[1]</code>, etc.

<p>
Here is an example on the outcome of the convergence rate computations:
<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay_convrate.py --dt 0.5 0.25 0.1 0.05 0.025 0.01
...
Pairwise convergence rates <span style="color: #008000; font-weight: bold">for </span><span style="color: #19177C">theta</span><span style="color: #666666">=</span>0:
1.33 1.15 1.07 1.03 1.02

Pairwise convergence rates <span style="color: #008000; font-weight: bold">for </span><span style="color: #19177C">theta</span><span style="color: #666666">=</span>0.5:
2.14 2.07 2.03 2.01 2.01

Pairwise convergence rates <span style="color: #008000; font-weight: bold">for </span><span style="color: #19177C">theta</span><span style="color: #666666">=</span>1:
0.98 0.99 0.99 1.00 1.00
</pre></div>
<p>
The Forward and Backward Euler methods seem to have an \( r \) value which
stabilizes at 1, while the Crank-Nicolson seems to be a second-order
method with \( r=2 \).

<p>
Very often, we have some theory that predicts what \( r \) is for a numerical
method. Various theoretical error measures for the \( \theta \)-rule point to
\( r=2 \) for \( \theta =0.5 \) and \( r=1 \) otherwise. The computed estimates of \( r \) are
in very good agreement with these theoretical values.

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Why convergence rates are important.</b>
The strong practical application of computing convergence rates is for
verification: wrong convergence rates point to errors in the code, and
correct convergence rates brings evidence that the implementation is
correct. Experience shows that bugs in the code easily destroy the
expected convergence rate.
</div>
<h4>Debugging via convergence rates  <a name="___sec40"></a></h4>

<p>
Let us experiment with bugs and see the implication on the convergence
rate. We may, for instance, forget to multiply by <code>a</code> in the denominator
in the updating formula for <code>u[n+1]</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt)<span style="color: #666666">*</span>u[n]
</pre></div>
<p>
Running the same <code>decay_convrate.py</code> command as above gives the expected
convergence rates (!). Why? The reason is that we just specified
the \( \Delta t \) values are relied on default values for other
parameters. The default value of \( a \) is 1. Forgetting the factor
<code>a</code> has then no effect. This example shows how important it is to
avoid parameters that are 1 or 0 when verifying implementations.
Running the code <code>decay_v0.py</code> with \( a=2.1 \) and \( I=0.1 \) yields

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay_convrate.py --a 2.1 --I 0.1  <span style="color: #BB6622; font-weight: bold">\ </span>
          --dt 0.5 0.25 0.1 0.05 0.025 0.01
...
Pairwise convergence rates <span style="color: #008000; font-weight: bold">for </span><span style="color: #19177C">theta</span><span style="color: #666666">=</span>0:
1.49 1.18 1.07 1.04 1.02

Pairwise convergence rates <span style="color: #008000; font-weight: bold">for </span><span style="color: #19177C">theta</span><span style="color: #666666">=</span>0.5:
-1.42 -0.22 -0.07 -0.03 -0.01

Pairwise convergence rates <span style="color: #008000; font-weight: bold">for </span><span style="color: #19177C">theta</span><span style="color: #666666">=</span>1:
0.21 0.12 0.06 0.03 0.01
</pre></div>
<p>
This time we see that the expected convergence rates for the Crank-Nicolson and
Backward Euler methods are not obtained, while \( r=1 \) for the Forward Euler
method. The reason for correct rate in the latter case is that \( \theta=0 \)
and the wrong <code>theta*dt</code> term in the denominator vanishes anyway.

<p>
The error

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[n]
</pre></div>
<p>
manifests itself through wrong rates \( r\approx 0 \) for all three methods.
About the same results arise from an erroneous initial condition, <code>u[0] = 1</code>,
or wrong loop limits, <code>range(1,Nt)</code>. It seems that in this simple
problem, most bugs we can think of are detected by the convergence rate
test, provided the values of the input data do not hide the bug.

<p>
A <code>verify_convergence_rate</code> function could compute the dictionary of
list via <code>main</code> and check if the final rate estimates (\( r_{m-2} \))
are sufficiently close to the expected ones. A tolerance of 0.1
seems appropriate, given the uncertainty in estimating \( r \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">verify_convergence_rate</span>():
    r <span style="color: #666666">=</span> main()
    tol <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    expected_rates <span style="color: #666666">=</span> {<span style="color: #666666">0</span>: <span style="color: #666666">1</span>, <span style="color: #666666">1</span>: <span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>: <span style="color: #666666">2</span>}
    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> r:
        r_final <span style="color: #666666">=</span> r[theta][<span style="color: #666666">-1</span>]
        diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected_rates[theta] <span style="color: #666666">-</span> r_final)
        <span style="color: #008000; font-weight: bold">if</span> diff <span style="color: #666666">&gt;</span> tol:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">False</span>
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">True</span>  <span style="color: #408080; font-style: italic"># all tests passed</span>
</pre></div>
<p>
We remark that <code>r[theta]</code> is a list and the last element in any list
can be extracted by the index <code>-1</code>.

<h3>Memory-saving implementation  <a name="___sec41"></a></h3>

<p>
The computer memory requirements of our implementations so far consists
mainly of the <code>u</code> and <code>t</code> arrays, both of length \( N_t+1 \), plus some other
temporary arrays that Python needs for intermediate results if we do
array arithmetics in our program (e.g., <code>I*exp(-a*t)</code> needs to store
<code>a*t</code> before <code>-</code> can be applied to it and then <code>exp</code>).  The
extremely modest storage requirements of simple ODE problems put no
restrictions on the formulations of the algorithm and implementation.
Nevertheless, when the methods for ODEs used here are applied to
three-dimensional partial differential equation (PDE) problems,
memory storage requirements
suddenly become an issue.

<p>
The PDE counterpart to our model problem
\( u'=-a \) is a diffusion equation \( u_t = a\nabla^2 u \) posed on a
space-time domain. The discrete representation of this domain may in
3D be a spatial mesh of \( M^3 \) points and a time mesh of \( N_t \) points. A
typical desired value for \( M \) is 100 in many applications, or even
\( 1000 \).  Storing all the computed \( u \) values, like we have done in the
programs so far, demands storage of some arrays of size \( M^3N_t \), giving
a factor of \( M^3 \) larger storage demands compared to our ODE
programs. Each real number in the array for \( u \) requires 8 bytes (b) of
storage. With \( M=100 \) and \( N_t=1000 \), there is a storage demand of
\( (10^3)^3\cdot 1000\cdot 8 = 8 \) Gb for the solution array.
Fortunately, we can usually get rid of the \( N_t \)
factor, resulting in 8 Mb of storage.
Below we explain how this is done, and the technique is almost
always applied in implementations of PDE problems.

<p>
<!-- Fortunately, the methods we use to solve ODEs -->
<!-- and PDEs were mostly developed in a time where the size of a computer's -->
<!-- memory was very small compared to today's standards, and researchers -->
<!-- were therefore forced to always minimize the memory usage. As a result of -->
<!-- these circumstances, there is still a very strong focus on reducing -->
<!-- memory requirements in scientific computing algorithms. -->

<p>
Let us critically evaluate how much we really need to store in the
computer's memory in our implementation of the \( \theta \) method. To
compute a new \( u^{n+1} \), all we need is \( u^n \). This implies that the
previous \( u^{n-1},u^{n-2},\dots,u^0 \) values do not need to be stored
in an array, although this is convenient for plotting and data
analysis in the program.  Instead of the <code>u</code> array we can work with
two variables for real numbers, <code>u</code> and <code>u_1</code>, representing
\( u^{n+1} \) and \( u^n \) in the algorithm, respectively.  At each time
level, we update <code>u</code> from <code>u_1</code> and then set <code>u_1 = u</code> so that the
computed \( u^{n+1} \) value becomes the "previous" value \( u^n \) at the
next time level. The downside is that we cannot plot the solution
after the simulation is done since only the last two numbers are
available.  The remedy is to store computed values in a file and use
the file for visualizing the solution later.

<p>
We have implemented this memory saving idea in the file <a href="http://tinyurl.com/jvzzcfn/decay/decay_memsave.py"><tt>decay_memsave.py</tt></a>, which is a
merge of the <a href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py"><tt>decay_plot_mpl.py</tt></a> and
<a href="http://tinyurl.com/jvzzcfn/decay/decay_argparse.py"><tt>decay_argparse.py</tt></a>
programs, using module prefixes <code>np</code> for <code>numpy</code> and <code>plt</code> for
<code>matplotlib.pyplot</code>.

<p>
The following function demonstrates how we work with the two most
recent values of the unknown:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_memsave</span>(I, a, T, dt, theta, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;sol.dat&#39;</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span style="color: #BA2121; font-style: italic">    Minimum use of memory. The solution is stored in a file</span>
<span style="color: #BA2121; font-style: italic">    (with name filename) for later plotting.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)         <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))  <span style="color: #408080; font-style: italic"># no of intervals</span>

    outfile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;w&#39;</span>)
    <span style="color: #408080; font-style: italic"># u: time level n+1, u_1: time level n</span>
    t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u_1 <span style="color: #666666">=</span> I
    outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%.16E</span><span style="color: #BA2121">  </span><span style="color: #BB6688; font-weight: bold">%.16E</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, u_1))
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt<span style="color: #666666">+1</span>):
        u <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u_1
        u_1 <span style="color: #666666">=</span> u
        t <span style="color: #666666">+=</span> dt
        outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%.16E</span><span style="color: #BA2121">  </span><span style="color: #BB6688; font-weight: bold">%.16E</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (t, u))
    outfile<span style="color: #666666">.</span>close()
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>
<p>
This code snippet serves as a quick introduction to file writing in Python.
Reading the data in the file into arrays <code>t</code> and <code>u</code> are done by the
function

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_file</span>(filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;sol.dat&#39;</span>):
    infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(filename, <span style="color: #BA2121">&#39;r&#39;</span>)
    u <span style="color: #666666">=</span> [];  t <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> infile:
        words <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split()
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(words) <span style="color: #666666">!=</span> <span style="color: #666666">2</span>:
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Found more than two numbers on a line!&#39;</span>, words
            sys<span style="color: #666666">.</span>exit(<span style="color: #666666">1</span>)  <span style="color: #408080; font-style: italic"># abort</span>
        t<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(words[<span style="color: #666666">0</span>]))
        u<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(words[<span style="color: #666666">1</span>]))
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>array(t), np<span style="color: #666666">.</span>array(u)
</pre></div>
<p>
This type of file with numbers in rows and columns is very common, and
<code>numpy</code> has a function <code>loadtxt</code> which loads such tabular data into a
two-dimensional array, say with name <code>data</code>. The number in row <code>i</code> and
column <code>j</code> is then <code>data[i,j]</code>.  The whole column number <code>j</code> can be
extracted by <code>data[:,j]</code>.  A version of <code>read_file</code> using <code>np.loadtxt</code>
reads

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">read_file_numpy</span>(filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;sol.dat&#39;</span>):
    data <span style="color: #666666">=</span> np<span style="color: #666666">.</span>loadtxt(filename)
    t <span style="color: #666666">=</span> data[:,<span style="color: #666666">0</span>]
    u <span style="color: #666666">=</span> data[:,<span style="color: #666666">1</span>]
    <span style="color: #008000; font-weight: bold">return</span> t, u
</pre></div>
<p>
The present counterpart to the <code>explore</code> function from
<a href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py"><tt>decay_plot_mpl.py</tt></a> must run
<code>solver_memsave</code> and then load data from file before we can compute
the error measure and make the plot:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">explore</span>(I, a, T, dt, theta<span style="color: #666666">=0.5</span>, makeplot<span style="color: #666666">=</span><span style="color: #008000">True</span>):
    filename <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;u.dat&#39;</span>
    u, t <span style="color: #666666">=</span> solver_memsave(I, a, T, dt, theta, filename)

    t, u <span style="color: #666666">=</span> read_file(filename)
    u_e <span style="color: #666666">=</span> exact_solution(t, I, a)
    e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
    E <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(dt<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sum(e<span style="color: #666666">**2</span>))
    <span style="color: #008000; font-weight: bold">if</span> makeplot:
        plt<span style="color: #666666">.</span>figure()
        <span style="color: #666666">...</span>
</pre></div>
<p>
The <a href="http://tinyurl.com/jvzzcfn/decay/decay_memsave.py"><tt>decay_memsave.py</tt></a>
file also includes command-line options <code>--I</code>, <code>--a</code>, <code>--T</code>, <code>--dt</code>,
<code>--theta</code>, and <code>--makeplot</code> for controlling input parameters and
making a single run.  For example,

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python decay_memsave.py --T 10 --theta 1 --dt 2
</pre></div>
<p>
results in the output

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">I=1.0, a=1.0, T=10.0, makeplot=True, theta=1.0, dt=2.0
theta=1.0 dt=2 Error=3.136E-01
</pre></div>
<p>
<p>
<!-- begin bottom navigation -->
<a href="._part0001_main_decay.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0003_main_decay.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

