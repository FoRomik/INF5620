<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study Guide: Introduction to Finite Element Methods">
<meta name="keywords" content="approximation of general vectors,Galerkin method,projection,approximation of functions,approximation by sines,collocation method (approximation),approximation collocation,Lagrange (interpolating) polynomial,sparse matrices,trial function,test function,trial space,test space,integration by parts,mixed finite elements">







<!-- deck.js: https://github.com/imakewebthings/deck.js -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=1024, user-scalable=no">

<!-- Required stylesheet -->
<link rel="stylesheet" href="deck.js/core/deck.core.css">

<!-- Extension CSS files go here. Remove or add as needed.
deck.goto: Adds a shortcut key to jump to any slide number.
Hit g, type in the slide number, and hit enter.

deck.hash: Enables internal linking within slides, deep
linking to individual slides, and updates the address bar and
a permalink anchor with each slide change.

deck.menu: Adds a menu view, letting you see all slides in a grid.
Hit m to toggle to menu view, continue navigating your deck,
and hit m to return to normal view. Touch devices can double-tap
the deck to switch between views.

deck.navigation: Adds clickable left and right buttons for the
less keyboard inclined.

deck.status: Adds a page number indicator. (current/total).

deck.scale: Scales each slide to fit within the deck container
using CSS Transforms for those browsers that support them.

deck.pointer: Turn mouse into laser pointer (toggle with p).
(Requires https://github.com/mikeharris100/deck.pointer.js)
-->

<link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
<link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
<link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">
<link rel="stylesheet" href="deck.js/extensions/pointer/deck.pointer.css">
<link rel="stylesheet" href="deck.js/extensions/notes/deck.notes.css">
<!--
<link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
<link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
<link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
-->

<!-- Style theme. More available in themes/style/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">

<!--
<link rel="stylesheet" href="deck.js/themes/style/neon.css">
<link rel="stylesheet" href="deck.js/themes/style/swiss.css">
<link rel="stylesheet" href="deck.js/themes/style/web-2.0.css">

git clone git://github.com/duijf/mnml.git
<link rel="stylesheet" href="deck.js/themes/style/mnml.css">

git://github.com/groovecoder/deckjs-theme-mozilla.git
<link rel="stylesheet" href="deck.js/themes/style/sandstone.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.aurora.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.dark.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.firefox.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.light.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.mdn.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.nightly.css">

git://github.com/barraq/deck.ext.js.git
<link rel="stylesheet" href="deck.js/themes/style/beamer.css">
-->

<!-- Transition theme. More available in /themes/transition/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
<!--
<link rel="stylesheet" href="deck.js/themes/transition/fade.css">
<link rel="stylesheet" href="deck.js/themes/transition/vertical-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
-->

<!-- Required Modernizr file -->
<script src="deck.js/modernizr.custom.js"></script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .slide .alert-text-small   { font-size: 80%;  }
    .slide .alert-text-large   { font-size: 130%; }
    .slide .alert-text-normal  { font-size: 90%;  }
    .slide .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
               -webkit-border-radius:14px; -moz-border-radius:14px;
             border-radius:14px
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .slide .alert-block {padding-top:14px; padding-bottom:14px}
     .slide .alert-block > p, .alert-block > ul {margin-bottom:0}
     /*.slide .alert li {margin-top: 1em}*/
     .deck .alert-block p+p {margin-top:5px}
     /*.slide .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_notice.png); }
     .slide .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_summary.png); }
     .slide .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_warning.png); }
     .slide .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body class="deck-container">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
%\newcommand{\If}{\mathcal{I}}     % for FEM
\newcommand{\If}{I}     % for FEM
%\newcommand{\Ifd}{\mathcal{I}_d}  % for FEM
\newcommand{\Ifd}{I_d}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    



<section class="slide">
<!-- ------------------- main content ---------------------- -->


<title>Study Guide: Introduction to Finite Element Methods</title>

<center><h1>Study Guide: Introduction to Finite Element Methods</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b style="font-weight: bold">Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b style="font-weight: bold">Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b style="font-weight: bold">Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Oct 16, 2013</h4></center> <!-- date -->
<p>

</section>


<section class="slide">

<h2>Why finite elements?  <a name="___sec0"></a></h2>

<p>

<ul>
 <p><li> Can with ease solve PDEs in domains with <em>complex geometry</em></li>
 <p><li> Can with ease provide higher-order approximations</li>
 <p><li> Has (in simpler stationary problems) a rigorus mathematical
   analysis framework (not much considered here)
<!-- The theoretical framework is not powerful enough to uncover the -->
<!-- serious limitations of the method in time-dependent problems -->
<!-- and the necessary adjustments) --></li>
</ul>
<p>


</section>


<section class="slide">

<h3>Domain for flow around a dolphin  <a name="___sec1"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_mesh.png" align="bottom" width=400,></p></center>

<p>

</section>


<section class="slide">

<h3>The flow  <a name="___sec2"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_flow.gif" align="bottom" width=400,></p></center>

<p>

</section>


<section class="slide">

<h3>Basic ingredients of the finite element method  <a name="___sec3"></a></h3>

<p>

<ul>
 <p><li> Transform the PDE problem to a <em>variational form</em></li>
 <p><li> Define function approximation over <em>finite elements</em></li>
 <p><li> Use a machinery to derive <em>linear systems</em></li>
 <p><li> Solve linear systems</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Our learning strategy  <a name="___sec4"></a></h3>

<p>

<ul>
 <p><li> Start with approximation of functions, not PDEs</li>
 <p><li> Introduce finite element <em>approximations</em></li>
 <p><li> See later how this is applied to PDEs</li>
</ul>
<p>

Reason: the finite element method has many concepts and a jungle of details.
This strategy minimizes the mixing of ideas, concepts, and technical details.

<p>

</section>


<section class="slide">

<h3>Approximation set-up  <a name="___sec5"></a></h3>

<p>
General idea:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
 u(x) = \sum_{i=0}^N c_i\baspsi_i(x),
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>


<p>
where

<p>

<ul>
 <p><li> \( \baspsi_i(x) \) are prescribed functions</li>
 <p><li> \( c_i \), \( i=0,\ldots,N \) are unknown coefficients to be determined</li>
</ul>
<p>


</section>


<section class="slide">

<h3>How to determine the coefficients?  <a name="___sec6"></a></h3>

<p>

<ul>
 <p><li> least squares method</li>
 <p><li> projection or Galerkin method</li>
 <p><li> interpolation (or collocation) method</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal"><b style="font-weight: bold">Underlying motivation for our notation.</b>
Our mathematical framework for doing this is phrased in a way such
that it becomes easy to understand and use the <a href="http://fenicsproject.org">FEniCS</a> software package for finite element computing.
</div>
<p>

</section>


<section class="slide">

<h3>Approximation of planar vectors; problem <a name="fem:approx:vec:plane"></a></h3>

<p>
Given a vector \( \f = (3,5) \), find an approximation
to \( \f \) directed along a given line.

<p>
<center><p><img src="fig-fem/vecapprox_plane.png" align="bottom" width=200></p></center>

<p>

</section>


<section class="slide">

<h3>Approximation of planar vectors; vector space terminology  <a name="___sec8"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
V = \mbox{span}\,\{ \psib_0\}\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \psib_0 \) is a basis vector in the space \( V \)</li>
 <p><li> Seek \( \u = c_0\psib_0\in V \)</li>
 <p><li> Determine \( c_0 \) such that \( \u \) is the "best" approximation to \( \f \)</li>
 <p><li> Visually, "best" is obvious</li>
</ul>
<p>

Define

<p>

<ul>
 <p><li> the error \( \e = \f - \u \)</li>
 <p><li> the (Eucledian) scalar product of two vectors: \( (\u,\v) \)</li>
 <p><li> the norm of \( \e \): \( ||\e|| = \sqrt{(\e, \e)} \)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>The least squares method; principle  <a name="___sec9"></a></h3>

<p>

<ul>
 <p><li> Idea: find \( c_0 \) such that \( ||\e|| \) is minimized</li>
 <p><li> Actually, we always minimize \( E=||\e||^2 \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_0} = 0
\tp  \end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The least squares method; calculations  <a name="___sec10"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
E(c_0) = (\e,\e) = (\f,\f) - 2c_0(\f,\psib_0) + c_0^2(\psib_0,\psib_0)
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\psib_0) + 2c_0 (\psib_0,\psib_0) = 0
\tag{2}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = \frac{(\f,\psib_0)}{(\psib_0,\psib_0)}
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = \frac{3a + 5b}{a^2 + b^2}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Observation for later: the vanishing derivative <a href="#mjx-eqn-2">(2)</a>
can be alternatively written as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\e, \psib_0) = 0
\tp
\tag{4}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The projection (or Galerkin) method  <a name="___sec11"></a></h3>

<p>

<ul>
 <p><li> Backgrund: minimizing \( ||\e||^2 \) implies that \( \e \) is
   orthogonal to <em>any</em> vector \( \v \) in the space \( V \)
   (visually clear, but can easily be computed too)</li>
 <p><li> Alternative idea: demand \( (\e, \v) = 0,\quad\forall\v\in V \)</li>
 <p><li> Equivalent statement: \( (\e, \psib_0)=0 \) (see notes for why)</li>
 <p><li> Insert \( \e = \f - c_0\psib_0 \) and solve for \( c_0 \)</li>
 <p><li> Same equation for \( c_0 \) and hence same solution as in the least squares
   method</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Approximation of general vectors <a name="fem:approx:vec:Np1dim"></a></h3>

<p>
Given a vector \( \f \), find an approximation \( \u\in V \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\psib_0,\ldots,\psib_N\}
\tp
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> We have a set of linearly independent basis vectors
   \( \psib_0,\ldots,\psib_N \)</li>
 <p><li> Any \( \u\in V \) can then be written as \( \u = \sum_{j=0}^Nc_j\psib_j \)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>The least squares method  <a name="___sec13"></a></h3>

<p>
Idea: find \( c_0,\ldots,c_N \) such that \( E= ||\e||^2 \) is minimized, \( \e=\f-\u \).

<p>
<p>&nbsp;<br>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\psib_j,\f -\sum_jc_j\psib_j)
\nonumber\\ 
&= (\f,\f) - 2\sum_{j=0}^Nc_j(\f,\psib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)\tp
\end{align*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\tp
\end{equation*}
$$
<p>&nbsp;<br>


<p>
After some work we end up with a <em>linear system</em>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j=0}^N A_{i,j}c_j &= b_i,\quad i=0,\ldots,N\\ 
A_{i,j} &= (\psib_i,\psib_j)\\ 
b_i &= (\psib_i, \f)
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The projection (or Galerkin) method  <a name="___sec14"></a></h3>

<p>
Can be shown that minimizing \( ||\e|| \) implies that
\( \e \) is orthogonal to all \( \v\in V \):

<p>
<p>&nbsp;<br>
$$
(\e,\v)=0,\quad \forall\v\in V,
$$
<p>&nbsp;<br>

which implies that \( \e \) most be orthogonal to each basis vector:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\e,\psib_i)=0,\quad i=0,\ldots,N\tp
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>


<p>
This orthogonality condition is the principle of the projection
(or Galerkin) method. Leads to
the same linear system as in the least squares method.

<p>

</section>


<section class="slide">

<h2>Approximation of functions <a name="fem:approx:global"></a></h2>

<p>
Let \( V \) be a <em>function space</em> spanned by a set of <em>basis functions</em>
\( \baspsi_0,\ldots,\baspsi_N \),

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\baspsi_0,\ldots,\baspsi_N\},\end{equation*}
$$
<p>&nbsp;<br>


<p>
Find \( u\in V \) as a linear
combination of the basis functions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u = \sum_{j\in\If} c_j\baspsi_j,\quad\If = \{0,1,\ldots,N\}
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The least squares method <a name="fem:approx:LS"></a></h3>

<p>

<ul>
 <p><li> Extend the ideas from the vector case: minimize the (square) norm
   of the error.</li>
 <p><li> What norm? \( (f,g) = \int_\Omega f(x)g(x)\, dx \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
E = (e,e) = (f-u,f-u) = (f(x)-\sum_{j\in\If} c_j\baspsi_j(x), f(x)-\sum_{j\in\If} c_j\baspsi_j(x))
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
E(c_0,\ldots,c_N) = (f,f) -2\sum_{j\in\If} c_j(f,\baspsi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\baspsi_p,\baspsi_q)
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=\in\If
\end{equation*}
$$
<p>&nbsp;<br>


<p>
After computations <em>identical to the vector case</em>, we get a linear system

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j\in\If}^N A_{i,j}c_j &= b_i,\quad i\in\If
\tag{8}\\ 
A_{i,j} &= (\baspsi_i,\baspsi_j)
\tag{9}\\ 
b_i &= (f,\baspsi_i)
\tag{10}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The projection (or Galerkin) method  <a name="___sec17"></a></h3>

<p>
As before, minimizing \( (e,e) \) is equivalent to the projection (or Galerkin)
method

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(e,v)=0,\quad\forall v\in V,
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>

which means, as before,

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(e,\baspsi_i)=0,\quad i\in\If\tp
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>


<p>
With the same algebra as in the multi-dimensional vector case,
we get the same linear system as arose from the least squares method.

<p>

</section>


<section class="slide">

<h3>Example: linear approximation; problem <a name="fem:approx:global:linear"></a></h3>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b style="font-weight: bold">Problem.</b>
Approximate a parabola \( f(x) = 10(x-1)^2 - 1 \) by a straight line.
</div>
<p>
<p>&nbsp;<br>
$$
\begin{equation*} V = \hbox{span}\,\{1, x\}\tp  \end{equation*}
$$
<p>&nbsp;<br>

That is, \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=x \), and \( N=1 \).
We seek

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
u=c_0\baspsi_0(x) + c_1\baspsi_1(x) = c_0 + c_1x,\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Example: linear approximation; solution  <a name="___sec19"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_1^21\cdot 1\, dx = 1\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_1^2 1\cdot x\, dx = 3/2\\ 
A_{1,0} &= A_{0,1} = 3/2,\\ 
A_{1,1} &= (\baspsi_1,\baspsi_1) = \int_1^2 x\cdot x\,dx = 7/3
\end{align}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align}
b_1 &= (f,\baspsi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3\\ 
b_2 &= (f,\baspsi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3
\end{align}
$$
<p>&nbsp;<br>

Solution of 2x2 linear system:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = -38/3,\quad c_1 = 10,\quad u(x) = 10x - \frac{38}{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Example: linear approximation; plot  <a name="___sec20"></a></h3>

<p>
<center><p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h3>Implementation of the least squares method; ideas <a name="fem:approx:global:LS:code"></a></h3>

<p>
Consider symbolic computation of the linear system,
where

<p>

<ul>
 <p><li> \( f(x) \) is given as a <code>sympy</code> expression <code>f</code> (involving
   the symbol <code>x</code>),</li>
 <p><li> <code>phi</code> is a list of \( \sequencei{\baspsi} \),</li>
 <p><li> <code>Omega</code> is a 2-tuple/list holding the domain \( \Omega \)</li>
</ul>
<p>

Carry out the integrations, solve the linear system, and
return \( u(x)=\sum_jc_j\baspsi_j(x) \)

<p>

</section>


<section class="slide">

<h3>Implementation of the least squares method; code  <a name="___sec22"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">least_squares</span>(f, phi, Omega):
    N = <span style="color: #658b00">len</span>(phi) - <span style="color: #B452CD">1</span>
    A = sm.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sm.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            A[i,j] = sm.integrate(phi[i]*phi[j],
                                  (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            A[j,i] = A[i,j]
        b[i,<span style="color: #B452CD">0</span>] = sm.integrate(phi[i]*f, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
    c = A.LUsolve(b)
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(phi)):
        u += c[i,<span style="color: #B452CD">0</span>]*phi[i]
    <span style="color: #8B008B; font-weight: bold">return</span> u
</code></pre></div>
<p>
Observe: symmetric coefficient matrix so we can halve the integrations.

<p>

</section>


<section class="slide">

<h3>Implementation of the least squares method; plotting  <a name="___sec23"></a></h3>

<p>
Compare \( f \) and \( u \) visually:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">comparison_plot</span>(f, u, Omega, filename=<span style="color: #CD5555">&#39;tmp.pdf&#39;</span>):
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #228B22"># Turn f and u to ordinary Python functions</span>
    f = sm.lambdify([x], f, modules=<span style="color: #CD5555">&quot;numpy&quot;</span>)
    u = sm.lambdify([x], u, modules=<span style="color: #CD5555">&quot;numpy&quot;</span>)
    resolution = <span style="color: #B452CD">401</span>  <span style="color: #228B22"># no of points in plot</span>
    xcoor  = linspace(Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>], resolution)
    exact  = f(xcoor)
    approx = u(xcoor)
    plot(xcoor, approx)
    hold(<span style="color: #CD5555">&#39;on&#39;</span>)
    plot(xcoor, exact)
    legend([<span style="color: #CD5555">&#39;approximation&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>])
    savefig(filename)
</code></pre></div>
<p>
All code in module <a href="http://tinyurl.com/jvzzcfn/fem/approx1D.py"><tt>approx1D.py</tt></a>

<p>

</section>


<section class="slide">

<h3>Implementation of the least squares method; application  <a name="___sec24"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>-<span style="color: #B452CD">1</span>
&gt;&gt;&gt; u = least_squares(f=f, phi=[<span style="color: #B452CD">1</span>, x], Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
&gt;&gt;&gt; comparison_plot(f, u, Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
</code></pre></div>
<p>
<center><p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h3>Perfect approximation; parabola approximating parabola <a name="fem:approx:global:exact"></a></h3>

<p>

<ul>
 <p><li> What if we add \( \baspsi_2=x^2 \) to the space \( V \)?</li>
 <p><li> That is, approximating a parabola by any parabola?</li>
 <p><li> (Hopefully we get the exact parabola!)</li>
</ul>
<p>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>-<span style="color: #B452CD">1</span>
&gt;&gt;&gt; u = least_squares(f=f, phi=[<span style="color: #B452CD">1</span>, x, x**<span style="color: #B452CD">2</span>], Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u
<span style="color: #B452CD">10</span>*x**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">20</span>*x + <span style="color: #B452CD">9</span>
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sm.expand(f)
<span style="color: #B452CD">10</span>*x**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">20</span>*x + <span style="color: #B452CD">9</span>
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Perfect approximation; the general result  <a name="___sec26"></a></h3>

<p>

<ul>
 <p><li> What if we use \( \phi_i(x)=x^i \) for \( i=0,\ldots,N=40 \)?</li>
 <p><li> The output from <code>least_squares</code> is \( c_i=0 \) for \( i>2 \)</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal"><b style="font-weight: bold">General result.</b>
If \( f\in V \), least squares and projection/Galerkin give \( u=f \).
</div>
<p>

</section>


<section class="slide">

<h3>Perfect approximation; proof of the general result  <a name="___sec27"></a></h3>

<p>
If \( f\in V \), \( f=\sum_{j\in\If}d_j\baspsi_j \), for
some  \( \sequencei{d} \). Then

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
b_i = (f,\baspsi_i) = \sum_{j\in\If}d_j(\baspsi_j, \baspsi_i)
= \sum_{j\in\If} d_jA_{i,j}\tp
\end{equation*}
$$
<p>&nbsp;<br>

The linear system \( \sum_j A_{i,j}c_j = b_i \), \( i\in\If \), is then

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\sum_{j\in\If}c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},\quad i\in\If,
\end{equation*}
$$
<p>&nbsp;<br>

which implies that \( c_i=d_i \) for \( i\in\If \) and \( u \) is identical to \( f \).

<p>

</section>


<section class="slide">

<h3>Finite-precision/numerical computations <a name="fem:approx:global:illconditioning"></a></h3>

<p>
The previous computations were symbolic. What if we solve the
linear system numerically with standard arrays?

<p>
<table border="1">
<tr><td align="center"><b style="font-weight: bold">        exact         </b></td> <td align="center"><b style="font-weight: bold">  <code>sympy</code>  </b></td> <td align="center"><b style="font-weight: bold"> <code>numpy32</code> </b></td> <td align="center"><b style="font-weight: bold"> <code>numpy64</code> </b></td> </tr>
<tr><td align="right">   9                       </td> <td align="right">   9.62                    </td> <td align="right">   5.57                    </td> <td align="right">   8.98                    </td> </tr>
<tr><td align="right">   -20                     </td> <td align="right">   -23.39                  </td> <td align="right">   -7.65                   </td> <td align="right">   -19.93                  </td> </tr>
<tr><td align="right">   10                      </td> <td align="right">   17.74                   </td> <td align="right">   -4.50                   </td> <td align="right">   9.96                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -9.19                   </td> <td align="right">   4.13                    </td> <td align="right">   -0.26                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   5.25                    </td> <td align="right">   2.99                    </td> <td align="right">   0.72                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.18                    </td> <td align="right">   -1.21                   </td> <td align="right">   -0.93                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -2.48                   </td> <td align="right">   -0.41                   </td> <td align="right">   0.73                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   1.81                    </td> <td align="right">   -0.013                  </td> <td align="right">   -0.36                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.66                   </td> <td align="right">   0.08                    </td> <td align="right">   0.11                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.12                    </td> <td align="right">   0.04                    </td> <td align="right">   -0.02                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.001                  </td> <td align="right">   -0.02                   </td> <td align="right">   0.002                   </td> </tr>
</table>
<p>

<ul>
  <p><li> Column 2: <code>sympy.mpmath.fp.matrix</code> and <code>sympy.mpmath.fp.lu_solve</code></li>
  <p><li> Column 3: <code>numpy</code> arrays with <code>numpy.float32</code> entries</li>
  <p><li> Column 4: <code>numpy</code> arrays with <code>numpy.float64</code> entries</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Ill-conditioning (1)  <a name="___sec29"></a></h3>

<p>
Observations:

<p>

<ul>
 <p><li> Significant round-off errors in the numerical computations (!)</li>
 <p><li> But if we plot the approximations they look good (!)</li>
</ul>
<p>

Problem: The basis functions \( x^i \) become almost linearly dependent for
large \( N \).

<p>
<center><p><img src="fig-fem/ill_conditioning.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h3>Ill-conditioning (2)  <a name="___sec30"></a></h3>

<p>

<ul>
  <p><li> Almost linearly dependent basis functions give almost singular matrices</li>
  <p><li> Such matrices are said to be <em>ill conditioned</em>, and Gaussian elimination
    is severely affected by round-off errors</li>
  <p><li> The basis \( 1, x, x^2, x^3, x^4, \ldots \) is a bad basis</li>
  <p><li> Polynomials are fine as basis, but the more orthogonal they are,
    \( (\baspsi_i,\baspsi_j)\approx 0 \), the better</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Fourier series approximation; problem and code <a name="fem:approx:global:Fourier"></a></h3>

<p>
Consider

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\tp  \end{equation*}
$$
<p>&nbsp;<br>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">N = <span style="color: #B452CD">3</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> sin, pi
phi = [sin(pi*(i+<span style="color: #B452CD">1</span>)*x) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]
f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">1</span>
Omega = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>]
u = least_squares(f, phi, Omega)
comparison_plot(f, u, Omega)
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Fourier series approximation; plot  <a name="___sec32"></a></h3>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-fem/parabola_ls_sines4_12.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Fourier series approximation; improvements  <a name="___sec33"></a></h3>

<p>

<ul>
 <p><li> Considerably improvement by \( N=11 \)</li>
 <p><li> But always discrepancy of \( f(0)-u(0)=9 \) at \( x=0 \), because all the
   \( \baspsi_i(0)=0 \) and hence \( u(0)=0 \)</li>
 <p><li> Possible remedy: add a term that leads to correct boundary values</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
u(x) = f(0)(1-x) + xf(1) + \sum_{j\in\If} c_j\baspsi_j(x)
\tp
\end{equation}
$$
<p>&nbsp;<br>

The extra term ensures \( u(0)=f(0) \) and \( u(1)=f(1) \) and
is a strikingly good help to get a good
approximation!

<p>

</section>


<section class="slide">

<h3>Fourier series approximation; final results  <a name="___sec34"></a></h3>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-fem/parabola_ls_sines4_12_wfterm.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Orthogonal basis functions  <a name="___sec35"></a></h3>

<p>
This choice of sine functions as basis functions is popular because

<p>

<ul>
 <p><li> the basis functions are orthogonal: \( (\baspsi_i,\baspsi_j)=0 \)</li>
 <p><li> implying that \( A_{i,j} \) is a diagonal matrix</li>
 <p><li> implying that we can solve for \( c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx \)</li>
</ul>
<p>

In general for an orthogonal basis, \( A_{i,j} \) is diagonal and we can
easily solve for \( c_i \):

<p>
<p>&nbsp;<br>
$$
c_i = \frac{b_i}{A_{i,i}} = \frac{(f,\baspsi_i)}{(\baspsi_i,\baspsi_i)}
\tp
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The collocation or interpolation method; ideas and math <a name="fem:approx:global:interp"></a></h3>

<p>
Here is another idea for approximating \( f(x) \) by \( u(x)=\sum_jc_j\baspsi_j \):

<p>

<ul>
 <p><li> Force \( u(\xno{i}) = f(\xno{i}) \) at some selected <em>collocation</em> points
   \( \sequencei{x} \)</li>
 <p><li> Then \( u \) interpolates \( f \)</li>
 <p><li> The method is known as <em>interpolation</em> or <em>collocation</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i}),
\quad i\in\If,N\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>
This is a linear system with no need for integration:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If\\ 
A_{i,j} &= \baspsi_j(\xno{i})\\ 
b_i &= f(\xno{i})
\end{align}
$$
<p>&nbsp;<br>


<p>
No symmetric matrix: \( \baspsi_j(\xno{i})\neq \baspsi_i(\xno{j}) \) in general

<p>

</section>


<section class="slide">

<h3>The collocation or interpolation method; implementation  <a name="___sec37"></a></h3>

<p>
<code>points</code> holds the interpolation/collocation points

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">interpolation</span>(f, phi, points):
    N = <span style="color: #658b00">len</span>(phi) - <span style="color: #B452CD">1</span>
    A = sm.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sm.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #228B22"># Turn phi and f into Python functions</span>
    phi = [sm.lambdify([x], phi[i]) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]
    f = sm.lambdify([x], f)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
            A[i,j] = phi[j](points[i])
        b[i,<span style="color: #B452CD">0</span>] = f(points[i])
    c = A.LUsolve(b)
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(phi)):
        u += c[i,<span style="color: #B452CD">0</span>]*phi[i](x)
    <span style="color: #8B008B; font-weight: bold">return</span> u
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>The collocation or interpolation method; approximating a parabola by linear functions  <a name="___sec38"></a></h3>

<p>

<ul>
 <p><li> Potential difficulty: how to choose \( \xno{i} \)?</li>
 <p><li> The results are sensitive to the points!</li>
</ul>
<p>

\( (4/3,5/3) \) vs \( (1,2) \):

<p>
<center><p><img src="fig-fem/parabola_inter.png" align="bottom" width=700,></p></center>

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; motivation and ideas <a name="fem:approx:global:Lagrange"></a></h3>

<p>
Motivation:

<p>

<ul>
 <p><li> The interpolation/collocation method avoids integration</li>
 <p><li> With a diagonal matrix \( A_{i,j} = \baspsi_j(\xno{i}) \) we
   can solve the linear system by hand</li>
</ul>
<p>

The <em>Lagrange interpolating polynomials</em> \( \baspsi_j \) have the property that

<p>
<p>&nbsp;<br>
$$ \basphi_i(\xno{j}) =\delta_{ij},\quad \delta_{ij} =
\left\lbrace\begin{array}{ll}
1, & i=j,\\ 
0, & i\neq j,
\end{array}\right.
$$
<p>&nbsp;<br>


<p>
Hence, \( c_i = f(x_i) \) and

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \sum_{j\in\If} f(\xno{i})\baspsi_i(x)
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Lagrange polynomials and interpolation/collocation look convenient</li>
 <p><li> Lagrange polynomials are very much used in the finite element method</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Lagrange polynomials; formula and code  <a name="___sec40"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\baspsi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N},
\tag{13}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; successful example  <a name="___sec41"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_ls_interp_sin_4.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; a less successful example  <a name="___sec42"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_interp_abs_8_15.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; oscillatory behavior  <a name="___sec43"></a></h3>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-fem/Lagrange_basis_12.png" align="bottom" width=500></p></center>

<p>
Problem: strong oscillations near the boundaries for larger \( N \) values.

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; remedy for strong oscillations  <a name="___sec44"></a></h3>

<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N,
\end{equation}
$$
<p>&nbsp;<br>

on an interval \( [a,b] \).

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; recalculation with Chebyshev nodes  <a name="___sec45"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; less oscillations with Chebyshev nodes  <a name="___sec46"></a></h3>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-fem/Lagrange_basis_Cheb_12.png" align="bottom" width=500></p></center>

<p>

</section>


<section class="slide">

<h2>Finite element basis functions <a name="fem:approx:fe"></a></h2>

<p>

</section>


<section class="slide">

<h3>So far: basis functions have been global  <a name="___sec48"></a></h3>

<p>
\( \baspsi_i(x) \neq 0 \) for most \( x\in\Omega \)

<p>
<center><p><img src="fig-fem/u_example_sin.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h3>In the finite element method we use basis functions with local support  <a name="___sec49"></a></h3>

<p>

<ul>
 <p><li> <em>Local support</em>: \( \baspsi_i(x) \neq 0 \) for \( x \) in a
   small subdomain of \( \Omega \)</li>
 <p><li> Typically hat-shaped</li>
 <p><li> \( u(x) \) based on these \( \baspsi_i \) is a piecewise polynomial
   defined over many (small) subdomains</li>
</ul>
<p>


</section>


<section class="slide">

<h3>The linear combination of hat functions is a piecewise linear function  <a name="___sec50"></a></h3>

<p>
<center><p><img src="fig-fem/u_example_fe2.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h3>Elements and nodes <a name="fem:approx:fe:def:elements:nodes"></a></h3>

<p>
Split \( \Omega \) into non-overlapping subdomains called <em>elements</em>:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(N_e)}\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>
On each element, introduce points called <em>nodes</em>: \( \xno{0},\ldots,\xno{N_n} \)

<p>

<ul>
 <p><li> The finite element basis functions are named \( \basphi_i(x) \)</li>
 <p><li> \( \basphi_i=1 \) at node \( i \) and 0 at all other nodes</li>
 <p><li> \( \basphi_i \) is a Lagrange polynomial on each element</li>
 <p><li> For nodes at the boundary between two elements, \( \basphi_i \) is made
   up of a Lagrange polynomial over each element</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Example on elements with two nodes (P1 elements)  <a name="___sec52"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D.png" align="bottom" width=500></p></center>

<p>
Data structure: <code>nodes</code> holds coordinates or nodes, <code>elements</code> holds the
node numbers in each element

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1.2</span>, <span style="color: #B452CD">2.4</span>, <span style="color: #B452CD">3.6</span>, <span style="color: #B452CD">4.8</span>, <span style="color: #B452CD">5</span>]
elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>], [<span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>]]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Illustration of two basis functions on the mesh  <a name="___sec53"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>

</section>


<section class="slide">

<h3>Example on elements with three nodes (P2 elements)  <a name="___sec54"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_P2.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.125</span>, <span style="color: #B452CD">0.25</span>, <span style="color: #B452CD">0.375</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.625</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.875</span>, <span style="color: #B452CD">1.0</span>]
elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>, <span style="color: #B452CD">6</span>], [<span style="color: #B452CD">6</span>, <span style="color: #B452CD">7</span>, <span style="color: #B452CD">8</span>]]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Some corresponding basis functions (P2 elements)  <a name="___sec55"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h3>Examples on elements with four nodes per element (P3 elements)  <a name="___sec56"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_d4_stretched.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">d = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># d+1 nodes per element</span>
num_elements = <span style="color: #B452CD">4</span>
num_nodes = num_elements*d + <span style="color: #B452CD">1</span>
nodes = [i*<span style="color: #B452CD">0.5</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(num_nodes)]
elements = [[i*d+j <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(num_elements)]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Some corresponding basis functions (P3 elements)  <a name="___sec57"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h3>The numbering does not need to be regular from left to right  <a name="___sec58"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_random_numbering.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">1.5</span>, <span style="color: #B452CD">5.5</span>, <span style="color: #B452CD">4.2</span>, <span style="color: #B452CD">0.3</span>, <span style="color: #B452CD">2.2</span>, <span style="color: #B452CD">3.1</span>]
elements = [[<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>], [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">3</span>, <span style="color: #B452CD">0</span>], [<span style="color: #B452CD">5</span>, <span style="color: #B452CD">2</span>]]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Interpretation of the coefficients \( c_i \)  <a name="___sec59"></a></h3>

<p>
Important property: \( c_i \)
is the value of \( u \) at node \( i \), \( \xno{i} \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) =
c_i\basphi_i(\xno{i}) = c_i
\tag{14}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Properties of the basis functions  <a name="___sec60"></a></h3>

<p>
\( \basphi_i(x) \) is mostly zero throughout the domain:

<p>

<ul>
 <p><li> \( \basphi_i(x) \neq 0 \) only on those elements that contain global node \( i \),</li>
 <p><li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) if and only if \( i \) and \( j \) are global node
   numbers in the same element.</li>
</ul>
<p>

Since \( A_{i,j} \) is the integral of
\( \basphi_i\basphi_j \) it means that
<em>most of the elements in the coefficient matrix will be zero</em>
(important for implementation!).

<p>

</section>


<section class="slide">

<h3>How to construct quadratic \( \basphi_i \) (P2 elements)  <a name="___sec61"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p></center>

<p>

<ol>
<p><li> Associate Lagrange polynomials with the nodes in an element</li>
<p><li> When the polynomial is 1 on the element boundary, combine it
   with the polynomial in the neighboring element</li>
</ol>
<p>


</section>


<section class="slide">

<h3>Example on linear \( \basphi_i \) (P1 elements)  <a name="___sec62"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=600></p></center>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
(x - \xno{i-1})/h,
& \xno{i-1} \leq x < \xno{i},\\ 
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{15}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Example on cubic \( \basphi_i \) (P3 elements)  <a name="___sec63"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600,></p></center>

<p>

</section>


<section class="slide">

<h2>Calculating the linear system for \( c_i \) <a name="fem:approx:global:linearsystem"></a></h2>

<p>

</section>


<section class="slide">

<h3>Computing a specific matrix entry (1)  <a name="___sec65"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>
\( A_{2,3}=\int_\Omega\basphi_2\basphi_3 dx \): \( \basphi_2\basphi_3\neq 0 \)
only over element 2. There,

<p>
<p>&nbsp;<br>
$$ \basphi_3(x) = (x-x_2)/h,\quad \basphi_2(x) = 1- (x-x_2)/h$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
A_{2,3} = \int_\Omega \basphi_2\basphi_{3}\dx =
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right) \frac{x - x_{2}}{h}
 \dx = \frac{h}{6}\tp
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Computing a specific matrix entry (2)  <a name="___sec66"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$ A_{2,2} =
\int_{\xno{1}}^{\xno{2}}
\left(\frac{x - \xno{1}}{h}\right)^2\dx +
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right)^2\dx
= \frac{h}{3}\tp
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Calculating a general row in the matrix; figure  <a name="___sec67"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_im1.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$ A_{i,i-1} = \int_\Omega \basphi_i\basphi_{i-1}\dx = \hbox{?}$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Calculating a general row in the matrix; details  <a name="___sec68"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,i-1} &= \int_\Omega \basphi_i\basphi_{i-1}\dx\\ 
&=
\underbrace{\int_{\xno{i-2}}^{\xno{i-1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_i=0} +
\int_{\xno{i}}^{\xno{i}} \basphi_i\basphi_{i-1}\dx +
\underbrace{\int_{\xno{i}}^{\xno{i+1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_{i-1}=0}\\ 
&= \int_{\xno{i-1}}^{\xno{i}}
\underbrace{\frac{x - x_{i}}{h}}_{\basphi_i(x)}
\underbrace{\left(1 - \frac{x - \xno{i-1}}{h}\right)}_{\basphi_{i-1}(x)} \dx =
\frac{h}{6}
\tp
\end{align*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( A_{i,i+1}=A_{i,i-1} \) due to symmetry</li>
 <p><li> \( A_{i,i}=h/3 \) (same calculation as for \( A_{2,2} \))</li>
 <p><li> \( A_{0,0}=A_{N,N}=h/3 \) (only one element)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Calculation of the right-hand side  <a name="___sec69"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_f.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i(x)f(x)\dx
= \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)\dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)
\dx\tp
\tag{16}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Need a specific \( f(x) \) to do more...

<p>

</section>


<section class="slide">

<h3>Specific example: two elements; linear system and solution  <a name="___sec70"></a></h3>

<p>

<ul>
 <p><li> \( f(x)=x(1-x) \) on \( \Omega=[0,1] \)</li>
 <p><li> Two equal-sized elements \( [0,0.5] \) and \( [0.5,1] \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\ 
1 & 4 & 1\\ 
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\ 
12 - 14h\\ 
10 -17h
\end{array}\right)\tp
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*} c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2\tp  \end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Specific example: two elements; plot  <a name="___sec71"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)\end{equation*}
$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-fem/fe_p1_x2_2e.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h3>Specific example: what about four elements?  <a name="___sec72"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p1_x2_2e_4e.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h2>Assembly of elementwise computations <a name="fem:approx:fe:elementwise"></a></h2>

<p>

</section>


<section class="slide">

<h3>Split the integrals into elementwise integrals  <a name="___sec74"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A_{i,j} = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} A^{(e)}_{i,j},\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_jdx\tp
\tag{17}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
 <p><li> \( A^{(e)}_{i,j}\neq 0 \) if and only if \( i \) and \( j \) are nodes in element
   \( e \) (otherwise no overlap between the basis functions)</li>
 <p><li> all the nonzero elements in \( A^{(e)}_{i,j} \) are collected in an
   <em>element matrix</em></li>
</ul>
<p>


</section>


<section class="slide">

<h3>The element matrix  <a name="___sec75"></a></h3>

<p>
<p>&nbsp;<br>
$$
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad r,s\in\Ifd=\{0,\ldots,d\},
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)}dx,\quad r,s\in\Ifd\tp
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( r,s \) run over <em>local node numbers</em> within an element, while \( i,j \) run
   over <em>global node numbers</em>.</li>
 <p><li> \( i=q(e,r) \): mapping of local node number \( r \) in element
   \( e \) to the global node number \( i \). Math equivalent to <code>i=elements[e][r]</code>.</li>
 <p><li> Add contribution from an element into the global coefficient matrix
   (<em>assembly</em>)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s\in\Ifd\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Illustration of the matrix assembly: regularly numbered P1 elements  <a name="___sec76"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_regular_2x2/fe_assembly_regular_2x2.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>

</section>


<section class="slide">

<h3>Illustration of the matrix assembly: regularly numbered P3 elements  <a name="___sec77"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_regular_4x4/fe_assembly_regular_4x4.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>

</section>


<section class="slide">

<h3>Illustration of the matrix assembly: irregularly numbered P1 elements  <a name="___sec78"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_irregular/fe_assembly_irregular.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>

</section>


<section class="slide">

<h3>Assembly of the right-hand side  <a name="___sec79"></a></h3>

<p>
Split in elementwise contributions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} b^{(e)}_{i},\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)dx\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
  <p><li> \( b_i^{(e)}\neq 0 \) if and only if global node \( i \) is a node in element \( e \)
    (otherwise \( \basphi_i=0 \))</li>
  <p><li> The \( d+1 \) nonzero \( b_i^{(e)} \) can be collected in an <em>element vector</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
\tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\},\quad r\in\Ifd\tp
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Assembly:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r,s\in\Ifd\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Mapping to a reference element <a name="fem:approx:fe:mapping"></a></h2>

<p>
Instead of computing

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx\end{equation*}
$$
<p>&nbsp;<br>

over some element
\( \Omega^{(e)} = [x_L, x_R] \),
we now map \( [x_L, x_R] \) to
a standardized reference element domain \( [-1,1] \) with local coordinate \( X \).

<p>

</section>


<section class="slide">

<h3>Affine mapping  <a name="___sec81"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
x = \half (x_L + x_R) + \half (x_R - x_L)X\tp
\tag{18}
\end{equation}
$$
<p>&nbsp;<br>

or rewritten as
<p>&nbsp;<br>
$$
\begin{equation}
x = x_m + \frac{1}{2}hX, \qquad x_m=(x_L+x_R)/2
\tag{19}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Integral transformation  <a name="___sec82"></a></h3>

<p>
Integrating on
the reference element is a matter of just changing the integration
variable from \( x \) to \( X \). Introduce local basis function

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
\end{equation}
$$
<p>&nbsp;<br>

The integral transformation reads

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\frac{dx}{dX}dX\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>
Introduce the notation
\( \det J = dx/dX = h/2 \) (2D/3D must use \( \det J \))

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)}_{r,s}
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
\tag{20}
\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
\tag{21}
\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Advantages of the reference element  <a name="___sec83"></a></h3>

<p>

<ul>
  <p><li> Always the same domain for integration: \( [-1,1] \)</li>
  <p><li> We only need formulas for \( \refphi_r(X) \) on the reference elements
    (no need for piecewise polynomial definition)</li>
  <p><li> All geometric information (length and location) is "factored out"
    in the mapping and \( \det J \)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Standardized basis functions for P1 elements  <a name="___sec84"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\tag{22}\\ 
\refphi_1(X) &= \half (1 + X)
\tag{23}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Standardized basis functions for P2 elements  <a name="___sec85"></a></h3>

<p>
P2 elements:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (X-1)X\\ 
\refphi_1(X) &= 1 - X^2\\ 
\refphi_2(X) &= \half (X+1)X
\end{align}
$$
<p>&nbsp;<br>


<p>
Easy to generalize to arbitrary order!

<p>

</section>


<section class="slide">

<h3>Integration over a reference element; element matrix <a name="fem:approx:fe:intg:ref"></a></h3>

<p>
P1 elements and \( f(x)=x(1-x) \).

<p>
<p>&nbsp;<br>
$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1-X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3},
\tag{24}\\ 
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6},\\ 
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0},
\tag{25}\\ 
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\tag{26}
\tp
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Integration over a reference element; element vector  <a name="___sec87"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1-X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\tag{27}\\ 
\tilde b^{(e)}_{1}
&= \int_{-1}^1 f(x(X))\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1+X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\tp
\end{align}
$$
<p>&nbsp;<br>


<p>
\( x_m \): element midpoint.

<p>

</section>


<section class="slide">

<h3>Tedious calculations! Let's use symbolic software  <a name="___sec88"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
&gt;&gt;&gt; x, x_m, h, X = sm.symbols(<span style="color: #CD5555">&#39;x x_m h X&#39;</span>)
&gt;&gt;&gt; sm.integrate(h/<span style="color: #B452CD">8</span>*(<span style="color: #B452CD">1</span>-X)**<span style="color: #B452CD">2</span>, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
h/<span style="color: #B452CD">3</span>
&gt;&gt;&gt; sm.integrate(h/<span style="color: #B452CD">8</span>*(<span style="color: #B452CD">1</span>+X)*(<span style="color: #B452CD">1</span>-X), (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
h/<span style="color: #B452CD">6</span>
&gt;&gt;&gt; x = x_m + h/<span style="color: #B452CD">2</span>*X
&gt;&gt;&gt; b_0 = sm.integrate(h/<span style="color: #B452CD">4</span>*x*(<span style="color: #B452CD">1</span>-x)*(<span style="color: #B452CD">1</span>-X), (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> b_0
-h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">24</span> + h**<span style="color: #B452CD">2</span>*x_m/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - h*x_m**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">2</span> + h*x_m/<span style="color: #B452CD">2</span>
</code></pre></div>
<p>
Can printe out in LaTeX too (convenient for copying into reports):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sm.latex(b_0, mode=<span style="color: #CD5555">&#39;plain&#39;</span>)
- \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">24</span>} h^{<span style="color: #B452CD">3</span>} + \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">6</span>} h^{<span style="color: #B452CD">2</span>} x_{m}
- \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">12</span>} h^{<span style="color: #B452CD">2</span>} - \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">2</span>} h x_{m}^{<span style="color: #B452CD">2</span>}
+ \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">2</span>} h x_{m}
</code></pre></div>
<p>

</section>


<section class="slide">

<h2>Implementation  <a name="___sec89"></a></h2>

<p>

<ul>
 <p><li> Coming functions appear in <a href="http://tinyurl.com/jvzzcfn/fem/fe_approx1D.py"><tt>fe_approx1D.py</tt></a></li>
 <p><li> Functions can operate in symbolic or numeric mode</li>
 <p><li> The code documents all steps in finite element calculations!</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Compute finite element basis functions  <a name="___sec90"></a></h3>

<p>
Let \( \refphi_r(X) \) be a Lagrange polynomial of degree <code>d</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">phi_r</span>(r, X, d):
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(X, sm.Symbol):
        h = sm.Rational(<span style="color: #B452CD">1</span>, d)  <span style="color: #228B22"># node spacing</span>
        nodes = [<span style="color: #B452CD">2</span>*i*h - <span style="color: #B452CD">1</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #228B22"># assume X is numeric: use floats for nodes</span>
        nodes = np.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, d+<span style="color: #B452CD">1</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> Lagrange_polynomial(X, r, nodes)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">basis</span>(d=<span style="color: #B452CD">1</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Return the complete basis.&quot;&quot;&quot;</span>
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    phi = [phi_r(r, X, d) <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> phi
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Compute the element matrix  <a name="___sec91"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_matrix</span>(phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    A_e = sm.zeros((n, n))
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sm.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(r, n):
            A_e[r,s] = sm.integrate(phi[r]*phi[s]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
            A_e[s,r] = A_e[r,s]
    <span style="color: #8B008B; font-weight: bold">return</span> A_e
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Example on symbolic and numeric element matrix  <a name="___sec92"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; phi
[<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> - X/<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> + X/<span style="color: #B452CD">2</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">True</span>)
[h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">False</span>)
[<span style="color: #B452CD">0.0333333333333333</span>, <span style="color: #B452CD">0.0166666666666667</span>]
[<span style="color: #B452CD">0.0166666666666667</span>, <span style="color: #B452CD">0.0333333333333333</span>]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Compute the element vector  <a name="___sec93"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    b_e = sm.zeros((n, <span style="color: #B452CD">1</span>))
    <span style="color: #228B22"># Make f a function of X</span>
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sm.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    x = (Omega_e[<span style="color: #B452CD">0</span>] + Omega_e[<span style="color: #B452CD">1</span>])/<span style="color: #B452CD">2</span> + h/<span style="color: #B452CD">2</span>*X  <span style="color: #228B22"># mapping</span>
    f = f.subs(<span style="color: #CD5555">&#39;x&#39;</span>, x)  <span style="color: #228B22"># substitute mapping formula for x</span>
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        b_e[r] = sm.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">return</span> b_e
</code></pre></div>
<p>
Note <code>f.subs('x', x)</code>: replace <code>x</code> by \( x(X) \) such that <code>f</code> contains <code>X</code>

<p>

</section>


<section class="slide">

<h3>Fallback on numerical integration if symbolic integration fails  <a name="___sec94"></a></h3>

<p>

<ul>
  <p><li> Element matrix: only polynomials and <code>sympy</code> always succeeds</li>
  <p><li> Element vector: \( \int f\refphi \dx \) can fail
    (<code>sympy</code> then returns an <code>Integral</code> object instead of a number)</li>
</ul>
<p>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
        ...
        I = sm.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))  <span style="color: #228B22"># try...</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sm.Integral):
            h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]  <span style="color: #228B22"># Ensure h is numerical</span>
            detJ = h/<span style="color: #B452CD">2</span>
            integrand = sm.lambdify([X], f*phi[r]*detJ)
            I = sm.mpmath.quad(integrand, [-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>])
        b_e[r] = I
        ...
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Linear system assembly and solution  <a name="___sec95"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assemble</span>(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>):
    N_n, N_e = <span style="color: #658b00">len</span>(nodes), <span style="color: #658b00">len</span>(elements)
    zeros = sm.zeros <span style="color: #8B008B; font-weight: bold">if</span> symbolic <span style="color: #8B008B; font-weight: bold">else</span> np.zeros
    A = zeros((N_n, N_n))
    b = zeros((N_n, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_e):
        Omega_e = [nodes[elements[e][<span style="color: #B452CD">0</span>]], nodes[elements[e][-<span style="color: #B452CD">1</span>]]]

        A_e = element_matrix(phi, Omega_e, symbolic)
        b_e = element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] += A_e[r,s]
            b[elements[e][r]] += b_e[r]
    <span style="color: #8B008B; font-weight: bold">return</span> A, b
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Linear system solution  <a name="___sec96"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> symbolic:
    c = A.LUsolve(b)           <span style="color: #228B22"># sympy arrays, symbolic Gaussian elim.</span>
<span style="color: #8B008B; font-weight: bold">else</span>:
    c = np.linalg.solve(A, b)  <span style="color: #228B22"># numpy arrays, numerical solve</span>
</code></pre></div>
<p>
Note: the symbolic computation of <code>A</code> and <code>b</code> and the symbolic
solution can be very tedious.

<p>

</section>


<section class="slide">

<h3>Example on computing approximations  <a name="___sec97"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; h, x = sm.symbols(<span style="color: #CD5555">&#39;h x&#39;</span>)
&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, h, <span style="color: #B452CD">2</span>*h]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; b
[     h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
[      h**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">5</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - <span style="color: #B452CD">17</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[                           h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">12</span>*(<span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - <span style="color: #B452CD">35</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">72</span>)/(<span style="color: #B452CD">7</span>*h)]
[  <span style="color: #B452CD">7</span>*(<span style="color: #B452CD">4</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">7</span> - <span style="color: #B452CD">23</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">21</span>)/(<span style="color: #B452CD">2</span>*h)]
</code></pre></div>
<p>
Numerical computations:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">False</span>)
&gt;&gt;&gt; A
[ <span style="color: #B452CD">0.166666666666667</span>, <span style="color: #B452CD">0.0833333333333333</span>,                  <span style="color: #B452CD">0</span>]
[<span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.333333333333333</span>, <span style="color: #B452CD">0.0833333333333333</span>]
[                 <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.166666666666667</span>]
&gt;&gt;&gt; b
[          <span style="color: #B452CD">0.03125</span>]
[<span style="color: #B452CD">0.104166666666667</span>]
[          <span style="color: #B452CD">0.03125</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[<span style="color: #B452CD">0.0416666666666666</span>]
[ <span style="color: #B452CD">0.291666666666667</span>]
[<span style="color: #B452CD">0.0416666666666666</span>]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>The structure of the coefficient matrix <a name="fem:approx:fe:A:structure"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; d=<span style="color: #B452CD">1</span>; N_e=<span style="color: #B452CD">8</span>; Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]  <span style="color: #228B22"># 8 linear elements on [0,1]</span>
&gt;&gt;&gt; phi = basis(d)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; nodes, elements = mesh_symbolic(N_e, d, Omega)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
</code></pre></div>
<p>
Note: do this by hand to understand what is going on!

<p>

</section>


<section class="slide">

<h3>General result: the coefficient matrix is sparse  <a name="___sec99"></a></h3>

<p>

<ul>
 <p><li> Sparse = most of the entries are zeros</li>
 <p><li> Below: P1 elements</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Exemplifying the sparsity for P2 elements  <a name="___sec100"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 &
  0\\0 & 0 & 2 & 16 & 2 & 0 & 0
  & 0 & 0\\0 & 0 & - 1 & 2 & 8
  & 2 & - 1 & 0 & 0\\0 & 0 & 0 & 0 &
  2 & 16 & 2 & 0 & 0\\0 & 0 & 0
  & 0 & - 1 & 2 & 8 &
  2 & - 1\\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Matrix sparsity pattern for regular/random numbering of P1 elements  <a name="___sec101"></a></h3>

<p>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>
<p>

<center><p><img src="fig-fem/sparsity_pattern_1D_30.png" align="bottom" width=800></p></center>

<p>

</section>


<section class="slide">

<h3>Matrix sparsity pattern for regular/random numbering of P3 elements  <a name="___sec102"></a></h3>

<p>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>
<p>

<center><p><img src="fig-fem/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p></center>

<p>

</section>


<section class="slide">

<h3>Sparse matrix storage and solution <a name="fem:approx:fe:impl:sparse"></a></h3>

<p>
The minimum storage requirements for the coefficient matrix \( A_{i,j} \):

<p>

<ul>
 <p><li> P1 elements: only 3 nonzero entires per row</li>
 <p><li> P2 elements: only 5 nonzero entires per row</li>
 <p><li> P2 elements: only 7 nonzero entires per row</li>
 <p><li> It is important to utilize sparse storage and sparse solvers</li>
 <p><li> In Python: <code>scipy.sparse</code> package</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Approximate \( f\sim x^9 \) by various elements; code  <a name="___sec104"></a></h3>

<p>
Compute a mesh with <code>N_e</code> elements, basis functions of
degree <code>d</code>, and approximate a given symbolic expression
<code>f</code> by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> approximate
x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)

approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">4</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">2</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">8</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">4</span>)
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Approximate \( f\sim x^9 \) by various elements; plot  <a name="___sec105"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p1_p2_x9_248e.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h2>Comparison of finite element and finite difference approximation <a name="fem:approx:fe:fd"></a></h2>

<p>

<ul>
 <p><li> Finite difference approximation of a function \( f(x) \): simply
   choose \( u_i = f(x_i) \) (interpolation)</li>
 <p><li> Galerkin/projection and least squares method:
   must derive and solve a linear system</li>
 <p><li> What is really the difference?</li>
</ul>
<p>

<h3>Interpolation/collocation with finite elements  <a name="___sec107"></a></h3>

<p>
Let \( \xno{i} \), \( i\in\If \), be the nodes in the mesh.
Collocation means

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i})=f(\xno{i}),\quad i\in\If,
\end{equation}
$$
<p>&nbsp;<br>

which translates to

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} c_j \basphi_j(\xno{i}) = f(\xno{i}),$$
<p>&nbsp;<br>

but \( \basphi_j(\xno{i})=0 \) if \( i\neq j \) so the sum collapses to one
term \( c_i\basphi_i(\xno{i}) = c_i \), and we have the result

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_i = f(\xno{i})
\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Same result as the standard finite difference approach</li>
 <p><li> \( u \) <em>interpolates</em> \( f \) at the node points</li>
 <p><li> \( u \) has a variation between the node points dictated by the \( \basphi_i \)
   functions</li>
</ul>
<p>

<h3>Differential equation models <a name="fem:deq:1D:models"></a></h3>

<p>
Abstract differential equation:
<p>&nbsp;<br>
$$
\begin{equation}
\mathcal{L}(u) = 0,\quad x\in\Omega\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>
Examples:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mathcal{L}(u) &= \frac{d^2u}{dx^2} - f(x),
\tag{28}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(x)\frac{du}{dx}\right) + f(x),
\tag{29}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(u)\frac{du}{dx}\right) - \alpha u + f(x),
\tag{30}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(u)\frac{du}{dx}\right) + f(u,x)
\tag{31}
\tp 
\end{align}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
{\cal B}_0(u)=0,\ x=0,\quad {\cal B}_1(u)=0,\ x=L
\end{equation}
$$
<p>&nbsp;<br>


<p>
There are three common choices of boundary conditions:
<p>&nbsp;<br>
$$
\begin{align}
{\cal B}_i(u) &= u - g,\quad \hbox{(Dirichlet condition)},\\ 
{\cal B}_i(u) &= -a \frac{du}{dx} - g,\quad \hbox{(Neumann condition)},\\ 
{\cal B}_i(u) &= -a \frac{du}{dx} - a(u-g),\quad \hbox{(Robin condition)}
\tp 
\end{align}
$$
<p>&nbsp;<br>


<p>
From now on we shall use \( \uex(x) \) as symbol for the <em>exact</em> solution,
fulfilling

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\mathcal{L}(\uex)=0,\quad x\in\Omega,
\end{equation}
$$
<p>&nbsp;<br>

while \( u(x) \) denotes an <em>approximate</em> solution of the differential
equation.

<h3>Residual-minimizing principles <a name="fem:deq:1D:residual:min"></a></h3>

<p>
The fundamental idea is to seek an approximate solution
\( u \) in some space \( V \) with basis

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \{ \baspsi_0(x),\ldots,\baspsi_N(x)\},\end{equation*}
$$
<p>&nbsp;<br>

which means that \( u \) can always be expressed as

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) = \sum_{j\in\If} c_j\baspsi_j(x),\end{equation*}
$$
<p>&nbsp;<br>

for some unknown coefficients \( c_0,\ldots,c_N \).

<p>
Inserting this \( u \) in the equation gives a nonzero <em>residual</em> \( R \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
R = \mathcal{L}(u) = \mathcal{L}(\sum_j c_j \baspsi_j),
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( R \) measures how well \( u \) fulfills the differential equation, but says
   nothing about the <em>error</em> \( \uex - u \)</li>
 <p><li> We cannot know \( \uex - u \)</li>
 <p><li> Therefore, we aim to minimize \( R \)</li>
 <p><li> Find \( c_0,\ldots,c_N \) such that \( R(x; c_0,\ldots,c_N) \) is small</li>
</ul>
<p>

<h4>The least squares method  <a name="___sec110"></a></h4>

<p>
Idea: minimize

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} R^2 dx
\end{equation}
$$
<p>&nbsp;<br>


<p>
With the inner product

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,g) = \int_{\Omega} f(x)g(x) dx,
\end{equation}
$$
<p>&nbsp;<br>


<p>
the least-squares method can be defined as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\min_{c_0,\ldots,c_N} E = (R,R)\tp  \end{equation}
$$
<p>&nbsp;<br>

Differentiating with respect to the free parameters \( c_0,\ldots,c_N \)
gives the \( N+1 \) equations

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} 2R\frac{\partial R}{\partial c_i} dx = 0\quad
\Leftrightarrow\quad (R,\frac{\partial R}{\partial c_i})=0,\quad
i\in\If\tp 
\tag{32}
\end{equation}
$$
<p>&nbsp;<br>

<h4>The Galerkin method  <a name="___sec111"></a></h4>

<p>
Idea: make \( R \) orthogonal to \( V \),

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in V\tp 
\tag{33}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Equivalent statement:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,\baspsi_i)=0,\quad i\in\If,
\tag{34}
\end{equation}
$$
<p>&nbsp;<br>

This statement generates \( N+1 \) equations for \( c_0,\ldots,c_N \).

<h4>The Method of Weighted Residuals  <a name="___sec112"></a></h4>

<p>
Generalization of the Galerkin method: demand \( R \)
orthogonal to some space \( W \), possibly \( W\neq V \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in W\tp 
\tag{35}
\end{equation}
$$
<p>&nbsp;<br>

If \( \{w_0,\ldots,w_N\} \) is a basis for \( W \), we can equivalently
express the method of weighted residuals as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,w_i)=0,\quad i\in\If\tp 
\tag{36}
\end{equation}
$$
<p>&nbsp;<br>

This gives \( N+1 \) equations for \( c_0,\ldots,c_N \).

<p>
Note: The least-squares method can also be viewed as a weighted residual
method with \( w_i = \partial R/\partial c_i \).

<h4>Test and Trial Functions  <a name="___sec113"></a></h4>

<p>

<ul>
 <p><li> \( \baspsi_j \) used in \( \sum_jc_j\baspsi_j \): <em>trial function</em></li>
 <p><li> \( \baspsi_i \) or \( w_i \) used as weight in Galerkin's method: <em>test function</em></li>
</ul>
<p>

<h4>The collocation method  <a name="___sec114"></a></h4>

<p>
Idea: demand \( R=0 \) at \( N+1 \) points.

<p>
<p>&nbsp;<br>
$$
\begin{equation}
R(\xno{i}; c_0,\ldots,c_N)=0,\quad i\in\If\tp 
\tag{37}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Note: The collocation method is a weighted residual method with
delta functions as weights.

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} f(x)\delta (x-\xno{i}) dx = f(\xno{i}),\quad \xno{i}\in\Omega\tp 
\tag{38}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Approximation of delta functions by narrow Gaussian functions. <a name="fem:deq:1D:fig:Dirac"></a> </p></center>
<p><img src="fig-fem/delta_func_weight.png" align="bottom" width=400></p>
</center>

<h3>Examples on using the principles <a name="fem:deq:1D:ex:sines"></a></h3>

<h4>The model problem  <a name="___sec116"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=0
\tp 
\tag{39}
\end{equation}
$$
<p>&nbsp;<br>

<h4>Basis functions  <a name="___sec117"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\baspsi_i(x) = \sinL{i},\quad i\in\If\tp 
\tag{40}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Note: \( \baspsi_i(0)=\baspsi_i(L)=0 \), which ensures that \( u \)
fulfills the boundary conditions:

<p>
<p>&nbsp;<br>
$$ u(0) = \sum_jc_j\baspsi_j(0) = 0,\quad u(L) = \sum_jc_j\baspsi_j(L)
\tp $$
<p>&nbsp;<br>


<p>
Another useful property is the orthogonality on \( \Omega \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int\limits_0^L \sinL{i}\sinL{j}\, dx = \left\lbrace
\begin{array}{ll} \half L & i=j  \\ 0, & i\neq j
\end{array}\right.
\end{equation}
$$
<p>&nbsp;<br>


<p>
That is, the coefficient matrix becomes diagonal (\( \baspsi_i\baspsi_j=0 \)).

<h4>The residual  <a name="___sec118"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{align}
R(x;c_0,\ldots,c_N) &= u''(x) + f(x),\nonumber\\ 
&= \frac{d^2}{dx^2}\left(\sum_{j\in\If} c_j\baspsi_j(x)\right)
+ f(x),\nonumber\\ 
&= -\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\tp 
\tag{41}
\end{align}
$$
<p>&nbsp;<br>

<h4>The least squares method  <a name="___sec119"></a></h4>

<p>
<p>&nbsp;<br>
$$
(R,\frac{\partial R}{\partial c_i}) = 0,\quad i\in\If\tp 
$$
<p>&nbsp;<br>


<p>
We need an expression for
\( \partial R/\partial c_i \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial R}{\partial c_i} =
\frac{\partial}{\partial c_i}
\left(\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\right)
= \baspsi_i''(x)\tp  \end{equation}
$$
<p>&nbsp;<br>

Because:
<p>&nbsp;<br>
$$
\frac{\partial}{\partial c_i}\left(c_0\baspsi_0'' + c_1\baspsi_1'' + \cdots +
c_{i-1}\baspsi_{i-1}'' + c_i\baspsi_{i}'' + c_{i+1}\baspsi_{i+1}''
+ \cdots + c_N\baspsi_N'' \right) = \baspsi_{i}''
$$
<p>&nbsp;<br>


<p>
The governing equations for \( c_0,\ldots,c_N \) are then

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\sum_j c_j \baspsi_j'' + f,\baspsi_i'')=0,\quad i\in\If,
\end{equation}
$$
<p>&nbsp;<br>

which can be rearranged as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j\in\If}(\baspsi_i'',\baspsi_j'')c_j = -(f,\baspsi_i''),\quad i\in\If\tp  \end{equation}
$$
<p>&nbsp;<br>

This is nothing but a linear system

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \sum_{j\in\If}A_{i,j}c_j = b_i,\quad i\in\If,
\end{equation*}
$$
<p>&nbsp;<br>

with

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{i,j} &= (\baspsi_i'',\baspsi_j'')\nonumber\\ 
& = \pi^4(i+1)^2(j+1)^2L^{-4}\int_0^L \sinL{i}\sinL{j}\, dx\nonumber\\ 
&= \left\lbrace
\begin{array}{ll} {1\over2}L^{-3}\pi^4(i+1)^4 & i=j  \\ 0, & i\neq j
\end{array}\right.
\\ 
b_i &= -(f,\baspsi_i'') = (i+1)^2\pi^2L^{-2}\int_0^Lf(x)\sinL{i}\, dx
\end{align}
$$
<p>&nbsp;<br>

Since the coefficient matrix is diagonal we can easily solve for

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_i = \frac{2L}{\pi^2(i+1)^2}\int_0^Lf(x)\sinL{i}\, dx\tp 
\tag{42}
\end{equation}
$$
<p>&nbsp;<br>

With the special choice of \( f(x)=2 \) the integral becomes

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \frac{L\cos(\pi i) + L}{\pi (i+1)},\end{equation*}
$$
<p>&nbsp;<br>


<p>
The solution becomes:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \sum_{k=0}^{N/2} \frac{8L^2}{\pi^3(2k+1)^3}\sinL{2k}\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>
The coefficients decay very fast: \( c_2 = c_0/27 \), \( c_4=c_0/125 \).
The first term therefore suffices:

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) \approx \frac{8L^2}{\pi^3}\sin\left(\pi\frac{x}{L}\right)\tp  \end{equation*}
$$
<p>&nbsp;<br>

<h4>The Galerkin method  <a name="___sec120"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
(u''+f,v)=0,\quad \forall v\in V,
\end{equation*}
$$
<p>&nbsp;<br>

or

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(u'',v) = -(f,v),\quad\forall v\in V\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>
This is called a <em>variational formulation</em> of the differential equation problem.

<p>
\( \forall v\in V \) means for all basis functions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\sum_{j\in\If} c_j\baspsi_j'', \baspsi_i)=-(f,\baspsi_i),\quad i\in\If\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>
For the particular choice of the sine basis functions, we
get in fact the same linear system
as in the least squares method
(because \( \baspsi''= -(i+1)^2\pi^2L^{-2}\baspsi \)).

<h4>The collocation method  <a name="___sec121"></a></h4>

<p>
Residual must vanish at selected points, or equivalently, the
differential equation with approximation \( u \) inserted, must be
fulfilled at selected points:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\sum_{j\in\If} c_j\baspsi_j''(\xno{i}) = f(\xno{i}),\quad i\in\If
\tp 
\end{equation}
$$
<p>&nbsp;<br>

This is a linear system with entries

<p>
<p>&nbsp;<br>
$$
\begin{equation*} A_{i,j}=-\baspsi_j''(\xno{i})=
(j+1)^2\pi^2L^{-2}\sin\left((j+1)\pi \frac{x_i}{L}\right),\end{equation*}
$$
<p>&nbsp;<br>

and \( b_i=2 \).

<p>
Special case: \( N=0 \), \( x_0=L/2 \)
<p>&nbsp;<br>
$$ c_0=2L^2/\pi^2 $$
<p>&nbsp;<br>

<h4>Comparison  <a name="___sec122"></a></h4>

<p>

<ul>
 <p><li> Exact solution: \( u(x)=x(L-x) \)</li>
 <p><li> Galerkin or least squares (\( N=0 \)): \( u(x)=8L^2\pi^{-3}\sin (\pi x/L) \)</li>
 <p><li> Collocation method (\( N=0 \)): \( u(x)=2L^2\pi^{-2}\sin (\pi x/L) \).</li>
 <p><li> Max error in Galerkin/least sq.: \( -0.008L^2 \)</li>
 <p><li> Max error in collocation: \( 0.047L^2 \)</li>
</ul>
<p>

<h3>Integration by parts <a name="fem:deq:1D:varform"></a></h3>

<p>

<ul>
 <p><li> Finite elements: \( \baspsi_i = \baspsi_i \)</li>
 <p><li> Problem: \( \baspsi_i' \) is discontinuous (at cell boundaries)
   and we need \( \baspsi_i'' \) in the Galerkin or least squares methods</li>
 <p><li> Remedy: integrate by parts - then we only need \( \baspsi_i' \)</li>
</ul>
<p>

Given
<p>&nbsp;<br>
$$
\begin{equation*} -(u'',v) = (f,v)\quad\forall v\in V\tp
\end{equation*}
$$
<p>&nbsp;<br>

Integrate by parts:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\int_0^L u''(x)v(x) dx &= - \int_0^Lu'(x)v'(x)dx
+ [vu']_0^L\nonumber\\ 
&= - \int_0^Lu'(x)v'(x) dx
+ u'(L)v(L) - u'(0)v(0)\tp 
\tag{43}
\end{align}
$$
<p>&nbsp;<br>


<p>
Recall that \( v(0)=v(L)=0 \), i.e.,
\( \baspsi_i(0)=\baspsi_i(L)=0 \) because we demand so where we have
Dirichlet conditions.

<p>
Advantageous features of integration by parts:

<p>

<ul>
  <p><li> Only first-order derivatives</li>
  <p><li> Symmatric coefficient matrix</li>
  <p><li> Incorporation of \( u' \) boundary conditions (later)</li>
</ul>
<p>

<h3>Boundary function  <a name="___sec124"></a></h3>
<a name="fem:deq:1D:essBC:Bfunc"></a>

<p>

<ul>
 <p><li> What about nonzero Dirichlet conditions?</li>
 <p><li> E.g. \( u(L)=D \)</li>
 <p><li> Problem: \( u(L) = \sum_j c_j\baspsi_j(L)=0 \) - always</li>
 <p><li> Remedy: \( u(x) = B(x) + \sum_j c_j\baspsi_j(x) \)</li>
 <p><li> \( u(0)=B(0) \), \( u(L)=B(L) \)</li>
 <p><li> \( B(x) \) must fulfill the Dirichlet conditions on \( u \)</li>
 <p><li> No restrictions of how \( B(x) \) varies in the interior</li>
</ul>
<p>

<h4>Example  <a name="___sec125"></a></h4>

<p>
\( u(0)=0 \) and \( u(L)=D \). Choose

<p>
<p>&nbsp;<br>
$$ B(x) = \frac{D}{L}x:\qquad B(0)=0,\ B(L)=D \tp $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \frac{x}{L}D + \sum_{j\in\If} c_j\baspsi_j(x),
\tag{44}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u(0) = 0,\quad u(L) = 0\tp  $$
<p>&nbsp;<br>

<h3>Abstract notation for variational formulations <a name="fem:deq:1D:varform:abstract"></a></h3>

<p>
The finite element literature (and much FEniCS documentation)
applies an abstract notation for the variational formulation:
*Find \( u-B\in V \) such that
<p>&nbsp;<br>
$$ a(u,v) = L(v)\quad \forall v\in V\tp $$
<p>&nbsp;<br>

<h4>Example  <a name="___sec127"></a></h4>

<p>
Given a variational formulation for \( -u''=f \):

<p>
<p>&nbsp;<br>
$$ \int_{\Omega} u' v'dx = \int_{\Omega} fvdx\quad\hbox{or}\quad (u',v') = (f,v)
\quad\forall v\in V$$
<p>&nbsp;<br>

we identify

<p>
<p>&nbsp;<br>
$$ a(u,v) = (u',v'),\quad L(v) = (f,v)\tp  $$
<p>&nbsp;<br>


<p>
Then we can write
<p>&nbsp;<br>
$$ a(u,v) = L(v)\quad \forall v\in V,$$
<p>&nbsp;<br>

if

<h4>Bilinear and linear forms  <a name="___sec128"></a></h4>

<p>
\( a(u,v) \) is a <em>bilinear form</em> and \( L(v) \) is a <em>linear form</em>.

<p>
Linear form:

<p>
<p>&nbsp;<br>
$$ L(\alpha_1 v_1 + \alpha_2 v_2)
=\alpha_1 L(v_1) + \alpha_2 L(v_2),
$$
<p>&nbsp;<br>


<p>
Bilinear form:
<p>&nbsp;<br>
$$
\begin{align*}
a(\alpha_1 u_1 + \alpha_2 u_2, v) &= \alpha_1 a(u_1,v) + \alpha_2 a(u_2, v),
\\ 
a(u, \alpha_1 v_1 + \alpha_2 v_2) &= \alpha_1 a(u,v_1) + \alpha_2 a(u, v_2)
\tp 
\end{align*}
$$
<p>&nbsp;<br>


<p>
In nonlinear problems the abstract form is \( F(u;v)=0 \) $\forall v\in V$.

<p>
The abstract form \( a(u,v)=L(v) \) is equivalent with a linear system

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} A_{i,j}c_j=b_i,\quad i\in\If$$
<p>&nbsp;<br>

with
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,j} &= a(\baspsi_j,\baspsi_i),\\ 
b_i &= L(\baspsi_i) \tp 
\end{align*}
$$
<p>&nbsp;<br>

<h3>More examples on variational formulations <a name="fem:deq:1D:varform:ex"></a></h3>

<h4>Variable coefficient  <a name="___sec130"></a></h4>

<p>
Consider the problem

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\frac{d}{dx}\left( a(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u(L)=D\tp 
\end{equation}
$$
<p>&nbsp;<br>


<p>
Two new features:

<p>

<ul>
 <p><li> a variable coefficient \( a(x) \)</li>
 <p><li> nonzero Dirichlet conditions at \( x=0 \) <em>and</em> \( x=L \)</li>
</ul>
<p>

A boundary function handles nonzero Dirichlet conditions:

<p>
<p>&nbsp;<br>
$$
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_i(x),\quad \baspsi_i(0)=\baspsi_i(L)=0
$$
<p>&nbsp;<br>


<p>
One possible choice of \( B \) is:

<p>
<p>&nbsp;<br>
$$ B(x) = C + \frac{1}{L}(D-C)x
\tp 
$$
<p>&nbsp;<br>


<p>
The residual:

<p>
<p>&nbsp;<br>
$$ R = -\frac{d}{dx}\left( a\frac{du}{dx}\right) -f\tp $$
<p>&nbsp;<br>


<p>
Galerkin's method:

<p>
<p>&nbsp;<br>
$$
(R, v) = 0,\quad \forall v\in V,
$$
<p>&nbsp;<br>


<p>
Written in terms of integrals:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} \left(\frac{d}{dx}\left( a\frac{du}{dx}\right) -f\right)v dx = 0,\quad \forall v\in V \tp 
$$
<p>&nbsp;<br>


<p>
Integration by parts:

<p>
<p>&nbsp;<br>
$$ -\int_{\Omega} \frac{d}{dx}\left( a(x)\frac{du}{dx}\right) vdx
= \int_{\Omega} a(x)\frac{du}{dx}\frac{dv}{dx}dx -
\left[a\frac{du}{dx}v\right]_0^L
\tp 
$$
<p>&nbsp;<br>

Must have \( v=0 \) where we have Dirichlet conditions: boundary terms vanish.

<p>
The final variational formulation:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} a(x)\frac{du}{dx}\frac{dv}{dx}dx = \int_{\Omega} f(x)vdx,\quad
\forall v\in V,
$$
<p>&nbsp;<br>


<p>
Alternative, compact notation:

<p>
<p>&nbsp;<br>
$$
(a u',v') = (f,v),\quad \forall v\in V
\tp 
$$
<p>&nbsp;<br>


<p>
The abstract notation is

<p>
<p>&nbsp;<br>
$$ a(u,v)=L(v)\quad\forall v\in V,$$
<p>&nbsp;<br>

with
<p>&nbsp;<br>
$$ a(u,v)= (au',v'),\quad L(v)=(f,v) \tp  $$
<p>&nbsp;<br>

Do not mix the \( a \) in \( a(\cdot,\cdot) \) (notation) and \( a(x) \) (function
name).

<p>
Can derive the linear system by inserting \( u=B + \sum_jc_j\baspsi_j \) and
\( v=\baspsi_i \):

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} (a\baspsi_j', \baspsi_i')c_j  =
(f,\baspsi_i) + (a(D-C)L^{-1},\baspsi_i'),
\quad i\in\If,
$$
<p>&nbsp;<br>

or \( \sum_j A_{i,j}c_j=b_i \) with

<p>
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,j} &= (a\baspsi_j', \baspsi_i') = \int_{\Omega} a(x)\baspsi_j'(x),
\baspsi_i'(x)dx,\\ 
b_i &= (f,\baspsi_i) + (a(D-C)L^{-1},\baspsi_i')=
\int_{\Omega} \left(f(x)\baspsi_i(x) + a(x)\frac{D-C}{L}\baspsi_i'(x)\right)dx
\tp 
\end{align*}
$$
<p>&nbsp;<br>

<h4>First-order derivative in the equation and boundary condition  <a name="___sec131"></a></h4>

<p>
Model:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u'(L)=E\tp 
\end{equation}
$$
<p>&nbsp;<br>


<p>
New features:

<p>

<ul>
 <p><li> first-order derivative \( u' \) in the equation</li>
 <p><li> boundary condition with \( u' \): \( u'(L)=E \)</li>
</ul>
<p>

Initial steps:

<p>

<ul>
 <p><li> Must force \( \baspsi_i(0)=0 \) because of Dirichlet condition at \( x=0 \)</li>
 <p><li> Boundary function: \( B(x)=C(L-x)/L \)</li>
 <p><li> No requirements on \( \baspsi_i(L) \) (no Dirichlet condition at \( x=L \))</li>
</ul>
<p>

<p>&nbsp;<br>
$$ u = \frac{C}{L}(L-x) + \sum_{j\in\If} c_j \baspsi_i(x)
\tp 
$$
<p>&nbsp;<br>


<p>
Galerkin's method: multiply by \( v \), integrate over \( \Omega \), integrate
by parts.

<p>
<p>&nbsp;<br>
$$  (-u'' + bu' - f, v) = 0,\quad\forall v\in V,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$  (-u'',v) + (bu',v) - (f, v) = 0,\quad\forall v\in V,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ (u',v') + (bu',v) = (f,v) + [u' v]_0^L, \quad\forall v\in V,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ (u'v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V,$$
<p>&nbsp;<br>

when \( [u' v]_0^L = u'(L)v(L) = E v(L) \) because
\( v(0)=0 \) and \( u'(L)=E \).

<p>
Important:

<p>

<ul>
  <p><li> The boundary term can be used to implement Neumann conditions</li>
  <p><li> Forgetting the boundary term implies the condition \( u'=0 \) (!)</li>
  <p><li> Such conditions are called <em>natural boundary conditions</em></li>
</ul>
<p>

Abstract notation:

<p>
<p>&nbsp;<br>
$$ a(u,v)=L(v)\quad\forall v\in V,$$
<p>&nbsp;<br>

with the particular formulas
<p>&nbsp;<br>
$$ a(u,v)=(u',v') + (bu',v),\quad L(v)= (f+C,v) + E v(L)\tp $$
<p>&nbsp;<br>


<p>
Linear system: insert \( u=B+\sum_jc_j\baspsi_j \) and \( v=\baspsi_i \),

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} \underbrace{((\baspsi_j',\baspsi_i') + (b\baspsi_j',\baspsi_i))}_{A_{i,j}} c_j = \underbrace{(f,\baspsi_i) + (bCL^{-1},\baspsi_i') + E \baspsi_i(L)}_{b_i}
\tp 
$$
<p>&nbsp;<br>


<p>
Observation: \( A_{i,j} \) is not symmetric because of the term

<p>
<p>&nbsp;<br>
$$
(b\baspsi_j',\baspsi_i)=\int_{\Omega} b\baspsi_j'\baspsi_i dx
 \neq \int_{\Omega} b \baspsi_i' \baspsi_jdx = (\baspsi_i',b\baspsi_j)
\tp 
$$
<p>&nbsp;<br>

<h3>Example on computing with Dirichlet and Neumann conditions  <a name="___sec132"></a></h3>

<p>
Let us solve

<p>
<p>&nbsp;<br>
$$
\begin{equation*} -u''(x)=f(x),\quad x\in \Omega=[0,1],\quad u'(0)=C,\ u(1)=D,\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Use a <em>global</em> polynomial basis \( \baspsi_i\sim x^i \) on \( [0,1] \)</li>
 <p><li> Because of \( u(1)=D \): \( \baspsi_i(1)=0 \)</li>
 <p><li> Basis: \( \baspsi_i(x)=(1-x)^{i+1} \), \( i\in\If \)</li>
 <p><li> \( B(x)=Dx \)</li>
</ul>
<p>

We have

<p>
<p>&nbsp;<br>
$$ A_{i,j} = (\baspsi_j,\baspsi_i) = \int_{0}^1 \baspsi_i'(x)\baspsi_j'(x)dx
= \int_0^1 (i+1)(j+1)(1-x)^{i+j} dx,
$$
<p>&nbsp;<br>

and

<p>
<p>&nbsp;<br>
$$
\begin{align*}
b_i &= (2,\baspsi_i) - (D,\baspsi_i') -C\baspsi_i(0)\\ 
&= \int_0^1 \left( 2(1-x)^{i+1} - D(i+1)(1-x)^i\right)dx  -C\baspsi_i(0)
\end{align*}
$$
<p>&nbsp;<br>


<p>
With \( N=1 \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\left(\begin{array}{cc}
1 & 1\\ 
1 & 4/3
\end{array}\right)
\left(\begin{array}{c}
c_0\\ 
c_1
\end{array}\right)
=
\left(\begin{array}{c}
-C+D+1\\ 
2/3 -C + D
\end{array}\right)
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ c_0=-C+D+2, \quad c_1=-1,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u(x) = 1 -x^2 + D + C(x-1) \tp  $$
<p>&nbsp;<br>

This is also the exact solution (as expected when \( V \) contains second-degree
polynomials).

<h4>Nonlinear terms  <a name="___sec133"></a></h4>

<p>
The techniques used to derive variational
forms also apply in nonlinear cases.

<p>
Consider
<p>&nbsp;<br>
$$
\begin{equation}
-(a(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
\tp 
\end{equation}
$$
<p>&nbsp;<br>


<p>
Using the Galerkin principle, we multiply by \( v\in V \) and integrate,

<p>
<p>&nbsp;<br>
$$ -\int_0^L \frac{d}{dx}\left(a(u)\frac{du}{dx}\right)v dx =
\int_0^L f(u)v\, dx\quad\forall v\in V
\tp 
$$
<p>&nbsp;<br>

Integration by parts is not affected by \( a(u) \):

<p>
<p>&nbsp;<br>
$$ \int_0^L a(u)\frac{du}{dx}\frac{dv}{dx} dx =
\int_0^L f(u)v\, dx + [avu']_0^L\quad\forall v\in V
\tp 
$$
<p>&nbsp;<br>

\( [vu']_0^L=v(L)E \) since \( v(0)=0 \) and \( u'(L)=E \).

<p>
<p>&nbsp;<br>
$$ (a(u)u', v') = (f(u),v) + a(L)v(L)E\quad\forall v\in V
\tp 
$$
<p>&nbsp;<br>


<p>
Since the problem is nonlinear, we cannot identify a <em>bilinear</em> form
\( a(u,v) \) and a <em>linear</em> form \( L(v) \).
An abstract notation is typically <em>find \( u \) such that</em>

<p>
<p>&nbsp;<br>
$$ F(u;v) = 0\quad\forall v\in V,$$
<p>&nbsp;<br>

here with
<p>&nbsp;<br>
$$ F(u;v) = (a(u)u', v') - (f(u),v) - a(L)v(L)E
\tp 
$$
<p>&nbsp;<br>


<p>
By inserting \( u=\sum_j c_j\baspsi_j \) we get a <em>nonlinear system of
algebraic equations</em> for the unknowns \( c_0,\ldots,c_N \). Such systems must
be solved by constructing a sequence of linear systems whose solutions
converge to the solution of the nonlinear system. Frequently applied
methods are Picard iteration and Newton's method.

<h3>Variational problems and optimization of functionals <a name="fem:deq:1D:optimization"></a></h3>

<p>
If \( a(u,v)=a(v,u) \), it can be shown that the variational statement
\( a(u,v)=L(v)\ \forall v\in V \) is equivalent to minimizing the functional

<p>
<p>&nbsp;<br>
$$ F(v) = \frac{1}{2}a(v,v) - L(v) $$
<p>&nbsp;<br>

That is, find \( u \) such that

<p>
<p>&nbsp;<br>
$$ F(u)\leq F(v)\quad\forall v\in V\tp $$
<p>&nbsp;<br>


<p>
Traditional use of finite elements, especially in structural analysis,
often starts with \( F(v) \) and
then derives \( a(u,v)=L(v) \).

<h2>Computing with finite elements <a name="fem:deq:1D:fem1"></a></h2>

<p>
Given

<p>
<p>&nbsp;<br>
$$ -u''(x) = 2,\quad x\in (0,L),\ u(0)=u(L)=0,$$
<p>&nbsp;<br>

with variational formulation

<p>
<p>&nbsp;<br>
$$ (u',v') = (2,v)\quad\forall v\in V\tp  $$
<p>&nbsp;<br>


<p>
Tasks:

<p>

<ul>
 <p><li> Solve for \( u \) using finite elements</li>
 <p><li> show all details</li>
 <p><li> Uniformly spaced nodes</li>
 <p><li> P1 elements</li>
</ul>
<p>

Since \( u(0)=0 \) and \( u(L)=0 \), \( c_0=c_N=0 \), and we can use a
sum over basis functions associated with internal nodes only:

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
u(x) = \sum_{j=1}^{N-1}c_j\basphi_j(x)\tp 
\end{equation*}
$$
<p>&nbsp;<br>

<h3>Computation in the global physical domain  <a name="___sec136"></a></h3>

<p>
We are to compute

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i,j}=\int_0^L\basphi_i'(x)\basphi_j'(x) dx,\quad
b_i=\int_0^L2\basphi_i(x) dx
\tp  \end{equation*}
$$
<p>&nbsp;<br>


<p>
Need \( \basphi_i'(x) \) in the formulas:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\basphi_i'(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
h^{-1},
& \xno{i-1} \leq x < \xno{i},\\ 
-h^{-1},
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{45}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Illustration of the derivative of piecewise linear basis functions associated with nodes in cell 1.  <a name="fem:approx:fe:fig:dP1"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_dbasis_p1_4e_lab.png" align="bottom" width=600></p>
</center>

<p>
We realize that \( \basphi_i' \) and \( \basphi_j' \) has no overlap, and hence their
product vanishes, unless \( i \) and \( j \) are nodes belonging to the same
element. The only nonzero contributions to the coefficient matrix are
therefore

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
2 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 2
\end{array}
\right)
\left(
\begin{array}{c}
c_1 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N-1}
\end{array}
\right)
=
\left(
\begin{array}{c}
2h \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
2h
\end{array}
\right)
\tag{46}
\end{equation}
$$
<p>&nbsp;<br>


<p>
\( c_j=u(\xno{j}) \) so we introduce \( u_j=c_j \) to easily compare with
the finite difference method. The equation corresponding to row \( i \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\frac{1}{h}u_{i-1} + \frac{2}{h}u_{i} - \frac{1}{h}u_{i+1} = 2h\tp 
\tag{47}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Standard finite difference approximation of \( -u''(x)=2 \), with
\( u''(x_i)\approx [D_x D_x u]_i \) and \( \Delta x = h \),
yields

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\frac{u_{i-1} - 2u_{i} + u_{i+1}}{h^2} = 2,
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> The finite element and the finite difference method give the
   same equation (in this example)</li>
</ul>
<p>

<h3>Elementwise computations  <a name="___sec137"></a></h3>

<p>
We follow the same elementwise set-up as for approximating \( f \) by \( u \).

<p>
Present element matrix:

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i,j}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) dx
= \int_{-1}^1 \frac{d}{dx}\refphi_r(X)\frac{d}{dx}\refphi_s(X)
\frac{h}{2} dX,\quad i=q(e,r),\ j=q(e,s),\ r,s=1,2
\tp 
\end{equation*}
$$
<p>&nbsp;<br>


<p>
\( \refphi_r(X) \) are known as functions of \( X \), but
we need \( d\refphi_r(X)/dx \).

<p>
Given

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \refphi_0(X)=\half(1-X),\quad\refphi_1(X)=\half(1+X),\end{equation*}
$$
<p>&nbsp;<br>

we can easily compute \( d\refphi_r/ dX \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}\frac{d\refphi_0}{dX} = -\half,\quad  \frac{d\refphi_1}{dX} = \half\tp  \end{equation*}
$$
<p>&nbsp;<br>

From the chain rule,

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{d\refphi_r}{dx} = \frac{d\refphi_r}{dX}\frac{dX}{dx}
= \frac{2}{h}\frac{d\refphi_r}{dX}\tp  \end{equation}
$$
<p>&nbsp;<br>

The transformed integral is then:

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i,j}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) dx
= \int_{-1}^1 \frac{2}{h}\frac{d\refphi_r}{dX}\frac{2}{h}\frac{d\refphi_s}{dX}
\frac{h}{2} dX
\tp 
\end{equation*}
$$
<p>&nbsp;<br>


<p>
The right-hand side is transformed according to

<p>
<p>&nbsp;<br>
$$
\begin{equation*} b_i^{(e)} = \int_{\Omega^{(e)}} 2\basphi_i(x) dx =
\int_{-1}^12\refphi_r(X)\frac{h}{2} dX,\quad i=q(e,r),\ r=1,2
\tp 
\end{equation*}
$$
<p>&nbsp;<br>


<p>
We have to compute the matrix entries one by one...

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\tilde A_{0,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\frac{1}{2}\right)
\frac{2}{h}\left(-\frac{1}{2}\right)\frac{2}{h} dX = \frac{1}{h}\\ 
\tilde A_{0,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\frac{1}{2}\right)
\frac{2}{h}\left(\frac{1}{2}\right)\frac{2}{h} dX = -\frac{1}{h}\\ 
\tilde A_{1,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\frac{1}{2}\right)
\frac{2}{h}\left(-\frac{1}{2}\right)\frac{2}{h} dX = -\frac{1}{h}\\ 
\tilde A_{1,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\frac{1}{2}\right)
\frac{2}{h}\left(\frac{1}{2}\right)\frac{2}{h} dX = \frac{1}{h}
\end{align*}
$$
<p>&nbsp;<br>

The element vector entries become
<p>&nbsp;<br>
$$
\begin{align*}
\tilde b_0^{(e)} &= \int_{-1}^12\half(1-X)\frac{h}{2} dX = h\\ 
\tilde b_1^{(e)} &= \int_{-1}^12\half(1+X)\frac{h}{2} dX = h\tp 
\end{align*}
$$
<p>&nbsp;<br>


<p>
In matrix/vector notation:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1\\ 
1
\end{array}\right)\tp 
\tag{48}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Must assemble - but first see how to incorporate boundary conditions.

<h2>Boundary conditions: specified value <a name="fem:deq:1D:essBC"></a></h2>

<h3>General construction of a boundary function <a name="fem:deq:1D:essBC:Bfunc"></a></h3>

<p>

<ul>
  <p><li> \( B(x) \) is not always easy to construct (extend to the interior of \( \Omega \)),
    at least not in 2D and 3D</li>
  <p><li> With finite element \( \basphi_i \), \( B(x) \) can be constructed in
    a completely general way</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
B(x) = \sum_{j\in D} U_j\basphi_j(x), \end{equation}
$$
<p>&nbsp;<br>

where \( D \) are the nodes with Dirichlet conditions and \( U_j \) the known values.

<p>
In 1D
<p>&nbsp;<br>
$$
\begin{equation}
B(x) = U_0\basphi_0(x) + U_N\basphi_N(x)\tp  \end{equation}
$$
<p>&nbsp;<br>


<p>
Unknowns: \( c_1,\ldots,c_{N-1} \),

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = U_0\basphi_0(x) + U_N\basphi_N(x) + \sum_{j=1}^{N-1} c_j\basphi_j(x)\tp  \end{equation}
$$
<p>&nbsp;<br>

<h4>Example  <a name="___sec140"></a></h4>

<p>
<p>&nbsp;<br>
$$ -u''=2, \quad u(0)=0,\ u(L)=D\tp  $$
<p>&nbsp;<br>


<p>
The expansion for \( u(x) \) reads

<p>
<p>&nbsp;<br>
$$
u(x) = 0\cdot\basphi_0(x) + D\basphi_N(x) +
\sum_{j=1}^{N-1} c_j\basphi_j(x)
\tp 
$$
<p>&nbsp;<br>

Inserting this expression in \( -(u'',\basphi_i)=(f,\basphi_i) \) and
integrating by parts results in a linear system with

<p>
<p>&nbsp;<br>
$$
A_{i,j} = \int_0^L \basphi_i'(x)\basphi_j'(x) dx,\quad
b_i = \int_0^L (f(x) - D\basphi_N'(x))\basphi_i(x) dx,
$$
<p>&nbsp;<br>

for \( i,j = 1,\ldots,N-1 \).

<h3>Modification of the linear system <a name="fem:deq:1D:essBC:Bfunc:modsys"></a></h3>

<p>

<ul>
 <p><li> \( B(x) \) and a reduced set of unknowns (e.g., \( c_1,\ldots,c_{N-1} \))
   are not so convenient in implementations</li>
 <p><li> We shall look at a less strict mathematical procedure that
   gives simpler impelementation</li>
 <p><li> Step 1: compute everything as there were no Dirichlet conditions</li>
 <p><li> Step 2: modify the linear system such that all known \( c_j \) get
   their right boundary values</li>
</ul>
<p>

Linear system from \( -u''=f \) without taking Dirichlet conditions into
account (\( u=\sum_{j\in\If}c_j\basphi_j \)):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
h \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
h
\end{array}
\right)
\tag{49}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Actions:

<p>

<ul>
 <p><li> General: replace row \( i \) by \( c_i=K \) if \( u \) at \( \xno{i} \) is prescrined as \( K \)</li>
 <p><li> Here: replace the first and last row by \( c_0=0 \) and \( c_N=D \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
D
\end{array}
\right)
\tag{50}
\end{equation}
$$
<p>&nbsp;<br>

<h3>Symmetric modification of the linear system  <a name="___sec142"></a></h3>

<p>

<ul>
 <p><li> The modification above destroys symmetry of the matrix (\( A_{0,1}\neq A_{1,0} \))</li>
 <p><li> Symmetry is often important in 2D and 3D (faster computations)</li>
 <p><li> A more complex modification preserves symmetry</li>
</ul>
<p>

Algorithm for incorporating \( c_i=K \):

<p>

<ol>
<p><li> Subtract column \( i \) times \( K \) from the right-hand side</li>
<p><li> Zero out column and row no \( i \)</li>
<p><li> Place 1 on the diagonal</li>
<p><li> Set \( b_i=K \)</li>
</ol>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
0 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & 0 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h +D/h\\ 
D
\end{array}
\right)
\tag{51}
\end{equation}
$$
<p>&nbsp;<br>

<h3>Modification of the element matrix and vector  <a name="___sec143"></a></h3>

<p>

<ul>
 <p><li> Modification of the linear system can be done in the
   the element matrix and vector instead</li>
 <p><li> Exactly the same procedure</li>
</ul>
<p>

Last degree of freedom in the last element is prescribed:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(N-1)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h\\ 
D
\end{array}\right)\tp 
\tag{52}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Or symmetric modification:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(N-1)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 0\\ 
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h + D/h\\ 
D
\end{array}\right)\tp 
\tag{53}
\end{equation}
$$
<p>&nbsp;<br>

<h2>Boundary conditions: specified derivative <a name="fem:deq:1D:BC:nat"></a></h2>

<p>
Focus now: how to incorporate \( u'(0)=C \) with finite elements.

<h3>The variational formulation  <a name="___sec145"></a></h3>

<p>
Start with the Galerkin method:

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \int_0^L(u''(x)+f(x))\basphi_i(x) dx = 0,\quad i\in\If,\end{equation*}
$$
<p>&nbsp;<br>


<p>
Integration of \( u''\basphi_i \) by parts:

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \int_0^Lu'(x)'\basphi_i'(x) dx -(u'(L)\basphi_i(L) - u'(0)\basphi_i(0)) =
\int_0^L f(x)\basphi_i(x) dx
\tp 
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Since \( \basphi_i(L)=0 \), \( u'(L)\basphi_i(L)=0 \)</li>
 <p><li> \( u'(0)\basphi_i(0) = C\basphi_i(0) \) since \( u'(0)=C \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*} \int_0^Lu'(x)\basphi_i'(x) dx + C\basphi_i(0) =
\int_0^L f(x)\basphi_i(x) dx,\quad i\in\If\tp  \end{equation*}
$$
<p>&nbsp;<br>

Inserting

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) = B(x) + \sum_{j=0}^{N-1} c_j\basphi_j(x),
\quad B(x) = D\basphi_N(x),
\end{equation*}
$$
<p>&nbsp;<br>

<!-- \frac{x}{L}D -->
leads to the linear system

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j=0}^{N-1}\left(
\int_0^L \basphi_i'(x)\basphi_j'(x) dx \right)c_j =
\int_0^L\left(f(x)\basphi_i(x) -D\basphi_N'(x)\basphi_i(x)\right) dx
 - C\basphi_i(0),
\tag{54}
\end{equation}
$$
<p>&nbsp;<br>

for \( i=0,\ldots,N-1 \).

<p>
Alternatively, we may just work with

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) = \sum_{j=0}^{N} c_j\basphi_j(x),
\end{equation*}
$$
<p>&nbsp;<br>

and modify the last equation to \( c_N=D \) in the linear system.

<p>
The extra term with \( C \) affects only the element vector from the
first element:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(0)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(0)} = \left(\begin{array}{c}
h - C\\ 
h
\end{array}\right)\tp 
\tag{55}
\end{equation}
$$
<p>&nbsp;<br>

<h2>The finite element algorithm  <a name="___sec146"></a></h2>

<p>
The problem at hand determines the integrals in the variational
formulation.

<p>
Request these functions from the user:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">integrand_lhs(phi, r, s, x)
boundary_lhs(phi, r, s, x)
integrand_rhs(phi, r, x)
boundary_rhs(phi, r, x)
</code></pre></div>
<p>
Given a mesh in terms of <code>vertices</code>, <code>cells</code>, and <code>dof_map</code>,
the rest is (almost) automatic.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&lt;Declare <span style="color: #8B008B; font-weight: bold">global</span> matrix <span style="color: #8B008B">and</span> rhs: A, b&gt;

<span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(cells)):

    <span style="color: #228B22"># Compute element matrix and vector</span>
    n = <span style="color: #658b00">len</span>(dof_map[e])  <span style="color: #228B22"># no of dofs in this element</span>
    h = vertices[cells[e][<span style="color: #B452CD">1</span>]] - vertices[cells[e][<span style="color: #B452CD">1</span>]]
    &lt;Declare element matrix <span style="color: #8B008B">and</span> vector: A_e, b_e&gt;

    <span style="color: #228B22"># Integrate over the reference cell</span>
    points, weights = &lt;numerical integration rule&gt;
    <span style="color: #8B008B; font-weight: bold">for</span> X, w <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(points, weights):
        phi = &lt;basis functions <span style="color: #8B008B">and</span> derivatives at X&gt;
        detJ = h/<span style="color: #B452CD">2</span>
        x = &lt;affine mapping <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">X</span>&gt;
        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
                A_e[r,s] += integrand_lhs(phi, r, s, x)*detJ*w
            b_e[r] += integrand_rhs(phi, r, x)*detJ*w

    <span style="color: #228B22"># Add boundary terms</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            A_e[r,s] += boundary_lhs(phi, r, s, x)*detJ*w
        b_e[r] += boundary_rhs(phi, r, x)*detJ*w

    <span style="color: #228B22"># Incorporate essential boundary conditions</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        global_dof = dof_map[e][r]
        <span style="color: #8B008B; font-weight: bold">if</span> global_dof <span style="color: #8B008B">in</span> essbc_dofs:
            <span style="color: #228B22"># dof r is subject to an essential condition</span>
            value = essbc_docs[global_dof]
            <span style="color: #228B22"># Symmetric modification</span>
            b_e -= value*A_e[:,r]
            A_e[r,:] = <span style="color: #B452CD">0</span>
            A_e[:,r] = <span style="color: #B452CD">0</span>
            A_e[r,r] = <span style="color: #B452CD">1</span>
            b_e[r] = value

    <span style="color: #228B22"># Assemble</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            A[dof_map[e][r], dof_map[e][r]] += A_e[r,s]
        b[dof_map[e][r] += b_e[r]

&lt;solve linear system&gt;
</code></pre></div>

<h2>Variational formulations in 2D and 3D <a name="fem:deq:2D:varform"></a></h2>

<p>
How to do integration by parts is the major difference when moving to
2D and 3D.

<p>
Consider

<p>
<p>&nbsp;<br>
$$ \nabla^2 u \quad\hbox{or}\quad \nabla\cdot\left( a(\x)\nabla u\right)
\tp 
$$
<p>&nbsp;<br>

with explicit 2D expressions
<p>&nbsp;<br>
$$ \nabla^2 u = \nabla\cdot\nabla u =
\frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2},
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
\nabla\cdot\left( a(\x)\nabla u\right) =
\frac{\partial}{\partial x}\left( a(x,y)\frac{\partial u}{\partial x}\right) +
\frac{\partial}{\partial y}\left( a(x,y)\frac{\partial u}{\partial y}\right)
\tp 
$$
<p>&nbsp;<br>


<p>
The general rule for integrating by parts is

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\int_{\Omega} \nabla\cdot (a(\x)\nabla u) v\dx =
\int_{\Omega} a(\x)\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} a\frac{\partial u}{\partial n} v \ds,
\tag{56}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \int_\Omega ()\dx \): area (2D) or volume (3D) integral</li>
 <p><li> \( \int_{\partial\Omega} ()\ds \): line(2D) or surface (3D) integral</li>
</ul>
<p>

Let us divide the boundary into two parts:

<p>

<ul>
 <p><li> \( \partial\Omega_N \), where we have Neumann conditions
   \( -a\frac{\partial u}{\partial n} = g \), and</li>
 <p><li> \( \partial\Omega_D \), where we have Dirichlet conditions
   \( u = u_0 \).</li>
</ul>
<p>

The test functions \( v \) are required to vanish on \( \partial\Omega_D \).

<h4>Example  <a name="___sec148"></a></h4>

<p>
A general and widely appearing PDE problem:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\v\cdot\nabla u + \alpha u &= \nabla\cdot\left( a\nabla u\right) + f,
\quad\x\in\Omega,\\ 
u &= u_0,\quad\x\in\partial\Omega_D,\\ 
-a\frac{\partial u}{\partial n} &= g,\quad\x\in\partial\Omega_N
\tp 
\end{align}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Known: \( a \), \( \alpha \), \( f \), \( u_0 \), and \( g \).</li>
 <p><li> Second-order PDE: must have <em>exactly one boundary condition at each
   point of the boundary</em></li>
 <p><li> \( \partial\Omega_N\cup\partial\Omega_D \) = entire boundary</li>
</ul>
<p>

The unknown function can be expanded as

<p>
<p>&nbsp;<br>
$$ u = u_0 + \sum_{j\in\If} c_j\basphi_j \tp $$
<p>&nbsp;<br>


<p>
Galerkin's method: multiply by \( v\in V \) and integrate over \( \Omega \),

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
\int_{\Omega} \nabla\cdot\left( a\nabla u\right)\dx + \int_{\Omega}fv \dx
\tp 
$$
<p>&nbsp;<br>

Integrate second-order term by parts,

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} \nabla\cdot\left( a\nabla u\right) v \dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds,
$$
<p>&nbsp;<br>

resulting in

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
+ \int_{\Omega} fv \dx
\tp 
$$
<p>&nbsp;<br>

Note: \( v\neq 0 \) only on \( \partial\Omega_N \):
<p>&nbsp;<br>
$$ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
= \int_{\partial\Omega_N} a\frac{\partial u}{\partial n} v\ds,
$$
<p>&nbsp;<br>

Insert flux condition \( a\frac{\partial u}{\partial n}=-g \) on \( \partial\Omega_N \):
<p>&nbsp;<br>
$$
-\int_{\partial\Omega_N} gv\ds\tp 
$$
<p>&nbsp;<br>

The final variational form:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v \dx
- \int_{\partial\Omega} g v\ds
+ \int_{\Omega} fv \dx
\tp 
$$
<p>&nbsp;<br>


<p>
With inner product notation:

<p>
<p>&nbsp;<br>
$$
(\v\cdot\nabla u, v) + (\alpha u,v) =
- (a\nabla u,\nabla v) - (g,v)_{N} + (f,v)
\tp 
$$
<p>&nbsp;<br>

\( (g,v)_{N} \): line or surface integral over \( \partial\Omega_N \).

<p>
Inserting the \( u \) expansion results in
a linear system with

<p>
<p>&nbsp;<br>
$$
A_{i,j} = (\v\cdot\nabla \basphi_j, \basphi_i) + (\alpha \basphi_j ,\basphi_i) + (a\nabla \basphi_j,\nabla \basphi_i)
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
b_i = (g,\basphi_i)_{N} + (f,\basphi_i) -
(\v\cdot\nabla u_0, \basphi_i) + (\alpha u_0 ,\basphi_i) +
(a\nabla u_0,\nabla \basphi_i),
$$
<p>&nbsp;<br>

<h3>Transformation to a reference cell in 2D and 3D  <a name="___sec149"></a></h3>

<p>
We consider an integral of the type

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{{\Omega}^{(e)}} a(\x)\nabla\basphi_i\cdot\nabla\basphi_j\dx
\end{equation}
$$
<p>&nbsp;<br>

in the physical domain.

<p>
Goal: integrate this term over the reference cell.

<p>
Mapping from reference to physical coordinates:

<p>
<p>&nbsp;<br>
$$ \x(\X), $$
<p>&nbsp;<br>

with Jacobian, \( J \), given by
<p>&nbsp;<br>
$$ J_{i,j}=\frac{\partial x_j}{\partial X_i}\tp $$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Step 1: \( \dx \rightarrow \det J\dX \).</li>
 <p><li> Step 2: express \( \nabla\basphi_i \) by an expression with \( \refphi_r \) (\( i=q(e,r) \))</li>
 <p><li> We want \( \nabla_{\x}\refphi_r(\X) \) (derivatives wrt \( \x \))</li>
 <p><li> What we readily have: \( \nabla_{\X}\refphi_r(\X) \) (derivative wrt \( \X \))</li>
 <p><li> Need to transform \( \nabla_{\X}\refphi_r(\X) \) to \( \nabla_{\x}\refphi_r(\X) \)</li>
</ul>
<p>

Can derive

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\nabla_{\X}\refphi_r &= J\cdot\nabla_{\x}\basphi_i,\\ 
\nabla_{\x}\basphi_i &= J^{-1}\cdot\nabla_{\X}\refphi_r\tp 
\end{align*}
$$
<p>&nbsp;<br>


<p>
Integral transformation from physical to reference coordinates:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega}^{(e)} a(\x)\nabla_{\x}\basphi_i\cdot\nabla_{\x}\basphi_j\dx
\int_{\tilde\Omega^r} a(\x(\X))(J^{-1}\cdot\nabla_{\X}\refphi_r)\cdot
(J^{-1}\cdot\nabla\refphi_s)\det J\dX
\end{equation}
$$
<p>&nbsp;<br>

<h2>Systems of differential equations <a name="fem:sys"></a></h2>

<p>
Consider \( m+1 \) unknown functions: \( u^{(0)},\ldots, u^{(m)} \) governed
by \( m+1 \) differential equations:

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\mathcal{L}_0(u^{(0)},\ldots,u^{(m)}) &= 0,\\ 
&\vdots\\ 
\mathcal{L}_{m}(u^{(0)},\ldots,u^{(m)}) &= 0,
\end{align*}
$$
<p>&nbsp;<br>

<h3>Variational forms <a name="fem:sys:vform"></a></h3>

<p>

<ul>
 <p><li> First approach: treat each equation as a scalar equation</li>
 <p><li> For equation no. \( i \), use test function \( v^{(i)}\in V^{(i)} \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align}
\int_\Omega \mathcal{L}^{(0)}(u^{(0)},\ldots,u^{(m)}) v^{(0)}\dx &= 0,
\tag{57}\\ 
&\vdots\\ 
\int_\Omega \mathcal{L}^{(m)}(u^{(0)},\ldots,u^{(m)}) v^{(m)}\dx &= 0
\tag{58}
\tp 
\end{align}
$$
<p>&nbsp;<br>

Terms with second-order derivatives may be integrated by parts, with
Neumann conditions inserted in boundary integrals.

<p>
<p>&nbsp;<br>
$$ V^{(i)} = \hbox{span}\{\basphi_0^{(i)},\ldots,\basphi_{N_i}^{(i)}\},$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u^{(i)} = B^{(i)}(\x) + \sum_{j=0}^{N_i} c_j^{(i)} \basphi_j^{(i)}(\x),
$$
<p>&nbsp;<br>


<p>
Can derive \( m \) coupled linear systems for the unknowns
\( c_j^{(i)} \), \( j=0,\ldots,N_i \),
\( i=0,\ldots,m \).

<p>

<ul>
 <p><li> Second approach: work with vectors (and vector notation)</li>
 <p><li> \( \u = (u^{(0)},\ldots,u^{(m)}) \)</li>
 <p><li> \( \v = (u^{(0)},\ldots,u^{(m)}) \)</li>
 <p><li> \( \u, \v \in  \V = V^{(0)}\times \cdots \times V^{(m)} \)</li>
 <p><li> Note: if \( \boldsymbol{B} = (B^{(0)},\ldots,B^{(m)}) \) is needed for
   nonzero Dirichlet conditions, \( \u - \boldsymbol{B}\in \V \) (not \( \u \) in \( \V \))</li>
 <p><li> \( \boldsymbol{\mathcal{L}}(\u ) = 0 \)</li>
 <p><li> \( \boldsymbol{\mathcal{L}}(\u ) = (\mathcal{L}^{(0)}(\u),\ldots, \mathcal{L}^{(m)}(\u)) \)</li>
</ul>
<p>

The variational form is derived by taking the <em>inner product</em> of
\( \boldsymbol{\mathcal{L}}(\u ) \) and \( \v \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_\Omega \boldsymbol{\mathcal{L}}(\u )\cdot\v = 0\quad\forall\v\in\V\tp 
\tag{59}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Observe: this is a scalar equation (!).</li>
 <p><li> Can derive \( m \) independent equation by choosing \( m \) independent \( \v \)</li>
 <p><li> E.g.: \( \v = (v^{(0)},0,\ldots,0) \) recovers <a href="#mjx-eqn-57">(57)</a></li>
 <p><li> E.g.: \( \v = (0,\ldots,0,v^{(m)} \) recovers <a href="#mjx-eqn-58">(58)</a></li>
</ul>
<p>

<h3>A worked example <a name="fem:sys:uT:ex"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mu \nabla^2 w &= -\beta,
\tag{60}\\ 
\kappa\nabla^2 T &= - \mu ||\nabla w||^2 \quad (= \mu \nabla w\cdot\nabla w)
\tp 
\tag{61}
\end{align}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Unknowns: \( w(x,y) \), \( T(x,y) \)</li>
 <p><li> Known constants: \( \mu \), \( \beta \), \( \kappa \)</li>
 <p><li> Application: fluid flow in a straight pipe, \( w \) is velocity, \( T \) is
   temperature</li>
 <p><li> \( \Omega \): cross section of the pipe</li>
 <p><li> Boundary conditions: \( w=0 \) and \( T=T_0 \) on \( \partial\Omega \)</li>
 <p><li> Note: \( T \) depends on \( w \), but \( w \) does not depend on \( T \) (one-way coupling)</li>
</ul>
<p>

<h3>Identical function spaces for the unknowns  <a name="___sec153"></a></h3>

<p>
Let \( w, (T-T_0) \in V \) with test functions \( v\in V \).

<p>
<p>&nbsp;<br>
$$ V = \hbox{span}\{\basphi_0(x,y),\ldots,\basphi_N(x,y)\}, $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
w = \sum_{j=0}^N c^{(w)}_j \basphi_j,\quad T = T_0 + \sum_{j=0}^N c^{(T)}_j
\basphi_j\tp 
\tag{62}
\end{equation}
$$
<p>&nbsp;<br>

<h4>Variational form of each individual PDE  <a name="___sec154"></a></h4>

<p>
Inserting <a href="#mjx-eqn-62">(62)</a>
in the PDEs, results in the residuals

<p>
<p>&nbsp;<br>
$$
\begin{align}
R_w &= \mu \nabla^2 w + \beta,
\tag{63}\\ 
R_T &= \kappa\nabla^2 T + \mu ||\nabla w||^2
\tp 
\tag{64}
\end{align}
$$
<p>&nbsp;<br>


<p>
Galerkin's method: make residual orthogonal to \( V \),

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\int_\Omega R_w v \dx &=0\quad\forall v\in V,\\ 
\int_\Omega R_T v \dx &=0\quad\forall v\in V
\tp 
\end{align*}
$$
<p>&nbsp;<br>


<p>
Integrate by parts and use \( v=0 \) on \( \partial\Omega \) (Dirichlet conditions!):

<p>
<p>&nbsp;<br>
$$
\begin{align}
\int_\Omega \mu \nabla w\cdot\nabla v \dx &= \int_\Omega \beta v\dx
\quad\forall v\in V,
\tag{65}\\ 
\int_\Omega \kappa \nabla T\cdot\nabla v \dx &= \int_\Omega \mu
\nabla w\cdot\nabla w\, v\dx \quad\forall v\in V
\tag{66}
\tp 
\end{align}
$$
<p>&nbsp;<br>

<h4>Compound scalar variational form  <a name="___sec155"></a></h4>

<p>

<ul>
 <p><li> Test vector function \( \v\in\V = V\times V \)</li>
 <p><li> Take the inner product of \( \v \) and the system of PDEs (and integrate)</li>
</ul>
<p>

<p>&nbsp;<br>
$$ \int_{\Omega} (R_w, R_T)\cdot\v \dx = 0\quad\forall\v\in\V
\tp $$
<p>&nbsp;<br>


<p>
With \( \v = (v_0,v_1) \):

<p>
<p>&nbsp;<br>
$$ \int_{\Omega} (R_w v_0 + R_T v_1) \dx = 0\quad\forall\v\in\V
\tp $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_\Omega (\mu\nabla w\cdot\nabla v_0 + \kappa\nabla T\cdot\nabla v_1)\dx
= \int_\Omega (\beta v_0 + \mu\nabla w\cdot\nabla w\, v_1)\dx,
\quad\forall \v\in\V
\tag{67}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Choosing \( v_0=v \) and \( v_1=0 \) gives the variational form
<a href="#mjx-eqn-65">(65)</a>, while \( v_0=0 \) and \( v_1=v \) gives
<a href="#mjx-eqn-66">(66)</a>.

<p>
Alternative inner product notation:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mu (\nabla w,\nabla v) &= (\beta, v)
\quad\forall v\in V,
\tag{68}\\ 
\kappa(\nabla T,\nabla v) &= \mu(\nabla w\cdot\nabla w, v)\quad\forall v\in V
\tag{69}
\tp 
\end{align}
$$
<p>&nbsp;<br>

<h4>Decoupled linear systems  <a name="___sec156"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j=0}^N A^{(w)}_{i,j} c^{(w)}_j &= b_i^{(w)},\quad i=0,\ldots,N,
\tag{70}\\ 
\sum_{j=0}^N A^{(T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N,
\tag{71}\\ 
A^{(w)}_{i,j} &= \mu(\nabla \basphi_j,\nabla\basphi_i),\\ 
b_i^{(w)} &= (\beta, \basphi_i),\\ 
A^{(T)}_{i,j} &= \kappa(\nabla \basphi_j,\nabla\basphi_i),\\ 
b_i^{(T)} &= (\mu\nabla w_{-}\cdot (\sum_k
c^{(w)}_k\nabla\basphi_k), \basphi_i)
\tp 
\end{align}
$$
<p>&nbsp;<br>


<p>
Matrix-vector form (alternative notation):

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mu K c^{(w)} &= b^{(w)},\\ 
\kappa K c^{(T)} &= b^{(T)},
\end{align}
$$
<p>&nbsp;<br>

where

<p>
<p>&nbsp;<br>
$$
\begin{align*}
K_{i,j} &= (\nabla \basphi_j,\nabla \basphi_i),\\ 
b^{(w)} &= (b_0^{(w)},\ldots,b_{N}^{(w)}),\\ 
b^{(T)} &= (b_0^{(T)},\ldots,b_{N}^{(T)}),\\ 
c^{(w)} &= (c_0^{(w)},\ldots,c_{N}^{(w)}),\\ 
c^{(T)} &= (c_0^{(T)},\ldots,c_{N}^{(T)})\tp 
\end{align*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> First solve the system for \( c^{(w)} \)</li>
 <p><li> Then solve the system for \( c^{(T)} \)</li>
</ul>
<p>

<h4>Coupled linear systems  <a name="___sec157"></a></h4>

<p>

<ul>
 <p><li> Pretend two-way coupling, i.e., need to solve for \( w \) and \( T \) simultaneously</li>
 <p><li> Want to derive <em>one system</em> for \( c_j^{(w)} \) and \( c_j^{(T)} \), \( j=0,\ldots,N \)</li>
 <p><li> The system is nonlinear because of \( \nabla w\cdot\nabla w \)</li>
 <p><li> Linearization: pretend an iteration where \( \hat w \) is computed
   in the previous iteration and set \( \nabla w\cdot\nabla w
   \approx \nabla\hat w\cdot\nabla w \) (so the term becomes linear in \( w \))</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align}
\sum_{j=0}^N A^{(w,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^N A^{(w,T)}_{i,j} c^{(T)}_j
&= b_i^{(w)},\quad i=0,\ldots,N,
\tag{72}\\ 
\sum_{j=0}^N A^{(T,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^N A^{(T,T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N,
\tag{73}\\ 
A^{(w,w)}_{i,j} &= \mu(\nabla \basphi_j,\basphi_i),\\ 
A^{(w,T)}_{i,j} &= 0,\\ 
b_i^{(w)} &= (\beta, \basphi_i),\\ 
A^{(w,T)}_{i,j} &= \mu(\nabla w_{-}\cdot\nabla\basphi_j), \basphi_i),\\ 
A^{(T,T)}_{i,j} &= \kappa(\nabla \basphi_j,\basphi_i),\\ 
b_i^{(T)} &= 0
\tp 
\end{align}
$$
<p>&nbsp;<br>


<p>
Alternative notation:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mu K c^{(w)} &= b^{(w)},\\ 
L c^{(w)} + \kappa K c^{(T)} & =0,
\end{align}
$$
<p>&nbsp;<br>

\( L \) is the matrix from the \( \nabla w_{-}\cdot\nabla \) operator:
\( L_{i,j} = A^{(w,T)}_{i,j} \).

<p>
Corresponding block form:

<p>
<p>&nbsp;<br>
$$
\left(\begin{array}{cc}
\mu K & 0\\ 
L & \kappa K
\end{array}\right)
\left(\begin{array}{c}
c^{(w)}\\ 
c^{(T)}
\end{array}\right) =
\left(\begin{array}{c}
b^{(w)}\\ 
0
\end{array}\right)
\tp 
$$
<p>&nbsp;<br>

<h3>Different function spaces for the unknowns  <a name="___sec158"></a></h3>

<p>

<ul>
 <p><li> Generalization: \( w\in V^{(w)} \) and \( T\in V^{(T)} \),
   \( V^{(w)} \neq V^{(T)} \)</li>
 <p><li> This is called a <em>mixed finite element method</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align*}
V^{(w)} &= \hbox{span}\{\basphi_0^{(w)},\ldots,\basphi_{N_w}^{(w)}\},\\ 
V^{(T)} &= \hbox{span}\{\basphi_0^{(T)},\ldots,\basphi_{N_T}^{(T)}\}
\tp 
\end{align*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align}
\int_\Omega \mu \nabla w\cdot\nabla v^{(w)} \dx &= \int_\Omega \beta v^{(w)}\dx
\quad\forall v^{(w)}\in V^{(w)},
\tag{74}\\ 
\int_\Omega \kappa \nabla T\cdot\nabla v^{(T)} \dx &= \int_\Omega \mu
\nabla w\cdot\nabla w\, v^{(T)}\dx \quad\forall v^{(T)}\in V^{(T)}
\tag{75}
\tp 
\end{align}
$$
<p>&nbsp;<br>


<p>
Take the inner product with \( \v = (v^{(w)}, v^{(T)}) \) and integrate:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_\Omega (\mu\nabla w\cdot\nabla v^{(w)} +
\kappa\nabla T\cdot\nabla v^{(T)})\dx
= \int_\Omega (\beta v^{(w)} + \mu\nabla w\cdot\nabla w\, v^{(T)})\dx,
\tag{76}
\end{equation}
$$
<p>&nbsp;<br>

valid \( \forall \v\in\V = V^{(w)}\times V^{(T)} \).


</section>



<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>
-->

<!-- deck.goto snippet
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>
-->

<!-- deck.hash snippet
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>
-->

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery-1.7.2.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/notes/deck.notes.js"></script>

<!-- From https://github.com/mikeharris100/deck.pointer.js -->
<script src="deck.js/extensions/pointer/deck.pointer.js"></script>

<!-- From https://github.com/stvnwrgs/presenterview -->
<script type="text/javascript" src="deck.js/extensions/presenterview/deck.presenterview.js"></script>

<!-- From https://github.com/nemec/deck.annotate.js
<script type="text/javascript" src="deck.js/extensions/deck.annotate.js/deck.annotate.js"></script>
-->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>


</body>
</html>
