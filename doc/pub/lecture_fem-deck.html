<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study Guide: Introduction to Finite Element Methods">
<meta name="keywords" content="approximation of general vectors,Galerkin method,projection,approximation of functions,approximation by sines,collocation method (approximation),approximation collocation,Lagrange (interpolating) polynomial,sparse matrices,mass matrix,mass lumping,lumped mass matrix,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,Midpoint rule,Trapezoidal rule,Simpson's rule,Gauss-Legendre quadrature,simplex elements,simplices,faces,edges,isoparametric mapping,mapping of reference cells isoparametric mapping,trial function,test function,trial space,test space,integration by parts,mixed finite elements">







<!-- deck.js: https://github.com/imakewebthings/deck.js -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=1024, user-scalable=no">

<!-- Required stylesheet -->
<link rel="stylesheet" href="deck.js/core/deck.core.css">

<!-- Extension CSS files go here. Remove or add as needed.
deck.goto: Adds a shortcut key to jump to any slide number.
Hit g, type in the slide number, and hit enter.

deck.hash: Enables internal linking within slides, deep
linking to individual slides, and updates the address bar and
a permalink anchor with each slide change.

deck.menu: Adds a menu view, letting you see all slides in a grid.
Hit m to toggle to menu view, continue navigating your deck,
and hit m to return to normal view. Touch devices can double-tap
the deck to switch between views.

deck.navigation: Adds clickable left and right buttons for the
less keyboard inclined.

deck.status: Adds a page number indicator. (current/total).

deck.scale: Scales each slide to fit within the deck container
using CSS Transforms for those browsers that support them.

deck.pointer: Turn mouse into laser pointer (toggle with p).
(Requires https://github.com/mikeharris100/deck.pointer.js)
-->

<link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
<link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
<link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">
<link rel="stylesheet" href="deck.js/extensions/pointer/deck.pointer.css">
<link rel="stylesheet" href="deck.js/extensions/notes/deck.notes.css">
<!--
<link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
<link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
<link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
-->

<!-- Style theme. More available in themes/style/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">

<!--
<link rel="stylesheet" href="deck.js/themes/style/neon.css">
<link rel="stylesheet" href="deck.js/themes/style/swiss.css">
<link rel="stylesheet" href="deck.js/themes/style/web-2.0.css">

git clone git://github.com/duijf/mnml.git
<link rel="stylesheet" href="deck.js/themes/style/mnml.css">

git://github.com/groovecoder/deckjs-theme-mozilla.git
<link rel="stylesheet" href="deck.js/themes/style/sandstone.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.aurora.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.dark.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.firefox.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.light.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.mdn.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.nightly.css">

git://github.com/barraq/deck.ext.js.git
<link rel="stylesheet" href="deck.js/themes/style/beamer.css">
-->

<!-- Transition theme. More available in /themes/transition/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
<!--
<link rel="stylesheet" href="deck.js/themes/transition/fade.css">
<link rel="stylesheet" href="deck.js/themes/transition/vertical-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
-->

<!-- Required Modernizr file -->
<script src="deck.js/modernizr.custom.js"></script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .slide .alert-text-small   { font-size: 80%;  }
    .slide .alert-text-large   { font-size: 130%; }
    .slide .alert-text-normal  { font-size: 90%;  }
    .slide .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
               -webkit-border-radius:14px; -moz-border-radius:14px;
             border-radius:14px
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .slide .alert-block {padding-top:14px; padding-bottom:14px}
     .slide .alert-block > p, .alert-block > ul {margin-bottom:0}
     /*.slide .alert li {margin-top: 1em}*/
     .deck .alert-block p+p {margin-top:5px}
     /*.slide .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_notice.png); }
     .slide .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_summary.png); }
     .slide .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_warning.png); }
     .slide .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body class="deck-container">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\If}{\mathcal{I}}     % for FEM
\newcommand{\Ifd}{\mathcal{I}_d}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    



<section class="slide">
<!-- ------------------- main content ---------------------- -->


<title>Study Guide: Introduction to Finite Element Methods</title>

<center><h1>Study Guide: Introduction to Finite Element Methods</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b style="font-weight: bold">Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b style="font-weight: bold">Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b style="font-weight: bold">Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Sep 26, 2013</h4></center> <!-- date -->
<p>

</section>


<section class="slide">

<h2>Why finite elements?  <a name="___sec0"></a></h2>

<p>

<ul>
 <p><li> Can with ease solve PDEs in domains with <em>complex geometry</em></li>
 <p><li> Can with ease provide higher-order approximations</li>
 <p><li> Has (in simpler problems) a rigorus mathematical analysis framework
   (not much considered here - not powerful enough to uncover the
   serious limitations of the method in time-dependent problems
   and the necessary adjustments)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Domain for flow around a dolphin  <a name="___sec1"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_mesh.png" align="bottom" width=400,></p></center>

<p>

</section>


<section class="slide">

<h3>The flow  <a name="___sec2"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_flow.gif" align="bottom" width=400,></p></center>

<p>

</section>


<section class="slide">

<h3>Basic ingredients  <a name="___sec3"></a></h3>

<p>

<ul>
 <p><li> Transform the PDE problem to a <em>variational form</em></li>
 <p><li> Define function approximation over <em>finite elements</em></li>
 <p><li> Use a machinery to derive <em>linear systems</em></li>
 <p><li> Solve linear systems</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Learning strategy  <a name="___sec4"></a></h3>

<p>

<ul>
 <p><li> Start with approximation of functions</li>
 <p><li> Introduce finite element <em>approximations</em></li>
 <p><li> See how this is applied to PDEs</li>
</ul>
<p>

Reason: the finite element method has many concepts and a jungle of details.
This strategy minimizes the mixing of ideas, concepts, and technical details.

<h2>Approximation set-up  <a name="___sec5"></a></h2>

<p>
General idea of approximation:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
 u(x) = \sum_{i=0}^N c_i\basphi_i(x),
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>

where

<p>

<ul>
 <p><li> \( \basphi_i(x) \) are prescribed functions</li>
 <p><li> \( c_i \), \( i=0,\ldots,N \) are unknown coefficients to be determined</li>
</ul>
<p>

How to determine \( c_i \):

<p>

<ul>
 <p><li> least squares method</li>
 <p><li> projection or Galerkin method</li>
 <p><li> interpolation (or collocation) method</li>
</ul>
<p>

Our mathematical framework for doing this is phrased in a way such
that it becomes easy to understand and use the <a href="http://fenicsproject.org">FEniCS</a> software package for finite element computing.

<h3>Approximation of planar vectors <a name="fem:approx:vec:plane"></a></h3>

<h4>Problem  <a name="___sec7"></a></h4>

<p>
Given a two-dimensional vector \( \f = (3,5) \), find an approximation
to \( \f \) directed along a given line.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Approximation of a two-dimensional vector by a one-dimensional vector. <a name="fem:approx:vec:plane:fig"></a> </p></center>
<p><img src="fig-fem/vecapprox_plane.png" align="bottom" width=400></p>
</center>

<p>
In vector space terminology: given a vector in a two-dimensional vector
space, find an approximation in a one-dimensional vector space

<p>
<p>&nbsp;<br>
$$
\begin{equation}
V = \mbox{span}\,\{ \psib_0\}\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \psib_0 \) is a basis vector in the space \( V \)</li>
 <p><li> Seek \( \u = c_0\psib_0\in V \)</li>
 <p><li> Determine \( c_0 \) such that \( \u \) is the "best" approximation to \( \f \)</li>
 <p><li> Visually, "best" is obvious</li>
 <p><li> For PDEs, "best" is not so obvious</li>
 <p><li> Define the error \( \e = \f - \u \)</li>
 <p><li> Define the (Eucledian) scalar product of two vectors: \( (\u,\v) \)</li>
 <p><li> Define the norm of \( \e \): \( ||\e|| = \sqrt{(\e, \e)} \)</li>
</ul>
<p>

<h4>The least squares method  <a name="___sec8"></a></h4>

<p>

<ul>
 <p><li> Idea: find \( c_0 \) such that \( ||\e|| \) is minimized</li>
 <p><li> Actually, we always minimize \( E=||\e||^2 \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_0} = 0
\thinspace . \end{equation*}
$$
<p>&nbsp;<br>


<p>
Detailed mathematics:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
E(c_0) = (\e,\e) = (\f,\f) - 2c_0(\f,\psib_0) + c_0^2(\psib_0,\psib_0)
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\psib_0) + 2c_0 (\psib_0,\psib_0) = 0
\thinspace .
\tag{2}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = \frac{(\f,\psib_0)}{(\psib_0,\psib_0)},
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = \frac{3a + 5b}{a^2 + b^2}\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
For later, we note that setting <a href="#mjx-eqn-2">(2)</a> to zero
can be alternatively written as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\e, \psib_0) = 0
\thinspace .
\tag{4}
\end{equation}
$$
<p>&nbsp;<br>

<h4>The Galerkin or projection method  <a name="___sec9"></a></h4>

<p>

<ul>
 <p><li> Backgrund: minimizing \( ||\e||^2 \) implies that \( \e \) is
   orthogonal to <em>any</em> vector \( \v \) in the space \( V \)
   (visually clear, but can easily be computed too)</li>
 <p><li> Alternative idea: demand \( (\e, \v) = 0,\quad\forall\v\in V \)</li>
 <p><li> Equivalent statement: \( (\e, \psib_0)=0 \) (see notes for why)</li>
 <p><li> Insert \( \e = \f - c_0\psib_0 \) and solve for \( c_0 \)</li>
 <p><li> Same equation for \( c_0 \) and hence same solution</li>
</ul>
<p>

<h3>Approximation of general vectors <a name="fem:approx:vec:Np1dim"></a></h3>

<p>
Given some vector \( \f \), seek an approximation \( \u \) in a vector space \( V \)
of dimension \( N+1 \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\psib_0,\ldots,\psib_N\}
\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> We have a set of linearly independent basis vectors
   \( \psib_0,\ldots,\psib_N \)</li>
 <p><li> Any \( \u\in V \) can then be written as \( \u = \sum_{j=0}^Nc_j\psib_j \)</li>
</ul>
<p>

<h4>The least squares method  <a name="___sec11"></a></h4>

<p>
Idea: find \( c_0,\ldots,c_N \) such that \( E= ||\e||^2 \) is minimized, \( \e=\f-\u \).

<p>
<p>&nbsp;<br>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\psib_j,\f -\sum_jc_j\psib_j)
\nonumber\\ 
&= (\f,\f) - 2\sum_{j=0}^Nc_j(\f,\psib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)\thinspace .
\end{align*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>
After a bit tedious and technical work with sums, we get
a <em>linear system</em> \( Ac=b \) or

<p>
<p>&nbsp;<br>
$$
\sum_{j=0}^N A_{i,j}c_j = b_i,\quad i=0,\ldots,N,
$$
<p>&nbsp;<br>

where

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{i,j} &= (\psib_i,\psib_j),\\ 
b_i &= (\psib_i, \f)\thinspace . \end{align}
$$
<p>&nbsp;<br>

<h4>The Galerkin or projection method  <a name="___sec12"></a></h4>

<p>
Can be shown that minimizing \( ||\e|| \) implies that
\( \e \) is orthogonal to all \( \v\in V \):

<p>
<p>&nbsp;<br>
$$
(\e,\v)=0,\quad \forall\v\in V,
$$
<p>&nbsp;<br>

which implies that \( \e \) most be orthogonal to each basis vector (see notes):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\e,\psib_i)=0,\quad i=0,\ldots,N\thinspace .
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Inserting for \( \e \) and ordering terms gives the same linear system
as that in the least squares method, implying that the methods are
equivalent. However, the linear system will
not be the same when apply these principles to solve PDEs.

<h2>Approximation of functions <a name="fem:approx:global"></a></h2>

<p>
Let \( V \) be a <em>function space</em> spanned by a set of <em>basis functions</em>
\( \basphi_0,\ldots,\basphi_N \),

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\basphi_0,\ldots,\basphi_N\},\end{equation*}
$$
<p>&nbsp;<br>


<p>
Any function \( u\in V \) can be written as a linear
combination of the basis functions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u = \sum_{j\in\If} c_j\basphi_j,\quad\If = \{0,1,\ldots,N\}
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>

For now, we shall look at functions of a single variable \( x \):
\( u=u(x) \), \( \basphi_i=\basphi_i(x) \), \( i\in\If \). Easy to generalize
to the multi-variate case.

<h3>The least squares method <a name="fem:approx:LS"></a></h3>

<p>
Try to extend the ideas from the vector case: compute error
and minimize error norm.

<p>
What norm?

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,g) = \int_\Omega f(x)g(x)\, dx\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
Restrict attention to some domain \( \Omega \).

<p>
The error: \( e = f - u \).

<p>
The squared norm of the error:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
E = (e,e) = (f-u,f-u) = (f(x)-\sum_{j\in\If} c_j\basphi_j(x), f(x)-\sum_{j\in\If} c_j\basphi_j(x))
\thinspace .
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
E(c_0,\ldots,c_N) = (f,f) -2\sum_{j\in\If} c_j(f,\basphi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\basphi_p,\basphi_q)\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>
Minimizing \( E \) implies

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=in\If
\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>
After computations identical to the vector case, we get a <em>linear system</em>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j\in\If}^N A_{i,j}c_j = b_i,\quad i\in\If,
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>

where

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{i,j} &= (\basphi_i,\basphi_j)
\tag{9}\\ 
b_i &= (f,\basphi_i)\thinspace .
\tag{10}
\end{align}
$$
<p>&nbsp;<br>

<h3>The Galerkin or projection method  <a name="___sec15"></a></h3>

<p>
As before, minimizing \( (e,e) \) is equivalent to

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(e,v)=0,\quad\forall v\in V,
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>

which means (as before)

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(e,\basphi_i)=0,\quad i\in\If\thinspace .
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>


<p>
With the same algebra as in the multi-dimensional vector case,
we get the same linear system as arose from the least squares method.

<p>
That is, the least squares and Galerkin/projection methods are again equivalent.

<h3>Example: linear approximation <a name="fem:approx:global:linear"></a></h3>

<p>
Problem: approximate a parabola by a straight line.

<p>
<p>&nbsp;<br>
$$
\begin{equation*} V = \hbox{span}\,\{1, x\}\thinspace . \end{equation*}
$$
<p>&nbsp;<br>

That is, \( \basphi_0(x)=1 \), \( \basphi_1(x)=x \), and \( N=1 \).
We seek

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
u=c_0\basphi_0(x) + c_1\basphi_1(x) = c_0 + c_1x,\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{0,0} &= (\basphi_0,\basphi_0) = \int_1^21\cdot 1\, dx = 1,\\ 
A_{0,1} &= (\basphi_0,\basphi_1) = \int_1^2 1\cdot x\, dx = 3/2,\\ 
A_{1,0} &= A_{0,1} = 3/2,\\ 
A_{1,1} &= (\basphi_1,\basphi_1) = \int_1^2 x\cdot x\,dx = 7/3\thinspace . \end{align}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align}
b_1 &= (f,\basphi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3,\\ 
b_2 &= (f,\basphi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3\thinspace . \end{align}
$$
<p>&nbsp;<br>

Solution of 2x2 linear system:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = -38/3,\quad c_1 = 10,
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = 10x - \frac{38}{3}\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Best approximation of a parabola by a straight line.  <a name="fem:approx:global:fig:parabola:linear"></a> </p></center>
<p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p>
</center>

<h3>Implementation of the least squares method <a name="fem:approx:global:LS:code"></a></h3>

<p>
Consider symbolic computation of the linear system,
where

<p>

<ul>
 <p><li> \( f(x) \) is given as a <code>sympy</code> expression <code>f</code> (involving
   the symbol <code>x</code>),</li>
 <p><li> <code>phi</code> is a list of \( \basphi_i \), \( i\in\If \),</li>
 <p><li> <code>Omega</code> is a 2-tuple/list holding the domain \( \Omega \)</li>
</ul>
<p>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">least_squares</span>(f, phi, Omega):
    N = <span style="color: #658b00">len</span>(phi) - <span style="color: #B452CD">1</span>
    A = sm.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sm.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            A[i,j] = sm.integrate(phi[i]*phi[j],
                                  (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            A[j,i] = A[i,j]
        b[i,<span style="color: #B452CD">0</span>] = sm.integrate(phi[i]*f, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
    c = A.LUsolve(b)
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(phi)):
        u += c[i,<span style="color: #B452CD">0</span>]*phi[i]
    <span style="color: #8B008B; font-weight: bold">return</span> u
</code></pre></div>
<p>
Observe: symmetric coefficient matrix.

<p>
Compare \( f \) and \( u \) visually:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">comparison_plot</span>(f, u, Omega, filename=<span style="color: #CD5555">&#39;tmp.pdf&#39;</span>):
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    f = sm.lambdify([x], f, modules=<span style="color: #CD5555">&quot;numpy&quot;</span>)
    u = sm.lambdify([x], u, modules=<span style="color: #CD5555">&quot;numpy&quot;</span>)
    resolution = <span style="color: #B452CD">401</span>  <span style="color: #228B22"># no of points in plot</span>
    xcoor  = linspace(Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>], resolution)
    exact  = f(xcoor)
    approx = u(xcoor)
    plot(xcoor, approx)
    hold(<span style="color: #CD5555">&#39;on&#39;</span>)
    plot(xcoor, exact)
    legend([<span style="color: #CD5555">&#39;approximation&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>])
    savefig(filename)
</code></pre></div>

<h3>Perfect approximation <a name="fem:approx:global:exact"></a></h3>

<p>
What if we add \( \basphi_2=x^2 \) to the space \( V \)?
That is, approximating a parabola by any parabola?
(Hopefully we get the exact parabola!)

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>-<span style="color: #B452CD">1</span>
&gt;&gt;&gt; u = least_squares(f=f, phi=[<span style="color: #B452CD">1</span>, x, x**<span style="color: #B452CD">2</span>], Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u
<span style="color: #B452CD">10</span>*x**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">20</span>*x + <span style="color: #B452CD">9</span>
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sm.expand(f)
<span style="color: #B452CD">10</span>*x**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">20</span>*x + <span style="color: #B452CD">9</span>
</code></pre></div>
<p>
Yes!

<p>
What if we use \( \phi_i(x)=x^i \)
for \( i=0,\ldots,N=40 \)?

<p>
The output from <code>least_squares</code> is \( c_i=0 \) for \( i>2 \).

<p>
General result: if \( f\in V \), least squares and Galerkin/projection gives \( u=f \).

<p>
Proof: if \( f\in V \), \( f \) can be expanded in
terms of the basis functions, \( f=\sum_{j\in\If}d_j\basphi_j \), for
some coefficients \( d_i \), \( i\in\If \),
and the right-hand side then has entries

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
b_i = (f,\basphi_i) = \sum_{j\in\If}d_j(\basphi_j, \basphi_i)
= \sum_{j\in\If} d_jA_{i,j}\ts
\end{equation*}
$$
<p>&nbsp;<br>

The linear system \( \sum_jA_{i,j}c_j = b_i \), \( i\in\If \), is then

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\sum_{j\in\If}c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},\quad i\in\If,
\end{equation*}
$$
<p>&nbsp;<br>

which implies that \( c_i=d_i \) for \( i\in\If \).

<h3>Ill-conditioning <a name="fem:approx:global:illconditioning"></a></h3>

<p>
The previous computations were symbolic. What if we do numerical
computing with <code>numpy</code> arrays?

<p>
<table border="1">
<tr><td align="center"><b style="font-weight: bold">        exact         </b></td> <td align="center"><b style="font-weight: bold">  <code>sympy</code>  </b></td> <td align="center"><b style="font-weight: bold"> <code>numpy32</code> </b></td> <td align="center"><b style="font-weight: bold"> <code>numpy64</code> </b></td> </tr>
<tr><td align="right">   9                       </td> <td align="right">   9.62                    </td> <td align="right">   5.57                    </td> <td align="right">   8.98                    </td> </tr>
<tr><td align="right">   -20                     </td> <td align="right">   -23.39                  </td> <td align="right">   -7.65                   </td> <td align="right">   -19.93                  </td> </tr>
<tr><td align="right">   10                      </td> <td align="right">   17.74                   </td> <td align="right">   -4.50                   </td> <td align="right">   9.96                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -9.19                   </td> <td align="right">   4.13                    </td> <td align="right">   -0.26                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   5.25                    </td> <td align="right">   2.99                    </td> <td align="right">   0.72                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.18                    </td> <td align="right">   -1.21                   </td> <td align="right">   -0.93                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -2.48                   </td> <td align="right">   -0.41                   </td> <td align="right">   0.73                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   1.81                    </td> <td align="right">   -0.013                  </td> <td align="right">   -0.36                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.66                   </td> <td align="right">   0.08                    </td> <td align="right">   0.11                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.12                    </td> <td align="right">   0.04                    </td> <td align="right">   -0.02                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.001                  </td> <td align="right">   -0.02                   </td> <td align="right">   0.002                   </td> </tr>
</table>
<p>

<ul>
  <p><li> Column 2: The matrix and vector are converted to
    the <code>sympy.mpmath.fp.matrix</code> data structure and the
    <code>sympy.mpmath.fp.lu_solve</code> function is used to solve the system.</li>
  <p><li> Column 3: The matrix and vector are converted to
    <code>numpy</code> arrays with data type <code>numpy.float32</code>
    (single precision floating-point number) and solved by
    the <code>numpy.linalg.solve</code> function.</li>
  <p><li> Column 4: As column 3, but the data type is
    <code>numpy.float64</code> (double
    precision floating-point number).</li>
</ul>
<p>

Observations:

<p>

<ul>
 <p><li> Significant round-off errors in the numerical computations (!)</li>
 <p><li> But now visually appearant in a plot (!)</li>
</ul>
<p>

Reasons: The basis functions \( x^i \) become almost linearly dependent for
large \( N \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  The 15 first basis functions \( x^i \), \( i=0,\ldots,14 \). <a name="fem:approx:global:fig:illconditioning"></a> </p></center>
<p><img src="fig-fem/ill_conditioning.png" align="bottom" width=600></p>
</center>

<p>
Almost linearly dependent basis functions give almost singular matrices.
Such matrices are said to be <em>ill conditioned</em>, and Gaussian elimination
is then prone to round-off errors.

<p>
The basis \( 1, x, x^2, x^3, x^4, \ldots \) is a bad basis. Polynomials
are fine as basis, but more orthogonal they are,
\( (\basphi_i,\basphi_j)\approx 0 \), the better.

<h3>Fourier series <a name="fem:approx:global:Fourier"></a></h3>

<p>
Consider

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\thinspace . \end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\basphi_i(x) = \sin ((i+1)\pi x),\quad i\in\If\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">N = <span style="color: #B452CD">3</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> sin, pi
phi = [sin(pi*(i+<span style="color: #B452CD">1</span>)*x) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]
f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">1</span>
Omega = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>]
u = least_squares(f, phi, Omega)
comparison_plot(f, u, Omega)
</code></pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions.  <a name="fem:approx:global:fig:parabola:sine1"></a> </p></center>
<p><img src="fig-fem/parabola_ls_sines4_12.png" align="bottom" width=800,></p>
</center>

<p>
Considerably improvement by \( N=11 \).

<p>
However, always discrepancy of \( f(0)-u(0)=9 \) at \( x=0 \), because all the
\( \basphi_i(0)=0 \) and hence \( u(0)=0 \). Possible remedy:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = f(0)(1-x) + xf(1) + \sum_{j\in\If} c_j\basphi_j(x)
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>

The extra term is a strikingly good help to get a good
approximation.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Best approximation of a parabola by a sum of 3 (left) and 11 (right) sine functions with a boundary term.  <a name="fem:approx:global:fig:parabola:sine2"></a> </p></center>
<p><img src="fig-fem/parabola_ls_sines4_12_wfterm.png" align="bottom" width=800,></p>
</center>

<h3>Orthogonal basis functions  <a name="___sec21"></a></h3>

<p>
This choice of sine functions as basis functions is popular because

<p>

<ul>
 <p><li> the basis functions are orthogonal: \( (\basphi_i,\basphi_j)=0 \)</li>
 <p><li> implying that \( A_{i,j} \) is a diagonal matrix</li>
 <p><li> implying that \( c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx \)</li>
</ul>
<p>

In general for an orthogonal basis, \( A_{i,j} \) is diagonal and we can solve
for \( c_i \):

<p>
<p>&nbsp;<br>
$$
c_i = \frac{b_i}{A_{i,i}} = \frac{(f,\basphi_i)}{(\basphi_i,\basphi_i)}
\thinspace .
$$
<p>&nbsp;<br>

<h3>The collocation or interpolation method <a name="fem:approx:global:interp"></a></h3>

<p>
Here is another idea:

<p>

<ul>
 <p><li> force \( u(\xno{i}) = f(\xno{i}) \) at some selected <em>collocation</em> points
   \( \xno{i} \), \( i\in\If \).</li>
 <p><li> Then \( u \) interpolates \( f \).</li>
 <p><li> Called the <em>collocation method</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \basphi_j(\xno{i}) = f(\xno{i}),
\quad i\in\If,N\ts
\end{equation}
$$
<p>&nbsp;<br>


<p>
This is a linear system,

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j\in\If} A_{i,j}c_j = b_i,\quad i\in\If,
\end{equation}
$$
<p>&nbsp;<br>

with

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{i,j} &= \basphi_j(\xno{i}),\\ 
b_i &= f(\xno{i})\thinspace . \end{align}
$$
<p>&nbsp;<br>


<p>
No symmetric matrix: \( \basphi_j(\xno{i})\neq \basphi_i(\xno{j}) \) (in general).

<p>
With <code>points</code> as the collocation/interpolation points we can program
the symbolic computations:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">interpolation</span>(f, phi, points):
    N = <span style="color: #658b00">len</span>(phi) - <span style="color: #B452CD">1</span>
    A = sm.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sm.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #228B22"># Turn phi and f into Python functions</span>
    phi = [sm.lambdify([x], phi[i]) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]
    f = sm.lambdify([x], f)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
            A[i,j] = phi[j](points[i])
        b[i,<span style="color: #B452CD">0</span>] = f(points[i])
    c = A.LUsolve(b)
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(phi)):
        u += c[i,<span style="color: #B452CD">0</span>]*phi[i](x)
    <span style="color: #8B008B; font-weight: bold">return</span> u
</code></pre></div>
<p>
Features:

<p>

<ul>
 <p><li> +: no computation of integrals</li>
 <p><li> -: how to choose \( \xno{i} \)?</li>
</ul>
<p>

<h4>Example  <a name="___sec23"></a></h4>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Approximation of a parabola by linear functions computed by two interpolation points: 4/3 and 5/3 (left) versus 1 and 2 (right).  <a name="fem:approx:global:linear:interp:fig1"></a> </p></center>
<p><img src="fig-fem/parabola_inter.png" align="bottom" width=800,></p>
</center>

<h3>Lagrange polynomials <a name="fem:approx:global:Lagrange"></a></h3>

<p>
Motivation:

<p>

<ul>
 <p><li> the interpolation/collocation method avoids integration</li>
 <p><li> with a diagonal matrix \( A_{i,j} = \basphi_j(\xno{i}) \) we
   can solve the linear system by hand</li>
</ul>
<p>

The <em>Lagrange interpolating polynomials</em> \( \basphi_j \) have the property that
\( \basphi_j(\xno{i})=0 \) for \( i\neq 1 \) and \( \basphi_i(\xno{i})=1 \), so that
\( c_i = f(x_i) \) and hence

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \sum_{j\in\If} f(\xno{i})\basphi_i(x)\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
Formula:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\basphi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N},
\tag{13}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p
</code></pre></div>
<p>
These basis functions are very much used in finite element methods.

<h4>Successful example  <a name="___sec25"></a></h4>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Approximation via least squares (left) and interpolation (right) of a sine function by Lagrange interpolating polynomials of degree 4. <a name="fem:approx:global:Lagrange:fig:sine:ls:colloc"></a> </p></center>
<p><img src="fig-fem/Lagrange_ls_interp_sin_4.png" align="bottom" width=800,></p>
</center>

<h4>Less successful example  <a name="___sec26"></a></h4>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Interpolation of an absolute value function by Lagrange polynomials and uniformly distributed interpolation points: degree 7 (left) and 14 (right).  <a name="fem:approx:global:Lagrange:fig:abs:Lag:unif:7:14"></a> </p></center>
<p><img src="fig-fem/Lagrange_interp_abs_8_15.png" align="bottom" width=800,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Illustration of the oscillatory behavior of two Lagrange polynomials for 12 uniformly spaced points (marked by circles).  <a name="fem:approx:global:Lagrange:fig:abs:Lag:unif:osc"></a> </p></center>
<p><img src="fig-fem/Lagrange_basis_12.png" align="bottom" width=400></p>
</center>

<p>
Problem: strong oscillations near the boundaries for larger \( N \) values.

<h4>Remedy for strong oscillations  <a name="___sec27"></a></h4>

<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N,
\end{equation}
$$
<p>&nbsp;<br>

on an interval \( [a,b] \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Interpolation of an absolute value function by Lagrange polynomials and Chebyshev nodes as interpolation points: degree 7 (left) and 14 (right).  <a name="fem:approx:global:Lagrange:fig:abs:Lag:Cheb:7:14"></a> </p></center>
<p><img src="fig-fem/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800,></p>
</center>

<h2>Finite element basis functions <a name="fem:approx:fe"></a></h2>

<p>
So far: basis functions have been <em>global</em>:
\( \basphi_i(x) \neq 0 \) for most \( x\in\Omega \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  Approximation based on sine basis functions. <a name="fem:approx:fe:fig:u:sin"></a> </p></center>
<p><img src="fig-fem/u_example_sin.png" align="bottom" width=600></p>
</center>

<p>
In the finite element method, basis functions are <em>piecewise
polynomials</em> with <em>local support</em> (\( \basphi_i(x) \neq 0 \) for \( x \) in a
small subdomain of \( \Omega \)), typically hat-like functions.  This
makes \( u=\sum_j c_j\basphi_j \) a polynomial over (small) subdomains.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 12:  Approximation based on local piecewise linear (hat) functions. <a name="fem:approx:fe:fig:u:fe"></a> </p></center>
<p><img src="fig-fem/u_example_fe.png" align="bottom" width=600></p>
</center>

<h3>Elements and nodes <a name="fem:approx:fe:def:elements:nodes"></a></h3>

<p>
Split \( \Omega \) into non-overlapping subdomains called <em>elements</em>:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(n_e)}\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
On each element, introduce points called <em>nodes</em>. Below: nodes at the
end point of elements.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 13:  Vertical dashed lines mark element boundaries and nodes. <a name="fem:approx:fe:fig:u:fe2"></a> </p></center>
<p><img src="fig-fem/u_example_fe2.png" align="bottom" width=600></p>
</center>

<p>

<ul>
 <p><li> \( \basphi_i=1 \) at node \( i \) and 0 at all other nodes</li>
 <p><li> \( \basphi_i \) is a Lagrange polynomial on each element</li>
 <p><li> For nodes at the boundary between two elements, \( \basphi_i \) is made
   up of a Lagrange polynomial from each element</li>
</ul>
<p>

<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 14:  Illustration of the piecewise quadratic basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P2"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 15:  Illustration of the piecewise cubic basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P3"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600,></p>
</center>

<p>
Important property: \( c_i \)
is the value of \( u \) at node \( i \), \( \xno{i} \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) =
c_i\basphi_i(\xno{i}) = c_i
\tag{14}
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>
\( \basphi_i(x) \) is mostly zero throughout the domain:

<p>

<ul>
 <p><li> \( \basphi_i(x) \neq 0 \) only on those elements that contain global node \( i \),</li>
 <p><li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) if and only if \( i \) and \( j \) are global node
   numbers in the same element.</li>
</ul>
<p>

Since \( A_{i,j} \) is the integral of
\( \basphi_i\basphi_j \) it means that
<em>most of the elements in the coefficient matrix will be zero</em>
(important for implementation!).

<h3>Example on quadratic \( \basphi_i \)  <a name="___sec30"></a></h3>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 16:  Finite element mesh: nodes are circles and vertical lines denote element boundaries (piecewise quadratic basis functions).  <a name="fem:approx:fe:fig:P2:v2"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p>
</center>

<p>
Introduce <code>nodes</code> and <code>elements</code> lists:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.125</span>, <span style="color: #B452CD">0.25</span>, <span style="color: #B452CD">0.375</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.625</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.875</span>, <span style="color: #B452CD">1.0</span>]
elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>, <span style="color: #B452CD">6</span>], [<span style="color: #B452CD">6</span>, <span style="color: #B452CD">7</span>, <span style="color: #B452CD">8</span>]]
</code></pre></div>
<p>

<ol>
<p><li> The polynomial that is 1 at local node 1
   (\( x=0.375 \), global node 3) makes up the basis function
   \( \basphi_3(x) \) over this element,
   with \( \basphi_3(x)=0 \) outside the element.</li>
<p><li> The Lagrange polynomial that is 1 at local node 0 is the "right
   part" of the global basis function
   \( \basphi_2(x) \). The "left part" of \( \basphi_2(x) \) consists of
   a Lagrange polynomial associated with local node 2 in
   the neighboring element \( \Omega^{(0)}=[0, 0.25] \).</li>
<p><li> Finally, the polynomial that is 1 at local node 2 (global node 4)
   is the "left part" of the global basis function \( \basphi_4(x) \).
   The "right part" comes from the Lagrange polynomial that is 1 at
   local node 0 in the neighboring element \( \Omega^{(2)}=[0.5, 0.75] \).</li>
</ol>
<p>

<h3>Example on linear \( \basphi_i \)  <a name="___sec31"></a></h3>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 17:  Illustration of the piecewise linear basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P1"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=600></p>
</center>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
(x - \xno{i-1})/h,
& \xno{i-1} \leq x < \xno{i},\\ 
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{15}
\end{equation}
$$
<p>&nbsp;<br>

<h3>Example on cubic \( \basphi_i \)  <a name="___sec32"></a></h3>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 18:  Illustration of the piecewise cubic basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P3"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600,></p>
</center>

<h3>Terminology  <a name="___sec33"></a></h3>

<p>

<ul>
 <p><li> P1 element: piecewise linear \( \basphi_i \) (piecewise linear \( u \))</li>
 <p><li> P2 element: piecewise quadratic \( \basphi_i \) (piecewise quadratic \( u \))</li>
 <p><li> P3 element: piecewise cubic \( \basphi_i \) (piecewise cubic \( u \))</li>
 <p><li> Pd element: piecewise polynom of degree \( d \)</li>
</ul>
<p>

<h3>Back to approximating \( u \): calculating the linear system <a name="fem:approx:global:linearsystem"></a></h3>

<p>
Assume uniform element length and P1 elements:

<p>
<p>&nbsp;<br>
$$ \Omega^{(i)} = [\xno{i},\xno{i+1}] = [ih, (i+1)h],\quad i=0,\ldots,N-1$$
<p>&nbsp;<br>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 19:  Piecewise linear basis functions \( \basphi_1 \) and \( \basphi_2 \).  <a name="fem:approx:fe:fig:P1:v2"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=600></p>
</center>

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i,i-1} = \int_\Omega \basphi_i\basphi_{i-1}dx = \int_{\xno{i-1}}^{\xno{i}}
\left(1 - \frac{x - \xno{i-1}}{h}\right)\frac{x - x_{i}}{h} dx = \frac{h}{6}\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Can show that \( A_{i,i+1} =h/6 \), \( A_{i,i}=2h/3 \), but modifications
at the boundary of \( \Omega \): \( A_{0,0}=h/3 \) and \( A_{N,N}=h/3 \).

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_i = \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)dx\thinspace .
\tag{16}
\end{equation}
$$
<p>&nbsp;<br>


<p>
With two equal-sized elements in \( \Omega=[0,1] \) and \( f(x)=x(1-x) \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\ 
1 & 4 & 1\\ 
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\ 
12 - 14h\\ 
10 -17h
\end{array}\right)\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 20:  Least squares approximation using 2 (left) and 4 (right) P1 elements. <a name="fem:approx:fe:fig:ls:P1:2:4"></a> </p></center>
<p><img src="fig-fem/fe_p1_x2_2e_4e.png" align="bottom" width=800,></p>
</center>

<h3>Assembly of elementwise computations <a name="fem:approx:fe:elementwise"></a></h3>

<p>
Split the integral over \( \Omega \) into elementwise integrals:
each element:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A_{i,j} = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} A^{(e)}_{i,j},\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_jdx\thinspace .
\tag{17}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
 <p><li> \( A^{(e)}_{i,j}\neq 0 \) if and only if \( i \) and \( j \) are nodes in element
   \( e \) (otherwise no overlap between the basis functions)</li>
 <p><li> all the nonzero elements in \( A^{(e)}_{i,j} \) are collected in an
   <em>element matrix</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad r,s\in\Ifd=\{0,\ldots,d\},
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)}dx,\quad r,s\in\Ifd\ts
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( r,s \) run over <em>local node numbers</em> within an element, while \( i,j \) run
   over <em>global node numbers</em>.</li>
 <p><li> \( i=q(e,r) \): mapping of local node number \( r \) in element
   \( e \) to the global node number \( i \). Math equivalent to <code>i=elements[e][r]</code>.</li>
 <p><li> Add contribution from an element into the global coefficient matrix
   (<em>assembly</em>):</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s\in\Ifd\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 21:  Illustration of matrix assembly.  <a name="fem:approx:fe:fig:assembly"></a> </p></center>
<p><img src="fig-fem/matrix-assembly.png" align="bottom" width=600></p>
</center>

<p>
Can also compute the right-hand side of the linear system from
elementwise contributions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} b^{(e)}_{i},\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)dx\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
  <p><li> \( b_i^{(e)}\neq 0 \) if and only if global node \( i \) is a node in element \( e \)
    (otherwise \( \basphi_i=0 \))</li>
  <p><li> The \( d+1 \) nonzero \( b_i^{(e)} \) can be collected in an <em>element vector</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
\tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\},\quad r\in\Ifd\ts
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Assembly:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r,s\in\Ifd\thinspace .
\end{equation}
$$
<p>&nbsp;<br>

<h3>Mapping to a reference element <a name="fem:approx:fe:mapping"></a></h3>

<p>
Instead of computing

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx\end{equation*}
$$
<p>&nbsp;<br>

over some element
\( \Omega^{(e)} = [x_L, x_R] \),
we now map \( [x_L, x_R] \) to
a standardized reference element domain \( [-1,1] \) with local coordinate \( X \).

<p>
Affine mapping:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
x = \half (x_L + x_R) + \half (x_R - x_L)X\thinspace .
\tag{18}
\end{equation}
$$
<p>&nbsp;<br>

or rewritten as
<p>&nbsp;<br>
$$
\begin{equation}
x = x_m + \frac{1}{2}hX, \qquad x_m=(x_L+x_R)/2
\tag{19}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Integrating on
the reference element is a matter of just changing the integration
variable from \( x \) to \( X \). Let

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
\end{equation}
$$
<p>&nbsp;<br>

be the basis function associated with local node number \( r \) in the
reference element. The integral transformation reads

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\frac{dx}{dX}dX\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
Introduce the notation
\( \det J = dx/dX = h/2 \), because in 2D and 3D we get \( \det J \)
instead of \( dx/dX \).

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)}_{r,s}
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
\tag{20}
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
\tag{21}
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>
Advantages:

<p>

<ul>
  <p><li> Always the same domain for integration: \( [-1,1] \)</li>
  <p><li> We only need formulas for \( \refphi_r(X) \) on the reference elements
    (no need for piecewise polynomial definition)</li>
</ul>
<p>

P1 elements:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\tag{22}\\ 
\refphi_1(X) &= \half (1 + X)
\tag{23}
\end{align}
$$
<p>&nbsp;<br>


<p>
P2 elements:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (X-1)X\\ 
\refphi_1(X) &= 1 - X^2\\ 
\refphi_2(X) &= \half (X+1)X
\end{align}
$$
<p>&nbsp;<br>

<h3>Integration over a reference element <a name="fem:approx:fe:intg:ref"></a></h3>

<p>
P1 elements and \( f(x)=x(1-x) \).

<p>
<p>&nbsp;<br>
$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1-X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3},\\ 
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6},\\ 
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0},\\ 
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\thinspace .
\end{align}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1-X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}\\ 
\tilde b^{(e)}_{1}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1+X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\thinspace .
\end{align}
$$
<p>&nbsp;<br>

\( x_m \): element midpoint.

<p>
Tedious calculations! Let's use symbolic software:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
&gt;&gt;&gt; x, x_m, h, X = sm.symbols(<span style="color: #CD5555">&#39;x x_m h X&#39;</span>)
&gt;&gt;&gt; sm.integrate(h/<span style="color: #B452CD">8</span>*(<span style="color: #B452CD">1</span>-X)**<span style="color: #B452CD">2</span>, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
h/<span style="color: #B452CD">3</span>
&gt;&gt;&gt; sm.integrate(h/<span style="color: #B452CD">8</span>*(<span style="color: #B452CD">1</span>+X)*(<span style="color: #B452CD">1</span>-X), (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
h/<span style="color: #B452CD">6</span>
&gt;&gt;&gt; x = x_m + h/<span style="color: #B452CD">2</span>*X
&gt;&gt;&gt; b_0 = sm.integrate(h/<span style="color: #B452CD">4</span>*x*(<span style="color: #B452CD">1</span>-x)*(<span style="color: #B452CD">1</span>-X), (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> b_0
-h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">24</span> + h**<span style="color: #B452CD">2</span>*x_m/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - h*x_m**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">2</span> + h*x_m/<span style="color: #B452CD">2</span>
</code></pre></div>
<p>
Can printe out in LaTeX too (convenient for copying into reports):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sm.latex(b_0, mode=<span style="color: #CD5555">&#39;plain&#39;</span>)
- \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">24</span>} h^{<span style="color: #B452CD">3</span>} + \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">6</span>} h^{<span style="color: #B452CD">2</span>} x_{m}
- \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">12</span>} h^{<span style="color: #B452CD">2</span>} - \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">2</span>} h x_{m}^{<span style="color: #B452CD">2</span>}
+ \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">2</span>} h x_{m}
</code></pre></div>

<h2>Implementation  <a name="___sec38"></a></h2>

<p>

<ul>
 <p><li> Coming functions appear in <a href="http://tinyurl.com/jvzzcfn/fem/fe_approx1D.py"><tt>fe_approx1D.py</tt></a></li>
 <p><li> Functions can operate in symbolic or numeric mode</li>
 <p><li> The code documents all steps in finite element calculations</li>
</ul>
<p>

<h3>Integration  <a name="___sec39"></a></h3>

<p>
Compute \( \refphi_r(X) \) as a Lagrange polynomial of degree <code>d</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">phi_r</span>(r, X, d):
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(X, sm.Symbol):
        h = sm.Rational(<span style="color: #B452CD">1</span>, d)  <span style="color: #228B22"># node spacing</span>
        nodes = [<span style="color: #B452CD">2</span>*i*h - <span style="color: #B452CD">1</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #228B22"># assume X is numeric: use floats for nodes</span>
        nodes = np.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, d+<span style="color: #B452CD">1</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> Lagrange_polynomial(X, r, nodes)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p
</code></pre></div>
<p>
The complete basis:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">basis</span>(d=<span style="color: #B452CD">1</span>):
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    phi = [phi_r(r, X, d) <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> phi
</code></pre></div>
<p>
Element matrix:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_matrix</span>(phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    A_e = sm.zeros((n, n))
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sm.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(r, n):
            A_e[r,s] = sm.integrate(phi[r]*phi[s]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
            A_e[s,r] = A_e[r,s]
    <span style="color: #8B008B; font-weight: bold">return</span> A_e
</code></pre></div>
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; phi
[<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> - X/<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> + X/<span style="color: #B452CD">2</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">True</span>)
[h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">False</span>)
[<span style="color: #B452CD">0.0333333333333333</span>, <span style="color: #B452CD">0.0166666666666667</span>]
[<span style="color: #B452CD">0.0166666666666667</span>, <span style="color: #B452CD">0.0333333333333333</span>]
</code></pre></div>
<p>
Element vector:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    b_e = sm.zeros((n, <span style="color: #B452CD">1</span>))
    <span style="color: #228B22"># Make f a function of X</span>
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sm.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    x = (Omega_e[<span style="color: #B452CD">0</span>] + Omega_e[<span style="color: #B452CD">1</span>])/<span style="color: #B452CD">2</span> + h/<span style="color: #B452CD">2</span>*X  <span style="color: #228B22"># mapping</span>
    f = f.subs(<span style="color: #CD5555">&#39;x&#39;</span>, x)  <span style="color: #228B22"># substitute mapping formula for x</span>
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        b_e[r] = sm.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">return</span> b_e
</code></pre></div>
<p>
Note: need to replace the symbol <code>x</code> in the expression for <code>f</code>
by the mapping formula such that <code>f</code> contains the variable <code>X</code>.

<p>
Not all \( f(x) \) can be integrated by <code>sympy</code> so let us fall back on
numerical integration:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
        ...
        I = sm.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sm.Integral):
            h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]  <span style="color: #228B22"># Ensure h is numerical</span>
            detJ = h/<span style="color: #B452CD">2</span>
            integrand = sm.lambdify([X], f*phi[r]*detJ)
            I = sm.mpmath.quad(integrand, [-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>])
        b_e[r] = I
        ...
</code></pre></div>

<h3>Linear system assembly and solution  <a name="___sec40"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assemble</span>(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>):
    n_n, n_e = <span style="color: #658b00">len</span>(nodes), <span style="color: #658b00">len</span>(elements)
    zeros = sm.zeros <span style="color: #8B008B; font-weight: bold">if</span> symbolic <span style="color: #8B008B; font-weight: bold">else</span> np.zeros
    A = zeros((n_n, n_n))
    b = zeros((n_n, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n_e):
        Omega_e = [nodes[elements[e][<span style="color: #B452CD">0</span>]], nodes[elements[e][-<span style="color: #B452CD">1</span>]]]

        A_e = element_matrix(phi, Omega_e, symbolic)
        b_e = element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] += A_e[r,s]
            b[elements[e][r]] += b_e[r]
    <span style="color: #8B008B; font-weight: bold">return</span> A, b
</code></pre></div>
<p>
Linear system solution:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> symbolic:
    c = A.LUsolve(b)           <span style="color: #228B22"># sympy arrays, symbolic Gaussian elim.</span>
<span style="color: #8B008B; font-weight: bold">else</span>:
    c = np.linalg.solve(A, b)  <span style="color: #228B22"># numpy arrays, numerical solve</span>
</code></pre></div>

<h3>Example on computing approximations  <a name="___sec41"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; h, x = sm.symbols(<span style="color: #CD5555">&#39;h x&#39;</span>)
&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, h, <span style="color: #B452CD">2</span>*h]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; b
[     h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
[      h**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">5</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - <span style="color: #B452CD">17</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[                           h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">12</span>*(<span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - <span style="color: #B452CD">35</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">72</span>)/(<span style="color: #B452CD">7</span>*h)]
[  <span style="color: #B452CD">7</span>*(<span style="color: #B452CD">4</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">7</span> - <span style="color: #B452CD">23</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">21</span>)/(<span style="color: #B452CD">2</span>*h)]
</code></pre></div>
<p>
Numerical computations:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">False</span>)
&gt;&gt;&gt; A
[ <span style="color: #B452CD">0.166666666666667</span>, <span style="color: #B452CD">0.0833333333333333</span>,                  <span style="color: #B452CD">0</span>]
[<span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.333333333333333</span>, <span style="color: #B452CD">0.0833333333333333</span>]
[                 <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.166666666666667</span>]
&gt;&gt;&gt; b
[          <span style="color: #B452CD">0.03125</span>]
[<span style="color: #B452CD">0.104166666666667</span>]
[          <span style="color: #B452CD">0.03125</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[<span style="color: #B452CD">0.0416666666666666</span>]
[ <span style="color: #B452CD">0.291666666666667</span>]
[<span style="color: #B452CD">0.0416666666666666</span>]
</code></pre></div>

<h3>The structure of the coefficient matrix <a name="fem:approx:fe:A:structure"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; d=<span style="color: #B452CD">1</span>; n_e=<span style="color: #B452CD">8</span>; Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]  <span style="color: #228B22"># 8 linear elements on [0,1]</span>
&gt;&gt;&gt; phi = basis(d)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; nodes, elements = mesh_symbolic(n_e, d, Omega)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
</code></pre></div>
<p>
Note: do this by hand to understand what is going on!

<p>
The coefficient matrix is sparse (means mostly zeros):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>
For P2 elements:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 &
  0\\0 & 0 & 2 & 16 & 2 & 0 & 0
  & 0 & 0\\0 & 0 & - 1 & 2 & 8
  & 2 & - 1 & 0 & 0\\0 & 0 & 0 & 0 &
  2 & 16 & 2 & 0 & 0\\0 & 0 & 0
  & 0 & - 1 & 2 & 8 &
  2 & - 1\\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>
Exploiting the sparse structure is important for efficient computations.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 22:  Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P1 elements. <a name="fem:approx:fe:sparsity:P1"></a> </p></center>
<p><img src="fig-fem/sparsity_pattern_1D_30.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 23:  Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P3 elements. <a name="fem:approx:fe:sparsity:P3"></a> </p></center>
<p><img src="fig-fem/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p>
</center>

<h3>Sparse matrix storage and solution <a name="fem:approx:fe:impl:sparse"></a></h3>

<p>
We have observed that \( \basphi_i\basphi_j\neq 0 \) only when \( i \) and \( j \)
are nodes in the same element. This means that \( A_{i,j}=0 \) for most
\( i \) and \( j \), and the coefficient matrix is then <em>sparse</em>.

<p>

<ul>
 <p><li> P1 elements: only 3 nonzero entires per row</li>
 <p><li> P2 elements: only 5 nonzero entires per row</li>
 <p><li> P2 elements: only 7 nonzero entires per row</li>
 <p><li> It is important to utilize sparse storage and sparse solvers</li>
 <p><li> In Python: <code>scipy.sparse</code> package</li>
</ul>
<p>

<h3>Applications  <a name="___sec44"></a></h3>

<p>
Compute a mesh with <code>n_e</code> elements, basis functions of
degree <code>d</code>, and approximate a given symbolic expression
<code>f</code> by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">approximate</span>(f, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, n_e=<span style="color: #B452CD">4</span>, filename=<span style="color: #CD5555">&#39;tmp.pdf&#39;</span>):
</code></pre></div>
<p>
Tests:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> approximate
x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)

approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, n_e=<span style="color: #B452CD">4</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, n_e=<span style="color: #B452CD">2</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, n_e=<span style="color: #B452CD">8</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, n_e=<span style="color: #B452CD">4</span>)
</code></pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 24:  Comparison of the finite element approximations: 4 P1 elements with 5 nodes (upper left), 2 P2 elements with 5 nodes (upper right), 8 P1 elements with 9 nodes (lower left), and 4 P2 elements with 9 nodes (lower right).  <a name="fem:appro:fe:x9:sin"></a> </p></center>
<p><img src="fig-fem/fe_p1_p2_x9_248e.png" align="bottom" width=800,></p>
</center>

<h2>Comparison of finite element and finite difference approximation <a name="fem:approx:fe:fd"></a></h2>

<p>

<ul>
 <p><li> Finite difference approximation of a function \( f(x) \): simply
   choose \( u_i = f(x_i) \) (interpolation).</li>
 <p><li> Galerkin/projection and least squares method:
   must derive and solve a linear system.</li>
 <p><li> What is really the difference?</li>
</ul>
<p>

<h3>Collocation (interpolation)  <a name="___sec46"></a></h3>

<p>
Let \( \xno{i} \), \( i\in\If \), be the nodes in the mesh.
Collocation means

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i})=f(\xno{i}),\quad i\in\If,
\end{equation}
$$
<p>&nbsp;<br>

which translates to

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} c_j \basphi_j(\xno{i}) = f(\xno{i}),$$
<p>&nbsp;<br>

but \( \basphi_j(\xno{i})=0 \) if \( i\neq j \) so the sum collapses to one
term \( c_i\basphi_i(\xno{i}) = c_i \), and we have the result

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_i = f(\xno{i})
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> This yields the same result as the standard finite difference approach</li>
 <p><li> \( u \) <em>interpolates</em> \( f \) at the node points</li>
 <p><li> \( u \) has a variation between the node points dictated by the \( \basphi_i \)
   functions</li>
 <p><li> Collocation (interpolation) is not much used when solving
   differential equation, except for approximating initial conditions
   (like here)</li>
</ul>
<p>

<h3>Finite difference interpretation of a finite element approximation  <a name="___sec47"></a></h3>

<p>

<ul>
 <p><li> Scope: work with P1 elements (most similar to finite differences)</li>
 <p><li> Use Galerkin/project or least squares (equivalent)</li>
 <p><li> Interpret the resulting linear system as finite difference equations</li>
</ul>
<p>

General formula for computing the linear system:

<p>
<p>&nbsp;<br>
$$
\sum_{j\in\If} c_j (\basphi_i,\basphi_j) = (f,\basphi_i),\quad i\in\If\ts
$$
<p>&nbsp;<br>


<p>
The P1 finite element machinery results in a linear system where
equation no \( i \) is

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{h}{6}(u_{i-1} + 4u_i + u_{i+1}) = (f,\basphi_i)
\thinspace .
\tag{24}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Note:

<p>

<ul>
  <p><li> We have used \( u_i \) for \( c_i \) to simplify notation with
    finite differences.</li>
  <p><li> The finite difference counterpart is just \( u_i=f_i \).</li>
</ul>
<p>

Rewrite:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
h(u_i - \frac{1}{6}(-u_{i-1} + 2u_i - u_{i+1}))
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>

This looks like a finite difference approximation of

<p>
<p>&nbsp;<br>
$$ h(u - \frac{h^2}{6}u''),$$
<p>&nbsp;<br>

That is, the matrix arises from

<p>
<p>&nbsp;<br>
$$ [h(u - \frac{h^2}{6}D_x D_x u)]_i$$
<p>&nbsp;<br>


<p>
The right-hand side is more complicated:

<p>
<p>&nbsp;<br>
$$ (f,\basphi_i) = \int_{\xno{i-1}}^{\xno{i}} f(x)\frac{1}{h} (x - \xno{i-1}) dx
+ \int_{\xno{i}}^{\xno{i+1}} f(x)\frac{1}{h}(1 - (x - x_{i})) dx
\thinspace .
$$
<p>&nbsp;<br>

Can't to much unless we specialize \( f \) or use <em>numerical integration</em>.

<p>
Apply the Trapezoidal rule using all the nodes:

<p>
<p>&nbsp;<br>
$$ (f,\basphi_i) = \int_\Omega f\basphi_i dx\approx h\frac{1}{2}(
f(\xno{0})\basphi_i(\xno{0}) + f(\xno{N})\basphi_i(\xno{N}))
+ h\sum_{j=1}^{N-1} f(\xno{j})\basphi_i(\xno{j})
\thinspace .
$$
<p>&nbsp;<br>

Since \( \basphi_i \) is zero at all these points, except at \( \xno{i} \), the
Trapezoidal rule collapses to one term:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,\basphi_i) \approx hf(\xno{i}),\quad i=1,\ldots,N-1\thinspace.
\end{equation}
$$
<p>&nbsp;<br>

This is the same result as in collocation (interpolation)
and the finite difference method!

<p>
Simpson's rule:

<p>
<p>&nbsp;<br>
$$ \int_\Omega f(x)dx \approx \frac{\tilde h}{3}\left( f(x_0) +
2\sum_{j=2,4,6,\ldots} f(x_j)
+ 4\sum_{j=1,3,5,\ldots} f(x_j) + f(x_{2N})\right),
$$
<p>&nbsp;<br>

Here \( f \) is sampled at midpoints and endpoints of the elements.
The sums collapse because \( \basphi_i=0 \) at most of these points.

<p>
Result:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,\basphi_i) \approx \frac{h}{3}(f(\xno{i}-\frac{1}{2}h)
+ f(\xno{i}) + f(\xno{i}+\frac{1}{2}h)
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>

In a finite difference context we would typically express this formula as

<p>
<p>&nbsp;<br>
$$ \frac{h}{3}(f_{i-\frac{1}{2}} + f_i + f_{i+\frac{1}{2}})
\thinspace .
$$
<p>&nbsp;<br>


<p>
Conclusions:

<p>

<ul>
  <p><li> While the finite difference method just samples \( f \) at \( x_i \),
    the finite element method applies an average of \( f \) around \( x_i \).</li>
  <p><li> On the left-hand side we have a term \( \sim hu'' \), and \( u'' \)
    also contribute to smoothing.</li>
  <p><li> There are some inherent smoothing elements in the finite element
    method.</li>
</ul>
<p>

With Trapezoidal integration of \( (f,\basphi_i) \) we essentially solve

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u + \frac{h^2}{6} u'' = f,\quad u'(0)=u'(L)=0,
\end{equation}
$$
<p>&nbsp;<br>

expressed with operator notation as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[u + \frac{h^2}{6} D_x D_x u = f]_i\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
With Simpson integration of \( (f,\basphi_i) \) we essentially solve

<p>
<p>&nbsp;<br>
$$
\begin{equation}
[u + \frac{h^2}{6} D_x D_x u = \bar f]_i,
\end{equation}
$$
<p>&nbsp;<br>

where
<p>&nbsp;<br>
$$ \bar f_i = \frac{1}{3}(f_{i-1/2} + f_i + f_{i+1/2}) $$
<p>&nbsp;<br>


<p>
Note:

<p>

<ul>
  <p><li> As \( h\rightarrow 0 \), \( hu''\rightarrow 0 \) and \( \bar f_i\rightarrow f_i \),
    and all approaches yield the same result.</li>
</ul>
<p>

<h3>Making finite elements behave as finite differences  <a name="___sec48"></a></h3>

<p>

<ul>
 <p><li> Can we adjust the finite element method so that we do not
   get the extra \( hu'' \) smoothing term and averaging of \( f \)?</li>
 <p><li> This is important in time-dependent problems to incorporate good
   properties of finite differences into finite elements.</li>
</ul>
<p>

Result:

<p>

<ul>
 <p><li> By computing all integrals by the Trapezoidal method, P1 elements
   recovers the same formulas as in the finite difference method (\( u_i=f_i \)).</li>
 <p><li> Specifically: the coefficient matrix becomes diagonal ("lumped")</li>
 <p><li> Loss of accuracy? The Trapezoidal rule has error \( \Oof{h^2} \),
   the same as the approximation error in P1 elements (integrated exactly).</li>
</ul>
<p>

Reason:

<p>

<ul>
 <p><li> Integration rules sample the integrand in nodes will sample
   \( \basphi_i \) at points where it is 0. A lot of terms vanish.</li>
</ul>
<p>

<h2>A generalized element concept <a name="fem:approx:fe:element"></a></h2>

<p>
So far,

<p>

<ul>
 <p><li> <em>Nodes</em>: points for defining \( \basphi_i \) and compute \( u \) values</li>
 <p><li> <em>Elements</em>: subdomain (containing some nodes)</li>
 <p><li> This is a common notion of nodes and elements.</li>
</ul>
<p>

An extended and generalized element concept:

<p>

<ul>
 <p><li> An <em>element</em> is the collection of the subdomain (previous "element"),
   points where we seek function values, basis functions, numberings,
   mappings, etc.</li>
 <p><li> We introduce <em>cell</em> for the subdomain that we up to now called element.</li>
 <p><li> A cell has <em>vertices</em> (interval end points).</li>
 <p><li> <em>Nodes</em> are, almost as before,
   points where we want to compute unknown functions.</li>
 <p><li> <em>Degrees of freedom</em> is what the \( c_j \) represent (usually function values
   at nodes).</li>
</ul>
<p>

<h4>The concept of a finite element  <a name="___sec50"></a></h4>

<p>

<ul>
  <p><li> a <em>reference cell</em> in a local reference coordinate system;</li>
  <p><li> a set of <em>basis functions</em> \( \refphi_i \) defined on the cell;</li>
  <p><li> a set of <em>degrees of freedom</em> that uniquely determine
    the basis functions such that \( \refphi_i=1 \) for degree of freedom
    number \( i \) and \( \refphi_i=0 \) for all other degrees of freedom;</li>
  <p><li> a mapping between local and global degree of freedom numbers;</li>
  <p><li> a <em>mapping</em> of the reference cell onto to cell in the physical
    domain.</li>
</ul>
<p>

<h3>Implementation <a name="fem:approx:fe:element:impl"></a></h3>

<p>

<ul>
  <p><li> We replace <code>nodes</code> by <code>vertices</code>.</li>
  <p><li> We introduce <code>cells</code> such that <code>cell[e][r]</code> gives the mapping
    from local vertex <code>r</code> in cell <code>e</code> to the global vertex number
    in <code>vertices</code>.</li>
  <p><li> We replace <code>elements</code> by <code>dof_map</code> (the contents are the same).</li>
</ul>
<p>

Example: \( \Omega =[0,1] \) is divided into two cells,
\( \Omega^{(0)}=[0,0.4] \) and \( \Omega^{(1)}=[0.4,1] \).
Define P2 elements in each cell.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">vertices = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.4</span>, <span style="color: #B452CD">1</span>]
cells = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
dof_map = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>]]
</code></pre></div>
<p>
Example: \( u \) is piecewise constant in each cell (P0 element).
Same <code>vertices</code> and <code>cells</code>, but

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">dof_map = [[<span style="color: #B452CD">0</span>], [<span style="color: #B452CD">1</span>], [<span style="color: #B452CD">2</span>]]
</code></pre></div>
<p>
May think of nodes in the middle of each element.

<p>
The assembly process must now use the <code>dof_map</code> (no <code>elements</code> data
structure anymore):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">A[dof_map[e][r], dof_map[e][s]] += A_e[r,s]
b[dof_map[e][r]] += b_e[r]
</code></pre></div>
<p>
We will hereafter work with <code>cells</code>, <code>vertices</code>, and <code>dof_map</code>.

<h3>Cubic Hermite polynomials  <a name="___sec52"></a></h3>

<p>

<ul>
 <p><li> Can we construct \( \basphi_i(x) \) with continuous derivatives?</li>
 <p><li> Yes!</li>
</ul>
<p>

Consider a reference cell \( [-1,1] \). We introduce two nodes, \( X=-1 \) and \( X=1 \).
The degrees of freedom are

<p>

<ul>
  <p><li> 0: value of function at \( X=-1 \)</li>
  <p><li> 1: value of first derivative at \( X=-1 \)</li>
  <p><li> 2: value of function at \( X=1 \)</li>
  <p><li> 3: value of first derivative at \( X=1 \)</li>
</ul>
<p>

Derivatives as unknowns ensure the same \( \basphi_i'(x) \) value at nodes!

<p>
The 4 degrees of freedom, applied to the 4 \( \basphi_i(x) \), give four
\( 4\times 4 \) linear systems to determine the 4 cubic \( \basphi_i(x) \).

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= 1 - \frac{3}{4}(X+1)^2 + \frac{1}{4}(X+1)^3\\ 
\refphi_1(X) &= -(X+1)(1 - \frac{1}{2}(X+1))^2\\ 
\refphi_2(X) &= \frac{3}{4}(X+1)^2 - \frac{1}{2}(X+1)^3\\ 
\refphi_3(X) &= -\frac{1}{2}(X+1)(\frac{1}{2}(X+1)^2 - (X+1))\\ 
\end{align}
$$
<p>&nbsp;<br>

<h2>Numerical integration  <a name="___sec53"></a></h2>

<p>
\( \int_\Omega f\basphi_idx \) must in general be computed by numerical integration.

<p>
Common form:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx \sum_{j=0}^M w_j\bar X_j,
\end{equation}
$$
<p>&nbsp;<br>

where

<p>

<ul>
 <p><li> \( \bar X_j \) are <em>integration points</em></li>
 <p><li> \( w_j \) are <em>integration weights</em></li>
 <p><li> Different rules correspond to different choices of points and weights</li>
</ul>
<p>

Simplest possibility: the Midpoint rule,

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx 2g(0),\quad \bar X_0=0,\ w_0=2,
\end{equation}
$$
<p>&nbsp;<br>

<h3>Newton-Cotes rules <a name="fem:approx:fe:numint1"></a></h3>

<p>
Idea: use a fixed, uniformly distributed set of points.
The points usually coincides with nodes (in higher-order elements).
Very useful for making \( \basphi_i\basphi_j=0 \) and get diagonal
(mass) matrices ("lumping").

<p>
The Trapezoidal rule:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx g(-1) + g(1),\quad \bar X_0=-1,\ \bar X_1=1,\ w_0=w_1=1,
 \tag{25}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Simpson's rule:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{-1}^{1} g(X)dX \approx \frac{1}{3}\left(g(-1) + 4g(0)
+ g(1)\right),
\end{equation}
$$
<p>&nbsp;<br>

where

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\bar X_0=-1,\ \bar X_1=0,\ \bar X_2=1,\ w_0=w_2=\frac{1}{3},\ w_1=\frac{4}{3}\thinspace . \end{equation}
$$
<p>&nbsp;<br>

<h3>Gauss-Legendre rules with optimized points  <a name="___sec55"></a></h3>

<p>

<ul>
 <p><li> Do not fix points, e.g., uniform distribution</li>
 <p><li> Optimize the location of points</li>
 <p><li> Gauss-Legendre rules (quadrature) adjust points and weights to
   integrate polynomials exactly</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align}
M=1&:\quad \bar X_0=-\frac{1}{\sqrt{3}},\ 
\bar X_1=\frac{1}{\sqrt{3}},\ w_0=w_1=1\\ 
M=2&:\quad \bar X_0=-\sqrt{\frac{3}{{5}}},\ \bar X_0=0,\ 
\bar X_2= \sqrt{\frac{3}{{5}}},\ w_0=w_2=\frac{5}{9},\ w_1=\frac{8}{9}\thinspace . \end{align}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( M=1 \): integrates 3rd degree polynomials exactly</li>
 <p><li> \( M=2 \): integrates 5th degree polynomials exactly</li>
 <p><li> In general, \( M \)-point rule integrates a polynomial
   of degree \( 2M+1 \) exactly.</li>
</ul>
<p>

See <a href="http://tinyurl.com/jvzzcfn/fem/numint.py"><tt>numint.py</tt></a> for a large collection of Gauss-Legendre rules.

<h2>Approximation of functions in 2D <a name="fem:approx:2D"></a></h2>

<p>
<b style="font-weight: bold">All the concepts and algorithms developed for approximation of 1D functions
\( f(x) \) can readily be extended to 2D functions \( f(x,y) \) and 3D functions
\( f(x,y,z) \).</b> Key formulas stay the same.

<p>
Inner product in 2D:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,g) = \int_\Omega f(x,y)g(x,y) dx dy
\end{equation}
$$
<p>&nbsp;<br>

<h4>Constructing 2D basis functions from 1D functions  <a name="___sec57"></a></h4>

<p>
Given 1D basis functions

<p>
<p>&nbsp;<br>
$$ \{ \hat\basphi_0(x),\ldots,\hat\basphi_{N_x}(x)\},
$$
<p>&nbsp;<br>

we can combine these two form 2D basis functions:
\( \hat\basphi_p(x)\hat\basphi_q(y) \) (tensor-product definition).

<p>
Either double index \( (p,q) \),

<p>
<p>&nbsp;<br>
$$ u = \sum_{p=0}^{N_y}\sum_{q=0}^{N_x} c_{p,q}\basphi_{p,q}(x,y),
\quad \basphi_{p,q}(x,y) = \hat\basphi_p(x)\hat\basphi_q(y),
$$
<p>&nbsp;<br>

or we may transform the double index \( (p,q) \) to a single index \( i \),
using \( i=pN_y + q \) or \( i=qN_x + p \).

<p>
Simple example:

<p>
<p>&nbsp;<br>
$$ \{ 1, x \} $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ \basphi_{0,0}=1,\quad \basphi_{1,0}=x, \quad \basphi_{0,1}=y,
\quad \basphi_{1,1}=xy,
$$
<p>&nbsp;<br>

or with a single index:

<p>
<p>&nbsp;<br>
$$ \basphi_0=1,\quad \basphi_1=x, \quad \basphi_2=y,\quad\basphi_3 =xy
\thinspace .
$$
<p>&nbsp;<br>


<p>
See notes for details of a hand-calculation.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 25:  Approximation of a 2D quadratic function (left) by a 2D bilinear function (right) using the Galerkin or least squares method. <a name="fem:approx:fe:2D:fig:ubilinear"></a> </p></center>
<p><img src="fig-fem/approx2D_bilinear.png" align="bottom" width=800></p>
</center>

<h2>Finite elements in 2D and 3D  <a name="___sec58"></a></h2>

<p>
The two great advantages of the finite element method:

<p>

<ul>
  <p><li> Can handle complex-shaped domains in 2D and 3D</li>
  <p><li> Can easily provide higher-order polynomials in the approximation</li>
</ul>
<p>

Typical cell types: triangles and quadrilaterals in 2D,
tetrahetra and hexahedra in 3D.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 26:  Examples on 2D P1 elements. <a name="fem:approx:fe:2D:fig:rectP1"></a> </p></center>
<p><img src="fig-fem/mesh2D_rect_P1.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 27:  Examples on 2D P1 elements in a deformed geometry. <a name="fem:approx:fe:2D:fig:circP1"></a> </p></center>
<p><img src="fig-fem/mesh2D_quarter_circle.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 28:  Examples on 2D Q1 elements. <a name="fem:approx:fe:2D:fig:rectQ1"></a> </p></center>
<p><img src="fig-fem/mesh2D_rect_Q1.png" align="bottom" width=400></p>
</center>

<h3>Basis functions over triangles in the physical domain  <a name="___sec59"></a></h3>

<p>
The P1 triangular 2D element: \( u \) is linear \( ax + by + c \) over each
triangular cell.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 29:  Example on piecewise linear 2D functions defined on triangles. <a name="fem:approx:fe:2D:fig:femfunc"></a> </p></center>
<p><img src="fig-fem/demo2D_4x3r.png" align="bottom" width=400></p>
</center>

<p>

<ul>
 <p><li> Cells: triangles</li>
 <p><li> Vertices: corners of the cells</li>
 <p><li> Nodes = vertices</li>
 <p><li> Degrees of freedom: function values at the nodes</li>
 <p><li> Linear mapping of reference element onto general triangular cell</li>
 <p><li> \( \basphi_i \): pyramid shape, composed of planes.</li>
 <p><li> \( \basphi_i=1 \) at vertex (node) \( i \), 0 at all other vertices (nodes).</li>
</ul>
<p>

<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 30:  Example on a piecewise linear 2D basis function over a patch of triangles. <a name="fem:approx:fe:2D:fig:basphi"></a> </p></center>
<p><img src="fig-fem/demo2D_basisfunc.png" align="bottom" width=400></p>
</center>

<h4>Element matrices and vectors  <a name="___sec60"></a></h4>

<p>
\( \basphi_i\basphi_j\neq 0 \) only if \( i \) and \( j \) are degrees of freedom
(vertices/nodes) in the same element. Element matrix: \( 3\times 3 \).

<h3>Basis functions over triangles in the reference cell  <a name="___sec61"></a></h3>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 31:  2D P1 element. <a name="fem:approx:fe:2D:fig:P12D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P1_2d.png" align="bottom" width=100></p>
</center>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X,Y) &= 1 - X - Y,\\ 
\refphi_1(X,Y) &= X,\\ 
\refphi_2(X,Y) &= Y
\end{align}
$$
<p>&nbsp;<br>


<p>
Higher-order elements introduce more nodes. Degrees of freedom are the
function values at the nodes.

<p>
Higher-order means higher-degree polynomials.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 32:  2D P2 element. <a name="fem:approx:fe:2D:fig:P22D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P2_2d.png" align="bottom" width=100></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 33:  2D P1, P2, P3, P4, P5, and P6 elements. <a name="fem:approx:fe:2D:fig:P162D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P1-6_2d.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 34:  P1 elements in 1D, 2D, and 3D. <a name="fem:approx:fe:2D:fig:P1:123D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P1-1d2d3d.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 35:  P2 elements in 1D, 2D, and 3D. <a name="fem:approx:fe:2D:fig:P2:123D"></a> </p></center>
<p><img src="fig-fem/fenics-book/elements/P2-1d2d3d.png" align="bottom" width=400></p>
</center>

<p>

<ul>
 <p><li> Interval, triangle, tetrahedron: <em>simplex</em> element</li>
 <p><li> Plural quick-form: <em>simplices</em></li>
 <p><li> Side of the cell is called <em>face</em></li>
 <p><li> Thetrahedron has also <em>edges</em></li>
</ul>
<p>

<h3>Affine mapping of the reference cell  <a name="___sec62"></a></h3>

<p>
Mapping of local \( (X,Y) \) coordinates in the reference cell to
global, physical \( (x,y) \) coordinates:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\x = \sum_{r} \refphi_r^{(1)}(\X)\xdno{q(e,r)},
\tag{26}
\end{equation}
$$
<p>&nbsp;<br>

where

<p>

<ul>
  <p><li> \( r \) runs over the local vertex numbers in the cell</li>
  <p><li> \( \xdno{i} \) are the \( (x,y) \) coordinates of vertex \( i \)</li>
  <p><li> \( \refphi_r^{(1)} \) are P1 basis functions</li>
</ul>
<p>

This mapping preserves the straight/planar faces and edges.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 36:  Affine mapping of a P1 element. <a name="fem:approx:fe:map:fig:2DP1"></a> </p></center>
<p><img src="fig-fem/ElmT3n2D_map.png" align="bottom" width=400></p>
</center>

<h3>Isoparametric mapping of the reference cell  <a name="___sec63"></a></h3>

<p>
Idea: Use the basis functions of the element to map the element

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\x = \sum_{r} \refphi_r(\X)\xdno{q(e,r)},
\tag{27}
\end{equation}
$$
<p>&nbsp;<br>

Advantage: higher-order polynomial basis functions now maps the
reference cell to a <em>curved</em> triangle or tetrahedron.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 37:  Isoparametric mapping of a P2 element. <a name="fem:approx:fe:map:fig:2DP2"></a> </p></center>
<p><img src="fig-fem/ElmT6n2D_map.png" align="bottom" width=400></p>
</center>

<h3>Computing integrals  <a name="___sec64"></a></h3>

<h3>Differential equation models <a name="fem:deq:1D:models"></a></h3>

<p>
Abstract differential equation:
<p>&nbsp;<br>
$$
\begin{equation}
\mathcal{L}(u) = 0,\quad x\in\Omega\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
Examples:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mathcal{L}(u) &= \frac{d^2u}{dx^2} - f(x),
\tag{28}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(x)\frac{du}{dx}\right) + f(x),
\tag{29}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(u)\frac{du}{dx}\right) - \alpha u + f(x),
\tag{30}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(u)\frac{du}{dx}\right) + f(u,x)
\tag{31}
\thinspace .
\end{align}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
{\cal B}_0(u)=0,\ x=0,\quad {\cal B}_1(u)=0,\ x=L
\end{equation}
$$
<p>&nbsp;<br>


<p>
There are three common choices of boundary conditions:
<p>&nbsp;<br>
$$
\begin{align}
{\cal B}_i(u) &= u - g,\quad \hbox{(Dirichlet condition)},\\ 
{\cal B}_i(u) &= -a \frac{du}{dx} - g,\quad \hbox{(Neumann condition)},\\ 
{\cal B}_i(u) &= -a \frac{du}{dx} - a(u-g),\quad \hbox{(Robin condition)}
\thinspace .
\end{align}
$$
<p>&nbsp;<br>


<p>
From now on we shall use \( \uex(x) \) as symbol for the <em>exact</em> solution,
fulfilling

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\mathcal{L}(\uex)=0,\quad x\in\Omega,
\end{equation}
$$
<p>&nbsp;<br>

while \( u(x) \) denotes an <em>approximate</em> solution of the differential
equation.

<h3>Residual-minimizing principles <a name="fem:deq:1D:residual:min"></a></h3>

<p>
The fundamental idea is to seek an approximate solution
\( u \) in some space \( V \) with basis

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \{ \baspsi_0(x),\ldots,\baspsi_N(x)\},\end{equation*}
$$
<p>&nbsp;<br>

which means that \( u \) can always be expressed as

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) = \sum_{j\in\If} c_j\baspsi_j(x),\end{equation*}
$$
<p>&nbsp;<br>

for some unknown coefficients \( c_0,\ldots,c_N \).

<p>
Inserting this \( u \) in the equation gives a nonzero <em>residual</em> \( R \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
R = \mathcal{L}(u) = \mathcal{L}(\sum_j c_j \baspsi_j),
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( R \) measures how well \( u \) fulfills the differential equation, but says
   nothing about the <em>error</em> \( \uex - u \)</li>
 <p><li> We cannot know \( \uex - u \)</li>
 <p><li> Therefore, we aim to minimize \( R \)</li>
 <p><li> Find \( c_0,\ldots,c_N \) such that \( R(x; c_0,\ldots,c_N) \) is small</li>
</ul>
<p>

<h4>The least squares method  <a name="___sec67"></a></h4>

<p>
Idea: minimize

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} R^2 dx
\end{equation}
$$
<p>&nbsp;<br>


<p>
With the inner product

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(f,g) = \int_{\Omega} f(x)g(x) dx,
\end{equation}
$$
<p>&nbsp;<br>


<p>
the least-squares method can be defined as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\min_{c_0,\ldots,c_N} E = (R,R)\thinspace . \end{equation}
$$
<p>&nbsp;<br>

Differentiating with respect to the free parameters \( c_0,\ldots,c_N \)
gives the \( N+1 \) equations

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} 2R\frac{\partial R}{\partial c_i} dx = 0\quad
\Leftrightarrow\quad (R,\frac{\partial R}{\partial c_i})=0,\quad
i\in\If\thinspace .
\tag{32}
\end{equation}
$$
<p>&nbsp;<br>

<h4>The Galerkin method  <a name="___sec68"></a></h4>

<p>
Idea: make \( R \) orthogonal to \( V \),

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in V\thinspace .
\tag{33}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Equivalent statement:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,\baspsi_i)=0,\quad i\in\If,
\tag{34}
\end{equation}
$$
<p>&nbsp;<br>

This statement generates \( N+1 \) equations for \( c_0,\ldots,c_N \).

<h4>The Method of Weighted Residuals  <a name="___sec69"></a></h4>

<p>
Generalization of the Galerkin method: demand \( R \)
orthogonal to some space \( W \), possibly \( W\neq V \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in W\thinspace .
\tag{35}
\end{equation}
$$
<p>&nbsp;<br>

If \( \{w_0,\ldots,w_N\} \) is a basis for \( W \), we can equivalently
express the method of weighted residuals as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(R,w_i)=0,\quad i\in\If\thinspace .
\tag{36}
\end{equation}
$$
<p>&nbsp;<br>

This gives \( N+1 \) equations for \( c_0,\ldots,c_N \).

<p>
Note: The least-squares method can also be viewed as a weighted residual
method with \( w_i = \partial R/\partial c_i \).

<h4>Test and Trial Functions  <a name="___sec70"></a></h4>

<p>

<ul>
 <p><li> \( \baspsi_j \) used in \( \sum_jc_j\baspsi_j \): <em>trial function</em></li>
 <p><li> \( \baspsi_i \) or \( w_i \) used as weight in Galerkin's method: <em>test function</em></li>
</ul>
<p>

<h4>The collocation method  <a name="___sec71"></a></h4>

<p>
Idea: demand \( R=0 \) at \( N+1 \) points.

<p>
<p>&nbsp;<br>
$$
\begin{equation}
R(\xno{i}; c_0,\ldots,c_N)=0,\quad i\in\If\thinspace .
\tag{37}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Note: The collocation method is a weighted residual method with
delta functions as weights.

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega} f(x)\delta (x-\xno{i}) dx = f(\xno{i}),\quad \xno{i}\in\Omega\thinspace .
\tag{38}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 38:  Approximation of delta functions by narrow Gaussian functions. <a name="fem:deq:1D:fig:Dirac"></a> </p></center>
<p><img src="fig-fem/delta_func_weight.png" align="bottom" width=400></p>
</center>

<h3>Examples on using the principles <a name="fem:deq:1D:ex:sines"></a></h3>

<h4>The model problem  <a name="___sec73"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=0
\thinspace .
\tag{39}
\end{equation}
$$
<p>&nbsp;<br>

<h4>Basis functions  <a name="___sec74"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\baspsi_i(x) = \sinL{i},\quad i\in\If\thinspace .
\tag{40}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Note: \( \baspsi_i(0)=\baspsi_i(L)=0 \), which ensures that \( u \)
fulfills the boundary conditions:

<p>
<p>&nbsp;<br>
$$ u(0) = \sum_jc_j\baspsi_j(0) = 0,\quad u(L) = \sum_jc_j\baspsi_j(L)
\thinspace .$$
<p>&nbsp;<br>


<p>
Another useful property is the orthogonality on \( \Omega \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int\limits_0^L \sinL{i}\sinL{j}\, dx = \left\lbrace
\begin{array}{ll} \half L & i=j  \\ 0, & i\neq j
\end{array}\right.
\end{equation}
$$
<p>&nbsp;<br>


<p>
That is, the coefficient matrix becomes diagonal (\( \baspsi_i\baspsi_j=0 \)).

<h4>The residual  <a name="___sec75"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{align}
R(x;c_0,\ldots,c_N) &= u''(x) + f(x),\nonumber\\ 
&= \frac{d^2}{dx^2}\left(\sum_{j\in\If} c_j\baspsi_j(x)\right)
+ f(x),\nonumber\\ 
&= -\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\thinspace .
\tag{41}
\end{align}
$$
<p>&nbsp;<br>

<h4>The least squares method  <a name="___sec76"></a></h4>

<p>
<p>&nbsp;<br>
$$
(R,\frac{\partial R}{\partial c_i}) = 0,\quad i\in\If\thinspace .
$$
<p>&nbsp;<br>


<p>
We need an expression for
\( \partial R/\partial c_i \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial R}{\partial c_i} =
\frac{\partial}{\partial c_i}
\left(\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\right)
= \baspsi_i''(x)\thinspace . \end{equation}
$$
<p>&nbsp;<br>

Because:
<p>&nbsp;<br>
$$
\frac{\partial}{\partial c_i}\left(c_0\baspsi_0'' + c_1\baspsi_1'' + \cdots +
c_{i-1}\baspsi_{i-1}'' + c_i\baspsi_{i}'' + c_{i+1}\baspsi_{i+1}''
+ \cdots + c_N\baspsi_N'' \right) = \baspsi_{i}''
$$
<p>&nbsp;<br>


<p>
The governing equations for \( c_0,\ldots,c_N \) are then

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\sum_j c_j \baspsi_j'' + f,\baspsi_i'')=0,\quad i\in\If,
\end{equation}
$$
<p>&nbsp;<br>

which can be rearranged as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j\in\If}(\baspsi_i'',\baspsi_j'')c_j = -(f,\baspsi_i''),\quad i\in\If\thinspace . \end{equation}
$$
<p>&nbsp;<br>

This is nothing but a linear system

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \sum_{j\in\If}A_{i,j}c_j = b_i,\quad i\in\If,
\end{equation*}
$$
<p>&nbsp;<br>

with

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{i,j} &= (\baspsi_i'',\baspsi_j'')\nonumber\\ 
& = \pi^4(i+1)^2(j+1)^2L^{-4}\int_0^L \sinL{i}\sinL{j}\, dx\nonumber\\ 
&= \left\lbrace
\begin{array}{ll} {1\over2}L^{-3}\pi^4(i+1)^4 & i=j  \\ 0, & i\neq j
\end{array}\right.
\\ 
b_i &= -(f,\baspsi_i'') = (i+1)^2\pi^2L^{-2}\int_0^Lf(x)\sinL{i}\, dx
\end{align}
$$
<p>&nbsp;<br>

Since the coefficient matrix is diagonal we can easily solve for

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_i = \frac{2L}{\pi^2(i+1)^2}\int_0^Lf(x)\sinL{i}\, dx\thinspace .
\tag{42}
\end{equation}
$$
<p>&nbsp;<br>

With the special choice of \( f(x)=2 \) the integral becomes

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \frac{L\cos(\pi i) + L}{\pi (i+1)},\end{equation*}
$$
<p>&nbsp;<br>


<p>
The solution becomes:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \sum_{k=0}^{N/2} \frac{8L^2}{\pi^3(2k+1)^3}\sinL{2k}\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
The coefficients decay very fast: \( c_2 = c_0/27 \), \( c_4=c_0/125 \).
The first term therefore suffices:

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) \approx \frac{8L^2}{\pi^3}\sin\left(\pi\frac{x}{L}\right)\thinspace . \end{equation*}
$$
<p>&nbsp;<br>

<h4>The Galerkin method  <a name="___sec77"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
(u''+f,v)=0,\quad \forall v\in V,
\end{equation*}
$$
<p>&nbsp;<br>

or

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(u'',v) = -(f,v),\quad\forall v\in V\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
This is called a <em>variational formulation</em> of the differential equation problem.

<p>
\( \forall v\in V \) means for all basis functions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\sum_{j\in\If} c_j\baspsi_j'', \baspsi_i)=-(f,\baspsi_i),\quad i\in\If\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
For the particular choice of the sine basis functions, we
get in fact the same linear system
as in the least squares method
(because \( \baspsi''= -(i+1)^2\pi^2L^{-2}\baspsi \)).

<h4>The collocation method  <a name="___sec78"></a></h4>

<p>
Residual must vanish at selected points, or equivalently, the
differential equation with approximation \( u \) inserted, must be
fulfilled at selected points:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\sum_{j\in\If} c_j\baspsi_j''(\xno{i}) = f(\xno{i}),\quad i\in\If
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>

This is a linear system with entries

<p>
<p>&nbsp;<br>
$$
\begin{equation*} A_{i,j}=-\baspsi_j''(\xno{i})=
(j+1)^2\pi^2L^{-2}\sin\left((j+1)\pi \frac{x_i}{L}\right),\end{equation*}
$$
<p>&nbsp;<br>

and \( b_i=2 \).

<p>
Special case: \( N=0 \), \( x_0=L/2 \)
<p>&nbsp;<br>
$$ c_0=2L^2/\pi^2 $$
<p>&nbsp;<br>

<h4>Comparison  <a name="___sec79"></a></h4>

<p>

<ul>
 <p><li> Exact solution: \( u(x)=x(L-x) \)</li>
 <p><li> Galerkin or least squares (\( N=0 \)): \( u(x)=8L^2\pi^{-3}\sin (\pi x/L) \)</li>
 <p><li> Collocation method (\( N=0 \)): \( u(x)=2L^2\pi^{-2}\sin (\pi x/L) \).</li>
 <p><li> Max error in Galerkin/least sq.: \( -0.008L^2 \)</li>
 <p><li> Max error in collocation: \( 0.047L^2 \)</li>
</ul>
<p>

<h3>Integration by parts <a name="fem:deq:1D:varform"></a></h3>

<p>

<ul>
 <p><li> Finite elements: \( \baspsi_i = \baspsi_i \)</li>
 <p><li> Problem: \( \baspsi_i' \) is discontinuous (at cell boundaries)
   and we need \( \baspsi_i'' \) in the Galerkin or least squares methods</li>
 <p><li> Remedy: integrate by parts - then we only need \( \baspsi_i' \)</li>
</ul>
<p>

Given
<p>&nbsp;<br>
$$
\begin{equation*} -(u'',v) = (f,v)\quad\forall v\in V\ts
\end{equation*}
$$
<p>&nbsp;<br>

Integrate by parts:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\int_0^L u''(x)v(x) dx &= - \int_0^Lu'(x)v'(x)dx
+ [vu']_0^L\nonumber\\ 
&= - \int_0^Lu'(x)v'(x) dx
+ u'(L)v(L) - u'(0)v(0)\thinspace .
\tag{43}
\end{align}
$$
<p>&nbsp;<br>


<p>
Recall that \( v(0)=v(L)=0 \), i.e.,
\( \baspsi_i(0)=\baspsi_i(L)=0 \) because we demand so where we have
Dirichlet conditions.

<p>
Advantageous features of integration by parts:

<p>

<ul>
  <p><li> Only first-order derivatives</li>
  <p><li> Symmatric coefficient matrix</li>
  <p><li> Incorporation of \( u' \) boundary conditions (later)</li>
</ul>
<p>

<h3>Boundary function  <a name="___sec81"></a></h3>
<a name="fem:deq:1D:essBC:Bfunc"></a>

<p>

<ul>
 <p><li> What about nonzero Dirichlet conditions?</li>
 <p><li> E.g. \( u(L)=D \)</li>
 <p><li> Problem: \( u(L) = \sum_j c_j\baspsi_j(L)=0 \) - always</li>
 <p><li> Remedy: \( u(x) = B(x) + \sum_j c_j\baspsi_j(x) \)</li>
 <p><li> \( u(0)=B(0) \), \( u(L)=B(L) \)</li>
 <p><li> \( B(x) \) must fulfill the Dirichlet conditions on \( u \)</li>
 <p><li> No restrictions of how \( B(x) \) varies in the interior</li>
</ul>
<p>

<h4>Example  <a name="___sec82"></a></h4>

<p>
\( u(0)=0 \) and \( u(L)=D \). Choose

<p>
<p>&nbsp;<br>
$$ B(x) = \frac{D}{L}x:\qquad B(0)=0,\ B(L)=D \thinspace .$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \frac{x}{L}D + \sum_{j\in\If} c_j\baspsi_j(x),
\tag{44}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u(0) = 0,\quad u(L) = 0\thinspace . $$
<p>&nbsp;<br>

<h3>Abstract notation for variational formulations <a name="fem:deq:1D:varform:abstract"></a></h3>

<p>
The finite element literature (and much FEniCS documentation)
applies an abstract notation for the variational formulation:
*Find \( u-B\in V \) such that
<p>&nbsp;<br>
$$ a(u,v) = L(v)\quad \forall v\in V\thinspace .$$
<p>&nbsp;<br>

<h4>Example  <a name="___sec84"></a></h4>

<p>
Given a variational formulation for \( -u''=f \):

<p>
<p>&nbsp;<br>
$$ \int_{\Omega} u' v'dx = \int_{\Omega} fvdx\quad\hbox{or}\quad (u',v') = (f,v)
\quad\forall v\in V$$
<p>&nbsp;<br>

we identify

<p>
<p>&nbsp;<br>
$$ a(u,v) = (u',v'),\quad L(v) = (f,v)\thinspace . $$
<p>&nbsp;<br>


<p>
Then we can write
<p>&nbsp;<br>
$$ a(u,v) = L(v)\quad \forall v\in V,$$
<p>&nbsp;<br>

if

<h4>Bilinear and linear forms  <a name="___sec85"></a></h4>

<p>
\( a(u,v) \) is a <em>bilinear form</em> and \( L(v) \) is a <em>linear form</em>.

<p>
Linear form:

<p>
<p>&nbsp;<br>
$$ L(\alpha_1 v_1 + \alpha_2 v_2)
=\alpha_1 L(v_1) + \alpha_2 L(v_2),
$$
<p>&nbsp;<br>


<p>
Bilinear form:
<p>&nbsp;<br>
$$
\begin{align*}
a(\alpha_1 u_1 + \alpha_2 u_2, v) &= \alpha_1 a(u_1,v) + \alpha_2 a(u_2, v),
\\ 
a(u, \alpha_1 v_1 + \alpha_2 v_2) &= \alpha_1 a(u,v_1) + \alpha_2 a(u, v_2)
\thinspace .
\end{align*}
$$
<p>&nbsp;<br>


<p>
In nonlinear problems the abstract form is \( F(u;v)=0 \) $\forall v\in V$.

<p>
The abstract form \( a(u,v)=L(v) \) is equivalent with a linear system

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} A_{i,j}c_j=b_i,\quad i\in\If$$
<p>&nbsp;<br>

with
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,j} &= a(\baspsi_j,\baspsi_i),\\ 
b_i &= L(\baspsi_i) \thinspace .
\end{align*}
$$
<p>&nbsp;<br>

<h3>More examples on variational formulations <a name="fem:deq:1D:varform:ex"></a></h3>

<h4>Variable coefficient  <a name="___sec87"></a></h4>

<p>
Consider the problem

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\frac{d}{dx}\left( a(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u(L)=D\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>
Two new features:

<p>

<ul>
 <p><li> a variable coefficient \( a(x) \)</li>
 <p><li> nonzero Dirichlet conditions at \( x=0 \) <em>and</em> \( x=L \)</li>
</ul>
<p>

A boundary function handles nonzero Dirichlet conditions:

<p>
<p>&nbsp;<br>
$$
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_i(x),\quad \baspsi_i(0)=\baspsi_i(L)=0
$$
<p>&nbsp;<br>


<p>
One possible choice of \( B \) is:

<p>
<p>&nbsp;<br>
$$ B(x) = C + \frac{1}{L}(D-C)x
\thinspace .
$$
<p>&nbsp;<br>


<p>
The residual:

<p>
<p>&nbsp;<br>
$$ R = -\frac{d}{dx}\left( a\frac{du}{dx}\right) -f\thinspace .$$
<p>&nbsp;<br>


<p>
Galerkin's method:

<p>
<p>&nbsp;<br>
$$
(R, v) = 0,\quad \forall v\in V,
$$
<p>&nbsp;<br>


<p>
Written in terms of integrals:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} \left(\frac{d}{dx}\left( a\frac{du}{dx}\right) -f\right)v dx = 0,\quad \forall v\in V \thinspace .
$$
<p>&nbsp;<br>


<p>
Integration by parts:

<p>
<p>&nbsp;<br>
$$ -\int_{\Omega} \frac{d}{dx}\left( a(x)\frac{du}{dx}\right) vdx
= \int_{\Omega} a(x)\frac{du}{dx}\frac{dv}{dx}dx -
\left[a\frac{du}{dx}v\right]_0^L
\thinspace .
$$
<p>&nbsp;<br>

Must have \( v=0 \) where we have Dirichlet conditions: boundary terms vanish.

<p>
The final variational formulation:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} a(x)\frac{du}{dx}\frac{dv}{dx}dx = \int_{\Omega} f(x)vdx,\quad
\forall v\in V,
$$
<p>&nbsp;<br>


<p>
Alternative, compact notation:

<p>
<p>&nbsp;<br>
$$
(a u',v') = (f,v),\quad \forall v\in V
\thinspace .
$$
<p>&nbsp;<br>


<p>
The abstract notation is

<p>
<p>&nbsp;<br>
$$ a(u,v)=L(v)\quad\forall v\in V,$$
<p>&nbsp;<br>

with
<p>&nbsp;<br>
$$ a(u,v)= (au',v'),\quad L(v)=(f,v) \thinspace . $$
<p>&nbsp;<br>

Do not mix the \( a \) in \( a(\cdot,\cdot) \) (notation) and \( a(x) \) (function
name).

<p>
Can derive the linear system by inserting \( u=B + \sum_jc_j\baspsi_j \) and
\( v=\baspsi_i \):

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} (a\baspsi_j', \baspsi_i')c_j  =
(f,\baspsi_i) + (a(D-C)L^{-1},\baspsi_i'),
\quad i\in\If,
$$
<p>&nbsp;<br>

or \( \sum_j A_{i,j}c_j=b_i \) with

<p>
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,j} &= (a\baspsi_j', \baspsi_i') = \int_{\Omega} a(x)\baspsi_j'(x),
\baspsi_i'(x)dx,\\ 
b_i &= (f,\baspsi_i) + (a(D-C)L^{-1},\baspsi_i')=
\int_{\Omega} \left(f(x)\baspsi_i(x) + a(x)\frac{D-C}{L}\baspsi_i'(x)\right)dx
\thinspace .
\end{align*}
$$
<p>&nbsp;<br>

<h4>First-order derivative in the equation and boundary condition  <a name="___sec88"></a></h4>

<p>
Model:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u'(L)=E\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>
New features:

<p>

<ul>
 <p><li> first-order derivative \( u' \) in the equation</li>
 <p><li> boundary condition with \( u' \): \( u'(L)=E \)</li>
</ul>
<p>

Initial steps:

<p>

<ul>
 <p><li> Must force \( \baspsi_i(0)=0 \) because of Dirichlet condition at \( x=0 \)</li>
 <p><li> Boundary function: \( B(x)=C(L-x)/L \)</li>
 <p><li> No requirements on \( \baspsi_i(L) \) (no Dirichlet condition at \( x=L \))</li>
</ul>
<p>

<p>&nbsp;<br>
$$ u = \frac{C}{L}(L-x) + \sum_{j\in\If} c_j \baspsi_i(x)
\thinspace .
$$
<p>&nbsp;<br>


<p>
Galerkin's method: multiply by \( v \), integrate over \( \Omega \), integrate
by parts.

<p>
<p>&nbsp;<br>
$$  (-u'' + bu' - f, v) = 0,\quad\forall v\in V,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$  (-u'',v) + (bu',v) - (f, v) = 0,\quad\forall v\in V,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ (u',v') + (bu',v) = (f,v) + [u' v]_0^L, \quad\forall v\in V,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ (u'v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V,$$
<p>&nbsp;<br>

when \( [u' v]_0^L = u'(L)v(L) = E v(L) \) because
\( v(0)=0 \) and \( u'(L)=E \).

<p>
Important:

<p>

<ul>
  <p><li> The boundary term can be used to implement Neumann conditions</li>
  <p><li> Forgetting the boundary term implies the condition \( u'=0 \) (!)</li>
  <p><li> Such conditions are called <em>natural boundary conditions</em></li>
</ul>
<p>

Abstract notation:

<p>
<p>&nbsp;<br>
$$ a(u,v)=L(v)\quad\forall v\in V,$$
<p>&nbsp;<br>

with the particular formulas
<p>&nbsp;<br>
$$ a(u,v)=(u',v') + (bu',v),\quad L(v)= (f+C,v) + E v(L)\thinspace .$$
<p>&nbsp;<br>


<p>
Linear system: insert \( u=B+\sum_jc_j\baspsi_j \) and \( v=\baspsi_i \),

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} \underbrace{((\baspsi_j',\baspsi_i') + (b\baspsi_j',\baspsi_i))}_{A_{i,j}} c_j = \underbrace{(f,\baspsi_i) + (bCL^{-1},\baspsi_i') + E \baspsi_i(L)}_{b_i}
\thinspace .
$$
<p>&nbsp;<br>


<p>
Observation: \( A_{i,j} \) is not symmetric because of the term

<p>
<p>&nbsp;<br>
$$
(b\baspsi_j',\baspsi_i)=\int_{\Omega} b\baspsi_j'\baspsi_i dx
 \neq \int_{\Omega} b \baspsi_i' \baspsi_jdx = (\baspsi_i',b\baspsi_j)
\thinspace .
$$
<p>&nbsp;<br>

<h3>Example on computing with Dirichlet and Neumann conditions  <a name="___sec89"></a></h3>

<p>
Let us solve

<p>
<p>&nbsp;<br>
$$
\begin{equation*} -u''(x)=f(x),\quad x\in \Omega=[0,1],\quad u'(0)=C,\ u(1)=D,\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Use a <em>global</em> polynomial basis \( \baspsi_i\sim x^i \) on \( [0,1] \)</li>
 <p><li> Because of \( u(1)=D \): \( \baspsi_i(1)=0 \)</li>
 <p><li> Basis: \( \baspsi_i(x)=(1-x)^{i+1} \), \( i\in\If \)</li>
 <p><li> \( B(x)=Dx \)</li>
</ul>
<p>

We have

<p>
<p>&nbsp;<br>
$$ A_{i,j} = (\baspsi_j,\baspsi_i) = \int_{0}^1 \baspsi_i'(x)\baspsi_j'(x)dx
= \int_0^1 (i+1)(j+1)(1-x)^{i+j} dx,
$$
<p>&nbsp;<br>

and

<p>
<p>&nbsp;<br>
$$
\begin{align*}
b_i &= (2,\baspsi_i) - (D,\baspsi_i') -C\baspsi_i(0)\\ 
&= \int_0^1 \left( 2(1-x)^{i+1} - D(i+1)(1-x)^i\right)dx  -C\baspsi_i(0)
\end{align*}
$$
<p>&nbsp;<br>


<p>
With \( N=1 \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\left(\begin{array}{cc}
1 & 1\\ 
1 & 4/3
\end{array}\right)
\left(\begin{array}{c}
c_0\\ 
c_1
\end{array}\right)
=
\left(\begin{array}{c}
-C+D+1\\ 
2/3 -C + D
\end{array}\right)
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ c_0=-C+D+2, \quad c_1=-1,$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u(x) = 1 -x^2 + D + C(x-1) \thinspace . $$
<p>&nbsp;<br>

This is also the exact solution (as expected when \( V \) contains second-degree
polynomials).

<h4>Nonlinear terms  <a name="___sec90"></a></h4>

<p>
The techniques used to derive variational
forms also apply in nonlinear cases.

<p>
Consider
<p>&nbsp;<br>
$$
\begin{equation}
-(a(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
\thinspace .
\end{equation}
$$
<p>&nbsp;<br>


<p>
Using the Galerkin principle, we multiply by \( v\in V \) and integrate,

<p>
<p>&nbsp;<br>
$$ -\int_0^L \frac{d}{dx}\left(a(u)\frac{du}{dx}\right)v dx =
\int_0^L f(u)v\, dx\quad\forall v\in V
\thinspace .
$$
<p>&nbsp;<br>

Integration by parts is not affected by \( a(u) \):

<p>
<p>&nbsp;<br>
$$ \int_0^L a(u)\frac{du}{dx}\frac{dv}{dx} dx =
\int_0^L f(u)v\, dx + [avu']_0^L\quad\forall v\in V
\thinspace .
$$
<p>&nbsp;<br>

\( [vu']_0^L=v(L)E \) since \( v(0)=0 \) and \( u'(L)=E \).

<p>
<p>&nbsp;<br>
$$ (a(u)u', v') = (f(u),v) + a(L)v(L)E\quad\forall v\in V
\thinspace .
$$
<p>&nbsp;<br>


<p>
Since the problem is nonlinear, we cannot identify a <em>bilinear</em> form
\( a(u,v) \) and a <em>linear</em> form \( L(v) \).
An abstract notation is typically <em>find \( u \) such that</em>

<p>
<p>&nbsp;<br>
$$ F(u;v) = 0\quad\forall v\in V,$$
<p>&nbsp;<br>

here with
<p>&nbsp;<br>
$$ F(u;v) = (a(u)u', v') - (f(u),v) - a(L)v(L)E
\thinspace .
$$
<p>&nbsp;<br>


<p>
By inserting \( u=\sum_j c_j\baspsi_j \) we get a <em>nonlinear system of
algebraic equations</em> for the unknowns \( c_0,\ldots,c_N \). Such systems must
be solved by constructing a sequence of linear systems whose solutions
converge to the solution of the nonlinear system. Frequently applied
methods are Picard iteration and Newton's method.

<h3>Variational problems and optimization of functionals <a name="fem:deq:1D:optimization"></a></h3>

<p>
If \( a(u,v)=a(v,u) \), it can be shown that the variational statement
\( a(u,v)=L(v)\ \forall v\in V \) is equivalent to minimizing the functional

<p>
<p>&nbsp;<br>
$$ F(v) = \frac{1}{2}a(v,v) - L(v) $$
<p>&nbsp;<br>

That is, find \( u \) such that

<p>
<p>&nbsp;<br>
$$ F(u)\leq F(v)\quad\forall v\in V\thinspace .$$
<p>&nbsp;<br>


<p>
Traditional use of finite elements, especially in structural analysis,
often starts with \( F(v) \) and
then derives \( a(u,v)=L(v) \).

<h2>Computing with finite elements <a name="fem:deq:1D:fem1"></a></h2>

<p>
Given

<p>
<p>&nbsp;<br>
$$ -u''(x) = 2,\quad x\in (0,L),\ u(0)=u(L)=0,$$
<p>&nbsp;<br>

with variational formulation

<p>
<p>&nbsp;<br>
$$ (u',v') = (2,v)\quad\forall v\in V\thinspace . $$
<p>&nbsp;<br>


<p>
Tasks:

<p>

<ul>
 <p><li> Solve for \( u \) using finite elements</li>
 <p><li> show all details</li>
 <p><li> Uniformly spaced nodes</li>
 <p><li> P1 elements</li>
</ul>
<p>

Since \( u(0)=0 \) and \( u(L)=0 \), \( c_0=c_N=0 \), and we can use a
sum over basis functions associated with internal nodes only:

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
u(x) = \sum_{j=1}^{N-1}c_j\basphi_j(x)\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>

<h3>Computation in the global physical domain  <a name="___sec93"></a></h3>

<p>
We are to compute

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i,j}=\int_0^L\basphi_i'(x)\basphi_j'(x) dx,\quad
b_i=\int_0^L2\basphi_i(x) dx
\thinspace . \end{equation*}
$$
<p>&nbsp;<br>


<p>
Need \( \basphi_i'(x) \) in the formulas:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\basphi_i'(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
h^{-1},
& \xno{i-1} \leq x < \xno{i},\\ 
-h^{-1},
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{45}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 39:  Illustration of the derivative of piecewise linear basis functions associated with nodes in cell 1.  <a name="fem:approx:fe:fig:dP1"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_dbasis_p1_4e_lab.png" align="bottom" width=600></p>
</center>

<p>
We realize that \( \basphi_i' \) and \( \basphi_j' \) has no overlap, and hence their
product vanishes, unless \( i \) and \( j \) are nodes belonging to the same
element. The only nonzero contributions to the coefficient matrix are
therefore

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
2 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 2
\end{array}
\right)
\left(
\begin{array}{c}
c_1 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N-1}
\end{array}
\right)
=
\left(
\begin{array}{c}
2h \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
2h
\end{array}
\right)
\tag{46}
\end{equation}
$$
<p>&nbsp;<br>


<p>
\( c_j=u(\xno{j}) \) so we introduce \( u_j=c_j \) to easily compare with
the finite difference method. The equation corresponding to row \( i \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\frac{1}{h}u_{i-1} + \frac{2}{h}u_{i} - \frac{1}{h}u_{i+1} = 2h\thinspace .
\tag{47}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Standard finite difference approximation of \( -u''(x)=2 \), with
\( u''(x_i)\approx [D_x D_x u]_i \) and \( \Delta x = h \),
yields

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\frac{u_{i-1} - 2u_{i} + u_{i+1}}{h^2} = 2,
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> The finite element and the finite difference method give the
   same equation (in this example)</li>
</ul>
<p>

<h3>Elementwise computations  <a name="___sec94"></a></h3>

<p>
We follow the same elementwise set-up as for approximating \( f \) by \( u \).

<p>
Present element matrix:

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i,j}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) dx
= \int_{-1}^1 \frac{d}{dx}\refphi_r(X)\frac{d}{dx}\refphi_s(X)
\frac{h}{2} dX,\quad i=q(e,r),\ j=q(e,s),\ r,s=1,2
\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>
\( \refphi_r(X) \) are known as functions of \( X \), but
we need \( d\refphi_r(X)/dx \).

<p>
Given

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \refphi_0(X)=\half(1-X),\quad\refphi_1(X)=\half(1+X),\end{equation*}
$$
<p>&nbsp;<br>

we can easily compute \( d\refphi_r/ dX \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}\frac{d\refphi_0}{dX} = -\half,\quad  \frac{d\refphi_1}{dX} = \half\thinspace . \end{equation*}
$$
<p>&nbsp;<br>

From the chain rule,

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{d\refphi_r}{dx} = \frac{d\refphi_r}{dX}\frac{dX}{dx}
= \frac{2}{h}\frac{d\refphi_r}{dX}\thinspace . \end{equation}
$$
<p>&nbsp;<br>

The transformed integral is then:

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
A_{i,j}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) dx
= \int_{-1}^1 \frac{2}{h}\frac{d\refphi_r}{dX}\frac{2}{h}\frac{d\refphi_s}{dX}
\frac{h}{2} dX
\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>
The right-hand side is transformed according to

<p>
<p>&nbsp;<br>
$$
\begin{equation*} b_i^{(e)} = \int_{\Omega^{(e)}} 2\basphi_i(x) dx =
\int_{-1}^12\refphi_r(X)\frac{h}{2} dX,\quad i=q(e,r),\ r=1,2
\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>
We have to compute the matrix entries one by one...

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\tilde A_{0,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\frac{1}{2}\right)
\frac{2}{h}\left(-\frac{1}{2}\right)\frac{2}{h} dX = \frac{1}{h}\\ 
\tilde A_{0,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\frac{1}{2}\right)
\frac{2}{h}\left(\frac{1}{2}\right)\frac{2}{h} dX = -\frac{1}{h}\\ 
\tilde A_{1,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\frac{1}{2}\right)
\frac{2}{h}\left(-\frac{1}{2}\right)\frac{2}{h} dX = -\frac{1}{h}\\ 
\tilde A_{1,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\frac{1}{2}\right)
\frac{2}{h}\left(\frac{1}{2}\right)\frac{2}{h} dX = \frac{1}{h}
\end{align*}
$$
<p>&nbsp;<br>

The element vector entries become
<p>&nbsp;<br>
$$
\begin{align*}
\tilde b_0^{(e)} &= \int_{-1}^12\half(1-X)\frac{h}{2} dX = h\\ 
\tilde b_1^{(e)} &= \int_{-1}^12\half(1+X)\frac{h}{2} dX = h\thinspace .
\end{align*}
$$
<p>&nbsp;<br>


<p>
In matrix/vector notation:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1\\ 
1
\end{array}\right)\thinspace .
\tag{48}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Must assemble - but first see how to incorporate boundary conditions.

<h2>Boundary conditions: specified value <a name="fem:deq:1D:essBC"></a></h2>

<h3>General construction of a boundary function <a name="fem:deq:1D:essBC:Bfunc"></a></h3>

<p>

<ul>
  <p><li> \( B(x) \) is not always easy to construct (extend to the interior of \( \Omega \)),
    at least not in 2D and 3D</li>
  <p><li> With finite element \( \basphi_i \), \( B(x) \) can be constructed in
    a completely general way</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
B(x) = \sum_{j\in D} U_j\basphi_j(x), \end{equation}
$$
<p>&nbsp;<br>

where \( D \) are the nodes with Dirichlet conditions and \( U_j \) the known values.

<p>
In 1D
<p>&nbsp;<br>
$$
\begin{equation}
B(x) = U_0\basphi_0(x) + U_N\basphi_N(x)\thinspace . \end{equation}
$$
<p>&nbsp;<br>


<p>
Unknowns: \( c_1,\ldots,c_{N-1} \),

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = U_0\basphi_0(x) + U_N\basphi_N(x) + \sum_{j=1}^{N-1} c_j\basphi_j(x)\thinspace . \end{equation}
$$
<p>&nbsp;<br>

<h4>Example  <a name="___sec97"></a></h4>

<p>
<p>&nbsp;<br>
$$ -u''=2, \quad u(0)=0,\ u(L)=D\thinspace . $$
<p>&nbsp;<br>


<p>
The expansion for \( u(x) \) reads

<p>
<p>&nbsp;<br>
$$
u(x) = 0\cdot\basphi_0(x) + D\basphi_N(x) +
\sum_{j=1}^{N-1} c_j\basphi_j(x)
\thinspace .
$$
<p>&nbsp;<br>

Inserting this expression in \( -(u'',\basphi_i)=(f,\basphi_i) \) and
integrating by parts results in a linear system with

<p>
<p>&nbsp;<br>
$$
A_{i,j} = \int_0^L \basphi_i'(x)\basphi_j'(x) dx,\quad
b_i = \int_0^L (f(x) - D\basphi_N'(x))\basphi_i(x) dx,
$$
<p>&nbsp;<br>

for \( i,j = 1,\ldots,N-1 \).

<h3>Modification of the linear system <a name="fem:deq:1D:essBC:Bfunc:modsys"></a></h3>

<p>

<ul>
 <p><li> \( B(x) \) and a reduced set of unknowns (e.g., \( c_1,\ldots,c_{N-1} \))
   are not so convenient in implementations</li>
 <p><li> We shall look at a less strict mathematical procedure that
   gives simpler impelementation</li>
 <p><li> Step 1: compute everything as there were no Dirichlet conditions</li>
 <p><li> Step 2: modify the linear system such that all known \( c_j \) get
   their right boundary values</li>
</ul>
<p>

Linear system from \( -u''=f \) without taking Dirichlet conditions into
account (\( u=\sum_{j\in\If}c_j\basphi_j \)):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
h \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
h
\end{array}
\right)
\tag{49}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Actions:

<p>

<ul>
 <p><li> General: replace row \( i \) by \( c_i=K \) if \( u \) at \( \xno{i} \) is prescrined as \( K \)</li>
 <p><li> Here: replace the first and last row by \( c_0=0 \) and \( c_N=D \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
D
\end{array}
\right)
\tag{50}
\end{equation}
$$
<p>&nbsp;<br>

<h3>Symmetric modification of the linear system  <a name="___sec99"></a></h3>

<p>

<ul>
 <p><li> The modification above destroys symmetry of the matrix (\( A_{0,1}\neq A_{1,0} \))</li>
 <p><li> Symmetry is often important in 2D and 3D (faster computations)</li>
 <p><li> A more complex modification preserves symmetry</li>
</ul>
<p>

Algorithm for incorporating \( c_i=K \):

<p>

<ol>
<p><li> Subtract column \( i \) times \( K \) from the right-hand side</li>
<p><li> Zero out column and row no \( i \)</li>
<p><li> Place 1 on the diagonal</li>
<p><li> Set \( b_i=K \)</li>
</ol>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
0 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & 0 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h +D/h\\ 
D
\end{array}
\right)
\tag{51}
\end{equation}
$$
<p>&nbsp;<br>

<h3>Modification of the element matrix and vector  <a name="___sec100"></a></h3>

<p>

<ul>
 <p><li> Modification of the linear system can be done in the
   the element matrix and vector instead</li>
 <p><li> Exactly the same procedure</li>
</ul>
<p>

Last degree of freedom in the last element is prescribed:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(N-1)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h\\ 
D
\end{array}\right)\thinspace .
\tag{52}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Or symmetric modification:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(N-1)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 0\\ 
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h + D/h\\ 
D
\end{array}\right)\thinspace .
\tag{53}
\end{equation}
$$
<p>&nbsp;<br>

<h2>Boundary conditions: specified derivative <a name="fem:deq:1D:BC:nat"></a></h2>

<p>
Focus now: how to incorporate \( u'(0)=C \) with finite elements.

<h3>The variational formulation  <a name="___sec102"></a></h3>

<p>
Start with the Galerkin method:

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \int_0^L(u''(x)+f(x))\basphi_i(x) dx = 0,\quad i\in\If,\end{equation*}
$$
<p>&nbsp;<br>


<p>
Integration of \( u''\basphi_i \) by parts:

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \int_0^Lu'(x)'\basphi_i'(x) dx -(u'(L)\basphi_i(L) - u'(0)\basphi_i(0)) =
\int_0^L f(x)\basphi_i(x) dx
\thinspace .
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Since \( \basphi_i(L)=0 \), \( u'(L)\basphi_i(L)=0 \)</li>
 <p><li> \( u'(0)\basphi_i(0) = C\basphi_i(0) \) since \( u'(0)=C \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*} \int_0^Lu'(x)\basphi_i'(x) dx + C\basphi_i(0) =
\int_0^L f(x)\basphi_i(x) dx,\quad i\in\If\thinspace . \end{equation*}
$$
<p>&nbsp;<br>

Inserting

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) = B(x) + \sum_{j=0}^{N-1} c_j\basphi_j(x),
\quad B(x) = D\basphi_N(x),
\end{equation*}
$$
<p>&nbsp;<br>

<!-- \frac{x}{L}D -->
leads to the linear system

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\sum_{j=0}^{N-1}\left(
\int_0^L \basphi_i'(x)\basphi_j'(x) dx \right)c_j =
\int_0^L\left(f(x)\basphi_i(x) -D\basphi_N'(x)\basphi_i(x)\right) dx
 - C\basphi_i(0),
\tag{54}
\end{equation}
$$
<p>&nbsp;<br>

for \( i=0,\ldots,N-1 \).

<p>
Alternatively, we may just work with

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x) = \sum_{j=0}^{N} c_j\basphi_j(x),
\end{equation*}
$$
<p>&nbsp;<br>

and modify the last equation to \( c_N=D \) in the linear system.

<p>
The extra term with \( C \) affects only the element vector from the
first element:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(0)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(0)} = \left(\begin{array}{c}
h - C\\ 
h
\end{array}\right)\thinspace .
\tag{55}
\end{equation}
$$
<p>&nbsp;<br>

<h2>The finite element algorithm  <a name="___sec103"></a></h2>

<p>
The problem at hand determines the integrals in the variational
formulation.

<p>
Request these functions from the user:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">integrand_lhs(phi, r, s, x)
boundary_lhs(phi, r, s, x)
integrand_rhs(phi, r, x)
boundary_rhs(phi, r, x)
</code></pre></div>
<p>
Given a mesh in terms of <code>vertices</code>, <code>cells</code>, and <code>dof_map</code>,
the rest is (almost) automatic.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&lt;Declare <span style="color: #8B008B; font-weight: bold">global</span> matrix <span style="color: #8B008B">and</span> rhs: A, b&gt;

<span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(cells)):

    <span style="color: #228B22"># Compute element matrix and vector</span>
    n = <span style="color: #658b00">len</span>(dof_map[e])  <span style="color: #228B22"># no of dofs in this element</span>
    h = vertices[cells[e][<span style="color: #B452CD">1</span>]] - vertices[cells[e][<span style="color: #B452CD">1</span>]]
    &lt;Declare element matrix <span style="color: #8B008B">and</span> vector: A_e, b_e&gt;

    <span style="color: #228B22"># Integrate over the reference cell</span>
    points, weights = &lt;numerical integration rule&gt;
    <span style="color: #8B008B; font-weight: bold">for</span> X, w <span style="color: #8B008B">in</span> <span style="color: #658b00">zip</span>(points, weights):
        phi = &lt;basis functions <span style="color: #8B008B">and</span> derivatives at X&gt;
        detJ = h/<span style="color: #B452CD">2</span>
        x = &lt;affine mapping <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">X</span>&gt;
        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
                A_e[r,s] += integrand_lhs(phi, r, s, x)*detJ*w
            b_e[r] += integrand_rhs(phi, r, x)*detJ*w

    <span style="color: #228B22"># Add boundary terms</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            A_e[r,s] += boundary_lhs(phi, r, s, x)*detJ*w
        b_e[r] += boundary_rhs(phi, r, x)*detJ*w

    <span style="color: #228B22"># Incorporate essential boundary conditions</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        global_dof = dof_map[e][r]
        <span style="color: #8B008B; font-weight: bold">if</span> global_dof <span style="color: #8B008B">in</span> essbc_dofs:
            <span style="color: #228B22"># dof r is subject to an essential condition</span>
            value = essbc_docs[global_dof]
            <span style="color: #228B22"># Symmetric modification</span>
            b_e -= value*A_e[:,r]
            A_e[r,:] = <span style="color: #B452CD">0</span>
            A_e[:,r] = <span style="color: #B452CD">0</span>
            A_e[r,r] = <span style="color: #B452CD">1</span>
            b_e[r] = value

    <span style="color: #228B22"># Assemble</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
            A[dof_map[e][r], dof_map[e][r]] += A_e[r,s]
        b[dof_map[e][r] += b_e[r]

&lt;solve linear system&gt;
</code></pre></div>

<h2>Variational formulations in 2D and 3D <a name="fem:deq:2D:varform"></a></h2>

<p>
How to do integration by parts is the major difference when moving to
2D and 3D.

<p>
Consider

<p>
<p>&nbsp;<br>
$$ \nabla^2 u \quad\hbox{or}\quad \nabla\cdot\left( a(\x)\nabla u\right)
\thinspace .
$$
<p>&nbsp;<br>

with explicit 2D expressions
<p>&nbsp;<br>
$$ \nabla^2 u = \nabla\cdot\nabla u =
\frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2},
$$
<p>&nbsp;<br>

and
<p>&nbsp;<br>
$$
\nabla\cdot\left( a(\x)\nabla u\right) =
\frac{\partial}{\partial x}\left( a(x,y)\frac{\partial u}{\partial x}\right) +
\frac{\partial}{\partial y}\left( a(x,y)\frac{\partial u}{\partial y}\right)
\thinspace .
$$
<p>&nbsp;<br>


<p>
The general rule for integrating by parts is

<p>
<p>&nbsp;<br>
$$
\begin{equation}
-\int_{\Omega} \nabla\cdot (a(\x)\nabla u) v\dx =
\int_{\Omega} a(\x)\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} a\frac{\partial u}{\partial n} v \ds,
\tag{56}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \int_\Omega ()\dx \): area (2D) or volume (3D) integral</li>
 <p><li> \( \int_{\partial\Omega} ()\ds \): line(2D) or surface (3D) integral</li>
</ul>
<p>

Let us divide the boundary into two parts:

<p>

<ul>
 <p><li> \( \partial\Omega_N \), where we have Neumann conditions
   \( -a\frac{\partial u}{\partial n} = g \), and</li>
 <p><li> \( \partial\Omega_D \), where we have Dirichlet conditions
   \( u = u_0 \).</li>
</ul>
<p>

The test functions \( v \) are required to vanish on \( \partial\Omega_D \).

<h4>Example  <a name="___sec105"></a></h4>

<p>
A general and widely appearing PDE problem:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\v\cdot\nabla u + \alpha u &= \nabla\cdot\left( a\nabla u\right) + f,
\quad\x\in\Omega,\\ 
u &= u_0,\quad\x\in\partial\Omega_D,\\ 
-a\frac{\partial u}{\partial n} &= g,\quad\x\in\partial\Omega_N
\thinspace .
\end{align}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Known: \( a \), \( \alpha \), \( f \), \( u_0 \), and \( g \).</li>
 <p><li> Second-order PDE: must have <em>exactly one boundary condition at each
   point of the boundary</em></li>
 <p><li> \( \partial\Omega_N\cup\partial\Omega_D \) = entire boundary</li>
</ul>
<p>

The unknown function can be expanded as

<p>
<p>&nbsp;<br>
$$ u = u_0 + \sum_{j\in\If} c_j\basphi_j \thinspace .$$
<p>&nbsp;<br>


<p>
Galerkin's method: multiply by \( v\in V \) and integrate over \( \Omega \),

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
\int_{\Omega} \nabla\cdot\left( a\nabla u\right)\dx + \int_{\Omega}fv \dx
\thinspace .
$$
<p>&nbsp;<br>

Integrate second-order term by parts,

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} \nabla\cdot\left( a\nabla u\right) v \dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds,
$$
<p>&nbsp;<br>

resulting in

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
+ \int_{\Omega} fv \dx
\thinspace .
$$
<p>&nbsp;<br>

Note: \( v\neq 0 \) only on \( \partial\Omega_N \):
<p>&nbsp;<br>
$$ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
= \int_{\partial\Omega_N} a\frac{\partial u}{\partial n} v\ds,
$$
<p>&nbsp;<br>

Insert flux condition \( a\frac{\partial u}{\partial n}=-g \) on \( \partial\Omega_N \):
<p>&nbsp;<br>
$$
-\int_{\partial\Omega_N} gv\ds\thinspace .
$$
<p>&nbsp;<br>

The final variational form:

<p>
<p>&nbsp;<br>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v \dx
- \int_{\partial\Omega} g v\ds
+ \int_{\Omega} fv \dx
\thinspace .
$$
<p>&nbsp;<br>


<p>
With inner product notation:

<p>
<p>&nbsp;<br>
$$
(\v\cdot\nabla u, v) + (\alpha u,v) =
- (a\nabla u,\nabla v) - (g,v)_{N} + (f,v)
\thinspace .
$$
<p>&nbsp;<br>

\( (g,v)_{N} \): line or surface integral over \( \partial\Omega_N \).

<p>
Inserting the \( u \) expansion results in
a linear system with

<p>
<p>&nbsp;<br>
$$
A_{i,j} = (\v\cdot\nabla \basphi_j, \basphi_i) + (\alpha \basphi_j ,\basphi_i) + (a\nabla \basphi_j,\nabla \basphi_i)
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
b_i = (g,\basphi_i)_{N} + (f,\basphi_i) -
(\v\cdot\nabla u_0, \basphi_i) + (\alpha u_0 ,\basphi_i) +
(a\nabla u_0,\nabla \basphi_i),
$$
<p>&nbsp;<br>

<h3>Transformation to a reference cell in 2D and 3D  <a name="___sec106"></a></h3>

<p>
We consider an integral of the type

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{{\Omega}^{(e)}} a(\x)\nabla\basphi_i\cdot\nabla\basphi_j\dx
\end{equation}
$$
<p>&nbsp;<br>

in the physical domain.

<p>
Goal: integrate this term over the reference cell.

<p>
Mapping from reference to physical coordinates:

<p>
<p>&nbsp;<br>
$$ \x(\X), $$
<p>&nbsp;<br>

with Jacobian, \( J \), given by
<p>&nbsp;<br>
$$ J_{i,j}=\frac{\partial x_j}{\partial X_i}\thinspace .$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Step 1: \( \dx \rightarrow \det J\dX \).</li>
 <p><li> Step 2: express \( \nabla\basphi_i \) by an expression with \( \refphi_r \) (\( i=q(e,r) \))</li>
 <p><li> We want \( \nabla_{\x}\refphi_r(\X) \) (derivatives wrt \( \x \))</li>
 <p><li> What we readily have: \( \nabla_{\X}\refphi_r(\X) \) (derivative wrt \( \X \))</li>
 <p><li> Need to transform \( \nabla_{\X}\refphi_r(\X) \) to \( \nabla_{\x}\refphi_r(\X) \)</li>
</ul>
<p>

Can derive

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\nabla_{\X}\refphi_r &= J\cdot\nabla_{\x}\basphi_i,\\ 
\nabla_{\x}\basphi_i &= J^{-1}\cdot\nabla_{\X}\refphi_r\thinspace .
\end{align*}
$$
<p>&nbsp;<br>


<p>
Integral transformation from physical to reference coordinates:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_{\Omega}^{(e)} a(\x)\nabla_{\x}\basphi_i\cdot\nabla_{\x}\basphi_j\dx
\int_{\tilde\Omega^r} a(\x(\X))(J^{-1}\cdot\nabla_{\X}\refphi_r)\cdot
(J^{-1}\cdot\nabla\refphi_s)\det J\dX
\end{equation}
$$
<p>&nbsp;<br>

<h2>Systems of differential equations <a name="fem:sys"></a></h2>

<p>
Consider \( m+1 \) unknown functions: \( u^{(0)},\ldots, u^{(m)} \) governed
by \( m+1 \) differential equations:

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\mathcal{L}_0(u^{(0)},\ldots,u^{(m)}) &= 0,\\ 
&\vdots\\ 
\mathcal{L}_{m}(u^{(0)},\ldots,u^{(m)}) &= 0,
\end{align*}
$$
<p>&nbsp;<br>

<h3>Variational forms <a name="fem:sys:vform"></a></h3>

<p>

<ul>
 <p><li> First approach: treat each equation as a scalar equation</li>
 <p><li> For equation no. \( i \), use test function \( v^{(i)}\in V^{(i)} \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align}
\int_\Omega \mathcal{L}^{(0)}(u^{(0)},\ldots,u^{(m)}) v^{(0)}\dx &= 0,
\tag{57}\\ 
&\vdots\\ 
\int_\Omega \mathcal{L}^{(m)}(u^{(0)},\ldots,u^{(m)}) v^{(m)}\dx &= 0
\tag{58}
\thinspace .
\end{align}
$$
<p>&nbsp;<br>

Terms with second-order derivatives may be integrated by parts, with
Neumann conditions inserted in boundary integrals.

<p>
<p>&nbsp;<br>
$$ V^{(i)} = \hbox{span}\{\basphi_0^{(i)},\ldots,\basphi_{N_i}^{(i)}\},$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$ u^{(i)} = B^{(i)}(\x) + \sum_{j=0}^{N_i} c_j^{(i)} \basphi_j^{(i)}(\x),
$$
<p>&nbsp;<br>


<p>
Can derive \( m \) coupled linear systems for the unknowns
\( c_j^{(i)} \), \( j=0,\ldots,N_i \),
\( i=0,\ldots,m \).

<p>

<ul>
 <p><li> Second approach: work with vectors (and vector notation)</li>
 <p><li> \( \u = (u^{(0)},\ldots,u^{(m)}) \)</li>
 <p><li> \( \v = (u^{(0)},\ldots,u^{(m)}) \)</li>
 <p><li> \( \u, \v \in  \V = V^{(0)}\times \cdots \times V^{(m)} \)</li>
 <p><li> Note: if \( \boldsymbol{B} = (B^{(0)},\ldots,B^{(m)}) \) is needed for
   nonzero Dirichlet conditions, \( \u - \boldsymbol{B}\in \V \) (not \( \u \) in \( \V \))</li>
 <p><li> \( \boldsymbol{\mathcal{L}}(\u ) = 0 \)</li>
 <p><li> \( \boldsymbol{\mathcal{L}}(\u ) = (\mathcal{L}^{(0)}(\u),\ldots, \mathcal{L}^{(m)}(\u)) \)</li>
</ul>
<p>

The variational form is derived by taking the <em>inner product</em> of
\( \boldsymbol{\mathcal{L}}(\u ) \) and \( \v \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_\Omega \boldsymbol{\mathcal{L}}(\u )\cdot\v = 0\quad\forall\v\in\V\thinspace .
\tag{59}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Observe: this is a scalar equation (!).</li>
 <p><li> Can derive \( m \) independent equation by choosing \( m \) independent \( \v \)</li>
 <p><li> E.g.: \( \v = (v^{(0)},0,\ldots,0) \) recovers <a href="#mjx-eqn-57">(57)</a></li>
 <p><li> E.g.: \( \v = (0,\ldots,0,v^{(m)} \) recovers <a href="#mjx-eqn-58">(58)</a></li>
</ul>
<p>

<h3>A worked example <a name="fem:sys:uT:ex"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mu \nabla^2 w &= -\beta,
\tag{60}\\ 
\kappa\nabla^2 T &= - \mu ||\nabla w||^2 \quad (= \mu \nabla w\cdot\nabla w)
\thinspace .
\tag{61}
\end{align}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Unknowns: \( w(x,y) \), \( T(x,y) \)</li>
 <p><li> Known constants: \( \mu \), \( \beta \), \( \kappa \)</li>
 <p><li> Application: fluid flow in a straight pipe, \( w \) is velocity, \( T \) is
   temperature</li>
 <p><li> \( \Omega \): cross section of the pipe</li>
 <p><li> Boundary conditions: \( w=0 \) and \( T=T_0 \) on \( \partial\Omega \)</li>
 <p><li> Note: \( T \) depends on \( w \), but \( w \) does not depend on \( T \) (one-way coupling)</li>
</ul>
<p>

<h3>Identical function spaces for the unknowns  <a name="___sec110"></a></h3>

<p>
Let \( w, (T-T_0) \in V \) with test functions \( v\in V \).

<p>
<p>&nbsp;<br>
$$ V = \hbox{span}\{\basphi_0(x,y),\ldots,\basphi_N(x,y)\}, $$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
w = \sum_{j=0}^N c^{(w)}_j \basphi_j,\quad T = T_0 + \sum_{j=0}^N c^{(T)}_j
\basphi_j\thinspace .
\tag{62}
\end{equation}
$$
<p>&nbsp;<br>

<h4>Variational form of each individual PDE  <a name="___sec111"></a></h4>

<p>
Inserting <a href="#mjx-eqn-62">(62)</a>
in the PDEs, results in the residuals

<p>
<p>&nbsp;<br>
$$
\begin{align}
R_w &= \mu \nabla^2 w + \beta,
\tag{63}\\ 
R_T &= \kappa\nabla^2 T + \mu ||\nabla w||^2
\thinspace .
\tag{64}
\end{align}
$$
<p>&nbsp;<br>


<p>
Galerkin's method: make residual orthogonal to \( V \),

<p>
<p>&nbsp;<br>
$$
\begin{align*}
\int_\Omega R_w v \dx &=0\quad\forall v\in V,\\ 
\int_\Omega R_T v \dx &=0\quad\forall v\in V
\thinspace .
\end{align*}
$$
<p>&nbsp;<br>


<p>
Integrate by parts and use \( v=0 \) on \( \partial\Omega \) (Dirichlet conditions!):

<p>
<p>&nbsp;<br>
$$
\begin{align}
\int_\Omega \mu \nabla w\cdot\nabla v \dx &= \int_\Omega \beta v\dx
\quad\forall v\in V,
\tag{65}\\ 
\int_\Omega \kappa \nabla T\cdot\nabla v \dx &= \int_\Omega \mu
\nabla w\cdot\nabla w\, v\dx \quad\forall v\in V
\tag{66}
\thinspace .
\end{align}
$$
<p>&nbsp;<br>

<h4>Compound scalar variational form  <a name="___sec112"></a></h4>

<p>

<ul>
 <p><li> Test vector function \( \v\in\V = V\times V \)</li>
 <p><li> Take the inner product of \( \v \) and the system of PDEs (and integrate)</li>
</ul>
<p>

<p>&nbsp;<br>
$$ \int_{\Omega} (R_w, R_T)\cdot\v \dx = 0\quad\forall\v\in\V
\thinspace .$$
<p>&nbsp;<br>


<p>
With \( \v = (v_0,v_1) \):

<p>
<p>&nbsp;<br>
$$ \int_{\Omega} (R_w v_0 + R_T v_1) \dx = 0\quad\forall\v\in\V
\thinspace .$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_\Omega (\mu\nabla w\cdot\nabla v_0 + \kappa\nabla T\cdot\nabla v_1)\dx
= \int_\Omega (\beta v_0 + \mu\nabla w\cdot\nabla w\, v_1)\dx,
\quad\forall \v\in\V
\tag{67}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Choosing \( v_0=v \) and \( v_1=0 \) gives the variational form
<a href="#mjx-eqn-65">(65)</a>, while \( v_0=0 \) and \( v_1=v \) gives
<a href="#mjx-eqn-66">(66)</a>.

<p>
Alternative inner product notation:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mu (\nabla w,\nabla v) &= (\beta, v)
\quad\forall v\in V,
\tag{68}\\ 
\kappa(\nabla T,\nabla v) &= \mu(\nabla w\cdot\nabla w, v)\quad\forall v\in V
\tag{69}
\thinspace .
\end{align}
$$
<p>&nbsp;<br>

<h4>Decoupled linear systems  <a name="___sec113"></a></h4>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j=0}^N A^{(w)}_{i,j} c^{(w)}_j &= b_i^{(w)},\quad i=0,\ldots,N,
\tag{70}\\ 
\sum_{j=0}^N A^{(T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N,
\tag{71}\\ 
A^{(w)}_{i,j} &= \mu(\nabla \basphi_j,\nabla\basphi_i),\\ 
b_i^{(w)} &= (\beta, \basphi_i),\\ 
A^{(T)}_{i,j} &= \kappa(\nabla \basphi_j,\nabla\basphi_i),\\ 
b_i^{(T)} &= (\mu\nabla w_{-}\cdot (\sum_k
c^{(w)}_k\nabla\basphi_k), \basphi_i)
\thinspace .
\end{align}
$$
<p>&nbsp;<br>


<p>
Matrix-vector form (alternative notation):

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mu K c^{(w)} &= b^{(w)},\\ 
\kappa K c^{(T)} &= b^{(T)},
\end{align}
$$
<p>&nbsp;<br>

where

<p>
<p>&nbsp;<br>
$$
\begin{align*}
K_{i,j} &= (\nabla \basphi_j,\nabla \basphi_i),\\ 
b^{(w)} &= (b_0^{(w)},\ldots,b_{N}^{(w)}),\\ 
b^{(T)} &= (b_0^{(T)},\ldots,b_{N}^{(T)}),\\ 
c^{(w)} &= (c_0^{(w)},\ldots,c_{N}^{(w)}),\\ 
c^{(T)} &= (c_0^{(T)},\ldots,c_{N}^{(T)})\thinspace .
\end{align*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> First solve the system for \( c^{(w)} \)</li>
 <p><li> Then solve the system for \( c^{(T)} \)</li>
</ul>
<p>

<h4>Coupled linear systems  <a name="___sec114"></a></h4>

<p>

<ul>
 <p><li> Pretend two-way coupling, i.e., need to solve for \( w \) and \( T \) simultaneously</li>
 <p><li> Want to derive <em>one system</em> for \( c_j^{(w)} \) and \( c_j^{(T)} \), \( j=0,\ldots,N \)</li>
 <p><li> The system is nonlinear because of \( \nabla w\cdot\nabla w \)</li>
 <p><li> Linearization: pretend an iteration where \( \hat w \) is computed
   in the previous iteration and set \( \nabla w\cdot\nabla w
   \approx \nabla\hat w\cdot\nabla w \) (so the term becomes linear in \( w \))</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align}
\sum_{j=0}^N A^{(w,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^N A^{(w,T)}_{i,j} c^{(T)}_j
&= b_i^{(w)},\quad i=0,\ldots,N,
\tag{72}\\ 
\sum_{j=0}^N A^{(T,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^N A^{(T,T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N,
\tag{73}\\ 
A^{(w,w)}_{i,j} &= \mu(\nabla \basphi_j,\basphi_i),\\ 
A^{(w,T)}_{i,j} &= 0,\\ 
b_i^{(w)} &= (\beta, \basphi_i),\\ 
A^{(w,T)}_{i,j} &= \mu(\nabla w_{-}\cdot\nabla\basphi_j), \basphi_i),\\ 
A^{(T,T)}_{i,j} &= \kappa(\nabla \basphi_j,\basphi_i),\\ 
b_i^{(T)} &= 0
\thinspace .
\end{align}
$$
<p>&nbsp;<br>


<p>
Alternative notation:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\mu K c^{(w)} &= b^{(w)},\\ 
L c^{(w)} + \kappa K c^{(T)} & =0,
\end{align}
$$
<p>&nbsp;<br>

\( L \) is the matrix from the \( \nabla w_{-}\cdot\nabla \) operator:
\( L_{i,j} = A^{(w,T)}_{i,j} \).

<p>
Corresponding block form:

<p>
<p>&nbsp;<br>
$$
\left(\begin{array}{cc}
\mu K & 0\\ 
L & \kappa K
\end{array}\right)
\left(\begin{array}{c}
c^{(w)}\\ 
c^{(T)}
\end{array}\right) =
\left(\begin{array}{c}
b^{(w)}\\ 
0
\end{array}\right)
\thinspace .
$$
<p>&nbsp;<br>

<h3>Different function spaces for the unknowns  <a name="___sec115"></a></h3>

<p>

<ul>
 <p><li> Generalization: \( w\in V^{(w)} \) and \( T\in V^{(T)} \),
   \( V^{(w)} \neq V^{(T)} \)</li>
 <p><li> This is called a <em>mixed finite element method</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align*}
V^{(w)} &= \hbox{span}\{\basphi_0^{(w)},\ldots,\basphi_{N_w}^{(w)}\},\\ 
V^{(T)} &= \hbox{span}\{\basphi_0^{(T)},\ldots,\basphi_{N_T}^{(T)}\}
\thinspace .
\end{align*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align}
\int_\Omega \mu \nabla w\cdot\nabla v^{(w)} \dx &= \int_\Omega \beta v^{(w)}\dx
\quad\forall v^{(w)}\in V^{(w)},
\tag{74}\\ 
\int_\Omega \kappa \nabla T\cdot\nabla v^{(T)} \dx &= \int_\Omega \mu
\nabla w\cdot\nabla w\, v^{(T)}\dx \quad\forall v^{(T)}\in V^{(T)}
\tag{75}
\thinspace .
\end{align}
$$
<p>&nbsp;<br>


<p>
Take the inner product with \( \v = (v^{(w)}, v^{(T)}) \) and integrate:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\int_\Omega (\mu\nabla w\cdot\nabla v^{(w)} +
\kappa\nabla T\cdot\nabla v^{(T)})\dx
= \int_\Omega (\beta v^{(w)} + \mu\nabla w\cdot\nabla w\, v^{(T)})\dx,
\tag{76}
\end{equation}
$$
<p>&nbsp;<br>

valid \( \forall \v\in\V = V^{(w)}\times V^{(T)} \).


</section>



<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>
-->

<!-- deck.goto snippet
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>
-->

<!-- deck.hash snippet
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>
-->

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery-1.7.2.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/notes/deck.notes.js"></script>

<!-- From https://github.com/mikeharris100/deck.pointer.js -->
<script src="deck.js/extensions/pointer/deck.pointer.js"></script>

<!-- From https://github.com/stvnwrgs/presenterview -->
<script type="text/javascript" src="deck.js/extensions/presenterview/deck.presenterview.js"></script>

<!-- From https://github.com/nemec/deck.annotate.js
<script type="text/javascript" src="deck.js/extensions/deck.annotate.js/deck.annotate.js"></script>
-->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>


</body>
</html>
