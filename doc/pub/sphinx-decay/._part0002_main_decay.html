

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementation (1) &mdash; Introduction to computing with finite difference methods</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Introduction to computing with finite difference methods" href="index.html" />
    <link rel="next" title="Software engineering" href="._part0003_main_decay.html" />
    <link rel="prev" title="Finite difference methods" href="._part0001_main_decay.html" />
 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._part0003_main_decay.html" title="Software engineering"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._part0001_main_decay.html" title="Finite difference methods"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Introduction to computing with finite difference methods</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="implementation-1">
<span id="decay-impl1"></span><h1>Implementation  (1)<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h1>
<div class="admonition-goal admonition">
<p class="first admonition-title">Goal</p>
<p>We want make a computer program for solving</p>
<div class="math">
\[u'(t) = -au(t),\quad t\in (0,T], \quad u(0)=I,\]</div>
<p class="last">by finite difference methods. The program should also display
the numerical solution as a curve on the
screen, preferably together with the
exact solution. We shall also be concerned with program testing,
user interfaces, and computing convergence rates.</p>
</div>
<span class="target" id="index-0"></span><p id="index-1">All programs referred to in this section are found in the
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay">src/decay</a> directory (we use the classical
Unix term <em>directory</em> for what many others nowadays call <em>folder</em>).</p>
<p><em>Mathematical problem.</em> We want to explore the Forward Euler scheme, the
Backward Euler, and the Crank-Nicolson schemes applied to our model problem.
From an implementational point of view, it is advantageous to
implement the <span class="math">\(\theta\)</span>-rule</p>
<div class="math">
\[u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,\]</div>
<p>since it can generate the three other schemes by various of
choices of <span class="math">\(\theta\)</span>: <span class="math">\(\theta=0\)</span> for Forward Euler, <span class="math">\(\theta =1\)</span> for
Backward Euler, and <span class="math">\(\theta =1/2\)</span> for Crank-Nicolson.
Given <span class="math">\(a\)</span>, <span class="math">\(u^0=I\)</span>, <span class="math">\(T\)</span>, and <span class="math">\(\Delta t\)</span>,
our task is to use the <span class="math">\(\theta\)</span>-rule to
compute <span class="math">\(u^1, u^2,\ldots,u^{N_t}\)</span>, where <span class="math">\(t_{N_t}=N_t\Delta t\)</span>, and
<span class="math">\(N_t\)</span> the closest integer to <span class="math">\(T/\Delta t\)</span>.</p>
<p><em>Computer Language: Python.</em> Any programming language can be used to generate the <span class="math">\(u^{n+1}\)</span> values from
the formula above. However, in this document we shall mainly make use of
Python of several reasons:</p>
<blockquote>
<div><ul class="simple">
<li>Python has a very clean, readable syntax (often known as
&#8220;executable pseudo-code&#8221;).</li>
<li>Python code is very similar to MATLAB code (and MATLAB has a
particularly widespread use for scientific computing).</li>
<li>Python is a full-fledged, very powerful programming language.</li>
<li>Python is similar to, but much simpler to work with and
results in more reliable code than C++.</li>
<li>Python has a rich set of modules for scientific computing, and its
popularity in scientific computing is rapidly growing.</li>
<li>Python was made for being combined with compiled languages
(C, C++, Fortran) to reuse existing numerical software and to
reach high computational performance of new implementations.</li>
<li>Python has extensive support for administrative task
needed when doing large-scale computational investigations.</li>
<li>Python has extensive support for graphics (visualization,
user interfaces, web applications).</li>
<li>FEniCS, a very powerful tool for solving PDEs by
the finite element method, is most human-efficient to operate
from Python.</li>
</ul>
</div></blockquote>
<p>Learning Python is easy. Many newcomers to the language will probably
learn enough from the forthcoming examples to perform their own computer
experiments. The examples start with simple Python code and gradually
make use of more powerful constructs as we proceed. As long as it is
not inconvenient for the problem at hand, our Python code is made as
close as possible to MATLAB code for easy transition between the two
languages.</p>
<p>Readers who feel the Python examples are too hard to follow will probably
benefit from read a tutorial, e.g.,</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://docs.python.org/2/tutorial/">The Official Python Tutorial</a></li>
<li><a class="reference external" href="http://www.tutorialspoint.com/python/">Python Tutorial on tutorialspoint.com</a></li>
<li><a class="reference external" href="http://www.learnpython.org/">Interactive Python tutorial site</a></li>
<li><a class="reference external" href="http://en.wikibooks.org/wiki/A_Beginner's_Python_Tutorial">A Beginner&#8217;s Python Tutorial</a></li>
</ul>
</div></blockquote>
<p>The author also has a book <a class="reference internal" href="._part0009_main_decay.html#ref1">[Ref1]</a> that introduces
scientific programming with Python.</p>
<div class="section" id="making-a-solver-function">
<span id="decay-py1"></span><h2>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h2>
<p>We choose to have an array <tt class="docutils literal"><span class="pre">u</span></tt> for storing the <span class="math">\(u^n\)</span> values, <span class="math">\(n=0,1,\ldots,N_t\)</span>.
The algorithmic steps are</p>
<blockquote>
<div><ol class="arabic simple">
<li>initialize <span class="math">\(u^0\)</span></li>
<li>for <span class="math">\(t=t_n\)</span>, <span class="math">\(n=1,2,\ldots,N_t\)</span>: compute <span class="math">\(u_n\)</span> using
the <span class="math">\(\theta\)</span>-rule formula</li>
</ol>
</div></blockquote>
<div class="section" id="function-for-computing-the-numerical-solution">
<h3>Function for computing the numerical solution<a class="headerlink" href="#function-for-computing-the-numerical-solution" title="Permalink to this headline">¶</a></h3>
<p>The following Python function takes the input data of the problem
(<span class="math">\(I\)</span>, <span class="math">\(a\)</span>, <span class="math">\(T\)</span>, <span class="math">\(\Delta t\)</span>, <span class="math">\(\theta\)</span>) as arguments and returns two arrays with
the solution <span class="math">\(u^0,\ldots,u^{N_t}\)</span> and the mesh points <span class="math">\(t_0,\ldots,t_{N_t}\)</span>,
respectively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>            <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                  <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>    <span class="c"># n=0,1,...,Nt-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">numpy</span></tt> library contains a lot of functions for array computing. Most
of the function names are similar to what is found
in the alternative scientific computing language MATLAB. Here
we make use of</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">zeros(Nt+1)</span></tt> for creating an array of a size <tt class="docutils literal"><span class="pre">Nt+1</span></tt>
and initializing the elements to zero</li>
<li><tt class="docutils literal"><span class="pre">linspace(0,</span> <span class="pre">T,</span> <span class="pre">Nt+1)</span></tt> for creating an array with <tt class="docutils literal"><span class="pre">Nt+1</span></tt> coordinates uniformly
distributed between <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">T</span></tt></li>
</ul>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">for</span></tt> loop deserves a comment, especially for newcomers to Python.
The construction <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">Nt,</span> <span class="pre">s)</span></tt> generates all integers from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">Nt</span></tt>
in steps of <tt class="docutils literal"><span class="pre">s</span></tt>, <em>but not including</em> <tt class="docutils literal"><span class="pre">Nt</span></tt>. Omitting <tt class="docutils literal"><span class="pre">s</span></tt> means <tt class="docutils literal"><span class="pre">s=1</span></tt>.
For example, <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">6,</span> <span class="pre">3)</span></tt>
gives <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt>, while <tt class="docutils literal"><span class="pre">range(0,</span> <span class="pre">Nt)</span></tt> generates <tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">1</span></tt>, ..., <tt class="docutils literal"><span class="pre">Nt-1</span></tt>.
Our loop implies the following assignments to <tt class="docutils literal"><span class="pre">u[n+1]</span></tt>: <tt class="docutils literal"><span class="pre">u[1]</span></tt>, <tt class="docutils literal"><span class="pre">u[2]</span></tt>, ...,
<tt class="docutils literal"><span class="pre">u[Nt]</span></tt>, which is what we want since <tt class="docutils literal"><span class="pre">u</span></tt> has length <tt class="docutils literal"><span class="pre">Nt+1</span></tt>.
The first index in Python arrays or lists is <em>always</em> <tt class="docutils literal"><span class="pre">0</span></tt> and the
last is then <tt class="docutils literal"><span class="pre">len(u)-1</span></tt>. The length of an array <tt class="docutils literal"><span class="pre">u</span></tt> is obtained by
<tt class="docutils literal"><span class="pre">len(u)</span></tt> or <tt class="docutils literal"><span class="pre">u.size</span></tt>.</p>
<p>To compute with the <tt class="docutils literal"><span class="pre">solver</span></tt> function, we need to <em>call</em> it. Here
is a sample call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="integer-division">
<h3>Integer division<a class="headerlink" href="#integer-division" title="Permalink to this headline">¶</a></h3>
<p>The shown implementation of the <tt class="docutils literal"><span class="pre">solver</span></tt> may face problems and
wrong results if <tt class="docutils literal"><span class="pre">T</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">dt</span></tt>, and <tt class="docutils literal"><span class="pre">theta</span></tt> are given as integers,
see <a class="reference internal" href="._part0005_main_decay.html#decay-exer-intdiv"><em>Exercise 4: Experiment with integer division</em></a> and <a class="reference internal" href="._part0005_main_decay.html#decay-exer-decay1err"><em>Exercise 5: Experiment with wrong computations</em></a>.
The problem is related to <em>integer division</em> in Python (as well as
in Fortran, C, C++, and many other computer languages): <tt class="docutils literal"><span class="pre">1/2</span></tt> becomes <tt class="docutils literal"><span class="pre">0</span></tt>,
while <tt class="docutils literal"><span class="pre">1.0/2</span></tt>, <tt class="docutils literal"><span class="pre">1/2.0</span></tt>, or <tt class="docutils literal"><span class="pre">1.0/2.0</span></tt> all become <tt class="docutils literal"><span class="pre">0.5</span></tt>. It is enough
that at least the nominator or the denominator is a real number
(i.e., a <tt class="docutils literal"><span class="pre">float</span></tt> object)
to ensure correct mathematical division. Inserting
a conversion <tt class="docutils literal"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">float(dt)</span></tt>
guarantees that <tt class="docutils literal"><span class="pre">dt</span></tt> is
<tt class="docutils literal"><span class="pre">float</span></tt> and avoids problems in <a class="reference internal" href="._part0005_main_decay.html#decay-exer-decay1err"><em>Exercise 5: Experiment with wrong computations</em></a>.</p>
<p>Another problem with computing <span class="math">\(N_t=T/\Delta t\)</span> is that we should
round <span class="math">\(N_t\)</span> to the nearest integer. With <tt class="docutils literal"><span class="pre">Nt</span> <span class="pre">=</span> <span class="pre">int(T/dt)</span></tt> the <tt class="docutils literal"><span class="pre">int</span></tt>
operation picks the largest integer smaller than <tt class="docutils literal"><span class="pre">T/dt</span></tt>. Correct
mathematical rounding as known from school is obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
<p>The complete version of our improved, safer <tt class="docutils literal"><span class="pre">solver</span></tt> function then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>            <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>     <span class="c"># no of time intervals</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>                 <span class="c"># adjust T to fit time step dt</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># array of u[n] values</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># time mesh</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>                  <span class="c"># assign initial condition</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>    <span class="c"># n=0,1,...,Nt-1</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
<div class="section" id="doc-strings">
<h3>Doc strings<a class="headerlink" href="#doc-strings" title="Permalink to this headline">¶</a></h3>
<p id="index-2">Right below the header line in the <tt class="docutils literal"><span class="pre">solver</span></tt> function there is a
Python string enclosed in triple double quotes <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt>.
The purpose of this string object is to document what the function
does and what the arguments are. In this case the necessary
documentation do not span more than one line, but with triple double
quoted strings the text may span several lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve</span>

<span class="sd">        u&#39;(t) = -a*u(t),</span>

<span class="sd">    with initial condition u(0)=I, for t in the time interval</span>
<span class="sd">    (0,T]. The time interval is divided into time steps of</span>
<span class="sd">    length dt.</span>

<span class="sd">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span class="sd">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span class="sd">    Nicolson method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Such documentation strings appearing right after the header of
a function are called <em>doc strings</em>. There are tools that can automatically
produce nicely formatted documentation by extracting the definition of
functions and the contents of doc strings.</p>
<p>It is strongly recommended to equip any function whose purpose
is not obvious with a doc string. Nevertheless, the forthcoming
text deviates from this rule if the function is explained in the text.</p>
</div>
<div class="section" id="formatting-of-numbers">
<h3>Formatting of numbers<a class="headerlink" href="#formatting-of-numbers" title="Permalink to this headline">¶</a></h3>
<p>Having computed the discrete solution <tt class="docutils literal"><span class="pre">u</span></tt>, it is natural to look at
the numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Write out a table of t and u values:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>This compact <tt class="docutils literal"><span class="pre">print</span></tt> statement gives unfortunately quite ugly output
because the <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> values are not aligned in nicely formatted columns.
To fix this problem, we recommend to use the <em>printf format</em>, supported most
programming languages inherited from C. Another choice is
Python&#8217;s recent <em>format string syntax</em>.</p>
<p id="index-3">Writing <tt class="docutils literal"><span class="pre">t[i]</span></tt> and <tt class="docutils literal"><span class="pre">u[i]</span></tt> in two nicely formatted columns is done like
this with the printf format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s"> u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>The percentage signs signify &#8220;slots&#8221; in the text where the variables
listed at the end of the statement are inserted. For each &#8220;slot&#8221; one
must specify a format for how the variable is going to appear in the
string: <tt class="docutils literal"><span class="pre">s</span></tt> for pure text, <tt class="docutils literal"><span class="pre">d</span></tt> for an integer, <tt class="docutils literal"><span class="pre">g</span></tt> for a real number
written as compactly as possible, <tt class="docutils literal"><span class="pre">9.3E</span></tt> for scientific notation with
three decimals in a field of width 9 characters (e.g., <tt class="docutils literal"><span class="pre">-1.351E-2</span></tt>),
or <tt class="docutils literal"><span class="pre">.2f</span></tt> for standard decimal notation with two decimals
formatted with minimum width. The printf syntax provides a quick way
of formatting tabular output of numbers with full control of the
layout.</p>
<p id="index-4">The alternative <em>format string syntax</em> looks like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;t={t:6.3f} u={u:g}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>As seen, this format allows logical names in the &#8220;slots&#8221; where
<tt class="docutils literal"><span class="pre">t[i]</span></tt> and <tt class="docutils literal"><span class="pre">u[i]</span></tt> are to be inserted. The &#8220;slots&#8221; are surrounded
by curly braces, and the logical name is followed by a colon and
then the printf-like specification of how to format real numbers,
integers, or strings.</p>
</div>
<div class="section" id="running-the-program">
<h3>Running the program<a class="headerlink" href="#running-the-program" title="Permalink to this headline">¶</a></h3>
<p>The function and main program shown above must be placed in a file,
say with name <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_v1.py">decay_v1.py</a> (<tt class="docutils literal"><span class="pre">v1</span></tt> stands for &#8220;version 1&#8221; - we shall make
numerous different versions of this program).  Make sure you
write the code with a suitable text editor (Gedit, Emacs, Vim,
Notepad++, or similar).  The program is run by executing the file this
way:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay_v1.py</span>
</pre></div>
</div>
<p>The text <tt class="docutils literal"><span class="pre">Terminal&gt;</span></tt> just indicates a prompt in a
Unix/Linux or DOS terminal window. After this prompt, which will look
different in your terminal window, depending on the terminal application
and how it is set up, commands like <tt class="docutils literal"><span class="pre">python</span> <span class="pre">decay_v1.py</span></tt> can be issued.
These commands are interpreted by the operating system.</p>
<p>We strongly recommend to run Python programs within the IPython shell.
First start IPython by typing <tt class="docutils literal"><span class="pre">ipython</span></tt> in the terminal window.
Inside the IPython shell, our program <tt class="docutils literal"><span class="pre">decay_v1.py</span></tt> is run by the command
<tt class="docutils literal"><span class="pre">run</span> <span class="pre">decay_v1.py</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; ipython</span>

<span class="go">In [1]: run decay_v1.py</span>
<span class="go">t= 0.000 u=1</span>
<span class="go">t= 0.800 u=0.384615</span>
<span class="go">t= 1.600 u=0.147929</span>
<span class="go">t= 2.400 u=0.0568958</span>
<span class="go">t= 3.200 u=0.021883</span>
<span class="go">t= 4.000 u=0.00841653</span>
<span class="go">t= 4.800 u=0.00323713</span>
<span class="go">t= 5.600 u=0.00124505</span>
<span class="go">t= 6.400 u=0.000478865</span>
<span class="go">t= 7.200 u=0.000184179</span>
<span class="go">t= 8.000 u=7.0838e-05</span>

<span class="go">In [2]:</span>
</pre></div>
</div>
<p>The advantage of running programs in IPython are many: previous commands
are easily recalled with the up arrow, <tt class="docutils literal"><span class="pre">%pdb</span></tt> turns on debugging so that
variables can be examined if the program
aborts due to an exception, output of commands are stored in variables,
programs and statements can be profiled,
any operating system command can be executed, modules can be loaded
automatically and other customizations can be performed when starting
IPython &#8211; to mention a few of the most
useful features.</p>
<p>Although running programs in IPython is strongly recommended, most
execution examples in the forthcoming text use the standard
Python shell with prompt <tt class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></tt> and run programs through
a typesetting like</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python programname</span>
</pre></div>
</div>
<p>The reason is that such typesetting
makes the text more compact in the vertical direction
than showing sessions with IPython syntax.</p>
</div>
</div>
<div class="section" id="verifying-the-implementation">
<h2>Verifying the implementation<a class="headerlink" href="#verifying-the-implementation" title="Permalink to this headline">¶</a></h2>
<p>It is easy to make mistakes while deriving and implementing numerical
algorithms, so we should never believe in the printed <span class="math">\(u\)</span> values before
they have been thoroughly verified. The most obvious idea is to compare
the computed solution with the exact solution, when that exists,
but there will always be a discrepancy between these two solutions
because of the numerical approximations. The challenging question is whether
we have the mathematically correct discrepancy or if we have another,
maybe small, discrepancy due to both an approximation error
and an error in the implementation.</p>
<p>The purpose of <em>verifying</em> a program is to bring evidence for the
property that there are no errors in the implementation. To avoid
mixing unavoidable approximation errors and undesired
implementation errors, we should
try to make tests where we have some exact computation of the
discrete solution or at least parts of it.
Examples will show how this can be done.</p>
<div class="section" id="running-a-few-algorithmic-steps-by-hand">
<h3>Running a few algorithmic steps by hand<a class="headerlink" href="#running-a-few-algorithmic-steps-by-hand" title="Permalink to this headline">¶</a></h3>
<p>The simplest approach to produce a correct reference for the discrete
solution <span class="math">\(u\)</span> of finite difference equations is to compute a few
steps of the algorithm by hand. Then we can compare the hand
calculations with numbers produced by the program.</p>
<p>A straightforward approach is to use a calculator and
compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>. With <span class="math">\(I=0.1\)</span>, <span class="math">\(\theta=0.8\)</span>,
and <span class="math">\(\Delta t =0.8\)</span> we get</p>
<div class="math">
\[A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035\]</div>
<div class="math">
\[\begin{split}u^1 &amp;= AI=0.0298245614035,\\
u^2 &amp;= Au^1= 0.00889504462912,\\
u^3 &amp;=Au^2= 0.00265290804728\end{split}\]</div>
<p>Comparison of these manual calculations with the result of the
<tt class="docutils literal"><span class="pre">solver</span></tt> function is carried out in the function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_three_steps</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compare three steps with known manual computations.&quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">I</span><span class="p">,</span>
                       <span class="mf">0.0298245614035</span><span class="p">,</span>
                       <span class="mf">0.00889504462912</span><span class="p">,</span>
                       <span class="mf">0.00265290804728</span><span class="p">])</span>

    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># number of time steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>  <span class="c"># tolerance for comparing floats</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_by_hand</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="k">return</span> <span class="n">success</span>
</pre></div>
</div>
<p>The main program, where we call the <tt class="docutils literal"><span class="pre">solver</span></tt> function and print <tt class="docutils literal"><span class="pre">u</span></tt>,
is now put in a separate function <tt class="docutils literal"><span class="pre">main</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Write out a table of t and u values:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="k">print</span> <span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s"> u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c"># or print &#39;t={t:6.3f} u={u:g}&#39;.format(t=t[i], u=u[i])</span>
</pre></div>
</div>
<p>The main program in the file may now first run the verification test
and then go on with the real simulation (<tt class="docutils literal"><span class="pre">main()</span></tt>) only if the test is passed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">verify_three_steps</span><span class="p">():</span>
    <span class="n">main</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;Bug in the implementation!&#39;</span>
</pre></div>
</div>
<p>Since the verification test is always done, future errors introduced
accidentally in the program have a good chance of being detected.</p>
<div class="admonition-caution-choice-of-parameter-values admonition">
<p class="first admonition-title">Caution: choice of parameter values</p>
<p class="last">For the choice of values of parameters in verification tests one should
stay away from integers, especially 0 and 1, as these can
simplify formulas too much for test purposes. For example, with
<span class="math">\(\theta =1\)</span> the nominator in the formula for <span class="math">\(u^n\)</span> will be the same for
all <span class="math">\(a\)</span> and <span class="math">\(\Delta t\)</span> values. One should therefore choose more
&#8220;arbitrary&#8221; values, say <span class="math">\(\theta =0.8\)</span> and <span class="math">\(I=0.1\)</span>.</p>
</div>
<p>It is essential that verification tests can be automatically run
at <em>any</em> time. For this purpose,
there are test frameworks and corresponding programming
rules that allow us to request running through a suite of test cases
(see the section <a class="reference internal" href="._part0003_main_decay.html#decay-prog-se-nose"><em>Unit testing with nose</em></a>),
but in this very early stage of program development we just implement
and run the verification in our own code so that every detail is
visible and understood.</p>
<p>The complete program including the <tt class="docutils literal"><span class="pre">verify_three_steps*</span></tt> functions is
found in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_verf1.py">decay_verf1.py</a> (<tt class="docutils literal"><span class="pre">verf1</span></tt> is a short name for &#8220;verification,
version 1&#8221;).</p>
</div>
<div class="section" id="comparison-with-an-exact-discrete-solution">
<h3>Comparison with an exact discrete solution<a class="headerlink" href="#comparison-with-an-exact-discrete-solution" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is possible to find a closed-form
<em>exact discrete solution</em> that fulfills the discrete finite
difference equations. The implementation can then be verified against
the exact discrete solution. This is usually the best technique for
verification.</p>
<p>Define</p>
<div class="math">
\[A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}{\thinspace .}\]</div>
<p>Manual computations with the <span class="math">\(\theta\)</span>-rule results in</p>
<div class="math">
\[\begin{split}u^0 &amp;= I,\\
u^1 &amp;= Au^0 = AI,\\
u^2 &amp;= Au^1 = A^2I,\\
&amp;\vdots\\
u^n &amp;= A^nu^{n-1} = A^nI {\thinspace .}\end{split}\]</div>
<p>We have then established the exact discrete solution as</p>
<div class="math" id="equation-decay:un:exact">
<span id="eq-decay-un-exact"></span><span class="eqno">(1)</span>\[     u^n = IA^n\]\[     {\thinspace .}\]</div>
<div class="admonition-caution admonition">
<p class="first admonition-title">Caution</p>
<p class="last">One should be conscious about the different meanings of the notation
on the left- and right-hand side
of <a href="#equation-decay:un:exact">(1)</a>: on the left, <span class="math">\(n\)</span> in <span class="math">\(u^n\)</span>
is a superscript reflecting a counter
of mesh points (<span class="math">\(t_n\)</span>), while on the right, <span class="math">\(n\)</span>
is the power in the exponentiation <span class="math">\(A^n\)</span>.</p>
</div>
<p>Comparison of the exact discrete solution and the computed
solution is done in the following function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_exact_discrete_solution</span><span class="p">():</span>

    <span class="k">def</span> <span class="nf">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">A</span><span class="o">**</span><span class="n">n</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># no of steps</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">u_de</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">exact_discrete_solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="n">difference</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_de</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c"># max deviation</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>  <span class="c"># tolerance for comparing floats</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="k">return</span> <span class="n">success</span>
</pre></div>
</div>
<p>The complete program is found in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_verf2.py">decay_verf2.py</a> (<tt class="docutils literal"><span class="pre">verf2</span></tt> is a short name for &#8220;verification,
version 2&#8221;).</p>
<div class="admonition-local-functions admonition">
<p class="first admonition-title">Local functions</p>
<p class="last">One can define a function inside another function, here called
a <em>local function</em> (also known as <em>closure</em>) inside a <em>parent function</em>.
A local function is invisible outside the parent function.
A convenient property is that any local function has access to all
variables defined in the parent function, also if we send the
local function to some other function as argument (!).
In the present example, it means that the local function
<tt class="docutils literal"><span class="pre">exact_discrete_solution</span></tt> does not need its five arguments as the
values can alternatively be accessed through the local variables defined
in the parent function <tt class="docutils literal"><span class="pre">verify_exact_discrete_solution</span></tt>. We can send
such an <tt class="docutils literal"><span class="pre">exact_discrete_solution</span></tt> without arguments to any other
function and <tt class="docutils literal"><span class="pre">exact_discrete_solution</span></tt> will still have access to
<tt class="docutils literal"><span class="pre">n</span></tt>, <tt class="docutils literal"><span class="pre">I</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt>, and so forth defined in its parent function.</p>
</div>
</div>
</div>
<div class="section" id="computing-the-numerical-error-as-a-mesh-function">
<span id="decay-computing-error"></span><h2>Computing the numerical error as a mesh function<a class="headerlink" href="#computing-the-numerical-error-as-a-mesh-function" title="Permalink to this headline">¶</a></h2>
<p>Now that we have evidence for a correct implementation, we are in a
position to compare the computed <span class="math">\(u^n\)</span> values in the <tt class="docutils literal"><span class="pre">u</span></tt> array with
the exact <span class="math">\(u\)</span> values at the mesh points, in order to study the error
in the numerical solution.</p>
<p>Let us first make a function for the analytical solution <span class="math">\({u_{\small\mbox{e}}}(t)=Ie^{-at}\)</span>
of the model problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-5">A natural way to compare the exact and discrete solutions is to
calculate their difference as a mesh function:</p>
<div class="math">
\[e^n = {u_{\small\mbox{e}}}(t_n) - u^n,\quad n=0,1,\ldots,N_t {\thinspace .}\]</div>
<p>We may view <span class="math">\({u_{\small\mbox{e}}}^n = {u_{\small\mbox{e}}}(t_n)\)</span> as the representation of <span class="math">\({u_{\small\mbox{e}}}(t)\)</span>
as a mesh function rather than a continuous function defined for all
<span class="math">\(t\in [0,T]\)</span> (<span class="math">\({u_{\small\mbox{e}}}^n\)</span> is often called the <em>representative</em> of
<span class="math">\({u_{\small\mbox{e}}}\)</span> on the mesh). Then, <span class="math">\(e^n = {u_{\small\mbox{e}}}^n - u^n\)</span> is clearly
the difference of two mesh functions. This interpretation of <span class="math">\(e^n\)</span>
is natural when programming.</p>
<p>The error mesh function <span class="math">\(e^n\)</span> can be computed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>  <span class="c"># Numerical sol.</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>      <span class="c"># Representative of exact sol.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
</pre></div>
</div>
<p>Note that the mesh functions <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">u_e</span></tt> are represented by arrays
and associated with the points in the array <tt class="docutils literal"><span class="pre">t</span></tt>.</p>
<span class="target" id="index-6"></span><div class="admonition-array-arithmetics admonition" id="index-7">
<p class="first admonition-title">Array arithmetics</p>
<p>The last statements</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
</pre></div>
</div>
<p class="last">are primary examples of array arithmetics: <tt class="docutils literal"><span class="pre">t</span></tt> is an
array of mesh points that we pass to <tt class="docutils literal"><span class="pre">exact_solution</span></tt>. This function
evaluates <tt class="docutils literal"><span class="pre">-a*t</span></tt>, which is a scalar times an array, meaning that
the scalar is multiplied with each array element.
The result is an array, let us call it <tt class="docutils literal"><span class="pre">tmp1</span></tt>. Then
<tt class="docutils literal"><span class="pre">exp(tmp1)</span></tt> means applying the exponential function to each element in
<tt class="docutils literal"><span class="pre">tmp</span></tt>, resulting an array, say <tt class="docutils literal"><span class="pre">tmp2</span></tt>. Finally, <tt class="docutils literal"><span class="pre">I*tmp2</span></tt> is computed
(scalar times array) and <tt class="docutils literal"><span class="pre">u_e</span></tt> refers to this array returned from
<tt class="docutils literal"><span class="pre">exact_solution</span></tt>. The expression <tt class="docutils literal"><span class="pre">u_e</span> <span class="pre">-</span> <span class="pre">u</span></tt> is the difference between
two arrays, resulting in a new array referred to by <tt class="docutils literal"><span class="pre">e</span></tt>.</p>
</div>
</div>
<div class="section" id="computing-the-norm-of-the-numerical-error">
<span id="decay-computing-error-norm"></span><h2>Computing the norm of the numerical error<a class="headerlink" href="#computing-the-norm-of-the-numerical-error" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-8"></span><p id="index-9">Instead of working with the error <span class="math">\(e^n\)</span> on the entire mesh, we
often want one number expressing the size of the error.
This is obtained by taking the norm of the error function.</p>
<p>Let us first define norms of a function <span class="math">\(f(t)\)</span>
defined for all <span class="math">\(t\in [0,T]\)</span>.
Three common norms are</p>
<div class="math" id="equation-decay:norms:L2">
<span id="eq-decay-norms-l2"></span><span class="eqno">(2)</span>\[     ||f||_{L^2} = \left( \int_0^T f(t)^2 dt\right)^{1/2},\]</div>
<div class="math" id="equation-decay:norms:L1">
<span id="eq-decay-norms-l1"></span><span class="eqno">(3)</span>\[     ||f||_{L^1} = \int_0^T |f(t)| dt,\]</div>
<div class="math" id="equation-decay:norms:Linf">
<span id="eq-decay-norms-linf"></span><span class="eqno">(4)</span>\[     ||f||_{L^\infty} = \max_{t\in [0,T]}|f(t)|{\thinspace .}\]</div>
<p>The <span class="math">\(L^2\)</span> norm <a href="#equation-decay:norms:L2">(2)</a> (&#8220;L-two norm&#8221;)
has nice mathematical properties and
is the most popular norm. It is a generalization
of the well-known Eucledian norm of vectors to functions.
The <span class="math">\(L^\infty\)</span> is also called the max norm or the supremum norm.
In fact, there is a whole family of norms,</p>
<div class="math">
\[||f||_{L^p} = \left(\int_0^T f(t)^pdt\right)^{1/p},\]</div>
<p>with <span class="math">\(p\)</span> real. In particular,
<span class="math">\(p=1\)</span> corresponds to the <span class="math">\(L^1\)</span> norm above while <span class="math">\(p=\infty\)</span> is the
<span class="math">\(L^\infty\)</span> norm.</p>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><p id="index-12">Numerical computations involving mesh functions need corresponding norms.
Given a set of function values, <span class="math">\(f^n\)</span>, and some associated mesh points, <span class="math">\(t_n\)</span>,
a numerical integration rule can be used to calculate the <span class="math">\(L^2\)</span> and
<span class="math">\(L^1\)</span> norms defined above. Imagining that the mesh function is extended
to vary linearly between the mesh points, the Trapezoidal rule is
in fact an exact integration rule. A possible modification of the <span class="math">\(L^2\)</span>
norm for a mesh function <span class="math">\(f^n\)</span> on a uniform mesh with spacing <span class="math">\(\Delta t\)</span>
is therefore the well-known Trapezoidal integration formula</p>
<div class="math">
\[||f^n|| = \left(\Delta t\left(\frac{1}{2}(f^0)^2 + \frac{1}{2}(f^{N_t})^2
+ \sum_{n=1}^{N_t-1} (f^n)^2\right)\right)^{1/2}\]</div>
<p>A common approximation of this expression, motivated by the
convenience of having a simpler formula, is</p>
<div class="math">
\[||f^n||_{\ell^2} = \left(\Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2} {\thinspace .}\]</div>
<p>This is called the discrete <span class="math">\(L^2\)</span> norm and denoted by <span class="math">\(\ell^2\)</span>.
The error in <span class="math">\(||f||_{\ell^2}^2\)</span> compared with the Trapezoidal
integration formula
is <span class="math">\(\Delta t((f^0)^2 + (f^{N_t})^2)/2\)</span>, which means perturbed weights
at the end points of the mesh function, and the error goes to zero as
<span class="math">\(\Delta t\rightarrow 0\)</span>. As long as we are consistent and
stick to one kind of integration
rule for the norm of a mesh function, the details and accuracy of this
rule is not of concern.</p>
<p>The three discrete norms for a mesh function <span class="math">\(f^n\)</span>, corresponding to
the <span class="math">\(L^2\)</span>, <span class="math">\(L^1\)</span>, and <span class="math">\(L^\infty\)</span> norms of <span class="math">\(f(t)\)</span> defined above, are
defined by</p>
<div class="math" id="equation-decay:norms:l2">
<span id="id2"></span><span class="eqno">(5)</span>\[     ||f^n||_{\ell^2}  \left( \Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2},\]</div>
<div class="math" id="equation-decay:norms:l1">
<span id="id3"></span><span class="eqno">(6)</span>\[     ||f^n||_{\ell^1}  \Delta t\sum_{n=0}^{N_t} |f^n|\]</div>
<div class="math" id="equation-decay:norms:linf">
<span id="id4"></span><span class="eqno">(7)</span>\[     ||f^n||_{\ell^\infty}  \max_{0\leq n\leq N_t}|f^n|{\thinspace .}\]</div>
<p>Note that the <span class="math">\(L^2\)</span>, <span class="math">\(L^1\)</span>, <span class="math">\(\ell^2\)</span>, and <span class="math">\(\ell^1\)</span> norms depend on the
length of the interval of interest (think of <span class="math">\(f=1\)</span>, then the
norms are proportional to <span class="math">\(\sqrt{T}\)</span> or <span class="math">\(T\)</span>). In some applications it
is convenient to think of a mesh function as just a vector of function
values and neglect the information of the mesh points. Then we can
replace <span class="math">\(\Delta t\)</span> by <span class="math">\(T/N_t\)</span> and drop <span class="math">\(T\)</span>. Moreover, it is convenient
to divide by the total length of the vector, <span class="math">\(N_t+1\)</span>, instead of <span class="math">\(N_t\)</span>.
This reasoning gives rise to the <em>vector norms</em> for a vector
<span class="math">\(f=(f_0,\ldots,f_{N})\)</span>:</p>
<div class="math" id="equation-decay:norms:vl2">
<span id="eq-decay-norms-vl2"></span><span class="eqno">(8)</span>\[     ||f||_2 = \left( \frac{1}{N+1}\sum_{n=0}^{N} (f_n)^2\right)^{1/2},\]</div>
<div class="math" id="equation-decay:norms:vl1">
<span id="eq-decay-norms-vl1"></span><span class="eqno">(9)</span>\[     ||f||_1 = \frac{1}{N+1}\sum_{n=0}^{N} |f_n|\]</div>
<div class="math" id="equation-decay:norms:vlinf">
<span id="eq-decay-norms-vlinf"></span><span class="eqno">(10)</span>\[     ||f||_{\ell^\infty} = \max_{0\leq n\leq N}|f_n|{\thinspace .}\]</div>
<p>Here we have used the common vector component notation with subscripts
(<span class="math">\(f_n\)</span>) and <span class="math">\(N\)</span> as length. We will mostly work with mesh functions
and use the discrete <span class="math">\(\ell^2\)</span>
norm <a href="#equation-decay:norms:l2">(5)</a> or the max norm <span class="math">\(\ell^\infty\)</span>
<a href="#equation-decay:norms:linf">(7)</a>, but the corresponding vector norms
<a href="#equation-decay:norms:vl2">(8)</a>-<a href="#equation-decay:norms:vlinf">(10)</a> are also much used
in numerical computations, so it is important to know the different
norms and the relations between them.</p>
<p id="index-13">A single number that expresses the size of the numerical error
will be taken as <span class="math">\(||e^n||_{\ell^2}\)</span> and called <span class="math">\(E\)</span>:</p>
<div class="math" id="equation-decay:E">
<span id="eq-decay-e"></span><span class="eqno">(11)</span>\[     E = \sqrt{\Delta t\sum_{n=0}^{N_t} (e^n)^2}\]</div>
<p>The corresponding Python code, using array arithmetics, reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">sum</span></tt> function comes from <tt class="docutils literal"><span class="pre">numpy</span></tt> and computes the sum of the elements
of an array. Also the <tt class="docutils literal"><span class="pre">sqrt</span></tt> function is from <tt class="docutils literal"><span class="pre">numpy</span></tt> and computes the
square root of each element in the array argument.</p>
<div class="section" id="scalar-computing">
<span id="index-14"></span><h3>Scalar computing<a class="headerlink" href="#scalar-computing" title="Permalink to this headline">¶</a></h3>
<p>Instead of doing array computing <tt class="docutils literal"><span class="pre">sqrt(dt*sum(e**2))</span></tt> we can compute with
one element at a time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>     <span class="c"># length of u array (alt: u.size)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># summation variable</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Such element-wise computing, often called <em>scalar</em> computing, takes
more code, is less readable, and runs much slower than what we
can achieve with array computing.</p>
</div>
</div>
<div class="section" id="plotting-solutions">
<span id="decay-plotting"></span><h2>Plotting solutions<a class="headerlink" href="#plotting-solutions" title="Permalink to this headline">¶</a></h2>
<p>Having the <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> arrays, the approximate solution <tt class="docutils literal"><span class="pre">u</span></tt> is visualized
by the intuitive command <tt class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="plotting-multiple-curves">
<h3>Plotting multiple curves<a class="headerlink" href="#plotting-multiple-curves" title="Permalink to this headline">¶</a></h3>
<p>It will be illustrative to also plot <span class="math">\({u_{\small\mbox{e}}}(t)\)</span> for comparison. Doing a
<tt class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u_e)</span></tt> is not exactly what we want: the <tt class="docutils literal"><span class="pre">plot</span></tt> function draws
straight lines between the discrete points <tt class="docutils literal"><span class="pre">(t[n],</span> <span class="pre">u_e[n])</span></tt> while
<span class="math">\({u_{\small\mbox{e}}}(t)\)</span> varies as an exponential function between the mesh points.
The technique for showing the &#8220;exact&#8221; variation of <span class="math">\({u_{\small\mbox{e}}}(t)\)</span> between
the mesh points is to introduce a very fine mesh for <span class="math">\({u_{\small\mbox{e}}}(t)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>      <span class="c"># fine mesh</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>            <span class="c"># blue line for u_e</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">)</span>          <span class="c"># red dashes w/circles</span>
</pre></div>
</div>
<p>With more than one curve in the plot we need to associate each curve
with a legend. We also want appropriate names on the axis, a title,
and a file containing the plot as an image for inclusion in reports.
The Matplotlib package (<tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt>) contains functions for
this purpose. The names of the functions are similar to the plotting
functions known from MATLAB.  A complete plot session then becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">figure</span><span class="p">()</span>                          <span class="c"># create new plot</span>
<span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>        <span class="c"># fine mesh for u_e</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">)</span>            <span class="c"># red dashes w/circles</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>              <span class="c"># blue line for exact sol.</span>
<span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
<span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">savefig</span></tt> here creates a PNG file whose name reflects the
values of <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> so that we can easily distinguish
files from different runs with <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span>.</p>
<p>A bit more sophisticated and easy-to-read filename can be generated
by mapping the <span class="math">\(\theta\)</span> value to acronyms for the three common
schemes: FE (Forward Euler, <span class="math">\(\theta=0\)</span>), BE (Backward Euler, <span class="math">\(\theta=1\)</span>),
CN (Crank-Nicolson, <span class="math">\(\theta=0.5\)</span>). A Python dictionary is ideal for such
a mapping from numbers to strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
<span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="experiments-with-computing-and-plotting">
<h3>Experiments with computing and plotting<a class="headerlink" href="#experiments-with-computing-and-plotting" title="Permalink to this headline">¶</a></h3>
<p>Let us wrap up the computation of the error measure and all the
plotting statements in a function <tt class="docutils literal"><span class="pre">explore</span></tt>. This function
can be called for various <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> values
to see how the error varies with the method and the mesh resolution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a case with the solver, compute error measure,</span>
<span class="sd">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>    <span class="c"># Numerical solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>                         <span class="c"># create new plot</span>
        <span class="n">t_e</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>       <span class="c"># fine mesh for u_e</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">)</span>           <span class="c"># red dashes w/circles</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>             <span class="c"># blue line for exact sol.</span>
        <span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">])</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
        <span class="n">title</span><span class="p">(</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.eps&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">figure()</span></tt> call is key here: without it, a new <tt class="docutils literal"><span class="pre">plot</span></tt> command will
draw the new pair of curves in the same plot window, while we want
the different pairs to appear in separate windows and files.
Calling <tt class="docutils literal"><span class="pre">figure()</span></tt> ensures this.</p>
<span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><p id="index-18">The <tt class="docutils literal"><span class="pre">explore</span></tt> function stores the plot in three different image file formats:
PNG, PDF, and EPS (Encapsulated PostScript). The PNG format is aimed
at being included in HTML files, the PDF format in pdfLaTeX documents,
and the EPS format in LaTeX documents. Frequently used viewers for these
image files on Unix systems are <tt class="docutils literal"><span class="pre">gv</span></tt> (comes with Ghostscript)
for the PDF and EPS formats and
<tt class="docutils literal"><span class="pre">display</span></tt> (from the ImageMagick) suite for PNG files:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; gv BE_0.5.pdf</span>
<span class="go">Terminal&gt; gv BE_0.5.eps</span>
<span class="go">Terminal&gt; display BE_0.5.png</span>
</pre></div>
</div>
<p>The complete code containing the functions above
resides in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py">decay_plot_mpl.py</a>.
Running this program results in</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay_plot_mpl.py</span>
<span class="go">0.0   0.40:    2.105E-01</span>
<span class="go">0.0   0.04:    1.449E-02</span>
<span class="go">0.5   0.40:    3.362E-02</span>
<span class="go">0.5   0.04:    1.887E-04</span>
<span class="go">1.0   0.40:    1.030E-01</span>
<span class="go">1.0   0.04:    1.382E-02</span>
</pre></div>
</div>
<p>We observe that reducing <span class="math">\(\Delta t\)</span> by a factor of 10 increases the
accuracy for all three methods (<span class="math">\(\theta\)</span> values). We also see that
the combination of <span class="math">\(\theta=0.5\)</span> and a small time step <span class="math">\(\Delta t =0.04\)</span>
gives a much more accurate solution, and that <span class="math">\(\theta=0\)</span> and <span class="math">\(\theta=1\)</span>
with <span class="math">\(\Delta t = 0.4\)</span> result in the least accurate solutions.</p>
<p>Figure <a class="reference internal" href="#decay-fig-fe1"><em>The Forward Euler scheme for two values of the time step</em></a> demonstrates that the numerical solution for
<span class="math">\(\Delta t=0.4\)</span> clearly lies below the exact curve, but that the
accuracy improves considerably by reducing the time step by a factor
of 10.</p>
<div class="figure" id="decay-fig-fe1">
<img alt="_images/FE1.png" src="_images/FE1.png" style="width: 600px;" />
<p class="caption"><em>The Forward Euler scheme for two values of the time step</em></p>
</div>
<span class="target" id="index-19"></span></div>
<div class="section" id="combining-plot-files-1">
<span id="index-20"></span><h3>Combining plot files  (1)<a class="headerlink" href="#combining-plot-files-1" title="Permalink to this headline">¶</a></h3>
<p>Mounting two PNG files, as done in the figure, is easily done by the
<a class="reference external" href="http://www.imagemagick.org/script/montage.php">montage</a> program
from the ImageMagick suite:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; montage -background white -geometry 100% -tile 2x1 \</span>
<span class="go">          FE_0.4.png FE_0.04.png FE1.png</span>
<span class="go">Terminal&gt; convert -trim FE1.png FE1.png</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">-geometry</span></tt> argument is used to specify the size of the image, and here
we preserve the individual sizes of the images. The <tt class="docutils literal"><span class="pre">-tile</span> <span class="pre">HxV</span></tt> option
specifies <tt class="docutils literal"><span class="pre">H</span></tt> images in the horizontal direction and <tt class="docutils literal"><span class="pre">V</span></tt> images in
the vertical direction. A series of image files to be combined are then listed,
with the name of the resulting combined image, here <tt class="docutils literal"><span class="pre">FE1.png</span></tt> at the end.
The <tt class="docutils literal"><span class="pre">convert</span> <span class="pre">-trim</span></tt> command removes surrounding white areas in the figure
(an operation usually known as <em>cropping</em> in image manipulation programs).</p>
<span class="target" id="index-21"></span><span class="target" id="index-22"></span><p id="index-23">For LaTeX{} reports it is not recommended to use <tt class="docutils literal"><span class="pre">montage</span></tt> and PNG files
as the result has too low resolution. Instead, plots should be made
in the PDF format and combined using the <tt class="docutils literal"><span class="pre">pdftk</span></tt>, <tt class="docutils literal"><span class="pre">pdfnup</span></tt>, and <tt class="docutils literal"><span class="pre">pdfcrop</span></tt> tools
(on Linux/Unix):</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; pdftk FE_0.4.png FE_0.04.png output tmp.pdf</span>
<span class="go">Terminal&gt; pdfnup --nup 2x1 tmp.pdf     # output in tmp-nup.pdf</span>
<span class="go">Terminal&gt; pdfcrop tmp-nup.pdf FE1.png  # output in FE1.png</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">pdftk</span></tt> combines images into a multi-page PDF file, <tt class="docutils literal"><span class="pre">pdfnup</span></tt>
combines the images in individual pages to a table of images (pages),
and <tt class="docutils literal"><span class="pre">pdfcrop</span></tt> removes white margins in the resulting combined image file.</p>
<p>The behavior of the two other schemes is shown in Figures <a class="reference internal" href="#decay-fig-be1"><em>The Backward Euler scheme for two values of the time step</em></a>
and <a class="reference internal" href="#decay-fig-cn1"><em>The Crank-Nicolson scheme for two values of the time step</em></a>. Crank-Nicolson is obviously the most accurate
scheme from this visual point of view.</p>
<div class="figure" id="decay-fig-be1">
<img alt="_images/BE1.png" src="_images/BE1.png" style="width: 600px;" />
<p class="caption"><em>The Backward Euler scheme for two values of the time step</em></p>
</div>
<div class="figure" id="decay-fig-cn1">
<img alt="_images/CN1.png" src="_images/CN1.png" style="width: 600px;" />
<p class="caption"><em>The Crank-Nicolson scheme for two values of the time step</em></p>
</div>
</div>
<div class="section" id="plotting-with-scitools">
<h3>Plotting with SciTools<a class="headerlink" href="#plotting-with-scitools" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="http://code.google.com/p/scitools">SciTools package</a> provides a
unified plotting interface, called Easyviz, to many different plotting
packages, including Matplotlib, Gnuplot, Grace, MATLAB,
VTK, OpenDX, and VisIt. The syntax is very similar to that of
Matplotlib and MATLAB. In fact, the plotting commands shown above look
the same in SciTool&#8217;s Easyviz interface, apart from the import
statement, which reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This statement performs a <tt class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></tt> as well as an import
of the most common pieces of the Easyviz (<tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt>) package,
along with some additional numerical functionality.</p>
<p>With Easyviz one can
merge several plotting commands into a single one
using keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span>   <span class="n">u</span><span class="p">,</span>   <span class="s">&#39;r--o&#39;</span><span class="p">,</span>           <span class="c"># red dashes w/circles</span>
     <span class="n">t_e</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span>             <span class="c"># blue line for exact sol.</span>
     <span class="n">legend</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span>
     <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span>
     <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
     <span class="n">title</span><span class="o">=</span><span class="s">&#39;theta=</span><span class="si">%g</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%g</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">),</span>
     <span class="n">show</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_st.py">decay_plot_st.py</a> file
contains such a demo.</p>
<p>By default, Easyviz employs Matplotlib for plotting, but <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> and <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a> are viable alternatives:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend gnuplot</span>
<span class="go">Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend grace</span>
</pre></div>
</div>
<p>The backend used for creating plots (and numerous other options)
can be permanently set in SciTool&#8217;s configuration file.</p>
<p>All the Gnuplot windows are launched without any need to kill one before
the next one pops up (as is the case with Matplotlib) and one can
press the key &#8216;q&#8217; anywhere in a plot window to kill it.
Another advantage of Gnuplot is the automatic choice of sensible
and distinguishable line types in black-and-white PDF and PostScript
files.</p>
<p>Regarding functionality for annotating plots with title, labels on the
axis, legends, etc., we refer to the documentation of Matplotlib and
SciTools for more detailed information on the syntax. The hope is that
the programming syntax explained so far suffices for understanding the
code and learning more from a combination of the forthcoming examples
and other resources such as books and web pages.</p>
<div class="admonition-test-the-understanding admonition">
<p class="first admonition-title">Test the understanding</p>
<p class="last"><a class="reference internal" href="._part0005_main_decay.html#decay-app-exer-cooling-py"><em>Exercise 2: Implement schemes for Newton&#8217;s law of cooling</em></a> asks you to implement
a solver for a problem that is slightly different from the
one above. You may use the <tt class="docutils literal"><span class="pre">solver</span></tt> and <tt class="docutils literal"><span class="pre">explore</span></tt> functions
explained above as a starting point. Apply the new solver
to <a class="reference internal" href="._part0005_main_decay.html#decay-app-exer-cooling-murder"><em>Exercise 3: Find time of murder from body temperature</em></a>.</p>
</div>
</div>
</div>
<div class="section" id="creating-command-line-interfaces">
<span id="decay-commandline"></span><h2>Creating command-line interfaces<a class="headerlink" href="#creating-command-line-interfaces" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-24"></span><p id="index-25">It is good programming practice to let programs read input from the user
rather than require the user to edit the source code when trying out
new values of input parameters.
Reading input from the command line is a simple and flexible way of interacting
with the user. Python stores all the command-line arguments in
the list <tt class="docutils literal"><span class="pre">sys.argv</span></tt>, and there are, in principle, two ways of programming with
command-line arguments in Python:</p>
<blockquote>
<div><ul class="simple">
<li>Decide upon a sequence of parameters on the command line and read
their values directly from the <tt class="docutils literal"><span class="pre">sys.argv[1:]</span></tt> list (<tt class="docutils literal"><span class="pre">sys.argv[0]</span></tt> is
the just program name).</li>
<li>Use option-value pairs (<tt class="docutils literal"><span class="pre">--option</span> <span class="pre">value</span></tt>) on
the command line to override default values of input parameters,
and utilize the <tt class="docutils literal"><span class="pre">argparse.ArgumentParser</span></tt> tool to interact with
the command line.</li>
</ul>
</div></blockquote>
<p>Both strategies will be illustrated next.</p>
<div class="section" id="reading-a-sequence-of-command-line-arguments">
<h3>Reading a sequence of command-line arguments<a class="headerlink" href="#reading-a-sequence-of-command-line-arguments" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py">decay_plot_mpl.py</a>
program needs the following input data: <span class="math">\(I\)</span>, <span class="math">\(a\)</span>, <span class="math">\(T\)</span>, an option to
turn the plot on or off (<tt class="docutils literal"><span class="pre">makeplot</span></tt>), and a list of <span class="math">\(\Delta t\)</span> values.</p>
<p>The simplest way of reading this input from the command line is to say
that the first four command-line arguments correspond to the first
four points in the list above, in that order, and that the rest of the
command-line arguments are the <span class="math">\(\Delta t\)</span> values.  The input given for
<tt class="docutils literal"><span class="pre">makeplot</span></tt> can be a string among <tt class="docutils literal"><span class="pre">'on'</span></tt>, <tt class="docutils literal"><span class="pre">'off'</span></tt>, <tt class="docutils literal"><span class="pre">'True'</span></tt>, and
<tt class="docutils literal"><span class="pre">'False'</span></tt>. The code for reading this input is most conveniently put in
a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">read_command_line</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Usage: </span><span class="si">%s</span><span class="s"> I a T on/off dt1 dt2 dt3 ...&#39;</span> <span class="o">%</span> \
              <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>

    <span class="n">I</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">makeplot</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">,</span> <span class="s">&#39;True&#39;</span><span class="p">)</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">5</span><span class="p">:]]</span>

    <span class="k">return</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span>
</pre></div>
</div>
<span class="target" id="index-27"></span><p id="index-28">One should note the following about the constructions in the program above:</p>
<blockquote>
<div><ul class="simple">
<li>Everything on the command line ends up in a <em>string</em> in
the list <tt class="docutils literal"><span class="pre">sys.argv</span></tt>. Explicit conversion to, e.g., a <tt class="docutils literal"><span class="pre">float</span></tt> object is
required if the string as a number we want to compute with.</li>
<li>The value of <tt class="docutils literal"><span class="pre">makeplot</span></tt> is determined from a boolean expression,
which becomes <tt class="docutils literal"><span class="pre">True</span></tt> if the command-line argument is either <tt class="docutils literal"><span class="pre">'on'</span></tt> or
<tt class="docutils literal"><span class="pre">'True'</span></tt>, and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</li>
<li>It is easy to build the list of <span class="math">\(\Delta t\)</span> values: we simply run through
the rest of the list, <tt class="docutils literal"><span class="pre">sys.argv[5:]</span></tt>, convert each command-line argument
to <tt class="docutils literal"><span class="pre">float</span></tt>, and collect these <tt class="docutils literal"><span class="pre">float</span></tt> objects in a list, using the
compact and convenient <em>list comprehension</em> syntax in Python.</li>
</ul>
</div></blockquote>
<p>The loops over <span class="math">\(\theta\)</span> and <span class="math">\(\Delta t\)</span> values can be coded in a <tt class="docutils literal"><span class="pre">main</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="si">%3.1f</span><span class="s"> </span><span class="si">%6.2f</span><span class="s">: </span><span class="si">%12.3E</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete program can be found in <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_cml.py">decay_cml.py</a>.</p>
</div>
<div class="section" id="working-with-an-argument-parser">
<h3>Working with an argument parser<a class="headerlink" href="#working-with-an-argument-parser" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-29"></span><span class="target" id="index-30"></span><span class="target" id="index-31"></span><span class="target" id="index-32"></span><p id="index-33">Python&#8217;s <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> tool in the <tt class="docutils literal"><span class="pre">argparse</span></tt> module makes it
easy to create a professional command-line interface to any
program. The documentation of <a class="reference external" href="http://docs.python.org/library/argparse.html">ArgumentParser</a> demonstrates its
versatile applications, so we shall here just list an example
containing basic features.  On the command line we want to
specify option-value pairs for <span class="math">\(I\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(T\)</span>, e.g., <tt class="docutils literal"><span class="pre">--a</span> <span class="pre">3.5</span> <span class="pre">--I</span> <span class="pre">2</span>
<span class="pre">--T</span> <span class="pre">2</span></tt>. Including <tt class="docutils literal"><span class="pre">--makeplot</span></tt> turns the plot on and excluding this
option turns the plot off.  The <span class="math">\(\Delta t\)</span> values can be given as
<tt class="docutils literal"><span class="pre">--dt</span> <span class="pre">1</span> <span class="pre">0.5</span> <span class="pre">0.25</span> <span class="pre">0.1</span> <span class="pre">0.01</span></tt>.  Each parameter must have a sensible
default value so that we specify the option on the command line only
when the default value is not suitable.</p>
<p>We introduce a function for defining the mentioned command-line options:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">define_command_line_options</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="s">&#39;--initial_condition&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;initial condition, u(0)&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;I&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--a&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;coefficient in ODE&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--T&#39;</span><span class="p">,</span> <span class="s">&#39;--stop_time&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;end time of simulation&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--makeplot&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s">&#39;display plot or not&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="s">&#39;--time_step_values&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;time step values&#39;</span><span class="p">,</span>
                        <span class="n">metavar</span><span class="o">=</span><span class="s">&#39;dt&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;dt_values&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span>
</pre></div>
</div>
<p>Each command-line option is defined through the <tt class="docutils literal"><span class="pre">parser.add_argument</span></tt>
method. Alternative options, like the short <tt class="docutils literal"><span class="pre">--I</span></tt> and the more
explaining version <tt class="docutils literal"><span class="pre">--initial_condition</span></tt> can be defined. Other arguments
are <tt class="docutils literal"><span class="pre">type</span></tt> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <tt class="docutils literal"><span class="pre">-h</span></tt> or <tt class="docutils literal"><span class="pre">--help</span></tt> is
included. The <tt class="docutils literal"><span class="pre">metavar</span></tt> argument specifies the value associated with
the option when the help string is printed. For example, the option for
<span class="math">\(I\)</span> has this help output:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay_argparse.py -h</span>
<span class="go">  ...</span>
<span class="go">  --I I, --initial_condition I</span>
<span class="go">                        initial condition, u(0)</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>The structure of this output is</p>
<div class="highlight-text"><div class="highlight"><pre>--I metavar, --initial_condition metavar
                      help-string
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">--makeplot</span></tt> option is a pure flag without any value, implying a
true value if the flag is present and otherwise a false value. The
<tt class="docutils literal"><span class="pre">action='store_true'</span></tt> makes an option for such a flag.</p>
<p>Finally, the <tt class="docutils literal"><span class="pre">--dt</span></tt> option demonstrates how to allow for more than one
value (separated by blanks) through the <tt class="docutils literal"><span class="pre">nargs='+'</span></tt> keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the <tt class="docutils literal"><span class="pre">dist</span></tt> keyword argument, which for the <tt class="docutils literal"><span class="pre">--dt</span></tt> option is
<tt class="docutils literal"><span class="pre">dt_values</span></tt>. Without the <tt class="docutils literal"><span class="pre">dest</span></tt> argument, the value of an option <tt class="docutils literal"><span class="pre">--opt</span></tt>
is stored as the attribute <tt class="docutils literal"><span class="pre">opt</span></tt>.</p>
<p>The code below demonstrates how to read the command line and extract
the values for each option:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_command_line</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">define_command_line_options</span><span class="p">()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;I={}, a={}, T={}, makeplot={}, dt_values={}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">makeplot</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">dt_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">args</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">makeplot</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">dt_values</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">main</span></tt> function remains the same as in the <tt class="docutils literal"><span class="pre">decay_cml.py</span></tt> code based
on reading from <tt class="docutils literal"><span class="pre">sys.argv</span></tt> directly. A complete program featuring the
demo above of <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> appears in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_argparse.py">decay_argparse.py</a>.</p>
</div>
</div>
<div class="section" id="creating-a-graphical-web-user-interface">
<h2>Creating a graphical web user interface<a class="headerlink" href="#creating-a-graphical-web-user-interface" title="Permalink to this headline">¶</a></h2>
<p>The Python package <a class="reference external" href="https://github.com/hplgit/parampool">Parampool</a>
can be used to automatically generate a web-based <em>graphical user interface</em>
(GUI) for our simulation program. Although the programming technique
dramatically simplifies the efforts to create a GUI, the forthcoming
material on equipping our <tt class="docutils literal"><span class="pre">decay_mod</span></tt> module with a GUI is quite technical
and of significantly less importance than knowing how to make
a command-line interface (the section <a class="reference internal" href="#decay-commandline"><em>Creating command-line interfaces</em></a>).
There is no danger in jumping right to the section <a class="reference internal" href="#decay-convergence-rate"><em>Computing convergence rates</em></a>.</p>
<div class="section" id="making-a-compute-function">
<h3>Making a compute function<a class="headerlink" href="#making-a-compute-function" title="Permalink to this headline">¶</a></h3>
<p>The first step is to identify a function
that performs the computations and that takes the necessary input
variables as arguments. This is called the <em>compute function</em> in
Parampool terminology. We may start with a copy of the basic file
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py">decay_plot_mpl.py</a>,
which has a <tt class="docutils literal"><span class="pre">main</span></tt> function displayed in
the section <a class="reference internal" href="#decay-plotting"><em>Plotting solutions</em></a> for carrying out simulations and plotting
for a series of <span class="math">\(\Delta t\)</span> values. Now we want to control and view the same
experiments from a web GUI.</p>
<p>To tell Parampool what type of input data we have,
we assign default values of the right type to all arguments in the
main function and call it <tt class="docutils literal"><span class="pre">main_GUI</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main_GUI</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">a</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
         <span class="n">dt_values</span><span class="o">=</span><span class="p">[</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
         <span class="n">theta_values</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
</pre></div>
</div>
<p>The compute function must return the HTML code we want for displaying
the result in a web page. Here we want to show plots of the numerical
and exact solution for different methods and <span class="math">\(\Delta t\)</span> values.
The plots can be organized in a table with <span class="math">\(\theta\)</span> (methods) varying
through the columns and <span class="math">\(\Delta t\)</span> varying through the rows.
Assume now that a new version of the <tt class="docutils literal"><span class="pre">explore</span></tt> function
not only returns the error <tt class="docutils literal"><span class="pre">E</span></tt> but also HTML code containing the
plot. Then we can write the <tt class="docutils literal"><span class="pre">main_GUI</span></tt> function as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main_GUI</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">a</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
         <span class="n">dt_values</span><span class="o">=</span><span class="p">[</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
         <span class="n">theta_values</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
    <span class="c"># Build HTML code for web page. Arrange plots in columns</span>
    <span class="c"># corresponding to the theta values, with dt down the rows</span>
    <span class="n">theta2name</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;BE&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="s">&#39;CN&#39;</span><span class="p">}</span>
    <span class="n">html_text</span> <span class="o">=</span> <span class="s">&#39;&lt;table&gt;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
        <span class="n">html_text</span> <span class="o">+=</span> <span class="s">&#39;&lt;tr&gt;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">theta_values</span><span class="p">:</span>
            <span class="n">E</span><span class="p">,</span> <span class="n">html</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">html_text</span> <span class="o">+=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">&lt;td&gt;</span>
<span class="s">&lt;center&gt;&lt;b&gt;</span><span class="si">%s</span><span class="s">, dt=</span><span class="si">%g</span><span class="s">, error: </span><span class="si">%s</span><span class="s">&lt;/b&gt;&lt;/center&gt;&lt;br&gt;</span>
<span class="si">%s</span><span class="s"></span>
<span class="s">&lt;/td&gt;</span>
<span class="s">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">theta2name</span><span class="p">[</span><span class="n">theta</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">html</span><span class="p">)</span>
        <span class="n">html_text</span> <span class="o">+=</span> <span class="s">&#39;&lt;/tr&gt;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">html_text</span> <span class="o">+=</span> <span class="s">&#39;&lt;/table&gt;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="k">return</span> <span class="n">html_text</span>
</pre></div>
</div>
<p>Rather than creating plot files and showing the plot on the screen,
the new version of the <tt class="docutils literal"><span class="pre">explore</span></tt> function makes a string with the PNG code of
the plot and embeds that string in HTML code. This action is
conveniently performed by Parampool&#8217;s <tt class="docutils literal"><span class="pre">save_png_to_str</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="o">...</span>
<span class="c"># plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="s">&#39;)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="kn">from</span> <span class="nn">parampool.utils</span> <span class="kn">import</span> <span class="n">save_png_to_str</span>
<span class="n">html_text</span> <span class="o">=</span> <span class="n">save_png_to_str</span><span class="p">(</span><span class="n">plt</span><span class="p">,</span> <span class="n">plotwidth</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we now write <tt class="docutils literal"><span class="pre">plt.plot</span></tt>, <tt class="docutils literal"><span class="pre">plt.xlabel</span></tt>, etc.
The <tt class="docutils literal"><span class="pre">html_text</span></tt> string is long and contains all the characters that
build up the PNG file of the current plot. The new <tt class="docutils literal"><span class="pre">explore</span></tt>
function can make use of the above code snippet and return
<tt class="docutils literal"><span class="pre">html_text</span></tt> along with <tt class="docutils literal"><span class="pre">E</span></tt>.</p>
</div>
<div class="section" id="generating-the-user-interface">
<h3>Generating the user interface<a class="headerlink" href="#generating-the-user-interface" title="Permalink to this headline">¶</a></h3>
<p>The web GUI is automatically generated by
the following code, placed in a file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_GUI_generate.py">decay_GUI_generate.py</a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">parampool.generator.flask</span> <span class="kn">import</span> <span class="n">generate</span>
<span class="kn">from</span> <span class="nn">decay_GUI</span> <span class="kn">import</span> <span class="n">main</span>
<span class="n">generate</span><span class="p">(</span><span class="n">main</span><span class="p">,</span>
         <span class="n">output_controller</span><span class="o">=</span><span class="s">&#39;decay_GUI_controller.py&#39;</span><span class="p">,</span>
         <span class="n">output_template</span><span class="o">=</span><span class="s">&#39;decay_GUI_view.py&#39;</span><span class="p">,</span>
         <span class="n">output_model</span><span class="o">=</span><span class="s">&#39;decay_GUI_model.py&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Running the <tt class="docutils literal"><span class="pre">decay_GUI_generate.py</span></tt> program results in three new
files whose names are specified in the call to <tt class="docutils literal"><span class="pre">generate</span></tt>:</p>
<blockquote>
<div><ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">decay_GUI_model.py</span></tt> defines HTML widgets to be used to set
input data in the web interface,</li>
<li><tt class="docutils literal"><span class="pre">templates/decay_GUI_views.py</span></tt> defines the layout of the web page,</li>
<li><tt class="docutils literal"><span class="pre">decay_GUI_controller.py</span></tt> runs the web application.</li>
</ol>
</div></blockquote>
<p>We only need to run the last program, and there is no need to look into
these files.</p>
</div>
<div class="section" id="running-the-web-application">
<h3>Running the web application<a class="headerlink" href="#running-the-web-application" title="Permalink to this headline">¶</a></h3>
<p>The web GUI is started by</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay_GUI_controller.py</span>
</pre></div>
</div>
<p>Open a web browser at the location <tt class="docutils literal"><span class="pre">127.0.0.1:5000</span></tt>. Input fields for
<tt class="docutils literal"><span class="pre">I</span></tt>, <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">T</span></tt>, <tt class="docutils literal"><span class="pre">dt_values</span></tt>, and <tt class="docutils literal"><span class="pre">theta_values</span></tt> are presented.
Setting the latter two to <tt class="docutils literal"><span class="pre">[1.25,</span> <span class="pre">0.5]</span></tt> and <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">0.5]</span></tt>,
respectively, and pressing <em>Compute</em> results in four plots, see
Figure <a class="reference internal" href="#decay-fig-gui"><em>Automatically generated graphical web interface</em></a>. With the techniques demonstrated here, one
can easily create a tailored web GUI for a particular type of application
and use it to interactively explore physical and numerical effects.</p>
<div class="figure" id="decay-fig-gui">
<img alt="_images/decay_GUI.png" src="_images/decay_GUI.png" style="width: 800px;" />
<p class="caption"><em>Automatically generated graphical web interface</em></p>
</div>
</div>
</div>
<div class="section" id="computing-convergence-rates">
<span id="decay-convergence-rate"></span><h2>Computing convergence rates<a class="headerlink" href="#computing-convergence-rates" title="Permalink to this headline">¶</a></h2>
<p id="index-34">We expect that the error <span class="math">\(E\)</span> in the numerical solution is
reduced if the mesh size <span class="math">\(\Delta t\)</span> is decreased. More specifically,
many numerical methods obey a power-law relation between <span class="math">\(E\)</span> and
<span class="math">\(\Delta t\)</span>:</p>
<div class="math" id="equation-decay:E:dt">
<span id="eq-decay-e-dt"></span><span class="eqno">(12)</span>\[     E = C\Delta t^r,\]</div>
<p>where <span class="math">\(C\)</span> and <span class="math">\(r\)</span> are (usually unknown) constants independent of <span class="math">\(\Delta t\)</span>.
The formula <a href="#equation-decay:E:dt">(12)</a> is viewed as an asymptotic model valid for
sufficiently small <span class="math">\(\Delta t\)</span>. How small is normally hard to estimate
without doing numerical estimations of <span class="math">\(r\)</span>.</p>
<p>The parameter <span class="math">\(r\)</span> is known as the <em>convergence rate</em>. For example,
if the convergence rate is 2, halving <span class="math">\(\Delta t\)</span> reduces the error by
a factor of 4. Diminishing <span class="math">\(\Delta t\)</span> then has a greater impact on
the error compared with methods that have <span class="math">\(r=1\)</span>. For a given value of <span class="math">\(r\)</span>,
we refer to the method as of <span class="math">\(r\)</span>-th order. First- and second-order
methods are most common in scientific computing.</p>
<div class="section" id="estimating">
<h3>Estimating <span class="math">\(r\)</span><a class="headerlink" href="#estimating" title="Permalink to this headline">¶</a></h3>
<p>There are two alternative ways of estimating <span class="math">\(C\)</span> and <span class="math">\(r\)</span> based on a set of
<span class="math">\(m\)</span> simulations with corresponding pairs <span class="math">\((\Delta t_i, E_i)\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>,
and <span class="math">\(\Delta t_{i} &lt; \Delta t_{i-1}\)</span> (i.e., decreasing cell size).</p>
<blockquote>
<div><ol class="arabic simple">
<li>Take the logarithm of <a href="#equation-decay:E:dt">(12)</a>, <span class="math">\(\ln E = r\ln \Delta t + \ln C\)</span>,
and fit a straight line to the data points <span class="math">\((\Delta t_i, E_i)\)</span>,
<span class="math">\(i=0,\ldots,m-1\)</span>.</li>
<li>Consider two consecutive experiments, <span class="math">\((\Delta t_i, E_i)\)</span> and
<span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span>. Dividing the equation
<span class="math">\(E_{i-1}=C\Delta t_{i-1}^r\)</span> by <span class="math">\(E_{i}=C\Delta t_{i}^r\)</span> and solving
for <span class="math">\(r\)</span> yields</li>
</ol>
</div></blockquote>
<div class="math" id="equation-decay:conv:rate">
<span id="eq-decay-conv-rate"></span><span class="eqno">(13)</span>\[     r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}\]</div>
<p>for <span class="math">\(i=1,\ldots,m-1\)</span>.</p>
<p>The disadvantage of method 1 is that <a href="#equation-decay:E:dt">(12)</a> might not be valid
for the coarsest meshes (largest <span class="math">\(\Delta t\)</span> values). Fitting a line
to all the data points is then misleading.  Method 2 computes
convergence rates for pairs of experiments and allows us to see
if the sequence <span class="math">\(r_i\)</span> converges to some value as <span class="math">\(i\rightarrow m-2\)</span>.
The final <span class="math">\(r_{m-2}\)</span> can then be taken as the convergence rate.
If the coarsest meshes have a differing rate, the corresponding
time steps are probably too large for <a href="#equation-decay:E:dt">(12)</a> to be valid.
That is, those time steps lie outside the asymptotic range of
<span class="math">\(\Delta t\)</span> values where the error behaves like <a href="#equation-decay:E:dt">(12)</a>.</p>
</div>
<div class="section" id="implementation-2">
<h3>Implementation  (2)<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h3>
<p>It is straightforward to extend the <tt class="docutils literal"><span class="pre">main</span></tt> function in the program
<tt class="docutils literal"><span class="pre">decay_argparse.py</span></tt> with statements for computing <span class="math">\(r_0, r_1, \ldots, r_{m-2}\)</span>
from <a href="#equation-decay:E:dt">(12)</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">makeplot</span><span class="p">,</span> <span class="n">dt_values</span> <span class="o">=</span> <span class="n">read_command_line</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># estimated convergence rates</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

        <span class="c"># Compute convergence rates</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_values</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
                    <span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Pairwise convergence rates for theta=</span><span class="si">%g</span><span class="s">:&#39;</span> <span class="o">%</span> <span class="n">theta</span>
        <span class="k">print</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r_</span> <span class="k">for</span> <span class="n">r_</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>The program containing this <tt class="docutils literal"><span class="pre">main</span></tt> function is called <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_convrate.py">decay_convrate.py</a>.</p>
<p id="index-35">The <tt class="docutils literal"><span class="pre">r</span></tt> object is a <em>dictionary of lists</em>. The keys in this
dictionary are the <span class="math">\(\theta\)</span> values. For example,
<tt class="docutils literal"><span class="pre">r[1]</span></tt> holds the list of the <span class="math">\(r_i\)</span> values corresponding to
<span class="math">\(\theta=1\)</span>. In the loop <tt class="docutils literal"><span class="pre">for</span> <span class="pre">theta</span> <span class="pre">in</span> <span class="pre">r</span></tt>, the loop variable <tt class="docutils literal"><span class="pre">theta</span></tt>
takes on the values of the keys in the dictionary <tt class="docutils literal"><span class="pre">r</span></tt> (in an
undetermined ordering). We could simply do a <tt class="docutils literal"><span class="pre">print</span> <span class="pre">r[theta]</span></tt>
inside the loop, but this would typically yield output of
the convergence rates with 16 decimals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mf">1.331919482274763</span><span class="p">,</span> <span class="mf">1.1488178494691532</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Instead, we format each number with 2 decimals, using a list
comprehension to turn the list of numbers, <tt class="docutils literal"><span class="pre">r[theta]</span></tt>, into
a list of formatted strings. Then we join these strings
with a space in between to get a sequence of rates on one line
in the terminal window. More generally, <tt class="docutils literal"><span class="pre">d.join(list)</span></tt> joins the
strings in the list <tt class="docutils literal"><span class="pre">list</span></tt> to one string, with <tt class="docutils literal"><span class="pre">d</span></tt>
as delimiter between <tt class="docutils literal"><span class="pre">list[0]</span></tt>, <tt class="docutils literal"><span class="pre">list[1]</span></tt>, etc.</p>
<p>Here is an example on the outcome of the convergence rate computations:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay_convrate.py --dt 0.5 0.25 0.1 0.05 0.025 0.01</span>
<span class="go">...</span>
<span class="go">Pairwise convergence rates for theta=0:</span>
<span class="go">1.33 1.15 1.07 1.03 1.02</span>

<span class="go">Pairwise convergence rates for theta=0.5:</span>
<span class="go">2.14 2.07 2.03 2.01 2.01</span>

<span class="go">Pairwise convergence rates for theta=1:</span>
<span class="go">0.98 0.99 0.99 1.00 1.00</span>
</pre></div>
</div>
<p>The Forward and Backward Euler methods seem to have an <span class="math">\(r\)</span> value which
stabilizes at 1, while the Crank-Nicolson seems to be a second-order
method with <span class="math">\(r=2\)</span>.</p>
<p id="index-36">Very often, we have some theory that predicts what <span class="math">\(r\)</span> is for a numerical
method. Various theoretical error measures for the <span class="math">\(\theta\)</span>-rule point to
<span class="math">\(r=2\)</span> for <span class="math">\(\theta =0.5\)</span> and <span class="math">\(r=1\)</span> otherwise. The computed estimates of <span class="math">\(r\)</span> are
in very good agreement with these theoretical values.</p>
<div class="admonition-why-convergence-rates-are-important admonition">
<p class="first admonition-title">Why convergence rates are important</p>
<p class="last">The strong practical application of computing convergence rates is for
verification: wrong convergence rates point to errors in the code, and
correct convergence rates brings evidence that the implementation is
correct. Experience shows that bugs in the code easily destroy the
expected convergence rate.</p>
</div>
</div>
<div class="section" id="debugging-via-convergence-rates">
<h3>Debugging via convergence rates<a class="headerlink" href="#debugging-via-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>Let us experiment with bugs and see the implication on the convergence
rate. We may, for instance, forget to multiply by <tt class="docutils literal"><span class="pre">a</span></tt> in the denominator
in the updating formula for <tt class="docutils literal"><span class="pre">u[n+1]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>Running the same <tt class="docutils literal"><span class="pre">decay_convrate.py</span></tt> command as above gives the expected
convergence rates (!). Why? The reason is that we just specified
the <span class="math">\(\Delta t\)</span> values are relied on default values for other
parameters. The default value of <span class="math">\(a\)</span> is 1. Forgetting the factor
<tt class="docutils literal"><span class="pre">a</span></tt> has then no effect. This example shows how important it is to
avoid parameters that are 1 or 0 when verifying implementations.
Running the code <tt class="docutils literal"><span class="pre">decay_v0.py</span></tt> with <span class="math">\(a=2.1\)</span> and <span class="math">\(I=0.1\)</span> yields</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay_convrate.py --a 2.1 --I 0.1  \</span>
<span class="go">          --dt 0.5 0.25 0.1 0.05 0.025 0.01</span>
<span class="go">...</span>
<span class="go">Pairwise convergence rates for theta=0:</span>
<span class="go">1.49 1.18 1.07 1.04 1.02</span>

<span class="go">Pairwise convergence rates for theta=0.5:</span>
<span class="go">-1.42 -0.22 -0.07 -0.03 -0.01</span>

<span class="go">Pairwise convergence rates for theta=1:</span>
<span class="go">0.21 0.12 0.06 0.03 0.01</span>
</pre></div>
</div>
<p>This time we see that the expected convergence rates for the Crank-Nicolson and
Backward Euler methods are not obtained, while <span class="math">\(r=1\)</span> for the Forward Euler
method. The reason for correct rate in the latter case is that <span class="math">\(\theta=0\)</span>
and the wrong <tt class="docutils literal"><span class="pre">theta*dt</span></tt> term in the denominator vanishes anyway.</p>
<p>The error</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>manifests itself through wrong rates <span class="math">\(r\approx 0\)</span> for all three methods.
About the same results arise from an erroneous initial condition, <tt class="docutils literal"><span class="pre">u[0]</span> <span class="pre">=</span> <span class="pre">1</span></tt>,
or wrong loop limits, <tt class="docutils literal"><span class="pre">range(1,Nt)</span></tt>. It seems that in this simple
problem, most bugs we can think of are detected by the convergence rate
test, provided the values of the input data do not hide the bug.</p>
<p>A <tt class="docutils literal"><span class="pre">verify_convergence_rate</span></tt> function could compute the dictionary of
list via <tt class="docutils literal"><span class="pre">main</span></tt> and check if the final rate estimates (<span class="math">\(r_{m-2}\)</span>)
are sufficiently close to the expected ones. A tolerance of 0.1
seems appropriate, given the uncertainty in estimating <span class="math">\(r\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">verify_convergence_rate</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">main</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">expected_rates</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">r_final</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">theta</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">expected_rates</span><span class="p">[</span><span class="n">theta</span><span class="p">]</span> <span class="o">-</span> <span class="n">r_final</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>  <span class="c"># all tests passed</span>
</pre></div>
</div>
<p>We remark that <tt class="docutils literal"><span class="pre">r[theta]</span></tt> is a list and the last element in any list
can be extracted by the index <tt class="docutils literal"><span class="pre">-1</span></tt>.</p>
</div>
</div>
<div class="section" id="memory-saving-implementation">
<h2>Memory-saving implementation<a class="headerlink" href="#memory-saving-implementation" title="Permalink to this headline">¶</a></h2>
<p>The computer memory requirements of our implementations so far consists
mainly of the <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> arrays, both of length <span class="math">\(N_t+1\)</span>, plus some other
temporary arrays that Python needs for intermediate results if we do
array arithmetics in our program (e.g., <tt class="docutils literal"><span class="pre">I*exp(-a*t)</span></tt> needs to store
<tt class="docutils literal"><span class="pre">a*t</span></tt> before <tt class="docutils literal"><span class="pre">-</span></tt> can be applied to it and then <tt class="docutils literal"><span class="pre">exp</span></tt>).  The
extremely modest storage requirements of simple ODE problems put no
restrictions on the formulations of the algorithm and implementation.
Nevertheless, when the methods for ODEs used here are applied to
three-dimensional partial differential equation (PDE) problems,
memory storage requirements
suddenly become an issue.</p>
<p>The PDE counterpart to our model problem
<span class="math">\(u'=-a\)</span> is a diffusion equation <span class="math">\(u_t = a\nabla^2 u\)</span> posed on a
space-time domain. The discrete representation of this domain may in
3D be a spatial mesh of <span class="math">\(M^3\)</span> points and a time mesh of <span class="math">\(N_t\)</span> points. A
typical desired value for <span class="math">\(M\)</span> is 100 in many applications, or even
<span class="math">\(1000\)</span>.  Storing all the computed <span class="math">\(u\)</span> values, like we have done in the
programs so far, demands storage of some arrays of size <span class="math">\(M^3N_t\)</span>, giving
a factor of <span class="math">\(M^3\)</span> larger storage demands compared to our ODE
programs. Each real number in the array for <span class="math">\(u\)</span> requires 8 bytes (b) of
storage. With <span class="math">\(M=100\)</span> and <span class="math">\(N_t=1000\)</span>, there is a storage demand of
<span class="math">\((10^3)^3\cdot 1000\cdot 8 = 8\)</span> Gb for the solution array.
Fortunately, we can usually get rid of the <span class="math">\(N_t\)</span>
factor, resulting in 8 Mb of storage.
Below we explain how this is done, and the technique is almost
always applied in implementations of PDE problems.</p>
<p>Let us critically evaluate how much we really need to store in the
computer&#8217;s memory in our implementation of the <span class="math">\(\theta\)</span> method. To
compute a new <span class="math">\(u^{n+1}\)</span>, all we need is <span class="math">\(u^n\)</span>. This implies that the
previous <span class="math">\(u^{n-1},u^{n-2},\dots,u^0\)</span> values do not need to be stored
in an array, although this is convenient for plotting and data
analysis in the program.  Instead of the <tt class="docutils literal"><span class="pre">u</span></tt> array we can work with
two variables for real numbers, <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">u_1</span></tt>, representing
<span class="math">\(u^{n+1}\)</span> and <span class="math">\(u^n\)</span> in the algorithm, respectively.  At each time
level, we update <tt class="docutils literal"><span class="pre">u</span></tt> from <tt class="docutils literal"><span class="pre">u_1</span></tt> and then set <tt class="docutils literal"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">u</span></tt> so that the
computed <span class="math">\(u^{n+1}\)</span> value becomes the &#8220;previous&#8221; value <span class="math">\(u^n\)</span> at the
next time level. The downside is that we cannot plot the solution
after the simulation is done since only the last two numbers are
available.  The remedy is to store computed values in a file and use
the file for visualizing the solution later.</p>
<p>We have implemented this memory saving idea in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_memsave.py">decay_memsave.py</a>, which is a
merge of the <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py">decay_plot_mpl.py</a> and
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_argparse.py">decay_argparse.py</a>
programs, using module prefixes <tt class="docutils literal"><span class="pre">np</span></tt> for <tt class="docutils literal"><span class="pre">numpy</span></tt> and <tt class="docutils literal"><span class="pre">plt</span></tt> for
<tt class="docutils literal"><span class="pre">matplotlib.pyplot</span></tt>.</p>
<p>The following function demonstrates how we work with the two most
recent values of the unknown:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span class="sd">    Minimum use of memory. The solution is stored in a file</span>
<span class="sd">    (with name filename) for later plotting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>         <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>  <span class="c"># no of intervals</span>

    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="c"># u: time level n+1, u_1: time level n</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.16E</span><span class="s">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">u_1</span>
        <span class="n">u_1</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%.16E</span><span class="s">  </span><span class="si">%.16E</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>This code snippet serves as a quick introduction to file writing in Python.
Reading the data in the file into arrays <tt class="docutils literal"><span class="pre">t</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> are done by the
function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[];</span>  <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Found more than two numbers on a line!&#39;</span><span class="p">,</span> <span class="n">words</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># abort</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>This type of file with numbers in rows and columns is very common, and
<tt class="docutils literal"><span class="pre">numpy</span></tt> has a function <tt class="docutils literal"><span class="pre">loadtxt</span></tt> which loads such tabular data into a
two-dimensional array, say with name <tt class="docutils literal"><span class="pre">data</span></tt>. The number in row <tt class="docutils literal"><span class="pre">i</span></tt> and
column <tt class="docutils literal"><span class="pre">j</span></tt> is then <tt class="docutils literal"><span class="pre">data[i,j]</span></tt>.  The whole column number <tt class="docutils literal"><span class="pre">j</span></tt> can be
extracted by <tt class="docutils literal"><span class="pre">data[:,j]</span></tt>.  A version of <tt class="docutils literal"><span class="pre">read_file</span></tt> using <tt class="docutils literal"><span class="pre">np.loadtxt</span></tt>
reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">read_file_numpy</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;sol.dat&#39;</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
<p>The present counterpart to the <tt class="docutils literal"><span class="pre">explore</span></tt> function from
<a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_plot_mpl.py">decay_plot_mpl.py</a> must run
<tt class="docutils literal"><span class="pre">solver_memsave</span></tt> and then load data from file before we can compute
the error measure and make the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;u.dat&#39;</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_memsave</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">t</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>The <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_memsave.py">decay_memsave.py</a>
file also includes command-line options <tt class="docutils literal"><span class="pre">--I</span></tt>, <tt class="docutils literal"><span class="pre">--a</span></tt>, <tt class="docutils literal"><span class="pre">--T</span></tt>, <tt class="docutils literal"><span class="pre">--dt</span></tt>,
<tt class="docutils literal"><span class="pre">--theta</span></tt>, and <tt class="docutils literal"><span class="pre">--makeplot</span></tt> for controlling input parameters and
making a single run.  For example,</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python decay_memsave.py --T 10 --theta 1 --dt 2</span>
</pre></div>
</div>
<p>results in the output</p>
<div class="highlight-text"><div class="highlight"><pre>I=1.0, a=1.0, T=10.0, makeplot=True, theta=1.0, dt=2.0
theta=1.0 dt=2 Error=3.136E-01
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Implementation  (1)</a><ul>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a><ul>
<li><a class="reference internal" href="#function-for-computing-the-numerical-solution">Function for computing the numerical solution</a></li>
<li><a class="reference internal" href="#integer-division">Integer division</a></li>
<li><a class="reference internal" href="#doc-strings">Doc strings</a></li>
<li><a class="reference internal" href="#formatting-of-numbers">Formatting of numbers</a></li>
<li><a class="reference internal" href="#running-the-program">Running the program</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verifying-the-implementation">Verifying the implementation</a><ul>
<li><a class="reference internal" href="#running-a-few-algorithmic-steps-by-hand">Running a few algorithmic steps by hand</a></li>
<li><a class="reference internal" href="#comparison-with-an-exact-discrete-solution">Comparison with an exact discrete solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-the-numerical-error-as-a-mesh-function">Computing the numerical error as a mesh function</a></li>
<li><a class="reference internal" href="#computing-the-norm-of-the-numerical-error">Computing the norm of the numerical error</a><ul>
<li><a class="reference internal" href="#scalar-computing">Scalar computing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#plotting-solutions">Plotting solutions</a><ul>
<li><a class="reference internal" href="#plotting-multiple-curves">Plotting multiple curves</a></li>
<li><a class="reference internal" href="#experiments-with-computing-and-plotting">Experiments with computing and plotting</a></li>
<li><a class="reference internal" href="#combining-plot-files-1">Combining plot files  (1)</a></li>
<li><a class="reference internal" href="#plotting-with-scitools">Plotting with SciTools</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-command-line-interfaces">Creating command-line interfaces</a><ul>
<li><a class="reference internal" href="#reading-a-sequence-of-command-line-arguments">Reading a sequence of command-line arguments</a></li>
<li><a class="reference internal" href="#working-with-an-argument-parser">Working with an argument parser</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-a-graphical-web-user-interface">Creating a graphical web user interface</a><ul>
<li><a class="reference internal" href="#making-a-compute-function">Making a compute function</a></li>
<li><a class="reference internal" href="#generating-the-user-interface">Generating the user interface</a></li>
<li><a class="reference internal" href="#running-the-web-application">Running the web application</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-convergence-rates">Computing convergence rates</a><ul>
<li><a class="reference internal" href="#estimating">Estimating <span class="math">\(r\)</span></a></li>
<li><a class="reference internal" href="#implementation-2">Implementation  (2)</a></li>
<li><a class="reference internal" href="#debugging-via-convergence-rates">Debugging via convergence rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-saving-implementation">Memory-saving implementation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._part0001_main_decay.html"
                        title="previous chapter">Finite difference methods</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._part0003_main_decay.html"
                        title="next chapter">Software engineering</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._part0002_main_decay.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._part0003_main_decay.html" title="Software engineering"
             >next</a> |</li>
        <li class="right" >
          <a href="._part0001_main_decay.html" title="Finite difference methods"
             >previous</a> |</li>
        <li><a href="index.html">Introduction to computing with finite difference methods</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>