<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for wave motion">
<meta name="keywords" content="waves on a string,wave equation 1D,wave equation 1D, finite difference method,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,unit testing,software testing nose,vectorization,scalar code,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,stencil Neumann boundary,index set notation,geometric mean,arithmetic mean,harmonic average,averaging geometric,averaging arithmetic,averaging harmonic,wave equation 1D, analytical properties,Fourier series,Fourier transform,discrete Fourier transform,wave equation 1D, exact numerical solution,Courant number,stability criterion,wave equation 1D, stability,wave equation 2D, implementation,Cython,declaration of variables in Cython,C extension module,wrapper code,Fortran subroutine,row-major ordering,column-major ordering,Fortran array storage,C/Python array storage,radiation condition,open boundary condition">



<style type="text/css">
    /* solarized style */
    body {
      margin:5;
      padding:0;
      border:0;	/* Remove the border around the viewport in old versions of IE */
      width:100%;
      background: #fdf6e3;
      min-width:600px;	/* Minimum width of layout - remove if not required */
      font-family: Verdana, Helvetica, Arial, sans-serif;
      font-size: 1.0em;
      line-height: 1.3em;
      color: #657b83;
    }
    a { color: #657b83; text-decoration:none; }
    a:hover { color: #b58900; background: #eee8d5; text-decoration:none; }
    h1, h2, h3 { margin:.8em 0 .2em 0; padding:0; line-height: 125%; }
    h2 { font-variant: small-caps; }
    pre {
      background: #fdf6e3;
      -webkit-box-shadow: inset 0 0 2px #000000;
      -moz-box-shadow: inset 0 0 2px #000000;
      box-shadow: inset 0 0 2px #000000;
      color: #586e75;
      margin-left: 0px;
      font-family: 'Droid Sans Mono', monospace;
      padding: 2px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      -moz-background-clip: padding;
      -webkit-background-clip: padding-box;
      background-clip: padding-box;
    }
    tt { font-family: "Courier New", Courier; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p { text-indent: 0px; }
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #FFBF00;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #fbeed5;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods for waves on a string ',
               1,
               'wave:string',
               'wave:string'),
              (' Discretizing the domain ',
               2,
               'wave:string:mesh',
               'wave:string:mesh'),
              (' Uniform meshes ', 3, None, '___sec2'),
              (' The discrete solution ',
               2,
               'wave:string:numerical:sol',
               'wave:string:numerical:sol'),
              (' Fulfilling the equation at the mesh points ',
               2,
               'wave:string:samplingPDE',
               'wave:string:samplingPDE'),
              (' Replacing derivatives by finite differences ',
               2,
               'wave:string:fd',
               'wave:string:fd'),
              (' Algebraic version of the PDE ', 3, None, '___sec6'),
              (' Algebraic version of the initial conditions ',
               3,
               None,
               '___sec7'),
              (' Formulating a recursive algorithm ',
               2,
               'wave:string:alg',
               'wave:string:alg'),
              (' Sketch of an implementation ',
               2,
               'wave:string:impl',
               'wave:string:impl'),
              (' Verification ', 1, None, '___sec10'),
              (' A slightly generalized model problem ',
               2,
               'wave:pde2:fd',
               'wave:pde2:fd'),
              (' Using an analytical solution of physical significance ',
               2,
               None,
               '___sec12'),
              (' Manufactured solution ', 2, None, '___sec13'),
              (' Constructing an exact solution of the discrete equations ',
               2,
               None,
               '___sec14'),
              (' Implementation ', 1, 'wave:pde1:impl', 'wave:pde1:impl'),
              (' Making a solver function ', 2, None, '___sec16'),
              (' Verification: exact quadratic solution ',
               2,
               None,
               '___sec17'),
              (' Visualization: animating $u(x,t)$ ', 2, None, '___sec18'),
              (' Visualization via SciTools ', 3, None, '___sec19'),
              (' Making movie files ', 3, None, '___sec20'),
              (' Skipping frames for animation speed ', 3, None, '___sec21'),
              (' Visualization via Matplotlib ', 3, None, '___sec22'),
              (' Running a case ',
               2,
               'wave:pde1:guitar:data',
               'wave:pde1:guitar:data'),
              (' The benefits of scaling ', 2, None, '___sec24'),
              (' Vectorization ', 1, None, '___sec25'),
              (' Operations on slices of arrays ', 2, None, '___sec26'),
              (' Finite difference schemes expressed as slices ',
               2,
               None,
               '___sec27'),
              (' Verification ', 2, None, '___sec28'),
              (' Efficiency measurements ', 2, None, '___sec29'),
              (' Exercises ', 1, None, '___sec30'),
              (' Exercise 1: Simulate a standing wave ',
               2,
               'wave:exer:standingwave',
               'wave:exer:standingwave'),
              (' Exercise 2: Add storage of solution in a user action function ',
               2,
               'wave:exer:store:list',
               'wave:exer:store:list'),
              (' Exercise 3: Use a class for the user action function ',
               2,
               'wave:exer:store:list:class',
               'wave:exer:store:list:class'),
              (' Exercise 4: Compare several Courant numbers in one movie ',
               2,
               'wave:exer:multiple:C',
               'wave:exer:multiple:C'),
              (' Project 5: Calculus with 1D mesh functions ',
               2,
               'wave:exer:mesh1D:calculus',
               'wave:exer:mesh1D:calculus'),
              (' Generalization: reflecting boundaries ',
               1,
               None,
               '___sec36'),
              (' Neumann boundary condition ',
               2,
               'wave:pde2:Neumann',
               'wave:pde2:Neumann'),
              (' Discretization of derivatives at the boundary ',
               2,
               'wave:pde2:Neumann:discr',
               'wave:pde2:Neumann:discr'),
              (' Implementation of Neumann conditions ',
               2,
               'wave:pde2:Neumann:impl',
               'wave:pde2:Neumann:impl'),
              (' Index set notation ', 2, 'wave:indexset', 'wave:indexset'),
              (' Alternative implementation via ghost cells ',
               2,
               'wave:pde1:Neumann:ghost',
               'wave:pde1:Neumann:ghost'),
              (' Idea ', 3, None, '___sec42'),
              (' Implementation ', 3, None, '___sec43'),
              (' Generalization: variable wave velocity ',
               1,
               'wave:pde2:var:c',
               'wave:pde2:var:c'),
              (' The model PDE with a variable coefficient ',
               2,
               None,
               '___sec45'),
              (' Discretizing the variable coefficient ',
               2,
               'wave:pde2:var:c:ideas',
               'wave:pde2:var:c:ideas'),
              (' Computing the coefficient between mesh points ',
               2,
               'wave:pde2:var:c:means',
               'wave:pde2:var:c:means'),
              (' How a variable coefficient affects the stability ',
               2,
               'wave:pde2:var:c:stability',
               'wave:pde2:var:c:stability'),
              (' Neumann condition and a variable coefficient ',
               2,
               'wave:pde2:var:c:Neumann',
               'wave:pde2:var:c:Neumann'),
              (' Implementation of variable coefficients ',
               2,
               'wave:pde2:var:c:impl',
               'wave:pde2:var:c:impl'),
              (' A more general model PDE with variable coefficients ',
               2,
               None,
               '___sec51'),
              (' Generalization: damping ', 2, None, '___sec52'),
              (' Building a general 1D wave equation solver ',
               1,
               'wave:pde2:software',
               'wave:pde2:software'),
              (' User action function as a class ', 2, None, '___sec54'),
              (' Collection of initial conditions ', 2, None, '___sec55'),
              (' Exercises ', 1, None, '___sec56'),
              (' Problem 6: Explore the effect of boundary conditions ',
               2,
               'wave:exer:1D:bceffects',
               'wave:exer:1D:bceffects'),
              (' Problem 7: Explore symmetry boundary conditions ',
               2,
               'wave:exer:symmetry:bc',
               'wave:exer:symmetry:bc'),
              (' Exercise 8: Send pulse waves through a layered medium ',
               2,
               'wave:app:exer:pulse1D',
               'wave:app:exer:pulse1D'),
              (' Exercise 9: Compare discretizations of a Neumann condition ',
               2,
               None,
               '___sec60'),
              (' Analysis of the continuous and discrete solutions ',
               1,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Properties of the solution of the wave equation ',
               2,
               'wave:pde1:properties',
               'wave:pde1:properties'),
              (' More precise definition of Fourier representations ',
               2,
               'wave:pde1:Fourier',
               'wave:pde1:Fourier'),
              (' Analysis of the finite difference scheme ',
               2,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Extending the analysis to 2D and 3D ',
               2,
               'wave:pde1:analysis:2D3D',
               'wave:pde1:analysis:2D3D'),
              (' Finite difference methods for 2D and 3D wave equations ',
               1,
               'wave:2D3D',
               'wave:2D3D'),
              (' Multi-dimensional wave equations ',
               2,
               'wave:2D3D:models',
               'wave:2D3D:models'),
              (' Mesh ', 2, 'wave:2D3D:mesh', 'wave:2D3D:mesh'),
              (' Discretization ', 2, 'wave:2D3D:models', 'wave:2D3D:models'),
              (' Discretizing the PDEs ', 3, None, '___sec70'),
              (' Handling boundary conditions where is $u$ known ',
               3,
               None,
               '___sec71'),
              (' Discretizing the $\\partial u/\\partial n = 0$ ',
               3,
               None,
               '___sec72'),
              (' Implementation ', 1, 'wave:2D3D:impl', 'wave:2D3D:impl'),
              (' Scalar computations ', 2, None, '___sec74'),
              (' Domain and mesh ', 3, None, '___sec75'),
              (' Stability limit ', 3, None, '___sec76'),
              (' Solution arrays ', 3, None, '___sec77'),
              (' Computing the solution ', 3, None, '___sec78'),
              (' Vectorized computations ', 2, None, '___sec79'),
              (' Verification ', 2, None, '___sec80'),
              (' Testing a quadratic solution ', 3, None, '___sec81'),
              (' Migrating loops to Cython ', 2, None, '___sec82'),
              (' Declaring variables and annotating the code ',
               3,
               None,
               '___sec83'),
              (' Visual inspection of the C translation ',
               3,
               None,
               '___sec84'),
              (' Building the extension module ', 3, None, '___sec85'),
              (' Calling the Cython function ', 3, None, '___sec86'),
              (' Efficiency ', 3, None, '___sec87'),
              (' Migrating loops to Fortran ', 2, None, '___sec88'),
              (' The Fortran subroutine ', 3, None, '___sec89'),
              (' Building the Fortran module with f2py ',
               3,
               None,
               '___sec90'),
              (' Examining doc strings ', 3, None, '___sec91'),
              (' How to avoid array copying ', 3, None, '___sec92'),
              (' Efficiency ', 3, None, '___sec93'),
              (' Migrating loops to C via Cython ', 2, None, '___sec94'),
              (' Translating index pairs to single indices ',
               3,
               None,
               '___sec95'),
              (' The complete C code ', 3, None, '___sec96'),
              (' The Cython interface file ', 3, None, '___sec97'),
              (' Building the extension module ', 3, None, '___sec98'),
              (' Efficiency ', 3, None, '___sec99'),
              (' Migrating loops to C via f2py ', 2, None, '___sec100'),
              (' Migrating loops to C via Instant ', 2, None, '___sec101'),
              (' Migrating loops to C++ via f2py ', 2, None, '___sec102'),
              (' Using classes to implement a simulator ',
               2,
               None,
               '___sec103'),
              (' Callbacks to Python from Fortran or C ',
               2,
               None,
               '___sec104'),
              (' Exercises ', 1, None, '___sec105'),
              (' Project 10: Calculus with 2D/3D mesh functions ',
               2,
               'wave:exer:mesh3D:calculus',
               'wave:exer:mesh3D:calculus'),
              (' Applications of wave equations ', 1, 'wave:app', 'wave:app'),
              (' Waves on a string ',
               2,
               'wave:app:string',
               'wave:app:string'),
              (' Damping ', 3, None, '___sec109'),
              (' External forcing ', 3, None, '___sec110'),
              (' Modeling the tension via springs ', 3, None, '___sec111'),
              (' Waves on a membrane ',
               2,
               'wave:app:membrane',
               'wave:app:membrane'),
              (' Elastic waves in a rod ',
               2,
               'wave:app:elastic:rod',
               'wave:app:elastic:rod'),
              (' The acoustic model for seismic waves ',
               2,
               'wave:app:acoustic:seismic',
               'wave:app:acoustic:seismic'),
              (' Anisotropy ', 3, None, '___sec115'),
              (' Sound waves in liquids and gases ',
               2,
               'wave:app:sound',
               'wave:app:sound'),
              (' Spherical waves ',
               2,
               'wave:app:spherical',
               'wave:app:spherical'),
              (' The linear shallow water equations ',
               2,
               'wave:app:sw:2D',
               'wave:app:sw:2D'),
              (' Wind drag on the surface ', 3, None, '___sec119'),
              (' Bottom drag ', 3, None, '___sec120'),
              (" Effect of the Earth's rotation ", 3, None, '___sec121'),
              (' Waves in blood vessels ',
               2,
               'wave:app:blood',
               'wave:app:blood'),
              (' Reduction to standard wave equation ', 3, None, '___sec123'),
              (' Electromagnetic waves ',
               2,
               'wave:app:light',
               'wave:app:light'),
              (' Exercises ', 1, 'wave:app:exer', 'wave:app:exer'),
              (' Exercise 11: Simulate waves on a non-homogeneous string ',
               2,
               'wave:app:exer:string:discont',
               'wave:app:exer:string:discont'),
              (' Exercise 12: Simulate damped waves on a string ',
               2,
               'wave:app:exer:string:damping',
               'wave:app:exer:string:damping'),
              (' Exercise 13: Simulate elastic waves in a rod ',
               2,
               'wave:app:exer:rod',
               'wave:app:exer:rod'),
              (' Exercise 14: Explain why numerical noise occurs ',
               2,
               'wave:app:exer:pulse1D:analysis',
               'wave:app:exer:pulse1D:analysis'),
              (' Exercise 15: Investigate harmonic averaging in a 1D model ',
               2,
               'wave:app:exer:pulse1D:harmonic',
               'wave:app:exer:pulse1D:harmonic'),
              (' Exercise 16: Test the efficiency of compiled loops in 3D ',
               2,
               'wave:exer:3D:f77:cy:efficiency',
               'wave:exer:3D:f77:cy:efficiency'),
              (' Exercise 17: Earthquake-generated tsunami in a 1D model ',
               2,
               'wave:app:exer:tsunami1D',
               'wave:app:exer:tsunami1D'),
              (' Exercise 18: Implement an open boundary condition ',
               2,
               'wave:app:exer:tsunami1D:radiation',
               'wave:app:exer:tsunami1D:radiation'),
              (' Exercise 19: Earthquake-generated tsunami over a subsea hill ',
               2,
               'wave:app:exer:tsunami1D:hill',
               'wave:app:exer:tsunami1D:hill'),
              (' Exercise 20: Implement Neumann conditions in 2D ',
               2,
               'wave:app:exer:wave2D:Neumann',
               'wave:app:exer:wave2D:Neumann'),
              (' Exercise 21: Implement a convergence test for a 2D code ',
               2,
               None,
               '___sec136'),
              (' Exercise 22: Earthquake-generated tsunami over a 3D hill ',
               2,
               'wave:app:exer:tsunami2D:hill',
               'wave:app:exer:tsunami2D:hill'),
              (' Exercise 23: Implement loops in compiled languages ',
               2,
               'wave:app:exer:tsunami2D:hill:compiled',
               'wave:app:exer:tsunami2D:hill:compiled'),
              (' Exercise 24: Write a complete program in Fortran or C ',
               2,
               'wave:app:exer:tsunami2D:hill:compiled2',
               'wave:app:exer:tsunami2D:hill:compiled2'),
              (' Exercise 25: Investigate Matplotlib for visualization ',
               2,
               'wave:app:exer:tsunami:hill:viz:matplotlib',
               'wave:app:exer:tsunami:hill:viz:matplotlib'),
              (' Exercise 26: Investigate visualization packages ',
               2,
               'wave:app:exer:tsunami:hill:viz:packages',
               'wave:app:exer:tsunami:hill:viz:packages'),
              (' Exercise 27: Investigate harmonic vs arithmetic mean ',
               2,
               'wave:app:exer:tsunami:hill:harmonic',
               'wave:app:exer:tsunami:hill:harmonic'),
              (' Exercise 28: Simulate seismic waves in 2D ',
               2,
               'wave:app:exer:seismic2D',
               'wave:app:exer:seismic2D'),
              (' Project 29: Modeling 3D acoustic waves in a room ',
               2,
               'wave:app:exer:acoustics',
               'wave:app:exer:acoustics'),
              (' Project 30: Solve a 1D transport equation ',
               2,
               'wave:app:exer:advec1D',
               'wave:app:exer:advec1D')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0002"></a>
<!-- begin top navigation -->
<a href="._part0001_main_wave-solarized.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0003_main_wave-solarized.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end top navigation -->

<p>
<!-- !split -->

<h2>Implementation <a name="wave:pde1:impl"></a></h2>

<p>
This section present the complete computational algorithm, its
implementation in Python code, animation of the solution,
and verification of the implementation.

<p>
A real implementation of the basic computational algorithm
from the sections <a href="._part0001_main_wave-solarized.html#wave:string:alg">Formulating a recursive algorithm</a> and <a href="._part0001_main_wave-solarized.html#wave:string:impl">Sketch of an implementation</a> can be
encapsulated in a function,
taking all the input data for the problem as arguments.  The physical
input data consists of \( c \), \( I(x) \), \( V(x) \), \( f(x,t) \), \( L \), and \( T \).
The numerical input is the mesh parameters \( \Delta t \) and \( \Delta x \).
One possibility is to specify \( N_x \) and the Courant number \( C=c\Delta
t/\Delta x \).  The latter is convenient to prescribe instead of \( \Delta
t \) when performing numerical investigations, because the numerical
accuracy depends directly on \( C \).

<p>
The solution at all spatial points at a new time level is stored in an
array <code>u</code> (of length \( N_x+1 \)). We need to decide what do to with
this solution, e.g., visualize the curve, analyze the values, or write
the array to file for later use. The decision what to do is left to
the user in a suppled function
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">user_action</span>(u, x, t, n):
</pre></div>
<p>
where <code>u</code> is the solution at the spatial points <code>x</code> at time <code>t[n]</code>.

<h3>Making a solver function  <a name="___sec16"></a></h3>

<p>
A first attempt at a solver function is listed below.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, V, f, c, L, Nx, C, T, user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u_tt=c^2*u_xx + f on (0,L)x(0,T].&quot;&quot;&quot;</span>
    x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)     <span style="color: #228B22"># Mesh points in space</span>
    dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
    dt = C*dx/c
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>) <span style="color: #228B22"># Mesh points in time</span>
    C2 = C**<span style="color: #B452CD">2</span>                    <span style="color: #228B22"># Help variable in the scheme</span>
    <span style="color: #8B008B; font-weight: bold">if</span> f <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> f == <span style="color: #B452CD">0</span> :
        f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">if</span> V <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> V == <span style="color: #B452CD">0</span>:
        V = <span style="color: #8B008B; font-weight: bold">lambda</span> x: <span style="color: #B452CD">0</span>

    u   = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution array at new time level</span>
    u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution at 1 time level back</span>
    u_2 = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution at 2 time levels back</span>

    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>;  t0 = time.clock()  <span style="color: #228B22"># for measuring CPU time</span>

    <span style="color: #228B22"># Load initial condition into u_1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,Nx+<span style="color: #B452CD">1</span>):
        u_1[i] = I(x[i])

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u_1, x, t, <span style="color: #B452CD">0</span>)

    <span style="color: #228B22"># Special formula for first time step</span>
    n = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = u_1[i] + dt*V(x[i]) + \ 
               <span style="color: #B452CD">0.5</span>*C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
               <span style="color: #B452CD">0.5</span>*dt**<span style="color: #B452CD">2</span>*f(x[i], t[n])
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u, x, t, <span style="color: #B452CD">1</span>)

    <span style="color: #228B22"># Switch variables before next step</span>
    u_2[:], u_1[:] = u_1, u

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        <span style="color: #228B22"># Update all inner points at time t[n+1]</span>
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
            u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
                     C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
                     dt**<span style="color: #B452CD">2</span>*f(x[i], t[n])

        <span style="color: #228B22"># Insert boundary conditions</span>
        u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>
        <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            <span style="color: #8B008B; font-weight: bold">if</span> user_action(u, x, t, n+<span style="color: #B452CD">1</span>):
                <span style="color: #8B008B; font-weight: bold">break</span>

        <span style="color: #228B22"># Switch variables before next step</span>
        u_2[:], u_1[:] = u_1, u

    cpu_time = t0 - time.clock()
    <span style="color: #8B008B; font-weight: bold">return</span> u, x, t, cpu_time
</pre></div>
<p>
<!-- Too trivial here: -->
<!-- Checking that a solution \( u^n_i \) stays constant throughout some -->
<!-- time steps is often of considerable help in tracking down bugs -->
<!-- in an implementation. A constant solution \( \uex = Q \) fulfills -->
<!-- the PDE problem <a href="._part0001_main_wave-solarized.html#mjx-eqn-12">(12)</a>-<a href="._part0001_main_wave-solarized.html#mjx-eqn-16">(16)</a> -->
<!-- if \( I(x)=Q \), \( V=0 \), \( u(0,t)=u(L,t)=Q \), and \( f=0 \) -->

<h3>Verification: exact quadratic solution  <a name="___sec17"></a></h3>

<p>
We use the test problem derived in the section <a href="._part0001_main_wave-solarized.html#wave:pde2:fd">A slightly generalized model problem</a> for
verification. Here is a function realizing this verification as a
<!-- cite -->
nose test:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">nose.tools</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">nt</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Check that u(x,t)=x(L-x)(1+t/2) is exactly reproduced.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(x, t):
        <span style="color: #8B008B; font-weight: bold">return</span> x*(L-x)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> exact_solution(x, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">V</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*exact_solution(x, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x, t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)*c**<span style="color: #B452CD">2</span>

    L = <span style="color: #B452CD">2.5</span>
    c = <span style="color: #B452CD">1.5</span>
    Nx = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># Very coarse mesh</span>
    C = <span style="color: #B452CD">0.75</span>
    T = <span style="color: #B452CD">18</span>

    u, x, t, cpu = solver(I, V, f, c, L, Nx, C, T)
    u_e = exact_solution(x, t[-<span style="color: #B452CD">1</span>])
    diff = <span style="color: #658b00">abs</span>(u - u_e).max()
    nt.assert_almost_equal(diff, <span style="color: #B452CD">0</span>, places=<span style="color: #B452CD">14</span>)
</pre></div>

<h3>Visualization: animating \( u(x,t) \)  <a name="___sec18"></a></h3>

<p>
Now that we have verified the implementation it is time to do a
real computation where we also display the evolution of the waves
on the screen.

<h4>Visualization via SciTools  <a name="___sec19"></a></h4>

<p>
The following <code>viz</code> function defines a <code>user_action</code>
callback function for plotting the solution at each time level:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">viz</span>(I, V, f, c, L, Nx, C, T, umin, umax, animate=<span style="color: #658b00">True</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Run solver and visualize u at each time level.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>, <span style="color: #008b45; text-decoration: underline">glob</span>, <span style="color: #008b45; text-decoration: underline">os</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_u</span>(u, x, t, n):
        <span style="color: #CD5555">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
        plt.plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>,
                 xlabel=<span style="color: #CD5555">&#39;x&#39;</span>, ylabel=<span style="color: #CD5555">&#39;u&#39;</span>,
                 axis=[<span style="color: #B452CD">0</span>, L, umin, umax],
                 title=<span style="color: #CD5555">&#39;t=%f&#39;</span> % t[n], show=<span style="color: #658b00">True</span>)
        <span style="color: #228B22"># Let the initial condition stay on the screen for 2</span>
        <span style="color: #228B22"># seconds, else insert a pause of 0.2 s between each plot</span>
        time.sleep(<span style="color: #B452CD">2</span>) <span style="color: #8B008B; font-weight: bold">if</span> t[n] == <span style="color: #B452CD">0</span> <span style="color: #8B008B; font-weight: bold">else</span> time.sleep(<span style="color: #B452CD">0.2</span>)
        plt.savefig(<span style="color: #CD5555">&#39;frame_%04d.png&#39;</span> % n)  <span style="color: #228B22"># for movie making</span>

    <span style="color: #228B22"># Clean up old movie frames</span>
    <span style="color: #8B008B; font-weight: bold">for</span> filename <span style="color: #8B008B">in</span> glob.glob(<span style="color: #CD5555">&#39;frame_*.png&#39;</span>):
        os.remove(filename)

    user_action = plot_u <span style="color: #8B008B; font-weight: bold">if</span> animate <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">None</span>
    u, x, t, cpu = solver(I, V, f, c, L, Nx, C, T, user_action)

    <span style="color: #228B22"># Make movie files</span>
    fps = <span style="color: #B452CD">4</span>  <span style="color: #228B22"># Frames per second</span>
    plt.movie(<span style="color: #CD5555">&#39;frame_*.png&#39;</span>, encoder=<span style="color: #CD5555">&#39;html&#39;</span>, fps=fps,
              output_file=<span style="color: #CD5555">&#39;movie.html&#39;</span>)
    codec2ext = <span style="color: #658b00">dict</span>(flv=<span style="color: #CD5555">&#39;flv&#39;</span>, libx64=<span style="color: #CD5555">&#39;mp4&#39;</span>, libvpx=<span style="color: #CD5555">&#39;webm&#39;</span>,
                     libtheora=<span style="color: #CD5555">&#39;ogg&#39;</span>)
    filespec = <span style="color: #CD5555">&#39;frame_%04d.png&#39;</span>
    movie_program = <span style="color: #CD5555">&#39;avconv&#39;</span>  <span style="color: #228B22"># or &#39;ffmpeg&#39;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> codec <span style="color: #8B008B">in</span> codec2ext:
        ext = codec2ext[codec]
        cmd = <span style="color: #CD5555">&#39;%(movie_program)s -r %(fps)d -i %(filespec)s &#39;</span>\ 
              <span style="color: #CD5555">&#39;-vcodec %(codec)s movie.%(ext)s&#39;</span> % <span style="color: #658b00">vars</span>()
        os.system(cmd)
</pre></div>
<p>
A function inside another function, like <code>plot_u</code> in the above code
segment, has access to <em>and remembers</em> all the local variables
in the surrounding code inside the <code>viz</code> function (!). This is known
in computer science as a <em>closure</em> and is very convenient to
program with. For example,
the <code>plt</code> and <code>time</code> modules defined outside <code>plot_u</code> are accessible for
<code>plot_u</code> when
the function is called (as <code>user_action</code>) in the <code>solver</code> function.
Some may think, however, that a class instead of a closure is a cleaner
and easier-to-understand implementation of
the user action function, see the section <a href="._part0003_main_wave-solarized.html#wave:pde2:software">Building a general 1D wave equation solver</a>.

<h4>Making movie files  <a name="___sec20"></a></h4>

<p>
Several hardcopies of the animation are made from the
<code>frame_*.png</code> files. The first movie, made by the SciTools function
<code>plt.movie</code> creates a <code>movie.html</code> file with a movie player
for displaying the <code>frame_*.png</code> files. This movie player can
be generated from the command line too

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; scitools movie <span style="color: #00688B">encoder</span>=html <span style="color: #00688B">output_file</span>=movie.html <span style="color: #CD5555">\ </span>
          <span style="color: #00688B">fps</span>=4 frame_*.png
</pre></div>
<p>
We also use
the <code>avconv</code> (or <code>ffmpeg</code>) programs to make movie files in modern
formats: Flash, MP4, Webm, and Ogg.
A typical <code>avconv</code> (or <code>ffmpeg</code>) commands for creating a movie file
look like

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; avconv -r 4 -i frame_%04d.png -vcodec libtheora movie.ogg
</pre></div>
<p>
The different formats require
different encoders to be installed: Flash applies <code>flv</code>,
WebM applies <code>libvpx</code>, and MP4 applies <code>libx64</code>.
Players like <code>vlc</code>, <code>mplayer</code>,
<code>gxine</code>, and <code>totem</code> can be used to play these movie files.

<p>
Note that padding the frame counter with zeros in the <code>frame_*.png</code>
files, as specified by the <code>%04d</code> format, is essential so that the wildcard
notation <code>frame_*.png</code> expands to the correct set of files.

<h4>Skipping frames for animation speed  <a name="___sec21"></a></h4>

<p>
Sometimes the time step is small and \( T \) is large, leading to an
inconveniently large number of plot files and a slow animation on the
screen. The solution to such a problem is to decide on a total number
of frames in the animation, <code>num_frames</code>, and plot the solution only at
every <code>every</code> frame. The total number of time levels (i.e., maximum
possible number of frames) is the length of <code>t</code>, <code>t.size</code>, and if we
want <code>num_frames</code>, we need to plot every <code>t.size/num_frames</code> frame:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">every = <span style="color: #658b00">int</span>(t.size/<span style="color: #658b00">float</span>(num_frames))
<span style="color: #8B008B; font-weight: bold">if</span> n % every == <span style="color: #B452CD">0</span> <span style="color: #8B008B">or</span> n == t.size-<span style="color: #B452CD">1</span>:
    st.plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>, ...)
</pre></div>
<p>
The initial condition (<code>n=0</code>) is natural to include,
and as <code>n % every == 0</code> will very seldom be true for the
very final frame, we also ensure that <code>n == t.size-1</code> and hence
the final frame is included.

<p>
A simple choice of numbers may illustrate the formulas: say we have
801 frames in total (<code>t.size</code>) and we allow only 60 frames to be
plotted. Then we need to plot every 801/60 frame, which with integer
division yields 13 as <code>every</code>. Using the mod function, <code>n % every</code>,
this operation is zero every time <code>n</code> can be divided by 13 without a
remainder. That is, the <code>if</code> test is true when <code>n</code> equals \( 0, 13, 26,
39, ..., 780, 801 \). The associated code is included in the <code>plot_u</code>
function in the file <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_u0_sv.py"><tt>wave1D_u0_sv.py</tt></a>.

<h4>Visualization via Matplotlib  <a name="___sec22"></a></h4>

<p>
The previous code based on the <code>plot</code> interface from <code>scitools.std</code>
can be run with Matplotlib as the visualization backend, but if one
desires to program directly with Matplotlib, quite different code
is needed. Matplotlib's interactive mode must be turned on:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
plt.ion()  <span style="color: #228B22"># interactive mode on</span>
</pre></div>
<p>
The most
commonly used animation technique with Matplotlib
is to update the data in the plot at each time level:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Make a first plot</span>
lines = plt.plot(t, u)
<span style="color: #228B22"># call plt.axis, plt.xlabel, plt.ylabel, etc. as desired</span>

<span style="color: #228B22"># At later time levels</span>
lines[<span style="color: #B452CD">0</span>].set_ydata(u)
plt.legend(<span style="color: #CD5555">&#39;t=%g&#39;</span> % t[n])
plt.draw()  <span style="color: #228B22"># make updated plot</span>
plt.savefig(...)
</pre></div>
<p>
An alternative is to rebuild the plot at every time level:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">plt.clf()        <span style="color: #228B22"># delete any previous curve(s)</span>
plt.axis([...])
plt.plot(t, u)
<span style="color: #228B22"># plt.xlabel, plt.legend and other decorations</span>
plt.draw()
plt.savefig(...)
</pre></div>
<p>
Many prefer to work with figure and axis objects as in MATLAB:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">fig = plt.figure()
...
fig.clf()
ax = fig.gca()
ax.axis(...)
ax.plot(t, u)
<span style="color: #228B22"># ax.set_xlabel, ax.legend and other decorations</span>
plt.draw()
fig.savefig(...)
</pre></div>

<h3>Running a case <a name="wave:pde1:guitar:data"></a></h3>

<p>
The first demo of our 1D wave equation solver concerns vibrations of a
string that is initially deformed to a triangular shape, like when picking
a guitar string:

<p>
$$
\begin{equation}
I(x) = \left\lbrace
\begin{array}{ll}
ax/x_0, & x < x_0,\\ 
a(L-x)/(L-x_0), & \hbox{otherwise}
\end{array}\right.
\tag{21}
\end{equation}
$$

We choose \( L=75 \) cm, \( x_0=0.8L \), \( a=5 \) mm, \( N_x=50 \), and a time frequency
\( \nu = 440 \) Hz. The relation between the wave speed \( c \) and \( \nu \) is
\( c=\nu\lambda \), where \( \lambda \) is the wavelength, taken as \( 2L \) because
the longest wave on the string form half a wavelength. There is no
external force, so \( f=0 \), and the string is at rest initially so
that \( V=0 \). A function setting
these physical parameters and calling <code>viz</code> for this case goes as follows:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">guitar</span>(C):
    <span style="color: #CD5555">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    L = <span style="color: #B452CD">0.75</span>
    x0 = <span style="color: #B452CD">0.8</span>*L
    a = <span style="color: #B452CD">0.005</span>
    freq = <span style="color: #B452CD">440</span>
    wavelength = <span style="color: #B452CD">2</span>*L
    c = freq*wavelength
    omega = <span style="color: #B452CD">2</span>*pi*freq
    num_periods = <span style="color: #B452CD">1</span>
    T = <span style="color: #B452CD">2</span>*pi/omega*num_periods
    Nx = <span style="color: #B452CD">50</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> a*x/x0 <span style="color: #8B008B; font-weight: bold">if</span> x &lt; x0 <span style="color: #8B008B; font-weight: bold">else</span> a/(L-x0)*(L-x)

    umin = -<span style="color: #B452CD">1.2</span>*a;  umax = -umin
    cpu = viz(I, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0</span>, c, L, Nx, C, T, umin, umax, animate=<span style="color: #658b00">True</span>)
</pre></div>
<p>
The associated program has the name <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_u0_s.py"><tt>wave1D_u0_s.py</tt></a>. Run
the program and watch the <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/guitar_C0.8/index.html">movie of the vibrating string</a>.

<h3>The benefits of scaling  <a name="___sec24"></a></h3>

<p>
The previous example demonstrated that quite some work is needed
with establishing relevant physical parameters for a case. By <em>scaling</em>
the mathematical problem we can often reduce the need to estimate
physical parameters dramatically. A scaling consists of introducing new
independent and dependent variables, with the aim that the absolute
value of these vary between 0 and 1:
$$ \bar x = \frac{x}{L},\quad \bar t = \frac{c}{L}t,\quad
\bar u = \frac{u}{a}
\thinspace .
$$

Replacing old by new variables in the PDE, using \( f=0 \),
and dropping the bars, results in the <em>scaled equation</em>
\( u_{tt} = u_{xx} \). This is simply
the original equation with \( c=1 \). The initial condition
corresponds to <a href="#mjx-eqn-21">(21)</a> with \( a=1 \), \( L=1 \), and
\( x_0\in [0,1] \). This means that we only need to decide on \( x_0 \), because
the scaled problem corresponds to setting all
other parameters to unity! In the code we can just set
<code>a=c=L=1</code>, <code>x0=0.8</code>, and there is no need to calculate with
wavelengths and frequencies to estimate \( c \).

<p>
The only non-trivial parameter to estimate in the scaled problem
is the final end time of the simulation, or more precisely, how it relates
to periods in periodic solutions in time, since we often want to
express the end time as a certain number of periods.
Suppose as \( u \) behaves as \( \sin (\omega t) \) in time in variables
with dimension. The corresponding period is \( P=2\pi/\omega \).
The frequency \( \omega \) is related to the wavelength \( \lambda \) of the waves
through the relations \( \omega = kc \) and \( k=2\pi/\lambda \), giving
\( \omega = 2\pi c/\lambda \) and \( P=\lambda/c \). It remains to estimate \( \lambda \).
With \( u(x,t)=F(x)\sin\omega t \) we find from \( u_{tt}=c^2u_{xx} \)
that \( c^2F'' + \omega^2F=0 \), and the boundary conditions demand
\( F(0)=F(L)=0 \). The solution is \( F(x)=\sin(x\pi/L) \), which has
wavelength \( \lambda = 2\pi/(\pi/L)=2L \). One period is therefore
given by \( P=2L/c \). The dimensionless period is \( \bar P=Pc/L = 2 \).

<h2>Vectorization  <a name="___sec25"></a></h2>

<p>
The computational algorithm for solving the wave equation visits one
mesh point at a time and evaluates a formula for the new value \( u_i^{n+1} \)
at
that point. Technically, this is implemented by a loop over array
elements in a program. Such loops may run slowly in Python (and
similar interpreted languages such as R and MATLAB).
One technique for speeding up loops is to
perform operations on entire arrays instead of working with one element
at a time. This is referred to as <em>vectorization</em>, <em>vector computing</em>,
or <em>array computing</em>.
Operations on whole arrays are possible if the computations
involving each element is independent of each other and therefore can,
at least in principle, be performed simultaneously.
Vectorization not only speeds up the code on serial computers, but it
also makes it easy to exploit parallel computing.

<h3>Operations on slices of arrays  <a name="___sec26"></a></h3>

<p>
Efficient computing with <code>numpy</code> arrays demands that we avoid loops
and compute with entire arrays at once (or at least large portions of them).
Consider this calculation of differences \( d_i = u_{i+1}-u_i \):
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">n = u.size
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, n-<span style="color: #B452CD">1</span>):
    d[i] = u[i+<span style="color: #B452CD">1</span>] - u[i]
</pre></div>
<p>
All the differences here are independent of each other.
The computation of <code>d</code> can therefore alternatively be done by
subtracting the array \( (u_0,u_1,\ldots,u_{n-1}) \) from
the array where the elements are shifted one index upwards:
\( (u_1,u_2,\ldots,u_n) \), see Figure <a href="#wave:pde1:vec:fig1">3</a>.
The former subset of the array can be
expressed by <code>u[0:n-1]</code>,
<code>u[0:-1]</code>, or just
<code>u[:-1]</code>, meaning from index 0 up to,
but not including, the last element (<code>-1</code>). The latter subset
is obtained by <code>u[1:n]</code> or <code>u[1:]</code>,
meaning from index 1 and the rest of the array.
The computation of <code>d</code> can now be done without an explicit Python loop:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">d = u[<span style="color: #B452CD">1</span>:] - u[:-<span style="color: #B452CD">1</span>]
</pre></div>
<p>
or with explicit limits if desired:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">d = u[<span style="color: #B452CD">1</span>:n] - u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">1</span>]
</pre></div>
<p>
Indices with a colon, going from an index to (but not including) another
index are called <em>slices</em>. With <code>numpy</code> arrays, the computations
are still done by loops, but in efficient, compiled, highly optimized code
in C or Fortran. Such array operations can also easily be distributed
among many processors on parallel computers. We say that the <em>scalar code</em>
above, working on an element (a scalar) at a time, has been replaced by
an equivalent <em>vectorized code</em>. The process of vectorizing code is called
<em>vectorization</em>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Illustration of subtracting two slices of two arrays. <a name="wave:pde1:vec:fig1"></a> </p></center>
<p><img src="fig-wave/vectorized_diff.png" align="bottom" width=400,></p>
</center>

<p>
<div class="alert alert-block alert-question alert-text-normal"><b>Test the understanding.</b>
Newcomers to vectorization are encouraged to choose
a small array <code>u</code>, say with five elements,
and simulate with pen and paper
both the loop version and the vectorized version.
</div>
<p>
Finite difference schemes basically contains differences between array
elements with shifted indices. Consider the updating formula

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>):
    u2[i] = u[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u[i] + u[i+<span style="color: #B452CD">1</span>]
</pre></div>
<p>
The vectorization consists of replacing the loop by arithmetics on
slices of arrays of length <code>n-2</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2 = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:]
u2 = u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:n]   <span style="color: #228B22"># alternative</span>
</pre></div>
<p>
Note that <code>u2</code> here gets length <code>n-2</code>. If <code>u2</code> is already an array of
length <code>n</code> and we want to use the formula to update all the "inner"
elements of <code>u2</code>, as we will when solving a 1D wave equation, we can write
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]  = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:]
u2[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:n]   <span style="color: #228B22"># alternative</span>
</pre></div>
<p>
Pen and paper calculations with a small array will demonstrate what is
actually going on. The expression on the right-hand side are done in the
following steps, involving temporary arrays with intermediate results,
since we can only work with two arrays at a time in
arithmetic expressions:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">temp1 = <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]
temp2 = u[<span style="color: #B452CD">0</span>:-<span style="color: #B452CD">2</span>] - temp1
temp3 = temp2 + u[<span style="color: #B452CD">2</span>:]
u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = temp3
</pre></div>
<p>
We can extend the previous example to a formula with an additional term computed
by calling a function:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x):
    <span style="color: #8B008B; font-weight: bold">return</span> x**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>):
    u2[i] = u[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u[i] + u[i+<span style="color: #B452CD">1</span>] + f(x[i])
</pre></div>
<p>
Assuming <code>u2</code>, <code>u</code>, and <code>x</code> all have length <code>n</code>, the vectorized
version becomes
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:] + f(x[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>])
</pre></div>

<h3>Finite difference schemes expressed as slices  <a name="___sec27"></a></h3>

<p>
We now have the necessary tools to vectorize the algorithm for
the wave equation. There are three loops: one for the initial condition,
one for the first time step, and finally the loop that is repeated for
all subsequent time levels. Since only the latter is repeated a potentially
large number of times, we limit the efforts of vectorizing the code
to this loop:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = <span style="color: #B452CD">2</span>*u_1[i] - u_2[i] + \ 
           C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])
</pre></div>
<p>
The vectorized version becomes

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = - u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
          C2*(u_1[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">2</span>:])
</pre></div>
<p>
or
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:Nx] = <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:Nx]- u_2[<span style="color: #B452CD">1</span>:Nx] + \ 
          C2*(u_1[<span style="color: #B452CD">0</span>:Nx-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:Nx] + u_1[<span style="color: #B452CD">2</span>:Nx+<span style="color: #B452CD">1</span>])
</pre></div>
<p>
<!-- We may vectorize the other loops regarding the initial condition and -->
<!-- the first time step, but the effect will hardly be -->
<!-- noticeable in long time simulations. -->

<p>
The program
<a href="http://tinyurl.com/jvzzcfn/wave/wave1D_u0_sv.py"><tt>wave1D_u0_sv.py</tt></a>
contains a new version of the function <code>solver</code> where both the scalar
and the vectorized loops are included (the argument <code>version</code> is
set to <code>scalar</code> or <code>vectorized</code>, respectively).

<h3>Verification  <a name="___sec28"></a></h3>

<p>
We may reuse the quadratic solution \( \uex(x,t)=x(L-x)(1+\frac{1}{2}t) \) for
verifying also the vectorized code. A nose test can now test
both the scalar and the vectorized version. Moreover, we may
use a <code>user_action</code> function that compares the computed and exact
solution at each time level and performs a test:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Check the scalar and vectorized versions work for</span>
<span style="color: #CD5555">    a quadratic u(x,t)=x(L-x)(1+t/2) that is exactly reproduced.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># The following function must work for x as array or scalar</span>
    exact_solution = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: x*(L - x)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)
    I = <span style="color: #8B008B; font-weight: bold">lambda</span> x: exact_solution(x, <span style="color: #B452CD">0</span>)
    V = <span style="color: #8B008B; font-weight: bold">lambda</span> x: <span style="color: #B452CD">0.5</span>*exact_solution(x, <span style="color: #B452CD">0</span>)
    <span style="color: #228B22"># f is a scalar (zeros_like(x) works for scalar x too)</span>
    f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: zeros_like(x) + <span style="color: #B452CD">2</span>*c**<span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    L = <span style="color: #B452CD">2.5</span>
    c = <span style="color: #B452CD">1.5</span>
    Nx = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># Very coarse mesh</span>
    C = <span style="color: #B452CD">1</span>
    T = <span style="color: #B452CD">18</span>  <span style="color: #228B22"># Long time integration</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assert_no_error</span>(u, x, t, n):
        u_e = exact_solution(x, t[n])
        diff = <span style="color: #658b00">abs</span>(u - u_e).max()
        nt.assert_almost_equal(diff, <span style="color: #B452CD">0</span>, places=<span style="color: #B452CD">13</span>)

    solver(I, V, f, c, L, Nx, C, T,
           user_action=assert_no_error, version=<span style="color: #CD5555">&#39;scalar&#39;</span>)
    solver(I, V, f, c, L, Nx, C, T,
           user_action=assert_no_error, version=<span style="color: #CD5555">&#39;vectorized&#39;</span>)
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Lambda functions.</b>
The code segment above demonstrates how to achieve very
compact code with the use of lambda functions for the various
input parameters that require a Python function. In essence,

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #fbeed5"><pre style="line-height: 125%">f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: L*(x-t)**<span style="color: #B452CD">2</span>
</pre></div>
<p>
is equivalent to

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #fbeed5"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x, t):
    <span style="color: #8B008B; font-weight: bold">return</span> L(x-t)**<span style="color: #B452CD">2</span>
</pre></div>
<p>
Note that lambda functions can just contain a single expression and no
statements.

<p>
One advantage with lambda functions is that they can be used directly
in calls:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #fbeed5"><pre style="line-height: 125%">solver(I=<span style="color: #8B008B; font-weight: bold">lambda</span> x: sin(pi*x/L), V=<span style="color: #B452CD">0</span>, f=<span style="color: #B452CD">0</span>, ...)
</pre></div>
<p>
</div>
<h3>Efficiency measurements  <a name="___sec29"></a></h3>

<p>
Running the <code>wave1D_u0_sv.py</code> code with the previous string vibration example
for \( N_x=50,100,200,400,800 \) and measuring the CPU time
(see the <code>run_efficiency_experiments</code> function), shows that the vectorized
code runs substantially faster: the scalar code uses approximately
a factor \( N_x/5 \) more time!

<p>
<!-- ===== Profiling code ===== better in 2D -->

<p>
<!-- ======= Storing simulation data ======= -->
<!-- plain files, NUumPyDB, XDMF, joblib, exercises with retrieval and comparison -->

<p>
<!-- ======= Programming with classes ======= -->
<!-- can integrate data storage and check pointing, or maybe do it later in 2D -->
<!-- with Cython, Fortran and C? Might have a very simple version here and -->
<!-- then a new, more sophisticated version in 2D. -->
<!-- Think about grabbing out all soft eng and -->
<!-- present in short course. Need to be self-contained. -->

<h2>Exercises  <a name="___sec30"></a></h2>

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 1: Simulate a standing wave <a name="wave:exer:standingwave"></a></h3>

<p>
The purpose of this exercise is to simulate standing waves on \( [0,L] \)
and illustrate the error in the simulation.
Standing waves arise from an initial condition

<p>
$$ u(x,0)= A \sin\left(\frac{pi}{L}mx\right),$$

where \( m \) is an integer and \( A \) is a freely chosen amplitude.
The corresponding exact solution can be computed and reads

<p>
$$ \uex(x,t) =  A\sin\left(\frac{\pi}{L}mx\right)
\cos\left(\frac{\pi}{L}mct\right)\ts
$$

Make an animation where you show
both the numerical and the exact solution, or the error. It is of
interest to see how the error develops in time.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Import the <code>solver</code> function <code>wave1D_u0_s.py</code> into a new file
<code>wave_standing.py</code>. Reimplement the <code>viz</code> function in this file
that plots either the numerical and exact solution, or the error,
instead of just the numerical solution.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>wave_standing.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 2: Add storage of solution in a user action function <a name="wave:exer:store:list"></a></h3>

<p>
Extend the <code>plot_u</code> function in the file <code>wave1D_u0_s.py</code> to also store
the solutions <code>u</code> in a list.
To this end, declare <code>all_u</code> as
an empty list in the <code>viz</code> function, outside <code>plot_u</code>, and perform
an append operation inside the <code>plot_u</code> function. Note that a
function, like <code>plot_u</code>, inside another function, like <code>viz</code>,
remembers all local variables in <code>viz</code> function, including <code>all_u</code>,
even when <code>plot_u</code> is called (as <code>user_action</code>) in the <code>solver</code> function.
Test both <code>all_u.append(u)</code> and <code>all_u.append(u.copy())</code>.
Why does one of these constructions fail to store the solution correctly?
Let the <code>viz</code> function return the <code>all_u</code> list
converted to a two-dimensional <code>numpy</code> array.
Filename: <code>wave1D_u0_s_store.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 3: Use a class for the user action function <a name="wave:exer:store:list:class"></a></h3>

<p>
Redo <a href="#wave:exer:store:list">Exercise 2: Add storage of solution in a user action function</a> using a class for the
user action function. That is, define a class <code>Action</code> where
the <code>all_u</code> list is an attribute, and implement the user action
function as a method (the special method <code>__call__</code> is a natural
choice). The class versions avoids that the user action function
depends on parameters defined outside the function (such as <code>all_u</code>
in <a href="#wave:exer:store:list">Exercise 2: Add storage of solution in a user action function</a>).
Filename: <code>wave1D_u0_s2c.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 4: Compare several Courant numbers in one movie <a name="wave:exer:multiple:C"></a></h3>

<p>
The goal of this exercise is to make movies where several curves,
corresponding to different Courant numbers, are visualized.
Import the <code>solver</code> function from the <code>wave1D_u0_s</code> movie
in a new file <code>wave_compare.py</code>. Reimplement the <code>viz</code> function
such that it can take a list of <code>C</code> values as argument
and create a movie with solutions corresponding to the given <code>C</code>
values. The <code>plot_u</code> function must be changed to store the solution
in an array (see <a href="#wave:exer:store:list">Exercise 2: Add storage of solution in a user action function</a> or
<a href="#wave:exer:store:list:class">Exercise 3: Use a class for the user action function</a> for details), <code>solver</code> must be
computed for each value of the Courant number, and finally
one must run through each time step and plot all the spatial
solution curves in one figure and store it in a file.

<p>
The challenge in such a visualization is to ensure that the curves in
one plot corresponds to the same time point. The easiest remedy is to
keep the time and space resolution constant and change the wave
velocity \( c \) to change the Courant number.
Filename: <code>wave_numerics_comparison.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Project 5: Calculus with 1D mesh functions <a name="wave:exer:mesh1D:calculus"></a></h3>

<p>
This project explores integration and differentiation of
mesh functions, both with scalar and vectorized implementations.
We are given a mesh function \( f_i \) on a spatial one-dimensional
mesh \( x_i=i\Delta x \), \( i=0,\ldots,N_x \), over the interval \( [a,b] \).

<p>
<b>a)</b>
Define the discrete derivative of \( f_i \) by using centered
differences at internal mesh points and one-sided differences
at the end points. Implement a scalar version of
the computation in a Python function and supply a nose test
for the linear case \( f(x)=4x-2.5 \) where the discrete derivative should
be exact.

<p>
<b>b)</b>
Vectorize the implementation of the discrete derivative.
Extend the nose test to check the validity of the implementation.

<p>
<b>c)</b>
To compute the discrete integral \( F_i \) of \( f_i \), we assume that
the mesh function \( f_i \) varies linearly between the mesh points.
Let \( f(x) \) be such a linear interpolant of \( f_i \). We then
have

<p>
$$ F_i = \int_{x_0}^{x_i} f(x) dx\ts$$

The exact integral of a piecewise linear function \( f(x) \) is
given by the Trapezoidal rule. S
how that if \( F_{i} \) is already computed, we can find \( F_{i+1} \)
from

<p>
$$ F_{i+1} = F_i + \frac{1}{2}(f_i + f_{i+1})\Delta x\ts$$

Make a function for a scalar implementation of the discrete integral
as a mesh function. That is, the function should return
\( F_i \) for \( i=0,\ldots,N_x \).
For a nose test one can use the fact that the above defined
discrete integral of a linear
function (say \( f(x)=4x-2.5 \)) is exact.

<p>
<b>d)</b>
Vectorize the implementation of the discrete integral.
Extend the nose test to check the validity of the implementation.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Interpret the recursive formula for \( F_{i+1} \) as a sum.
Make an array with each element of the sum and use the "cumsum"
(<code>numpy.cumsum</code>) operation to compute the accumulative sum:
<code>numpy.cumsum([1,3,5])</code> is <code>[1,4,9]</code>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>e)</b>
Create a class <code>MeshCalculus</code> that can integrate and differentiate
mesh functions. The class can just define some methods that call
the previously implemented Python functions. Here is an example
on the usage:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
calc = MeshCalculus(vectorized=<span style="color: #658b00">True</span>)
x = np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">11</span>)        <span style="color: #228B22"># mesh</span>
f = np.exp(x)                    <span style="color: #228B22"># mesh function</span>
df = calc.differentiate(f, x)    <span style="color: #228B22"># discrete derivative</span>
F = calc.integrate(f, x)         <span style="color: #228B22"># discrete anti-derivative</span>
</pre></div>
<p>
Filename: <code>mesh_calculus_1D.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<a href="._part0001_main_wave-solarized.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0003_main_wave-solarized.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

