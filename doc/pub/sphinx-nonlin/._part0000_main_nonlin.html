

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Nonlinear differential equation problems &mdash; Nonlinear differential equation problems</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Nonlinear differential equation problems" href="index.html" />
    <link rel="prev" title="Nonlinear differential equation problems" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Nonlinear differential equation problems"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Nonlinear differential equation problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="nonlinear-differential-equation-problems">
<h1>Nonlinear differential equation problems<a class="headerlink" href="#nonlinear-differential-equation-problems" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Nov 27, 2013</td>
</tr>
</tbody>
</table>
<p>Note: <strong>VERY PRELIMINARY VERSION</strong> (expect typos and mathematical errors)</p>
<p>In a linear differential equation all terms involving the unknown functions
are linear in the unknown functions or their derivatives. Linear here means that
the unknown function or a derivative of it is multiplied by a number or
a known function. All other differential equations are non-linear.
The easiest way to see if an equation is nonlinear is to spot nonlinear terms
where the unknown functions or their derivatives are multiplied by
each other. For example, in</p>
<div class="math">
\[u'(t) = -a(t)u(t) + b(t),\]</div>
<p>the terms involving the unknown function <span class="math">\(u\)</span> are linear: <span class="math">\(u'\)</span> contains
the derivative of the unknown function multiplied by unity, and <span class="math">\(au\)</span> contains
the unknown function multiplied by a known function.
However,</p>
<div class="math">
\[u'(t) = u(t)(1 - u(t)),\]</div>
<p>is nonlinear because of the term <span class="math">\(-u^2\)</span> where the unknown function is
multiplied by itself. Also</p>
<div class="math">
\[\frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0,\]</div>
<p>is nonlinear because of the term <span class="math">\(uu_x\)</span> where the unknown
function appears in a product with itself or one if its derivatives.
Another example of a nonlinear equation is</p>
<div class="math">
\[u'' + \sin(u) =0,\]</div>
<p>because <span class="math">\(\sin(u)\)</span> contains products of <span class="math">\(u\)</span>,</p>
<div class="math">
\[\sin(u) = u - \frac{1}{3} u^3 + \ldots\]</div>
<p>A series of forthcoming examples will explain who to tackle
nonlinear differential equations with various techniques.</p>
</div>
<div class="section" id="basic-examples-using-the-logistic-equation">
<span id="nonlin-timediscrete-logistic"></span><h1>Basic examples using the logistic equation<a class="headerlink" href="#basic-examples-using-the-logistic-equation" title="Permalink to this headline">¶</a></h1>
<p>Consider the (scaled) logistic equation</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:eq">
<span id="eq-nonlin-timediscrete-logistic-eq"></span><span class="eqno">(1)</span>\[     u'(t) = u(t)(1 - u(t)) {\thinspace .}\]</div>
<p>This is a nonlinear differential equation which will be solved by
different strategies in the following.
A time discretization of <a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a>
will either lead to a linear algebraic equation or a nonlinear
algebraic equation at each time level.
In the former case, the time discretization method transforms
the nonlinear ODE into linear subproblems at each time level, and
the solution is straightforward to find. However,
when the time discretization leads to nonlinear algebraic equations, we
cannot (except in very rare cases) solve these without turning to
approximate, iterative solution methods</p>
<div class="section" id="linearization-by-explicit-time-discretization">
<span id="nonlin-timediscrete-logistic-fe"></span><h2>Linearization by explicit time discretization<a class="headerlink" href="#linearization-by-explicit-time-discretization" title="Permalink to this headline">¶</a></h2>
<p id="index-0">A Forward Euler
method to solve <a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a> results in</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = u^n(1 - u^n),\]</div>
<p>which is a <em>linear</em> algebraic
equation for the unknown value <span class="math">\(u^{n+1}\)</span>. Therefore,
the nonlinearity in the original equation poses no difficulty
in the discrete algebraic equation.
Any other explicit scheme in time will also give only linear
algebraic equations
to solve. For example, a typical 2nd-order Runge-Kutta method
for <a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a> reads,</p>
<div class="math">
\[\begin{split}u^* &amp;= u^n + \Delta t u^n(1 - u^n),\\
u^{n+1} &amp;= u^n + \Delta t \frac{1}{2} \left(
u^n(1 - u^n) + u^*(1 - u^*))
\right){\thinspace .}\end{split}\]</div>
<p>The first step is linear in the unknown <span class="math">\(u^*\)</span>. Then <span class="math">\(u^*\)</span> is computed
and known in the next step, which is linear in the unknown <span class="math">\(u^{n+1}\)</span> .</p>
</div>
<div class="section" id="exact-solution-of-nonlinear-equations">
<span id="nonlin-timediscrete-logistic-roots"></span><h2>Exact solution of nonlinear equations<a class="headerlink" href="#exact-solution-of-nonlinear-equations" title="Permalink to this headline">¶</a></h2>
<p>Switching to a Backward Euler scheme for
<a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a>,</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:eq:BE">
<span id="eq-nonlin-timediscrete-logistic-eq-be"></span><span class="eqno">(2)</span>\[     \frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^n),\]</div>
<p>results in a nonlinear algebraic equation for the unknown value <span class="math">\(u^n\)</span>.
The equation is of quadratic type:</p>
<div class="math">
\[\Delta t (u^n)^2 + (1-\Delta t)u^n - u^{n-1} = 0{\thinspace .}\]</div>
<p>We shall now introduce a shorter and often cleaner notation for nonlinear
algebraic equation that appear at a given time level. The notation
gets rid of the superscript that indicates the time level and
is motivated by how we will program the solution method for
the algebraic equation, especially in more advanced partial
differential equation problems. The unknown
in the algebraic equation is denoted by <span class="math">\(u\)</span>, while <span class="math">\(u_1\)</span> is
the value of the unknown at the previous time level (in general <span class="math">\(u_\ell\)</span>
is the value of the unknown <span class="math">\(\ell\)</span> levels back in time).
The quadratic equation for the unknown <span class="math">\(u^n\)</span> in
<a href="#equation-nonlin:timediscrete:logistic:eq:BE">(2)</a> can then be written</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:eq:F">
<span id="eq-nonlin-timediscrete-logistic-eq-f"></span><span class="eqno">(3)</span>\[     F(u) = \Delta t u^2 + (1-\Delta t)u - u_1 = 0,\]</div>
<p>and the solution is</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:eq:roots">
<span id="eq-nonlin-timediscrete-logistic-eq-roots"></span><span class="eqno">(4)</span>\[     u = \frac{1}{2\Delta t}
     \left(-1-\Delta t \pm \sqrt{(1-\Delta t)^2 - 4\Delta t u_1}\right)
     {\thinspace .}\]</div>
<p>Here we encounter a fundamental challenge with nonlinear
algebraic equations:
the equation may have more than one solution. How do we pick the right
solution? In the present simple case we can expand the square root
in a series in <span class="math">\(\Delta t\)</span> and truncate after the linear term since
the Backward Euler scheme will introduce an error proportional to
<span class="math">\(\Delta t\)</span> anyway. Using <tt class="docutils literal"><span class="pre">sympy</span></tt> we find the following Taylor series
expansions of the roots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt u_1 u&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>  <span class="c"># find roots</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span>
<span class="go">(dt - sqrt(dt**2 + 4*dt*u_1 - 2*dt + 1) - 1)/(2*dt)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span>
<span class="go">(dt + sqrt(dt**2 + 4*dt*u_1 - 2*dt + 1) - 1)/(2*dt)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r1</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-1/dt + 1 - u_1 + dt*(u_1**2 - u_1) + O(dt**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r2</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">u_1 + dt*(-u_1**2 + u_1) + O(dt**2)</span>
</pre></div>
</div>
<p>We see that the <tt class="docutils literal"><span class="pre">r1</span></tt> root, corresponding to
a minus sign in front of the square root in
<a href="#equation-nonlin:timediscrete:logistic:eq:roots">(4)</a>,
behaves as <span class="math">\(1/\Delta t\)</span> and will therefore
blow up as <span class="math">\(\Delta t\rightarrow 0\)</span>! Only the <tt class="docutils literal"><span class="pre">r2</span></tt> root is of
relevance in this case.</p>
</div>
<div class="section" id="linearization">
<h2>Linearization<a class="headerlink" href="#linearization" title="Permalink to this headline">¶</a></h2>
<p>When the time integration of an ODE results in a nonlinear algebraic
equation, we must normally find its solution by defining a sequence
of linear equations and hope that the solutions of these linear equations
converge to the desired solution of the nonlinear algebraic equation.
Usually this means solving the linear equation repeatedly in an
iterative fashion.
Sometimes the nonlinear equation is just approximated by a linear equation
and no iteration is carried out.</p>
<p>Constructing a linear equation from a nonlinear one requires
<em>linearization</em> of each nonlinear term. This can be done manually
as in Picard iteration, or fully algorithmically as in Newton&#8217;s method.
Examples will best illustrate how to linearize nonlinear problems.</p>
</div>
<div class="section" id="picard-iteration-1">
<span id="nonlin-timediscrete-logistic-picard"></span><h2>Picard iteration  (1)<a class="headerlink" href="#picard-iteration-1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><span class="target" id="index-5"></span><p id="index-6">Let us write <a href="#equation-nonlin:timediscrete:logistic:eq:F">(3)</a> in a
more compact form</p>
<div class="math">
\[F(u) = au^2 + bu + c = 0,\]</div>
<p>with <span class="math">\(a=\Delta t\)</span>, <span class="math">\(b=1-\Delta t\)</span>, and <span class="math">\(c=-u_1\)</span>.
Let <span class="math">\(u_{-}\)</span> an available approximation of the unknown <span class="math">\(u\)</span>.
Then we can linearize the term <span class="math">\(u^2\)</span> by writing
<span class="math">\(u_{-}u\)</span>. The resulting equation, <span class="math">\(\hat F(u)=0\)</span>, is linear
and hence easy to solve:</p>
<div class="math">
\[F(u)\approx\hat F(u) = au_{-}u + bu + c = 0{\thinspace .}\]</div>
<p>Since the equation <span class="math">\(\hat F=0\)</span> is only approximate, the solution <span class="math">\(u\)</span>
does not equal the exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> of the exact
equation <span class="math">\(F({u_{\small\mbox{e}}})=0\)</span>, but we can hope that <span class="math">\(u\)</span> is closer to
<span class="math">\({u_{\small\mbox{e}}}\)</span> than <span class="math">\(u_{-}\)</span> is, and hence it makes sense to repeat the
procedure, i.e., set <span class="math">\(u_{-}=u\)</span> and solve <span class="math">\(\hat F(u)=0\)</span> again.</p>
<p>The idea of turning a nonlinear equation into a linear one by
using an approximation <span class="math">\(u_{-}\)</span> of <span class="math">\(u\)</span> in nonlinear terms is
a widely used approach that goes under many names:
<em>fixed-point iteration</em>, the method of <em>successive substitutions</em>,
<em>nonlinear Richardson iteration</em>, and <em>Picard iteration</em>.
We will stick to the latter name.</p>
<p>Picard iteration for solving the nonlinear equation
arising from the Backward Euler discretization of the logistic
equation can be written as</p>
<div class="math">
\[u = -\frac{c}{au_{-} + b},\quad u_{-}\ \leftarrow\ u{\thinspace .}\]</div>
<p>The iteration is started with the value of the unknown at the
previous time level: <span class="math">\(u_{-}=u_1\)</span>.</p>
<p>Some prefer an explicit iteration counter as superscript
in the mathematical notation. Let <span class="math">\(u^k\)</span> be the computed approximation
to the solution in iteration <span class="math">\(k\)</span>. In iteration <span class="math">\(k+1\)</span> we want
to solve</p>
<div class="math">
\[au^k u^{k+1} + bu^{k+1} + c = 0\quad\Rightarrow\quad u^{k+1}
= -\frac{c}{au^k + b},\quad k=0,1,\ldots\]</div>
<p>However, we will normally apply a mathematical notation in our
final formulas that is as close as possible to what we aim to write
in a computer code and then we want to omit the <span class="math">\(k\)</span> superscript
in <span class="math">\(u\)</span>.</p>
<div class="section" id="stopping-criteria-1">
<span id="index-7"></span><h3>Stopping criteria  (1)<a class="headerlink" href="#stopping-criteria-1" title="Permalink to this headline">¶</a></h3>
<p>The iteration method can typically be terminated when the change
in the solution is smaller than a tolerance <span class="math">\(\epsilon_u\)</span>:</p>
<div class="math">
\[|u - u_{-}| \leq\epsilon_u,\]</div>
<p>or when the residual in the equation is sufficiently small (<span class="math">\(\epsilon_r\)</span>),</p>
<div class="math">
\[\begin{split}|F(u)|= |au^2+bu + c| &lt; \epsilon_r{\thinspace .}\end{split}\]</div>
<p>With <span class="math">\(\epsilon_r = 10^{-7}\)</span> we seldom need more than about 5 iterations
when solving this logistic equation.</p>
</div>
<div class="section" id="a-single-picard-iteration">
<span id="index-8"></span><h3>A single Picard iteration<a class="headerlink" href="#a-single-picard-iteration" title="Permalink to this headline">¶</a></h3>
<p>Instead of iterating until a stopping criterion is fulfilled, one may
iterate a specific number of times. Just one Picard iteration is
popular as this corresponds to the intuitive idea of approximating
a nonlinear term like <span class="math">\((u^n)^2\)</span> by <span class="math">\(u^{n-1}u^n\)</span>. That is, one just
applies a known value for the unknown at the previous time level
in nonlinear terms. The corresponding time discretization reads</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:BE:Picard:1it">
<span id="eq-nonlin-timediscrete-logistic-be-picard-1it"></span><span class="eqno">(5)</span>\[     \frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^{n-1}){\thinspace .}\]</div>
<p>This is obviously an approximation and does not correspond to
a &#8220;pure&#8221; finite difference method where the equation is sampled at
a point and derivatives replaced by differences. The best
interpretation of the scheme <a href="#equation-nonlin:timediscrete:logistic:BE:Picard:1it">(5)</a>
is a Backward Euler difference combined with a single Picard iteration
at each time level, using the value at the previous time level as
start for the Picard iteration.</p>
</div>
</div>
<div class="section" id="linearization-by-a-geometric-mean">
<span id="nonlin-timediscrete-logistic-geometric-mean"></span><h2>Linearization by a geometric mean<a class="headerlink" href="#linearization-by-a-geometric-mean" title="Permalink to this headline">¶</a></h2>
<p>We consider now a Crank-Nicolson discretization of
<a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a>. This means that the
time derivative is approximated by a centered
difference,</p>
<div class="math">
\[[D_t u = u(1-u)]^{n+\frac{1}{2}},\]</div>
<p>written out as</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:geometric:mean:scheme">
<span id="eq-nonlin-timediscrete-logistic-geometric-mean-scheme"></span><span class="eqno">(6)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = u^{n+\frac{1}{2}} -
     (u^{n+\frac{1}{2}})^2{\thinspace .}\]</div>
<p>The term <span class="math">\(u^{n+\frac{1}{2}}\)</span> is normally approximated by an arithmetic
mean,</p>
<div class="math">
\[u^{n+\frac{1}{2}}\approx \frac{1}{2}(u^n + u^{n+1}),\]</div>
<p>such that the scheme involves the unknown function only at the time levels
where we actually compute it.
The same arithmetic mean applied to the nonlinear term gives</p>
<div class="math">
\[(u^{n+\frac{1}{2}})^2\approx \frac{1}{4}(u^n + u^{n+1})^2,\]</div>
<p>which is nonlinear in the unknown <span class="math">\(u^{n+1}\)</span>.
However, using a <em>geometric mean</em> for <span class="math">\((u^{n+\frac{1}{2}})^2\)</span>
is a way of linearizing the nonlinear term in
<a href="#equation-nonlin:timediscrete:logistic:geometric:mean:scheme">(6)</a>:</p>
<div class="math">
\[(u^{n+\frac{1}{2}})^2\approx u^nu^{n+1}{\thinspace .}\]</div>
<p>The linearized scheme for <span class="math">\(u^{n+1}\)</span> now reads</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} =
\frac{1}{2}(u^n + u^{n+1}) + u^nu^{n+1},\]</div>
<p>which can readily be solved:</p>
<div class="math">
\[u^{n+1} = \frac{1 + \frac{1}{2}\Delta t}{1+\Delta t u^n - \frac{1}{2}\Delta t}
u^n{\thinspace .}\]</div>
<p>This scheme can be coded directly, and since
there is no nonlinear algebraic equation to solve by methods for those
kind of problems we skip the simplified notation (<span class="math">\(u\)</span> for <span class="math">\(u^{n+1}\)</span>
and <span class="math">\(u_1\)</span> for <span class="math">\(u^n\)</span>).</p>
<p>The geometric mean approximation is often very effective to deal with
quadratic nonlinearities. Both the arithmetic and geometric mean
approximations have truncation errors of order <span class="math">\(\Delta t^2\)</span> and are
therefore compatible with the truncation error of the
centered difference approximation for <span class="math">\(U'\)</span> in the Crank-Nicolson
method.</p>
<p>Applying the operator notation for the means, the linearized Crank-Nicolson
scheme for the logistic equation can be compactly expressed as</p>
<div class="math">
\[[D_t u = \overline{u}^{t} + \overline{u^2}^{t,g}]^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p><strong>Remark.</strong>
If we use an arithmetic instead of a geometric mean
for the nonlinear term in
<a href="#equation-nonlin:timediscrete:logistic:geometric:mean:scheme">(6)</a>,
we end up with a nonlinear term <span class="math">\((u^{n+1})^2\)</span>.
The term can be linearized as <span class="math">\(u^nu^{n+1}\)</span> in a Picard iteration approach.
Observe that the geometric mean avoids any iteration.</p>
</div>
<div class="section" id="newton-s-method-1">
<span id="nonlin-timediscrete-logistic-newton"></span><h2>Newton&#8217;s method  (1)<a class="headerlink" href="#newton-s-method-1" title="Permalink to this headline">¶</a></h2>
<p>The Backward Euler scheme <a href="#equation-nonlin:timediscrete:logistic:eq:BE">(2)</a>
for the logistic equation leads to a nonlinear algebraic equation
<a href="#equation-nonlin:timediscrete:logistic:eq:F">(3)</a>. Now we write any nonlinear
algebraic equation in the general and compact form</p>
<div class="math">
\[F(u) = 0{\thinspace .}\]</div>
<p>Newton&#8217;s method linearizes this equation by approximating <span class="math">\(F(u)\)</span> by
its Taylor series expansion around a computed value <span class="math">\(u_{-}\)</span>
and keeping only the linear part:</p>
<div class="math">
\[\begin{split}F(u) &amp;= F(u_{-}) + F'(u_{-})(u - u_{-}) + {\frac{1}{2}}F''(u_{-})(u-u_{-})^2
+\cdots\\
&amp; \approx F(u_{-}) + F'(u_{-})(u - u_{-}) = \hat F(u){\thinspace .}\end{split}\]</div>
<p>The linear equation <span class="math">\(\hat F(u)=0\)</span> has the solution</p>
<div class="math">
\[u = u_{-} - \frac{F(u_{-})}{F'(u_{-})}{\thinspace .}\]</div>
<p>Expressed with an iteration index on the unknown, Newton&#8217;s method takes
on the more familiar mathematical form</p>
<div class="math">
\[u^{k+1} = u^k - \frac{F(u^k)}{F'(u^k)},\quad k=0,1,\ldots\]</div>
<p>Application of Newton&#8217;s method to the logistic equation discretized
by the Backward Euler method is straightforward
as we have</p>
<div class="math">
\[F(u) = au^2 + bu + c,\quad a=\Delta t,\ b = 1-\Delta t,\ c=-u_1,\]</div>
<p>and then</p>
<div class="math">
\[F'(u) = 2au + b{\thinspace .}\]</div>
<p>The iteration method becomes</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:Newton:alg1">
<span id="eq-nonlin-timediscrete-logistic-newton-alg1"></span><span class="eqno">(7)</span>\[     u = u_{-} + \frac{au_{-}^2 + bu_{-} + c}{2au_{-} + b},\quad
     u_{-}\ \leftarrow u{\thinspace .}\]</div>
<p>At each time level, we start the iteration by setting <span class="math">\(u_{-}=u_1\)</span>.
Stopping criteria as listed for the Picard iteration can be used also
for Newton&#8217;s method.</p>
<p>An alternative mathematical form, where we write out <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, and <span class="math">\(c\)</span>,
and use a time level counter <span class="math">\(n\)</span> and an iteration counter <span class="math">\(k\)</span>, takes
the form</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:Newton:alg2">
<span id="eq-nonlin-timediscrete-logistic-newton-alg2"></span><span class="eqno">(8)</span>\[     u^{n,k+1} = u^{n,k} +
     \frac{\Delta t (u^{n,k})^2 + (1-\Delta t)u^{n,k} - u^{n-1}}
     {2\Delta t u^{n,k} + 1 - \Delta t},\quad u^{n,0}=u^{n-1},\quad k=0,1,\ldots\]</div>
<p>The implementation is much closer to <a href="#equation-nonlin:timediscrete:logistic:Newton:alg1">(7)</a> than to <a href="#equation-nonlin:timediscrete:logistic:Newton:alg2">(8)</a>, but
the latter is better aligned with the established mathematical
notation used in the literature.</p>
</div>
<div class="section" id="relaxation">
<span id="nonlin-timediscrete-logistic-relaxation"></span><h2>Relaxation<a class="headerlink" href="#relaxation" title="Permalink to this headline">¶</a></h2>
<p id="index-9">One iteration in Newton&#8217;s method or
Picard iteration consists of solving a linear problem <span class="math">\(\hat F(u)=0\)</span>.
Sometimes convergence problems arise because the new solution <span class="math">\(u\)</span>
of <span class="math">\(\hat F(u)=0\)</span> is &#8220;too far away&#8221; from the previously computed
solution <span class="math">\(u_{-}\)</span>. A remedy is to introduce a relaxation, meaning that
we first solve <span class="math">\(\hat F(u^*)=0\)</span> for a suggested value <span class="math">\(u^*\)</span> and
then we take <span class="math">\(u\)</span> as a weighted mean of what we had, <span class="math">\(u_{-}\)</span>, and
what our linearized equation <span class="math">\(\hat F=0\)</span> suggests, <span class="math">\(u^*\)</span>:</p>
<div class="math">
\[u = \omega u^* + (1-\omega) u_{-}{\thinspace .}\]</div>
<p>The parameter <span class="math">\(\omega\)</span>
is known as a <em>relaxation parameter</em>, and a choice <span class="math">\(\omega &lt; 1\)</span>
may prevent divergent iterations.</p>
<p>Relaxation in Newton&#8217;s method can be directly incorporated
in the basic iteration formula:</p>
<div class="math">
\[u = u_{-} - \omega \frac{F(u_{-})}{F'(u_{-})}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-and-experiments">
<h2>Implementation and experiments<a class="headerlink" href="#implementation-and-experiments" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/nonlin/logistic.py">logistic.py</a> contains
implementations of all the methods described above.
Below is an extract of the file showing how the Picard and Newton
methods are implemented for a Backward Euler discretization of
the logistic equation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">BE_logistic</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="s">&#39;Picard&#39;</span><span class="p">,</span> <span class="n">eps_r</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dt</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">&#39;Picard&#39;</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">c</span>

            <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps_r</span><span class="p">:</span>
                <span class="n">u_</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">u_</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">u_</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_</span>
        <span class="k">elif</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">&#39;Newton&#39;</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">c</span>

            <span class="k">def</span> <span class="nf">dF</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">b</span>

            <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps_r</span><span class="p">:</span>
                <span class="n">u_</span> <span class="o">=</span> <span class="n">u_</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">/</span><span class="n">dF</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>The Crank-Nicolson method utilizing a linearization based on the
geometric mean gives a simpler algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CN_logistic</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>Experiments with this program reveal the relative performance
of the methods as summarized in the table below.
The Picard and Newton columns reflect the typical number of
iterations with these methods before the curve starts to flatten out
and the number of iterations is significantly reduced since
the solution of the nonlinear algebraic equation is very close to
the starting value for the iterations (the solution at the previous
time level). Increasing <span class="math">\(\Delta t\)</span> moves the starting value further
away from the solution of the nonlinear equation and one expects
an increase in the number of iterations. Picard iteration is
very much more sensitive to the size of <span class="math">\(\Delta t\)</span> than Newton&#8217;s method.
The tolerance <span class="math">\(\epsilon_r\)</span> in residual-based
stopping criterion takes on a low and high value in the experiments.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\epsilon_r\)</span></th>
<th class="head">Picard</th>
<th class="head">Newton</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(0.2\)</span></td>
<td><span class="math">\(10^{-7}\)</span></td>
<td>5</td>
<td>2</td>
</tr>
<tr class="row-odd"><td><span class="math">\(0.2\)</span></td>
<td><span class="math">\(10^{-3}\)</span></td>
<td>2</td>
<td>1</td>
</tr>
<tr class="row-even"><td><span class="math">\(0.4\)</span></td>
<td><span class="math">\(10^{-7}\)</span></td>
<td>12</td>
<td>3</td>
</tr>
<tr class="row-odd"><td><span class="math">\(0.4\)</span></td>
<td><span class="math">\(10^{-3}\)</span></td>
<td>4</td>
<td>2</td>
</tr>
<tr class="row-even"><td><span class="math">\(0.8\)</span></td>
<td><span class="math">\(10^{-7}\)</span></td>
<td>58</td>
<td>3</td>
</tr>
<tr class="row-odd"><td><span class="math">\(0.8\)</span></td>
<td><span class="math">\(10^{-3}\)</span></td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><strong>Remark.</strong>
The simple Crank-Nicolson method with a geometric mean for the quadratic
nonlinearity gives visually more accurate solutions than the
Backward Euler discretization. Even with a tolerance of <span class="math">\(\epsilon_r=10^{-3}\)</span>,
all the methods for treating the nonlinearities in the Backward Euler
discretization gives graphs that cannot be distinguished. So for
accuracy in this problem, the time discretization is much more crucial
than <span class="math">\(\epsilon_r\)</span>. Ideally, one should estimate the error in the
time discretization, as the solution progresses, and set <span class="math">\(\epsilon_r\)</span>
accordingly.</p>
</div>
<div class="section" id="generalization-to-a-general-nonlinear-ode">
<span id="nonlin-ode-generic"></span><h2>Generalization to a general nonlinear ODE<a class="headerlink" href="#generalization-to-a-general-nonlinear-ode" title="Permalink to this headline">¶</a></h2>
<p>Let us see how the various methods in the previous sections
can be applied to the more generic model</p>
<div class="math" id="equation-nonlin:ode:generic:model">
<span id="eq-nonlin-ode-generic-model"></span><span class="eqno">(9)</span>\[     u' = f(u, t),\]</div>
<p>where <span class="math">\(f\)</span> is a nonlinear function of <span class="math">\(u\)</span>.</p>
<div class="section" id="explicit-time-discretization">
<h3>Explicit time discretization<a class="headerlink" href="#explicit-time-discretization" title="Permalink to this headline">¶</a></h3>
<p>Explicit ODE methods like the Forward Euler scheme, Runge-Kutta methods,
Adams-Bashforth methods all evaluate <span class="math">\(f\)</span> at time levels where
<span class="math">\(u\)</span> is already computed, so nonlinearities in <span class="math">\(f\)</span> do not
pose any difficulties.</p>
</div>
<div class="section" id="backward-euler-discretization">
<h3>Backward Euler discretization<a class="headerlink" href="#backward-euler-discretization" title="Permalink to this headline">¶</a></h3>
<p>Approximating <span class="math">\(u'\)</span> by a backward difference leads to a Backward Euler
scheme, which can be written as</p>
<div class="math">
\[F(u^n) = u^{n} - \Delta t f(u^n, t_n) - u^{n-1}=0,\]</div>
<p>or alternatively</p>
<div class="math">
\[F(u) = u - \Delta t f(u, t_n) - u_1 = 0{\thinspace .}\]</div>
<p>A simple Picard iteration, not knowing anything about the nonlinear
structure of <span class="math">\(f\)</span>, must approximate <span class="math">\(f(u,t_n)\)</span> by <span class="math">\(f(u_{-},t_n)\)</span>:</p>
<div class="math">
\[\hat F(u) = u - \Delta t f(u_{-},t_n) - u_1{\thinspace .}\]</div>
<p>The iteration starts with <span class="math">\(u_{-}=u_1\)</span> and proceeds with repeating</p>
<div class="math">
\[u^* = \Delta t f(u_{-},t_n) + u_1,\quad u = \omega u^* + (1-\omega)u_{-},
\quad u_{-}\ \leftarrow\ u,\]</div>
<p>until a stopping criterion is fulfilled.</p>
<p>Newton&#8217;s method requires the computation of the derivative</p>
<div class="math">
\[F'(u) = 1 - \Delta t\frac{\partial f}{\partial u}(u,t_n){\thinspace .}\]</div>
<p>Starting with the solution at the previous time level, <span class="math">\(u_{-}=u_1\)</span>,
we can just use the standard formula</p>
<div class="math">
\[u = u_{-} - \omega \frac{F(u_{-})}{F'(u_{-})}
= u_ - \omega \frac{u_1 + \Delta t f(u_,t_{n})}{1 - \Delta t
\frac{\partial}{\partial u}f(u_,t_n)}
{\thinspace .}\]</div>
<p>The geometric mean trick cannot be used unless we know that <span class="math">\(f\)</span> has
a special structure with quadratic expressions in <span class="math">\(u\)</span>.</p>
</div>
<div class="section" id="crank-nicolson-discretization">
<h3>Crank-Nicolson discretization<a class="headerlink" href="#crank-nicolson-discretization" title="Permalink to this headline">¶</a></h3>
<p>The standard Crank-Nicolson scheme with arithmetic mean approximation of
<span class="math">\(f\)</span> takes the form</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = \frac{1}{2}(f(u^{n+1}, t_{n+1})
+ f(u^n, t_n)){\thinspace .}\]</div>
<p>Introducing <span class="math">\(u\)</span> for the unknown <span class="math">\(u^{n+1}\)</span> and <span class="math">\(u_1\)</span> for <span class="math">\(u^n\)</span>, we
can write the scheme as a nonlinear algebraic equation</p>
<div class="math">
\[F(u) = u - u_1 - \Delta t{\frac{1}{2}}f(u,t_{n+1}) -
\Delta t{\frac{1}{2}}f(u_1,t_{n}) = 0{\thinspace .}\]</div>
<p>A Picard iteration scheme must in general employ the linearization,</p>
<div class="math">
\[\hat F(u) = u - u_1 - \Delta t{\frac{1}{2}}f(u_{-},t_{n+1}) -
\Delta t{\frac{1}{2}}f(u_1,t_{n}),\]</div>
<p>while Newton&#8217;s method can apply the general formula,  but we need
to derive</p>
<div class="math">
\[F'(u)= 1 - \frac{1}{2}\Delta t\frac{\partial f}{\partial u}(u,t_{n+1}){\thinspace .}\]</div>
</div>
</div>
</div>
<div class="section" id="systems-of-nonlinear-algebraic-equations">
<span id="nonlin-systems-alg"></span><h1>Systems of nonlinear algebraic equations<a class="headerlink" href="#systems-of-nonlinear-algebraic-equations" title="Permalink to this headline">¶</a></h1>
<p>Implicit time discretization methods for a system of ODEs, or a PDE,
lead to <em>systems</em> of nonlinear algebraic equations, written
compactly as</p>
<div class="math">
\[F(u) = 0,\]</div>
<p>where <span class="math">\(u\)</span> is a vector of unknowns <span class="math">\(u=(u_0,\ldots,u_N)\)</span>, and
<span class="math">\(F\)</span> is a vector function: <span class="math">\(F=(F_0,\ldots,F_N)\)</span>.
Sometimes the equation system has a special structure because of the
underlying problem, e.g.,</p>
<div class="math">
\[A(u)u = b(u),\]</div>
<p>with <span class="math">\(A(u)\)</span> as
an <span class="math">\((N+1)\times (N+1)\)</span> matrix function of <span class="math">\(u\)</span> and <span class="math">\(b\)</span> as a vector
function: <span class="math">\(b=(b_0,\ldots,b_N)\)</span>.</p>
<p>We shall next explain how Picard iteration and Newton&#8217;s method
can be applied to systems like <span class="math">\(F(u)=0\)</span> and <span class="math">\(A(u)u=b(u)\)</span>.
The exposition has a focus on ideas and practical computations.
More theoretical considerations, including quite general results
on convergence properties
of these methods, can be found in Kelley <a class="reference internal" href="#ref1">[Ref1]</a>.</p>
<div class="section" id="picard-iteration-2">
<span id="nonlin-systems-alg-picard"></span><h2>Picard iteration  (2)<a class="headerlink" href="#picard-iteration-2" title="Permalink to this headline">¶</a></h2>
<p>We cannot apply Picard iteration to nonlinear equations unless there is
some special structure. For the commonly arising case
<span class="math">\(A(u)u=b(u)\)</span> we can linearize the
product <span class="math">\(A(u)u\)</span> to <span class="math">\(A(u_{-})u\)</span> and <span class="math">\(b(u)\)</span> as <span class="math">\(b(u_{-})\)</span>.
That is, we use the most previously
computed approximation in <span class="math">\(A\)</span> and <span class="math">\(b\)</span> to arrive at a <em>linear system</em> for
<span class="math">\(u\)</span>:</p>
<div class="math">
\[A(u_{-})u = b(u_{-}){\thinspace .}\]</div>
<p>A relaxed iteration takes the form</p>
<div class="math">
\[A(u_{-})u^* = b(u_{-}),\quad u = \omega u^* + (1-\omega)u_{-}{\thinspace .}\]</div>
<p>In other words, we solve a system of nonlinear algebraic equations as
a sequence of linear systems.</p>
<div class="admonition-algorithm-for-relaxed-picard-iteration admonition">
<p class="first admonition-title">Algorithm for relaxed Picard iteration</p>
<p>Given <span class="math">\(A(u)u=b(u)\)</span> and an initial guess <span class="math">\(u_{-}\)</span>, iterate until convergence:</p>
<ol class="last arabic simple">
<li>solve <span class="math">\(A(u_{-})u^* = b(u_{-})\)</span> with respect to <span class="math">\(u^*\)</span></li>
<li><span class="math">\(u = \omega u^* + (1-\omega) u_{-}\)</span></li>
<li><span class="math">\(u_{-}\ \leftarrow\ u\)</span></li>
</ol>
</div>
</div>
<div class="section" id="newton-s-method-2">
<span id="nonlin-systems-alg-newton"></span><h2>Newton&#8217;s method  (2)<a class="headerlink" href="#newton-s-method-2" title="Permalink to this headline">¶</a></h2>
<p>The natural starting point for Newton&#8217;s method is the general
nonlinear vector equation <span class="math">\(F(u)=0\)</span>.
As for a scalar equation, the idea is to approximate <span class="math">\(F\)</span>
around a known value <span class="math">\(u_{-}\)</span> by a linear function <span class="math">\(\hat F\)</span>,
calculated from the first two terms of a Taylor expansion of
<span class="math">\(F\)</span>. In the multi-variate case these two terms become</p>
<div class="math">
\[F(u_{-}) + J(u_{-}) \cdot (u - u_{-}),\]</div>
<p>where <span class="math">\(J\)</span> is the <em>Jacobian</em> of <span class="math">\(F\)</span>, defined by</p>
<div class="math">
\[J_{i,j} = \frac{\partial F_i}{\partial u_j}{\thinspace .}\]</div>
<p>So, the original nonlinear system is approximated by</p>
<div class="math">
\[\hat F(u) = F(u_{-}) + J(u_{-}) \cdot (u - u_{-})=0,\]</div>
<p>which is linear in <span class="math">\(u\)</span> and can be solved in a two-step procedure:
first solve <span class="math">\(J\delta u = -F(u_{-})\)</span> with respect to the vector <span class="math">\(\delta u\)</span>
and then update <span class="math">\(u = u_{-} + \delta u\)</span>.
A relaxation parameter can easily be incorporated:</p>
<div class="math">
\[u = \omega(u_{-} +\delta u)
+ (1-\omega)u_{-} = \omega_{-}  + \omega\delta u{\thinspace .}\]</div>
<div class="admonition-algorithm-for-newton-s-method admonition">
<p class="first admonition-title">Algorithm for Newton&#8217;s method</p>
<p>Given <span class="math">\(F(u)=0\)</span> and an initial guess <span class="math">\(u_{-}\)</span>, iterate until convergence:</p>
<ol class="last arabic simple">
<li>solve <span class="math">\(J\delta u = -F(u_{-})\)</span> with respect to <span class="math">\(\delta u\)</span></li>
<li><span class="math">\(u = u_{-} + \omega)\delta u\)</span></li>
<li><span class="math">\(u_{-}\ \leftarrow\ u\)</span></li>
</ol>
</div>
<p>For the special system with structure <span class="math">\(A(u)u=b(u)\)</span>,</p>
<div class="math">
\[F_i = \sum_k A_{i,k}(u)u_k - b_i(u),\]</div>
<p>and</p>
<div class="math">
\[J_{i,j} = \sum_k \frac{\partial A_{i,k}}{\partial u_j}u_k
+ A_{i,j} -
\frac{\partial b_i}{\partial u_j}{\thinspace .}\]</div>
<p>We realize that the Jacobian needed in Newton&#8217;s method consists of
<span class="math">\(A(u_{-})\)</span> as in the Picard iteration plus two additional terms
arising from the differentiation. Using the notation <span class="math">\(A'(u)\)</span> for
<span class="math">\(\partial A/\partial u\)</span> (a quantity with three indices: <span class="math">\(\partial
A_{i,k}/\partial u_j\)</span>), and <span class="math">\(b'(u)\)</span> for <span class="math">\(\partial b/\partial u\)</span> (a
quantity with two indices: <span class="math">\(\partial b_i/\partial u_j\)</span>), we can write
the linear system to be solved as</p>
<div class="math">
\[(A + A'u + b')\delta u = -Au + b,\]</div>
<p>or</p>
<div class="math">
\[(A(u_{-}) + A'(u_{-})u_{-} + b'(u_{i}))\delta u
= -A(u_{-})u_{-} + b(u_{-}){\thinspace .}\]</div>
<p>Rearranging the terms demonstrates the difference from the system
solved in each Picard iteration:</p>
<div class="math">
\[\underbrace{A(u_{-})(u_{-}+\delta u) - b(u_{-})}_{\hbox{Picard system}}
+\, \gamma (A'(u_{-})u_{-} + b'(u_{i}))\delta u
= 0{\thinspace .}\]</div>
<p>Here we have inserted a parameter <span class="math">\(\gamma\)</span> such that <span class="math">\(\gamma=0\)</span>
gives the Picard system and <span class="math">\(\gamma=1\)</span> gives the Newton system.
Such a parameter can be handy in software to easily switch between
the methods.</p>
</div>
<div class="section" id="stopping-criteria-2">
<span id="nonlin-systems-alg-terminate"></span><h2>Stopping criteria  (2)<a class="headerlink" href="#stopping-criteria-2" title="Permalink to this headline">¶</a></h2>
<p id="index-10">Let <span class="math">\(||\cdot||\)</span> be the standard Eucledian vector norm. Four termination
criteria are much in use:</p>
<blockquote>
<div><ul class="simple">
<li>Absolute change in solution: <span class="math">\(||u - u_{-}||\leq \epsilon_u\)</span></li>
<li>Relative change in solution: <span class="math">\(||u - u_{-}||\leq \epsilon_u ||u_0||\)</span>,
where <span class="math">\(u_0\)</span> denotes the start value of <span class="math">\(u_{-}\)</span> in the iteration</li>
<li>Absolute residual: <span class="math">\(||F(u)|| \leq \epsilon_r\)</span></li>
<li>Relative residual: <span class="math">\(||F(u)|| \leq \epsilon_r ||F(u_0)||\)</span></li>
</ul>
</div></blockquote>
<p>To prevent divergent iterations to run forever,
one terminates the iterations when
the current number of iterations <span class="math">\(k\)</span> exceeds a maximum value <span class="math">\(k_{\max}\)</span>.</p>
<p>The relative criteria are most used since they are not sensitive to
the characteristic size of <span class="math">\(u\)</span>. Nevertheless, the relative criteria
can be misleading when the initial start value for the iteration is
very close to the solution, since an unnecessary reduction in
the error measure is enforced. In such cases the absolute criteria
work better. It is common to combine the absolute and relative measures
of the size of the residual,
as in</p>
<div class="math">
\[||F(u)|| \leq \epsilon_{rr} ||F(u_0)|| + \epsilon_{ra},\]</div>
<p>where <span class="math">\(\epsilon_{rr}\)</span> is the tolerance in the relative criterion
and <span class="math">\(\epsilon_{ra}\)</span> is the tolerance in the absolute criterion.
With a very good initial guess for the iteration
(typically the solution of a differential
equation at the previous time level), the term <span class="math">\(||F(u_0)||\)</span> is small
and <span class="math">\(\epsilon_{ra}\)</span> is the dominating tolerance. Otherwise,
<span class="math">\(\epsilon_{rr} ||F(u_0)||\)</span> and the relative criterion dominates.</p>
<p>With the change in solution as criterion we can formulate and combined
absolute and relative measure of the change in the solution:</p>
<div class="math">
\[||\delta u|| \leq \epsilon_{ur} ||u_0|| + \epsilon_{ua},\]</div>
<p>The ultimate termination criterion, combining the residual and
the change in solution tests with a test on the maximum number
of iterations allow, can be expressed as</p>
<div class="math">
\[\begin{split}||F(u)|| \leq \epsilon_{rr} ||F(u_0)|| + \epsilon_{ra}
\hbox{ or }
||\delta u|| \leq \epsilon_{ur} ||u_0|| + \epsilon_{ua}
\hbox{ or }
k&gt;k_{\max}{\thinspace .}\end{split}\]</div>
</div>
<div class="section" id="example-a-nonlinear-ode-model-from-epidemiology">
<span id="nonlin-systems-alg-si"></span><h2>Example: A nonlinear ODE model from epidemiology<a class="headerlink" href="#example-a-nonlinear-ode-model-from-epidemiology" title="Permalink to this headline">¶</a></h2>
<p>The simplest model spreading of a disease, such as a flu, takes
the form of a <span class="math">\(2\times 2\)</span> ODE system</p>
<div class="math">
\[S' = -\beta SI,\]</div>
<div class="math">
\[I' = \beta SI - \nu I,\]</div>
<p>where <span class="math">\(S(t)\)</span> is the number of people who can get ill (susceptibles)
and <span class="math">\(I(t)\)</span> is the number of people who are ill (infected).
The constants <span class="math">\(\beta &gt;0\)</span> and <span class="math">\(\nu &gt;0\)</span> must be given along with
initial conditions <span class="math">\(S(0)\)</span> and <span class="math">\(I(0)\)</span>.</p>
<div class="section" id="implicit-time-discretization">
<h3>Implicit time discretization<a class="headerlink" href="#implicit-time-discretization" title="Permalink to this headline">¶</a></h3>
<p>A Crank-Nicolson scheme leads to a <span class="math">\(2\times 2\)</span> system of nonlinear
algebraic equations in the unknowns <span class="math">\(S^{n+1}\)</span> and <span class="math">\(I^{n+1}\)</span>:</p>
<div class="math">
\[\frac{S^{n+1}-S^n}{\Delta t} = -\beta [SI]^{n+\frac{1}{2}}
\approx -\frac{\beta}{2}(S^nI^n + S^{n+1}I^{n+1}),\]</div>
<div class="math">
\[\frac{I^{n+1}-I^n}{\Delta t} = \beta [SI]^{n+\frac{1}{2}} -
\nu I^{n+\frac{1}{2}}
\approx \frac{\beta}{2}(S^nI^n + S^{n+1}I^{n+1}) -
\frac{\nu}{2}(I^n + I^{n+1}){\thinspace .}\]</div>
<p>Introducing <span class="math">\(S\)</span> for <span class="math">\(S^{n+1}\)</span>, <span class="math">\(S_1\)</span> for <span class="math">\(S^n\)</span>, <span class="math">\(I\)</span> for <span class="math">\(I^{n+1}\)</span>,
<span class="math">\(I_1\)</span> for <span class="math">\(I^n\)</span>, we can rewrite the system as</p>
<div class="math" id="equation-nonlin:systems:alg:SI:CN:FS">
<span id="eq-nonlin-systems-alg-si-cn-fs"></span><span class="eqno">(10)</span>\[     F_S(S,I) = S - S_1 +
     \frac{1}{2}\Delta t\beta(S_1I_1 + SI) = 0,\]</div>
<div class="math" id="equation-nonlin:systems:alg:SI:CN:FI">
<span id="eq-nonlin-systems-alg-si-cn-fi"></span><span class="eqno">(11)</span>\[     F_I(S,I) = I - I_1 -
     \frac{1}{2}\Delta t\beta(S_1I_1 + SI) -
     \frac{1}{2}\Delta t\nu(I_1 + I) =0{\thinspace .}\]</div>
</div>
<div class="section" id="a-picard-iteration">
<h3>A Picard iteration<a class="headerlink" href="#a-picard-iteration" title="Permalink to this headline">¶</a></h3>
<p>We assume that we have approximations <span class="math">\(S_{-}\)</span> and <span class="math">\(I_{-}\)</span> to <span class="math">\(S\)</span> and <span class="math">\(I\)</span>.
A way of linearizing the only nonlinear term <span class="math">\(SI\)</span> is to write
<span class="math">\(I_{-}S\)</span> in the <span class="math">\(F_S=0\)</span> equation and <span class="math">\(S_{-}I\)</span> in the <span class="math">\(F_I=0\)</span> equation,
which also decouples the equations. Solving the resulting linear
equations with respect to the unknowns <span class="math">\(S\)</span> and <span class="math">\(I\)</span> gives</p>
<div class="math">
\[\begin{split}S &amp;= \frac{S_1 - \frac{1}{2}\Delta t\beta S_1I_1}
{1 + \frac{1}{2}\Delta t\beta I_{-}},
\\
I &amp;= \frac{I_1 + \frac{1}{2}\Delta t\beta S_1I_1}
{1 - \frac{1}{2}\Delta t\beta S_{-} + \nu}{\thinspace .}\end{split}\]</div>
<p>The solutions <span class="math">\(S\)</span> and <span class="math">\(I\)</span> are stored in <span class="math">\(S_{-}\)</span> and <span class="math">\(I_{-}\)</span> and
a new iteration is carried out.</p>
</div>
<div class="section" id="newton-s-method-3">
<h3>Newton&#8217;s method  (3)<a class="headerlink" href="#newton-s-method-3" title="Permalink to this headline">¶</a></h3>
<p>The nonlinear system
<a href="#equation-nonlin:systems:alg:SI:CN:FS">(10)</a>-<a href="#equation-nonlin:systems:alg:SI:CN:FI">(11)</a>
can be written as <span class="math">\(F(u)=0\)</span> with <span class="math">\(F=(F_S,F_I)\)</span> and <span class="math">\(u=(S,I)\)</span>.  The
Jacobian becomes</p>
<div class="math">
\[\begin{split}\renewcommand*{\arraystretch}{2}
J = \left(\begin{array}{cc}
\frac{\partial}{\partial S} F_S &amp; \frac{\partial}{\partial I}F_S\\
\frac{\partial}{\partial S} F_I &amp; \frac{\partial}{\partial I}F_I
\end{array}\right)
= \left(\begin{array}{cc}
1 + \frac{1}{2}\Delta t\beta I &amp; \frac{1}{2}\Delta t\beta\\
- \frac{1}{2}\Delta t\beta S &amp; 1 - \frac{1}{2}\Delta t\beta I -
\frac{1}{2}\Delta t\nu
\end{array}\right)
{\thinspace .}\end{split}\]\[The Newton system to be solved in each iteration is then\]\[!bt\]\[\begin{split}\renewcommand*{\arraystretch}{1.5}
&amp;
\left(\begin{array}{cc}
1 + \frac{1}{2}\Delta t\beta I_{-} &amp; \frac{1}{2}\Delta t\beta S_{-}\\
- \frac{1}{2}\Delta t\beta S_{-} &amp; 1 - \frac{1}{2}\Delta t\beta I_{-} -
\frac{1}{2}\Delta t\nu
\end{array}\right)
\left(\begin{array}{c}
\delta S\\
\delta I
\end{array}\right)
=\\
&amp; \qquad\qquad
\left(\begin{array}{c}
S_{-} - S_1 + \frac{1}{2}\Delta t\beta(S_1I_1 + S_{-}I_{-})\\
I_{-} - I_1 - \frac{1}{2}\Delta t\beta(S_1I_1 + S_{-}I_{-}) -
\frac{1}{2}\Delta t\nu(I_1 + I_{-})
\end{array}\right)\end{split}\]</div>
<p><strong>Remark.</strong>
For this particular system explicit time integration methods work very
well. The 4-th order Runge-Kutta method is an excellent
balance between high accuracy, high efficiency, and simplicity.</p>
</div>
</div>
</div>
<div class="section" id="linearization-at-the-differential-equation-level">
<span id="nonlin-pdelevel"></span><h1>Linearization at the differential equation level<a class="headerlink" href="#linearization-at-the-differential-equation-level" title="Permalink to this headline">¶</a></h1>
<p>The attention is now turned
to nonlinear partial differential equations (PDEs)
and application of the techniques explained for ODEs.
The model problem is a nonlinear diffusion equation</p>
<div class="math" id="equation-nonlin:pdelevel:model:pde">
<span id="eq-nonlin-pdelevel-model-pde"></span><span class="eqno">(12)</span>\[     \frac{\partial u}{\partial t} = \nabla\cdot ({\alpha}(u)\nabla u) + f(u),\quad
     \boldsymbol{x}\in\Omega,\ t\in (0,T],\]</div>
<div class="math" id="equation-nonlin:pdelevel:model:Neumann">
<span id="eq-nonlin-pdelevel-model-neumann"></span><span class="eqno">(13)</span>\[     -{\alpha}(u)\frac{\partial u}{\partial n} = g,\quad \boldsymbol{x}\in\partial\Omega_N,\
     t\in (0,T],\]</div>
<div class="math" id="equation-nonlin:pdelevel:model:Dirichlet">
<span id="eq-nonlin-pdelevel-model-dirichlet"></span><span class="eqno">(14)</span>\[     u = u_0,\quad \boldsymbol{x}\in\partial\Omega_D,\ t\in (0,T]{\thinspace .}\]</div>
<p>Our aim is to discretize the problem in time and then present
techniques for linearizing the time-discrete PDE problem &#8220;at the PDE
level&#8221; such that we transform the nonlinear stationary PDE problems at
each time level into a sequence of linear PDE problems, which can be
solved using any method for linear PDEs. This strategy avoids the
solution systems of nonlinear algebraic equations.  In the section <a class="reference internal" href="#nonlin-alglevel-1d"><em>Discretization of nonlinear differential equations</em></a> we shall take the opposite (and more common)
approach: discretize the nonlinear problem in time and space first,
and then solve the resulting nonlinear algebraic equations at each
time level by the methods of the section <a class="reference internal" href="#nonlin-systems-alg"><em>Systems of nonlinear algebraic equations</em></a>.</p>
<div class="section" id="explicit-time-integration">
<span id="nonlin-pdelevel-explicit"></span><h2>Explicit time integration<a class="headerlink" href="#explicit-time-integration" title="Permalink to this headline">¶</a></h2>
<p>The nonlinearities in the PDE are trivial to deal with if we choose
an explicit time integration method
for <a href="#equation-nonlin:pdelevel:model:pde">(12)</a>, such as the Forward Euler method:</p>
<div class="math">
\[D_t^+ u = \nabla\cdot ({\alpha}(u)\nabla u) + f(u)]^n,\]</div>
<p>which leads to a linear equation in the unknown <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = \nabla\cdot ({\alpha}(u^n)\nabla u^n)
+ f(u^n){\thinspace .}\]</div>
</div>
<div class="section" id="picard-iteration-3">
<span id="nonlin-pdelevel-picard"></span><h2>Picard iteration  (3)<a class="headerlink" href="#picard-iteration-3" title="Permalink to this headline">¶</a></h2>
<p>A Backward Euler scheme for <a href="#equation-nonlin:pdelevel:model:pde">(12)</a>
reads</p>
<div class="math">
\[D_t^- u = \nabla\cdot ({\alpha}(u)\nabla u) + f(u)]^n{\thinspace .}\]</div>
<p>Written out,</p>
<div class="math" id="equation-nonlin:pdelevel:pde:BE">
<span id="eq-nonlin-pdelevel-pde-be"></span><span class="eqno">(15)</span>\[     \frac{u^{n} - u^{n-1}}{\Delta t} = \nabla\cdot ({\alpha}(u^n)\nabla u^n)
     + f(u^n)\]</div>
<p>This is a nonlinear, stationary PDE for the unknown function <span class="math">\(u^n(\boldsymbol{x})\)</span>.
We introduce a Picard iteration with <span class="math">\(k\)</span> as iteration counter.
A typical linearization of the <span class="math">\(\nabla\cdot{\alpha}(u^n)\nabla u^n\)</span> term
in iteration <span class="math">\(k+1\)</span> is to use the previously computed <span class="math">\(u^{n,k}\)</span>
approximation in the diffusion coefficient: <span class="math">\({\alpha}(u^{n,k})\)</span>.
The nonlinear source term is treated similarly: <span class="math">\(f(u^{n,k})\)</span>.
The unknown function <span class="math">\(u^{n,k+1}\)</span> then fulfills the linear PDE</p>
<div class="math" id="equation-nonlin:pdelevel:pde:BE:Picard:k">
<span id="eq-nonlin-pdelevel-pde-be-picard-k"></span><span class="eqno">(16)</span>\[     \frac{u^{n,k+1} - u^{n-1}}{\Delta t} = \nabla\cdot ({\alpha}(u^{n,k})
     \nabla u^{n,k+1})
     + f(u^{n,k}){\thinspace .}\]</div>
<p>The initial guess for the Picard iteration at this time level can be
taken as the solution at the previous time level: <span class="math">\(u^{n,0}=u^{n-1}\)</span>.</p>
<p>We can alternatively apply the notation where <span class="math">\(u\)</span> corresponds to
the unknown we want to solve for, i.e., <span class="math">\(u^{n,k+1}\)</span> above, let <span class="math">\(u_{-}\)</span>
be the most recently computed value, <span class="math">\(u^{n,k}\)</span> above, and let
<span class="math">\(u_1\)</span> denote the unknown function at the previous time level, <span class="math">\(u^{n-1}\)</span>
above. The PDE to be solved in a Picard iteration then looks like</p>
<div class="math" id="equation-nonlin:pdelevel:pde:BE:Picard">
<span id="eq-nonlin-pdelevel-pde-be-picard"></span><span class="eqno">(17)</span>\[     \frac{u - u_1}{\Delta t} = \nabla\cdot ({\alpha}(u_{-})
     \nabla u)
     + f(u_{-}){\thinspace .}\]</div>
<p>At the beginning of the iteration we start with the value from the
previous time level: <span class="math">\(u_{-}=u_1\)</span>.</p>
</div>
<div class="section" id="newton-s-method-4">
<span id="nonlin-pdelevel-newton"></span><h2>Newton&#8217;s method  (4)<a class="headerlink" href="#newton-s-method-4" title="Permalink to this headline">¶</a></h2>
<p>At time level <span class="math">\(n\)</span> we have to solve the stationary PDE
<a href="#equation-nonlin:pdelevel:pde:BE">(15)</a>, this time with Newton&#8217;s method.
Normally, Newton&#8217;s method is defined for systems of <em>algebraic equations</em>,
but the idea of the method can be applied at the PDE level too.</p>
<p>Let <span class="math">\(u^{n,k}\)</span> be an approximation to <span class="math">\(u^n\)</span>. We seek a
better approximation on
the form</p>
<div class="math" id="equation-nonlin:pdelevel:Newton:ansatz">
<span id="eq-nonlin-pdelevel-newton-ansatz"></span><span class="eqno">(18)</span>\[     u^{n} = u^{n,k} + \delta u{\thinspace .}\]</div>
<p>The idea is to insert <a href="#equation-nonlin:pdelevel:Newton:ansatz">(18)</a> in
<a href="#equation-nonlin:pdelevel:pde:BE">(15)</a>, Taylor expand the nonlinearities
and only keep the terms that are
linear in <span class="math">\(\delta u\)</span>. Then we can solve a linear PDE for
the correction <span class="math">\(\delta u\)</span> and use <a href="#equation-nonlin:pdelevel:Newton:ansatz">(18)</a>
to find a new approximation <span class="math">\(u^{n,k+1}=u^{n,k}+\delta u\)</span> to <span class="math">\(u^{n}\)</span>.</p>
<p>Inserting <a href="#equation-nonlin:pdelevel:Newton:ansatz">(18)</a> in
<a href="#equation-nonlin:pdelevel:pde:BE">(15)</a> gives</p>
<div class="math" id="equation-nonlin:pdelevel:pde:BE:Newton1">
<span id="eq-nonlin-pdelevel-pde-be-newton1"></span><span class="eqno">(19)</span>\[     \frac{u^{n,k} +\delta u - u^{n-1}}{\Delta t} =
     \nabla\cdot ({\alpha}(u^{n,k} + \delta u)\nabla (u^{n,k}+\delta u))
     + f(u^{n,k}+\delta u)\]</div>
<p>We can Taylor expand <span class="math">\({\alpha}(u^{n,k} + \delta u)\)</span> and
<span class="math">\(f(u^{n,k}+\delta u)\)</span>:</p>
<div class="math">
\[\begin{split}{\alpha}(u^{n,k} + \delta u) &amp; = {\alpha}(u^{n,k}) + \frac{d{\alpha}}{du}(u^{n,k})
\delta u + {\mathcal{O}(\delta u^2)}\approx {\alpha}(u^{n,k}) + {\alpha}'(u^{n,k})\delta u,\\
f(u^{n,k}+\delta u) &amp;=  f(u^{n,k}) + \frac{df}{du}(u^{n,k})\delta u
+ {\mathcal{O}(\delta u^2)}\approx f(u^{n,k}) + f'(u^{n,k})\delta u{\thinspace .}\end{split}\]</div>
<p>Inserting the linear approximations of <span class="math">\({\alpha}\)</span> and <span class="math">\(f\)</span> in
<a href="#equation-nonlin:pdelevel:pde:BE:Newton1">(19)</a> results in</p>
<div class="math">
\[\frac{u^{n,k} +\delta u - u^{n-1}}{\Delta t} =
\nabla\cdot ({\alpha}(u^{n,k})\nabla u^{n,k}) + f(u^{m,k}) + \nonumber\]</div>
<div class="math">
\[\quad \nabla\cdot ({\alpha}(u^{n,k})\nabla \delta u)
+ \nabla\cdot ({\alpha}'(u^{n,k})\delta u\nabla u^{n,k}) + \nonumber\]</div>
<div class="math" id="equation-nonlin:pdelevel:pde:BE:Newton2">
<span id="eq-nonlin-pdelevel-pde-be-newton2"></span><span class="eqno">(20)</span>\[     \quad \nabla\cdot ({\alpha}'(u^{n,k})\delta u\nabla \delta u)
     + f'(u^{n,k})\delta u\]</div>
<p>The term <span class="math">\({\alpha}'(u^{n,k})\delta u\nabla \delta u\)</span> is <span class="math">\({\mathcal{O}(\delta u^2)}\)</span>
and therefore omitted. Reorganizing the equation gives a PDE
for <span class="math">\(\delta u\)</span> that we can write in short form as</p>
<div class="math">
\[\delta F(\delta u; u^{n,k}) = -F(u^{n,k}),\]</div>
<p>where</p>
<div class="math" id="equation-nonlin:pdelevel:pde:BE:Newton2:F">
<span id="eq-nonlin-pdelevel-pde-be-newton2-f"></span><span class="eqno">(21)</span>\[     F(u^{n,k}) = \frac{u^{n,k} - u^{n-1}}{\Delta t} -
     \nabla\cdot ({\alpha}(u^{n,k})\nabla u^{n,k}) + f(u^{n,k}),\]</div>
<div class="math">
\[\delta F(\delta u; u^{n,k}) =
- \frac{1}{\Delta t}\delta u +
\nabla\cdot ({\alpha}(u^{n,k})\nabla \delta u) + \nonumber\]</div>
<div class="math">
\[\quad \nabla\cdot ({\alpha}'(u^{n,k})\delta u\nabla u^{n,k})
+ f'(u^{n,k})\delta u{\thinspace .}\]</div>
<p>Note that <span class="math">\(\delta F\)</span> is a linear function of <span class="math">\(\delta u\)</span>, and
<span class="math">\(F\)</span> contains only terms that are known, such that
the PDE for <span class="math">\(\delta u\)</span> is indeed linear.</p>
<p>The form <span class="math">\(\delta F = -F\)</span> resembles the Newton system <span class="math">\(J\delta u =-F\)</span>
for systems of algebraic equations, with <span class="math">\(\delta F\)</span> as <span class="math">\(J\delta u\)</span>.
The unknown vector in a linear system of algebraic equations enters
the system as a matrix-vector product (<span class="math">\(J\delta u\)</span>), while at
the PDE level we have a linear differential operator instead
(<span class="math">\(\delta F\)</span>).</p>
<p>We can rewrite the PDE for <span class="math">\(\delta u\)</span> in a slightly different way too
if we define <span class="math">\(u^{n,k} + \delta u\)</span> as <span class="math">\(u^{n,k+1}\)</span>.</p>
<div class="math">
\[ \frac{u^{n,k+1} - u^{n-1}}{\Delta t} =
\nabla\cdot ({\alpha}(u^{n,k})\nabla u^{n,k+1}) + f(u^{n,k}) + \nonumber\]</div>
<div class="math">
\[\qquad  \nabla\cdot ({\alpha}'(u^{n,k})\delta u\nabla u^{n,k})
+ f'(u^{n,k})\delta u{\thinspace .}\]</div>
<p>Note that the first line is the same PDE as arise in the Picard
iteration, while the remaining terms arise from the differentiations
that are an inherent ingredient in Newton&#8217;s method.</p>
<p>For coding we want to introduce <span class="math">\(u_{-}\)</span> for <span class="math">\(u^{n,k}\)</span> and
<span class="math">\(u_1\)</span> for <span class="math">\(u^{n-1}\)</span>. The formulas for <span class="math">\(F\)</span> and <span class="math">\(\delta F\)</span>
are then</p>
<div class="math" id="equation-nonlin:pdelevel:pde:BE:Newton2:F2">
<span id="eq-nonlin-pdelevel-pde-be-newton2-f2"></span><span class="eqno">(22)</span>\[     F(u_{-}) = \frac{u_{-} - u_1}{\Delta t} -
     \nabla\cdot ({\alpha}(u_{-})\nabla u_{-}) + f(u_{-}),\]</div>
<div class="math">
\[\delta F(\delta u; u_{-}) =
- \frac{1}{\Delta t}\delta u +
\nabla\cdot ({\alpha}(u_{-})\nabla \delta u) + \nonumber\]</div>
<div class="math">
\[\quad \nabla\cdot ({\alpha}'(u_{-})\delta u\nabla u_{-})
+ f'(u_{-})\delta u{\thinspace .}\]</div>
<p>The form that orders the PDE as the Picard iteration terms plus
the Newton method&#8217;s derivative terms becomes</p>
<div class="math">
\[ \frac{u - u_1}{\Delta t} =
\nabla\cdot ({\alpha}(u_{-})\nabla u) + f(u_{-}) + \nonumber\]</div>
<div class="math">
\[\qquad  \nabla\cdot ({\alpha}'(u_{-})\delta u\nabla u_{-})
+ f'(u_{-})\delta u{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="discretization-of-nonlinear-differential-equations">
<span id="nonlin-alglevel-1d"></span><h1>Discretization of nonlinear differential equations<a class="headerlink" href="#discretization-of-nonlinear-differential-equations" title="Permalink to this headline">¶</a></h1>
<p>the section <a class="reference internal" href="#nonlin-pdelevel"><em>Linearization at the differential equation level</em></a> presents methods for linearizing
time-discrete PDEs directly prior to discretization in space.  We can
alternatively carry out the discretization in space and of the
time-discrete nonlinear PDE problem and get a system of nonlinear
algebraic equations, which can be solved by Picard iteration or
Newton&#8217;s method as presented in the section <a class="reference internal" href="#nonlin-systems-alg"><em>Systems of nonlinear algebraic equations</em></a>.
This latter approach will now be described in detail.</p>
<p>We shall work with the 1D problem</p>
<div class="math" id="equation-nonlin:alglevel:1D:pde">
<span id="eq-nonlin-alglevel-1d-pde"></span><span class="eqno">(23)</span>\[     -({\alpha}(u)u')' + au = f(u),\quad x\in (0,L),
     \quad {\alpha}(u(0))u'(0) = C,\ u(L)=0
     {\thinspace .}\]</div>
<p>This problem is of the same nature as those arising from implicit
time integration of a nonlinear diffusion PDE as outlined in
the section <a class="reference internal" href="#nonlin-pdelevel-picard"><em>Picard iteration  (3)</em></a> (set <span class="math">\(a=1/\Delta t\)</span> and let
<span class="math">\(f(u)\)</span> incorporate the nonlinear source term as well as
known terms with the time-dependent unknown function at the previous
time level).</p>
<div class="section" id="finite-difference-discretizations">
<span id="nonlin-alglevel-1d-fd"></span><h2>Finite difference discretizations<a class="headerlink" href="#finite-difference-discretizations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="discretization">
<h3>Discretization<a class="headerlink" href="#discretization" title="Permalink to this headline">¶</a></h3>
<p>The nonlinearity in
the differential equation <a href="#equation-nonlin:alglevel:1D:pde">(23)</a> poses no more
difficulty than a variable coefficient, as in <span class="math">\(({\alpha}(x)u')'\)</span>.
We can therefore use a standard approach to discretizing the Laplace
term with a variable coefficient:</p>
<div class="math">
\[[-D_x{\alpha} D_x u +au = f]_i{\thinspace .}\]</div>
<p>Writing this out for a uniform mesh with points <span class="math">\(x_i=i\Delta x\)</span>,
<span class="math">\(i=0,\ldots,N_x\)</span>, leads to</p>
<div class="math" id="equation-nonlin:alglevel:1D:fd:deq0">
<span id="eq-nonlin-alglevel-1d-fd-deq0"></span><span class="eqno">(24)</span>\[     -\frac{1}{\Delta x^2}
     \left({\alpha}_{i+\frac{1}{2}}(u_{i+1}-u_i) -
     {\alpha}_{i-\frac{1}{2}}(u_{i}-u_{i-1})\right)
     + au_i = f(u_i){\thinspace .}\]</div>
<p>This equation is valid at all the mesh points <span class="math">\(i=0,1,\ldots,N_x-1\)</span>.
At <span class="math">\(i=N_x\)</span> we have the Dirichlet condition <span class="math">\(u_i=0\)</span>.
The only difference from the case with <span class="math">\(({\alpha}(x)u')'\)</span> and <span class="math">\(f(x)\)</span> is that
now <span class="math">\({\alpha}\)</span> and <span class="math">\(f\)</span> are functions of <span class="math">\(u\)</span> and not only on <span class="math">\(x\)</span>:
<span class="math">\(({\alpha}(u(x))u')'\)</span> and <span class="math">\(f(u(x))\)</span>.</p>
<p>The quantity <span class="math">\({\alpha}_{i+\frac{1}{2}}\)</span>, evaluated between two mesh points,
needs a comment. Since <span class="math">\({\alpha}\)</span> depends on <span class="math">\(u\)</span> and <span class="math">\(u\)</span> is only known
at the mesh points, we need to express <span class="math">\({\alpha}_{i+\frac{1}{2}}\)</span> in
terms of <span class="math">\(u_i\)</span> and <span class="math">\(u_{i+1}\)</span>. For this purpose we use an arithmetic
mean, although a harmonic mean is also common in this context if
<span class="math">\({\alpha}\)</span> features large jumps.
There are two choices of arithmetic means:</p>
<div class="math" id="equation-nonlin:alglevel:1D:fd:dfc:mean:u">
<span id="eq-nonlin-alglevel-1d-fd-dfc-mean-u"></span><span class="eqno">(25)</span>\[     {\alpha}_{i+\frac{1}{2}} \approx
     {\alpha}(\frac{1}{2}(u_i + u_{i+1}) =
     [{\alpha}(\overline{u}^x)]^{i+\frac{1}{2}},\]</div>
<div class="math" id="equation-nonlin:alglevel:1D:fd:dfc:mean:dfc">
<span id="eq-nonlin-alglevel-1d-fd-dfc-mean-dfc"></span><span class="eqno">(26)</span>\[     {\alpha}_{i+\frac{1}{2}} \approx
     \frac{1}{2}({\alpha}(u_i) + {\alpha}(u_{i+1})) = [\overline{{\alpha}(u)}^x]^{i+\frac{1}{2}}\]</div>
<p>Equation <a href="#equation-nonlin:alglevel:1D:fd:deq0">(24)</a> with
the latter approximation then looks like</p>
<div class="math">
\[-\frac{1}{2\Delta x^2}
\left(({\alpha}(u_i)+{\alpha}(u_{i+1}))(u_{i+1}-u_i) -
({\alpha}(u_{i-1})+{\alpha}(u_{i}))(u_{i}-u_{i-1})\right)\nonumber\]</div>
<div class="math" id="equation-nonlin:alglevel:1D:fd:deq">
<span id="eq-nonlin-alglevel-1d-fd-deq"></span><span class="eqno">(27)</span>\[     \qquad\qquad + au_i = f(u_i),\]</div>
<p>or written more compactly,</p>
<div class="math">
\[[-D_x\overline{{\alpha}}^x D_x u +au = f]_i{\thinspace .}\]</div>
<p>At mesh point <span class="math">\(i=0\)</span> we have the boundary condition <span class="math">\({\alpha}(u)u'=C\)</span>,
which is discretized by</p>
<div class="math">
\[[{\alpha}(u)D_{2x}u = C]_0,\]</div>
<p>meaning</p>
<div class="math" id="equation-nonlin:alglevel:1D:fd:Neumann:x0">
<span id="eq-nonlin-alglevel-1d-fd-neumann-x0"></span><span class="eqno">(28)</span>\[     {\alpha}(u_0)\frac{u_{1} - u_{-1}}{2\Delta x} = C{\thinspace .}\]</div>
<p>The fictitious value <span class="math">\(u_{-1}\)</span> can be eliminated with the aid
of <a href="#equation-nonlin:alglevel:1D:fd:deq">(27)</a> for <span class="math">\(i=0\)</span>.
Formally, <a href="#equation-nonlin:alglevel:1D:fd:deq">(27)</a> should be solved with
respect to <span class="math">\(u_{i-1}\)</span> and that value (for <span class="math">\(i=0\)</span>) should be inserted in
<a href="#equation-nonlin:alglevel:1D:fd:Neumann:x0">(28)</a>, but it is algebraically
much easier to do it the other way around. Alternatively, one can
use a ghost cell <span class="math">\([-\Delta x,0]\)</span> and update the <span class="math">\(u_{-1}\)</span> value
in the ghost cell according to <a href="#equation-nonlin:alglevel:1D:fd:Neumann:x0">(28)</a>
after every Picard or Newton iteration. Such an approach means that
we use a known <span class="math">\(u_{-1}\)</span> value in <a href="#equation-nonlin:alglevel:1D:fd:deq">(27)</a>
from the previous iteration.</p>
</div>
<div class="section" id="solution-of-algebraic-equations">
<h3>Solution of algebraic equations<a class="headerlink" href="#solution-of-algebraic-equations" title="Permalink to this headline">¶</a></h3>
<p>The nonlinear algebraic equations <a href="#equation-nonlin:alglevel:1D:fd:deq">(27)</a> are
of the form <span class="math">\(A(u)u = b(u)\)</span> with</p>
<div class="math">
\[\begin{split}A_{i,i} &amp;= \frac{1}{2\Delta x^2}(-{\alpha}(u_{i-1}) + 2{\alpha}(u_{i})
-{\alpha}(u_{i+1})) + a,\\
A_{i,i-1} &amp;= -\frac{1}{2\Delta x^2}({\alpha}(u_{i-1}) + {\alpha}(u_{i})),\\
A_{i,i+1} &amp;= -\frac{1}{2\Delta x^2}({\alpha}(u_{i}) + {\alpha}(u_{i+1})),\\
b_i &amp;= f(u_i){\thinspace .}\end{split}\]</div>
<p>The matrix <span class="math">\(A(u)\)</span> is tridiagonal: <span class="math">\(A_{i,j}=0\)</span> for <span class="math">\(j&gt;1+1\)</span> and <span class="math">\(j&lt;i-1\)</span>.
The obvious Picard iteration scheme is to use previously computed
values of <span class="math">\(u_i\)</span> in <span class="math">\(A(u)\)</span> and <span class="math">\(b(u)\)</span>, as described more in detail in
the section <a class="reference internal" href="#nonlin-systems-alg"><em>Systems of nonlinear algebraic equations</em></a>.</p>
<p>Newton&#8217;s method requires computation of the Jacobian. Here it means
that we need to differentiate <span class="math">\(F(u)=A(u)u - b(u)\)</span> with respect to
<span class="math">\(u_0,u_1,\ldots,u_{N_x-1}\)</span>. Nonlinear equation number <span class="math">\(i\)</span> has
the structure</p>
<div class="math">
\[F_i = A_{i,i-1}(u_{i-1},u_i)u_{i-1} +
A_{i,i}(u_{i-1},u_i,u_{i+1})u_i +
A_{i,i+1}(u_i, u_{i+1})u_{i+1} - b_i(u_i){\thinspace .}\]</div>
<p>The Jacobian becomes</p>
<div class="math">
\[\begin{split}J_{i,i} &amp;= \frac{\partial F_i}{\partial u_i}
= \frac{\partial A_{i,i-1}}{\partial u_i}u_{i-1}
+ \frac{\partial A_{i,i}}{\partial u_i}u_i
- \frac{\partial b_i}{\partial u_i}
+ A_{i,i}
+ \frac{\partial A_{i,i+1}}{\partial u_i}u_{i+1}
- \frac{\partial b_i}{\partial u_{i}}\\
&amp;=
\frac{1}{2\Delta x^2}(
-{\alpha}'(u_i)u_{i-1}
+2{\alpha}'(u_i)u_{i}
+(-{\alpha}(u_{i-1}) + 2{\alpha}(u_i) - {\alpha}(u_{i+1}))) +\\
&amp;\quad a
-\frac{1}{2\Delta x^2}{\alpha}'(u_{i})u_{i+1})
- b'(u_i),\\
J_{i,i-1} &amp;= \frac{\partial F_i}{\partial u_{i-1}}
= \frac{\partial A_{i,i-1}}{\partial u_{i-1}}u_{i-1}
+ A_{i-1,i}
+ \frac{\partial A_{i,i}}{\partial u_{i-1}}u_i
- \frac{\partial b_i}{\partial u_{i-1}}\\
&amp;=
\frac{1}{2\Delta x^2}(
-{\alpha}'(u_{i-1})u_{i-1} - ({\alpha}(u_{i-1}) + {\alpha}(u_i))
+ {\alpha}'(u_{i-1})u_i),\\
J_{i,i+1} &amp;= \frac{\partial A_{i,i+1}}{\partial u_{i-1}}u_{i+1}
+ A_{i+1,i} +
\frac{\partial A_{i,i}}{\partial u_{i+1}}u_i
- \frac{\partial b_i}{\partial u_{i+1}}\\
&amp;=\frac{1}{2\Delta x^2}(
-{\alpha}'(u_{i+1})u_{i+1} - ({\alpha}(u_{i}) + {\alpha}(u_{i+1}))
+ {\alpha}'(u_{i+1})u_i){\thinspace .}
{\thinspace .}\end{split}\]</div>
<p>The explicit expression for nonlinear equation number <span class="math">\(i\)</span>,
<span class="math">\(F_i(u_0,u_1,\ldots)\)</span>, arises from moving all terms in
<a href="#equation-nonlin:alglevel:1D:fd:deq">(27)</a> to the left-hand side. Then we have
<span class="math">\(J_{i,j}\)</span> and <span class="math">\(F_i\)</span> (modulo the boundary conditions) and can implement
Newton&#8217;s method.</p>
<p>We have seen, and can see from the present example, that the
linear system in Newton&#8217;s method contains all the terms present
in the system that arises in the Picard iteration method.
The extra terms in Newton&#8217;s method can be multiplied by a factor
such that it is easy to program one linear system and set this
factor to 0 or 1 to generate the Picard or Newton system.</p>
</div>
</div>
<div class="section" id="finite-element-discretizations">
<span id="nonlin-alglevel-1d-fe"></span><h2>Finite element discretizations<a class="headerlink" href="#finite-element-discretizations" title="Permalink to this headline">¶</a></h2>
<p>For the finite element discretization we first need to derive the
variational problem. Let <span class="math">\(V\)</span> be an appropriate function space
with basis functions <span class="math">\(\left\{ {{\psi}}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>. Because of the
Dirichlet condition at <span class="math">\(x=L\)</span> we require <span class="math">\({\psi}_i(L)=0\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>.
Using Galerkin&#8217;s method,
we multiply the differential equation by any <span class="math">\(v\in V\)</span>, integrate
terms with second-order derivatives by parts, and insert the
Neumann condition at <span class="math">\(x=0\)</span>. The variational problem is then:
find <span class="math">\(u\in V\)</span> such that</p>
<div class="math" id="equation-nonlin:alglevel:1D:pde:varform">
<span id="eq-nonlin-alglevel-1d-pde-varform"></span><span class="eqno">(29)</span>\[     \int_0^L {\alpha}(u)u'v'{\, \mathrm{d}x} + \int_0^L auv{\, \mathrm{d}x} =
     \int_0^L f(u)v{\, \mathrm{d}x} - Cv(0),\quad \forall v\in V{\thinspace .}\]</div>
<p>To derive the algebraic equations we also demand the above equations
to hold for <span class="math">\(v={\psi}_i\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>, and we set
<span class="math">\(u=\sum_{j\in{\mathcal{I}_s}}c_j{\psi}_j\)</span>. The result is</p>
<div class="math">
\[\sum_{j\in{\mathcal{I}_s}}\left(
\int_0^L {\alpha}(\sum_{k\in{\mathcal{I}_s}}c_k{\psi}_k)
{\psi}_j'{\psi}_i'{\, \mathrm{d}x}\right)c_j =
\int_0^L f(\sum_{k\in{\mathcal{I}_s}}c_k{\psi}_k){\psi}_i{\, \mathrm{d}x} -
C{\psi}_i(0),\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<div class="section" id="remark">
<h3>Remark<a class="headerlink" href="#remark" title="Permalink to this headline">¶</a></h3>
<p>Fundamental integration problem
Methods that use the Galerkin or weighted residual principle
face a fundamental difficulty in nonlinear
problems: how can we integrate a terms like
<span class="math">\(\int_0^L {\alpha}(\sum_{k}c_k{\psi}_k){\psi}_i'{\psi}_j'{\, \mathrm{d}x}\)</span>
and <span class="math">\(\int_0^L f(\sum_{k}c_k{\psi}_k){\psi}_i{\, \mathrm{d}x}\)</span>
when we do not know
the <span class="math">\(c_k\)</span> coefficients in the argument of the <span class="math">\({\alpha}\)</span> function?
We can resort to numerical integration, provided an approximate
<span class="math">\(\sum_kc_k{\psi}_k\)</span> can be used for the argument <span class="math">\(u\)</span> in <span class="math">\(f\)</span> and <span class="math">\({\alpha}\)</span>.
If we want to derive the structure of the nonlinear algebraic
equations, we need to apply numerical integration based on the
nodes only and/or the group finite element method.</p>
</div>
</div>
<div class="section" id="the-group-finite-element-method">
<span id="nonlin-alglevel-1d-fe-group"></span><h2>The group finite element method<a class="headerlink" href="#the-group-finite-element-method" title="Permalink to this headline">¶</a></h2>
<div class="section" id="finite-element-notation">
<h3>Finite element notation<a class="headerlink" href="#finite-element-notation" title="Permalink to this headline">¶</a></h3>
<p>Let us simplify the model problem for a while and set <span class="math">\(a=0\)</span>, <span class="math">\({\alpha}=1\)</span>,
<span class="math">\(f(u)=u^2\)</span>, and have Dirichlet conditions at both ends such that we
get a very simple nonlinear problem <span class="math">\(-u''=u^2\)</span>. The variational form
is then</p>
<div class="math">
\[\int_0^L u'v'{\, \mathrm{d}x} = \int_0^L u^2v{\, \mathrm{d}x},\quad\forall v\in V{\thinspace .}\]</div>
<p>The term with <span class="math">\(u'v'\)</span> is well known so the only new feature is
the term <span class="math">\(\int u^2v{\, \mathrm{d}x}\)</span>.</p>
<p>Introduction of finite element basis functions <span class="math">\({\varphi}_i\)</span> means setting</p>
<div class="math">
\[{\psi}_i = {\varphi}_{\nu(i)},\quad i\in{\mathcal{I}_s},\]</div>
<p>where degree of freedom number <span class="math">\(\nu(j)\)</span> in the mesh corresponds to
unknown number <span class="math">\(j\)</span>. When the degrees of freedom are just the function
values at nodes, we have that <span class="math">\(c_j=u(x_{\nu(j)})=u_{\nu(j)}\)</span>, i.e., the value of
<span class="math">\(u\)</span> at node number <span class="math">\(\nu(j)\)</span>.
The finite element expansion for <span class="math">\(u\)</span>
is now</p>
<div class="math">
\[u = \sum_{j\in{I_b}} U_j{\varphi}_j + \sum_{j\in{\mathcal{I}_s}}{\varphi}_{\nu(j)}u_{\nu(j)},\]</div>
<p>with the <span class="math">\(U_j\)</span> quantities being prescribed Dirichlet values at some nodes
with numbers in the index <span class="math">\({I_b}\)</span>. Instead of the <span class="math">\(\nu(j)\)</span> indices
in the sum <span class="math">\(\sum_{j\in{\mathcal{I}_s}}{\varphi}_{\nu(j)}u_{\nu(j)}\)</span>, we just write
<span class="math">\(\sum_{j}{\varphi}_ju_j\)</span>. This is possible by saying that <span class="math">\(j\)</span> runs over
a transformed index set:
<span class="math">\(\{\nu(0),\nu(1),\ldots,\nu(N)\}\)</span>. In the following we drop the
boundary term <span class="math">\(\sum_j U_j{\varphi}_j\)</span> and write
<span class="math">\(u = \sum_j{\varphi}_j u_j\)</span>. The replacement of <span class="math">\(c_j\)</span> by <span class="math">\(u_j\)</span> as explained
is motivated by simpler interpretation of the nonlinear algebraic
equations as a finite difference scheme.</p>
</div>
<div class="section" id="integrating-nonlinear-functions">
<h3>Integrating nonlinear functions<a class="headerlink" href="#integrating-nonlinear-functions" title="Permalink to this headline">¶</a></h3>
<p>Consider the term <span class="math">\(\int u^2v{\, \mathrm{d}x}\)</span> in the variational formulation
with <span class="math">\(v={\varphi}_i\)</span> and <span class="math">\(u=\sum_k{\varphi}_ku_k\)</span>:</p>
<div class="math">
\[\int_0^L (\sum_ku_k{\varphi}_k)^2{\varphi}_i{\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Evaluating this integral for P1 elements (see <a class="reference internal" href="#nonlin-exer-fu-fem-int"><em>Problem 9: Integrate functions of finite element expansions</em></a>) results in the expression</p>
<div class="math">
\[\frac{h}{12}(u_{i-1}^2 + 2u_i(u_{i-1} + u_{i+1}) + 6u_i^2
+ u_{i+1}^2,\]</div>
<p>to be compared with the simple value <span class="math">\(u_i^2\)</span> that would arise in
a finite difference discretization. More complicated <span class="math">\(f(u)\)</span> functions
give rise to much more lengthy expressions, if it is possible to
carry out the integral symbolically.</p>
<span class="target" id="index-11"></span></div>
<div class="section" id="finite-element-approximation-of-functions-of">
<span id="index-12"></span><h3>Finite element approximation of functions of <span class="math">\(u\)</span><a class="headerlink" href="#finite-element-approximation-of-functions-of" title="Permalink to this headline">¶</a></h3>
<p>Since we already expand <span class="math">\(u\)</span> as <span class="math">\(\sum_j{\varphi}_ju_j\)</span> we may use the
same approximation for nonlinearities. That is, any function can be
expanded as a sum of basis functions times the function values.
In particular,</p>
<div class="math">
\[f(u)\approx \sum_{j\in{I_b}} {\varphi}_jf(u_j)
+ \sum_{j} {\psi}_{j}(x)f(u_j),\]</div>
<p>where the first sum contain <span class="math">\(f\)</span> values at the boundary where <span class="math">\(u\)</span> has
Dirichlet conditions and the other sum is over the node values <span class="math">\(j\)</span>
where <span class="math">\(u\)</span> is unknown. However, for <span class="math">\(f\)</span> there is no reason two have
two summations as we do not need to distinguish between the nodes where
<span class="math">\(u\)</span> are known or unknown. Therefore, we can collapse the two
sums into one (over all nodes, <span class="math">\(j=0,\ldots,N_n\)</span>) and write</p>
<div class="math">
\[f(u) \approx \sum_{j=0}^{N_n} {\varphi}_j(x)f(u_j){\thinspace .}\]</div>
<p>This approximation is known as the <em>group finite element method</em>
or the <em>product approximation</em> technique.</p>
<p>The principal advantage of the group finite element method is for
deriving the <em>symbolic form</em> of difference equations in nonlinear problems.
The symbolic form is useful for comparing finite element and finite
difference equations of nonlinear differential equation problems.
Computer programs
will always integrate <span class="math">\(\int f(u){\varphi}_i{\, \mathrm{d}x}\)</span> numerically by using
an existing approximation of <span class="math">\(u\)</span> in <span class="math">\(f(u)\)</span> such that the integrand
can be sampled at any spatial point.</p>
</div>
<div class="section" id="application">
<h3>Application<a class="headerlink" href="#application" title="Permalink to this headline">¶</a></h3>
<p>Let use the group finite element method to derive the terms in
the difference equation corresponding to <span class="math">\(f(u)\)</span> in the differential
equation. We have</p>
<div class="math">
\[\int_0^L f(u){\varphi}_i{\, \mathrm{d}x} \approx
\int_0^L (\sum_j {\varphi}_jf(u_j)){\varphi}_i{\, \mathrm{d}x}
= \sum_j \left(\int_0^L {\varphi}_i{\varphi}_j{\, \mathrm{d}x}\right) f(u_j){\thinspace .}\]</div>
<p>We recognize this expression as the mass matrix <span class="math">\(M\)</span>, arising from
<span class="math">\(\int{\varphi}_i{\varphi}_j{\, \mathrm{d}x}\)</span>, times the
vector <span class="math">\(f=(f(u_0),f(u_1),\ldots,)\)</span>: <span class="math">\(Mf\)</span>. The associated terms
in the difference equations are</p>
<div class="math">
\[\frac{h}{6}(f(u_{i-1}) + 4f(u_i) + f(u_{i+1})){\thinspace .}\]</div>
<p>Occasionally, we want to interpret this expression in terms of finite
differences and then a rewrite of this expression is convenient:</p>
<div class="math">
\[\frac{h}{6}(f(u_{i-1}) + 4f(u_i) + f(u_{i+1}))
= h[f(u) - \frac{h^2}{6}D_xD_x f(u)]_i{\thinspace .}\]</div>
<p>We may lump the mass matrix through integration with the Trapezoidal
rule. In that case the <span class="math">\(f(u)\)</span> term in the differential equation
gives rise to a single term <span class="math">\(hf(u_i)\)</span>, just as in the finite difference
method.</p>
</div>
</div>
<div class="section" id="numerical-integration-of-nonlinear-terms">
<span id="nonlin-alglevel-1d-fe-f"></span><h2>Numerical integration of nonlinear terms<a class="headerlink" href="#numerical-integration-of-nonlinear-terms" title="Permalink to this headline">¶</a></h2>
<p>Let us reconsider a term <span class="math">\(\int f(u)v{\, \mathrm{d}x}\)</span> as treated in the previous
section, but now we want to integrate this term numerically.
Such an approach can lead to easy-to-interpret formulas if we apply
a numerical integration rule that samples the integrand at the node
points.</p>
<p>The term in question takes the form</p>
<div class="math">
\[\int_0^L f(\sum_k u_k{\varphi}_k){\varphi}_i{\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Evaluation of the integrand at a node <span class="math">\(x_{\ell}\)</span> leads to a
collapse of the sum <span class="math">\(\sum_k u_k{\varphi}_k\)</span> to one term because</p>
<div class="math">
\[\sum_k u_k{\varphi}_k(x_{\ell}) = u_\ell{\thinspace .}\]</div>
<div class="math">
\[f(\sum_k u_k\underbrace{{\varphi}_k(x_{\ell})}_{\delta_{k\ell}})
\underbrace{{\varphi}_i(x_{\ell})}_{\delta_{i\ell}}
= f(u_\ell)\delta_{i\ell},\]</div>
<p>where we have used the Kronecker delta <span class="math">\(\delta_{ij}=0\)</span> if <span class="math">\(i\neq j\)</span> and
<span class="math">\(\delta_{ij}=1\)</span> if <span class="math">\(i=j\)</span>.</p>
<p>Considering the Trapezoidal rule for integration, we have</p>
<div class="math">
\[\begin{split}\int_0^L f(\sum_k u_k{\varphi}_k)(x){\varphi}_i(x){\, \mathrm{d}x}
\approx h\sum_{\ell=0}^{N_n} f(u_\ell)\delta_{i\ell} - \mathcal{C}\\
= hf(u_i){\thinspace .}\end{split}\]</div>
<p>The term <span class="math">\(\mathcal{C}\)</span> contains the evaluations of the integrand
at the ends with weight <span class="math">\(\frac{1}{2}\)</span>, needed to make a true Trapezoidal rule.
The answer <span class="math">\(hf(u_i)\)</span> must therefore be multiplied by <span class="math">\(\frac{1}{2}\)</span> if
<span class="math">\(i=0\)</span> or <span class="math">\(i=N_n\)</span>.
(<span class="math">\(\mathcal{C} = \frac{h}{2}f(u_0){\varphi}_i(0) + \frac{h}{2}f(u_{N_n}){\varphi}_i(L)\)</span>.)</p>
<p>One can easily use the Trapezoidal rule on the reference cell and
assemble the contributions. It is a bit more work in this context,
but working on the reference cell is safer as that approach is
guaranteed to handle discontinuous derivatives of finite element
functions correctly.</p>
<p>The conclusion is that it suffices to use the Trapezoidal rule if
one wants to derive the difference equations in the finite element
method and make them similar to those arising in the finite difference
method. The Trapezoidal rule has sufficient accuracy for P1 elements, but
for P2 elements one should turn to Simpson&#8217;s rule.</p>
</div>
<div class="section" id="finite-element-discretization-of-a-variable-coefficient-laplace-term">
<span id="nonlin-alglevel-1d-fe-laplace"></span><h2>Finite element discretization of a variable coefficient Laplace term<a class="headerlink" href="#finite-element-discretization-of-a-variable-coefficient-laplace-term" title="Permalink to this headline">¶</a></h2>
<p>Turning back to the model problem <a href="#equation-nonlin:alglevel:1D:pde">(23)</a>, it
remains to calculate the contribution of the <span class="math">\(({\alpha} u')'\)</span>
and boundary terms
to the difference equations. The integral in the variational form
corresponding to <span class="math">\(({\alpha} u')'\)</span> is</p>
<div class="math">
\[\int_0^L {\alpha}(\sum_k c_k{\psi}_k){\psi}_i'{\psi}_j'{\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Numerical integration utilizing a value of <span class="math">\(\sum_k c_k{\psi}_k\)</span> from
a previous iteration must in general be used to compute the integral.
Now our aim is to integrate symbolically, as much as we can, to obtain
some insight into how the finite element method approximates
this term.</p>
<p>To be able to derive symbolic expressions, we either turn to
the group finite element method or numerical integration in the
node points. Finite element basis functions <span class="math">\({\varphi}_i\)</span> are used,
we set <span class="math">\({\alpha}(u)\approx \sum_k\alpha(u_k){\varphi}_k\)</span>, and then
we write</p>
<div class="math">
\[\int_0^L {\alpha}(\sum_k c_k{\varphi}_k){\varphi}_i'{\varphi}_j'{\, \mathrm{d}x}
\approx
\sum_k (\underbrace{\int_0^L {\varphi}_k{\varphi}_i'{\varphi}_j'{\, \mathrm{d}x}}_{L_{i,j,k}})
{\alpha}(u_k) = \sum_k L_{i,j,k}{\alpha}(u_k){\thinspace .}\]</div>
<p>Further calculations are now easiest to carry out in the reference
cell. With P1 elements we can compute
<span class="math">\(L_{i,j,k}\)</span> for the two <span class="math">\(k\)</span> values that are relevant on the reference
cell. Turning to local indices, one gets</p>
<div class="math">
\[\begin{split}L_{r,s,t}^{(e)} =
\frac{1}{2h}\left(\begin{array}{rr}
1 &amp; -1\\
-1 &amp; 1
\end{array}\right),\quad t=0, 1,\end{split}\]</div>
<p>where <span class="math">\(r,s,t=0,1\)</span> are indices over local degrees of
freedom in the reference cell
(<span class="math">\(i=q(e,r)\)</span>, <span class="math">\(j=q(e,s)\)</span>, and <span class="math">\(k=q(e,t)\)</span>). The
sum <span class="math">\(\sum_k L_{i,j,k}{\alpha}(u_k)\)</span> at the cell level becomes
<span class="math">\(\sum_{t=0}^1 L_{r,s,t}^{(e)}{\alpha}(\tilde u_t)\)</span>, where <span class="math">\(\tilde u_t\)</span>
is <span class="math">\(u(x_{q(e,t)})\)</span>, i.e., the value of <span class="math">\(u\)</span> at local node number <span class="math">\(t\)</span> in
cell number <span class="math">\(e\)</span>. The element matrix becomes</p>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Laplace:Ae">
<span id="eq-nonlin-alglevel-1d-fe-laplace-ae"></span><span class="eqno">(30)</span>\[\begin{split}     \frac{1}{2} ({\alpha}(\tilde u_0) + {\alpha}(\tilde u_1))
     \frac{1}{h}\left(\begin{array}{rr}
     1 &amp; -1\\
     -1 &amp; 1
     \end{array}\right){\thinspace .}\end{split}\]</div>
<p>As usual, we employ
a left-to-right numbering of cells and nodes.
Row number <span class="math">\(i\)</span> in the global matrix gets contributions from
the first row of the element matrix in cell <span class="math">\(i-1\)</span> and the last
row of the element matrix in cell <span class="math">\(i\)</span>.
In cell number <span class="math">\(i-1\)</span> the sum
<span class="math">\({\alpha}(\tilde u_0) + {\alpha}(\tilde u_1)\)</span> corresponds to
<span class="math">\({\alpha}(u_{i-1}) + {\alpha}(u_i)\)</span>. The same becomes
<span class="math">\({\alpha}(u_{i}) + {\alpha}(u_{i+1})\)</span> in cell number <span class="math">\(i\)</span>.
We can with this insight assemble the contributions to row number <span class="math">\(i\)</span>
in the global matrix:</p>
<div class="math">
\[\frac{1}{2h}(-({\alpha}(u_{i-1}) + {\alpha}(u_i)),\quad
{\alpha}(u_{i-1}) + 2{\alpha}(u_i) + {\alpha}(u_{i+1}),\quad
{\alpha}(u_{i}) + {\alpha}(u_{i+1})){\thinspace .}\]</div>
<p>Multiplying by the vector of unknowns <span class="math">\(u_i\)</span> results in</p>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Laplace:diffeq">
<span id="eq-nonlin-alglevel-1d-fe-laplace-diffeq"></span><span class="eqno">(31)</span>\[     -\frac{1}{h}(\frac{1}{2}({\alpha}(u_i) + {\alpha}(u_{i+1}))(u_{i+1}-u_i)
     -  \frac{1}{2}({\alpha}(u_{i-1}) + {\alpha}(u_{i}))(u_{i}-u_{i-1})),\]</div>
<p>which is nothing but the standard finite difference discretization
of <span class="math">\(-({\alpha}(u)u')'\)</span> with an arithmetic mean of <span class="math">\({\alpha}(u)\)</span> (and a
factor <span class="math">\(h\)</span> because of the integration in the finite element method).</p>
<p>Instead of using the group finite element method and exact integration
we can turn to the Trapezoidal rule for computing
<span class="math">\(\int_0^L {\alpha}(\sum_k u_k{\varphi}_k){\varphi}_i'{\varphi}_j'{\, \mathrm{d}x}\)</span>, again at
the cell level since that is most convenient:</p>
<div class="math">
\[\int_{-1}^1 {\alpha}(\sum_{t=0}^1
\tilde u_t{\tilde{\varphi}}_t)\frac{2}{h}\frac{d{\tilde{\varphi}}_r}{dX}
\frac{2}{h}\frac{d{\tilde{\varphi}}_s}{dX}\frac{h}{2}dX
= \frac{1}{2h}(-1)^r(-1)^s \int_{-1}^1 {\alpha}(\sum_{t=0}^1 u_t{\tilde{\varphi}}_t(X))dX
\nonumber\]</div>
<div class="math">
\[ \approx \frac{1}{2h}(-1)^r(-1)^s(
\sum_{t=0}^1{\tilde{\varphi}}_t(-1)\tilde u_t + \sum_{t=0}^1{\tilde{\varphi}}_t(1)\tilde u_t)
\nonumber\]</div>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Laplace:Ae:Trapez">
<span id="eq-nonlin-alglevel-1d-fe-laplace-ae-trapez"></span><span class="eqno">(32)</span>\[     = \frac{1}{2h}(-1)^r(-1)^s({\alpha}(\tilde u_0) + {\alpha}(\tilde u_1)){\thinspace .}\]</div>
<p>The element matrix in <a href="#equation-nonlin:alglevel:1D:fe:Laplace:Ae:Trapez">(32)</a>
is identical to the one in
<a href="#equation-nonlin:alglevel:1D:fe:Laplace:Ae">(30)</a>, showing that the
group finite element method and Trapezoidal integration are
equivalent with a standard finite discretization of a
nonlinear Laplace term <span class="math">\(({\alpha}(u)u')'\)</span> using an arithmetic mean for
<span class="math">\({\alpha}\)</span>: <span class="math">\([D_x\overline{x}D_xu]_i\)</span>.</p>
<p>We might comment on integration in the physical coordinate system too.
The common Trapezoidal rule in the section <a class="reference internal" href="#nonlin-alglevel-1d-fe-f"><em>Numerical integration of nonlinear terms</em></a>
cannot be used to integrate derivatives like <span class="math">\({\varphi}_i'\)</span>, because
the formula is derived under the assumption of a continuous integrand.
One must instead use the more basic version of the Trapezoidal rule
where all the trapezoids are summed up. This is straightforward, but
I think it is even more straightforward to apply the Trapezoidal
rule on the reference cell and assemble the contributions.</p>
<p>The term <span class="math">\(\int auv{\, \mathrm{d}x}\)</span> in the variational form is linear and gives
these terms in the algebraic equations:</p>
<div class="math">
\[\frac{ah}{6}(u_{i-1} + 4u_i + u_{i+1})
= ah[u - \frac{h^2}{6}D_xD_x u]_i{\thinspace .}\]</div>
<p>The final term in the variational form is the Neumann condition
at the boundary: <span class="math">\(Cv(0)=C{\varphi}_i(0)\)</span>. With a left-to-right numbering
only <span class="math">\(i=0\)</span> will give a contribution <span class="math">\(Cv(0)=C\delta_{i0}\)</span> (since
<span class="math">\({\varphi}_i(0)\neq 0\)</span> only for <span class="math">\(i=0\)</span>).</p>
<div class="admonition-summary admonition">
<p class="first admonition-title">Summary</p>
<p>For the equation</p>
<div class="math">
\[-({\alpha}(u)u')' +au = f(u),\]</div>
<p>P1 finite elements results in difference equations where</p>
<blockquote class="last">
<div><ul class="simple">
<li>the term <span class="math">\(-({\alpha}(u)u')'\)</span> becomes <span class="math">\(-h[D_x\overline{{\alpha}(u)}^xD_x u]_i\)</span>
if the group finite element method or Trapezoidal integration is applied,</li>
<li><span class="math">\(f(u)\)</span> becomes <span class="math">\(hf(u_i)\)</span> with Trapezoidal integration or the
&#8220;mass matrix&#8221; representation <span class="math">\(h[f(u) - \frac{h}{6}D_xD_x f(u)]_i\)</span>
if computed by a group finite element method,</li>
<li><span class="math">\(au\)</span> leads to the &#8220;mass matrix&#8221; form <span class="math">\(ah[u - \frac{h}{6}D_xD_x u]_i\)</span>.</li>
</ul>
</div></blockquote>
</div>
<p>As we now have explicit expressions for
the nonlinear difference equations also in the finite
element method, a Picard or Newton method can be defined as shown for
the finite difference method.
Nevertheless, the general situation is that we have not assembled
finite difference-style equations by hand and the linear system
in the Picard or Newton method must therefore be defined
directly through the variational form, as shown next.</p>
</div>
<div class="section" id="picard-iteration-defined-from-the-variational-form">
<span id="nonlin-alglevel-1d-fe-picard"></span><h2>Picard iteration defined from the variational form<a class="headerlink" href="#picard-iteration-defined-from-the-variational-form" title="Permalink to this headline">¶</a></h2>
<p>We address again the problem <a href="#equation-nonlin:alglevel:1D:pde">(23)</a> with
the corresponding
variational form <a href="#equation-nonlin:alglevel:1D:pde:varform">(29)</a>.
Our aim is to define a Picard iteration based on this variational
form without any attempt to compute integrals symbolically as in
the previous three sections.
The idea  in Picard iteration is to use a previously computed <span class="math">\(u\)</span> value in
the nonlinear functions <span class="math">\({\alpha}(u)\)</span> and <span class="math">\(f(u)\)</span>. Let <span class="math">\(u_{-}\)</span> be
the available approximation to <span class="math">\(u\)</span> from the previous iteration.
The linearized variational form for Picard iteration is then</p>
<div class="math" id="equation-nonlin:alglevel:1D:pde:varform:Picard">
<span id="eq-nonlin-alglevel-1d-pde-varform-picard"></span><span class="eqno">(33)</span>\[     \int_0^L ({\alpha}(u_{-})u'v' + auv){\, \mathrm{d}x} = \int_0^L f(u_{-})v{\, \mathrm{d}x} -
     Cv(0),\quad \forall v\in V{\thinspace .}\]</div>
<p>This is a linear problem <span class="math">\(a(u,v)=L(v)\)</span> with bilinear and linear forms</p>
<div class="math">
\[a(u,v) = \int_0^L ({\alpha}(u_{-})u'v' + auv){\, \mathrm{d}x},\quad
L(v) = \int_0^L f(u_{-})v{\, \mathrm{d}x} - Cv(0){\thinspace .}\]</div>
<p>The associated linear system is computed the standard way.
Technically, we are back to solving <span class="math">\(-({\alpha}(x)u')' + au=f(x)\)</span>.</p>
</div>
<div class="section" id="newton-s-method-defined-from-the-variational-form">
<span id="nonlin-alglevel-1d-fe-newton"></span><h2>Newton&#8217;s method defined from the variational form<a class="headerlink" href="#newton-s-method-defined-from-the-variational-form" title="Permalink to this headline">¶</a></h2>
<p>Application of Newton&#8217;s method to the nonlinear variational
form <a href="#equation-nonlin:alglevel:1D:pde:varform">(29)</a> arising from
the problem <a href="#equation-nonlin:alglevel:1D:pde">(23)</a> requires identification
of the nonlinear algebraic equations <span class="math">\(F_i(c_0,\ldots,c_N)=0\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>,
and the Jacobian <span class="math">\(J_{i,j}=\partial F_i/\partial c_j\)</span> for
<span class="math">\(i,j\in{\mathcal{I}_s}\)</span>.</p>
<p>The equations <span class="math">\(F_i=0\)</span> follows from the variational form</p>
<div class="math">
\[\int_0^L ({\alpha}(u)u'v' + auv){\, \mathrm{d}x} =
\int_0^L f(u)v{\, \mathrm{d}x} - Cv(0),\quad \forall v\in V,\]</div>
<p>by choosing <span class="math">\(v={\psi}_i\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>, and setting
<span class="math">\(u=\sum_{j\in{\mathcal{I}_s}}c_j{\psi}_j\)</span>, maybe with a boundary function
to incorporate Dirichlet conditions.</p>
<p>With <span class="math">\(v={\psi}_i\)</span> we have</p>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Newton:Fi">
<span id="eq-nonlin-alglevel-1d-fe-newton-fi"></span><span class="eqno">(34)</span>\[     F_i =
     \int_0^L ({\alpha}(u)u'{\psi}_i' + au{\psi}_i -
     f(u){\psi}_i){\, \mathrm{d}x} + C{\psi}_i(0)=0,\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>In the differentiations leading to the Jacobian we will frequently use
the results</p>
<div class="math">
\[\frac{\partial u}{\partial c_j} = \frac{\partial}{\partial c_j}
\sum_kc_k{\psi}_k = {\psi}_j,\quad
\frac{\partial u'}{\partial c_j} = \frac{\partial}{\partial c_j}
\sum_kc_k{\psi}_k' = {\psi}_j'{\thinspace .}\]</div>
<p>The derivation of the Jacobian goes as</p>
<div class="math">
\[J_{i,j} = \frac{\partial F_i}{\partial c_j}
 = \int_0^L \frac{\partial}{\partial c_j}
({\alpha}(u)u'{\psi}_i' + au{\psi}_i -
f(u){\psi}_i){\, \mathrm{d}x}\nonumber\]</div>
<div class="math">
\[=
\int_0^L
(({\alpha}'(u)\frac{\partial u}{\partial c_j}u' +
{\alpha}(u)\frac{\partial u'}{\partial c_j}){\psi}_i'
+ a\frac{\partial u}{\partial c_j}{\psi}_i -
f'(u)\frac{\partial u}{\partial c_j}{\psi}_i){\, \mathrm{d}x}\nonumber\]</div>
<div class="math">
\[=
\int_0^L
(({\alpha}'(u){\psi}_ju' +
{\alpha}(u){\psi}_j'{\psi}_i'
+ a{\psi}_j{\psi}_i -
f'(u){\psi}_j{\psi}_i){\, \mathrm{d}x}\nonumber\]</div>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Newton:Jij">
<span id="id2"></span><span class="eqno">(35)</span>\[     =
     \int_0^L
     ({\alpha}'(u)u'{\psi}_i'{\psi}_j +
     {\alpha}(u){\psi}_i'{\psi}_j'
     + (a - f(u)){\psi}_i{\psi}_j){\, \mathrm{d}x}\]</div>
<p>When calculating the right-hand side vector <span class="math">\(F_i\)</span> and the coefficient
matrix <span class="math">\(J_{i,j}\)</span> in the linear system to be solved in each Newton
iteration, one must use
a previously computed <span class="math">\(u\)</span>, denoted by <span class="math">\(u_{-}\)</span>, for
the <span class="math">\(u\)</span> in <a href="#equation-nonlin:alglevel:1D:fe:Newton:Fi">(34)</a> and
<a href="#equation-nonlin:alglevel:1D:fe:Newton:Jij">(37)</a>.
With this notation we have</p>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Newton:Fi2">
<span id="eq-nonlin-alglevel-1d-fe-newton-fi2"></span><span class="eqno">(36)</span>\[     F_i =
     \int_0^L\left(
     {\alpha}(u_{-})u_{-}'{\psi}_i' +
     (a-f(u_{-})){\psi}_i\right){\, \mathrm{d}x} -
     C{\psi}_i(0),\quad i\in{\mathcal{I}_s},\]</div>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Newton:Jij">
<span id="id4"></span><span class="eqno">(37)</span>\[     J_{i,j} =
     \int_0^L
     ({\alpha}'(u_{-})u_{-}'{\psi}_i'{\psi}_j +
     {\alpha}(u_{-}){\psi}_i'{\psi}_j'
     + (a - f(u_{-})){\psi}_i{\psi}_j){\, \mathrm{d}x},
     \quad i,j\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>These expressions can be used for any basis <span class="math">\(\left\{ {{\psi}}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>.
Choosing finite element functions for <span class="math">\({\psi}_i\)</span>, one will
normally want to compute the integral contribution cell by cell,
working in a reference cell. To this end, we restrict the
integration to one cell and transform the cell to <span class="math">\([-1,1]\)</span>.
The formulas <a href="#equation-nonlin:alglevel:1D:fe:Newton:Fi2">(36)</a> and
<a href="#equation-nonlin:alglevel:1D:fe:Newton:Jij">(37)</a> then change to</p>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Newton:Fi2:e">
<span id="eq-nonlin-alglevel-1d-fe-newton-fi2-e"></span><span class="eqno">(38)</span>\[     \tilde F_r^{(e)} =
     \int_{-1}^1\left(
     {\alpha}(\tilde u_{-})\tilde u_{-}'{\tilde{\varphi}}_r' +
     (a-f(\tilde u_{-})){\tilde{\varphi}}_r\right)\det J{\, \mathrm{d}X} -
     C{\tilde{\varphi}}_r(0),\]</div>
<div class="math" id="equation-nonlin:alglevel:1D:fe:Newton:Jij:e">
<span id="eq-nonlin-alglevel-1d-fe-newton-jij-e"></span><span class="eqno">(39)</span>\[     \tilde J_{r,s}^{(e)} =
     \int_{-1}^1
     ({\alpha}'(\tilde u_{-})\tilde u_{-}'{\tilde{\varphi}}_r'{\tilde{\varphi}}_s +
     {\alpha}(\tilde u_{-}){\tilde{\varphi}}_r'{\tilde{\varphi}}_s'
     + (a - f(\tilde u_{-})){\tilde{\varphi}}_r{\tilde{\varphi}}_s)\det J{\, \mathrm{d}X},\]</div>
<p>with <span class="math">\(r,s\in{I_d}\)</span> runs over the local degrees of freedom.
In the above formulas,
<span class="math">\(\tilde u_{-}(X)=\sum_r \tilde c_{-r}{\tilde{\varphi}}_r(X)\)</span> is the
finite element expansion of <span class="math">\(u_{-}\)</span> over the current cell.</p>
<p>Many finite element programs require the user to provide <span class="math">\(F_i\)</span> and
<span class="math">\(J_{i,j}\)</span>. Some programs, like <a class="reference external" href="http://fenicsproject.org">FEniCS</a>,
are capable of automatically deriving <span class="math">\(J_{i,j}\)</span> if <span class="math">\(F_i\)</span>
is specified.</p>
<div class="section" id="dirichlet-conditions">
<h3>Dirichlet conditions<a class="headerlink" href="#dirichlet-conditions" title="Permalink to this headline">¶</a></h3>
<p>Incorporation of the Dirichlet values by assembling contributions from
all degrees of freedom and then modifying the linear system can be
obviously be applied to Picard iteration as that method involves
a standard linear system. In the Newton system, however, the unknown
is a correction <span class="math">\(\delta u\)</span> to the solution. Dirichlet conditions
are implemented by inserting them in the initial guess <span class="math">\(u_{-}\)</span>
for the Newton iteration and implementing <span class="math">\(\delta u_i =0\)</span> for
all known degrees of freedom. The manipulation of the linear system
follows exactly the algorithm in the linear problems, the only
difference being that the known values are zero.</p>
</div>
</div>
</div>
<div class="section" id="multi-dimensional-pde-problems">
<h1>Multi-dimensional PDE problems<a class="headerlink" href="#multi-dimensional-pde-problems" title="Permalink to this headline">¶</a></h1>
<div class="section" id="finite-element-discretization">
<h2>Finite element discretization<a class="headerlink" href="#finite-element-discretization" title="Permalink to this headline">¶</a></h2>
<p>The derivation of <span class="math">\(F_i\)</span> and <span class="math">\(J_{i,j}\)</span> in the 1D model problem
is easily generalized to multi-dimensional problems.
For example, Backward Euler discretization of the
PDE</p>
<div class="math">
\[u_t = \nabla\cdot({\alpha}(u)\nabla u) + f(u),\]</div>
<p>gives the nonlinear time-discrete PDEs</p>
<div class="math">
\[u^n - \Delta t\nabla\cdot({\alpha}(u^n)\nabla u^n) + f(u^n) = u^{n-1},\]</div>
<p>or with <span class="math">\(u^n\)</span> simply as <span class="math">\(u\)</span> and <span class="math">\(u^{n-1}\)</span> as <span class="math">\(u_1\)</span>,</p>
<div class="math">
\[u - \Delta t\nabla\cdot({\alpha}(u^n)\nabla u) - \Delta t f(u) = u_1{\thinspace .}\]</div>
<p>The variational form, assuming homogeneous Neumann conditions
for simplicity, becomes</p>
<div class="math" id="equation-nonlin:alglevel:dD:fe:varform">
<span id="eq-nonlin-alglevel-dd-fe-varform"></span><span class="eqno">(40)</span>\[     \int_\Omega (uv + \Delta t{\alpha}(u)\nabla u\cdot\nabla v
     - \Delta t f(u)v - u_1v){\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The nonlinear algebraic equations follow from setting <span class="math">\(v={\psi}_i\)</span>
and using the representation <span class="math">\(u=\sum_kc_k{\psi}_k\)</span>, which we
just write as</p>
<div class="math" id="equation-nonlin:alglevel:dD:fe:Fi">
<span id="eq-nonlin-alglevel-dd-fe-fi"></span><span class="eqno">(41)</span>\[     F_i =
     \int_\Omega (u{\psi}_i + \Delta t{\alpha}(u)\nabla u\cdot\nabla {\psi}_i
     - \Delta t f(u){\psi}_i - u_1{\psi}_i){\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Picard iteration needs a linearization where we use
the most recent approximation <span class="math">\(u_{-}\)</span> to <span class="math">\(u\)</span> in
<span class="math">\({\alpha}\)</span> and <span class="math">\(f\)</span>:</p>
<div class="math" id="equation-nonlin:alglevel:dD:fe:Fi:Picard">
<span id="eq-nonlin-alglevel-dd-fe-fi-picard"></span><span class="eqno">(42)</span>\[     F_i \approx \hat F_i =
     \int_\Omega (u_{-}{\psi}_i + \Delta t{\alpha}(u_{-})\nabla u\cdot\nabla {\psi}_i
     - \Delta t f(u_{-}){\psi}_i - u_1{\psi}_i){\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The equations <span class="math">\(\hat F_i=0\)</span> are now linear and we can easily derive
a linear system for the unknown coefficients
<span class="math">\(\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}\)</span> by inserting <span class="math">\(u=\sum_jc_j{\psi}_j\)</span>.</p>
<p>In Newton&#8217;s method we need to evaluate <span class="math">\(F_i\)</span> with the known value
<span class="math">\(u_{-}\)</span> for <span class="math">\(u\)</span>:</p>
<div class="math" id="equation-nonlin:alglevel:dD:fe:Fi:Newton">
<span id="eq-nonlin-alglevel-dd-fe-fi-newton"></span><span class="eqno">(43)</span>\[     F_i \approx \hat F_i =
     \int_\Omega (u_{-}{\psi}_i + \Delta t{\alpha}(u_{-})
     \nabla u_{-}\cdot\nabla {\psi}_i
     - \Delta t f(u_{-}){\psi}_i - u_1{\psi}_i){\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The Jacobian is obtained by differentiating
<a href="#equation-nonlin:alglevel:dD:fe:Fi">(41)</a> and using <span class="math">\(\partial u/\partial c_j={\psi}_j\)</span>:</p>
<div class="math">
\[J_{i,j} = \frac{\partial F_i}{\partial c_j} =
\int_\Omega  ({\psi}_j{\psi}_i + \Delta t{\alpha}'(u){\psi}_j
\nabla u\cdot\nabla {\psi}_i +
\Delta t{\alpha}(u)\nabla{\psi}_j\cdot\nabla{\psi}_i - \nonumber\]</div>
<div class="math" id="equation-nonlin:alglevel:dD:fe:Jij">
<span id="id5"></span><span class="eqno">(44)</span>\[     \ \Delta t f'(u){\psi}_j{\psi}_i - u_1{\psi}_i){\, \mathrm{d}x}{\thinspace .}\]</div>
<p>The evaluation of <span class="math">\(J_{i,j}\)</span> as the coefficient matrix in the linear
system in Newton&#8217;s method applies the known approximation <span class="math">\(u_{-}\)</span>
for <span class="math">\(u\)</span>:</p>
<div class="math">
\[J_{i,j} =
\int_\Omega  ({\psi}_j{\psi}_i + \Delta t{\alpha}'(u_{-}){\psi}_j
\nabla u_{-}\cdot\nabla {\psi}_i +
\Delta t{\alpha}(u_{-})\nabla{\psi}_j\cdot\nabla{\psi}_i - \nonumber\]</div>
<div class="math" id="equation-nonlin:alglevel:dD:fe:Jij">
<span id="id7"></span><span class="eqno">(45)</span>\[     \ \Delta t f'(u_{-}){\psi}_j{\psi}_i - u_1{\psi}_i){\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Hopefully, these example also show how convenient the notation
with <span class="math">\(u\)</span> and <span class="math">\(u_{-}\)</span> is: the unknown to be computed is always <span class="math">\(u\)</span> and
linearization by inserting known (previously computed) values
is a matter of adding an underscore.
One can take great advantage of this quick notation in
software <a class="reference internal" href="#ref2">[Ref2]</a>.</p>
</div>
<div class="section" id="finite-difference-discretization">
<h2>Finite difference discretization<a class="headerlink" href="#finite-difference-discretization" title="Permalink to this headline">¶</a></h2>
<p>A typical diffusion equation</p>
<div class="math">
\[u_t = \nabla\cdot({\alpha}(u)\nabla u) + f(u),\]</div>
<p>can be discretized by (e.g.) a Backward Euler scheme,
which in 2D can be written</p>
<div class="math">
\[[D_t^- u = D_x\overline{{\alpha}}^xD_x u
+ D_y\overline{{\alpha}}^yD_y u + f(u)]_{i,j}^n{\thinspace .}\]</div>
<p>We do not dive into details of boundary conditions now. Dirichlet and
Neumann conditions are handled as in linear diffusion problems.</p>
<p>Writing the scheme out, putting the unknown values on the
left-hand side and known values on the right-hand side, and
introducing <span class="math">\(\Delta x=\Delta y=h\)</span> to save some writing, one gets</p>
<div class="math">
\[\begin{split}u^n_{i,j} &amp;- \frac{\Delta t}{h^2}(
 \frac{1}{2}({\alpha}(u_{i,j}^n)   + {\alpha}(u_{i+1,j}^n))(u_{i+1,j}^n-u_{i,j}^n) -
 \frac{1}{2}({\alpha}(u_{i-1,j}^n) + {\alpha}(u_{i,j}^n))(u_{i,j}^n-u_{i-1,j}^n) \\
&amp;+
 \frac{1}{2}({\alpha}(u_{i,j}^n)   + {\alpha}(u_{i,j+1}^n))(u_{i,j+1}^n-u_{i,j}^n) -
 \frac{1}{2}({\alpha}(u_{i,j-1}^n) + {\alpha}(u_{i,j}^n))(u_{i,j}^n-u_{i-1,j-1}^n))\\
&amp;- \Delta tf(u_{i,j}^n) = u^{n-1}_{i,j}\end{split}\]</div>
<p>This defines a nonlinear algebraic system <span class="math">\(A(u)u=b(u)\)</span>.
A Picard iteration applies old values <span class="math">\(u_{-}\)</span> in <span class="math">\({\alpha}\)</span> and <span class="math">\(f\)</span>,
or equivalently, old values for <span class="math">\(u\)</span> in <span class="math">\(A(u)\)</span> and <span class="math">\(b(u)\)</span>.
The result is a linear system of the same type as those arising
from <span class="math">\(u_t = \nabla\cdot ({\alpha}(\boldsymbol{x})\nabla u) + f(\boldsymbol{x},t)\)</span>.</p>
<p>Newton&#8217;s method is as usual more involved. We first define
the nonlinear algebraic equations to be solved, drop the
superscript <span class="math">\(n\)</span>, and introduce <span class="math">\(u_1\)</span> for <span class="math">\(u^{n-1}\)</span>:</p>
<div class="math">
\[\begin{split}F_{i,j} &amp;= u^n_{i,j} - \frac{\Delta t}{h^2}(\\
&amp;\quad \frac{1}{2}({\alpha}(u_{i,j}^n)   + {\alpha}(u_{i+1,j}^n))(u_{i+1,j}^n-u_{i,j}^n) -
 \frac{1}{2}({\alpha}(u_{i-1,j}^n) + {\alpha}(u_{i,j}^n))(u_{i,j}^n-u_{i-1,j}^n) + \\
&amp;\quad
 \frac{1}{2}({\alpha}(u_{i,j}^n)   + {\alpha}(u_{i,j+1}^n))(u_{i,j+1}^n-u_{i,j}^n) -
 \frac{1}{2}({\alpha}(u_{i,j-1}^n) + {\alpha}(u_{i,j}^n))(u_{i,j}^n-u_{i-1,j-1}^n)) -\\
&amp;\quad \Delta tf(u_{i,j}^n) - u^{n-1}_{i,j} = 0{\thinspace .}\end{split}\]</div>
<p>It is convenient to work with two indices <span class="math">\(i\)</span> and <span class="math">\(j\)</span> in 2D
finite difference discretizations, but it complicates
the derivation of the Jacobian, which then gets four indices.
The left-hand expression of an equation <span class="math">\(F_{i,j}=0\)</span> is to be
differentiated with respect to each of the unknowns <span class="math">\(u_{r,s}\)</span>
(short for <span class="math">\(u_{r,s}^n\)</span>), <span class="math">\(r\in{\mathcal{I}_x}\)</span>, <span class="math">\(s\in{\mathcal{I}_y}\)</span>,</p>
<div class="math">
\[J_{i,j,r,s} = \frac{\partial F_{i,j}}{\partial u_{r,s}}{\thinspace .}\]</div>
<p>Given <span class="math">\(i\)</span> and <span class="math">\(j\)</span>, only a few <span class="math">\(r\)</span> and <span class="math">\(s\)</span> indices give nonzero
contribution since <span class="math">\(F_{i,j}\)</span> contains <span class="math">\(u_{i\pm 1,j}\)</span>, <span class="math">\(u_{i,j\pm 1}\)</span>,
and <span class="math">\(u_{i,j}\)</span>. Therefore, <span class="math">\(J_{i,j,r,s}\)</span> is very sparse and we
can set up the left-hand side of the Newton system as</p>
<div class="math">
\[\begin{split} J_{i,j,r,s}\delta u_{r,s} =
J_{i,j,i,j}\delta u_{i,j} &amp; +
J_{i,j,i-1,j}\delta u_{i-1,j} +
J_{i,j,i+1,j}\delta u_{i+1,j} +
J_{i,j,i,j-1}\delta u_{i,j-1}\\
&amp; +
J_{i,j,i,j+1}\delta u_{i,j+1}\end{split}\]</div>
<p>The specific derivatives become</p>
<div class="math">
\[\begin{split}J_{i,j,i-1,j} &amp;= \frac{\partial F_{i,j}}{\partial u_{i-1,j}}\\
&amp;= \frac{\Delta t}{h^2}({\alpha}'(u_{i-1,j})(u_{i,j}-u_{i-1,j})
+ {\alpha}(u_{i-1,j})(-1))\\
J_{i,j,i+1,j} &amp;= \frac{\partial F_{i,j}}{\partial u_{i+1,j}}\\
&amp;= \frac{\Delta t}{h^2}(-{\alpha}'(u_{i+1,j})(u_{i+1,j}-u_{i,j})
- {\alpha}(u_{i-1,j}))\\
J_{i,j,i,j-1} &amp;= \frac{\partial F_{i,j}}{\partial u_{i,j-1}}\\
&amp;= \frac{\Delta t}{h^2}({\alpha}'(u_{i,j-1})(u_{i,j}-u_{i,j-1})
+ {\alpha}(u_{i,j-1})(-1))\\
J_{i,j,i,j+1} &amp;= \frac{\partial F_{i,j}}{\partial u_{i,j+1}}\\
&amp;= \frac{\Delta t}{h^2}(-{\alpha}'(u_{i,j+1})(u_{i,j+1}-u_{i,j})
- {\alpha}(u_{i,j-1}))\end{split}\]</div>
<p>The <span class="math">\(J_{i,j,i,j}\)</span> entry has a few more terms.
Inserting <span class="math">\(u_{-}\)</span> for <span class="math">\(u\)</span> in the <span class="math">\(J\)</span> formula and then
forming <span class="math">\(J\delta u=-F\)</span> gives the linear system to be solved
in each Newton iteration.</p>
</div>
<div class="section" id="continuation-methods">
<h2>Continuation methods<a class="headerlink" href="#continuation-methods" title="Permalink to this headline">¶</a></h2>
<p id="index-13">Picard iteration or Newton&#8217;s method may diverge when solving PDEs with
severe nonlinearities. Relaxation with <span class="math">\(\omega &lt;1\)</span>
may help, but in highly nonlinear problems it can be
necessary to introduce a <em>continuation parameter</em> <span class="math">\(\Lambda\)</span> in
the problem: <span class="math">\(\Lambda =0\)</span> gives a version of the
problem that is easy to solve, while
<span class="math">\(\Lambda =1\)</span> is the target problem. The idea is then
to increase <span class="math">\(\Lambda\)</span> in steps, <span class="math">\(\Lambda_0=0 ,\Lambda_1 &lt;\cdots &lt;\Lambda_n=1\)</span>,
and use the solution from the problem with <span class="math">\(\Lambda_{i-1}\)</span> as
initial guess for the iterations in the problem corresponding
to <span class="math">\(\Lambda_i\)</span>.</p>
<p>The continuation method is easiest to understand through an example.
Suppose we intend to solve</p>
<div class="math">
\[-\nabla\cdot\left( ||\nabla u||^q\nabla u\right) = f,\]</div>
<p>which is an equation modeling the flow of a non-Newtonian fluid through
i channel or pipe. For <span class="math">\(q=0\)</span> we have the Poisson equation (corresponding
to a Newtonian fluid) and the problem is linear. A typical
value for pseudo-plastic fluids may be <span class="math">\(q_n=-0.8\)</span>. We can introduce
the continuation parameter <span class="math">\(\Lambda\in [0,1]\)</span> such that
<span class="math">\(q=q_n\Lambda\)</span>. Let <span class="math">\(\{\Lambda_\ell\}_{\ell=0}^n\)</span> be the sequence of
<span class="math">\(\Lambda\)</span> values in <span class="math">\([0,1]\)</span>, with corresponding <span class="math">\(q\)</span> values
<span class="math">\(\{q_\ell\}_{\ell=0}^n\)</span>. We can then solve a sequence of problems</p>
<div class="math">
\[-\nabla\cdot\left( ||\nabla u||^q_\ell\nabla u^\ell\right) = f,\quad
\ell = 0,\ldots,n,\]</div>
<p>where the initial guess for iterating on <span class="math">\(u^{\ell}\)</span> is the
previously computed solution <span class="math">\(u^{\ell-1}\)</span>. If a particular <span class="math">\(\Lambda_\ell\)</span>
leads to convergence problems, one may try a smaller
increase in <span class="math">\(\Lambda\)</span>:
<span class="math">\(\Lambda_* = \frac{1}{2} (\Lambda_{\ell-1}+\Lambda_\ell)\)</span>,
and repeat halving the step in <span class="math">\(\Lambda\)</span> until convergence is reestablished.</p>
</div>
</div>
<div class="section" id="exercises">
<span id="nonlin-exer"></span><h1>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-1-determine-if-equations-are-nonlinear-or-not">
<span id="nonlin-exer-lin-vs-nonlin"></span><h2>Problem 1: Determine if equations are nonlinear or not<a class="headerlink" href="#problem-1-determine-if-equations-are-nonlinear-or-not" title="Permalink to this headline">¶</a></h2>
<p>Classify each term in the following equations as linear or nonlinear.
Assume that <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are unknown
numbers and that <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are unknown functions.
All other symbols are known quantities.</p>
<ol class="arabic simple">
<li><span class="math">\(b^2 = 1\)</span></li>
<li><span class="math">\(a+b = 1\)</span>, <span class="math">\(a-2b = 0\)</span></li>
<li><span class="math">\(mu'' + \beta |u'|u' + cu = F(t)\)</span></li>
<li><span class="math">\(u_t = {\alpha} u_{xx}\)</span></li>
<li><span class="math">\(u_{tt} = c^2\nabla^2 u\)</span></li>
<li><span class="math">\(u_t = \nabla\cdot({\alpha}(u)\nabla u) + f(x,y)\)</span></li>
<li><span class="math">\(u_t + f(u)_x = 0\)</span></li>
<li><span class="math">\(\boldsymbol{u}_t + \boldsymbol{u}\cdot\nabla \boldsymbol{u} = -\nabla p + r\nabla^2\boldsymbol{u}\)</span>, <span class="math">\(\nabla\cdot\boldsymbol{u} = 0\)</span>
(<span class="math">\(\boldsymbol{u}\)</span> is a vector field)</li>
<li><span class="math">\(u' = f(u,t)\)</span></li>
<li><span class="math">\(\nabla^2 u = \lambda e^u\)</span></li>
</ol>
</div>
<div class="section" id="problem-2-linearize-a-nonlinear-vibration-ode">
<span id="nonlin-exer-vib-geometric-mean"></span><h2>Problem 2: Linearize a nonlinear vibration ODE<a class="headerlink" href="#problem-2-linearize-a-nonlinear-vibration-ode" title="Permalink to this headline">¶</a></h2>
<p>Consider a nonlinear vibration problem</p>
<div class="math">
\[mu'' + bu'|u'| + s(u) = F(t),\]</div>
<p>where <span class="math">\(m&gt;0\)</span> is a constant,
<span class="math">\(b\geq 0\)</span> is a constant, <span class="math">\(s(u)\)</span> a possibly nonlinear function
of <span class="math">\(u\)</span>, and <span class="math">\(F(t)\)</span> is a prescribed function. Such models arise
from Newton&#8217;s second law of motion
in mechanical vibration problems where <span class="math">\(s(u)\)</span> is a spring or
restoring force, <span class="math">\(mu''\)</span> is mass times acceleration, and
<span class="math">\(bu'|u'|\)</span> models water or air drag.</p>
<p>Approximate <span class="math">\(u''\)</span> by a centered finite difference <span class="math">\(D_tD_t u\)</span>,
and use a centered difference <span class="math">\(D_t u\)</span> for <span class="math">\(u'\)</span> as well.
Observe then that <span class="math">\(s(u)\)</span> does not contribute to making the
resulting algebraic equation at a time level nonlinear.
Use a geometric mean to linearize the quadratic nonlinearity arising
from the term <span class="math">\(bu'|u'|\)</span>.</p>
</div>
<div class="section" id="exercise-3-find-the-sparsity-of-the-jacobian">
<span id="nonlin-exer-sparsity-jacobian"></span><h2>Exercise 3: Find the sparsity of the Jacobian<a class="headerlink" href="#exercise-3-find-the-sparsity-of-the-jacobian" title="Permalink to this headline">¶</a></h2>
<p>Consider a typical nonlinear Laplace term like
<span class="math">\(\nabla\cdot{\alpha}(u)\nabla u\)</span> discretized by centered finite differences.
Explain why the Jacobian corresponding to this term has the same
sparsity pattern as the matrix associated with the corresponding linear
term <span class="math">\({\alpha}\nabla^2 u\)</span>.</p>
<p><strong>Hint.</strong>
Set up the unknowns that enter the difference stencil and find the
sparsity of the Jacobian that arise from the stencil.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">nonlin_sparsity_Jacobian.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-4-newton-s-method-for-linear-problems">
<span id="nonlin-exer-newton-linear"></span><h2>Exercise 4: Newton&#8217;s method for linear problems<a class="headerlink" href="#exercise-4-newton-s-method-for-linear-problems" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have a linear system <span class="math">\(F(u) = Au- b=0\)</span>. Apply Newton&#8217;s method
to this system, and show that the method converges in one iteration.
Filename: <tt class="docutils literal"><span class="pre">nonlin_Newton_linear.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-5-differentiate-a-highly-nonlinear-term">
<span id="nonlin-exer-grad-pow-term"></span><h2>Exercise 5: Differentiate a highly nonlinear term<a class="headerlink" href="#exercise-5-differentiate-a-highly-nonlinear-term" title="Permalink to this headline">¶</a></h2>
<p>The operator <span class="math">\(\nabla\cdot({\alpha}(u)\nabla u)\)</span> with
<span class="math">\({\alpha}(u) = ||\nabla u||^q\)</span> appears in several physical problems,
especially flow of Non-Newtonian fluids. In a Newton method one
has to carry out the differentiation <span class="math">\(\partial{\alpha}(u)/\partial c_j\)</span>,
for <span class="math">\(u=\sum_kc_k{\psi}_k\)</span>. Show that</p>
<div class="math">
\[{\partial\over\partial u_j} ||\nabla u||^q =
q||\nabla  u||^{q-2}\nabla u\cdot
\nabla{\psi}_j{\thinspace .}\]</div>
<p>Filename: <tt class="docutils literal"><span class="pre">nonlin_differentiate.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-6-discretize-a-1d-problem-with-a-nonlinear-coefficient">
<span id="nonlin-exer-1d-1pu2-fem"></span><h2>Problem 6: Discretize a 1D problem with a nonlinear coefficient<a class="headerlink" href="#problem-6-discretize-a-1d-problem-with-a-nonlinear-coefficient" title="Permalink to this headline">¶</a></h2>
<p>We consider the problem</p>
<div class="math" id="equation-nonlin:exer:1D:1pu2:fem:pde">
<span id="eq-nonlin-exer-1d-1pu2-fem-pde"></span><span class="eqno">(46)</span>\[     ((1 + u^2)u')' = 1,\quad x\in (0,1),\quad u(0)=u(1)=0{\thinspace .}\]</div>
<p><strong>a)</strong>
Discretize <a href="#equation-nonlin:exer:1D:1pu2:fem:pde">(46)</a> by a centered
finite difference method on a uniform mesh.</p>
<p><strong>b)</strong>
Discretize <a href="#equation-nonlin:exer:1D:1pu2:fem:pde">(46)</a> by a finite
element method with P1 of equal length.
Use the Trapezoidal method to compute all integrals.
Set up the resulting matrix system.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">nonlin_1D_coeff_discretize.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-7-linearize-a-1d-problem-with-a-nonlinear-coefficient">
<span id="nonlin-exer-1d-1pu2-picardnewton"></span><h2>Problem 7: Linearize a 1D problem with a nonlinear coefficient<a class="headerlink" href="#problem-7-linearize-a-1d-problem-with-a-nonlinear-coefficient" title="Permalink to this headline">¶</a></h2>
<p>We have a two-point boundary value problem</p>
<div class="math" id="equation-nonlin:exer:1D:1pu2:PicardNewton:pde">
<span id="eq-nonlin-exer-1d-1pu2-picardnewton-pde"></span><span class="eqno">(47)</span>\[     ((1 + u^2)u')' = 1,\quad x\in (0,1),\quad u(0)=u(1)=0{\thinspace .}\]</div>
<p><strong>a)</strong>
Construct a Picard iteration method for <a href="#equation-nonlin:exer:1D:1pu2:PicardNewton:pde">(47)</a>
without discretizing in space.</p>
<p><strong>b)</strong>
Apply Newton&#8217;s method to <a href="#equation-nonlin:exer:1D:1pu2:PicardNewton:pde">(47)</a>
without discretizing in space.</p>
<p><strong>c)</strong>
Discretize <a href="#equation-nonlin:exer:1D:1pu2:PicardNewton:pde">(47)</a> by a centered finite
difference scheme. Construct a Picard method for the resulting
system of nonlinear algebraic equations.</p>
<p><strong>d)</strong>
Discretize <a href="#equation-nonlin:exer:1D:1pu2:PicardNewton:pde">(47)</a> by a centered finite
difference scheme. Define the system of nonlinear algebraic equations,
calculate the Jacobian, and set up Newton&#8217;s method for solving the system.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">nonlin_1D_coeff_linearize.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-8-finite-differences-for-the-1d-bratu-problem">
<span id="nonlin-exer-1d-fu-discretize-fd"></span><h2>Problem 8: Finite differences for the 1D Bratu problem<a class="headerlink" href="#problem-8-finite-differences-for-the-1d-bratu-problem" title="Permalink to this headline">¶</a></h2>
<p>We address the so-called Bratu problem</p>
<div class="math" id="equation-nonlin:exer:1D:fu:discretize:fd:pde">
<span id="eq-nonlin-exer-1d-fu-discretize-fd-pde"></span><span class="eqno">(48)</span>\[     u'' + \lambda e^u=0,\quad x\in (0,1),\quad u(0)=u(1)=0,\]</div>
<p>where <span class="math">\(\lambda\)</span> is a given parameter and <span class="math">\(u\)</span> is a function of <span class="math">\(x\)</span>.
This is a widely used model problem for studying numerical
methods for nonlinear differential equations.
The problem <a href="#equation-nonlin:exer:1D:fu:discretize:fd:pde">(48)</a> has an
exact solution</p>
<div class="math">
\[u(x) = -2\ln\left(\frac{\cosh((x-\frac{1}{2})\theta/2)}{\cosh(\theta/4)}\right),\]</div>
<p>where <span class="math">\(\theta\)</span> solves</p>
<div class="math">
\[\theta = \sqrt{2\lambda}\cosh(\theta/4){\thinspace .}\]</div>
<p>There are two solutions of <a href="#equation-nonlin:exer:1D:fu:discretize:fd:pde">(48)</a> for
<span class="math">\(0&lt;\lambda &lt;\lambda_c\)</span> and no solution for <span class="math">\(\lambda &gt;\lambda_c\)</span>.
For <span class="math">\(\lambda = \lambda_c\)</span> there is one unique solution. The critical
value <span class="math">\(\lambda_c\)</span> solves</p>
<div class="math">
\[1 = \sqrt{2\lambda_c}\frac{1}{4}\sinh(\theta(\lambda_c)/4){\thinspace .}\]</div>
<p>A numerical value is <span class="math">\(\lambda_c = 3.513830719\)</span>.</p>
<p><strong>a)</strong>
Discretize <a href="#equation-nonlin:exer:1D:fu:discretize:fd:pde">(48)</a> by a
centered finite difference method.</p>
<p><strong>b)</strong>
Set up the nonlinear equations <span class="math">\(F_i(u_0,u_1,\ldots,u_{N_x})=0\)</span>
from a). Calculate the associated Jacobian.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">nonlin_1D_Bratu_fd.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-9-integrate-functions-of-finite-element-expansions">
<span id="nonlin-exer-fu-fem-int"></span><h2>Problem 9: Integrate functions of finite element expansions<a class="headerlink" href="#problem-9-integrate-functions-of-finite-element-expansions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-14"></span><p id="index-15">We shall investigate integrals on the form</p>
<div class="math" id="equation-nonlin:exer:fu:fem:int:global">
<span id="eq-nonlin-exer-fu-fem-int-global"></span><span class="eqno">(49)</span>\[     \int_0^L f(\sum_ku_k{\varphi}_k(x)){\varphi}_i(x){\, \mathrm{d}x},\]</div>
<p>where <span class="math">\({\varphi}_i(x)\)</span> are P1 finite element basis functions and <span class="math">\(u_k\)</span>
are unknown coefficients, more precisely the values of the unknown
function <span class="math">\(u\)</span> at nodes <span class="math">\(x_{k}\)</span>. We introduce a node numbering that
goes from left to right and also that all cells have
the same length <span class="math">\(h\)</span>. Given <span class="math">\(i\)</span>, the integral
only gets contributions from <span class="math">\([x_{i-1},x_{i+1}]\)</span>. On this
interval <span class="math">\({\varphi}_k(x)=0\)</span> for <span class="math">\(k&lt;i-1\)</span> and <span class="math">\(k&gt;i+1\)</span>, so only three
basis functions will contribute:</p>
<div class="math">
\[\sum_k u_k{\varphi}_k(x) = u_{i-1}{\varphi}_{i-1}(x) +
u_{i}{\varphi}_{i}(x) + u_{i+1}{\varphi}_{i+1}(x){\thinspace .}\]</div>
<p>The integral <a href="#equation-nonlin:exer:fu:fem:int:global">(49)</a> now takes the
simplified form</p>
<div class="math">
\[\int_{x_{i-1}}^{x_{i+1}}
f(u_{i-1}{\varphi}_{i-1}(x) +
u_{i}{\varphi}_{i}(x) + u_{i+1}{\varphi}_{i+1}(x)){\varphi}_i(x){\, \mathrm{d}x}{\thinspace .}\]</div>
<p>Split this integral in two integrals over cell L (left),
<span class="math">\([x_{i-1},x_{i}]\)</span>, and cell R (right), <span class="math">\([x_{i},x_{i+1}]\)</span>. Over
cell L, <span class="math">\(u\)</span> simplifies to <span class="math">\(u_{i-1}{\varphi}_{i-1} + u_{i}{\varphi}_{i}\)</span>
(since <span class="math">\({\varphi}_{i+1}=0\)</span> on this cell), and over cell R, <span class="math">\(u\)</span>
simplifies to <span class="math">\(u_{i}{\varphi}_{i} + u_{i+1}{\varphi}_{i+1}\)</span>.  Make a
<tt class="docutils literal"><span class="pre">sympy</span></tt> program that can compute the integral and write it out as a
difference equation. Give the <span class="math">\(f(u)\)</span> formula on the command line.
Try out <span class="math">\(f(u)=u^2, \sin u, \exp u\)</span>.</p>
<p><strong>Hint.</strong>
Introduce symbols <tt class="docutils literal"><span class="pre">u_i</span></tt>, <tt class="docutils literal"><span class="pre">u_im1</span></tt>, and <tt class="docutils literal"><span class="pre">u_ip1</span></tt> for <span class="math">\(u_i\)</span>, <span class="math">\(u_{i-1}\)</span>,
and <span class="math">\(u_{i+1}\)</span>, respectively, and similar symbols for <span class="math">\(x_i\)</span>, <span class="math">\(x_{i-1}\)</span>,
and <span class="math">\(x_{i+1}\)</span>. Find formulas for the basis functions on each of the
two cells, make expressions for <span class="math">\(u\)</span> on the two cells, integrate over
each cell, expand the answer and simplify. You can make
LaTeX code and render it via
<a class="reference external" href="http://latex.codecogs.com">http://latex.codecogs.com</a>. Here are some appropriate Python statements
for the latter purpose:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">...</span>
<span class="c"># expr_i holdes the integral as a sympy expression</span>
<span class="n">latex_code</span> <span class="o">=</span> <span class="n">latex</span><span class="p">(</span><span class="n">expr_i</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;plain&#39;</span><span class="p">)</span>
<span class="c"># Replace u_im1 sympy symbol name by latex symbol u_{i-1}</span>
<span class="n">latex_code</span> <span class="o">=</span> <span class="n">latex_code</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;im1&#39;</span><span class="p">,</span> <span class="s">&#39;{i-1}&#39;</span><span class="p">)</span>
<span class="c"># Replace u_ip1 sympy symbol name by latex symbol u_{i+1}</span>
<span class="n">latex_code</span> <span class="o">=</span> <span class="n">latex_code</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;ip1&#39;</span><span class="p">,</span> <span class="s">&#39;{i+1}&#39;</span><span class="p">)</span>
<span class="c"># Escape (quote) latex_code so it can be sent as HTML text</span>
<span class="kn">import</span> <span class="nn">cgi</span>
<span class="n">html_code</span> <span class="o">=</span> <span class="n">cgi</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">latex_code</span><span class="p">)</span>
<span class="c"># Make a file with HTML code for displaying the LaTeX formula</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;tmp.html&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="c"># Include an image that can be clicked on to yield a new</span>
<span class="c"># page with an interactive editor and display area where the</span>
<span class="c"># formula can be further edited</span>
<span class="n">text</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=</span><span class="si">%(html_code)s</span><span class="s">&quot;</span>
<span class="s"> target=&quot;_blank&quot;&gt;</span>
<span class="s">&lt;img src=&quot;http://latex.codecogs.com/gif.latex?</span><span class="si">%(html_code)s</span><span class="s">&quot;</span>
<span class="s"> title=&quot;</span><span class="si">%(latex_code)s</span><span class="s">&quot;/&gt;</span>
<span class="s">&lt;/a&gt;</span>
<span class="s"> &quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">()</span>
<span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The formula is displayed by loading <tt class="docutils literal"><span class="pre">tmp.html</span></tt> into a web browser.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">fu_fem_int.py</span></tt>.</p>
</div>
<div class="section" id="problem-10-finite-elements-for-the-1d-bratu-problem">
<span id="nonlin-exer-1d-fu-discretize-fe"></span><h2>Problem 10: Finite elements for the 1D Bratu problem<a class="headerlink" href="#problem-10-finite-elements-for-the-1d-bratu-problem" title="Permalink to this headline">¶</a></h2>
<p>We address the same 1D Bratu problem as described in
<a class="reference internal" href="#nonlin-exer-1d-fu-discretize-fd"><em>Problem 8: Finite differences for the 1D Bratu problem</em></a>.</p>
<p><strong>a)</strong>
Discretize (<a class="reference internal" href="#nonlin-exer-1d-fu-discretize-fe"><em>Problem 10: Finite elements for the 1D Bratu problem</em></a>) by a finite element
method using a uniform mesh with P1 elements. Use a group
finite element method for the <span class="math">\(e^u\)</span> term.</p>
<p><strong>b)</strong>
Set up the nonlinear equations <span class="math">\(F_i(u_0,u_1,\ldots,u_{N_x})=0\)</span>
from a). Calculate the associated Jacobian.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">nonlin_1D_Bratu_fe.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-11-derive-the-newton-system-from-a-variational-form">
<span id="nonlin-exer-dd-heat-nonlinear-c-a"></span><h2>Problem 11: Derive the Newton system from a variational form<a class="headerlink" href="#problem-11-derive-the-newton-system-from-a-variational-form" title="Permalink to this headline">¶</a></h2>
<p>We study the multi-dimensional heat conduction PDE</p>
<div class="math">
\[\varrho c(T) T_t = \nabla\cdot (k(T)\nabla T)\]</div>
<p>in a spatial domain <span class="math">\(\Omega\)</span>, with a nonlinear Robin boundary condition</p>
<div class="math">
\[-k(T)\frac{\partial T}{\partial n} = h(T)(T-T_s(t)),\]</div>
<p>at the boundary <span class="math">\(\partial\Omega\)</span>.
The primary unknown is the temperature <span class="math">\(T\)</span>, <span class="math">\(\varrho\)</span> is the density
of the solid material, <span class="math">\(c(T)\)</span> is the heat capacity, <span class="math">\(k(T)\)</span> is
the heat conduction, <span class="math">\(h(T)\)</span> is a heat transfer coefficient, and
<span class="math">\(T_s(T)\)</span> is a possibly time-dependent temperature of the surroundings.</p>
<p><strong>a)</strong>
Use a Backward Euler or Crank-Nicolson time discretization and
derive the variational form for the spatial problem to be solved
at each time level.</p>
<p><strong>b)</strong>
Define a Picard iteration method from the variational form at
a time level.</p>
<p><strong>c)</strong>
Derive expressions for the matrix and the right-hand side of the
equation system that arises from applying Newton&#8217;s method to
the variational form at a time level.</p>
<p><strong>d)</strong>
Apply the Backward Euler or Crank-Nicolson scheme in time first.
Derive a Newton method at the PDE level. Make a variational
form of the resulting PDE at a time level.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">nonlin_heat_Newton.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-12-derive-algebraic-equations-for-nonlinear-1d-heat-conduction">
<span id="nonlin-exer-1d-heat-nonlinear-c-a"></span><h2>Problem 12: Derive algebraic equations for nonlinear 1D heat conduction<a class="headerlink" href="#problem-12-derive-algebraic-equations-for-nonlinear-1d-heat-conduction" title="Permalink to this headline">¶</a></h2>
<p>Consider a 1D heat conduction PDE</p>
<div class="math">
\[\varrho c(T) T_t = (k(T)T_x)_x,\]</div>
<p>where <span class="math">\(\varrho\)</span> is the density of the solid material, <span class="math">\(c(T)\)</span> is
the heat capacity, <span class="math">\(T\)</span> is the temperature, and <span class="math">\(k(T)\)</span> is the
heat conduction coefficient.</p>
<p>Use a uniform finite element mesh, P1 elements, and the group finite
element method to derive the algebraic equations arising from the
heat conduction PDE</p>
<p><strong>a)</strong>
Discretize the PDE by a finite difference method. Use either a
Backward Euler or Crank-Nicolson scheme in time.</p>
<p><strong>b)</strong>
Derive the matrix and right-hand side of a Newton method applied
to the discretized PDE.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">nonlin_1D_heat_PDE.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-13-investigate-a-1d-problem-with-a-continuation-method">
<span id="nonlin-exer-continuation-1dnnflow"></span><h2>Problem 13: Investigate a 1D problem with a continuation method<a class="headerlink" href="#problem-13-investigate-a-1d-problem-with-a-continuation-method" title="Permalink to this headline">¶</a></h2>
<p id="index-16">Flow of a pseudo-plastic power-law fluid between two flat plates can be
modeled by</p>
<div class="math">
\[\frac{d}{dx}\left(\mu_0\left\vert\frac{du}{dx}\right\vert^{n-1}
\frac{du}{dx}\right) = -\beta,\quad u'(0)=0,\ u(H) = 0,\]</div>
<p>where <span class="math">\(\beta&gt;0\)</span> and <span class="math">\(\mu_0&gt;0\)</span> are constants.
A target value of <span class="math">\(n\)</span> may be <span class="math">\(n=0.2\)</span>.</p>
<p><strong>a)</strong>
Formulate a Picard iteration method directly for the differential
equation problem.</p>
<p><strong>b)</strong>
Perform a finite difference discretization of the problem in
each Picard iteration. Implement a solver that can compute <span class="math">\(u\)</span>
on a mesh. Verify that the solver gives an exact solution for <span class="math">\(n=1\)</span>
on a uniform mesh regardless of the cell size.</p>
<p><strong>c)</strong>
Given a sequence of decreasing <span class="math">\(n\)</span> values, solve the problem for each
<span class="math">\(n\)</span> using the solution for the previous <span class="math">\(n\)</span> as initial guess for
the Picard iteration. This is called a continuation method.
Experiment with <span class="math">\(n=(1,0.6,0.2)\)</span> and <span class="math">\(n=(1,0.9,0.8,\ldots,0.2)\)</span>
and make a table of the number of Picard iterations versus <span class="math">\(n\)</span>.</p>
<p><strong>d)</strong>
Derive a Newton method at the differential equation level and
discretize the resulting linear equations in each Newton iteration
with the finite difference method.</p>
<p><strong>e)</strong>
Investigate if Newton&#8217;s method has better convergence properties than
Picard iteration, both in combination with a continuation method.</p>
</div>
</div>
<div class="section" id="bibliography">
<h1>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h1>
<table class="docutils citation" frame="void" id="ref1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Ref1]</a></td><td><strong>C. T. Kelley</strong>. <em>Iterative Methods for Linear and Nonlinear Equations</em>,
SIAM,
1995.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[Ref2]</a></td><td><strong>M. Mortensen, H. P. Langtangen and G. N. Wells</strong>. A FEniCS-Based Programming Framework for Modeling Turbulent Flow by the Reynolds-Averaged Navier-Stokes Equations,
<em>Advances in Water Resources</em>,
34(9),
<a class="reference external" href="http://dx.doi.org/10.1016/j.advwatres.2011.02.013">doi: 10.1016/j.advwatres.2011.02.013</a>,
2011.</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Nonlinear differential equation problems</a></li>
<li><a class="reference internal" href="#basic-examples-using-the-logistic-equation">Basic examples using the logistic equation</a><ul>
<li><a class="reference internal" href="#linearization-by-explicit-time-discretization">Linearization by explicit time discretization</a></li>
<li><a class="reference internal" href="#exact-solution-of-nonlinear-equations">Exact solution of nonlinear equations</a></li>
<li><a class="reference internal" href="#linearization">Linearization</a></li>
<li><a class="reference internal" href="#picard-iteration-1">Picard iteration  (1)</a><ul>
<li><a class="reference internal" href="#stopping-criteria-1">Stopping criteria  (1)</a></li>
<li><a class="reference internal" href="#a-single-picard-iteration">A single Picard iteration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#linearization-by-a-geometric-mean">Linearization by a geometric mean</a></li>
<li><a class="reference internal" href="#newton-s-method-1">Newton&#8217;s method  (1)</a></li>
<li><a class="reference internal" href="#relaxation">Relaxation</a></li>
<li><a class="reference internal" href="#implementation-and-experiments">Implementation and experiments</a></li>
<li><a class="reference internal" href="#generalization-to-a-general-nonlinear-ode">Generalization to a general nonlinear ODE</a><ul>
<li><a class="reference internal" href="#explicit-time-discretization">Explicit time discretization</a></li>
<li><a class="reference internal" href="#backward-euler-discretization">Backward Euler discretization</a></li>
<li><a class="reference internal" href="#crank-nicolson-discretization">Crank-Nicolson discretization</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#systems-of-nonlinear-algebraic-equations">Systems of nonlinear algebraic equations</a><ul>
<li><a class="reference internal" href="#picard-iteration-2">Picard iteration  (2)</a></li>
<li><a class="reference internal" href="#newton-s-method-2">Newton&#8217;s method  (2)</a></li>
<li><a class="reference internal" href="#stopping-criteria-2">Stopping criteria  (2)</a></li>
<li><a class="reference internal" href="#example-a-nonlinear-ode-model-from-epidemiology">Example: A nonlinear ODE model from epidemiology</a><ul>
<li><a class="reference internal" href="#implicit-time-discretization">Implicit time discretization</a></li>
<li><a class="reference internal" href="#a-picard-iteration">A Picard iteration</a></li>
<li><a class="reference internal" href="#newton-s-method-3">Newton&#8217;s method  (3)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#linearization-at-the-differential-equation-level">Linearization at the differential equation level</a><ul>
<li><a class="reference internal" href="#explicit-time-integration">Explicit time integration</a></li>
<li><a class="reference internal" href="#picard-iteration-3">Picard iteration  (3)</a></li>
<li><a class="reference internal" href="#newton-s-method-4">Newton&#8217;s method  (4)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discretization-of-nonlinear-differential-equations">Discretization of nonlinear differential equations</a><ul>
<li><a class="reference internal" href="#finite-difference-discretizations">Finite difference discretizations</a><ul>
<li><a class="reference internal" href="#discretization">Discretization</a></li>
<li><a class="reference internal" href="#solution-of-algebraic-equations">Solution of algebraic equations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#finite-element-discretizations">Finite element discretizations</a><ul>
<li><a class="reference internal" href="#remark">Remark</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-group-finite-element-method">The group finite element method</a><ul>
<li><a class="reference internal" href="#finite-element-notation">Finite element notation</a></li>
<li><a class="reference internal" href="#integrating-nonlinear-functions">Integrating nonlinear functions</a></li>
<li><a class="reference internal" href="#finite-element-approximation-of-functions-of">Finite element approximation of functions of <span class="math">\(u\)</span></a></li>
<li><a class="reference internal" href="#application">Application</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numerical-integration-of-nonlinear-terms">Numerical integration of nonlinear terms</a></li>
<li><a class="reference internal" href="#finite-element-discretization-of-a-variable-coefficient-laplace-term">Finite element discretization of a variable coefficient Laplace term</a></li>
<li><a class="reference internal" href="#picard-iteration-defined-from-the-variational-form">Picard iteration defined from the variational form</a></li>
<li><a class="reference internal" href="#newton-s-method-defined-from-the-variational-form">Newton&#8217;s method defined from the variational form</a><ul>
<li><a class="reference internal" href="#dirichlet-conditions">Dirichlet conditions</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#multi-dimensional-pde-problems">Multi-dimensional PDE problems</a><ul>
<li><a class="reference internal" href="#finite-element-discretization">Finite element discretization</a></li>
<li><a class="reference internal" href="#finite-difference-discretization">Finite difference discretization</a></li>
<li><a class="reference internal" href="#continuation-methods">Continuation methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises">Exercises</a><ul>
<li><a class="reference internal" href="#problem-1-determine-if-equations-are-nonlinear-or-not">Problem 1: Determine if equations are nonlinear or not</a></li>
<li><a class="reference internal" href="#problem-2-linearize-a-nonlinear-vibration-ode">Problem 2: Linearize a nonlinear vibration ODE</a></li>
<li><a class="reference internal" href="#exercise-3-find-the-sparsity-of-the-jacobian">Exercise 3: Find the sparsity of the Jacobian</a></li>
<li><a class="reference internal" href="#exercise-4-newton-s-method-for-linear-problems">Exercise 4: Newton&#8217;s method for linear problems</a></li>
<li><a class="reference internal" href="#exercise-5-differentiate-a-highly-nonlinear-term">Exercise 5: Differentiate a highly nonlinear term</a></li>
<li><a class="reference internal" href="#problem-6-discretize-a-1d-problem-with-a-nonlinear-coefficient">Problem 6: Discretize a 1D problem with a nonlinear coefficient</a></li>
<li><a class="reference internal" href="#problem-7-linearize-a-1d-problem-with-a-nonlinear-coefficient">Problem 7: Linearize a 1D problem with a nonlinear coefficient</a></li>
<li><a class="reference internal" href="#problem-8-finite-differences-for-the-1d-bratu-problem">Problem 8: Finite differences for the 1D Bratu problem</a></li>
<li><a class="reference internal" href="#problem-9-integrate-functions-of-finite-element-expansions">Problem 9: Integrate functions of finite element expansions</a></li>
<li><a class="reference internal" href="#problem-10-finite-elements-for-the-1d-bratu-problem">Problem 10: Finite elements for the 1D Bratu problem</a></li>
<li><a class="reference internal" href="#problem-11-derive-the-newton-system-from-a-variational-form">Problem 11: Derive the Newton system from a variational form</a></li>
<li><a class="reference internal" href="#problem-12-derive-algebraic-equations-for-nonlinear-1d-heat-conduction">Problem 12: Derive algebraic equations for nonlinear 1D heat conduction</a></li>
<li><a class="reference internal" href="#problem-13-investigate-a-1d-problem-with-a-continuation-method">Problem 13: Investigate a 1D problem with a continuation method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Nonlinear differential equation problems</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._part0000_main_nonlin.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Nonlinear differential equation problems"
             >previous</a> |</li>
        <li><a href="index.html">Nonlinear differential equation problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>