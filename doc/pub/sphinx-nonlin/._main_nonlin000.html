

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Nonlinear differential equation problems</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Nonlinear differential equation problems" href="index.html" />
    <link rel="next" title="Systems of nonlinear algebraic equations" href="._main_nonlin001.html" />
    <link rel="prev" title="Nonlinear differential equation problems" href="index.html" />
 
  
   <style type=text/css>
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_nonlin001.html" title="Systems of nonlinear algebraic equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Nonlinear differential equation problems"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Nonlinear differential equation problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="nonlinear-differential-equation-problems">
<h1>Nonlinear differential equation problems<a class="headerlink" href="#nonlinear-differential-equation-problems" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Dec 3, 2013</td>
</tr>
</tbody>
</table>
<p>Note: <strong>VERY PRELIMINARY VERSION</strong> (expect typos and mathematical errors)</p>
<p>In a linear differential equation all terms involving the unknown functions
are linear in the unknown functions or their derivatives. Linear here means that
the unknown function or a derivative of it is multiplied by a number or
a known function. All other differential equations are non-linear.
The easiest way to see if an equation is nonlinear is to spot nonlinear terms
where the unknown functions or their derivatives are multiplied by
each other. For example, in</p>
<div class="math">
\[u'(t) = -a(t)u(t) + b(t),\]</div>
<p>the terms involving the unknown function <span class="math">\(u\)</span> are linear: <span class="math">\(u'\)</span> contains
the derivative of the unknown function multiplied by unity, and <span class="math">\(au\)</span> contains
the unknown function multiplied by a known function.
However,</p>
<div class="math">
\[u'(t) = u(t)(1 - u(t)),\]</div>
<p>is nonlinear because of the term <span class="math">\(-u^2\)</span> where the unknown function is
multiplied by itself. Also</p>
<div class="math">
\[\frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0,\]</div>
<p>is nonlinear because of the term <span class="math">\(uu_x\)</span> where the unknown
function appears in a product with itself or one if its derivatives.
Another example of a nonlinear equation is</p>
<div class="math">
\[u'' + \sin(u) =0,\]</div>
<p>because <span class="math">\(\sin(u)\)</span> contains products of <span class="math">\(u\)</span>,</p>
<div class="math">
\[\sin(u) = u - \frac{1}{3} u^3 + \ldots\]</div>
<p>A series of forthcoming examples will explain who to tackle
nonlinear differential equations with various techniques.</p>
</div>
<div class="section" id="basic-examples-using-the-logistic-equation">
<span id="nonlin-timediscrete-logistic"></span><h1>Basic examples using the logistic equation<a class="headerlink" href="#basic-examples-using-the-logistic-equation" title="Permalink to this headline">¶</a></h1>
<p>Consider the (scaled) logistic equation</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:eq">
<span id="eq-nonlin-timediscrete-logistic-eq"></span><span class="eqno">(1)</span>\[     u'(t) = u(t)(1 - u(t)) {\thinspace .}\]</div>
<p>This is a nonlinear differential equation which will be solved by
different strategies in the following.
A time discretization of <a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a>
will either lead to a linear algebraic equation or a nonlinear
algebraic equation at each time level.
In the former case, the time discretization method transforms
the nonlinear ODE into linear subproblems at each time level, and
the solution is straightforward to find. However,
when the time discretization leads to nonlinear algebraic equations, we
cannot (except in very rare cases) solve these without turning to
approximate, iterative solution methods</p>
<div class="section" id="linearization-by-explicit-time-discretization">
<span id="nonlin-timediscrete-logistic-fe"></span><h2>Linearization by explicit time discretization<a class="headerlink" href="#linearization-by-explicit-time-discretization" title="Permalink to this headline">¶</a></h2>
<p id="index-0">A Forward Euler
method to solve <a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a> results in</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = u^n(1 - u^n),\]</div>
<p>which is a <em>linear</em> algebraic
equation for the unknown value <span class="math">\(u^{n+1}\)</span>. Therefore,
the nonlinearity in the original equation poses no difficulty
in the discrete algebraic equation.
Any other explicit scheme in time will also give only linear
algebraic equations
to solve. For example, a typical 2nd-order Runge-Kutta method
for <a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a> reads,</p>
<div class="math">
\[\begin{split}u^* &amp;= u^n + \Delta t u^n(1 - u^n),\\
u^{n+1} &amp;= u^n + \Delta t \frac{1}{2} \left(
u^n(1 - u^n) + u^*(1 - u^*))
\right){\thinspace .}\end{split}\]</div>
<p>The first step is linear in the unknown <span class="math">\(u^*\)</span>. Then <span class="math">\(u^*\)</span> is computed
and known in the next step, which is linear in the unknown <span class="math">\(u^{n+1}\)</span> .</p>
</div>
<div class="section" id="exact-solution-of-nonlinear-equations">
<span id="nonlin-timediscrete-logistic-roots"></span><h2>Exact solution of nonlinear equations<a class="headerlink" href="#exact-solution-of-nonlinear-equations" title="Permalink to this headline">¶</a></h2>
<p>Switching to a Backward Euler scheme for
<a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a>,</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:eq:BE">
<span id="eq-nonlin-timediscrete-logistic-eq-be"></span><span class="eqno">(2)</span>\[     \frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^n),\]</div>
<p>results in a nonlinear algebraic equation for the unknown value <span class="math">\(u^n\)</span>.
The equation is of quadratic type:</p>
<div class="math">
\[\Delta t (u^n)^2 + (1-\Delta t)u^n - u^{n-1} = 0{\thinspace .}\]</div>
<p>We shall now introduce a shorter and often cleaner notation for nonlinear
algebraic equation that appear at a given time level. The notation
gets rid of the superscript that indicates the time level and
is motivated by how we will program the solution method for
the algebraic equation, especially in more advanced partial
differential equation problems. The unknown
in the algebraic equation is denoted by <span class="math">\(u\)</span>, while <span class="math">\(u_1\)</span> is
the value of the unknown at the previous time level (in general <span class="math">\(u_\ell\)</span>
is the value of the unknown <span class="math">\(\ell\)</span> levels back in time).
The quadratic equation for the unknown <span class="math">\(u^n\)</span> in
<a href="#equation-nonlin:timediscrete:logistic:eq:BE">(2)</a> can then be written</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:eq:F">
<span id="eq-nonlin-timediscrete-logistic-eq-f"></span><span class="eqno">(3)</span>\[     F(u) = \Delta t u^2 + (1-\Delta t)u - u_1 = 0,\]</div>
<p>and the solution is</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:eq:roots">
<span id="eq-nonlin-timediscrete-logistic-eq-roots"></span><span class="eqno">(4)</span>\[     u = \frac{1}{2\Delta t}
     \left(-1-\Delta t \pm \sqrt{(1-\Delta t)^2 - 4\Delta t u_1}\right)
     {\thinspace .}\]</div>
<p>Here we encounter a fundamental challenge with nonlinear
algebraic equations:
the equation may have more than one solution. How do we pick the right
solution? In the present simple case we can expand the square root
in a series in <span class="math">\(\Delta t\)</span> and truncate after the linear term since
the Backward Euler scheme will introduce an error proportional to
<span class="math">\(\Delta t\)</span> anyway. Using <tt class="docutils literal"><span class="pre">sympy</span></tt> we find the following Taylor series
expansions of the roots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt u_1 u&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>  <span class="c"># find roots</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span>
<span class="go">(dt - sqrt(dt**2 + 4*dt*u_1 - 2*dt + 1) - 1)/(2*dt)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span>
<span class="go">(dt + sqrt(dt**2 + 4*dt*u_1 - 2*dt + 1) - 1)/(2*dt)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r1</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-1/dt + 1 - u_1 + dt*(u_1**2 - u_1) + O(dt**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r2</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">u_1 + dt*(-u_1**2 + u_1) + O(dt**2)</span>
</pre></div>
</div>
<p>We see that the <tt class="docutils literal"><span class="pre">r1</span></tt> root, corresponding to
a minus sign in front of the square root in
<a href="#equation-nonlin:timediscrete:logistic:eq:roots">(4)</a>,
behaves as <span class="math">\(1/\Delta t\)</span> and will therefore
blow up as <span class="math">\(\Delta t\rightarrow 0\)</span>! Only the <tt class="docutils literal"><span class="pre">r2</span></tt> root is of
relevance in this case.</p>
</div>
<div class="section" id="linearization">
<h2>Linearization<a class="headerlink" href="#linearization" title="Permalink to this headline">¶</a></h2>
<p>When the time integration of an ODE results in a nonlinear algebraic
equation, we must normally find its solution by defining a sequence
of linear equations and hope that the solutions of these linear equations
converge to the desired solution of the nonlinear algebraic equation.
Usually this means solving the linear equation repeatedly in an
iterative fashion.
Sometimes the nonlinear equation is just approximated by a linear equation
and no iteration is carried out.</p>
<p>Constructing a linear equation from a nonlinear one requires
<em>linearization</em> of each nonlinear term. This can be done manually
as in Picard iteration, or fully algorithmically as in Newton&#8217;s method.
Examples will best illustrate how to linearize nonlinear problems.</p>
</div>
<div class="section" id="picard-iteration-1">
<span id="nonlin-timediscrete-logistic-picard"></span><h2>Picard iteration  (1)<a class="headerlink" href="#picard-iteration-1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><span class="target" id="index-5"></span><p id="index-6">Let us write <a href="#equation-nonlin:timediscrete:logistic:eq:F">(3)</a> in a
more compact form</p>
<div class="math">
\[F(u) = au^2 + bu + c = 0,\]</div>
<p>with <span class="math">\(a=\Delta t\)</span>, <span class="math">\(b=1-\Delta t\)</span>, and <span class="math">\(c=-u_1\)</span>.
Let <span class="math">\(u_{-}\)</span> an available approximation of the unknown <span class="math">\(u\)</span>.
Then we can linearize the term <span class="math">\(u^2\)</span> by writing
<span class="math">\(u_{-}u\)</span>. The resulting equation, <span class="math">\(\hat F(u)=0\)</span>, is linear
and hence easy to solve:</p>
<div class="math">
\[F(u)\approx\hat F(u) = au_{-}u + bu + c = 0{\thinspace .}\]</div>
<p>Since the equation <span class="math">\(\hat F=0\)</span> is only approximate, the solution <span class="math">\(u\)</span>
does not equal the exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> of the exact
equation <span class="math">\(F({u_{\small\mbox{e}}})=0\)</span>, but we can hope that <span class="math">\(u\)</span> is closer to
<span class="math">\({u_{\small\mbox{e}}}\)</span> than <span class="math">\(u_{-}\)</span> is, and hence it makes sense to repeat the
procedure, i.e., set <span class="math">\(u_{-}=u\)</span> and solve <span class="math">\(\hat F(u)=0\)</span> again.</p>
<p>The idea of turning a nonlinear equation into a linear one by
using an approximation <span class="math">\(u_{-}\)</span> of <span class="math">\(u\)</span> in nonlinear terms is
a widely used approach that goes under many names:
<em>fixed-point iteration</em>, the method of <em>successive substitutions</em>,
<em>nonlinear Richardson iteration</em>, and <em>Picard iteration</em>.
We will stick to the latter name.</p>
<p>Picard iteration for solving the nonlinear equation
arising from the Backward Euler discretization of the logistic
equation can be written as</p>
<div class="math">
\[u = -\frac{c}{au_{-} + b},\quad u_{-}\ \leftarrow\ u{\thinspace .}\]</div>
<p>The iteration is started with the value of the unknown at the
previous time level: <span class="math">\(u_{-}=u_1\)</span>.</p>
<p>Some prefer an explicit iteration counter as superscript
in the mathematical notation. Let <span class="math">\(u^k\)</span> be the computed approximation
to the solution in iteration <span class="math">\(k\)</span>. In iteration <span class="math">\(k+1\)</span> we want
to solve</p>
<div class="math">
\[au^k u^{k+1} + bu^{k+1} + c = 0\quad\Rightarrow\quad u^{k+1}
= -\frac{c}{au^k + b},\quad k=0,1,\ldots\]</div>
<p>However, we will normally apply a mathematical notation in our
final formulas that is as close as possible to what we aim to write
in a computer code and then we want to omit the <span class="math">\(k\)</span> superscript
in <span class="math">\(u\)</span>.</p>
<div class="section" id="stopping-criteria-1">
<span id="index-7"></span><h3>Stopping criteria  (1)<a class="headerlink" href="#stopping-criteria-1" title="Permalink to this headline">¶</a></h3>
<p>The iteration method can typically be terminated when the change
in the solution is smaller than a tolerance <span class="math">\(\epsilon_u\)</span>:</p>
<div class="math">
\[|u - u_{-}| \leq\epsilon_u,\]</div>
<p>or when the residual in the equation is sufficiently small (<span class="math">\(\epsilon_r\)</span>),</p>
<div class="math">
\[\begin{split}|F(u)|= |au^2+bu + c| &lt; \epsilon_r{\thinspace .}\end{split}\]</div>
<p>With <span class="math">\(\epsilon_r = 10^{-7}\)</span> we seldom need more than about 5 iterations
when solving this logistic equation.</p>
</div>
<div class="section" id="a-single-picard-iteration">
<span id="index-8"></span><h3>A single Picard iteration<a class="headerlink" href="#a-single-picard-iteration" title="Permalink to this headline">¶</a></h3>
<p>Instead of iterating until a stopping criterion is fulfilled, one may
iterate a specific number of times. Just one Picard iteration is
popular as this corresponds to the intuitive idea of approximating
a nonlinear term like <span class="math">\((u^n)^2\)</span> by <span class="math">\(u^{n-1}u^n\)</span>. That is, one just
applies a known value for the unknown at the previous time level
in nonlinear terms. The corresponding time discretization reads</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:BE:Picard:1it">
<span id="eq-nonlin-timediscrete-logistic-be-picard-1it"></span><span class="eqno">(5)</span>\[     \frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^{n-1}){\thinspace .}\]</div>
<p>This is obviously an approximation and does not correspond to
a &#8220;pure&#8221; finite difference method where the equation is sampled at
a point and derivatives replaced by differences. The best
interpretation of the scheme <a href="#equation-nonlin:timediscrete:logistic:BE:Picard:1it">(5)</a>
is a Backward Euler difference combined with a single Picard iteration
at each time level, using the value at the previous time level as
start for the Picard iteration.</p>
</div>
</div>
<div class="section" id="linearization-by-a-geometric-mean">
<span id="nonlin-timediscrete-logistic-geometric-mean"></span><h2>Linearization by a geometric mean<a class="headerlink" href="#linearization-by-a-geometric-mean" title="Permalink to this headline">¶</a></h2>
<p>We consider now a Crank-Nicolson discretization of
<a href="#equation-nonlin:timediscrete:logistic:eq">(1)</a>. This means that the
time derivative is approximated by a centered
difference,</p>
<div class="math">
\[[D_t u = u(1-u)]^{n+\frac{1}{2}},\]</div>
<p>written out as</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:geometric:mean:scheme">
<span id="eq-nonlin-timediscrete-logistic-geometric-mean-scheme"></span><span class="eqno">(6)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = u^{n+\frac{1}{2}} -
     (u^{n+\frac{1}{2}})^2{\thinspace .}\]</div>
<p>The term <span class="math">\(u^{n+\frac{1}{2}}\)</span> is normally approximated by an arithmetic
mean,</p>
<div class="math">
\[u^{n+\frac{1}{2}}\approx \frac{1}{2}(u^n + u^{n+1}),\]</div>
<p>such that the scheme involves the unknown function only at the time levels
where we actually compute it.
The same arithmetic mean applied to the nonlinear term gives</p>
<div class="math">
\[(u^{n+\frac{1}{2}})^2\approx \frac{1}{4}(u^n + u^{n+1})^2,\]</div>
<p>which is nonlinear in the unknown <span class="math">\(u^{n+1}\)</span>.
However, using a <em>geometric mean</em> for <span class="math">\((u^{n+\frac{1}{2}})^2\)</span>
is a way of linearizing the nonlinear term in
<a href="#equation-nonlin:timediscrete:logistic:geometric:mean:scheme">(6)</a>:</p>
<div class="math">
\[(u^{n+\frac{1}{2}})^2\approx u^nu^{n+1}{\thinspace .}\]</div>
<p>The linearized scheme for <span class="math">\(u^{n+1}\)</span> now reads</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} =
\frac{1}{2}(u^n + u^{n+1}) + u^nu^{n+1},\]</div>
<p>which can readily be solved:</p>
<div class="math">
\[u^{n+1} = \frac{1 + \frac{1}{2}\Delta t}{1+\Delta t u^n - \frac{1}{2}\Delta t}
u^n{\thinspace .}\]</div>
<p>This scheme can be coded directly, and since
there is no nonlinear algebraic equation to solve by methods for those
kind of problems we skip the simplified notation (<span class="math">\(u\)</span> for <span class="math">\(u^{n+1}\)</span>
and <span class="math">\(u_1\)</span> for <span class="math">\(u^n\)</span>).</p>
<p>The geometric mean approximation is often very effective to deal with
quadratic nonlinearities. Both the arithmetic and geometric mean
approximations have truncation errors of order <span class="math">\(\Delta t^2\)</span> and are
therefore compatible with the truncation error of the
centered difference approximation for <span class="math">\(U'\)</span> in the Crank-Nicolson
method.</p>
<p>Applying the operator notation for the means, the linearized Crank-Nicolson
scheme for the logistic equation can be compactly expressed as</p>
<div class="math">
\[[D_t u = \overline{u}^{t} + \overline{u^2}^{t,g}]^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p><strong>Remark.</strong>
If we use an arithmetic instead of a geometric mean
for the nonlinear term in
<a href="#equation-nonlin:timediscrete:logistic:geometric:mean:scheme">(6)</a>,
we end up with a nonlinear term <span class="math">\((u^{n+1})^2\)</span>.
The term can be linearized as <span class="math">\(u^nu^{n+1}\)</span> in a Picard iteration approach.
Observe that the geometric mean avoids any iteration.</p>
</div>
<div class="section" id="newton-s-method-1">
<span id="nonlin-timediscrete-logistic-newton"></span><h2>Newton&#8217;s method  (1)<a class="headerlink" href="#newton-s-method-1" title="Permalink to this headline">¶</a></h2>
<p>The Backward Euler scheme <a href="#equation-nonlin:timediscrete:logistic:eq:BE">(2)</a>
for the logistic equation leads to a nonlinear algebraic equation
<a href="#equation-nonlin:timediscrete:logistic:eq:F">(3)</a>. Now we write any nonlinear
algebraic equation in the general and compact form</p>
<div class="math">
\[F(u) = 0{\thinspace .}\]</div>
<p>Newton&#8217;s method linearizes this equation by approximating <span class="math">\(F(u)\)</span> by
its Taylor series expansion around a computed value <span class="math">\(u_{-}\)</span>
and keeping only the linear part:</p>
<div class="math">
\[\begin{split}F(u) &amp;= F(u_{-}) + F'(u_{-})(u - u_{-}) + {\frac{1}{2}}F''(u_{-})(u-u_{-})^2
+\cdots\\
&amp; \approx F(u_{-}) + F'(u_{-})(u - u_{-}) = \hat F(u){\thinspace .}\end{split}\]</div>
<p>The linear equation <span class="math">\(\hat F(u)=0\)</span> has the solution</p>
<div class="math">
\[u = u_{-} - \frac{F(u_{-})}{F'(u_{-})}{\thinspace .}\]</div>
<p>Expressed with an iteration index on the unknown, Newton&#8217;s method takes
on the more familiar mathematical form</p>
<div class="math">
\[u^{k+1} = u^k - \frac{F(u^k)}{F'(u^k)},\quad k=0,1,\ldots\]</div>
<p>Application of Newton&#8217;s method to the logistic equation discretized
by the Backward Euler method is straightforward
as we have</p>
<div class="math">
\[F(u) = au^2 + bu + c,\quad a=\Delta t,\ b = 1-\Delta t,\ c=-u_1,\]</div>
<p>and then</p>
<div class="math">
\[F'(u) = 2au + b{\thinspace .}\]</div>
<p>The iteration method becomes</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:Newton:alg1">
<span id="eq-nonlin-timediscrete-logistic-newton-alg1"></span><span class="eqno">(7)</span>\[     u = u_{-} + \frac{au_{-}^2 + bu_{-} + c}{2au_{-} + b},\quad
     u_{-}\ \leftarrow u{\thinspace .}\]</div>
<p>At each time level, we start the iteration by setting <span class="math">\(u_{-}=u_1\)</span>.
Stopping criteria as listed for the Picard iteration can be used also
for Newton&#8217;s method.</p>
<p>An alternative mathematical form, where we write out <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, and <span class="math">\(c\)</span>,
and use a time level counter <span class="math">\(n\)</span> and an iteration counter <span class="math">\(k\)</span>, takes
the form</p>
<div class="math" id="equation-nonlin:timediscrete:logistic:Newton:alg2">
<span id="eq-nonlin-timediscrete-logistic-newton-alg2"></span><span class="eqno">(8)</span>\[     u^{n,k+1} = u^{n,k} +
     \frac{\Delta t (u^{n,k})^2 + (1-\Delta t)u^{n,k} - u^{n-1}}
     {2\Delta t u^{n,k} + 1 - \Delta t},\quad u^{n,0}=u^{n-1},\quad k=0,1,\ldots\]</div>
<p>The implementation is much closer to <a href="#equation-nonlin:timediscrete:logistic:Newton:alg1">(7)</a> than to <a href="#equation-nonlin:timediscrete:logistic:Newton:alg2">(8)</a>, but
the latter is better aligned with the established mathematical
notation used in the literature.</p>
</div>
<div class="section" id="relaxation">
<span id="nonlin-timediscrete-logistic-relaxation"></span><h2>Relaxation<a class="headerlink" href="#relaxation" title="Permalink to this headline">¶</a></h2>
<p id="index-9">One iteration in Newton&#8217;s method or
Picard iteration consists of solving a linear problem <span class="math">\(\hat F(u)=0\)</span>.
Sometimes convergence problems arise because the new solution <span class="math">\(u\)</span>
of <span class="math">\(\hat F(u)=0\)</span> is &#8220;too far away&#8221; from the previously computed
solution <span class="math">\(u_{-}\)</span>. A remedy is to introduce a relaxation, meaning that
we first solve <span class="math">\(\hat F(u^*)=0\)</span> for a suggested value <span class="math">\(u^*\)</span> and
then we take <span class="math">\(u\)</span> as a weighted mean of what we had, <span class="math">\(u_{-}\)</span>, and
what our linearized equation <span class="math">\(\hat F=0\)</span> suggests, <span class="math">\(u^*\)</span>:</p>
<div class="math">
\[u = \omega u^* + (1-\omega) u_{-}{\thinspace .}\]</div>
<p>The parameter <span class="math">\(\omega\)</span>
is known as a <em>relaxation parameter</em>, and a choice <span class="math">\(\omega &lt; 1\)</span>
may prevent divergent iterations.</p>
<p>Relaxation in Newton&#8217;s method can be directly incorporated
in the basic iteration formula:</p>
<div class="math">
\[u = u_{-} - \omega \frac{F(u_{-})}{F'(u_{-})}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-and-experiments">
<h2>Implementation and experiments<a class="headerlink" href="#implementation-and-experiments" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/nonlin/logistic.py">logistic.py</a> contains
implementations of all the methods described above.
Below is an extract of the file showing how the Picard and Newton
methods are implemented for a Backward Euler discretization of
the logistic equation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">BE_logistic</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="s">&#39;Picard&#39;</span><span class="p">,</span> <span class="n">eps_r</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dt</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">&#39;Picard&#39;</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">c</span>

            <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps_r</span><span class="p">:</span>
                <span class="n">u_</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">u_</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">u_</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_</span>
        <span class="k">elif</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">&#39;Newton&#39;</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">c</span>

            <span class="k">def</span> <span class="nf">dF</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">b</span>

            <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps_r</span><span class="p">:</span>
                <span class="n">u_</span> <span class="o">=</span> <span class="n">u_</span> <span class="o">-</span> <span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">/</span><span class="n">dF</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>The Crank-Nicolson method utilizing a linearization based on the
geometric mean gives a simpler algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CN_logistic</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>Experiments with this program reveal the relative performance
of the methods as summarized in the table below.
The Picard and Newton columns reflect the typical number of
iterations with these methods before the curve starts to flatten out
and the number of iterations is significantly reduced since
the solution of the nonlinear algebraic equation is very close to
the starting value for the iterations (the solution at the previous
time level). Increasing <span class="math">\(\Delta t\)</span> moves the starting value further
away from the solution of the nonlinear equation and one expects
an increase in the number of iterations. Picard iteration is
very much more sensitive to the size of <span class="math">\(\Delta t\)</span> than Newton&#8217;s method.
The tolerance <span class="math">\(\epsilon_r\)</span> in residual-based
stopping criterion takes on a low and high value in the experiments.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\epsilon_r\)</span></th>
<th class="head">Picard</th>
<th class="head">Newton</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\(0.2\)</span></td>
<td><span class="math">\(10^{-7}\)</span></td>
<td>5</td>
<td>2</td>
</tr>
<tr class="row-odd"><td><span class="math">\(0.2\)</span></td>
<td><span class="math">\(10^{-3}\)</span></td>
<td>2</td>
<td>1</td>
</tr>
<tr class="row-even"><td><span class="math">\(0.4\)</span></td>
<td><span class="math">\(10^{-7}\)</span></td>
<td>12</td>
<td>3</td>
</tr>
<tr class="row-odd"><td><span class="math">\(0.4\)</span></td>
<td><span class="math">\(10^{-3}\)</span></td>
<td>4</td>
<td>2</td>
</tr>
<tr class="row-even"><td><span class="math">\(0.8\)</span></td>
<td><span class="math">\(10^{-7}\)</span></td>
<td>58</td>
<td>3</td>
</tr>
<tr class="row-odd"><td><span class="math">\(0.8\)</span></td>
<td><span class="math">\(10^{-3}\)</span></td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><strong>Remark.</strong>
The simple Crank-Nicolson method with a geometric mean for the quadratic
nonlinearity gives visually more accurate solutions than the
Backward Euler discretization. Even with a tolerance of <span class="math">\(\epsilon_r=10^{-3}\)</span>,
all the methods for treating the nonlinearities in the Backward Euler
discretization gives graphs that cannot be distinguished. So for
accuracy in this problem, the time discretization is much more crucial
than <span class="math">\(\epsilon_r\)</span>. Ideally, one should estimate the error in the
time discretization, as the solution progresses, and set <span class="math">\(\epsilon_r\)</span>
accordingly.</p>
</div>
<div class="section" id="generalization-to-a-general-nonlinear-ode">
<span id="nonlin-ode-generic"></span><h2>Generalization to a general nonlinear ODE<a class="headerlink" href="#generalization-to-a-general-nonlinear-ode" title="Permalink to this headline">¶</a></h2>
<p>Let us see how the various methods in the previous sections
can be applied to the more generic model</p>
<div class="math" id="equation-nonlin:ode:generic:model">
<span id="eq-nonlin-ode-generic-model"></span><span class="eqno">(9)</span>\[     u' = f(u, t),\]</div>
<p>where <span class="math">\(f\)</span> is a nonlinear function of <span class="math">\(u\)</span>.</p>
<div class="section" id="explicit-time-discretization">
<h3>Explicit time discretization<a class="headerlink" href="#explicit-time-discretization" title="Permalink to this headline">¶</a></h3>
<p>Explicit ODE methods like the Forward Euler scheme, Runge-Kutta methods,
Adams-Bashforth methods all evaluate <span class="math">\(f\)</span> at time levels where
<span class="math">\(u\)</span> is already computed, so nonlinearities in <span class="math">\(f\)</span> do not
pose any difficulties.</p>
</div>
<div class="section" id="backward-euler-discretization">
<h3>Backward Euler discretization<a class="headerlink" href="#backward-euler-discretization" title="Permalink to this headline">¶</a></h3>
<p>Approximating <span class="math">\(u'\)</span> by a backward difference leads to a Backward Euler
scheme, which can be written as</p>
<div class="math">
\[F(u^n) = u^{n} - \Delta t f(u^n, t_n) - u^{n-1}=0,\]</div>
<p>or alternatively</p>
<div class="math">
\[F(u) = u - \Delta t f(u, t_n) - u_1 = 0{\thinspace .}\]</div>
<p>A simple Picard iteration, not knowing anything about the nonlinear
structure of <span class="math">\(f\)</span>, must approximate <span class="math">\(f(u,t_n)\)</span> by <span class="math">\(f(u_{-},t_n)\)</span>:</p>
<div class="math">
\[\hat F(u) = u - \Delta t f(u_{-},t_n) - u_1{\thinspace .}\]</div>
<p>The iteration starts with <span class="math">\(u_{-}=u_1\)</span> and proceeds with repeating</p>
<div class="math">
\[u^* = \Delta t f(u_{-},t_n) + u_1,\quad u = \omega u^* + (1-\omega)u_{-},
\quad u_{-}\ \leftarrow\ u,\]</div>
<p>until a stopping criterion is fulfilled.</p>
<p>Newton&#8217;s method requires the computation of the derivative</p>
<div class="math">
\[F'(u) = 1 - \Delta t\frac{\partial f}{\partial u}(u,t_n){\thinspace .}\]</div>
<p>Starting with the solution at the previous time level, <span class="math">\(u_{-}=u_1\)</span>,
we can just use the standard formula</p>
<div class="math">
\[u = u_{-} - \omega \frac{F(u_{-})}{F'(u_{-})}
= u_ - \omega \frac{u_1 + \Delta t f(u_,t_{n})}{1 - \Delta t
\frac{\partial}{\partial u}f(u_,t_n)}
{\thinspace .}\]</div>
<p>The geometric mean trick cannot be used unless we know that <span class="math">\(f\)</span> has
a special structure with quadratic expressions in <span class="math">\(u\)</span>.</p>
</div>
<div class="section" id="crank-nicolson-discretization">
<h3>Crank-Nicolson discretization<a class="headerlink" href="#crank-nicolson-discretization" title="Permalink to this headline">¶</a></h3>
<p>The standard Crank-Nicolson scheme with arithmetic mean approximation of
<span class="math">\(f\)</span> takes the form</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = \frac{1}{2}(f(u^{n+1}, t_{n+1})
+ f(u^n, t_n)){\thinspace .}\]</div>
<p>Introducing <span class="math">\(u\)</span> for the unknown <span class="math">\(u^{n+1}\)</span> and <span class="math">\(u_1\)</span> for <span class="math">\(u^n\)</span>, we
can write the scheme as a nonlinear algebraic equation</p>
<div class="math">
\[F(u) = u - u_1 - \Delta t{\frac{1}{2}}f(u,t_{n+1}) -
\Delta t{\frac{1}{2}}f(u_1,t_{n}) = 0{\thinspace .}\]</div>
<p>A Picard iteration scheme must in general employ the linearization,</p>
<div class="math">
\[\hat F(u) = u - u_1 - \Delta t{\frac{1}{2}}f(u_{-},t_{n+1}) -
\Delta t{\frac{1}{2}}f(u_1,t_{n}),\]</div>
<p>while Newton&#8217;s method can apply the general formula,  but we need
to derive</p>
<div class="math">
\[F'(u)= 1 - \frac{1}{2}\Delta t\frac{\partial f}{\partial u}(u,t_{n+1}){\thinspace .}\]</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Nonlinear differential equation problems</a></li>
<li><a class="reference internal" href="#basic-examples-using-the-logistic-equation">Basic examples using the logistic equation</a><ul>
<li><a class="reference internal" href="#linearization-by-explicit-time-discretization">Linearization by explicit time discretization</a></li>
<li><a class="reference internal" href="#exact-solution-of-nonlinear-equations">Exact solution of nonlinear equations</a></li>
<li><a class="reference internal" href="#linearization">Linearization</a></li>
<li><a class="reference internal" href="#picard-iteration-1">Picard iteration  (1)</a><ul>
<li><a class="reference internal" href="#stopping-criteria-1">Stopping criteria  (1)</a></li>
<li><a class="reference internal" href="#a-single-picard-iteration">A single Picard iteration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#linearization-by-a-geometric-mean">Linearization by a geometric mean</a></li>
<li><a class="reference internal" href="#newton-s-method-1">Newton&#8217;s method  (1)</a></li>
<li><a class="reference internal" href="#relaxation">Relaxation</a></li>
<li><a class="reference internal" href="#implementation-and-experiments">Implementation and experiments</a></li>
<li><a class="reference internal" href="#generalization-to-a-general-nonlinear-ode">Generalization to a general nonlinear ODE</a><ul>
<li><a class="reference internal" href="#explicit-time-discretization">Explicit time discretization</a></li>
<li><a class="reference internal" href="#backward-euler-discretization">Backward Euler discretization</a></li>
<li><a class="reference internal" href="#crank-nicolson-discretization">Crank-Nicolson discretization</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Nonlinear differential equation problems</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_nonlin001.html"
                        title="next chapter">Systems of nonlinear algebraic equations</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_nonlin000.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_nonlin001.html" title="Systems of nonlinear algebraic equations"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Nonlinear differential equation problems"
             >previous</a> |</li>
        <li><a href="index.html">Nonlinear differential equation problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>