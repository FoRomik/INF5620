

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite difference methods for vibration problems</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Finite difference methods for vibration problems" href="index.html" /> 
  
   <style type=text/css>
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">Finite difference methods for vibration problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="finite-difference-methods-for-vibration-problems">
<h1>Finite difference methods for vibration problems<a class="headerlink" href="#finite-difference-methods-for-vibration-problems" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Sep 9, 2013</td>
</tr>
</tbody>
</table>
<p>Note: <strong>PRELIMINARY VERSION</strong> (expect typos)</p>
<p>Vibration problems lead to differential equations with solutions that
oscillates in time, typically in a damped or undamped sinusoidal
fashion.  Such solutions put certain demands on the numerical methods
compared to other phenomena whose solutions are monotone.
Both the frequency and amplitude of the oscillations need to be
accurately handled by the numerical schemes. Most of the reasoning and
specific building blocks introduced in the fortcoming text can be
reused to construct sound methods for partial differential equations
of wave nature in multiple spatial dimensions.</p>
</div>
<div class="section" id="finite-difference-discretization">
<span id="vib-model1"></span><h1>Finite difference discretization<a class="headerlink" href="#finite-difference-discretization" title="Permalink to this headline">¶</a></h1>
<p>Much of the numerical challenges with computing oscillatory
solutions in ODEs and PDEs can be captured by the very simple
ODE <span class="math">\(u'' + u =0\)</span> and this is therefore the starting point for
method development, implementation, and analysis.</p>
<div class="section" id="a-basic-model-for-vibrations">
<h2>A basic model for vibrations<a class="headerlink" href="#a-basic-model-for-vibrations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">A system that vibrates without damping and external forcing
can be described by ODE problem</p>
<div class="math" id="equation-vib:ode1">
<span class="eqno">(1)</span>\[     u'' + \omega^2u = 0,\quad u(0)=I,\ u'(0)=0,\ t\in (0,T]
     \thinspace .\]</div>
<p>Here, <span class="math">\(\omega\)</span> and <span class="math">\(I\)</span> are given constants.
The exact solution of <a href="#equation-vib:ode1">(1)</a> is</p>
<span class="target" id="index-3"></span><span class="target" id="index-4"></span><div class="math" id="equation-vib:ode1:uex">
<span id="index-5"></span><span class="eqno">(2)</span>\[     u(t) = I\cos (\omega t)
     \thinspace .\]</div>
<p>That is, <span class="math">\(u\)</span> oscillates with constant amplitude <span class="math">\(I\)</span> and
angular frequency <span class="math">\(\omega\)</span>.
The corresponding period of oscillations (i.e., the time between two
neighboring peaks in the cosine function) is <span class="math">\(P=2\pi/\omega\)</span>.
The number of periods per second
is <span class="math">\(f=\omega/(2\pi)\)</span> and measured in the unit Hz.
Both <span class="math">\(f\)</span> and <span class="math">\(\omega\)</span> are referred to as frequency, but <span class="math">\(\omega\)</span>
may be more precisely named angular frequency, measured in rad/s.</p>
<p>In vibrating mechanical systems modeled by <a href="#equation-vib:ode1">(1)</a>, <span class="math">\(u(t)\)</span>
very often represents a position or a displacement of a particular
point in the system. The derivative <span class="math">\(u'(t)\)</span> then has the
interpretation of the point&#8217;s velocity, and <span class="math">\(u''(t)\)</span> is the associated
acceleration.  The model <a href="#equation-vib:ode1">(1)</a> is not only
applicable to vibrating mechanical systems, but also to oscillations
in electrical circuits.</p>
</div>
<div class="section" id="a-centered-finite-difference-scheme">
<span id="vib-ode1-fdm"></span><h2>A centered finite difference scheme<a class="headerlink" href="#a-centered-finite-difference-scheme" title="Permalink to this headline">¶</a></h2>
<p>To formulate a finite difference method for the model
problem  <a href="#equation-vib:ode1">(1)</a> we follow the <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#the-forward-euler-scheme">four steps</a> in <a class="reference internal" href="#ref1">[Ref1]</a>.</p>
<span class="target" id="index-6"></span><div class="section" id="step-1-discretizing-the-domain">
<span id="index-7"></span><h3>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The domain is discretized by
introducing a uniformly partitioned time mesh in the present problem.
The points in the mesh are hence <span class="math">\(t_n=n\Delta t\)</span>, <span class="math">\(n=0,1,\ldots,N_t\)</span>,
where <span class="math">\(\Delta t = T/N_t\)</span> is the constant length of the time steps.
We introduce a mesh function <span class="math">\(u^n\)</span> for <span class="math">\(n=0,1,\ldots,N_t\)</span>, which
approximates the exact solution at the mesh points. The mesh
function will be computed from algebraic equations derived from
the differential equation problem.</p>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h3>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h3>
<p>The ODE is to be satisfied at each mesh point:</p>
<div class="math" id="equation-vib:ode1:step2">
<span class="eqno">(3)</span>\[     u''(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
     \thinspace .\]</div>
<span class="target" id="index-8"></span></div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<span id="index-9"></span><h3>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The derivative <span class="math">\(u''(t_n)\)</span> is to be replaced by a finite
difference approximation. A common second-order accurate approximation
to the second-order derivative is</p>
<div class="math" id="equation-vib:ode1:step3">
<span class="eqno">(4)</span>\[     u''(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     \thinspace .\]</div>
<p>Inserting <a href="#equation-vib:ode1:step3">(4)</a> in <a href="#equation-vib:ode1:step2">(3)</a>
yields</p>
<div class="math" id="equation-vib:ode1:step3b">
<span class="eqno">(5)</span>\[     \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
     \thinspace .\]</div>
<p>We also need to replace the derivative in the initial condition by
a finite difference. Here we choose a centered difference:</p>
<div class="math" id="equation-vib:ode1:step3c">
<span class="eqno">(6)</span>\[     \frac{u^1-u^{-1}}{2\Delta t} = 0\]\[     \thinspace .\]</div>
</div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<h3>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p>To formulate the computational algorithm, we assume that we
have already computed <span class="math">\(u^{n-1}\)</span> and <span class="math">\(u^n\)</span> such that <span class="math">\(u^{n+1}\)</span> is the
unknown value, which we can readily solve for:</p>
<div class="math" id="equation-vib:ode1:step4">
<span class="eqno">(7)</span>\[     u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
     \thinspace .\]</div>
<p>The computational algorithm is simply to apply <a href="#equation-vib:ode1:step4">(7)</a>
successively for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>. This numerical scheme sometimes
goes under the name
Stormer&#8217;s
method or <a class="reference external" href="http://en.wikipedia.org/wiki/Velocity_Verlet">Verlet integration</a>.</p>
</div>
<div class="section" id="computing-the-first-step">
<h3>Computing the first step<a class="headerlink" href="#computing-the-first-step" title="Permalink to this headline">¶</a></h3>
<p>We observe that <a href="#equation-vib:ode1:step4">(7)</a> cannot be used for <span class="math">\(n=0\)</span> since
the computation of <span class="math">\(u^1\)</span> then involves the undefined value <span class="math">\(u^{-1}\)</span>
at <span class="math">\(t=-\Delta t\)</span>. The discretization of the initial condition
then come to rescue: <a href="#equation-vib:ode1:step3c">(6)</a> implies <span class="math">\(u^{-1} = u^1\)</span>
and this relation can be combined with <a href="#equation-vib:ode1:step4">(7)</a>
for <span class="math">\(n=1\)</span> to yield a value for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u^1 = 2u^0 - u^{1} - \Delta t^2 \omega^2 u^0,\]</div>
<p>which reduces to</p>
<div class="math" id="equation-vib:ode1:step4b">
<span class="eqno">(8)</span>\[     u^1 = u^0 - \frac{1}{2} \Delta t^2 \omega^2 u^0
     \thinspace .\]</div>
<p><a class="reference internal" href="#vib-exer-step4b-alt"><em>Exercise 4: Use a Taylor polynomial to compute </em></a> asks you to perform an alternative derivation
and also to generalize the initial condition to <span class="math">\(u'(0)=V\neq 0\)</span>.</p>
</div>
<div class="section" id="the-computational-algorithm">
<h3>The computational algorithm<a class="headerlink" href="#the-computational-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The steps for solving <a href="#equation-vib:ode1">(1)</a> becomes</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a href="#equation-vib:ode1:step4b">(8)</a></li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>compute <span class="math">\(u^{n+1}\)</span> from <a href="#equation-vib:ode1:step4">(7)</a></li>
</ol>
</div></blockquote>
</div></blockquote>
<p>The algorithm is more precisely expressed directly in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># mesh points in time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c"># constant time step</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># solution</span>

<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition-remark admonition">
<p class="first admonition-title">Remark</p>
<p class="last">In the code, we use <tt class="docutils literal"><span class="pre">w</span></tt> as the symbol for <span class="math">\(\omega\)</span>.
The reason is that this author prefers <tt class="docutils literal"><span class="pre">w</span></tt> for readability
and comparison with the mathematical <span class="math">\(\omega\)</span> instead of
the full word <tt class="docutils literal"><span class="pre">omega</span></tt> as variable name.</p>
</div>
</div>
<div class="section" id="operator-notation">
<h3>Operator notation<a class="headerlink" href="#operator-notation" title="Permalink to this headline">¶</a></h3>
<p>We may write the scheme using the compact difference notation
(see
<a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#compact-operator-notation-for-finite-differences">examples</a> in <a class="reference internal" href="#ref1">[Ref1]</a>). The difference <a href="#equation-vib:ode1:step3">(4)</a> has the operator
notation <span class="math">\([D_tD_t u]^n\)</span> such that we can write:</p>
<div class="math" id="equation-vib:ode1:step4:op">
<span class="eqno">(9)</span>\[     [D_tD_t u  + \omega^2 u = 0]^n
     \thinspace .\]</div>
<p>Note that <span class="math">\([D_tD_t u]^n\)</span> means applying a central difference with step <span class="math">\(\Delta t/2\)</span> twice:</p>
<div class="math">
\[[D_t(D_t u)]^n = \frac{[D_t u]^{n+1/2} - [D_t u]^{n-1/2}}{\Delta t}\]</div>
<p>which is written out as</p>
<div class="math">
\[\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .\]</div>
<p>The discretization of initial conditions can in the operator notation
be expressed as</p>
<div class="math">
\[[u = I]^0,\quad [D_{2t} u = 0]^0,\]</div>
<p>where the operator <span class="math">\([D_{2t} u]^n\)</span> is defined as</p>
<div class="math">
\[[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
\thinspace .\]</div>
</div>
<div class="section" id="computing">
<h3>Computing <span class="math">\(u'\)</span><a class="headerlink" href="#computing" title="Permalink to this headline">¶</a></h3>
<p>In mechanical vibration applications one is often interested in
computing the velocity <span class="math">\(u'(t)\)</span> after <span class="math">\(u(t)\)</span> has been computed.
This can be done by a central difference,</p>
<div class="math">
\[u'(t_n) \approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
\thinspace .\]</div>
</div>
</div>
</div>
<div class="section" id="implementation-1">
<span id="vib-impl1"></span><h1>Implementation  (1)<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="making-a-solver-function">
<h2>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h2>
<p>The algorithm from the previous section is readily translated to
a complete Python function for computing (returning)
<span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> and <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>, given the
input <span class="math">\(I\)</span>, <span class="math">\(\omega\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(T\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>A function for plotting the numerical and the exact solution is also
convenient to have:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r--o&#39;</span><span class="p">)</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c"># very fine mesh for u_e</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>
    <span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">title</span><span class="p">(</span><span class="s">&#39;dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">axis</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">])</span>
    <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;vib1.png&#39;</span><span class="p">)</span>
    <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;vib1.pdf&#39;</span><span class="p">)</span>
    <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;vib1.eps&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A corresponding main program calling these functions for a simulation
of a given number of periods (<tt class="docutils literal"><span class="pre">num_periods</span></tt>) may take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Adjusting some of the input parameters on the command line can be
handy. Here is a code segment using the <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> tool in
the <tt class="docutils literal"><span class="pre">argparse</span></tt> module to define option value (<tt class="docutils literal"><span class="pre">--option</span> <span class="pre">value</span></tt>)
pairs on the command line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--w&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--num_periods&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_periods</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">num_periods</span>
</pre></div>
</div>
<p>A typical execution goes like</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python vib_undamped.py --num_periods 20 --dt 0.1</span>
</pre></div>
</div>
</div>
<div class="section" id="verification-1">
<span id="vib-ode1-verify"></span><h2>Verification  (1)<a class="headerlink" href="#verification-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="manual-calculation">
<h3>Manual calculation<a class="headerlink" href="#manual-calculation" title="Permalink to this headline">¶</a></h3>
<p>The simplest type of verification, which is also instructive for understanding
the algorithm, is to compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>
with the aid of a calculator
and make a function for comparing these results with those from the <tt class="docutils literal"><span class="pre">solver</span></tt>
function. We refer to the <tt class="docutils literal"><span class="pre">test_three_steps</span></tt> function in
the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/vib/vib_undamped.py">vib_undamped.py</a>
for details.</p>
</div>
<div class="section" id="testing-very-simple-solutions">
<h3>Testing very simple solutions<a class="headerlink" href="#testing-very-simple-solutions" title="Permalink to this headline">¶</a></h3>
<p>Constructing test problems where the exact solution is constant or linear
helps initial debugging and verification as one expects any reasonable
numerical method to reproduce such solutions to machine
precision.
Second-order accurate methods will often also reproduce a quadratic
solution.
Here <span class="math">\([D_tD_tt^2]^n=2\)</span>, which is the exact result. A solution
<span class="math">\(u=t^2\)</span> leads to <span class="math">\(u''+\omega^2 u=2 + (\omega t)^2\neq 0\)</span>.
We must therefore add a source in the equation:
<span class="math">\(u'' + \omega^2 u = f\)</span> to allow a solution <span class="math">\(u=t^2\)</span> for <span class="math">\(f=(\omega t)^2\)</span>.
By simple insertion we can show that the mesh function <span class="math">\(u^n = t_n^2\)</span> is
also a solution of the discrete equations.
<a class="reference internal" href="#vib-exer-undamped-verify-linquad"><em>Problem 1: Use linear/quadratic functions for verification</em></a>
asks you to carry out all
details with showing that linear and quadratic solutions are solutions
of the discrete equations. Such results are very useful
for debugging and verification.</p>
</div>
<div class="section" id="checking-convergence-rates">
<h3>Checking convergence rates<a class="headerlink" href="#checking-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>Empirical computation of convergence rates, as explained
for a simple <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#computing-convergence-rates">ODE model</a>, yields a good method for
verification. The function below</p>
<blockquote>
<div><ul class="simple">
<li>performs <span class="math">\(m\)</span> simulations with halved time steps: <span class="math">\(2^{-i}\Delta t\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>,</li>
<li>computes the <span class="math">\(L^2\)</span> norm of the error,
<span class="math">\(E=\sqrt{2^{-i}\Delta t\sum_{n=0}^{N_t-1}(u^n-u_{\small\mbox{e}}(t_n))^2}\)</span> in each case,</li>
<li>estimates the convergence rates <span class="math">\(r_i\)</span> based on two consecutive
experiments <span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span> and <span class="math">\((\Delta t_{i}, E_{i})\)</span>,
assuming <span class="math">\(E_i=C\Delta t_i^{r_i}\)</span> and <span class="math">\(E_{i-1}=C\Delta t_{i-1}^{r_i}\)</span>.
From these equations it follows that
<span class="math">\(r_{i-1} = \ln (E_{i-1}/E_i)/\ln (\Delta t_{i-1}/\Delta t_i)\)</span>, for
<span class="math">\(i=1,\ldots,m-1\)</span>.</li>
</ul>
</div></blockquote>
<p>All the implementational details appear below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return m-1 empirical estimates of the convergence rate</span>
<span class="sd">    based on m simulations, where the time step is halved</span>
<span class="sd">    for each simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span><span class="o">/</span><span class="mi">30</span>  <span class="c"># 30 time step per period 2*pi/w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span><span class="o">*</span><span class="n">num_periods</span>
    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">((</span><span class="n">u_e</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">dt_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>The returned <tt class="docutils literal"><span class="pre">r</span></tt> list has its values equal to 2.00, which is in
excellent agreement with what is
expected from the second-order finite difference approximation <span class="math">\([D_tD_tu]^n\)</span>
and other theoretical measures of the error in the numerical method.
The final <tt class="docutils literal"><span class="pre">r[-1]</span></tt> value is a good candidate for a unit test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c"># Accept rate to 1 decimal place</span>
    <span class="n">nt</span><span class="o">.</span><span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code appears in the file <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="long-time-simulations">
<span id="vib-ode1-longseries"></span><h1>Long time simulations<a class="headerlink" href="#long-time-simulations" title="Permalink to this headline">¶</a></h1>
<p>Figure <a class="reference internal" href="#vib-ode1-2dt"><em>Effect of halving the time step</em></a> shows a comparison of the exact and numerical
solution for <span class="math">\(\Delta t=0.1, 0.05\)</span> and <span class="math">\(w=2\pi\)</span>.
From the plot we make the following observations:</p>
<blockquote>
<div><ul class="simple">
<li>The numerical solution seems to have correct amplitude.</li>
<li>There is a phase error which is reduced by reducing the time step.</li>
<li>The total phase error grows with time.</li>
</ul>
</div></blockquote>
<p>By phase error we mean that the peaks of the numerical solution have incorrect
positions compared with the peaks of the exact cosine solution. This
effect can be understood as if also the numerical solution is on
the form <span class="math">\(I\cos\tilde\omega t\)</span>, but where <span class="math">\(\tilde\omega\)</span> is not exactly
equal to <span class="math">\(\omega\)</span>. Later, we shall mathematically
quantify this numerical frequency <span class="math">\(\tilde\omega\)</span>.</p>
<div class="figure" id="vib-ode1-2dt">
<img alt="_images/vib_phase_err11.png" src="_images/vib_phase_err11.png" style="width: 600px;" />
<p class="caption"><em>Effect of halving the time step</em></p>
</div>
<div class="section" id="using-a-moving-plot-window">
<h2>Using a moving plot window<a class="headerlink" href="#using-a-moving-plot-window" title="Permalink to this headline">¶</a></h2>
<p>In vibration problems it is often of interest to investigate the system&#8217;s
behavior over long time intervals. Errors in the phase may then show
up as crucial. Let us investigate long
time series by introducing a moving plot window that can move along with
the <span class="math">\(p\)</span> most recently computed periods of the solution. The
<a class="reference external" href="http://code.google.com/p/scitools">SciTools</a> package contains
a convenient tool for this: <tt class="docutils literal"><span class="pre">MovingPlotWindow</span></tt>. Typing
<tt class="docutils literal"><span class="pre">pydoc</span> <span class="pre">scitools.MovingPlotWindow</span></tt> shows a demo and description of usage.
The function below illustrates the usage and is invoked in the
<tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> code if the number of periods in the simulation exceeds
10:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize u and the exact solution vs t, using a</span>
<span class="sd">    moving plot window and continuous drawing of the</span>
<span class="sd">    curves as they evolve in time.</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">st</span>
    <span class="kn">from</span> <span class="nn">scitools.MovingPlotWindow</span> <span class="kn">import</span> <span class="n">MovingPlotWindow</span>

    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># one period</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">plot_manager</span> <span class="o">=</span> <span class="n">MovingPlotWindow</span><span class="p">(</span>
        <span class="n">window_width</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">yaxis</span><span class="o">=</span><span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
        <span class="n">mode</span><span class="o">=</span><span class="s">&#39;continuous drawing&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">first_index_in_plot</span>
            <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;r-1&#39;</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;b-1&#39;</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">plot_manager</span><span class="o">.</span><span class="n">axis</span><span class="p">(),</span>
                    <span class="n">show</span><span class="o">=</span><span class="ow">not</span> <span class="n">savefig</span><span class="p">)</span> <span class="c"># drop window if savefig</span>
            <span class="k">if</span> <span class="n">savefig</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;tmp_vib</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">n</span>
                <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&#39;making plot file&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">&#39;at t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">plot_manager</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Running</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40</span>
</pre></div>
</div>
<p>makes the simulation last for 40 periods of the cosine function.
With the moving plot window we can follow the numerical and exact
solution as time progresses, and we see from this demo that
the phase error is small in the beginning, but then becomes more
prominent with time. Running <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> with <span class="math">\(\Delta t=0.1\)</span>
clearly shows that the phase errors become significant even earlier
in the time series and destroys the solution.</p>
</div>
<div class="section" id="making-a-movie-file">
<h2>Making a movie file<a class="headerlink" href="#making-a-movie-file" title="Permalink to this headline">¶</a></h2>
<p id="index-10">The <tt class="docutils literal"><span class="pre">visualize_front</span></tt> function stores all the plots in
files whose names are numbered:
<tt class="docutils literal"><span class="pre">tmp_vib0000.png</span></tt>, <tt class="docutils literal"><span class="pre">tmp_vib0001.png</span></tt>, <tt class="docutils literal"><span class="pre">tmp_vib0002.png</span></tt>,
and so on. From these files we may make a movie. The Flash
format is popular,</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; avconv -r 12 -i tmp_vib%04d.png -vcodec flv movie.flv</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">avconv</span></tt> program can be replaced by the <tt class="docutils literal"><span class="pre">ffmpeg</span></tt> program in
the above command if desired.
Other formats can be generated by changing the video codec
and equipping the movie file with the right extension:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Codec and filename</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Flash</td>
<td><tt class="docutils literal"><span class="pre">-vcodec</span> <span class="pre">flv</span> <span class="pre">movie.flv</span></tt></td>
</tr>
<tr class="row-odd"><td>MP4</td>
<td><tt class="docutils literal"><span class="pre">-vcodec</span> <span class="pre">libx64</span> <span class="pre">movie.mp4</span></tt></td>
</tr>
<tr class="row-even"><td>Webm</td>
<td><tt class="docutils literal"><span class="pre">-vcodec</span> <span class="pre">libvpx</span> <span class="pre">movie.webm</span></tt></td>
</tr>
<tr class="row-odd"><td>Ogg</td>
<td><tt class="docutils literal"><span class="pre">-vcodec</span> <span class="pre">libtheora</span> <span class="pre">movie.ogg</span></tt></td>
</tr>
</tbody>
</table>
<p>The movie file can be played by some video player like <tt class="docutils literal"><span class="pre">vlc</span></tt>, <tt class="docutils literal"><span class="pre">mplayer</span></tt>,
<tt class="docutils literal"><span class="pre">gxine</span></tt>, or <tt class="docutils literal"><span class="pre">totem</span></tt>, e.g.,</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; vlc movie.webm</span>
</pre></div>
</div>
<p>A web page can also be used to play the movie. Today&#8217;s standard is
to use the HTML5 <tt class="docutils literal"><span class="pre">video</span></tt> tag:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width=</span><span class="s">&#39;640&#39;</span> <span class="na">height=</span><span class="s">&#39;365&#39;</span> <span class="na">preload=</span><span class="s">&#39;none&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type=</span><span class="s">&#39;video/webm; codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/video&gt;</span>
</pre></div>
</div>
<div class="admonition-caution-number-the-plot-files-correctly admonition">
<p class="first admonition-title">Caution: number the plot files correctly</p>
<p class="last">To ensure that the individual plot frames are shown in correct order,
it is important to number the files with zero-padded numbers
(0000, 0001, 0002, etc.). The printf format <tt class="docutils literal"><span class="pre">%04d</span></tt> specifies an
integer in a field of width 4, padded with zeros from the left.
A simple Unix wildcard file specification like <tt class="docutils literal"><span class="pre">tmp_vib*.png</span></tt>
will then list the frames in the right order. If the numbers in the
filenames were not zero-padded, the frame <tt class="docutils literal"><span class="pre">tmp_vib11.png</span></tt> would appear
before <tt class="docutils literal"><span class="pre">tmp_vib2.png</span></tt> in the movie.</p>
</div>
</div>
<div class="section" id="using-a-line-by-line-ascii-plotter">
<h2>Using a line-by-line ascii plotter<a class="headerlink" href="#using-a-line-by-line-ascii-plotter" title="Permalink to this headline">¶</a></h2>
<p>Plotting functions vertically, line by line, in the terminal window
using ascii characters only is a simple, fast, and convenient
visualization technique for long time series (the time arrow points
downward). The tool
<tt class="docutils literal"><span class="pre">scitools.avplotter.Plotter</span></tt> makes it easy to create such plots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visualize_front_ascii</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot u and the exact solution vs t line by line in a</span>
<span class="sd">    terminal window (only using ascii characters).</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scitools.avplotter</span> <span class="kn">import</span> <span class="n">Plotter</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="s">&#39;+o&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])),</span> \
              <span class="s">&#39;</span><span class="si">%.1f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">))</span>
</pre></div>
</div>
<p>The call <tt class="docutils literal"><span class="pre">p.plot</span></tt> returns a line of text, with the <span class="math">\(t\)</span> axis marked and
a symbol <tt class="docutils literal"><span class="pre">+</span></tt> for the first function (<tt class="docutils literal"><span class="pre">u</span></tt>) and <tt class="docutils literal"><span class="pre">o</span></tt> for the second
function (the exact solution). Here we append this text
a time counter reflecting how many periods the current time point
corresponds to. A typical output (<span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t=0.05\)</span>)
looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre>                         <span class="o">|</span>                       <span class="n">o</span><span class="o">+</span>      <span class="mf">14.0</span>
                         <span class="o">|</span>                      <span class="o">+</span> <span class="n">o</span>      <span class="mf">14.0</span>
                         <span class="o">|</span>                  <span class="o">+</span>    <span class="n">o</span>       <span class="mf">14.1</span>
                         <span class="o">|</span>             <span class="o">+</span>     <span class="n">o</span>           <span class="mf">14.1</span>
                         <span class="o">|</span>     <span class="o">+</span>        <span class="n">o</span>                <span class="mf">14.2</span>
                        <span class="o">+|</span>       <span class="n">o</span>                       <span class="mf">14.2</span>
                <span class="o">+</span>        <span class="o">|</span>                               <span class="mf">14.2</span>
         <span class="o">+</span>       <span class="n">o</span>       <span class="o">|</span>                               <span class="mf">14.3</span>
    <span class="o">+</span>     <span class="n">o</span>              <span class="o">|</span>                               <span class="mf">14.4</span>
 <span class="o">+</span>   <span class="n">o</span>                   <span class="o">|</span>                               <span class="mf">14.4</span>
<span class="o">+</span><span class="n">o</span>                       <span class="o">|</span>                               <span class="mf">14.5</span>
<span class="n">o</span> <span class="o">+</span>                      <span class="o">|</span>                               <span class="mf">14.5</span>
 <span class="n">o</span>    <span class="o">+</span>                  <span class="o">|</span>                               <span class="mf">14.6</span>
     <span class="n">o</span>      <span class="o">+</span>            <span class="o">|</span>                               <span class="mf">14.6</span>
          <span class="n">o</span>        <span class="o">+</span>     <span class="o">|</span>                               <span class="mf">14.7</span>
                 <span class="n">o</span>       <span class="o">|</span> <span class="o">+</span>                             <span class="mf">14.7</span>
                         <span class="o">|</span>        <span class="o">+</span>                      <span class="mf">14.8</span>
                         <span class="o">|</span>       <span class="n">o</span>       <span class="o">+</span>               <span class="mf">14.8</span>
                         <span class="o">|</span>              <span class="n">o</span>     <span class="o">+</span>          <span class="mf">14.9</span>
                         <span class="o">|</span>                   <span class="n">o</span>   <span class="o">+</span>       <span class="mf">14.9</span>
                         <span class="o">|</span>                       <span class="n">o</span><span class="o">+</span>      <span class="mf">15.0</span>
</pre></div>
</div>
</div>
<div class="section" id="empirical-analysis-of-the-solution">
<span id="vib-ode1-empirical"></span><h2>Empirical analysis of the solution<a class="headerlink" href="#empirical-analysis-of-the-solution" title="Permalink to this headline">¶</a></h2>
<p>For oscillating functions like those in Figure <a class="reference internal" href="#vib-ode1-2dt"><em>Effect of halving the time step</em></a> we may
compute the amplitude and frequency (or period) empirically.
That is, we run through the discrete solution points <span class="math">\((t_n, u_n)\)</span> and
find all maxima and minima points. The distance between two consecutive
maxima (or minima) points can be used as estimate of the local period,
while half the difference between the <span class="math">\(u\)</span> value at a maximum and a nearby
minimum gives an estimate of the local amplitude.</p>
<p>The local maxima are the points where</p>
<div class="math">
\[\begin{split}u^{n-1} &lt; u^n &gt; u^{n+1},\quad n=1,\ldots,N_t-1,\end{split}\]</div>
<p>and the local minima are recognized by</p>
<div class="math">
\[\begin{split}u^{n-1} &gt; u^n &lt; u^{n+1},\quad n=1,\ldots,N_t-1
\thinspace .\end{split}\]</div>
<p>In computer code this becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">minima</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">maxima</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">minima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">maxima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span>
</pre></div>
</div>
<p>Note that the returned objects are list of tuples.</p>
<p>Let <span class="math">\((t_i, e_i)\)</span>, <span class="math">\(i=0,\ldots,M-1\)</span>, be the sequence of all
the <span class="math">\(M\)</span> maxima points, where <span class="math">\(t_i\)</span>
is the time value and <span class="math">\(e_i\)</span> the corresponding <span class="math">\(u\)</span> value.
The local period can be defined as <span class="math">\(p_i=t_{i+1}-t_i\)</span>.
With Python syntax this reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">periods</span><span class="p">(</span><span class="n">maxima</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">extrema</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>The list <tt class="docutils literal"><span class="pre">p</span></tt> created by a list comprehension is converted to an array
since we probably want to compute with it, e.g., find the corresponding
frequencies <tt class="docutils literal"><span class="pre">2*pi/p</span></tt>.</p>
<p>Having the minima and the maxima, the local amplitude can be
calculated as the difference between two neighboring minimum and
maximum points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">amplitudes</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="mf">2.0</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">)))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The code segments are found in the file <a class="reference external" href="http://tinyurl.com/jvzzcfn/vib/vib_empirical_analysis.py">vib_empirical_analysis.py</a>.</p>
<p>Visualization of the periods <tt class="docutils literal"><span class="pre">p</span></tt> or the amplitudes <tt class="docutils literal"><span class="pre">a</span></tt>
it is most conveniently done with just a counter
on the horizontal axis, since <tt class="docutils literal"><span class="pre">a[i]</span></tt> and <tt class="docutils literal"><span class="pre">p[i]</span></tt> correspond to
the <span class="math">\(i\)</span>-th amplitude estimate and the <span class="math">\(i\)</span>-th period estimate, respectively.
There is no unique time point associated with either of these estimate
since values at two different time points were used in the
computations.</p>
<p>In the analysis of very long time series, it is advantageous to
compute and plot <tt class="docutils literal"><span class="pre">p</span></tt> and <tt class="docutils literal"><span class="pre">a</span></tt> instead of <span class="math">\(u\)</span> to get an impression of
the development of the oscillations.</p>
</div>
</div>
<div class="section" id="analysis-of-the-numerical-scheme">
<span id="vib-ode1-analysis"></span><h1>Analysis of the numerical scheme<a class="headerlink" href="#analysis-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h1>
<div class="section" id="deriving-an-exact-numerical-solution">
<h2>Deriving an exact numerical solution<a class="headerlink" href="#deriving-an-exact-numerical-solution" title="Permalink to this headline">¶</a></h2>
<p>After having seen the phase error grow with time in the previous
section, we shall now quantify this error through mathematical analysis.  The
key tool in the analysis will be to establish an exact solution of the
discrete equations.  The difference equation <a href="#equation-vib:ode1:step4">(7)</a>
has constant coefficients and is homogeneous. The solution is then of
the form <span class="math">\(u^n=A^n\)</span>, where <span class="math">\(A\)</span> is some number to be determined
(recall that <span class="math">\(n\)</span> in <span class="math">\(u^n\)</span> is a superscript labeling the time level,
while <span class="math">\(n\)</span> in <span class="math">\(A^n\)</span> is an exponent).
With oscillating functions as solutions, the algebra will be
considerably simplified if we write</p>
<div class="math">
\[A=Ie^{i\tilde\omega \Delta t},\]</div>
<p>and solve for the numerical frequency <span class="math">\(\tilde\omega\)</span> rather than
<span class="math">\(A\)</span>. Note that <span class="math">\(i=\sqrt{-1}\)</span> is the imaginary unit. (Using a
complex exponential function gives simpler arithmetics than working
with a sine or cosine function.)
We have</p>
<div class="math">
\[A^n = Ie^{i\tilde\omega \Delta t\, n}=Ie^{i\tilde\omega t} =
I\cos (\tilde\omega t) + iI\sin(\tilde \omega t)
\thinspace .\]</div>
<p>The physically relevant numerical solution can
be taken as the real part of this complex expression.</p>
<p>The calculations goes as</p>
<div class="math">
\[\begin{split}[D_tD_t u]^n &amp;= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\
&amp;= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\
&amp;= I\frac{\exp{(i\tilde\omega(t+\Delta t))} - 2\exp{(i\tilde\omega t)} + \exp{(i\tilde\omega(t-\Delta t))}}{\Delta t^2}\\
&amp;= I\exp{(i\tilde\omega t)}\frac{1}{\Delta t^2}\left(\exp{(i\tilde\omega(\Delta t))} + \exp{(i\tilde\omega(-\Delta t))} - 2\right)\\
&amp;= I\exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\
&amp;= I\exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\
&amp;= -I\exp{(i\tilde\omega t)}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})\end{split}\]</div>
<p>The last line follows from the relation
<span class="math">\(\cos x - 1 = -2\sin^2(x/2)\)</span> (try <tt class="docutils literal"><span class="pre">cos(x)-1</span></tt> in
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see the formula).</p>
<p>The scheme <a href="#equation-vib:ode1:step4">(7)</a>
with <span class="math">\(u^n=Ie^{i\omega\tilde\Delta t\, n}\)</span> inserted now gives</p>
<div class="math">
\[-Ie^{i\tilde\omega t}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
+ \omega^2 Ie^{i\tilde\omega t} = 0,\]</div>
<p>which after dividing by <span class="math">\(Ie^{i\tilde\omega t}\)</span> results in</p>
<div class="math">
\[\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
\thinspace .\]</div>
<p>The first step in solving for the unknown <span class="math">\(\tilde\omega\)</span> is</p>
<div class="math">
\[\sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
\thinspace .\]</div>
<p>Then, taking the square root, applying the inverse sine function, and
multiplying by <span class="math">\(2/\Delta t\)</span>, results in</p>
<div class="math" id="equation-vib:ode1:tildeomega">
<span class="eqno">(10)</span>\[     \tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
     \thinspace .\]</div>
<p>The first observation of <a href="#equation-vib:ode1:tildeomega">(10)</a> tells that
there is a phase error since the numerical frequency <span class="math">\(\tilde\omega\)</span>
never equals the exact frequency <span class="math">\(\omega\)</span>. But how good is
the approximation <a href="#equation-vib:ode1:tildeomega">(10)</a>? That is, what
is the error <span class="math">\(\omega - \tilde\omega\)</span> or <span class="math">\(\tilde\omega/\omega\)</span>?
Taylor series expansion
for small <span class="math">\(\Delta t\)</span> may give an expression that is easier to understand
than the complicated function in <a href="#equation-vib:ode1:tildeomega">(10)</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde</span> <span class="o">=</span> <span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w_tilde</span>
<span class="go">(dt*w + dt**3*w**3/24 + O(dt**4))/dt</span>
</pre></div>
</div>
<p>This means that</p>
<div class="math" id="equation-vib:ode1:tildeomega:series">
<span class="eqno">(11)</span>\[     \tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right) + {\cal O}(\Delta t^3)
     \thinspace .\]</div>
<p>The error in the numerical frequency is of second-order in
<span class="math">\(\Delta t\)</span>, and the error vanishes as <span class="math">\(\Delta t\rightarrow 0\)</span>.
We see that <span class="math">\(\tilde\omega &gt; \omega\)</span> since the term <span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>
and this is by far the biggest term in the series expansion for small
<span class="math">\(\omega\Delta t\)</span>. A numerical frequency that is too large gives an oscillating
curve that oscillates too fast and therefore &#8220;lags behind&#8221; the exact
oscillations, a feature that can be seen in the plots.</p>
<p>Figure <a class="reference internal" href="#vib-ode1-tildeomega-plot"><em>Exact discrete frequency and its second-order series expansion</em></a> plots the discrete frequency
<a href="#equation-vib:ode1:tildeomega">(10)</a>
and its approximation <a href="#equation-vib:ode1:tildeomega:series">(11)</a> for <span class="math">\(\omega =1\)</span> (based
on the program <a class="reference external" href="http://tinyurl.com/jvzzcfn/vib/vib_plot_freq.py">vib_plot_freq.py</a>).
Although <span class="math">\(\tilde\omega\)</span> is a function of <span class="math">\(\Delta t\)</span> in
<a href="#equation-vib:ode1:tildeomega:series">(11)</a>,
it is misleading to think of <span class="math">\(\Delta t\)</span> as the important
discretization parameter. It is the product <span class="math">\(\omega\Delta t\)</span> that is
the key discretization parameter. This quantity reflects the
<em>number of time steps per period</em> of the oscillations.
To see this, we set <span class="math">\(P=N_P\Delta t\)</span>, where <span class="math">\(P\)</span> is the length of
a period, and <span class="math">\(N_P\)</span> is the number of time steps during a period.
Since <span class="math">\(P\)</span> and <span class="math">\(\omega\)</span> are related by <span class="math">\(P=2\pi/\omega\)</span>,
we get that <span class="math">\(\omega\Delta t = 2\pi/N_P\)</span>, which shows that
<span class="math">\(\omega\Delta t\)</span> is directly related to <span class="math">\(N_P\)</span>.</p>
<p>The plot shows
that at least <span class="math">\(N_P\sim 25-30\)</span> points per period are necessary for reasonable
accuracy, but this depends on the length of the simulation (<span class="math">\(T\)</span>) as
the total phase error due to the frequency error grows linearly with time
(see <a class="reference internal" href="#vib-exer-phase-err-growth"><em>Exercise 1: Show linear growth of the phase with time</em></a>).</p>
<div class="figure" id="vib-ode1-tildeomega-plot">
<img alt="_images/discrete_freq1.png" src="_images/discrete_freq1.png" style="width: 400px;" />
<p class="caption"><em>Exact discrete frequency and its second-order series expansion</em></p>
</div>
</div>
<div class="section" id="exact-discrete-solution">
<h2>Exact discrete solution<a class="headerlink" href="#exact-discrete-solution" title="Permalink to this headline">¶</a></h2>
<p>Perhaps more important than the <span class="math">\(\tilde\omega = \omega + {\cal O}(\Delta t^2)\)</span>
result found above is the fact that we have an exact discrete solution of
the problem:</p>
<div class="math" id="equation-vib:ode1:un:exact">
<span class="eqno">(12)</span>\[     u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
     \tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
     \thinspace .\]</div>
<p>We can then compute the error mesh function</p>
<div class="math" id="equation-vib:ode1:en">
<span class="eqno">(13)</span>\[     e^n = u_{\small\mbox{e}}(t_n) - u^n =
     I\cos\left(\omega n\Delta t\right)
     - I\cos\left(\tilde\omega n\Delta t\right) {\thinspace .}\]</div>
<p>In particular, we can use this expression to show <em>convergence</em> of the
numerical scheme, i.e., <span class="math">\(e^n\rightarrow 0\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>.
We have that</p>
<div class="math">
\[\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,\]</div>
<p>by L&#8217;Hopital&#8217;s rule or simply asking
<tt class="docutils literal"><span class="pre">(2/x)*asin(w*x/2)</span> <span class="pre">as</span> <span class="pre">x-&gt;0</span></tt> in <a class="reference external" href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0">WolframAlpha</a>.
Therefore, <span class="math">\(\tilde\omega\rightarrow\omega\)</span>, and the two terms in
<span class="math">\(e^n\)</span> cancel each other in the limit <span class="math">\(\Delta t\rightarrow 0\)</span>.</p>
<p>The error mesh function is ideal for verification purposes
(and you are encouraged to make a test based on <a href="#equation-vib:ode1:un:exact">(12)</a>
in <a class="reference internal" href="#vib-exer-discrete-omega"><em>Exercise 9: Use an exact discrete solution for verification</em></a>).</p>
</div>
<div class="section" id="stability">
<h2>Stability<a class="headerlink" href="#stability" title="Permalink to this headline">¶</a></h2>
<p>Looking at <a href="#equation-vib:ode1:un:exact">(12)</a>, it appears that the numerical
solution has constant and correct amplitude, but an error in the
frequency (phase error). However, there is another error that
is more serious, namely an unstable growing amplitude that can
occur of <span class="math">\(\Delta t\)</span> is too large.</p>
<p>We realize that
a constant amplitude demands
<span class="math">\(\tilde\omega\)</span> to be a real number. A complex <span class="math">\(\tilde\omega\)</span> is
indeed possible if the argument <span class="math">\(x\)</span> of <span class="math">\(\sin^{-1}(x)\)</span> has magnitude
larger than unity: <span class="math">\(|x|&gt;1\)</span> (type <tt class="docutils literal"><span class="pre">asin(x)</span></tt> in <a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see basic properties of <span class="math">\(\sin^{-1} (x)\)</span>).
A complex <span class="math">\(\tilde\omega\)</span> can be written <span class="math">\(\tilde\omega = \tilde\omega_r +
i\tilde\omega_i\)</span>. Since <span class="math">\(\sin^{-1}(x)\)</span> has a <em>negative</em> imaginary part for
<span class="math">\(x&gt;1\)</span>, <span class="math">\(\tilde\omega_i &lt; 0\)</span>, it means that
<span class="math">\(\exp{(i\omega\tilde t)}=\exp{(-\tilde\omega_i t)}\exp{(i\tilde\omega_r t)}\)</span>
will lead to exponential growth in time because
<span class="math">\(\exp{(-\tilde\omega_i t)}\)</span> with <span class="math">\(\tilde\omega_i &lt;0\)</span> has a positive
exponent.</p>
<p id="index-11">We do not tolerate growth in the amplitude and we therefore
have a <em>stability criterion</em> arising from requiring the argument
<span class="math">\(\omega\Delta t/2\)</span> in the inverse sine function to be less than
one:</p>
<div class="math">
\[\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
\Delta t \leq \frac{2}{\omega}
\thinspace .\]</div>
<p>With <span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t &gt; \pi^{-1} = 0.3183098861837907\)</span> will give
growing solutions. Figure <a class="reference internal" href="#vib-ode1-dt-unstable"><em>Growing, unstable solution because of a time step slightly beyond the stability limit</em></a>
displays what happens when <span class="math">\(\Delta t =0.3184\)</span>,
which is slightly above the critical value: <span class="math">\(\Delta t =\pi^{-1} + 9.01\cdot
10^{-5}\)</span>.</p>
<div class="figure" id="vib-ode1-dt-unstable">
<img alt="_images/vib_unstable1.png" src="_images/vib_unstable1.png" style="width: 400px;" />
<p class="caption"><em>Growing, unstable solution because of a time step slightly beyond the stability limit</em></p>
</div>
<div class="admonition-summary admonition">
<p class="first admonition-title">Summary</p>
<p>From the analysis we can draw three important conclusions:</p>
<ol class="last arabic simple">
<li>The key parameter in the formulas is <span class="math">\(p=\omega\Delta t\)</span>.
The period of oscillations is <span class="math">\(P=2\pi/\omega\)</span>, and the
number of time steps per period is <span class="math">\(N_P=P/\Delta t\)</span>.
Therefore, <span class="math">\(p=\omega\Delta t = 2\pi N_P\)</span>, showing that the
critical parameter is the number of time steps per period.
The smallest possible <span class="math">\(N_P\)</span> is 2, showing that <span class="math">\(p\in (0,\pi]\)</span>.</li>
<li>Provided <span class="math">\(p\leq 2\)</span>, the amplitude of the numerical solution is
constant.</li>
<li>The numerical solution exhibits a relative phase error
<span class="math">\(\tilde\omega/\omega \approx 1 + \frac{1}{24}p^2\)</span>.
This error leads to wrongly displaced peaks of the numerical
solution, and the error in peak location grows linearly with time
(see <a class="reference internal" href="#vib-exer-phase-err-growth"><em>Exercise 1: Show linear growth of the phase with time</em></a>).</li>
</ol>
</div>
</div>
</div>
<div class="section" id="alternative-schemes-based-on-1st-order-equations">
<span id="vib-model2x2"></span><h1>Alternative schemes based on 1st-order equations<a class="headerlink" href="#alternative-schemes-based-on-1st-order-equations" title="Permalink to this headline">¶</a></h1>
<p>A standard technique for solving second-order ODEs is
to rewrite them as a system of first-order ODEs and then apply the
vast collection of methods for first-order ODE systems.
Given the second-order ODE problem</p>
<div class="math">
\[u'' + \omega^2 u = 0,\quad u(0)=I,\ u'(0)=0,\]</div>
<p>we introduce the auxiliary variable <span class="math">\(v=u'\)</span> and express the ODE problem
in terms of first-order derivatives of <span class="math">\(u\)</span> and <span class="math">\(v\)</span>:</p>
<div class="math" id="equation-vib:model2x2:ueq">
<span class="eqno">(14)</span>\[     u' = v,\]</div>
<div class="math" id="equation-vib:model2x2:veq">
<span class="eqno">(15)</span>\[     v' = -\omega^2 u\]\[     \thinspace .\]</div>
<p>The initial conditions become <span class="math">\(u(0)=I\)</span> and <span class="math">\(v(0)=0\)</span>.</p>
<div class="section" id="standard-methods-for-1st-order-ode-systems">
<span id="vib-undamped-1stode"></span><h2>Standard methods for 1st-order ODE systems<a class="headerlink" href="#standard-methods-for-1st-order-ode-systems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-forward-euler-scheme">
<h3>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<p>A Forward Euler approximation to our <span class="math">\(2\times 2\)</span> system of ODEs
<a href="#equation-vib:model2x2:ueq">(14)</a>-<a href="#equation-vib:model2x2:veq">(15)</a>
becomes</p>
<div class="math">
\[\lbrack D_t^+ u = v\rbrack^n,
\lbrack D_t^+ v = -\omega^2 u\rbrack^n,\]</div>
<p>or written out,</p>
<div class="math" id="equation-vib:undamped:FE1">
<span class="eqno">(16)</span>\[     u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="equation-vib:undamped:FE2">
<span class="eqno">(17)</span>\[     v^{n+1} = v^n -\Delta t \omega^2 u^n\]\[     \thinspace .\]</div>
<p>Let us briefly compare this Forward Euler method with the
centered difference scheme for the second-order differential
equation. We have from <a href="#equation-vib:undamped:FE1">(16)</a> and
<a href="#equation-vib:undamped:FE2">(17)</a> applied at levels <span class="math">\(n\)</span> and <span class="math">\(n-1\)</span> that</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t v^n = u^n + \Delta t (v^{n-1} -\Delta t \omega^2 u^{n-1}{\thinspace .}\]</div>
<p>Since from <a href="#equation-vib:undamped:FE1">(16)</a></p>
<div class="math">
\[v^{n-1} = \frac{1}{\Delta t}(u^{n}-u^{n-1}),\]</div>
<p>it follows that</p>
<div class="math">
\[u^{n+1} = 2u^n - u^{n-1} -\Delta t^2\omega^2 u^{n-1},\]</div>
<p>which is very close to the centered difference scheme, but
the last term is evaluated at <span class="math">\(t_{n-1}\)</span> instead of <span class="math">\(t_n\)</span>.
This difference is actually crucial for the accuracy of
the Forward Euler method applied to vibration problems.</p>
</div>
<div class="section" id="the-backward-euler-scheme">
<h3>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<p>A Backward Euler approximation the ODE system is equally easy to
write up in the operator notation:</p>
<div class="math">
\[\lbrack D_t^- u = v\rbrack^{n+1},\]</div>
<div class="math">
\[\lbrack D_t^- v = -\omega u\rbrack^{n+1} \thinspace .\]</div>
<p>This becomes a coupled system for <span class="math">\(u^{n+1}\)</span> and <span class="math">\(v^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1} - \Delta t v^{n+1} = u^{n},\]</div>
<div class="math">
\[v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}
\thinspace .\]</div>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<h3>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h3>
<p>The Crank-Nicolson scheme takes this form in the operator notation:</p>
<div class="math">
\[\lbrack D_t u = \overline{v}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t v = -\omega \overline{u}^t\rbrack^{n+\frac{1}{2}}
\thinspace .\]</div>
<p>Writing the equations out shows that is also a coupled system:</p>
<div class="math">
\[u^{n+1} - \frac{1}{2}\Delta t v^{n+1} = u^{n} + \frac{1}{2}\Delta t v^{n},\]</div>
<div class="math">
\[v^{n+1} + \frac{1}{2}\Delta t \omega^2 u^{n+1} = v^{n}
- \frac{1}{2}\Delta t \omega^2 u^{n}
\thinspace .\]</div>
</div>
<div class="section" id="comparison-of-schemes">
<h3>Comparison of schemes<a class="headerlink" href="#comparison-of-schemes" title="Permalink to this headline">¶</a></h3>
<p>We can easily compare methods like the ones above (and many more!)
with the aid of the
<a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> package. Below is
a sketch of the code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">u</span>  <span class="c"># u is array of length 2 holding our [u, v]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">run_solvers_and_plot</span><span class="p">(</span><span class="n">solvers</span><span class="p">,</span> <span class="n">timesteps_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                         <span class="n">num_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># one period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>There is quite some more code dealing with plots also, and we refer
to the source file <a class="reference external" href="http://tinyurl.com/jvzzcfn/vib/vib_odespy.py">vib_odespy.py</a>
for details. Observe that keyword arguments in <tt class="docutils literal"><span class="pre">f(u,t,w=1)</span></tt> can
be supplied through a solver parameter <tt class="docutils literal"><span class="pre">f_kwargs</span></tt> (dictionary).</p>
<p>Specification of the Forward Euler, Backward Euler, and
Crank-Nicolson schemes is done like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">ForwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="c"># Implicit methods must use Newton solver to converge</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">CrankNicolson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">vib_odespy.py</span></tt>
program makes two plots of the computed solutions with the various
methods in the <tt class="docutils literal"><span class="pre">solvers</span></tt> list: one plot with <span class="math">\(u(t)\)</span> versus <span class="math">\(t\)</span>, and
one <em>phase plane plot</em> where <span class="math">\(v\)</span> is plotted against <span class="math">\(u\)</span>.
That is, the phase plane plot is the curve <span class="math">\((u(t),v(t))\)</span> parameterized
by <span class="math">\(t\)</span>. Analytically, <span class="math">\(u=I\cos(\omega t)\)</span> and <span class="math">\(v=u'=-\omega I\sin(\omega t)\)</span>.
The exact curve <span class="math">\((u(t),v(t))\)</span> is therefore an ellipse, which often
looks like a circle in a plot if the axes are automatically scaled. The
important feature, however, is that exact curve <span class="math">\((u(t),v(t))\)</span> is
closed and repeats itself for every period. Not all numerical schemes
are capable to do that, meaning that the amplitude instead shrinks or
grows with time.</p>
<p>The Forward Euler scheme in Figure
<a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><em>Comparison of classical schemes in the phase plane</em></a> has a pronounced spiral
curve, pointing to the fact that the amplitude steadily grows, which
is also evident in Figure <a class="reference internal" href="#vib-ode1-1st-odespy-theta"><em>Comparison of classical schemes</em></a>.
The Backward Euler scheme has a similar feature, except that the
spriral goes inward and the amplitude is significantly damped.  The
changing amplitude and the sprial form decreases with decreasing time
step.  The Crank-Nicolson scheme looks much more
accurate.  In fact, these plots tell that the Forward and Backward
Euler schemes are not suitable for solving our ODEs with oscillating
solutions.</p>
<div class="figure" id="vib-ode1-1st-odespy-theta-phaseplane">
<img alt="_images/vib_theta_1_pp1.png" src="_images/vib_theta_1_pp1.png" style="width: 600px;" />
<p class="caption"><em>Comparison of classical schemes in the phase plane</em></p>
</div>
<div class="figure" id="vib-ode1-1st-odespy-theta">
<img alt="_images/vib_theta_1_u1.png" src="_images/vib_theta_1_u1.png" style="width: 600px;" />
<p class="caption"><em>Comparison of classical schemes</em></p>
</div>
<p>We may run two popular standard methods for first-order ODEs, the 2nd-
and 4th-order Runge-Kutta methods, to see how they perform. Figures
<a class="reference internal" href="#vib-ode1-1st-odespy-rk-phaseplane"><em>Comparison of Runge-Kutta schemes in the phase plane</em></a> and
<a class="reference internal" href="#vib-ode1-1st-odespy-rk"><em>Comparison of Runge-Kutta schemes</em></a> show the solutions with larger <span class="math">\(\Delta
t\)</span> values than what was used in the previous two plots.</p>
<div class="figure" id="vib-ode1-1st-odespy-rk-phaseplane">
<img alt="_images/vib_RK_1_pp1.png" src="_images/vib_RK_1_pp1.png" style="width: 600px;" />
<p class="caption"><em>Comparison of Runge-Kutta schemes in the phase plane</em></p>
</div>
<div class="figure" id="vib-ode1-1st-odespy-rk">
<img alt="_images/vib_RK_1_u1.png" src="_images/vib_RK_1_u1.png" style="width: 600px;" />
<p class="caption"><em>Comparison of Runge-Kutta schemes</em></p>
</div>
<p>The visual impression is that the
4th-order Runge-Kutta method is very accurate, under all circumstances
in these tests, and the 2nd-order scheme suffer from amplitude errors
unless the time step is very small.</p>
<p>The corresponding results for the Crank-Nicolson scheme
are shown in Figures <a class="reference internal" href="#vib-ode1-1st-odespy-cn-long-phaseplane"><em>Long-time behavior of the Crank-Nicolson scheme in the phase plane</em></a> and
<a class="reference internal" href="#vib-ode1-1st-odespy-cn-long"><em>Long-time behavior of the Crank-Nicolson scheme</em></a>. It is clear that the Crank-Nicolson
scheme outperforms
the 2nd-order Runge-Kutta method. Both schemes have the same order
of accuracy <span class="math">\({{\cal O}(\Delta t^2)}\)</span>, but their differences in the accuracy
that matters in
a real physical application is very clearly pronounced in this example.
<a class="reference internal" href="#vib-exer-undamped-odespy"><em>Exercise 11: Investigate the amplitude errors of many solvers</em></a> invites you to investigate
how</p>
<div class="figure" id="vib-ode1-1st-odespy-cn-long-phaseplane">
<img alt="_images/vib_CN_10_pp1.png" src="_images/vib_CN_10_pp1.png" style="width: 600px;" />
<p class="caption"><em>Long-time behavior of the Crank-Nicolson scheme in the phase plane</em></p>
</div>
<div class="figure" id="vib-ode1-1st-odespy-cn-long">
<img alt="_images/vib_CN_10_u1.png" src="_images/vib_CN_10_u1.png" style="width: 600px;" />
<p class="caption"><em>Long-time behavior of the Crank-Nicolson scheme</em></p>
</div>
</div>
</div>
<div class="section" id="enegy-considerations">
<span id="vib-model1-energy"></span><h2>Enegy considerations<a class="headerlink" href="#enegy-considerations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-12"></span><p id="index-13">The observations of various methods in the previous section can be
better interpreted if we compute an expression reflecting
the <em>energy of the system</em>.</p>
<div class="section" id="derivation-of-the-energy-expression">
<h3>Derivation of the energy expression<a class="headerlink" href="#derivation-of-the-energy-expression" title="Permalink to this headline">¶</a></h3>
<p>We starting multiplying</p>
<div class="math">
\[u'' + \omega^2 u = 0,\]</div>
<p>by <span class="math">\(u'\)</span> and integrating from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>:</p>
<div class="math">
\[\int_0^T u''u' dt + \int_0^T\omega^2 u u' dt = 0{\thinspace .}\]</div>
<p>Observing that</p>
<div class="math">
\[u''u' = \frac{d}{dt}\frac{1}{2}(u')^2,\quad uu' = \frac{d}{dt} \frac{1}{2}u^2,\]</div>
<p>we get</p>
<div class="math">
\[\int_0^T (\frac{d}{dt}\frac{1}{2}(u')^2 + \frac{d}{dt} \frac{1}{2}\omega^2u^2)dt = E(T) - E(0),\]</div>
<p>where we have introduced the energy measure <span class="math">\(E(t)\)</span></p>
<div class="math" id="equation-vib:model1:energy:balance1">
<span class="eqno">(18)</span>\[     E(t) = \frac{1}{2}(u')^2 + \frac{1}{2}\omega^2u^2{\thinspace .}\]</div>
<p>The important result from this derivation is that the total energy
is constant:</p>
<div class="math">
\[E(t) = \hbox{const}{\thinspace .}\]</div>
<div class="admonition-remark-on-the-energy-expression admonition">
<p class="first admonition-title">Remark on the energy expression</p>
<p>The quantity <span class="math">\(E(t)\)</span> derived above is physically not the energy of a
vibrating mechanical system, but the energy per unit mass. To see this,
we start with Newton&#8217;s second law <span class="math">\(F=ma\)</span> (<span class="math">\(F\)</span> is the sum of forces, <span class="math">\(m\)</span>
is the mass of the system, and <span class="math">\(a\)</span> is the acceleration).
The displacement <span class="math">\(u\)</span> is related to <span class="math">\(a\)</span> through
<span class="math">\(a=u''\)</span>. With a spring force as the only force we have <span class="math">\(F=-ku\)</span>, where
<span class="math">\(k\)</span> is a spring constant measuring the stiffness of the spring.
Newton&#8217;s second law then implies the differential equation</p>
<div class="math">
\[-ku = mu''\quad\Rightarrow mu'' + ku = 0{\thinspace .}\]</div>
<p>This equation of motion can be turned into an energy balance equation
by finding the work done by each term during a time interval <span class="math">\([0,T]\)</span>.
To this end, we multiply the equation by <span class="math">\(du=u'dt\)</span> and integrate:</p>
<div class="math">
\[\int_0^T muu'dt + \int_0^T kuu'dt = 0{\thinspace .}\]</div>
<p>The result is</p>
<div class="math">
\[E(t) = E_k(t) + E_p(t) = 0,\]</div>
<p>where</p>
<div class="math" id="equation-vib:model1:energy:kinetic">
<span class="eqno">(19)</span>\[     E_k(t) = \frac{1}{}2mv^2,\quad v=u',\]</div>
<p>is the <em>kinetic energy</em> of the system,</p>
<div class="math" id="equation-vib:model1:energy:potential">
<span class="eqno">(20)</span>\[     E_p(t) = \frac{1}{2}ku^2\]</div>
<p>is the <em>potential energy</em>, and the sum <span class="math">\(E(t)\)</span> is the total energy.
The derivation demonstrates the famous energy principle that any
change in the kinetic energy is due to a change in potential energy
and vice versa.</p>
<p class="last">The equation <span class="math">\(mu''+ku=0\)</span> can be divided by <span class="math">\(m\)</span> and written as
<span class="math">\(u'' + \omega^2u=0\)</span> for <span class="math">\(\omega=\sqrt{k/m}\)</span>. The energy expression
<span class="math">\(E(t)=\frac{1}{2}(u')^2 + \frac{1}{2}\omega^2u^2\)</span> derived earlier is then
simply the
true physical total
energy <span class="math">\(\frac{1}{2}m(u')^2 + \frac{1}{2}k^2u^2\)</span> divided by <span class="math">\(m\)</span>, i.e.,
total energy per unit mass.</p>
</div>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Analytically, we have <span class="math">\(u(t)=I\cos\omega t\)</span>, if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u'(0)=0\)</span>,
so we can easily check that the evolution of the energy <span class="math">\(E(t)\)</span> is
constant:</p>
<div class="math">
\[E(t) = \frac{1}{2}I^2 (-\omega\sin\omega t)^2
+ \frac{1}{2}\omega^2 I^2 \cos^2\omega t
= \frac{1}{2}\omega^2 (\sin^2\omega t + \cos^2\omega t) = \frac{1}{2}\omega^2
{\thinspace .}\]</div>
</div>
<div class="section" id="discrete-total-energy">
<h3>Discrete total energy<a class="headerlink" href="#discrete-total-energy" title="Permalink to this headline">¶</a></h3>
<p>The total energy <span class="math">\(E(t)\)</span> can be computed as soon as
<span class="math">\(u^n\)</span> is available. Using <span class="math">\((u')^n\approx [D_{2t} u^n]\)</span> we have</p>
<div class="math">
\[E^n = \frac{1}{2}([D_{2t} u]^n)^2 + \frac{1}{2}\omega^2 (u^n)^2{\thinspace .}\]</div>
<p>The errors involved in <span class="math">\(E^n\)</span> get a contribution <span class="math">\({{\cal O}(\Delta t^2)}\)</span>
from the difference approximation of <span class="math">\(u'\)</span> and a contribution from
the numerical error in <span class="math">\(u^n\)</span>. With a second-order scheme for computing
<span class="math">\(u^n\)</span>, the overall error in <span class="math">\(E^n\)</span> is expected to be <span class="math">\({{\cal O}(\Delta t^2)}\)</span>.</p>
</div>
<div class="section" id="an-error-measure-based-on-total-energy">
<h3>An error measure based on total energy<a class="headerlink" href="#an-error-measure-based-on-total-energy" title="Permalink to this headline">¶</a></h3>
<p>The error in total energy, as a mesh function, can be computed by</p>
<div class="math">
\[e_E^n = \frac{1}{2}\left(\frac{u^{n+1}-u^{n-1}}{2\Delta t}\right)^2
+ \frac{1}{2}\omega^2 (u^n)^2 - E(0),
\quad n=1,\ldots,N_t-1,\]</div>
<p>where</p>
<div class="math">
\[E(0) = \frac{1}{2}V^2 + \frac{1}{2}\omega^2I^2,\]</div>
<p>if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u'(0)=V\)</span>.
A useful norm can be the maximum absolute value of <span class="math">\(e_E^n\)</span>:</p>
<div class="math">
\[\begin{split}||e_E^n||_{\ell^\infty} = \max_{1\leq n &lt;N_t} |e_E^n|{\thinspace .}\end{split}\]</div>
<p>The corresponding Python implementation takes the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># import numpy as np and compute u, t</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">E0</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">V</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">**</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">**</span><span class="mi">2</span>
<span class="n">e_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">E0</span>
<span class="n">e_E_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e_E</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>The convergence rates of the quantity <tt class="docutils literal"><span class="pre">e_E_norm</span></tt> can be used for verification.
The value of <tt class="docutils literal"><span class="pre">e_E_norm</span></tt> is also useful for comparing schemes
through their ability to preserve energy. Below is a table demonstrating
the error in total energy for various schemes. We clearly see that
the Crank-Nicolson and 4th-order Runge-Kutta schemes are superior to
the 2nd-order Runge-Kutta method and even more superior to the Forward
and Backward Euler schemes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.113\cdot 10^{2}\)</span></td>
</tr>
<tr class="row-odd"><td>Forward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(3.312\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-even"><td>Backward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.683\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.231\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(8.401\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.637\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.389\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-odd"><td>Crank-Nicolson</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(2.411\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(2.387\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(6.476\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(3.389\)</span></td>
</tr>
<tr class="row-odd"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.389\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(3.686\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(6.928\cdot 10^{-1}\)</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="the-euler-cromer-method">
<span id="vib-model2x2-eulercromer"></span><h2>The Euler-Cromer method<a class="headerlink" href="#the-euler-cromer-method" title="Permalink to this headline">¶</a></h2>
<p>While the 4th-order Runge-Kutta method and the a centered Crank-Nicolson scheme
work well for the first-order formulation of the vibration model, both
were inferior to the straightforward centered difference
scheme for the second-order
equation <span class="math">\(u''+\omega^2u=0\)</span>. However, there is a similarly successful
scheme available for the first-order system <span class="math">\(u'=v\)</span>, <span class="math">\(v'=-\omega^2u\)</span>,
to be presented next.</p>
<div class="section" id="forward-backward-discretization">
<span id="index-14"></span><h3>Forward-backward discretization<a class="headerlink" href="#forward-backward-discretization" title="Permalink to this headline">¶</a></h3>
<p>The idea is to apply a Forward Euler discretization to the first
equation and a Backward Euler discretization to the second. In operator
notation this is stated as</p>
<div class="math">
\[\lbrack D_t^+u = v\rbrack^n,\]</div>
<div class="math">
\[\lbrack D_t^-v = -\omega u\rbrack^{n+1}
\thinspace .\]</div>
<p>We can write out the formulas and collect the unknowns on the left-hand side:</p>
<div class="math" id="equation-vib:model2x2:EulerCromer:ueq1">
<span class="eqno">(21)</span>\[     u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="equation-vib:model2x2:EulerCromer:veq1">
<span class="eqno">(22)</span>\[     v^{n+1} = v^n -\Delta t \omega^2u^{n+1}\]\[     \thinspace .\]</div>
<p>We realize that <span class="math">\(u^{n+1}\)</span> can be computed from
<a href="#equation-vib:model2x2:EulerCromer:ueq1">(21)</a> and then <span class="math">\(v^{n+1}\)</span> from
<a href="#equation-vib:model2x2:EulerCromer:veq1">(22)</a> using the recently computed value
<span class="math">\(u^{n+1}\)</span> on the right-hand side.</p>
<p>The scheme
<a href="#equation-vib:model2x2:EulerCromer:ueq1">(21)</a>-<a href="#equation-vib:model2x2:EulerCromer:veq1">(22)</a>
goes under several names: Forward-backward scheme, <a class="reference external" href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">Semi-implicit Euler method</a>, symplectic
Euler, semi-explicit Euler,
Newton-Stormer-Verlet,
and Euler-Cromer.
We shall stick to the latter name.
Since both time discretizations are based on first-order difference
approximation, one may think that the scheme is only of first-order,
but this is not true: the use of a forward and then a backward
difference make errors cancel so that the overall error in the scheme
is <span class="math">\({{\cal O}(\Delta t^2)}\)</span>. This is explaned below.</p>
</div>
<div class="section" id="equivalence-with-the-scheme-for-the-second-order-ode">
<h3>Equivalence with the scheme for the second-order ODE<a class="headerlink" href="#equivalence-with-the-scheme-for-the-second-order-ode" title="Permalink to this headline">¶</a></h3>
<p>We may eliminate the <span class="math">\(v^n\)</span> variable from
<a href="#equation-vib:model2x2:EulerCromer:ueq1">(21)</a>-<a href="#equation-vib:model2x2:EulerCromer:veq1">(22)</a>.
From <a href="#equation-vib:model2x2:EulerCromer:veq1">(22)</a> we have
<span class="math">\(v^n = v^{n-1} - \Delta t \omega^2u^{n}\)</span>, which can be inserted
in <a href="#equation-vib:model2x2:EulerCromer:ueq1">(21)</a> to yield</p>
<div class="math" id="equation-vib:model2x2:EulerCromer:elim1">
<span class="eqno">(23)</span>\[     u^{n+1} = u^n + \Delta t v^{n-1} - \Delta t^2 \omega^2u^{n} .\]</div>
<p>The <span class="math">\(v^{n-1}\)</span> quantity can be expressed by <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span>
using <a href="#equation-vib:model2x2:EulerCromer:ueq1">(21)</a>:</p>
<div class="math">
\[v^{n-1} = \frac{u^n - u^{n-1}}{\Delta t},\]</div>
<p>and when this is inserted in <a href="#equation-vib:model2x2:EulerCromer:elim1">(23)</a> we get</p>
<div class="math">
\[u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},\]</div>
<p>which is nothing but the centered scheme <a href="#equation-vib:ode1:step4">(7)</a>!
The previous analysis of this scheme then also applies to the Euler-Cromer
method. That is, the amplitude is constant, given that the stability
criterion is fulfilled, but there is always a phase error
<a href="#equation-vib:ode1:tildeomega:series">(11)</a>.</p>
<p>The initial condition <span class="math">\(u'=0\)</span> means <span class="math">\(u'=v=0\)</span>. Then <span class="math">\(v^0=0\)</span>, and
<a href="#equation-vib:model2x2:EulerCromer:ueq1">(21)</a> implies <span class="math">\(u^1=u^0\)</span>, while
<a href="#equation-vib:model2x2:EulerCromer:veq1">(22)</a> says <span class="math">\(v^1=-\omega^2 u^0\)</span>.
This approximation, <span class="math">\(u^1=u^0\)</span>,
corresponds to a first-order Forward Euler discretization
of the initial condition <span class="math">\(u'(0)=0\)</span>: <span class="math">\([D_t^+ u = 0]^0\)</span>.
Therefore, the Euler-Cromer scheme will start out differently
and not exactly reproduce the solution of <a href="#equation-vib:ode1:step4">(7)</a>.</p>
</div>
</div>
<div class="section" id="the-euler-cromer-scheme-on-a-staggered-mesh">
<span id="vib-model2x2-staggered"></span><h2>The Euler-Cromer scheme on a staggered mesh<a class="headerlink" href="#the-euler-cromer-scheme-on-a-staggered-mesh" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-15"></span><p id="index-16">The Forward and Backward Euler schemes used in the Euler-Cromer
method are both non-symmetric, but their combination yields a
symmetric method since the resulting scheme is equivalent with
a centered (symmetric) difference scheme for <span class="math">\(u''+\omega^2u=0\)</span>.
The symmetric nature of the Euler-Cromer scheme is much more evident if we
introduce a <em>staggered mesh</em> in time where <span class="math">\(u\)</span> is sought at
integer time points <span class="math">\(t_n\)</span> and <span class="math">\(v\)</span> is sought at <span class="math">\(t_{n+1/2}\)</span>
<em>between</em> two <span class="math">\(u\)</span> points.
The unknowns are then <span class="math">\(u^1, v^{3/2}, u^2, v^{5/2}\)</span>, and so on.
We typically use the notation
<span class="math">\(u^n\)</span> and <span class="math">\(v^{n+1/2}\)</span> for the two unknown mesh functions.</p>
<p>On a staggered mesh it is natural to
use centered difference approximations, expressed
in operator notation as</p>
<div class="math">
\[\lbrack D_t u = v\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t v = -\omega u\rbrack^{n+1}
\thinspace .\]</div>
<p>Writing out the formulas gives</p>
<div class="math" id="equation-vib:model2x2:EulerCromer:ueq1s">
<span class="eqno">(24)</span>\[     u^{n+1} = u^{n} + \Delta t v^{n+\frac{1}{2}},\]</div>
<div class="math" id="equation-vib:model2x2:EulerCromer:veq1s">
<span class="eqno">(25)</span>\[     v^{n+\frac{3}{2}} = v^{n+\frac{1}{2}} -\Delta t \omega^2u^{n+1}\]\[     \thinspace .\]</div>
<p>Of esthetic reasons one often writes these equations at the
previous time level to replace the <span class="math">\(\frac{3}{2}\)</span> by <span class="math">\(\frac{1}{2}\)</span> in the
left-most term in the last equation,</p>
<div class="math" id="equation-vib:model2x2:EulerCromer:ueq1s2">
<span class="eqno">(26)</span>\[     u^{n} = u^{n-1} + \Delta t v^{n-\frac{1}{2}},\]</div>
<div class="math" id="equation-vib:model2x2:EulerCromer:veq1s2">
<span class="eqno">(27)</span>\[     v^{n+\frac{1}{2}} = v^{n-\frac{1}{2}} -\Delta t \omega^2u^{n}\]\[     \thinspace .\]</div>
<p>Such a rewrite is only mathematical cosmetics. The important thing
is that this centered scheme has exactly the same computational
structure as the forward-backward scheme. We shall use the names
<em>forward-backward Euler-Cromer</em> and <em>staggered Euler-Cromer</em>
to distinguish the two schemes.</p>
<p>We can eliminate the <span class="math">\(v\)</span>
values and get back the centered scheme based on the second-order
differential equation, so all these three schemes are equivalent.
However, they differ somewhat in the treatment of the initial
conditions.</p>
<p>Suppose we have <span class="math">\(u(0)=I\)</span> and <span class="math">\(u'(0)=v(0)=0\)</span> as mathematical
initial conditions. This means <span class="math">\(u^0=I\)</span> and</p>
<div class="math">
\[v(0)\approx \frac{1}{2}(v^{-\frac{1}{2}} + v^{\frac{1}{2}}) = 0,
\quad\Rightarrow\quad v^{-\frac{1}{2}} =- v^{\frac{1}{2}}{\thinspace .}\]</div>
<p>Using the discretized equation <a href="#equation-vib:model2x2:EulerCromer:veq1s2">(27)</a> for
<span class="math">\(n=0\)</span> yields</p>
<div class="math">
\[v^{\frac{1}{2}} = v^{-\frac{1}{2}} -\Delta t\omega^2 I,\]</div>
<p>and eliminating <span class="math">\(v^{-\frac{1}{2}} =- v^{\frac{1}{2}}\)</span>
results in <span class="math">\(v^{\frac{1}{2}} = -\frac{1}{2}\Delta t\omega^2I\)</span> and</p>
<div class="math">
\[u^1 = u^0 - \frac{1}{2}\Delta t^2\omega^2 I,\]</div>
<p>which is exactly the same equation for <span class="math">\(u^1\)</span> as we had in the
centered scheme based on the second-order differential equation
(and hence corresponds to a centered difference approximation of
the initial condition for <span class="math">\(u'(0)\)</span>).
The conclusion is that a staggered mesh is fully equivalent with
that scheme, while the forward-backward version gives a slight
deviation in the computation of <span class="math">\(u^1\)</span>.</p>
</div>
<div class="section" id="implementation-of-the-scheme-on-a-staggered-mesh">
<h2>Implementation of the scheme on a staggered mesh<a class="headerlink" href="#implementation-of-the-scheme-on-a-staggered-mesh" title="Permalink to this headline">¶</a></h2>
<p>To summarize the formulas, the initial conditions are</p>
<div class="math" id="equation-vib:model2x2:EulerCromer:u0s2">
<span class="eqno">(28)</span>\[     u^0 = I,\]</div>
<div class="math" id="equation-vib:model2x2:EulerCromer:v0s2">
<span class="eqno">(29)</span>\[     v^{\frac{1}{2}} = \frac{1}{2}\Delta t\omega^2I {\thinspace .}\]</div>
<p>We then realize that for <span class="math">\(n=1,2,\ldots\)</span>, <span class="math">\(u^{n}\)</span> can be computed from
<a href="#equation-vib:model2x2:EulerCromer:ueq1s2">(26)</a> and then <span class="math">\(v^{n+1/2}\)</span> from
<a href="#equation-vib:model2x2:EulerCromer:veq1s2">(27)</a> using the recently computed value
<span class="math">\(u^{n}\)</span> on the right-hand side.</p>
<p><em>NOT FINISHED.</em> .. implement the staggered scheme</p>
</div>
</div>
<div class="section" id="generalization-damping-nonlinear-spring-and-external-excitation">
<span id="vib-model2"></span><h1>Generalization: damping, nonlinear spring, and external excitation<a class="headerlink" href="#generalization-damping-nonlinear-spring-and-external-excitation" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-17"></span><span class="target" id="index-18"></span><p id="index-19">We shall now generalize the simple model problem from
the section <a class="reference internal" href="#vib-model1"><em>Finite difference discretization</em></a> to include a possibly nonlinear damping term <span class="math">\(f(u')\)</span>,
a possibly nonlinear spring (or restoring) force <span class="math">\(s(u)\)</span>, and
some external excitation <span class="math">\(F(t)\)</span>:</p>
<div class="math" id="equation-vib:ode2">
<span class="eqno">(30)</span>\[     mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T]
     \thinspace .\]</div>
<p>We have also included a possibly nonzero initial value of <span class="math">\(u'(0)\)</span>.
The parameters <span class="math">\(m\)</span>, <span class="math">\(f(u')\)</span>, <span class="math">\(s(u)\)</span>, <span class="math">\(F(t)\)</span>, <span class="math">\(I\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(T\)</span> are
input data.</p>
<p>There are two main types of damping (friction) forces: linear <span class="math">\(f(u')=bu\)</span>, or
quadratic <span class="math">\(f(u')=bu'|u'|\)</span>. Spring systems often feature linear
damping, while air resistance usually gives rise to quadratic damping.
Spring forces are often linear: <span class="math">\(s(u)=cu\)</span>, but nonlinear versions
are also common, the most famous is the gravity force on a pendulum
that acts as a spring with <span class="math">\(s(u)\sim \sin(u)\)</span>.</p>
<div class="section" id="a-centered-scheme-for-linear-damping">
<span id="vib-ode2-fdm-flin"></span><h2>A centered scheme for linear damping<a class="headerlink" href="#a-centered-scheme-for-linear-damping" title="Permalink to this headline">¶</a></h2>
<p>Sampling <a href="#equation-vib:ode2">(30)</a> at a mesh point <span class="math">\(t_n\)</span>, replacing
<span class="math">\(u''(t_n)\)</span> by <span class="math">\([D_tD_tu]^n\)</span>, and <span class="math">\(u'(t_n)\)</span> by <span class="math">\([D_{2t}u]^n\)</span> results
in the discretization</p>
<div class="math">
\[[mD_tD_t u + f(D_{2t}u) + s(u) = F]^n,\]</div>
<p>which written out means</p>
<div class="math" id="equation-vib:ode2:step3b">
<span class="eqno">(31)</span>\[     m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     + f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n,\]</div>
<p>where <span class="math">\(F^n\)</span> as usual means <span class="math">\(F(t)\)</span> evaluated at <span class="math">\(t=t_n\)</span>.
Solving <a href="#equation-vib:ode2:step3b">(31)</a> with respect to the unknown
<span class="math">\(u^{n+1}\)</span> gives a problem: the <span class="math">\(u^{n+1}\)</span> inside the <span class="math">\(f\)</span> function
makes the equation <em>nonlinear</em> unless <span class="math">\(f(u')\)</span> is a linear function,
<span class="math">\(f(u')=bu'\)</span>. For now we shall assume that <span class="math">\(f\)</span> is linear in <span class="math">\(u'\)</span>.
Then</p>
<div class="math" id="equation-vib:ode2:step3b2">
<span class="eqno">(32)</span>\[     m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     + b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + s(u^n) = F^n,\]</div>
<p>which gives an explicit formula for <span class="math">\(u\)</span> at each
new time level:</p>
<div class="math" id="equation-vib:ode2:step4">
<span class="eqno">(33)</span>\[     u^{n+1} = \left(2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
     \Delta t^2(F^n - s(u^n))
     \right)(m + \frac{b}{2}\Delta t)^{-1}\]\[     \thinspace .\]</div>
<p>For the first time step we need to discretize <span class="math">\(u'(0)=V\)</span>
as <span class="math">\([D_{2t}u = V]^0\)</span> and combine
with <a href="#equation-vib:ode2:step4">(33)</a> for <span class="math">\(n=0\)</span>. The discretized initial condition
leads to</p>
<div class="math" id="equation-vib:ode2:ic:du">
<span class="eqno">(34)</span>\[     u^{-1} = u^{1} - 2\Delta t V,\]</div>
<p>which inserted in <a href="#equation-vib:ode2:step4">(33)</a> for <span class="math">\(n=0\)</span> gives an equation
that can be solved for
<span class="math">\(u^1\)</span>:</p>
<div class="math" id="equation-vib:ode2:step4b">
<span class="eqno">(35)</span>\[     u^1 = u^0 + \Delta t\, V
     + \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
     \thinspace .\]</div>
</div>
<div class="section" id="a-centered-scheme-for-quadratic-damping">
<span id="vib-ode2-fdm-fquad"></span><h2>A centered scheme for quadratic damping<a class="headerlink" href="#a-centered-scheme-for-quadratic-damping" title="Permalink to this headline">¶</a></h2>
<p>When <span class="math">\(f(u')=bu'|u'|\)</span>, we get a quadratic equation for <span class="math">\(u^{n+1}\)</span>
in <a href="#equation-vib:ode2:step3b">(31)</a>. This equation can straightforwardly
be solved, but we can also avoid the nonlinearity by
performing an approximation that is within
other numerical errors that we have already committed by replacing
derivatives with finite differences.</p>
<p id="index-20">The idea is to reconsider <a href="#equation-vib:ode2">(30)</a> and only replace
<span class="math">\(u''\)</span> by <span class="math">\(D_tD_tu\)</span>, giving</p>
<div class="math" id="equation-vib:ode2:quad:idea1">
<span class="eqno">(36)</span>\[     [mD_tD_t u + bu'|u'| + s(u) = F]^n,\]</div>
<p>Here, <span class="math">\(u'|u'|\)</span> is to be computed at time <span class="math">\(t_n\)</span>. We can introduce
a <em>geometric mean</em>, defined by</p>
<div class="math">
\[(w^2)^n \approx w^{n-1/2}w^{n+1/2},\]</div>
<p>for some quantity <span class="math">\(w\)</span> depending on time. The error in the geometric mean
approximation is <span class="math">\({{\cal O}(\Delta t^2)}\)</span>, the same as in the
approximation <span class="math">\(u''\approx D_tD_tu\)</span>. With <span class="math">\(w=u'\)</span> it follows
that</p>
<div class="math">
\[[u'|u'|]^n \approx u'(t_n+\frac{1}{2})|u'(t_n-\frac{1}{2})|{\thinspace .}\]</div>
<p>The next step is to approximate
<span class="math">\(u'\)</span> at <span class="math">\(t_{n\pm 1/2}\)</span>, but here a centered difference can be used:</p>
<div class="math" id="equation-vib:ode2:quad:idea2">
<span class="eqno">(37)</span>\[     u'(t_{n+1/2})\approx [D_t u]^{n+1/2},\quad u'(t_{n-1/2})\approx [D_t u]^{n-1/2}
     \thinspace .\]</div>
<p>We then get</p>
<div class="math">
\[[u'|u'|]^n
\approx [D_tu]^{n+1/2}[|D_tu|]^{n-1/2} = \frac{u^{n+1}-u^n}{\Delta t}
\frac{|u^n-u^{n-1}|}{\Delta t}
\thinspace .\]</div>
<p>The counterpart to <a href="#equation-vib:ode2:step3b">(31)</a> is then</p>
<div class="math" id="equation-vib:ode2:step3b:quad">
<span class="eqno">(38)</span>\[     m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     + b\frac{u^{n+1}-u^n}{\Delta t}\frac{|u^n-u^{n-1}|}{\Delta t}
     + s(u^n) = F^n,\]</div>
<p>which is linear in <span class="math">\(u^{n+1}\)</span>. Therefore, we can easily solve
with respect to <span class="math">\(u^{n+1}\)</span> and achieve
the explicit updating formula</p>
<div class="math">
\[u^{n+1} =  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \nonumber\]</div>
<div class="math" id="equation-vib:ode2:step4:quad">
<span class="eqno">(39)</span>\[      \qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - s(u^n))
     \right)
     \thinspace .\]</div>
<p>For <span class="math">\(n=0\)</span> we run into some trouble: inserting <a href="#equation-vib:ode2:ic:du">(34)</a>
in <a href="#equation-vib:ode2:step4:quad">(39)</a> results in a complicated nonlinear
equation for <span class="math">\(u^1\)</span>. By thinking differently about the problem we can
get away with the nonlinearity (again). We have for <span class="math">\(n=0\)</span> that
<span class="math">\(b[u'|u'|]^0 = bV|V|\)</span>. Using this value in <a href="#equation-vib:ode2:quad:idea1">(36)</a>
gives</p>
<div class="math">
\[[mD_tD_t u + bV|V| + s(u) = F]^0
\thinspace .\]</div>
<p>Writing this equation out and using <a href="#equation-vib:ode2:ic:du">(34)</a> gives</p>
<div class="math" id="equation-vib:ode2:step4b:quad">
<span class="eqno">(40)</span>\[     u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - s(u^0) + F^0\right)
     \thinspace .\]</div>
</div>
<div class="section" id="implementation-2">
<span id="vib-ode2-solver"></span><h2>Implementation  (2)<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h2>
<p>The algorithm is very similar to the undamped case. The difference is
basically a question of different formulas for <span class="math">\(u^1\)</span> and
<span class="math">\(u^{n+1}\)</span>. This is actually quite remarkable. The equation
<a href="#equation-vib:ode2">(30)</a> is normally impossible to solve by pen and paper, but
possible for some special choices of <span class="math">\(F\)</span>, <span class="math">\(s\)</span>, and <span class="math">\(f\)</span>. On the
contrary, the nonlinear generalized model <a href="#equation-vib:ode2">(30)</a> versus the
simple undamped model does not make much sense when we solve the
problem numerically!</p>
<p>The computational algorithm is a slight variation of the one
in the section <a class="reference internal" href="#vib-ode1-fdm"><em>A centered finite difference scheme</em></a>:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a href="#equation-vib:ode2:step4b">(35)</a> if linear
damping or <a href="#equation-vib:ode2:step4b:quad">(40)</a> if quadratic damping</li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>compute <span class="math">\(u^{n+1}\)</span> from <a href="#equation-vib:ode2:step4">(33)</a> if linear
damping or <a href="#equation-vib:ode2:step4:quad">(39)</a> if quadratic damping</li>
</ol>
</div></blockquote>
</div></blockquote>
<p>Modifying the <tt class="docutils literal"><span class="pre">solver</span></tt> function for the undamped case is fairly
easy, the big difference being many more terms and if tests on
the type of damping:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve m*u&#39;&#39; + f(u&#39;) + s(u) = F(t) for t in (0,T],</span>
<span class="sd">    u(0)=I and u&#39;(0)=V,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    If damping is &#39;linear&#39;, f(u&#39;)=b*u, while if damping is</span>
<span class="sd">    &#39;quadratic&#39;, f(u&#39;)=b*u&#39;*abs(u&#39;).</span>
<span class="sd">    F(t) and s(u) are Python functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c"># avoid integer div.</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;quadratic&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
               <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                      <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                      <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span>\
                      <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
</div>
<div class="section" id="verification-2">
<span id="vib-ode2-verify"></span><h2>Verification  (2)<a class="headerlink" href="#verification-2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="constant-solution">
<h3>Constant solution<a class="headerlink" href="#constant-solution" title="Permalink to this headline">¶</a></h3>
<p>For debugging and initial verification, a constant solution is often
very useful. We choose <span class="math">\(u_{\small\mbox{e}}(t)=I\)</span>, which implies <span class="math">\(V=0\)</span>.
Inserted in the ODE, we get
<span class="math">\(F(t)=s(I)\)</span> for any choice of <span class="math">\(f\)</span>. Since the discrete derivative
of a constant vanishes (in particular, <span class="math">\([D_{2t}I]^n=0\)</span>,
<span class="math">\([D_tI]^n=0\)</span>, and <span class="math">\([D_tD_t I]^n=0\)</span>), the constant solution also fulfills
the discrete equations. The constant should therefore be reproduced
to machine precision.</p>
</div>
<div class="section" id="linear-solution">
<h3>Linear solution<a class="headerlink" href="#linear-solution" title="Permalink to this headline">¶</a></h3>
<p>Now we choose a linear solution: <span class="math">\(u_{\small\mbox{e}} = ct + d\)</span>. The initial condition
<span class="math">\(u(0)=I\)</span> implies <span class="math">\(d=I\)</span>, and <span class="math">\(u'(0)=V\)</span> forces <span class="math">\(c\)</span> to be <span class="math">\(V\)</span>.
Inserting <span class="math">\(u_{\small\mbox{e}}=Vt+I\)</span> in the ODE with linear damping results in</p>
<div class="math">
\[0 + bV + s(Vt+I) = F(t),\]</div>
<p>while quadratic damping requires the source term</p>
<div class="math">
\[0 + b|V|V + s(Vt+I) = F(t){\thinspace .}\]</div>
<p>Since the finite difference approximations used to compute <span class="math">\(u'\)</span> all
are exact for a linear function, it turns out that the linear <span class="math">\(u_{\small\mbox{e}}\)</span>
is also a solution of the discrete equations.
<a class="reference internal" href="#vib-exer-verify-gen-linear"><em>Exercise 8: Use linear/quadratic functions for verification</em></a> asks you to carry out
all the details.</p>
</div>
<div class="section" id="quadratic-solution">
<h3>Quadratic solution<a class="headerlink" href="#quadratic-solution" title="Permalink to this headline">¶</a></h3>
<p>Choosing <span class="math">\(u_{\small\mbox{e}} = bt^2 + Vt + I\)</span>, with <span class="math">\(b\)</span> arbitrary,
fulfills the initial conditions and
fits the ODE if <span class="math">\(F\)</span> is adjusted properly. The solution also solves
the discrete equations with linear damping. However, this quadratic
polynomial in <span class="math">\(t\)</span> does not fulfill the discrete equations in case
of quadratic damping, because the geometric mean used in the approximation
of this term introduces an error.
Doing <a class="reference internal" href="#vib-exer-verify-gen-linear"><em>Exercise 8: Use linear/quadratic functions for verification</em></a> will reveal
the details. One can fit <span class="math">\(F^n\)</span> in the discrete equations such that
the quadratic polynomial is reproduced by the numerical method (to
machine precision).</p>
</div>
</div>
<div class="section" id="visualization">
<span id="vib-ode2-viz"></span><h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p>The functions for visualizations differ significantly from
those in the undamped case in the <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> program because
we in the present general case do not have an exact solution to
include in the plots. Moreover, we have no good estimate of
the periods of the oscillations as there will be one period
determined by the system parameters, essentially the
approximate frequency <span class="math">\(\sqrt{s'(0)/m}\)</span> for linear <span class="math">\(s\)</span> and small damping,
and one period dictated by <span class="math">\(F(t)\)</span> in case the excitation is periodic.
This is, however,
nothing that the program can depend on or make use of.
Therefore, the user has to specify <span class="math">\(T\)</span> and the window width
in case of a plot that moves with the graph and shows
the most recent parts of it in long time simulations.</p>
<p>The <a class="reference external" href="http://tinyurl.com/jvzzcfn/vib/vib.py">vib.py</a> code
contains several functions for analyzing the time series signal
and for visualizing the solutions.</p>
</div>
<div class="section" id="user-interface">
<span id="vib-ode2-ui"></span><h2>User interface<a class="headerlink" href="#user-interface" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-21"></span><p id="index-22">The <tt class="docutils literal"><span class="pre">main</span></tt> function has substantial changes from
the <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> code since we need to
specify the new data <span class="math">\(c\)</span>, <span class="math">\(s(u)\)</span>, and <span class="math">\(F(t)\)</span>.  In addition, we must
set <span class="math">\(T\)</span> and the plot window width (instead of the number of periods we
want to simulate as in <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt>). To figure out whether we
can use one plot for the whole time series or if we should follow the
most recent part of <span class="math">\(u\)</span>, we can use the <tt class="docutils literal"><span class="pre">plot_empricial_freq_and_amplitude</span></tt>
function&#8217;s estimate of the number of local maxima. This number is now
returned from the function and used in <tt class="docutils literal"><span class="pre">main</span></tt> to decide on the
visualization technique.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--V&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--m&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--c&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--s&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--F&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--T&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">140</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--damping&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--window_width&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--savefig&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">StringFunction</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">damping</span> <span class="o">=</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">window_width</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">savefig</span><span class="p">,</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">damping</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="n">empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_periods</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>
        <span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">)</span>
    <span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The program <tt class="docutils literal"><span class="pre">vib.py</span></tt> contains
the above code snippets and can solve the model problem
<a href="#equation-vib:ode2">(30)</a>. As a demo of <tt class="docutils literal"><span class="pre">vib.py</span></tt>, we consider the case
<span class="math">\(I=1\)</span>, <span class="math">\(V=0\)</span>, <span class="math">\(m=1\)</span>, <span class="math">\(c=0.03\)</span>, <span class="math">\(s(u)=\sin(u)\)</span>, <span class="math">\(F(t)=3\cos(4t)\)</span>,
<span class="math">\(\Delta t = 0.05\)</span>, and <span class="math">\(T=140\)</span>. The relevant command to run is</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">Terminal&gt; python vib.py --s &#39;sin(u)&#39; --F &#39;3*cos(4*t)&#39; --c 0.03</span>
</pre></div>
</div>
<p>This results in a <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/mov-vib/vib_generalized_dt0.05/index.html">moving window following the function</a> on the screen.
Figure <a class="reference internal" href="#vib-ode2-fig-demo"><em>Damped oscillator excited by a sinusoidal function</em></a> shows a part of the time series.</p>
<div class="figure" id="vib-ode2-fig-demo">
<img alt="_images/vib_gen_demo1.png" src="_images/vib_gen_demo1.png" style="width: 600px;" />
<p class="caption"><em>Damped oscillator excited by a sinusoidal function</em></p>
</div>
</div>
<div class="section" id="an-euler-cromer-scheme-for-the-generalized-model">
<span id="vib-ode2-staggered"></span><h2>An Euler-Cromer scheme for the generalized model<a class="headerlink" href="#an-euler-cromer-scheme-for-the-generalized-model" title="Permalink to this headline">¶</a></h2>
<p>The model</p>
<div class="math">
\[mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T],\]</div>
<p>can be rewritten as a first-order ODE system</p>
<div class="math" id="equation-vib:ode2:staggered:ueq">
<span class="eqno">(41)</span>\[     u' = v,\]</div>
<div class="math" id="equation-vib:ode2:staggered:veq">
<span class="eqno">(42)</span>\[     v' = m^{-1}\left(F(t) - f(v) - s(u)\right){\thinspace .}\]</div>
<p>It is natural to introduce a staggered mesh (see the section <a class="reference internal" href="#vib-model2x2-staggered"><em>The Euler-Cromer scheme on a staggered mesh</em></a>) and seek <span class="math">\(u\)</span> at mesh points <span class="math">\(t_n\)</span> (the numerical value is
denoted by <span class="math">\(u^n\)</span>) and <span class="math">\(v\)</span> between mesh points at <span class="math">\(t_{n+1/2}\)</span> (the numerical
value is denoted by <span class="math">\(v^{n+1/2}\)</span>).
A centered difference approximation to <a href="#equation-vib:ode2:staggered:ueq">(41)</a>-<a href="#equation-vib:ode2:staggered:veq">(42)</a> can then be written in operator notation as</p>
<div class="math" id="equation-vib:ode2:staggered:dueq">
<span class="eqno">(43)</span>\[     \lbrack D_t u = v\rbrack^{n-1/2},\]</div>
<div class="math" id="equation-vib:ode2:staggered:dveq">
<span class="eqno">(44)</span>\[     \lbrack D_tv = m^{-1}\left(F(t) - f(v) - s(u)\right)\rbrack^n{\thinspace .}\]</div>
<p>Written out,</p>
<div class="math" id="equation-vib:ode2:staggered:dueq2">
<span class="eqno">(45)</span>\[     \frac{u^n - u^{n-1}}{\Delta t} = v^{n-\frac{1}{2}},\]</div>
<div class="math" id="equation-vib:ode2:staggered:dveq2">
<span class="eqno">(46)</span>\[     \frac{v^{n+\frac{1}{2}} - v^{n-\frac{1}{2}}}{\Delta t}
     = m^{-1}\left(F^n - f(v^n) - s(u^n)\right){\thinspace .}\]</div>
<p>With linear damping, <span class="math">\(f(v)=bv\)</span>, we can use an arithmetic mean
for <span class="math">\(f(v^n)\)</span>: <span class="math">\(f(v^n)\approx = \frac{1}{2}(f(v^{n-1/2}) +
f(v^{n+1/2}))\)</span>. The system
<a href="#equation-vib:ode2:staggered:dueq2">(45)</a>-<a href="#equation-vib:ode2:staggered:dveq2">(46)</a>
can then be solved with respect to the unknowns <span class="math">\(u^n\)</span> and <span class="math">\(v^{n+1/2}\)</span>:</p>
<div class="math" id="equation-vib:ode2:staggered:u:scheme:lin">
<span class="eqno">(47)</span>\[     u^n  = u^{n-1} + {\Delta t}v^{n-\frac{1}{2}},\]</div>
<div class="math" id="equation-vib:ode2:staggered:v:scheme:lin">
<span class="eqno">(48)</span>\[     v^{n+\frac{1}{2}} = \left(1 + \frac{b}{2m}\Delta t\right)^{-1}\left(
     v^{n-\frac{1}{2}} + {\Delta t}
     m^{-1}\left(F^n - \frac{1}{2}f(v^{n-\frac{1}{2}}) - s(u^n)\right)\right){\thinspace .}\]</div>
<p>In case of quadratic damping, <span class="math">\(f(v)=b|v|v\)</span>, we can use a geometric mean:
<span class="math">\(f(v^n)\approx b|v^{n-1/2}|v^{n+1/2}\)</span>. Inserting this approximation
in <a href="#equation-vib:ode2:staggered:dueq2">(45)</a>-<a href="#equation-vib:ode2:staggered:dveq2">(46)</a> and
solving for the unknowns <span class="math">\(u^n\)</span> and <span class="math">\(v^{n+1/2}\)</span> results in</p>
<div class="math" id="equation-vib:ode2:staggered:u:scheme:quad">
<span class="eqno">(49)</span>\[     u^n  = u^{n-1} + {\Delta t}v^{n-\frac{1}{2}},\]</div>
<div class="math" id="equation-vib:ode2:staggered:v:scheme:quad">
<span class="eqno">(50)</span>\[     v^{n+\frac{1}{2}} = (1 + \frac{b}{m}|v^{n-1/2}|\Delta t)^{-1}\left(
     v^{n-\frac{1}{2}} + {\Delta t}
     m^{-1}\left(F^n - s(u^n)\right)\right){\thinspace .}\]</div>
<p>The initial conditions can be derived as in
the section <a class="reference internal" href="#vib-model2x2-staggered"><em>The Euler-Cromer scheme on a staggered mesh</em></a>. Assuming the general conditions
<span class="math">\(u(0)=I\)</span> and <span class="math">\(u'(0)=V\)</span>, we can repeat the derivation and arrive at</p>
<div class="math" id="equation-vib:ode2:staggered:u0">
<span class="eqno">(51)</span>\[     u^0 = I,\]</div>
<div class="math" id="equation-vib:ode2:staggered:v0">
<span class="eqno">(52)</span>\[     v^{\frac{1}{2}} = V - \frac{1}{2}\Delta t\omega^2I
     {\thinspace .}\]</div>
</div>
</div>
<div class="section" id="exercises-and-problems">
<h1>Exercises and Problems<a class="headerlink" href="#exercises-and-problems" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-1-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-undamped-verify-linquad"></span><h2>Problem 1: Use linear/quadratic functions for verification<a class="headerlink" href="#problem-1-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h2>
<p>Consider the ODE problem</p>
<div class="math">
\[u'+\omega^2u=f(t), \quad u(0)=I,\ u'(0)=V,\ t\in(0,T]{\thinspace .}\]</div>
<p>Discretize this equation according to
<span class="math">\([D_tD_t u + \omega^2 u = f]^n\)</span>.</p>
<p><em>a)</em> Derive the equation for the
first time step (<span class="math">\(u^1\)</span>).</p>
<p><em>b)</em> For verification purposes,
we use the method of manufactured solutions (MMS) with the
choice of <span class="math">\(u_{\small\mbox{e}}(x,t)= ct+d\)</span>.
Find restrictions on <span class="math">\(c\)</span> and <span class="math">\(d\)</span> from
the initial conditions. Compute the corresponding source term <span class="math">\(f\)</span> by term.
Show that <span class="math">\([D_tD_t t]^n=0\)</span> and use the fact
that the <span class="math">\(D_tD_t\)</span> operator is linear,
<span class="math">\([D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0\)</span>, to show that
<span class="math">\(u_{\small\mbox{e}}\)</span> is also a perfect solution of the discrete equations.</p>
<p><em>c)</em> Use <tt class="docutils literal"><span class="pre">sympy</span></tt> to do the symbolic calculations above. Here is a
sketch of the program <tt class="docutils literal"><span class="pre">vib_undamped_verify_mms.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
<span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;V t I w dt&#39;</span><span class="p">)</span>  <span class="c"># global symbols</span>
<span class="n">f</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># global variable for the source term in the ODE</span>

<span class="k">def</span> <span class="nf">ode_lhs</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return left-hand side of ODE: u&#39;&#39; + w**2*u.</span>
<span class="sd">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return chosen linear exact solution.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sm</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sm</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linear</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;=== Testing linear exact solution ===&#39;</span>
    <span class="k">print</span> <span class="s">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s">, u&#39;(0)=</span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sm</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u_e</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c"># Method of manufactured solution requires fitting f</span>
    <span class="k">global</span> <span class="n">f</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">ode_lhs</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>

    <span class="c"># Residual in discrete equations (should be 0)</span>
    <span class="k">print</span> <span class="s">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u_e</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">linear</span><span class="p">()</span>
</pre></div>
</div>
<p>Fill in the various functions such that the calls in the <tt class="docutils literal"><span class="pre">linear</span></tt>
function works.</p>
<p><em>d)</em> The purpose now is to choose a quadratic function
<span class="math">\(u_{\small\mbox{e}} = bt^2 + ct + d\)</span> as exact solution. Extend the <tt class="docutils literal"><span class="pre">sympy</span></tt>
code above with a function <tt class="docutils literal"><span class="pre">quadratic</span></tt> that computes the
right source term <tt class="docutils literal"><span class="pre">f</span></tt> and evaluates the residual
in the two types of finite difference equations.</p>
<p><em>e)</em> Implement a <tt class="docutils literal"><span class="pre">solver</span></tt> function for computing the numerical
solution of this problem.</p>
<p><em>f)</em> Write a nose test for checking that the quadratic solution
is computed to correctly (too machine precision, but the
round-off errors accumulate and increase with <span class="math">\(T\)</span>) by the <tt class="docutils literal"><span class="pre">solver</span></tt>
function.</p>
<p>Filenames: <tt class="docutils literal"><span class="pre">vib_undamped_verify_mms.pdf</span></tt>, <tt class="docutils literal"><span class="pre">vib_undamped_verify_mms.py</span></tt>.</p>
</div>
<div class="section" id="exercise-1-show-linear-growth-of-the-phase-with-time">
<span id="vib-exer-phase-err-growth"></span><h2>Exercise 1: Show linear growth of the phase with time<a class="headerlink" href="#exercise-1-show-linear-growth-of-the-phase-with-time" title="Permalink to this headline">¶</a></h2>
<p>Consider an exact solution <span class="math">\(I\cos (\omega t)\)</span> and an
approximation <span class="math">\(I\cos(\tilde\omega t)\)</span>.
Define the phase error as time lag between the peak <span class="math">\(I\)</span>
in the exact solution and the corresponding peak in the approximation
after <span class="math">\(m\)</span> periods of oscillations. Show that this phase error
is linear in <span class="math">\(m\)</span>.
Filename: <tt class="docutils literal"><span class="pre">vib_phase_error_growth.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-2-improve-the-accuracy-by-adjusting-the-frequency">
<span id="vib-exer-w-adjust"></span><h2>Exercise 2: Improve the accuracy by adjusting the frequency<a class="headerlink" href="#exercise-2-improve-the-accuracy-by-adjusting-the-frequency" title="Permalink to this headline">¶</a></h2>
<p>According to <a href="#equation-vib:ode1:tildeomega:series">(11)</a>, the numerical
frequency deviates from the exact frequency by a (dominating) amount
<span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>. Replace the <tt class="docutils literal"><span class="pre">w</span></tt> parameter in the algorithm
in the <tt class="docutils literal"><span class="pre">solver</span></tt> function in <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> by <tt class="docutils literal"><span class="pre">w*(1</span> <span class="pre">-</span>
<span class="pre">(1./24)*w**2*dt**2</span></tt> and test how this adjustment in the numerical
algorithm improves the accuracy (use <span class="math">\(\Delta t =0.1\)</span> and simulate
for 80 periods, with and without adjustment of <span class="math">\(\omega\)</span>).</p>
<p>Filename: <tt class="docutils literal"><span class="pre">vib_adjust_w.py</span></tt>.</p>
</div>
<div class="section" id="exercise-3-see-if-adaptive-methods-improve-the-phase-error">
<span id="vib-exer-undamped-adaptive"></span><h2>Exercise 3: See if adaptive methods improve the phase error<a class="headerlink" href="#exercise-3-see-if-adaptive-methods-improve-the-phase-error" title="Permalink to this headline">¶</a></h2>
<p>Adaptive methods for solving ODEs aim at adjusting <span class="math">\(\Delta t\)</span> such
that the error is within a user-prescribed tolerance. Implement the
equation <span class="math">\(u''+u=0\)</span> in the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a>
software. Use the example <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/._part0007_main_decay.html#example-adaptive-runge-kutta-methods">on adaptive
schemes</a>
in <a class="reference internal" href="#ref1">[Ref1]</a>.  Run the scheme with a very low
tolerance (say <span class="math">\(10^{-14}\)</span>) and for a long time, check the number of
time points in the solver&#8217;s mesh (<tt class="docutils literal"><span class="pre">len(solver.t_all)</span></tt>), and compare
the phase error with that produced by the simple finite difference
method from the section <a class="reference internal" href="#vib-ode1-fdm"><em>A centered finite difference scheme</em></a> with the same number of (equally
spaced) mesh points. The question is whether it pays off to use an
adaptive solver or if equally many points with a simple method gives
about the same accuracy.
Filename: <tt class="docutils literal"><span class="pre">vib_undamped_adaptive.py</span></tt>.</p>
</div>
<div class="section" id="exercise-4-use-a-taylor-polynomial-to-compute">
<span id="vib-exer-step4b-alt"></span><h2>Exercise 4: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span><a class="headerlink" href="#exercise-4-use-a-taylor-polynomial-to-compute" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to the derivation of <a href="#equation-vib:ode1:step4b">(8)</a> for
computing <span class="math">\(u^1\)</span>, one can use a Taylor polynomial with three terms
for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u(t_1) \approx u(0) + u'(0)\Delta t + \frac{1}{2}u''(0)\Delta t^2\]</div>
<p>With <span class="math">\(u''=-\omega^2 u\)</span> and <span class="math">\(u'(0)=0\)</span>, show that this method also leads to
<a href="#equation-vib:ode1:step4b">(8)</a>. Generalize the condition on <span class="math">\(u'(0)\)</span> to
be <span class="math">\(u'(0)=V\)</span> and compute <span class="math">\(u^1\)</span> in this case with both methods.
Filename: <tt class="docutils literal"><span class="pre">vib_first_step.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-5-find-the-minimal-resolution-of-an-oscillatory-function">
<span id="vib-exer-wdt-limit"></span><h2>Exercise 5: Find the minimal resolution of an oscillatory function<a class="headerlink" href="#exercise-5-find-the-minimal-resolution-of-an-oscillatory-function" title="Permalink to this headline">¶</a></h2>
<p>Sketch the function on a given mesh which has the highest possible
frequency. That is, this oscillatory &#8220;cos-like&#8221; function has its
maxima and minima at every two grid points.  Find an expression for
the frequency of this function, and use the result to find the largest
relevant value of <span class="math">\(\omega\Delta t\)</span> when <span class="math">\(\omega\)</span> is the frequency
of an oscillating function and <span class="math">\(\Delta t\)</span> is the mesh spacing.
Filename: <tt class="docutils literal"><span class="pre">vib_largest_wdt.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-6-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">
<span id="vib-exer-fd-exp-plot"></span><h2>Exercise 6: Visualize the accuracy of finite differences for a cosine function<a class="headerlink" href="#exercise-6-visualize-the-accuracy-of-finite-differences-for-a-cosine-function" title="Permalink to this headline">¶</a></h2>
<p>We introduce the error fraction</p>
<div class="math">
\[E = \frac{[D_tD_t u]^n}{u''(t_n)}\]</div>
<p>to measure the error in the finite difference approximation <span class="math">\(D_tD_tu\)</span> to
<span class="math">\(u''\)</span>.
Compute <span class="math">\(E\)</span>
for the specific choice of a cosine/sine function of the
form <span class="math">\(u=\exp{(i\omega t)}\)</span> and show that</p>
<div class="math">
\[E = \left(\frac{2}{\omega\Delta t}\right)^2
\sin^2(\frac{\tilde\omega\Delta t}{2})
\thinspace .\]</div>
<p>Plot <span class="math">\(E\)</span> as a function of <span class="math">\(p=\omega\Delta t\)</span>. The relevant
values of <span class="math">\(p\)</span> are <span class="math">\([0,\pi]\)</span> (see <a class="reference internal" href="#vib-exer-wdt-limit"><em>Exercise 5: Find the minimal resolution of an oscillatory function</em></a>
for why <span class="math">\(p&gt;\pi\)</span> does not make sense).
The deviation of the curve from unity visualizes the error in the
approximation. Also expand <span class="math">\(E\)</span> as a Taylor polynomial in <span class="math">\(p\)</span> up to
fourth degree (use, e.g., <tt class="docutils literal"><span class="pre">sympy</span></tt>).
Filename: <tt class="docutils literal"><span class="pre">vib_plot_fd_exp_error.py</span></tt>.</p>
</div>
<div class="section" id="exercise-7-verify-convergence-rates-of-the-error-in-energy">
<span id="vib-exer-energy-convrate"></span><h2>Exercise 7: verify convergence rates of the error in energy<a class="headerlink" href="#exercise-7-verify-convergence-rates-of-the-error-in-energy" title="Permalink to this headline">¶</a></h2>
<p>We consider the ODE problem <span class="math">\(u'' + \omega^2u=0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u'(0)=V\)</span>,
for <span class="math">\(t\in (0,T]\)</span>. The total energy of the solution
<span class="math">\(E(t)=\frac{1}{2}(u')^2 + \frac{1}{2}\omega^2 u^2\)</span> should stay
constant.
The error in energy can be computed as explained in
the section <a class="reference internal" href="#vib-model1-energy"><em>Enegy considerations</em></a>.</p>
<p>Make a nose test in a file <tt class="docutils literal"><span class="pre">test_error_conv.py</span></tt>, where code
from <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> is important, but <tt class="docutils literal"><span class="pre">convergence_rates</span></tt>
and <tt class="docutils literal"><span class="pre">test_convergence_rates</span></tt> are modified to also incorporate
computations of the error in energy and the convergence
rate of this error. The expected rate is 2.
Filename: <tt class="docutils literal"><span class="pre">test_error_conv.py</span></tt>.</p>
</div>
<div class="section" id="exercise-8-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-verify-gen-linear"></span><h2>Exercise 8: Use linear/quadratic functions for verification<a class="headerlink" href="#exercise-8-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h2>
<p>This exercise is a generalization of <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><em>Problem 1: Use linear/quadratic functions for verification</em></a> to the extended model problem
<a href="#equation-vib:ode2">(30)</a> where the damping term is either linear or quadratic.
Solve the various subproblems and see how the results and problem
settings change with the generalized ODE in case of linear or
quadratic damping. By modifying the code from <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><em>Problem 1: Use linear/quadratic functions for verification</em></a>, <tt class="docutils literal"><span class="pre">sympy</span></tt> will do most
of the work required to analyze the generalized problem.
Filename: <tt class="docutils literal"><span class="pre">vib_verify_mms.py</span></tt>.</p>
</div>
<div class="section" id="exercise-9-use-an-exact-discrete-solution-for-verification">
<span id="vib-exer-discrete-omega"></span><h2>Exercise 9: Use an exact discrete solution for verification<a class="headerlink" href="#exercise-9-use-an-exact-discrete-solution-for-verification" title="Permalink to this headline">¶</a></h2>
<p>Write a nose test function in a separate file
that employs the exact discrete solution
<a href="#equation-vib:ode1:un:exact">(12)</a> to verify the implementation of the
<tt class="docutils literal"><span class="pre">solver</span></tt> function in the file <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt>.
Just import <tt class="docutils literal"><span class="pre">solver</span></tt> and make functions for the exact discrete
solution and the nose test.
Filename: <tt class="docutils literal"><span class="pre">vib_verify_discrete_omega.py</span></tt>.</p>
</div>
<div class="section" id="exercise-10-use-analytical-solution-for-convergence-rate-tests">
<span id="vib-exer-conv-rate"></span><h2>Exercise 10: Use analytical solution for convergence rate tests<a class="headerlink" href="#exercise-10-use-analytical-solution-for-convergence-rate-tests" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this exercise is to perform convergence tests of
the problem <a href="#equation-vib:ode2">(30)</a> when <span class="math">\(s(u)=\omega^2u\)</span> and <span class="math">\(F(t)=A\sin\phi t\)</span>.
Find the complete analytical solution to the problem in this case
(most textbooks on mechanics list the various elements you need to
write down the exact solution).
Modify the <tt class="docutils literal"><span class="pre">convergence_rate</span></tt> function from the <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt>
program to perform experiments with the extended model.
Verify that the error is of order <span class="math">\(\Delta t^2\)</span>.
Filename: <tt class="docutils literal"><span class="pre">vib_conv_rate.py</span></tt>.</p>
</div>
<div class="section" id="exercise-11-investigate-the-amplitude-errors-of-many-solvers">
<span id="vib-exer-undamped-odespy"></span><h2>Exercise 11: Investigate the amplitude errors of many solvers<a class="headerlink" href="#exercise-11-investigate-the-amplitude-errors-of-many-solvers" title="Permalink to this headline">¶</a></h2>
<p>Use the program <tt class="docutils literal"><span class="pre">vib_odespy.py</span></tt> from the section <a class="reference internal" href="#vib-undamped-1stode"><em>Standard methods for 1st-order ODE systems</em></a>
and the amplitude estimation from the <tt class="docutils literal"><span class="pre">amplitudes</span></tt> function
in the <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> file (see the section <a class="reference internal" href="#vib-ode1-empirical"><em>Empirical analysis of the solution</em></a>)
to investigate how well famous methods for 1st-order ODEs
can preserve the amplitude of <span class="math">\(u\)</span> in undamped oscillations.
Test, for example, the 3rd- and 4th-order Runge-Kutta methods
(<tt class="docutils literal"><span class="pre">RK3</span></tt>, <tt class="docutils literal"><span class="pre">RK4</span></tt>), the Crank-Nicolson method (<tt class="docutils literal"><span class="pre">CrankNicolson</span></tt>),
the 2nd- and 3rd-order Adams-Bashforth methods (<tt class="docutils literal"><span class="pre">AdamsBashforth2</span></tt>,
<tt class="docutils literal"><span class="pre">AdamsBashforth3</span></tt>), and a 2nd-order Backwards scheme (<tt class="docutils literal"><span class="pre">Backward2Step</span></tt>).
The relevant governing equations are listed in
the section <em class="xref std std-ref">vib:model2x2:ueq</em>.
Filename: <tt class="docutils literal"><span class="pre">vib_amplitude_errors.py</span></tt>.</p>
</div>
<div class="section" id="exercise-12-minimize-memory-usage-of-a-vibration-solver">
<span id="vib-exer-memsave"></span><h2>Exercise 12: Minimize memory usage of a vibration solver<a class="headerlink" href="#exercise-12-minimize-memory-usage-of-a-vibration-solver" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/vib/vib.py">vib.py</a>
store the complete solution <span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> in memory, which is
convenient for later plotting.
Make a memory minimizing version of this program where only the last three
<span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span> values are stored in memory.
Write each computed <span class="math">\((t_{n+1}, u^{n+1})\)</span> pair to file.
Visualize the data in the file (a cool solution is to
read one line at a time and
plot the <span class="math">\(u\)</span> value using the line-by-line plotter in the
<tt class="docutils literal"><span class="pre">visualize_front_ascii</span></tt> function - this technique makes it trivial
to visualize very long time simulations).
Filename: <tt class="docutils literal"><span class="pre">vib_memsave.py</span></tt>.</p>
</div>
<div class="section" id="exercise-13-implement-the-solver-via-classes">
<span id="vib-exer-gen-class"></span><h2>Exercise 13: Implement the solver via classes<a class="headerlink" href="#exercise-13-implement-the-solver-via-classes" title="Permalink to this headline">¶</a></h2>
<p>Reimplement the <tt class="docutils literal"><span class="pre">vib.py</span></tt>
program
using a class <tt class="docutils literal"><span class="pre">Problem</span></tt> to hold all the physical parameters of the problem,
a class <tt class="docutils literal"><span class="pre">Solver</span></tt> to hold the numerical parameters and compute the
solution, and a class <tt class="docutils literal"><span class="pre">Visualizer</span></tt> to display the solution.</p>
<p><em>Hint.</em> Use the ideas and examples
for an <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#implementing-simple-problem-and-solver-classes">ODE model</a>.
More specifically, make a superclass <tt class="docutils literal"><span class="pre">Problem</span></tt> for holding the scalar
physical parameters of a problem and let subclasses implement the
<span class="math">\(s(u)\)</span> and <span class="math">\(F(t)\)</span> functions as methods.
Try to call up as much existing functionality in <tt class="docutils literal"><span class="pre">vib.py</span></tt> as possible.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">vib_class.py</span></tt>.</p>
</div>
<div class="section" id="exercise-14-show-equivalence-between-schemes">
<span id="vib-exer-schemes-equiv"></span><h2>Exercise 14: Show equivalence between schemes<a class="headerlink" href="#exercise-14-show-equivalence-between-schemes" title="Permalink to this headline">¶</a></h2>
<p>Show that the schemes from the sections <a class="reference internal" href="#vib-ode1-fdm"><em>A centered finite difference scheme</em></a>,
<a class="reference internal" href="#vib-model2x2-eulercromer"><em>The Euler-Cromer method</em></a>, and
<a class="reference internal" href="#vib-model2x2-staggered"><em>The Euler-Cromer scheme on a staggered mesh</em></a> are all equivalent.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">vib_scheme_equivalence.pdf</span></tt>.</p>
</div>
</div>
<div class="section" id="references">
<h1>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h1>
<table class="docutils citation" frame="void" id="ref1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id5">3</a>)</em> <strong>H. P. Langtangen</strong>. Introduction to Computing With Finite Difference Methods,
<em>Simula Research Laboratory and University of Oslo</em>,
2013,
<a class="reference external" href="http://hplgit.github.com/INF5620/doc/pub/decay-sphinx/main_decay.html">http://hplgit.github.com/INF5620/doc/pub/decay-sphinx/main_decay.html</a>.</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite difference methods for vibration problems</a></li>
<li><a class="reference internal" href="#finite-difference-discretization">Finite difference discretization</a><ul>
<li><a class="reference internal" href="#a-basic-model-for-vibrations">A basic model for vibrations</a></li>
<li><a class="reference internal" href="#a-centered-finite-difference-scheme">A centered finite difference scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#computing-the-first-step">Computing the first step</a></li>
<li><a class="reference internal" href="#the-computational-algorithm">The computational algorithm</a></li>
<li><a class="reference internal" href="#operator-notation">Operator notation</a></li>
<li><a class="reference internal" href="#computing">Computing <span class="math">\(u'\)</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-1">Implementation  (1)</a><ul>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a></li>
<li><a class="reference internal" href="#verification-1">Verification  (1)</a><ul>
<li><a class="reference internal" href="#manual-calculation">Manual calculation</a></li>
<li><a class="reference internal" href="#testing-very-simple-solutions">Testing very simple solutions</a></li>
<li><a class="reference internal" href="#checking-convergence-rates">Checking convergence rates</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#long-time-simulations">Long time simulations</a><ul>
<li><a class="reference internal" href="#using-a-moving-plot-window">Using a moving plot window</a></li>
<li><a class="reference internal" href="#making-a-movie-file">Making a movie file</a></li>
<li><a class="reference internal" href="#using-a-line-by-line-ascii-plotter">Using a line-by-line ascii plotter</a></li>
<li><a class="reference internal" href="#empirical-analysis-of-the-solution">Empirical analysis of the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-numerical-scheme">Analysis of the numerical scheme</a><ul>
<li><a class="reference internal" href="#deriving-an-exact-numerical-solution">Deriving an exact numerical solution</a></li>
<li><a class="reference internal" href="#exact-discrete-solution">Exact discrete solution</a></li>
<li><a class="reference internal" href="#stability">Stability</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative-schemes-based-on-1st-order-equations">Alternative schemes based on 1st-order equations</a><ul>
<li><a class="reference internal" href="#standard-methods-for-1st-order-ode-systems">Standard methods for 1st-order ODE systems</a><ul>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a></li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#comparison-of-schemes">Comparison of schemes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#enegy-considerations">Enegy considerations</a><ul>
<li><a class="reference internal" href="#derivation-of-the-energy-expression">Derivation of the energy expression</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#discrete-total-energy">Discrete total energy</a></li>
<li><a class="reference internal" href="#an-error-measure-based-on-total-energy">An error measure based on total energy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-euler-cromer-method">The Euler-Cromer method</a><ul>
<li><a class="reference internal" href="#forward-backward-discretization">Forward-backward discretization</a></li>
<li><a class="reference internal" href="#equivalence-with-the-scheme-for-the-second-order-ode">Equivalence with the scheme for the second-order ODE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-euler-cromer-scheme-on-a-staggered-mesh">The Euler-Cromer scheme on a staggered mesh</a></li>
<li><a class="reference internal" href="#implementation-of-the-scheme-on-a-staggered-mesh">Implementation of the scheme on a staggered mesh</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generalization-damping-nonlinear-spring-and-external-excitation">Generalization: damping, nonlinear spring, and external excitation</a><ul>
<li><a class="reference internal" href="#a-centered-scheme-for-linear-damping">A centered scheme for linear damping</a></li>
<li><a class="reference internal" href="#a-centered-scheme-for-quadratic-damping">A centered scheme for quadratic damping</a></li>
<li><a class="reference internal" href="#implementation-2">Implementation  (2)</a></li>
<li><a class="reference internal" href="#verification-2">Verification  (2)</a><ul>
<li><a class="reference internal" href="#constant-solution">Constant solution</a></li>
<li><a class="reference internal" href="#linear-solution">Linear solution</a></li>
<li><a class="reference internal" href="#quadratic-solution">Quadratic solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
<li><a class="reference internal" href="#user-interface">User interface</a></li>
<li><a class="reference internal" href="#an-euler-cromer-scheme-for-the-generalized-model">An Euler-Cromer scheme for the generalized model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-and-problems">Exercises and Problems</a><ul>
<li><a class="reference internal" href="#problem-1-use-linear-quadratic-functions-for-verification">Problem 1: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-1-show-linear-growth-of-the-phase-with-time">Exercise 1: Show linear growth of the phase with time</a></li>
<li><a class="reference internal" href="#exercise-2-improve-the-accuracy-by-adjusting-the-frequency">Exercise 2: Improve the accuracy by adjusting the frequency</a></li>
<li><a class="reference internal" href="#exercise-3-see-if-adaptive-methods-improve-the-phase-error">Exercise 3: See if adaptive methods improve the phase error</a></li>
<li><a class="reference internal" href="#exercise-4-use-a-taylor-polynomial-to-compute">Exercise 4: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span></a></li>
<li><a class="reference internal" href="#exercise-5-find-the-minimal-resolution-of-an-oscillatory-function">Exercise 5: Find the minimal resolution of an oscillatory function</a></li>
<li><a class="reference internal" href="#exercise-6-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">Exercise 6: Visualize the accuracy of finite differences for a cosine function</a></li>
<li><a class="reference internal" href="#exercise-7-verify-convergence-rates-of-the-error-in-energy">Exercise 7: verify convergence rates of the error in energy</a></li>
<li><a class="reference internal" href="#exercise-8-use-linear-quadratic-functions-for-verification">Exercise 8: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-9-use-an-exact-discrete-solution-for-verification">Exercise 9: Use an exact discrete solution for verification</a></li>
<li><a class="reference internal" href="#exercise-10-use-analytical-solution-for-convergence-rate-tests">Exercise 10: Use analytical solution for convergence rate tests</a></li>
<li><a class="reference internal" href="#exercise-11-investigate-the-amplitude-errors-of-many-solvers">Exercise 11: Investigate the amplitude errors of many solvers</a></li>
<li><a class="reference internal" href="#exercise-12-minimize-memory-usage-of-a-vibration-solver">Exercise 12: Minimize memory usage of a vibration solver</a></li>
<li><a class="reference internal" href="#exercise-13-implement-the-solver-via-classes">Exercise 13: Implement the solver via classes</a></li>
<li><a class="reference internal" href="#exercise-14-show-equivalence-between-schemes">Exercise 14: Show equivalence between schemes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/main_vib.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">Finite difference methods for vibration problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>