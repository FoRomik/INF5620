
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A FEniCS Tutorial</title>
    
    <link rel="stylesheet" href="_static/fenics.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="A FEniCS Tutorial" href="index.html" />
    <link rel="prev" title="A FEniCS Tutorial" href="index.html" />

<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="_static/featured.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="_static/slides.min.jquery.js"></script>
  <script>
	$(function(){
		$('#products').slides({
			preload: true,
			preloadImage: 'img/loading.gif',
			effect: 'slide, fade',
			crossfade: true,
			slideSpeed: 350,
			fadeSpeed: 500,
			generateNextPrev: false,
			generatePagination: false,
	                play: 5000,
                        hoverPause: false,
                        animationStart: function(current){
				$('.caption').animate({
					bottom:-35
				},100);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationStart on slide: ', current);
				};
			},
			animationComplete: function(current){
				$('.caption').animate({
					bottom:0
				},200);
				if (window.console && console.log) {
					// example return of current slide number
					console.log('animationComplete on slide: ', current);
				};
			},
			slidesLoaded: function() {
				$('.caption').animate({
					bottom:0
				},200);
			}
		});
	});
  </script>


<link rel="shortcut icon" href="_static/fenics.ico" />


  
   <style type=text/css>
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
<div class="wrapper">
  <a href="http://fenicsproject.org/"><img src="_static/fenics_banner.png" width="900px" alt="FEniCS Project Banner" /></a>
  <div id="access">
    <div class="menu">
      <ul>
	<li class="page_item"><a href="http://fenicsproject.org/about/" title="Find out more about the FEniCS project">About</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/download/" title="Obtain the FEniCS project">Download</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/documentation/" title="Learn how to use the FEniCS project">Documentation</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/applications/" title="Learn how others are using the FEniCS project">Applications</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/contributing/" title="Learn how to contribute to the FEniCS project">Contributing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/citing/" title="Learn how to cite the FEniCS project">Citing</a></li>
	<li class="page_item"><a href="http://fenicsproject.org/support/" title="Where to go for more help">Support</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="a-fenics-tutorial">
<h1>A FEniCS Tutorial<a class="headerlink" href="#a-fenics-tutorial" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Nov 13, 2013</td>
</tr>
</tbody>
</table>
<p>This document presents a FEniCS tutorial to get new users quickly up
and running with solving differential equations. FEniCS can be
programmed both in C++ and Python, but this tutorial focuses
exclusively on Python programming, since this is the simplest approach
to exploring FEniCS for beginners and since it actually gives high
performance. After having digested the examples in this tutorial, the
reader should be able to learn more from the FEniCS documentation, the
numerous demos, and the comprehensive FEniCS book <em>Automated Solution of
Differential Equations by the Finite element Method: The FEniCS book</em>
<a class="reference internal" href="#ref01">[Ref01]</a>.</p>
<p>The tutorial is still in an initial state so the reader is encouraged
to send email to the author on <tt class="docutils literal"><span class="pre">hpl&#64;simula.no</span></tt> about typos, errors,
and suggestions for improvements.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This tutorial is compatible with FEniCS version 1.1.
There are some differences between this document and
the tutorial in the FEniCS book <a class="reference internal" href="#ref01">[Ref01]</a> because of
changes in the FEniCS software from version 1.0 to 1.1</p>
</div>
</div>
<div class="section" id="fundamentals">
<span id="tut-fundamentals"></span><h1>Fundamentals<a class="headerlink" href="#fundamentals" title="Permalink to this headline">¶</a></h1>
<p>FEniCS is a user-friendly tool for solving partial differential
equations (PDEs). The goal of this tutorial is to get you started with
FEniCS through a series of simple examples that demonstrate</p>
<blockquote>
<div><ul class="simple">
<li>how to define the PDE problem in terms of a variational problem,</li>
<li>how to define simple domains,</li>
<li>how to deal with Dirichlet, Neumann, and Robin conditions,</li>
<li>how to deal with variable coefficients,</li>
<li>how to deal with domains built of several materials (subdomains),</li>
<li>how to compute derived quantities like the flux vector field or
a functional of the solution,</li>
<li>how to quickly visualize the mesh, the solution, the flux, etc.,</li>
<li>how to solve nonlinear PDEs in various ways,</li>
<li>how to deal with time-dependent PDEs,</li>
<li>how to set parameters governing solution methods for linear systems,</li>
<li>how to create domains of more complex shape.</li>
</ul>
</div></blockquote>
<p>The mathematics of the illustrations is kept simple to better focus
on FEniCS functionality and syntax. This means that we mostly use
the Poisson equation and the time-dependent diffusion equation
as model problems, often with input data adjusted such that we get
a very simple solution that can be exactly reproduced by any standard
finite element method over a uniform, structured mesh. This
latter property greatly simplifies the verification of the implementations.
Occasionally we insert a physically more relevant example
to remind the reader that changing the PDE and boundary
conditions to something more real might often be a trivial task.</p>
<p>FEniCS may seem to require a thorough understanding of the abstract
mathematical version of the finite element method as well as
familiarity with the Python programming language.  Nevertheless, it
turns out that many are able to pick up the fundamentals of finite
elements <em>and</em> Python programming as they go along with this
tutorial. Simply keep on reading and try out the examples. You will be
amazed of how easy it is to solve PDEs with FEniCS!</p>
<p>Reading this tutorial obviously requires access to a machine where the
FEniCS software is installed. The section <a class="reference internal" href="#tut-app-install"><em>Installing FEniCS</em></a> explains
briefly how to install the necessary tools.</p>
<p>All the examples discussed in the following are available as
executable Python source code files in a directory tree.</p>
<div class="section" id="the-poisson-equation">
<span id="tut-poisson1-bvp"></span><h2>The Poisson equation<a class="headerlink" href="#the-poisson-equation" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Our first example regards the Poisson problem,</p>
<div class="math" id="equation-tut:poisson1">
<span class="eqno">(1)</span>\[     - \nabla^2 u(\boldsymbol{x}) = f(\boldsymbol{x}),\quad \boldsymbol{x}\mbox{ in } \Omega,\]</div>
<div class="math" id="equation-tut:poisson1:bc">
<span class="eqno">(2)</span>\[     u(\boldsymbol{x}) = u_0(\boldsymbol{x}),\quad \boldsymbol{x}\mbox{ on } \partial \Omega{\thinspace . }\]</div>
<p>Here, <span class="math">\(u(\boldsymbol{x})\)</span> is the unknown function, <span class="math">\(f(\boldsymbol{x})\)</span> is a
prescribed function, <span class="math">\(\nabla^2\)</span> is the Laplace operator (also
often written as <span class="math">\(\Delta\)</span>), <span class="math">\(\Omega\)</span> is the spatial domain, and
<span class="math">\(\partial\Omega\)</span> is the boundary of <span class="math">\(\Omega\)</span>. A stationary PDE like
this, together with a complete set of boundary conditions, constitute
a <em>boundary-value problem</em>, which must be precisely stated before
it makes sense to start solving it with FEniCS.</p>
<p>In two space dimensions with coordinates <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, we can write out
the Poisson equation as</p>
<div class="math">
\[- {\partial^2 u\over\partial x^2} -
{\partial^2 u\over\partial y^2} = f(x,y){\thinspace . }\]</div>
<p>The unknown <span class="math">\(u\)</span> is now a function of two variables, <span class="math">\(u(x,y)\)</span>, defined
over a two-dimensional domain <span class="math">\(\Omega\)</span>.</p>
<p>The Poisson equation arises in numerous physical contexts, including
heat conduction, electrostatics, diffusion of substances, twisting of
elastic rods, inviscid fluid flow, and water waves. Moreover, the
equation appears in numerical splitting strategies of more complicated
systems of PDEs, in particular the Navier-Stokes equations.</p>
<p>Solving a physical problem with FEniCS consists
of the following steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Identify the PDE and its boundary conditions.</li>
<li>Reformulate the PDE problem as a variational problem.</li>
<li>Make a Python program where the formulas in the variational
problem are coded, along with definitions of input data such as
<span class="math">\(f\)</span>, <span class="math">\(u_0\)</span>, and a mesh for the spatial domain <span class="math">\(\Omega\)</span>.</li>
<li>Add statements in the program for solving the variational
problem, computing derived quantities such as <span class="math">\(\nabla u\)</span>, and
visualizing the results.</li>
</ol>
</div></blockquote>
<p>We shall now go through steps 2-4 in detail.  The key feature of
FEniCS is that steps 3 and 4 result in fairly short code, while most
other software frameworks for PDEs require much more code and more
technically difficult programming.</p>
</div>
<div class="section" id="variational-formulation">
<span id="tut-poisson1-varform"></span><h2>Variational Formulation<a class="headerlink" href="#variational-formulation" title="Permalink to this headline">¶</a></h2>
<p id="index-1">FEniCS makes it easy to solve PDEs if finite elements are used for
discretization in space and the problem is expressed as a
<em>variational problem</em>. Readers who are not familiar with
variational problems will get a brief introduction to the topic in
this tutorial, but getting and reading
a proper book on the finite element method in addition is encouraged. The section <a class="reference internal" href="#tut-appendix-books"><em>Books on the Finite Element Method</em></a> contains a list of some suitable
books.</p>
<span class="target" id="index-2"></span><p id="index-3">The core of the recipe for turning a PDE into a variational problem
is to multiply the PDE by a function <span class="math">\(v\)</span>, integrate the resulting
equation over <span class="math">\(\Omega\)</span>, and perform integration by parts of terms with
second-order derivatives. The function <span class="math">\(v\)</span> which multiplies the PDE
is in the mathematical finite element literature
called a <em>test function</em>. The unknown function <span class="math">\(u\)</span> to be approximated
is referred to
as a <em>trial function</em>. The terms test and trial function are used
in FEniCS programs too.
Suitable
function spaces must be specified for the test and trial functions.
For standard PDEs arising in physics and mechanics such spaces are
well known.</p>
<p>In the present case, we first multiply the Poisson equation
by the test function <span class="math">\(v\)</span> and integrate,</p>
<div class="math" id="equation-tut:poisson1:multbyv">
<span class="eqno">(3)</span>\[      -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>Then we apply integration by parts to the integrand with
second-order derivatives,</p>
<div class="math" id="equation-tut:poisson1:eqbyparts">
<span class="eqno">(4)</span>\[      -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
     = \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
     \partial n}v {\, \mathrm{d}s} ,\]</div>
<p>where <span class="math">\({\partial u\over
\partial n}\)</span> is the derivative of <span class="math">\(u\)</span> in the outward normal direction at
the boundary.
The test function <span class="math">\(v\)</span> is required to vanish on the parts of the
boundary where <span class="math">\(u\)</span> is known, which in the present problem implies that
<span class="math">\(v=0\)</span> on the whole boundary <span class="math">\(\partial\Omega\)</span>.
The second term on the right-hand side of the last equation therefore
vanishes. It then follows that</p>
<div class="math" id="equation-tut:poisson1:weak1 \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace . }">
</div>
<p>This equation is supposed to hold
for all <span class="math">\(v\)</span> in some function space <span class="math">\(\hat V\)</span>. The trial function <span class="math">\(u\)</span>
lies in some (possibly different) function space <span class="math">\(V\)</span>.
We say that the last equation is the <em>weak form</em> of the original
boundary value problem consisting of the PDE <span class="math">\(-\nabla^2u=f\)</span> and the
boundary condition <span class="math">\(u=u_0\)</span>.</p>
<p>The proper statement of
our variational problem now goes as follows:
Find <span class="math">\(u \in V\)</span> such that</p>
<div class="math" id="equation-tut:poisson1:var">
<span class="eqno">(6)</span>\[       \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} =
       \int_{\Omega} fv {\, \mathrm{d}x}
       \quad \forall v \in \hat{V}.\]</div>
<p>The test and trial spaces <span class="math">\(\hat{V}\)</span> and <span class="math">\(V\)</span> are in the present
problem defined as</p>
<div class="math">
\[\begin{split}\hat{V} &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } \partial\Omega\}, \\
 V      &amp;= \{v \in H^1(\Omega) : v = u_0 \mbox{ on } \partial\Omega\}{\thinspace . }\end{split}\]</div>
<p>In short,
<span class="math">\(H^1(\Omega)\)</span> is the mathematically well-known Sobolev space containing
functions <span class="math">\(v\)</span> such that <span class="math">\(v^2\)</span> and <span class="math">\(||\nabla v||^2\)</span> have finite integrals over
<span class="math">\(\Omega\)</span>. The solution of the underlying
PDE
must lie in a function space where also the derivatives are continuous,
but the Sobolev space <span class="math">\(H^1(\Omega)\)</span> allows functions with discontinuous
derivatives.
This weaker continuity requirement of <span class="math">\(u\)</span> in the variational
statement,
caused by the integration by parts, has
great practical consequences when it comes to constructing
finite elements.</p>
<p>To solve the Poisson equation numerically, we need to transform the
continuous variational problem
to a discrete variational
problem. This is done by introducing <em>finite-dimensional</em> test and
trial spaces, often denoted as
<span class="math">\(\hat{V}_h\subset\hat{V}\)</span> and <span class="math">\(V_h\subset{V}\)</span>. The
discrete variational problem reads:
Find <span class="math">\(u_h \in V_h \subset V\)</span> such that</p>
<div class="math" id="equation-tut:poisson1:vard">
<span class="eqno">(7)</span>\[       \int_{\Omega} \nabla u_h \cdot \nabla v {\, \mathrm{d}x} =
       \int_{\Omega} fv {\, \mathrm{d}x}
       \quad \forall v \in \hat{V}_h \subset \hat{V}{\thinspace . }\]</div>
<p>The choice of <span class="math">\(\hat{V}_h\)</span> and <span class="math">\(V_h\)</span> follows directly from the
kind of finite elements we want to apply in our problem. For example,
choosing the well-known linear triangular element with three nodes
implies that
<span class="math">\(\hat V_h\)</span> and <span class="math">\(V_h\)</span> are the spaces of all piecewise linear functions
over a mesh of triangles,
where the functions in <span class="math">\(\hat V_h\)</span>
are zero on the boundary
and those in <span class="math">\(V_h\)</span> equal <span class="math">\(u_0\)</span> on the boundary.</p>
<p>The mathematics literature on variational problems writes <span class="math">\(u_h\)</span> for
the solution of the discrete problem and <span class="math">\(u\)</span> for the solution of the
continuous problem. To obtain (almost) a one-to-one relationship
between the mathematical formulation of a problem and the
corresponding FEniCS program, we shall use <span class="math">\(u\)</span> for the solution of
the discrete problem and <span class="math">\(u_{e}\)</span> for the exact solution of the
continuous problem, <em>if</em> we need to explicitly distinguish
between the two.  In most cases, we will introduce the PDE problem with
<span class="math">\(u\)</span> as unknown, derive a variational equation <span class="math">\(a(u,v)=L(v)\)</span> with <span class="math">\(u\in
V\)</span> and <span class="math">\(v\in \hat V\)</span>, and then simply discretize the problem by saying
that we choose finite-dimensional spaces for <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>. This
restriction of <span class="math">\(V\)</span> implies that <span class="math">\(u\)</span> becomes a discrete finite element
function.  In practice, this means that we turn our PDE problem into a
continuous variational problem, create a mesh and specify an element
type, and then let <span class="math">\(V\)</span> correspond to this mesh and element choice.
Depending upon whether <span class="math">\(V\)</span> is infinite- or finite-dimensional, <span class="math">\(u\)</span>
will be the exact or approximate solution.</p>
<p>It turns out to be convenient to
introduce the following unified notation for linear weak forms:</p>
<div class="math">
\[a(u, v) = L(v){\thinspace . }\]</div>
<p>In the present problem we have that</p>
<div class="math" id="equation-tut:poisson1:vard:a">
<span class="eqno">(8)</span>\[     a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="equation-tut:poisson1:vard:L">
<span class="eqno">(9)</span>\[     L(v) = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>From the mathematics literature,
<span class="math">\(a(u,v)\)</span> is known as a <em>bilinear form</em> and <span class="math">\(L(v)\)</span> as a
<em>linear form</em>.
We shall in every linear problem we solve identify the terms with the
unknown <span class="math">\(u\)</span> and collect them in <span class="math">\(a(u,v)\)</span>, and similarly collect
all terms with only known functions in <span class="math">\(L(v)\)</span>. The formulas for <span class="math">\(a\)</span> and
<span class="math">\(L\)</span> are then coded directly in the program.</p>
<p>To summarize, before making a FEniCS program for solving a PDE,
we must first perform two steps:</p>
<blockquote>
<div><ul class="simple">
<li>Turn the PDE problem into a discrete
variational problem: find <span class="math">\(u\in V\)</span>
such that <span class="math">\(a(u,v) = L(v)\quad\forall v\in \hat{V}\)</span>.</li>
<li>Specify the choice of spaces (<span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>), which means
specifying the mesh and type of finite elements.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="implementation-1">
<span id="tut-poisson1-impl"></span><h2>Implementation  (1)<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h2>
<p id="index-4">The test problem so far has a general domain <span class="math">\(\Omega\)</span> and general functions
<span class="math">\(u_0\)</span> and <span class="math">\(f\)</span>. For our first implementation we must decide on specific
choices of <span class="math">\(\Omega\)</span>, <span class="math">\(u_0\)</span>, and <span class="math">\(f\)</span>.
It will be wise to construct a specific problem where we can easily
check that the computed solution is correct. Let us start with
specifying an exact solution</p>
<div class="math" id="equation-tut:poisson1:impl:uex">
<span class="eqno">(10)</span>\[     \
     u_{\rm e}(x, y) = 1 +x^2 + 2y^2\]</div>
<p>on some 2D domain.  By inserting eq:ref:<cite>tut:poisson1:impl:uex</cite> in
our Poisson problem, we find that <span class="math">\(u_{\rm e}(x,y)\)</span> is a solution if</p>
<div class="math">
\[f(x,y) = -6,\quad u_0(x,y)=u_{\rm e}(x,y)=1 + x^2 + 2y^2,\]</div>
<p>regardless of the shape of the domain. We choose here, for simplicity,
the domain to be the unit square,</p>
<div class="math">
\[\Omega = [0,1]\times [0,1] .\]</div>
<p>The reason for specifying the solution eq:ref:<cite>tut:poisson1:impl:uex</cite>
is that the finite element method, with a rectangular domain uniformly
partitioned into linear triangular elements, will exactly reproduce a
second-order polynomial at the vertices of the cells, regardless of
the size of the elements. This property allows us to verify the
implementation by comparing the computed solution, called <span class="math">\(u\)</span> in this
document (except when setting up the PDE problem), with the exact
solution, denoted by <span class="math">\(u_{\rm e}\)</span>: <span class="math">\(u\)</span> should equal
<span class="math">\(u_{\rm}\)</span> to machine precision emph{at the nodes}.
Test problems with this property will be frequently constructed
throughout this tutorial.</p>
<p>A FEniCS program for solving the Poisson equation in 2D
with the given choices
of <span class="math">\(u_0\)</span>, <span class="math">\(f\)</span>, and <span class="math">\(\Omega\)</span> may look as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Create mesh and define function space</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c">#mesh = UnitCubeMesh(6, 4, 5)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary conditions</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Compute solution</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="c"># Plot solution and mesh</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="c"># Dump solution to file in VTK format</span>
<span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;poisson.pvd&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>

<span class="c"># Hold plot</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The complete code can be found in the file <tt class="docutils literal"><span class="pre">d1_p2D.py</span></tt> in the
directory <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>.</p>
<p>We shall now dissect this FEniCS program in detail. The program
is written in the Python programming language.
You may either take a quick look at the
<a class="reference external" href="http://docs.python.org/tutorial/">official Python tutorial</a>
to pick up the basics of Python if you are unfamiliar with the language,
or you may learn enough Python as you go along with the examples in the
present tutorial. The latter strategy has proven to work for many newcomers
to FEniCS. (The requirement of using Python and an abstract
mathematical formulation of the finite element problem may seem
difficult for those who are unfamiliar with these topics.
However, the amount of mathematics and Python that is really demanded
to get you productive with FEniCS is quite limited.
And Python is an easy-to-learn language that you certainly will love
and use far beyond FEniCS programming.)
the section <a class="reference internal" href="#tut-appendix-pybooks"><em>Books on Python</em></a> lists some relevant Python books.</p>
<p>The listed FEniCS program defines a finite element mesh, the discrete
function spaces <span class="math">\(V\)</span> and <span class="math">\(\hat{V}\)</span> corresponding to this mesh and
the element type, boundary conditions
for <span class="math">\(u\)</span> (the function <span class="math">\(u_0\)</span>), <span class="math">\(a(u,v)\)</span>, and <span class="math">\(L(v)\)</span>.
Thereafter, the unknown
trial function <span class="math">\(u\)</span> is computed. Then we can investigate <span class="math">\(u\)</span> visually or
analyze the computed values.</p>
<p>The first line in the program,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>imports the key classes <tt class="docutils literal"><span class="pre">UnitSquareMesh</span></tt>,
<tt class="docutils literal"><span class="pre">FunctionSpace</span></tt>, <tt class="docutils literal"><span class="pre">Function</span></tt>, and so forth, from the DOLFIN library.
All FEniCS programs for solving PDEs by the finite element method
normally start with this line. DOLFIN is a software library with efficient
and convenient C++ classes for finite element computing, and
<tt class="docutils literal"><span class="pre">dolfin</span></tt> is a Python package providing access to this
C++ library from Python programs.
You can think of FEniCS as an umbrella, or project name, for a set of
computational components, where DOLFIN is one important component for
writing finite element programs. The <tt class="docutils literal"><span class="pre">from</span> <span class="pre">dolfin</span> <span class="pre">import</span> <span class="pre">*</span></tt> statement
imports other components too, but newcomers to FEniCS
programming do not need to care about this.</p>
<span class="target" id="index-5"></span><p id="index-6">The statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>defines a uniform finite element mesh over the unit square
<span class="math">\([0,1]\times [0,1]\)</span>. The mesh consists of <em>cells</em>,
which are triangles with
straight sides. The parameters 6 and 4 tell that the square is
first divided into <span class="math">\(6\times 4\)</span> rectangles, and then each rectangle
is divided into two triangles. The total number of triangles
then becomes 48. The total number of vertices in this mesh is
<span class="math">\(7\cdot 5=35\)</span>.
DOLFIN offers some classes for creating meshes over
very simple geometries. For domains of more complicated shape one needs
to use a separate <em>preprocessor</em> program to create the mesh.
The FEniCS program will then read the mesh from file.</p>
<p id="index-7">Having a mesh, we can define a discrete function space <tt class="docutils literal"><span class="pre">V</span></tt> over this mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second argument reflects the type of element, while the third
argument is the degree of the basis functions on the element.</p>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><p id="index-10">The type of element is here &#8220;Lagrange&#8221;, implying the
standard Lagrange family of elements.
(Some FEniCS programs use <tt class="docutils literal"><span class="pre">'CG'</span></tt>, for Continuous Galerkin,
as a synonym for <tt class="docutils literal"><span class="pre">'Lagrange'</span></tt>.)
With degree 1, we simply get the standard linear Lagrange element,
which is a triangle
with nodes at the three vertices.
Some finite element practitioners refer to this element as the
&#8220;linear triangle&#8221;.
The computed <span class="math">\(u\)</span> will be continuous and linearly varying in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> over
each cell in the mesh.
Higher-degree polynomial approximations over each cell are
trivially obtained by increasing the third parameter in
<tt class="docutils literal"><span class="pre">FunctionSpace</span></tt>. Changing the second parameter to <tt class="docutils literal"><span class="pre">'DG'</span></tt> creates a
function space for discontinuous Galerkin methods.</p>
<span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><p id="index-14">In mathematics, we distinguish between the trial and test
spaces <span class="math">\(V\)</span> and <span class="math">\(\hat{V}\)</span>. The only difference in the present problem
is the boundary conditions. In FEniCS we do not specify the boundary
conditions as part of the function space, so it is sufficient to work
with one common space <tt class="docutils literal"><span class="pre">V</span></tt> for the and trial and test functions in the
program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-15">The next step is to specify the boundary condition: <span class="math">\(u=u_0\)</span> on
<span class="math">\(\partial\Omega\)</span>. This is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">u0_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">u0</span></tt> is an instance holding the <span class="math">\(u_0\)</span> values,
and <tt class="docutils literal"><span class="pre">u0_boundary</span></tt> is a function (or object) describing whether a point lies
on the boundary where <span class="math">\(u\)</span> is specified.</p>
<p>Boundary conditions
of the type <span class="math">\(u=u_0\)</span> are known as <em>Dirichlet conditions</em>, and also
as <em>essential boundary conditions</em> in a finite element context.
Naturally, the name of the DOLFIN class holding the information about
Dirichlet boundary conditions is <tt class="docutils literal"><span class="pre">DirichletBC</span></tt>.</p>
<p id="index-16">The <tt class="docutils literal"><span class="pre">u0</span></tt> variable refers to an <tt class="docutils literal"><span class="pre">Expression</span></tt> object, which
is used to represent a mathematical function. The typical construction is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">formula</span></tt> is a string containing the mathematical expression.
This formula is
written with C++ syntax (the expression is
automatically turned into an efficient, compiled
C++ function, see the section <a class="reference internal" href="#tut-app-cpp-functions"><em>User-Defined Functions</em></a> for
details on the syntax). The independent variables in the function
expression are supposed to be available
as a point vector <tt class="docutils literal"><span class="pre">x</span></tt>, where the first element <tt class="docutils literal"><span class="pre">x[0]</span></tt>
corresponds to the <span class="math">\(x\)</span> coordinate, the second element <tt class="docutils literal"><span class="pre">x[1]</span></tt>
to the <span class="math">\(y\)</span> coordinate, and (in a three-dimensional problem)
<tt class="docutils literal"><span class="pre">x[2]</span></tt> to the <span class="math">\(z\)</span> coordinate. With our choice of
<span class="math">\(u_0(x,y)=1 + x^2 + 2y^2\)</span>, the formula string must be written
as <tt class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">x[0]*x[0]</span> <span class="pre">+</span> <span class="pre">2*x[1]*x[1]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The information about where to apply the <tt class="docutils literal"><span class="pre">u0</span></tt> function as
boundary condition is coded in a function <tt class="docutils literal"><span class="pre">u0_boundary</span></tt>:</p>
<div class="highlight-python" id="index-17"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>
</pre></div>
</div>
<p>A function like <tt class="docutils literal"><span class="pre">u0_boundary</span></tt> for marking the boundary must
return
a boolean value: <tt class="docutils literal"><span class="pre">True</span></tt> if the given point
<tt class="docutils literal"><span class="pre">x</span></tt> lies on the Dirichlet boundary and
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.
The argument <tt class="docutils literal"><span class="pre">on_boundary</span></tt> is <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> is on
the physical boundary of the mesh, so in the present case, where
we are supposed to return <tt class="docutils literal"><span class="pre">True</span></tt> for all points on
the boundary, we can just return the supplied value of
<tt class="docutils literal"><span class="pre">on_boundary</span></tt>.
The <tt class="docutils literal"><span class="pre">u0_boundary</span></tt> function will be called
for every discrete point in the mesh, which allows us to have boundaries
where <span class="math">\(u\)</span> are known also inside the domain, if desired.</p>
<p>One can also omit the <tt class="docutils literal"><span class="pre">on_boundary</span></tt> argument,
but in that case we need to test on the value of the coordinates
in <tt class="docutils literal"><span class="pre">x</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>As for the formula in <tt class="docutils literal"><span class="pre">Expression</span></tt> objects, <tt class="docutils literal"><span class="pre">x</span></tt> in the
<tt class="docutils literal"><span class="pre">u0_boundary</span></tt> function represents a point in space with
coordinates <tt class="docutils literal"><span class="pre">x[0]</span></tt>, <tt class="docutils literal"><span class="pre">x[1]</span></tt>, etc. Comparing floating-point
values using an exact match test with <tt class="docutils literal"><span class="pre">==</span></tt>
is not good programming practice, because small round-off errors in
the computations of the <tt class="docutils literal"><span class="pre">x</span></tt> values could make a test
<tt class="docutils literal"><span class="pre">x[0]</span> <span class="pre">==</span> <span class="pre">1</span></tt> become false even though <tt class="docutils literal"><span class="pre">x</span></tt> lies on the boundary.
A better test is to check for equality with a tolerance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u0_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-15</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> \
           <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p id="index-18">Before defining <span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span> we have to specify the <span class="math">\(f\)</span> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-6&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When <span class="math">\(f\)</span> is constant over the domain, <tt class="docutils literal"><span class="pre">f</span></tt> can be
more efficiently represented as a <tt class="docutils literal"><span class="pre">Constant</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we have all the objects we need in order to specify this problem&#8217;s
<span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>In essence, these two lines specify the PDE to be solved.
Note the very close correspondence between the Python syntax
and the mathematical formulas <span class="math">\(\nabla u\cdot\nabla v {\, \mathrm{d}x}\)</span> and
<span class="math">\(fv {\, \mathrm{d}x}\)</span>.
This is a key strength of FEniCS: the formulas in the variational
formulation translate directly to very similar Python code, a feature
that makes it easy to specify PDE problems with lots of PDEs and
complicated terms in the equations.
The language used to express weak forms is called UFL (Unified Form Language)
and is an integral part of FEniCS.</p>
<p>Instead of <tt class="docutils literal"><span class="pre">nabla_grad</span></tt> we could also just have written
<tt class="docutils literal"><span class="pre">grad</span></tt> in the examples in this tutorial. However, when taking
gradients of vector fields, <tt class="docutils literal"><span class="pre">grad</span></tt> and <tt class="docutils literal"><span class="pre">nabla_grad</span></tt>
differ. The latter is consistent with the tensor algebra commonly
used to derive vector and tensor PDEs, where the &#8220;nabla&#8221; acts as a
vector operator, and therefore this author prefers to always use
<tt class="docutils literal"><span class="pre">nabla_grad</span></tt>.</p>
<p>Having <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> defined, and information about essential
(Dirichlet) boundary conditions in <tt class="docutils literal"><span class="pre">bc</span></tt>, we can compute the
solution, a finite element function <tt class="docutils literal"><span class="pre">u</span></tt>, by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>Some prefer to replace <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> by an <tt class="docutils literal"><span class="pre">equation</span></tt>
variable, which is accomplished by this equivalent code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">equation</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">==</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we first defined the variable <tt class="docutils literal"><span class="pre">u</span></tt> as a
<tt class="docutils literal"><span class="pre">TrialFunction</span></tt> and used it to represent the unknown in the form
<tt class="docutils literal"><span class="pre">a</span></tt>.  Thereafter, we redefined <tt class="docutils literal"><span class="pre">u</span></tt> to be a <tt class="docutils literal"><span class="pre">Function</span></tt>
object representing the solution, i.e., the computed finite element
function <span class="math">\(u\)</span>.  This redefinition of the variable <tt class="docutils literal"><span class="pre">u</span></tt> is possible
in Python and often done in FEniCS applications. The two types of
objects that <tt class="docutils literal"><span class="pre">u</span></tt> refers to are equal from a mathematical point of
view, and hence it is natural to use the same variable name for both
objects. In a program, however, <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> objects must
always be used for the unknowns in the problem specification (the form
<tt class="docutils literal"><span class="pre">a</span></tt>), while <tt class="docutils literal"><span class="pre">Function</span></tt> objects must be used for quantities
that are computed (known).</p>
<p>The simplest way of quickly looking at <tt class="docutils literal"><span class="pre">u</span></tt> and the mesh
is to say</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">interactive()</span></tt> call is necessary for the plot to remain on the
screen. With the left, middle, and right
mouse buttons you can rotate, translate, and zoom
(respectively) the plotted surface to better examine what the solution looks
like.
Figures <a class="reference internal" href="#tut-poisson-2d-fig-ex1-u"><em>Plot of the solution in the first FEniCS example</em></a> and <a class="reference internal" href="#tut-poisson-2d-fig-ex1-mesh"><em>Plot of the mesh in the first FEniCS example</em></a>
display the resulting <span class="math">\(u\)</span> function and the finite element mesh, respectively.</p>
<p>It is also possible to dump the computed solution to file, e.g., in the
VTK format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&#39;poisson.pvd&#39;</span><span class="p">)</span>
<span class="nb">file</span> <span class="o">&lt;&lt;</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">poisson.pvd</span></tt> file can now be loaded into any
front-end to VTK, say ParaView or VisIt. The <tt class="docutils literal"><span class="pre">plot</span></tt> function
is intended for quick examination of the solution during program development.
More in-depth visual investigations of finite element solutions will
normally benefit from using highly professional tools such as ParaView and
VisIt.</p>
<div class="figure" id="tut-poisson-2d-fig-ex1-u">
<img alt="_images/ex1_u.png" src="_images/ex1_u.png" style="width: 480px;" />
<p class="caption"><em>Plot of the solution in the first FEniCS example</em></p>
</div>
<div class="figure" id="tut-poisson-2d-fig-ex1-mesh">
<img alt="_images/ex1_mesh.png" src="_images/ex1_mesh.png" style="width: 480px;" />
<p class="caption"><em>Plot of the mesh in the first FEniCS example</em></p>
</div>
<p>The next three sections deal with some technicalities about specifying
the solution method for linear systems (so that you can solve large
problems) and examining array data from the computed solution (so that
you can check that the program is correct).  These technicalities are
scattered around in forthcoming programs. However, the impatient reader who
is more interested in seeing the previous program being adapted to a
real physical problem, and play around with some interesting
visualizations, can safely jump to the section <a class="reference internal" href="#tut-poisson-membrane"><em>Solving a Real Physical Problem</em></a>.
Information in the intermediate sections can be studied on demand.</p>
</div>
<div class="section" id="controlling-the-solution-process">
<span id="tut-poisson1-solve-prm"></span><h2>Controlling the Solution Process<a class="headerlink" href="#controlling-the-solution-process" title="Permalink to this headline">¶</a></h2>
<p>Sparse LU decomposition (Gaussian elimination) is used by default to
solve linear systems of equations in FEniCS programs.  This is a very
robust and recommended method for a few thousand unknowns in the
equation system, and may hence be the method of choice in many 2D and
smaller 3D problems. However, sparse LU decomposition becomes slow and
memory demanding in large problems.  This fact forces the use of
iterative methods, which are faster and require much less memory.</p>
<p id="index-19">Preconditioned Krylov solvers is a type of popular iterative methods that are
easily accessible in FEniCS programs. The Poisson equation results in
a symmetric, positive definite coefficient matrix, for which the optimal
Krylov solver is the Conjugate Gradient (CG) method. Incomplete
LU factorization (ILU) is a popular and
robust all-round preconditioner, so let us try the CG-ILU pair:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span>
                         <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">})</span>
<span class="c"># Alternative syntax</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">linear_solver</span><span class="o">=</span><span class="s">&#39;cg&#39;</span><span class="p">,</span>
                             <span class="n">preconditioner</span><span class="o">=</span><span class="s">&#39;ilu&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>the section <a class="reference internal" href="#tut-app-solver-prec"><em>Linear Solvers and Preconditioners</em></a> lists the most
popular choices of Krylov solvers and preconditioners available in
FEniCS</p>
<span class="target" id="index-20"></span><span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><p id="index-24">The actual CG and ILU implementations that are brought into action depends on
the choice of linear algebra package. FEniCS interfaces
several linear algebra packages, called <em>linear algebra backends</em>
in FEniCS terminology.
PETSc is the default choice if DOLFIN is compiled with PETSc,
otherwise uBLAS.  Epetra (Trilinos) and MTL4 are two other
supported backends.
Which backend to apply can
be controlled by setting</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">backendname</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">backendname</span></tt> is a string, either <tt class="docutils literal"><span class="pre">'PETSc'</span></tt>, <tt class="docutils literal"><span class="pre">'uBLAS'</span></tt>,
<tt class="docutils literal"><span class="pre">'Epetra'</span></tt>, or <tt class="docutils literal"><span class="pre">'MTL4'</span></tt>.  All these backends offer high-quality
implementations of both iterative and direct solvers for linear systems
of equations.</p>
<p id="index-25">A common platform for FEniCS users is Ubuntu Linux.  The FEniCS
distribution for Ubuntu contains PETSc, making this package the default
linear algebra backend.  The default solver is sparse LU decomposition
(<tt class="docutils literal"><span class="pre">'lu'</span></tt>), and the actual software that is called
is then the sparse LU solver from UMFPACK (which PETSc has an
interface to). The <tt class="docutils literal"><span class="pre">MTL4</span></tt> package is not available in Ubuntu, so
this choice of backend unavailable to FEniCS users on Ubuntu unless they
build FEniCS from the source code. There is a tool
<a class="reference external" href="http://fenicsproject.org/download/installation_using_dorsal.html">Dorsal</a>
that performs the build process automatically.  The available linear
algebra backends in a FEniCS installation is listed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">list_linear_algebra_backends</span><span class="p">()</span>
</pre></div>
</div>
<span class="target" id="index-26"></span><p id="index-27">We will normally like to control
the tolerance in the stopping criterion and the maximum number
of iterations when running an iterative method.
Such parameters can be set by accessing
the <em>global parameter database</em>, which is called
<tt class="docutils literal"><span class="pre">parameters</span></tt> and which behaves as a nested dictionary. Write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">info</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>to list all parameters and their default values in the database.
The nesting of parameter sets is indicated through indentation in the
output from <tt class="docutils literal"><span class="pre">info</span></tt>.
According to this output, the relevant parameter set is
named <tt class="docutils literal"><span class="pre">'krylov_solver'</span></tt>, and the parameters are set like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-10</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Stopping criteria for Krylov solvers usually involve the norm of
the residual, which must be smaller than the absolute tolerance
parameter <em>or</em> smaller than the relative tolerance parameter times
the initial residual.</p>
<p>To see the number of actual iterations to reach the stopping criterion,
we can insert</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
</pre></div>
</div>
<p>A message with the equation system size, solver type, and number of
iterations arises from specifying the argument <tt class="docutils literal"><span class="pre">PROGRESS</span></tt>, while
<tt class="docutils literal"><span class="pre">DEBUG</span></tt> results in more information, including CPU time spent in
the various parts of the matrix assembly and solve process.</p>
<p>The complete solution process with control of the solver parameters
now contains the statements</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prm</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-10</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-6</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>

<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span>
      <span class="n">solver_parameters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;linear_solver&#39;</span><span class="p">:</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span>
                         <span class="s">&#39;preconditioner&#39;</span><span class="p">:</span> <span class="s">&#39;ilu&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>The demo program <tt class="docutils literal"><span class="pre">d2_p2D.py</span></tt> in the
<tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory incorporates the above shown control
of the linear solver and precnditioner, but
is otherwise similar to the previous <tt class="docutils literal"><span class="pre">d1_p2D.py</span></tt> program.</p>
<p>We remark that default values for the global parameter database can be
defined in an XML file, see the example file <tt class="docutils literal"><span class="pre">dolfin_parameters.xml</span></tt> in the
directory <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>.  If such a file is
found in the directory where a FEniCS program is run, this file is
read and used to initialize the <tt class="docutils literal"><span class="pre">parameters</span></tt> object. Otherwise,
the file <tt class="docutils literal"><span class="pre">.config/fenics/dolfin_parameters.xml</span></tt> in the user&#8217;s home
directory is read, if it exists.  The XML file can also be in gzip&#8217;ed form
with the extension <tt class="docutils literal"><span class="pre">.xml.gz</span></tt>.</p>
</div>
<div class="section" id="linear-variational-problem-and-solver-objects">
<span id="tut-poisson1-solver-problem"></span><h2>Linear Variational Problem and Solver Objects<a class="headerlink" href="#linear-variational-problem-and-solver-objects" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-28"></span><span class="target" id="index-29"></span><p id="index-30">The <tt class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></tt> call is just a compact syntax alternative to a
slightly more comprehensive specification of the variational equation
and the solution of the associated linear system.  This alternative
syntax is used in a lot of FEniCS applications and will also be
used later in this tutorial, so we show it already now:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>Many objects have an attribute <tt class="docutils literal"><span class="pre">parameters</span></tt> corresponding to
a parameter set in the global <tt class="docutils literal"><span class="pre">parameters</span></tt> database,
but local to the object. Here, <tt class="docutils literal"><span class="pre">solver.parameters</span></tt> play that
role. Setting the CG method with ILU preconditiong as solution
method and specifying solver-specific parameters can be done
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;cg&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
<span class="n">cg_prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">]</span> <span class="c"># short form</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">cg_prm</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">info(solver.parameters,</span> <span class="pre">True)</span></tt> lists all the available
parameter sets with default values for each parameter.
Settings in the global <tt class="docutils literal"><span class="pre">parameters</span></tt> database are
propagated to parameter sets in individual objects, with the
possibility of being overwritten as done above.</p>
<p>The <tt class="docutils literal"><span class="pre">d3_p2D.py</span></tt> program modifies the <tt class="docutils literal"><span class="pre">d2_p2D.py</span></tt> file
to incorporate objects for the variational problem and solver.</p>
</div>
<div class="section" id="examining-the-discrete-solution">
<span id="tut-poisson1-verify1"></span><h2>Examining the Discrete Solution<a class="headerlink" href="#examining-the-discrete-solution" title="Permalink to this headline">¶</a></h2>
<p id="index-31">We know that, in the particular boundary-value problem of the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation  (1)</em></a>, the computed solution <span class="math">\(u\)</span> should equal the
exact solution at the vertices of the cells.  An important extension
of our first program is therefore to examine the computed values of
the solution, which is the focus of the present section.</p>
<p>A finite element function like <span class="math">\(u\)</span> is expressed as a linear combination
of basis functions <span class="math">\(\phi_j\)</span>, spanning the space <span class="math">\(V\)</span>:</p>
<div class="math" id="equation-tut:poisson1:ufem">
<span class="eqno">(11)</span>\[     \sum_{j=1}^N U_j \phi_j {\thinspace . }\]</div>
<p>By writing <tt class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bc)</span></tt> in the program, a linear system
will be formed from <span class="math">\(a\)</span> and <span class="math">\(L\)</span>, and this system is solved for the
<span class="math">\(U_1,\ldots,U_N\)</span> values. The <span class="math">\(U_1,\ldots,U_N\)</span> values are known</p>
<p id="index-32">as <em>degrees of freedom</em> of <span class="math">\(u\)</span>. For Lagrange elements (and many other
element types) <span class="math">\(U_k\)</span> is simply the value of <span class="math">\(u\)</span> at the node
with global number <span class="math">\(k\)</span>.
(The nodes and cell vertices coincide for linear Lagrange elements, while
for higher-order elements there may be additional nodes at
the facets and in the interior of cells.)</p>
<p>Having <tt class="docutils literal"><span class="pre">u</span></tt> represented as a <tt class="docutils literal"><span class="pre">Function</span></tt> object,
we can either evaluate <tt class="docutils literal"><span class="pre">u(x)</span></tt> at any vertex <tt class="docutils literal"><span class="pre">x</span></tt> in the mesh,
or we can grab all the values
<span class="math">\(U_j\)</span> directly by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_nodal_values</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
</pre></div>
</div>
<p>The result is a DOLFIN <tt class="docutils literal"><span class="pre">Vector</span></tt> object, which is basically an
encapsulation of the vector object used in the linear algebra package
that is used to solve the linear system arising from the
variational problem.
Since we program in Python it is convenient to convert the
<tt class="docutils literal"><span class="pre">Vector</span></tt> object to a standard <tt class="docutils literal"><span class="pre">numpy</span></tt> array for further
processing:</p>
<span class="target" id="index-33"></span><div class="highlight-python" id="index-34"><div class="highlight"><pre><span class="n">u_array</span> <span class="o">=</span> <span class="n">u_nodal_values</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>With <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays we can write &#8220;MATLAB-like&#8221; code to analyze
the data. Indexing is done with square brackets: <tt class="docutils literal"><span class="pre">u_array[i]</span></tt>,
where the index <tt class="docutils literal"><span class="pre">i</span></tt> always starts at <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>Mesh information can be gathered from the <tt class="docutils literal"><span class="pre">mesh</span></tt> object, e.g.,</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">mesh.coordinates()</span></tt> returns the coordinates of the
vertices as a <tt class="docutils literal"><span class="pre">numpy</span></tt> array with shape
(<em>number of vertices</em>, <em>number of space dimensions</em>),
<span class="math">\(M\)</span> being the number of vertices in the mesh and <span class="math">\(d\)</span> being
the number of space dimensions,</li>
<li><tt class="docutils literal"><span class="pre">mesh.num_cells()</span></tt> returns the number of cells (triangles)
in the mesh,</li>
<li><tt class="docutils literal"><span class="pre">mesh.num_vertices()</span></tt> returns the number of vertices in
the mesh (with our choice of linear Lagrange elements this equals the
number of nodes),</li>
<li><tt class="docutils literal"><span class="pre">mesh.cells()</span></tt> returns the vertex numbers of the vertices in
each cell as a <tt class="docutils literal"><span class="pre">numpy</span></tt> array with shape
(<em>number of cells</em>, <em>number of vertices in a cell</em>),</li>
<li><tt class="docutils literal"><span class="pre">mesh.hmin()</span></tt> returns the minimum cell diameter (&#8220;smallest cell&#8221;),</li>
<li><tt class="docutils literal"><span class="pre">mesh.hmax()</span></tt> returns the maximum cell diameter (&#8220;largest cell&#8221;).</li>
</ul>
</div></blockquote>
<p>Writing <tt class="docutils literal"><span class="pre">print</span> <span class="pre">mesh</span></tt> dumps a short, &#8220;pretty print&#8221; description
of the mesh (<tt class="docutils literal"><span class="pre">print</span> <span class="pre">mesh</span></tt> actually displays the result of str(mesh)`,
which defines the pretty print):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">&lt;</span><span class="n">Mesh</span> <span class="n">of</span> <span class="n">topological</span> <span class="n">dimension</span> <span class="mi">2</span> <span class="p">(</span><span class="n">triangles</span><span class="p">)</span> <span class="k">with</span>
<span class="mi">16</span> <span class="n">vertices</span> <span class="ow">and</span> <span class="mi">18</span> <span class="n">cells</span><span class="p">,</span> <span class="n">ordered</span><span class="o">&gt;</span>
</pre></div>
</div>
<p id="index-35">All mesh objects are of type <tt class="docutils literal"><span class="pre">Mesh</span></tt> so typing the command
<tt class="docutils literal"><span class="pre">pydoc</span> <span class="pre">dolfin.Mesh</span></tt> in a terminal window will give a list
of methods (that is, functions in a class)
that can be called through any <tt class="docutils literal"><span class="pre">Mesh</span></tt> object. In fact,
<tt class="docutils literal"><span class="pre">pydoc</span> <span class="pre">dolfin.X</span></tt> shows the documentation of any DOLFIN name <tt class="docutils literal"><span class="pre">X</span></tt>.</p>
<p>Writing out the solution on the screen can now be done by a simple loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">u_array</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()):</span>
        <span class="k">print</span> <span class="s">&#39;u(</span><span class="si">%8g</span><span class="s">,</span><span class="si">%8g</span><span class="s">) = </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">coor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>The beginning of the output looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">(</span>       <span class="mi">0</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.166667</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.02778</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.333333</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.11111</span>
<span class="n">u</span><span class="p">(</span>     <span class="mf">0.5</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.25</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.666667</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.44444</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.833333</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.69444</span>
<span class="n">u</span><span class="p">(</span>       <span class="mi">1</span><span class="p">,</span>       <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>For Lagrange elements of degree higher than one, the vertices do not
correspond to all the nodal points and the <tt class="docutils literal"><span class="pre">if</span></tt>-test fails.</p>
<p>For verification purposes we want to compare the values of the
computed <tt class="docutils literal"><span class="pre">u</span></tt> at the nodes (given by <tt class="docutils literal"><span class="pre">u_array</span></tt>) with the exact
solution <tt class="docutils literal"><span class="pre">u0</span></tt> evaluated at the nodes.  The difference between the
computed and exact solution should be less than a small tolerance at
all the nodes. The <tt class="docutils literal"><span class="pre">Expression</span></tt> object <tt class="docutils literal"><span class="pre">u0</span></tt> can be evaluated
at any point <tt class="docutils literal"><span class="pre">x</span></tt> by calling <tt class="docutils literal"><span class="pre">u0(x)</span></tt>. Specifically,
<tt class="docutils literal"><span class="pre">u0(coor[i])</span></tt> returns the value of <tt class="docutils literal"><span class="pre">u0</span></tt> at the vertex or node
with global number <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
<span class="target" id="index-36"></span><p id="index-37">Alternatively, we can make a finite element field <tt class="docutils literal"><span class="pre">u_e</span></tt>, representing
the exact solution, whose values at the nodes are given by the
<tt class="docutils literal"><span class="pre">u0</span></tt> function. With mathematics, <span class="math">\(u_{\mbox{e}} = \sum_{j=1}^N  E_j\phi_j\)</span>, where
<span class="math">\(E_j=u_0(x_j,y_j)\)</span>, <span class="math">\((x_j,y_j)\)</span> being the coordinates of node number <span class="math">\(j\)</span>.
This process is known as interpolation.
FEniCS has a function for performing the operation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>The maximum error can now be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e_array</span> <span class="o">=</span> <span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;Max error:&#39;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e_array</span> <span class="o">-</span> <span class="n">u_array</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>The value of the error should be at the level of the machine precision
(<span class="math">\(10^{-16}\)</span>).</p>
<p>To demonstrate the use of point evaluations of <tt class="docutils literal"><span class="pre">Function</span></tt> objects,
we write out the computed <tt class="docutils literal"><span class="pre">u</span></tt> at the center point
of the domain and compare it with the exact solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;numerical u at the center point:&#39;</span><span class="p">,</span>  <span class="n">u</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;exact     u at the center point:&#39;</span><span class="p">,</span> <span class="n">u0</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
</pre></div>
</div>
<p>Trying a <span class="math">\(3\times 3\)</span> mesh, the output from the
previous snippet becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numerical</span> <span class="n">u</span> <span class="n">at</span> <span class="n">the</span> <span class="n">center</span> <span class="n">point</span><span class="p">:</span> <span class="p">[</span> <span class="mf">1.83333333</span><span class="p">]</span>
<span class="n">exact</span>     <span class="n">u</span> <span class="n">at</span> <span class="n">the</span> <span class="n">center</span> <span class="n">point</span><span class="p">:</span> <span class="p">[</span> <span class="mf">1.75</span><span class="p">]</span>
</pre></div>
</div>
<p>The discrepancy is due to the fact that the center point is not a node
in this particular mesh, but a point in the interior of a cell,
and <tt class="docutils literal"><span class="pre">u</span></tt> varies linearly over the cell while
<tt class="docutils literal"><span class="pre">u0</span></tt> is a quadratic function.</p>
<p>We have seen how to extract the nodal values in a <tt class="docutils literal"><span class="pre">numpy</span></tt> array.
If desired, we can adjust the nodal values too. Say we want to
normalize the solution such that <span class="math">\(\max_j U_j = 1\)</span>. Then we
must divide all <span class="math">\(U_j\)</span> values
by <span class="math">\(\max_j U_j\)</span>. The following snippet performs the task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">max_u</span> <span class="o">=</span> <span class="n">u_array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">u_array</span> <span class="o">/=</span> <span class="n">max_u</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_array</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">set_local</span><span class="p">(</span><span class="n">u_array</span><span class="p">)</span>  <span class="c"># alternative</span>
<span class="k">print</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>That is, we manipulate <tt class="docutils literal"><span class="pre">u_array</span></tt> as desired, and then
we insert this array into <tt class="docutils literal"><span class="pre">u</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">Vector</span></tt> object.
The <tt class="docutils literal"><span class="pre">/=</span></tt> operator implies an
in-place modification of the object on the left-hand side: all
elements of the <tt class="docutils literal"><span class="pre">u_array</span></tt> are divided by the value <tt class="docutils literal"><span class="pre">max_u</span></tt>.
Alternatively, one could write
<tt class="docutils literal"><span class="pre">u_array</span> <span class="pre">=</span> <span class="pre">u_array/max_u</span></tt>, which implies creating a new
array on the right-hand side and assigning this array to the
name <tt class="docutils literal"><span class="pre">u_array</span></tt>.</p>
<p>A call like <tt class="docutils literal"><span class="pre">u.vector().array()</span></tt> returns a copy of the data in
<tt class="docutils literal"><span class="pre">u.vector()</span></tt>. One must therefore never perform assignments like
<tt class="docutils literal"><span class="pre">u.vector.array()[:]</span> <span class="pre">=</span> <span class="pre">...</span></tt>, but instead extract the
<tt class="docutils literal"><span class="pre">numpy</span></tt> array (i.e., a copy), manipulate it, and insert
it back with <tt class="docutils literal"><span class="pre">u.vector()[:]</span> <span class="pre">=</span> <span class="pre">``</span> <span class="pre">or</span> <span class="pre">``u.set_local(...)</span></tt>.</p>
<p>All the code in this subsection can be found in the file
<tt class="docutils literal"><span class="pre">d4_p2D.py</span></tt> in the <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory.
We have commented out the plotting statements in
this version of the program, but if you want plotting to happen, make
sure that <tt class="docutils literal"><span class="pre">interactive</span></tt> is called at the very end of the program.</p>
</div>
<div class="section" id="solving-a-real-physical-problem">
<span id="tut-poisson-membrane"></span><h2>Solving a Real Physical Problem<a class="headerlink" href="#solving-a-real-physical-problem" title="Permalink to this headline">¶</a></h2>
<p>Perhaps you are not particularly amazed by viewing the simple surface
of <span class="math">\(u\)</span> in the test problem from the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation  (1)</em></a>.
However, solving a real physical problem
with a more interesting and amazing solution on the screen is only a
matter of specifying a more exciting domain, boundary condition,
and/or right-hand side <span class="math">\(f\)</span>.</p>
<p>One possible physical problem regards the deflection
<span class="math">\(D(x,y)\)</span> of an elastic circular membrane
with radius <span class="math">\(R\)</span>, subject to a localized perpendicular pressure
force, modeled as a Gaussian function.
The appropriate PDE model is</p>
<div class="math">
\[-T\nabla^2 D = p(x,y)\quad\hbox{in }\Omega = \{ (x,y)\,|\, x^2+y^2\leq R\},\]</div>
<p>with</p>
<div class="math">
\[p(x,y) = {A\over 2\pi\sigma}\exp{\left(
- {1\over2}\left( {x-x_0\over\sigma}\right)^2
- {1\over2}\left( {y-y_0\over\sigma}\right)^2
\right)}\, .\]</div>
<p>Here, <span class="math">\(T\)</span> is the tension in the membrane (constant), <span class="math">\(p\)</span> is the external
pressure load,
<span class="math">\(A\)</span> the amplitude of the pressure, <span class="math">\((x_0,y_0)\)</span> the localization of
the Gaussian pressure function, and <span class="math">\(\sigma\)</span> the &#8220;width&#8221; of this
function. The boundary of the membrane has no
deflection, implying <span class="math">\(D=0\)</span> as boundary condition.</p>
<p>For scaling and verification it is convenient to simplify the problem
to find an analytical solution. In the limit <span class="math">\(\sigma\rightarrow\infty\)</span>,
<span class="math">\(p\rightarrow A/(2\pi\sigma)\)</span>, which allows us to integrate an axi-symmetric
version of the equation in the radial coordinate <span class="math">\(r\in [0,R]\)</span> and
obtain <span class="math">\(D(r)=(r^2-R^2)A/(8\pi\sigma T)\)</span>. This result gives
a rough estimate of the characteristic size of the deflection:
<span class="math">\(|D(0)|=AR^2/(8\pi\sigma T)\)</span>, which can be used to scale the deflecton.
With <span class="math">\(R\)</span> as characteristic length scale, we can derive the equivalent
dimensionless problem on the unit circle,</p>
<div class="math" id="equation-tut:poisson1:membrane:scaled:eq">
<span class="eqno">(12)</span>\[     -\nabla^2 w = f,\]</div>
<p>with <span class="math">\(w=0\)</span> on the boundary and with</p>
<div class="math" id="equation-tut:poisson1:membrane:scaled:eq:rhs">
<span class="eqno">(13)</span>\[     \
     f(x,y) = 4\exp{\left(
     - \frac{1}{2}\left( \frac{Rx-x_0}{\sigma}\right)^2
     - \frac{1}{2}\left( \frac{Ry-y_0}{\sigma}\right)^2
     \right)}.\]</div>
<p>For notational convenience we have dropped introducing new symbols
for the scaled
coordinates in <a href="#equation-tut:poisson1:membrane:scaled:eq:rhs">(13)</a>.
Now <span class="math">\(D\)</span> is related to <span class="math">\(w\)</span> through <span class="math">\(D = AR^2w/(8\pi\sigma T)\)</span>.</p>
<p>Let us list the modifications of the
<tt class="docutils literal"><span class="pre">d1_p2D.py</span></tt> program that are needed to solve this membrane problem:</p>
<blockquote>
<div><ul class="simple">
<li>Initialize <span class="math">\(T\)</span>, <span class="math">\(A\)</span>, <span class="math">\(R\)</span>, <span class="math">\(x_0\)</span>, <span class="math">\(y_0\)</span>, and <span class="math">\(\sigma\)</span>,</li>
<li>create a mesh over the unit circle,</li>
<li>make an expression object for the scaled pressure function <span class="math">\(f\)</span>,</li>
<li>define the <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> formulas in the variational
problem for <span class="math">\(w\)</span> and compute the solution,</li>
<li>plot the mesh, <span class="math">\(w\)</span>, and <span class="math">\(f\)</span>,</li>
<li>write out the maximum real deflection <span class="math">\(D\)</span>.</li>
</ul>
</div></blockquote>
<p>Some suitable values of <span class="math">\(T\)</span>, <span class="math">\(A\)</span>, <span class="math">\(R\)</span>, <span class="math">\(x_0\)</span>, <span class="math">\(y_0\)</span>, and <span class="math">\(\sigma\)</span> are</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="mf">10.0</span>  <span class="c"># tension</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c"># pressure amplitude</span>
<span class="n">R</span> <span class="o">=</span> <span class="mf">0.3</span>   <span class="c"># radius of domain</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.025</span>
</pre></div>
</div>
<p>A mesh over the unit circle can be created by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCircleMesh</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">n</span></tt> is the typical number of elements in the radial direction.</p>
<span class="target" id="index-38"></span><p id="index-39">The function <span class="math">\(f\)</span> is represented by an <tt class="docutils literal"><span class="pre">Expression</span></tt> object. There
are many physical parameters in the formula for <span class="math">\(f\)</span> that enter the
expression string and these parameters must have their values set
by keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;4*exp(-0.5*(pow((R*x[0] - x0)/sigma, 2)) &#39;</span>
               <span class="s">&#39;     - 0.5*(pow((R*x[1] - y0)/sigma, 2)))&#39;</span><span class="p">,</span>
               <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
</pre></div>
</div>
<p>The coordinates in <tt class="docutils literal"><span class="pre">Expression</span></tt> objects <em>must</em> be a vector
with indices 0, 1, and 2, and with the name <tt class="docutils literal"><span class="pre">x</span></tt>. Otherwise
we are free to introduce names of parameters as long as these are
given default values by keyword arguments. All the parameters
initialized by keyword arguments can at any time have their
values modified. For example, we may set</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">f</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="mf">0.3</span>
</pre></div>
</div>
<p id="index-40">It would be of interest to visualize <span class="math">\(f\)</span> along with <span class="math">\(w\)</span> so that we can
examine the pressure force and its response.  We must then transform
the formula (<tt class="docutils literal"><span class="pre">Expression</span></tt>) to a finite element function
(<tt class="docutils literal"><span class="pre">Function</span></tt>).  The most natural approach is to construct a finite
element function whose degrees of freedom (values at the nodes in this case) are
calculated from <span class="math">\(f\)</span>. That is, we interpolate <span class="math">\(f\)</span> (see
the section <a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">plot(f)</span></tt> will produce a plot of <span class="math">\(f\)</span>. Note that the assignment
to <tt class="docutils literal"><span class="pre">f</span></tt> destroys the previous <tt class="docutils literal"><span class="pre">Expression</span></tt> object <tt class="docutils literal"><span class="pre">f</span></tt>, so if
it is of interest to still have access to this object, another name must be used
for the <tt class="docutils literal"><span class="pre">Function</span></tt> object returned by <tt class="docutils literal"><span class="pre">interpolate</span></tt>.</p>
<p>We need some evidence that the program works, and to this end we may
use the analytical solution listed above for the case
<span class="math">\(\sigma\rightarrow\infty\)</span>. In scaled coordinates the solution reads</p>
<div class="math">
\[w_{\rm}(x,y) = 1-x^2-y^2 .\]</div>
<p>Practical values for an infinite <span class="math">\(\sigma\)</span>
may be 50 or larger, and in such cases the program will report the
maximum deviation between the computed <span class="math">\(w\)</span> and the (approximate) exact
<span class="math">\(w_{\rm e}\)</span>.</p>
<p id="index-41">Note that the variational formulation remains the same as in the
program from the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation  (1)</em></a>, except that <span class="math">\(u\)</span> is
replaced by <span class="math">\(w\)</span> and <span class="math">\(u_0=0\)</span>.
The final program is found in the file <tt class="docutils literal"><span class="pre">membrane1.py</span></tt>, located
in the <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory, and also listed below.
We have inserted capabilities for iterative solution methods and
hence large meshes (the section <a class="reference internal" href="#tut-poisson1-solve-prm"><em>Controlling the Solution Process</em></a>),
used objects for the variational problem and solver
(the section <a class="reference internal" href="#tut-poisson1-solver-problem"><em>Linear Variational Problem and Solver Objects</em></a>), and made numerical
comparison of the numerical and (approximate) analytical solution
(the section <a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c"># Set pressure function:</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">10.0</span>  <span class="c"># tension</span>
<span class="n">A</span> <span class="o">=</span> <span class="mf">1.0</span>   <span class="c"># pressure amplitude</span>
<span class="n">R</span> <span class="o">=</span> <span class="mf">0.3</span>   <span class="c"># radius of domain</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.025</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c"># large value for verification</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">40</span>   <span class="c"># approx no of elements in radial direction</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCircleMesh</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Define boundary condition w=0</span>
<span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="c"># Define variational problem</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;4*exp(-0.5*(pow((R*x[0] - x0)/sigma, 2)) &#39;</span>
               <span class="s">&#39;      -0.5*(pow((R*x[1] - y0)/sigma, 2)))&#39;</span><span class="p">,</span>
               <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Compute solution</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;cg&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="c"># Plot scaled solution, mesh and pressure</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Mesh over scaled domain&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled deflection&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled pressure&#39;</span><span class="p">)</span>

<span class="c"># Find maximum real deflection</span>
<span class="n">max_w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">max_D</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">max_w</span><span class="o">/</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">T</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;Maximum real deflection is&#39;</span><span class="p">,</span> <span class="n">max_D</span>

<span class="c"># Verification for &quot;flat&quot; pressure (large sigma)</span>
<span class="k">if</span> <span class="n">sigma</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">:</span>
    <span class="n">w_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&quot;1 - x[0]*x[0] - x[1]*x[1]&quot;</span><span class="p">)</span>
    <span class="n">w_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">w_e</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">dev</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">w</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;sigma=</span><span class="si">%g</span><span class="s">: max deviation=</span><span class="si">%e</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>

<span class="c"># Should be at the end</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>Choosing a small width <span class="math">\(\sigma\)</span> (say 0.01) and a location <span class="math">\((x_0,y_0)\)</span>
toward the circular boundary (say <span class="math">\((0.6R\cos\theta, 0.6R\sin\theta)\)</span>
for any <span class="math">\(\theta\in [0,2\pi]\)</span>), may produce an exciting visual
comparison of <span class="math">\(w\)</span> and <span class="math">\(f\)</span> that demonstrates the very smoothed elastic
response to a peak force (or mathematically, the smoothing properties
of the inverse of the Laplace operator).  One needs to experiment with
the mesh resolution to get a smooth visual representation of~$f$.  You
are strongly encouraged to play around with the plots and different
mesh resolutions.</p>
</div>
<div class="section" id="quick-visualization-with-vtk">
<span id="tut-quickviz"></span><h2>Quick Visualization with VTK<a class="headerlink" href="#quick-visualization-with-vtk" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-42"></span><span class="target" id="index-43"></span><p id="index-44">As we go along with examples it is fun to play around with
<tt class="docutils literal"><span class="pre">plot</span></tt> commands and visualize what is computed. This section explains
some useful visualization features.</p>
<p>The <tt class="docutils literal"><span class="pre">plot</span></tt> command applies the VTK package to visualize finite element
functions in a very quick and simple way.  The command is ideal for
debugging, teaching, and initial scientific investigations.  The
visualization can be interactive, or you can steer and automate it
through program statements.  More advanced and professional
visualizations are usually better created with advanced tools like
Mayavi, ParaView, or VisIt.</p>
<p id="index-45">We have made a program <tt class="docutils literal"><span class="pre">membrane1v.py</span></tt> for the membrane deflection
problem in the section <a class="reference internal" href="#tut-poisson-membrane"><em>Solving a Real Physical Problem</em></a> and added various
demonstrations of Viper capabilities. You are encouraged to play around with
<tt class="docutils literal"><span class="pre">membrane1v.py</span></tt> and modify the code as you read about various features.</p>
<p id="index-46">The <tt class="docutils literal"><span class="pre">plot</span></tt> function can take additional arguments, such as
a title of the plot, or a specification of a wireframe plot (elevated mesh)
instead of a colored surface plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Finite element mesh&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">wireframe</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The left mouse button is used to rotate the surface, while the right
button can zoom the image in and out.
Point the mouse to the <tt class="docutils literal"><span class="pre">Help</span></tt> text down in the lower left corner to
get a list of all the keyboard commands that are available.
For example,</p>
<blockquote>
<div><ul class="simple">
<li>pressing <tt class="docutils literal"><span class="pre">m</span></tt> turns visualization of the mesh on and off,</li>
<li>pressing <tt class="docutils literal"><span class="pre">b</span></tt> turns on and off a bounding box,</li>
<li>pressing <tt class="docutils literal"><span class="pre">p</span></tt> dumps the plot to a PNG file,</li>
<li>pressing <tt class="docutils literal"><span class="pre">P</span></tt> dumps the plot to a PDF file,</li>
<li>pressing <cite>Ctrl +&#8217; stretches the surface in the :math:`z</cite> direction,</li>
<li>pressing <cite>Ctrl -&#8216; shrinks++ the surface in the :math:`z</cite> direction,</li>
<li>pressing <a href="#id3"><span class="problematic" id="id4">`</span></a>Ctrl w&#8217; closes the plot window,</li>
<li>pressing <a href="#id5"><span class="problematic" id="id6">`</span></a>Ctrl q&#8217; closes all plot windows.</li>
</ul>
</div></blockquote>
<p>The plots created by pressing <tt class="docutils literal"><span class="pre">p</span></tt> or <tt class="docutils literal"><span class="pre">P</span></tt> are stored in files with
names <tt class="docutils literal"><span class="pre">dolfin_plot_X.png</span></tt> or <tt class="docutils literal"><span class="pre">dolfin_plot_X.pdf</span></tt>,
where <tt class="docutils literal"><span class="pre">X</span></tt> is an integer that is increase by one from the last plot
that was made. The file stem <tt class="docutils literal"><span class="pre">dolfin_plot_</span></tt> can be set to something
more suitable through the <tt class="docutils literal"><span class="pre">prefix</span></tt> keyword argument to <tt class="docutils literal"><span class="pre">plot</span></tt>,
for instance, <tt class="docutils literal"><span class="pre">plot(f,</span> <span class="pre">prefix='pressure')</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">plot</span></tt> function takes several other keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">viz_w</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span>
             <span class="n">mode</span><span class="o">=</span><span class="s">&#39;warp&#39;</span><span class="p">,</span>     <span class="c"># &#39;color&#39; gives flat color plot</span>
             <span class="n">wireframe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="c"># True: elevated mesh</span>
             <span class="n">title</span><span class="o">=</span><span class="s">&#39;Scaled membrane deflection&#39;</span><span class="p">,</span>
             <span class="n">scale</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>       <span class="c"># stretch z axis by a factor of 3</span>
             <span class="n">elevate</span><span class="o">=-</span><span class="mf">75.0</span><span class="p">,</span>   <span class="c"># tilt camera -75 degrees</span>
             <span class="n">scalarbar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>  <span class="c"># show colorbar</span>
             <span class="n">axes</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>      <span class="c"># do not show X, Y, Z axes</span>
             <span class="n">window_width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span>
             <span class="n">window_height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>
             <span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#tut-poisson-2d-fig1"><em>Plot of the deflection of a membrane</em></a> shows the resulting scalar surface.</p>
<p>By grabbing the plotting object created by the <tt class="docutils literal"><span class="pre">plot</span></tt> function we can
create a PNG and PDF plot in the program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">viz_w</span><span class="o">.</span><span class="n">write_png</span><span class="p">(</span><span class="s">&#39;membrane_deflection&#39;</span><span class="p">)</span>
<span class="n">viz_w</span><span class="o">.</span><span class="n">write_pdf</span><span class="p">(</span><span class="s">&#39;tmp&#39;</span><span class="p">)</span>
<span class="c"># Rotate pdf file (right) from landscape to portrait</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&#39;pdftk tmp.pdf cat 1-endR output membrane_deflection.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure" id="tut-poisson-2d-fig1">
<img alt="_images/membrane_deflection.png" src="_images/membrane_deflection.png" style="width: 480px;" />
<p class="caption"><em>Plot of the deflection of a membrane</em></p>
</div>
</div>
<div class="section" id="computing-derivatives">
<span id="tut-poisson-gradu"></span><h2>Computing Derivatives<a class="headerlink" href="#computing-derivatives" title="Permalink to this headline">¶</a></h2>
<p>In Poisson and many other problems the gradient of the solution is
of interest. The computation is in principle simple:
since
<span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>, we have that</p>
<div class="math">
\[\nabla u = \sum_{j=1}^N U_j \nabla \phi_j{\thinspace . }\]</div>
<p>Given the solution variable <tt class="docutils literal"><span class="pre">u</span></tt> in the program, its gradient is
obtained by <tt class="docutils literal"><span class="pre">grad(u)</span></tt> or <tt class="docutils literal"><span class="pre">nabla_grad(u)</span></tt>.
However, the gradient of a piecewise continuous
finite element scalar field
is a discontinuous vector field
since the <span class="math">\(\phi_j\)</span> has discontinuous derivatives at the boundaries of
the cells. For example, using Lagrange elements of degree 1, <span class="math">\(u\)</span> is
linear over each cell, and the numerical <span class="math">\(\nabla u\)</span> becomes a piecewise
constant vector field. On the contrary,
the exact gradient is continuous.
For visualization and data analysis purposes
we often want the computed
gradient to be a continuous vector field. Typically,
we want each component of <span class="math">\(\nabla u\)</span> to be represented in the same
way as <span class="math">\(u\)</span> itself. To this end, we can project the components
of <span class="math">\(\nabla u\)</span> onto the
same function space as we used for <span class="math">\(u\)</span>.
This means that we solve <span class="math">\(w = \nabla u\)</span> approximately by a finite element
method, using the same elements for the components of
<span class="math">\(w\)</span> as we used for <span class="math">\(u\)</span>. This process is known as <em>projection</em>.</p>
<p id="index-47">Looking at the component <span class="math">\(\partial
u/\partial x\)</span> of the gradient, we project the (discrete) derivative
<span class="math">\(\sum_jU_j{\partial \phi_j/\partial x}\)</span> onto a function space
with basis <span class="math">\(\phi_1,\phi_2,\ldots\)</span> such that the derivative in
this space is expressed by the standard sum <span class="math">\(\sum_j\bar U_j \phi_j\)</span>,
for suitable (new) coefficients <span class="math">\(\bar U_j\)</span>.</p>
<p>The variational problem for <span class="math">\(w\)</span> reads: find  <span class="math">\(w\in V^{(\mbox{g})}\)</span> such that</p>
<div class="math">
\[a(w, v) = L(v)\quad\forall v\in \hat{V^{(\mbox{g})}},\]</div>
<p>where</p>
<div class="math">
\[a(w, v) = \int_\Omega w\cdot v {\, \mathrm{d}x},\]</div>
<div class="math">
\[L(v) = \int_\Omega \nabla u\cdot v {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>The function spaces <span class="math">\(V^{(\mbox{g})}\)</span> and <span class="math">\(\hat{V^{(\mbox{g})}}\)</span> (with the superscript
g denoting &#8220;gradient&#8221;) are
vector versions of the function space for <span class="math">\(u\)</span>, with
boundary conditions removed (if <span class="math">\(V\)</span> is the
space we used for <span class="math">\(u\)</span>, with no restrictions
on boundary values, <span class="math">\(V^{(\mbox{g})} = \hat{V^{(\mbox{g})}} = [V]^d\)</span>, where
<span class="math">\(d\)</span> is the number of space dimensions).
For example, if we used piecewise linear functions on the mesh to
approximate <span class="math">\(u\)</span>, the variational problem for <span class="math">\(w\)</span> corresponds to
approximating each component field of <span class="math">\(w\)</span> by piecewise linear functions.</p>
<p>The variational problem for the vector field
<span class="math">\(w\)</span>, called <tt class="docutils literal"><span class="pre">grad_u</span></tt> in the code, is easy to solve in FEniCS:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">grad_u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">grad_u</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">grad_u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;grad(u)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The boundary condition argument to <tt class="docutils literal"><span class="pre">solve</span></tt> is dropped since there are
no essential boundary conditions in this problem.
The new thing is basically that we work with a <tt class="docutils literal"><span class="pre">VectorFunctionSpace</span></tt>,
since the unknown is now a vector field, instead of the
<tt class="docutils literal"><span class="pre">FunctionSpace</span></tt> object for scalar fields.
Figure <a class="reference internal" href="#tut-poisson-2d-fig-ex1-gradu"><em>Example of visualizing the vector field :math:`nabla u` by arrows at the nodes</em></a> shows
example of how Viper can visualize such a vector field.</p>
<div class="figure" id="tut-poisson-2d-fig-ex1-gradu">
<img alt="_images/ex1_gradu.png" src="_images/ex1_gradu.png" style="width: 480px;" />
<p class="caption"><em>Example of visualizing the vector field :math:`nabla u` by arrows at the nodes</em></p>
</div>
<p>The scalar component fields of the gradient
can be extracted as separate fields and, e.g., visualized:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_x</span><span class="p">,</span> <span class="n">grad_u_y</span> <span class="o">=</span> <span class="n">grad_u</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># extract components</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad_u_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;x-component of grad(u)&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">grad_u_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;y-component of grad(u)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">deepcopy=True</span></tt> argument signifies a <em>deep copy</em>, which is
a general term in computer science implying that a copy of the data is
returned. (The opposite, <tt class="docutils literal"><span class="pre">deepcopy=False</span></tt>,
means a <em>shallow copy</em>, where
the returned objects are just pointers to the original data.)</p>
<span class="target" id="index-48"></span><span class="target" id="index-49"></span><p id="index-50">The <tt class="docutils literal"><span class="pre">grad_u_x</span></tt> and <tt class="docutils literal"><span class="pre">grad_u_y</span></tt> variables behave as
<tt class="docutils literal"><span class="pre">Function</span></tt> objects. In particular, we can extract the underlying
arrays of nodal values by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_x_array</span> <span class="o">=</span> <span class="n">grad_u_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">grad_u_y_array</span> <span class="o">=</span> <span class="n">grad_u_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The degrees of freedom of the <tt class="docutils literal"><span class="pre">grad_u</span></tt> vector field can also be
reached by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u_array</span> <span class="o">=</span> <span class="n">grad_u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>but this is a flat <tt class="docutils literal"><span class="pre">numpy</span></tt> array where the degrees of freedom
for the <span class="math">\(x\)</span> component of the gradient is stored in the first part, then the
degrees of freedom of the <span class="math">\(y\)</span> component, and so on.</p>
<p id="index-51">The program <tt class="docutils literal"><span class="pre">d5_p2D.py</span></tt> extends the
code <tt class="docutils literal"><span class="pre">d5_p2D.py</span></tt> from the section <a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a>
with computations and visualizations of the gradient.
Examining the arrays <tt class="docutils literal"><span class="pre">grad_u_x_array</span></tt>
and <tt class="docutils literal"><span class="pre">grad_u_y_array</span></tt>, or looking at the plots of
<tt class="docutils literal"><span class="pre">grad_u_x</span></tt> and
<tt class="docutils literal"><span class="pre">grad_u_y</span></tt>, quickly reveals that
the computed <tt class="docutils literal"><span class="pre">grad_u</span></tt> field does not equal the exact
gradient <span class="math">\((2x, 4y)\)</span> in this particular test problem where <span class="math">\(u=1+x^2+2y^2\)</span>.
There are inaccuracies at the boundaries, arising from the
approximation problem for <span class="math">\(w\)</span>. Increasing the mesh resolution shows,
however, that the components of the gradient vary linearly as
<span class="math">\(2x\)</span> and <span class="math">\(4y\)</span> in
the interior of the mesh (i.e., as soon as we are one element away from
the boundary). See the section <a class="reference internal" href="#tut-quickviz"><em>Quick Visualization with VTK</em></a> for illustrations of
this phenomenon.</p>
<span class="target" id="index-52"></span><p id="index-53">Projecting some function onto some space is a very common
operation in finite element programs. The manual steps in this process
have therefore been collected in a utility function <tt class="docutils literal"><span class="pre">project(q,</span> <span class="pre">W)</span></tt>,
which returns the projection of some <tt class="docutils literal"><span class="pre">Function</span></tt> or <tt class="docutils literal"><span class="pre">Expression</span></tt> object
named <tt class="docutils literal"><span class="pre">q</span></tt> onto the <tt class="docutils literal"><span class="pre">FunctionSpace</span></tt> or <tt class="docutils literal"><span class="pre">VectorFunctionSpace</span></tt> named <tt class="docutils literal"><span class="pre">W</span></tt>.
Specifically, the previous code for
projecting each component of <tt class="docutils literal"><span class="pre">grad(u)</span></tt> onto
the same space that we use for <tt class="docutils literal"><span class="pre">u</span></tt>, can now be done by a one-line call</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">grad_u</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The applications of projection are many, including turning discontinuous
gradient fields into continuous ones, comparing higher- and lower-order
function approximations, and transforming a higher-order finite element
solution down to a piecewise linear field, which is required by many
visualization packages.</p>
</div>
<div class="section" id="a-variable-coefficient-poisson-problem">
<span id="tut-possion-2d-varcoeff"></span><h2>A Variable-Coefficient Poisson Problem<a class="headerlink" href="#a-variable-coefficient-poisson-problem" title="Permalink to this headline">¶</a></h2>
<p id="index-54">Suppose we have a variable coefficient <span class="math">\(p(x,y)\)</span> in the Laplace operator,
as in the boundary-value problem</p>
<div class="math" id="equation-tut:poisson:2D:varcoeff">
<span class="eqno">(14)</span>\[\begin{split}         - \nabla\cdot \left\lbrack
     p(x,y)\nabla u(x,y)\right\rbrack &amp;= f(x,y) \quad \mbox{in } \Omega,
         \\
         u(x,y) &amp;= u_0(x,y) \quad \mbox{on}\  \partial\Omega{\thinspace . }\end{split}\]</div>
<p>We shall quickly demonstrate that this simple extension of our model
problem only requires an equally simple extension of the FEniCS program.</p>
<p>Let us continue to use our favorite solution <span class="math">\(u(x,y)=1+x^2+2y^2\)</span> and
then prescribe <span class="math">\(p(x,y)=x+y\)</span>. It follows that
<span class="math">\(u_0(x,y) = 1 + x^2 + 2y^2\)</span> and <span class="math">\(f(x,y)=-8x-10y\)</span>.</p>
<p id="index-55">What are the modifications we need to do in the <tt class="docutils literal"><span class="pre">d4_p2D.py</span></tt> program
from the section <a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a>?</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">f</span></tt> must be an <tt class="docutils literal"><span class="pre">Expression</span></tt> since it is no longer a constant,</li>
<li>a new <tt class="docutils literal"><span class="pre">Expression</span></tt> <cite>p</cite> must be defined for the variable coefficient,</li>
<li>the variational problem is slightly changed.</li>
</ul>
</div></blockquote>
<p>First we address the modified variational problem. Multiplying
the PDE by a test function <span class="math">\(v\)</span> and
integrating by parts now results
in</p>
<div class="math">
\[\int_\Omega p\nabla u\cdot\nabla v {\, \mathrm{d}x} -
\int_{\partial\Omega} p{\partial u\over
\partial n}v {\, \mathrm{d}s} = \int_\Omega fv {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>The function spaces for <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are the same as in
the section <a class="reference internal" href="#tut-poisson1-varform"><em>Variational Formulation</em></a>, implying that the boundary integral
vanishes since <span class="math">\(v=0\)</span> on <span class="math">\(\partial\Omega\)</span> where we have Dirichlet conditions.
The weak form <span class="math">\(a(u,v)=L(v)\)</span> then has</p>
<div class="math">
\[a(u,v) = \int_\Omega p\nabla u\cdot\nabla v {\, \mathrm{d}x},\]</div>
<div class="math">
\[L(v) = \int_\Omega fv {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>In the code from the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation  (1)</em></a> we must replace</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The definitions of <tt class="docutils literal"><span class="pre">p</span></tt> and <tt class="docutils literal"><span class="pre">f</span></tt> read</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;x[0] + x[1]&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-8*x[0] - 10*x[1]&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>No additional modifications are necessary. The complete code can be
found in in the file <tt class="docutils literal"><span class="pre">vcp2D.py</span></tt> (variable-coefficient Poisson problem in 2D).
You can run it and confirm
that it recovers the exact <span class="math">\(u\)</span> at the nodes.</p>
<p>The flux <span class="math">\(-p\nabla u\)</span> may be of particular interest in
variable-coefficient Poisson problems as it often has an interesting
physical significance. As explained in the section <a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a>,
we normally want the piecewise discontinuous flux or gradient to be
approximated by a continuous vector field, using the same elements as
used for the numerical solution <span class="math">\(u\)</span>. The approximation now consists of
solving <span class="math">\(w = -p\nabla u\)</span> by a finite element method: find <span class="math">\(w\in V^{(\mbox{g})}\)</span>
such that</p>
<div class="math">
\[a(w, v) = L(v)\quad\forall v\in \hat{V^{(\mbox{g})}},\]</div>
<p>where</p>
<div class="math">
\[a(w, v) = \int_\Omega w\cdot v {\, \mathrm{d}x},\]</div>
<div class="math">
\[L(v) = \int_\Omega (-p \nabla u)\cdot v {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>This problem is identical to the one in the section <a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a>,
except that <span class="math">\(p\)</span> enters the integral in <span class="math">\(L\)</span>.</p>
<p>The relevant Python statements for computing the flux field take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V_g</span> <span class="o">=</span> <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
<span class="n">flux</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V_g</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>The following call to <tt class="docutils literal"><span class="pre">project</span></tt> is equivalent to the above statements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span>
               <span class="n">VectorFunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Plotting the flux vector field is naturally as easy as plotting
the gradient (see the section <a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;flux field&#39;</span><span class="p">)</span>

<span class="n">flux_x</span><span class="p">,</span> <span class="n">flux_y</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># extract components</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;x-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">flux_y</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;y-component of flux (-p*grad(u))&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For data analysis of the nodal values of the flux field we can
grab the underlying <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flux_x_array</span> <span class="o">=</span> <span class="n">flux_x</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">flux_y_array</span> <span class="o">=</span> <span class="n">flux_y</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>The program <tt class="docutils literal"><span class="pre">vcp2D.py</span></tt> contains in addition some plots,
including a curve plot
comparing <tt class="docutils literal"><span class="pre">flux_x</span></tt> and the exact counterpart along the line <span class="math">\(y=1/2\)</span>.
The associated programming details related to this visualization
are explained in the section <a class="reference internal" href="#tut-structviz"><em>Visualization of Structured Mesh Data</em></a>.</p>
</div>
<div class="section" id="computing-functionals">
<span id="tut-poisson1-functionals"></span><h2>Computing Functionals<a class="headerlink" href="#computing-functionals" title="Permalink to this headline">¶</a></h2>
<p id="index-56">After the solution <span class="math">\(u\)</span> of a PDE is computed, we occasionally want to compute
functionals of <span class="math">\(u\)</span>, for example,</p>
<div class="math" id="equation-tut:poisson1:functionals:energy">
<span class="eqno">(15)</span>\[     {1\over2}||\nabla u||^2 \equiv {1\over2}\int_\Omega \nabla u\cdot \nabla u {\, \mathrm{d}x},\]</div>
<p>which often reflects some energy quantity.
Another frequently occurring functional is the error</p>
<div class="math" id="equation-tut:poisson1:functionals:error">
<span class="eqno">(16)</span>\[     ||u_{\mbox{e}}-u|| = \left(\int_\Omega (u_{\mbox{e}}-u)^2 {\, \mathrm{d}x}\right)^{1/2},\]</div>
<p>where <span class="math">\(u_{\rm e}\)</span> is the exact solution. The error
is of particular interest when studying convergence properties.
Sometimes the interest concerns the flux out of a part <span class="math">\(\Gamma\)</span> of
the boundary <span class="math">\(\partial\Omega\)</span>,</p>
<div class="math" id="equation-tut:poisson1:functionals:flux">
<span class="eqno">(17)</span>\[     F = -\int_\Gamma p\nabla u\cdot\boldsymbol{n} {\, \mathrm{d}s},\]</div>
<p>where <span class="math">\(\boldsymbol{n}\)</span> is an outward unit normal at <span class="math">\(\Gamma\)</span> and <span class="math">\(p\)</span> is a
coefficient (see the problem in the section <a class="reference internal" href="#tut-possion-2d-varcoeff"><em>A Variable-Coefficient Poisson Problem</em></a>
for a specific example).
All these functionals are easy to compute with FEniCS, and this section
describes how it can be done.</p>
<p id="index-57"><strong>Energy Functional.</strong>
The integrand of the
energy functional
<span class="math">\({1\over2}\int_\Omega \nabla u\cdot \nabla u {\, \mathrm{d}x}\)</span>
is described in the UFL language in the same manner as we describe
weak forms:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">energy</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">assemble</span></tt> call performs the integration.
It is possible to restrict the integration to subdomains, or parts
of the boundary, by using
a mesh function to mark the subdomains as explained in
the section <a class="reference internal" href="#tut-poisson-mat-neumann"><em>Multiple Neumann, Robin, and Dirichlet Condition</em></a>.
The program <tt class="docutils literal"><span class="pre">membrane2.py</span></tt> carries out the computation of
the elastic energy</p>
<div class="math" id="index-58">
\[{1\over2}||T\nabla D||^2 = {1\over2}\left({AR\over 8\pi\sigma}\right)^2
||\nabla w||^2\]</div>
<p>in the membrane problem from the section <a class="reference internal" href="#tut-poisson-membrane"><em>Solving a Real Physical Problem</em></a>.</p>
<p id="index-59"><strong>Convergence Estimation.</strong>
To illustrate error computations and convergence of finite element
solutions, we modify the <tt class="docutils literal"><span class="pre">d5_p2D.py</span></tt> program from
the section <a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a> and specify a more complicated solution,</p>
<div class="math">
\[u(x,y) = \sin(\omega\pi x)\sin(\omega\pi y)\]</div>
<p>on the unit square.
This choice implies <span class="math">\(f(x,y)=2\omega^2\pi^2 u(x,y)\)</span>.
With <span class="math">\(\omega\)</span> restricted to an integer
it follows that <span class="math">\(u_0=0\)</span>.</p>
<p id="index-60">We need to define the
appropriate boundary conditions, the exact solution, and the <span class="math">\(f\)</span> function
in the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>

<span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(omega*pi*x[0])*sin(omega*pi*x[1])&#39;</span><span class="p">,</span>
                 <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u_e</span>
</pre></div>
</div>
<p>The computation of
<span class="math">\(\left(\int_\Omega (u_e-u)^2 {\, \mathrm{d}x}\right)^{1/2}\)</span>
can be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">u_e</span></tt> will be interpolated onto
the function space <tt class="docutils literal"><span class="pre">V</span></tt>. This implies that the exact solution used in
the integral will vary linearly over
the cells, and not as a sine function,
if <tt class="docutils literal"><span class="pre">V</span></tt> corresponds to linear Lagrange elements.
This situation may yield a smaller error <tt class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">u_e</span></tt> than what is actually true.</p>
<p>More accurate representation of the exact solution is easily achieved
by interpolating the formula onto a space defined by
higher-order elements, say of third degree:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>To achieve complete mathematical
control of which function space the computations are carried out in,
we can explicitly interpolate <tt class="docutils literal"><span class="pre">u</span></tt> to the same space:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_Ve</span> <span class="o">-</span> <span class="n">u_e_Ve</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The square in the expression for <tt class="docutils literal"><span class="pre">error</span></tt> will be expanded and lead
to a lot of terms that almost cancel when the error is small, with the
potential of introducing significant round-off errors.
The function <tt class="docutils literal"><span class="pre">errornorm</span></tt> is available for avoiding this effect
by first interpolating <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">u_e</span></tt> to a space with
higher-order elements, then subtracting the degrees of freedom, and
then performing the integration of the error field. The usage is simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">normtype</span><span class="o">=</span><span class="s">&#39;L2&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>It is illustrative to look at the short implementation of <tt class="docutils literal"><span class="pre">errornorm</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">):</span>
    <span class="n">u_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">u_e_Ve</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="n">e_Ve</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Ve</span><span class="p">)</span>
    <span class="c"># Subtract degrees of freedom for the error field</span>
    <span class="n">e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_e_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> \
                       <span class="n">u_Ve</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">e_Ve</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">errornorm</span></tt> procedure turns out to be identical to computing
the expression <tt class="docutils literal"><span class="pre">(u_e</span> <span class="pre">-</span> <span class="pre">u)**2*dx</span></tt> directly in
the present test case.</p>
<p>Sometimes it is of interest to compute the error of the
gradient field: <span class="math">\(||\nabla (u-u_{\mbox{e}})||\)</span>
(often referred to as the <span class="math">\(H^1\)</span> seminorm of the error).
Given the error field <tt class="docutils literal"><span class="pre">e_Ve</span></tt> above, we simply write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H1seminorm</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">assemble</span><span class="p">(</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">e_Ve</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, we remove all <tt class="docutils literal"><span class="pre">plot</span></tt> calls and printouts of <span class="math">\(u\)</span> values
in the original program, and
collect the computations in a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">degree</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="n">Ve</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">Ve</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">E</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">compute</span></tt> for finer and finer meshes enables us to
study the convergence rate. Define the element size
<span class="math">\(h=1/n\)</span>, where <span class="math">\(n\)</span> is the number of divisions in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> direction
(<tt class="docutils literal"><span class="pre">nx=ny</span></tt> in the code). We perform experiments with <span class="math">\(h_0&gt;h_1&gt;h_2\cdots\)</span>
and compute the corresponding errors <span class="math">\(E_0, E_1, E_3\)</span> and so forth.
Assuming <span class="math">\(E_i=Ch_i^r\)</span> for unknown constants <span class="math">\(C\)</span> and <span class="math">\(r\)</span>, we can compare
two consecutive experiments, <span class="math">\(E_i=Ch_i^r\)</span> and <span class="math">\(E_{i-1}=Ch_{i-1}^r\)</span>,
and solve for <span class="math">\(r\)</span>:</p>
<div class="math">
\[r = {\ln(E_i/E_{i-1})\over\ln (h_i/h_{i-1})}{\thinspace . }\]</div>
<p>The <span class="math">\(r\)</span> values should approach the expected convergence
rate <tt class="docutils literal"><span class="pre">degree+1</span></tt> as <span class="math">\(i\)</span> increases.</p>
<p>The procedure above can easily be turned into Python code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># read degree as 1st command-line arg</span>
<span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># element sizes</span>
<span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># errors</span>
<span class="k">for</span> <span class="n">nx</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">264</span><span class="p">]:</span>
    <span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">degree</span><span class="p">))</span>

<span class="c"># Convergence rates</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>  <span class="c"># (log is a dolfin name too - and logg :-)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">print</span> <span class="s">&#39;h=</span><span class="si">%10.2E</span><span class="s"> r=.2f&#39;</span>  <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting program has the name <tt class="docutils literal"><span class="pre">d6_p2D.py</span></tt>
and computes error norms in various ways. Running this
program for elements of first degree and <span class="math">\(\omega=1\)</span> yields the output</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">h</span><span class="o">=</span><span class="mf">1.25E-01</span> <span class="n">E</span><span class="o">=</span><span class="mf">3.25E-02</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.83</span>
<span class="n">h</span><span class="o">=</span><span class="mf">6.25E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">8.37E-03</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.96</span>
<span class="n">h</span><span class="o">=</span><span class="mf">3.12E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">2.11E-03</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.99</span>
<span class="n">h</span><span class="o">=</span><span class="mf">1.56E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">5.29E-04</span> <span class="n">r</span><span class="o">=</span><span class="mf">2.00</span>
<span class="n">h</span><span class="o">=</span><span class="mf">7.81E-03</span> <span class="n">E</span><span class="o">=</span><span class="mf">1.32E-04</span> <span class="n">r</span><span class="o">=</span><span class="mf">2.00</span>
<span class="n">h</span><span class="o">=</span><span class="mf">3.79E-03</span> <span class="n">E</span><span class="o">=</span><span class="mf">3.11E-05</span> <span class="n">r</span><span class="o">=</span><span class="mf">2.00</span>
</pre></div>
</div>
<p>That is, we approach the expected second-order convergence of linear
Lagrange elements as the meshes become sufficiently fine.</p>
<p>Running the program for second-degree elements results in the expected
value <span class="math">\(r=3\)</span>,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">h</span><span class="o">=</span><span class="mf">1.25E-01</span> <span class="n">E</span><span class="o">=</span><span class="mf">5.66E-04</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.09</span>
<span class="n">h</span><span class="o">=</span><span class="mf">6.25E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">6.93E-05</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.03</span>
<span class="n">h</span><span class="o">=</span><span class="mf">3.12E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">8.62E-06</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.01</span>
<span class="n">h</span><span class="o">=</span><span class="mf">1.56E-02</span> <span class="n">E</span><span class="o">=</span><span class="mf">1.08E-06</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.00</span>
<span class="n">h</span><span class="o">=</span><span class="mf">7.81E-03</span> <span class="n">E</span><span class="o">=</span><span class="mf">1.34E-07</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.00</span>
<span class="n">h</span><span class="o">=</span><span class="mf">3.79E-03</span> <span class="n">E</span><span class="o">=</span><span class="mf">1.53E-08</span> <span class="n">r</span><span class="o">=</span><span class="mf">3.00</span>
</pre></div>
</div>
<p>However, using <tt class="docutils literal"><span class="pre">(u</span> <span class="pre">-</span> <span class="pre">u_e)**2</span></tt> for the error computation, which
implies interpolating <tt class="docutils literal"><span class="pre">u_e</span></tt> onto the same space as <tt class="docutils literal"><span class="pre">u</span></tt>,
results in <span class="math">\(r=4\)</span> (!). This is an example where it is important to
interpolate <tt class="docutils literal"><span class="pre">u_e</span></tt> to a higher-order space (polynomials of
degree 3 are sufficient here) to avoid computing a too optimistic
convergence rate.</p>
<p>Running the program for third-degree elements results in the
expected value <span class="math">\(r=4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">h</span><span class="o">=</span>  <span class="mf">1.25E-01</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.09</span>
<span class="n">h</span><span class="o">=</span>  <span class="mf">6.25E-02</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.03</span>
<span class="n">h</span><span class="o">=</span>  <span class="mf">3.12E-02</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.01</span>
<span class="n">h</span><span class="o">=</span>  <span class="mf">1.56E-02</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.00</span>
<span class="n">h</span><span class="o">=</span>  <span class="mf">7.81E-03</span> <span class="n">r</span><span class="o">=</span><span class="mf">4.00</span>
</pre></div>
</div>
<p>Checking convergence rates is the next best method for verifying PDE codes
(the best being exact recovery of a solution as in the section <a class="reference internal" href="#tut-poisson1-verify1"><em>Examining the Discrete Solution</em></a> and many other places in this tutorial).</p>
<p id="index-61"><strong>Flux Functionals.</strong>
To compute flux integrals like
<span class="math">\(\int_\Gamma p\nabla u\cdot\boldsymbol{n} {\, \mathrm{d}s}\)</span>
we need to define the <span class="math">\(\boldsymbol{n}\)</span> vector, referred to as <em>facet normal</em>
in FEniCS. If <span class="math">\(\Gamma\)</span> is the complete boundary we can perform
the flux computation by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">flux</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">ds</span>
<span class="n">total_flux</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
</pre></div>
</div>
<p>Although <tt class="docutils literal"><span class="pre">nabla_grad(u)</span></tt> and <tt class="docutils literal"><span class="pre">grad(u)</span></tt> are interchangeable
in the above expression when <tt class="docutils literal"><span class="pre">u</span></tt> is a scalar function, we have
chosen to write <tt class="docutils literal"><span class="pre">nabla_grad(u)</span></tt> because this is
the right expression if we generalize the underlying equation
to a vector Laplace/Poisson PDE. With <tt class="docutils literal"><span class="pre">grad(u)</span></tt> we must in that
case write <tt class="docutils literal"><span class="pre">dot(n,</span> <span class="pre">grad(u))</span></tt>.</p>
<p>It is possible to restrict the integration to a part of the boundary
using a mesh function to mark the relevant part, as
explained in the section <a class="reference internal" href="#tut-poisson-mat-neumann"><em>Multiple Neumann, Robin, and Dirichlet Condition</em></a>. Assuming that the
part corresponds to subdomain number <tt class="docutils literal"><span class="pre">i</span></tt>, the relevant form for the
flux is <tt class="docutils literal"><span class="pre">-p*inner(grad(u),</span> <span class="pre">n)*ds(i)</span></tt>.</p>
</div>
<div class="section" id="visualization-of-structured-mesh-data">
<span id="tut-structviz"></span><h2>Visualization of Structured Mesh Data<a class="headerlink" href="#visualization-of-structured-mesh-data" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-62"></span><span class="target" id="index-63"></span><p id="index-64">When finite element computations are done on a structured rectangular
mesh, maybe with uniform partitioning, VTK-based tools for completely
unstructured 2D/3D meshes are not required.  Instead we can use
visualization and data analysis tools for <em>structured data</em>.
Such data typically appear in finite difference simulations and
image analysis.  Analysis and visualization of structured data are faster
and easier than doing the same with data on unstructured meshes, and
the collection of tools to choose among is much larger.  We shall
demonstrate the potential of such tools and how they allow for
tailored and flexible visualization and data analysis.</p>
<span class="target" id="index-65"></span><p id="index-66">A necessary first step is to transform our <tt class="docutils literal"><span class="pre">mesh</span></tt> object to an object
representing a rectangle with equally-shaped <em>rectangular</em> cells.  The
Python package <tt class="docutils literal"><span class="pre">scitools</span></tt> (<a class="reference external" href="code.google.com/p/scitools">code.google.com/p/scitools</a>) has this
type of structure, called a <tt class="docutils literal"><span class="pre">UniformBoxMeshGrid</span></tt>. The second step is to
transform the one-dimensional array of nodal values to a
two-dimensional array holding the values at the corners of the cells
in the structured grid. In such grids, we want to access a value by
its <span class="math">\(i\)</span> and <span class="math">\(j\)</span> indices, <span class="math">\(i\)</span> counting cells in the <span class="math">\(x\)</span> direction, and
<span class="math">\(j\)</span> counting cells in the <span class="math">\(y\)</span> direction.  This transformation is in
principle straightforward, yet it frequently leads to obscure indexing
errors. The <tt class="docutils literal"><span class="pre">BoxMeshField</span></tt> object in <tt class="docutils literal"><span class="pre">scitools</span></tt> takes conveniently care of
the details of the transformation.  With a <tt class="docutils literal"><span class="pre">BoxMeshField</span></tt> defined on a
<tt class="docutils literal"><span class="pre">UniformBoxMeshGrid</span></tt> it is very easy to call up more standard plotting
packages to visualize the solution along lines in the domain or as 2D
contours or lifted surfaces.</p>
<p>Let us go back to the <tt class="docutils literal"><span class="pre">vcp2D.py</span></tt> code from
the section <a class="reference internal" href="#tut-possion-2d-varcoeff"><em>A Variable-Coefficient Poisson Problem</em></a> and map <tt class="docutils literal"><span class="pre">u</span></tt> onto a
<tt class="docutils literal"><span class="pre">BoxMeshField</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.BoxMeshField</span>
<span class="n">u2</span> <span class="o">=</span> <span class="n">u</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
     <span class="n">interpolate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">u_box</span> <span class="o">=</span> <span class="n">scitools</span><span class="o">.</span><span class="n">BoxMeshField</span><span class="o">.</span><span class="n">dolfin_function2BoxMeshField</span><span class="p">(</span>
        <span class="n">u2</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">),</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <tt class="docutils literal"><span class="pre">dolfin_function2BoxMeshField</span></tt> can only work with
finite element fields with <em>linear</em> (degree 1) elements, so for
higher-degree elements we here simply interpolate the solution onto
a mesh with linear elements. We could also
interpolate/project onto a finer mesh in the higher-degree case.
Such transformations to linear finite element fields
are very often needed when calling up plotting packages or data analysis tools.
The <tt class="docutils literal"><span class="pre">u.ufl_element()</span></tt> method returns an object holding the element
type, and this object has a method <tt class="docutils literal"><span class="pre">degree()</span></tt> for returning the
element degree as an integer.
The parameters <tt class="docutils literal"><span class="pre">nx</span></tt> and <tt class="docutils literal"><span class="pre">ny</span></tt> are the number of divisions in each space
direction that were used when calling <tt class="docutils literal"><span class="pre">UnitSquareMesh</span></tt> to make the
<tt class="docutils literal"><span class="pre">mesh</span></tt> object.
The result <tt class="docutils literal"><span class="pre">u_box</span></tt> is a <tt class="docutils literal"><span class="pre">BoxMeshField</span></tt>
object that supports &#8220;finite difference&#8221; indexing and an underlying
grid suitable for <tt class="docutils literal"><span class="pre">numpy</span></tt> operations on 2D data.
Also 1D and 3D meshes (with linear elements) can be turned
into <tt class="docutils literal"><span class="pre">BoxMeshField</span></tt> objects.</p>
<p>The ability to access a finite element field in the way one can access
a finite difference-type of field is handy in many occasions, including
visualization and data analysis.
Here is an example of writing out the coordinates and the field value
at a grid point with indices <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> (going from 0 to
<tt class="docutils literal"><span class="pre">nx</span></tt> and <tt class="docutils literal"><span class="pre">ny</span></tt>, respectively, from lower left to upper right corner):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># convenient indices</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ny</span>   <span class="c"># upper right corner</span>
<span class="k">print</span> <span class="s">&#39;u(</span><span class="si">%g</span><span class="s">,</span><span class="si">%g</span><span class="s">)=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">X</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                       <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coor</span><span class="p">[</span><span class="n">Y</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                       <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>For instance,
the <span class="math">\(x\)</span> coordinates are reached by <tt class="docutils literal"><span class="pre">u_box.grid.coor[X]</span></tt>.
The <tt class="docutils literal"><span class="pre">grid</span></tt> attribute is an instance of class <tt class="docutils literal"><span class="pre">UniformBoxMeshGrid</span></tt>.</p>
<p>Many plotting programs can be used to visualize the data in <tt class="docutils literal"><span class="pre">u_box</span></tt>.
Matplotlib is now a very popular plotting program in the Python world
and could be used to make contour plots of <tt class="docutils literal"><span class="pre">u_box</span></tt>. However, other
programs like Gnuplot, VTK, and MATLAB have better support for surface
plots at the time of this writing. Our choice in this tutorial is to
use the Python package <tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt>, which offers a uniform
MATLAB-like syntax as interface to various plotting packages such as
Gnuplot, Matplotlib, VTK, OpenDX, MATLAB, and others. With
<tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt> we write one set of statements, close to what one
would do in MATLAB or Octave, and then it is easy to switch between
different plotting programs, at a later stage, through a command-line
option, a line in a configuration file, or an import statement in the
program.</p>
<p id="index-67">A contour plot is made by the following <tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt> command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.easyviz</span> <span class="kn">as</span> <span class="nn">ev</span>
<span class="n">ev</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
           <span class="mi">5</span><span class="p">,</span> <span class="n">clabels</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
<span class="n">evtitle</span><span class="p">(</span><span class="s">&#39;Contour plot of u&#39;</span><span class="p">)</span>
<span class="n">ev</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;u_contours.eps&#39;</span><span class="p">)</span>

<span class="c"># or more compact syntax:</span>
<span class="n">ev</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
           <span class="mi">5</span><span class="p">,</span> <span class="n">clabels</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">,</span>
           <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_contours.eps&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Contour plot of u&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting plot can be viewed in
Figure <a class="reference internal" href="#tut-poisson-2d-fig2a"><em>Finite element function on a structured 2D grid: contour plot of the solution</em></a>.
The <tt class="docutils literal"><span class="pre">contour</span></tt> function needs arrays with the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> coordinates
expanded to 2D arrays (in the same way as demanded when
making vectorized
<tt class="docutils literal"><span class="pre">numpy</span></tt> calculations of arithmetic expressions over all grid points).
The correctly expanded arrays are stored in <tt class="docutils literal"><span class="pre">grid.coorv</span></tt>.
The above call to
<tt class="docutils literal"><span class="pre">contour</span></tt> creates 5 equally spaced contour lines, and with
<tt class="docutils literal"><span class="pre">clabels='on'</span></tt> the contour values can be seen in the plot.</p>
<p>Other functions for visualizing 2D scalar fields are <tt class="docutils literal"><span class="pre">surf</span></tt> and
<tt class="docutils literal"><span class="pre">mesh</span></tt> as known from MATLAB:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scitools.easyviz</span> <span class="kn">as</span> <span class="nn">ev</span>
<span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ev</span><span class="o">.</span><span class="n">surf</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">shading</span><span class="o">=</span><span class="s">&#39;interp&#39;</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="s">&#39;on&#39;</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;surf plot of u&#39;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_surf.eps&#39;</span><span class="p">)</span>

<span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ev</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coorv</span><span class="p">[</span><span class="n">Y</span><span class="p">],</span> <span class="n">u_box</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;mesh plot of u&#39;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;u_mesh.eps&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#tut-poisson-2d-fig3a"><em>Finite element function on a structured 2D grid: surface plot of the solution</em></a> and <a class="reference internal" href="#tut-poisson-2d-fig3b"><em>Finite element function on a structured 2D grid: lifted mesh plot of the solution</em></a> exemplify
the surfaces arising from
the two plotting commands above.
You can type
<tt class="docutils literal"><span class="pre">pydoc</span> <span class="pre">scitools.easyviz</span></tt> in a terminal window
to get a full tutorial.
Note that <tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt> offers function names like
<tt class="docutils literal"><span class="pre">plot</span></tt> and <tt class="docutils literal"><span class="pre">mesh</span></tt>, which clash with <tt class="docutils literal"><span class="pre">plot</span></tt> from <tt class="docutils literal"><span class="pre">dolfin</span></tt>
and the <tt class="docutils literal"><span class="pre">mesh</span></tt> variable in our programs. Therefore, we recommend the
<tt class="docutils literal"><span class="pre">ev</span></tt> prefix.</p>
<p>A handy feature of <tt class="docutils literal"><span class="pre">BoxMeshField</span></tt> is the ability to give a start point
in the grid and a direction, and then extract the field and corresponding
coordinates along the nearest grid
line. In 3D fields
one can also extract data in a plane.
Say we
want to plot <span class="math">\(u\)</span> along the line <span class="math">\(y=1/2\)</span> in the grid. The grid points,
<tt class="docutils literal"><span class="pre">x</span></tt>, and the
<span class="math">\(u\)</span> values along this line, <tt class="docutils literal"><span class="pre">uval</span></tt>, are extracted by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> <span class="n">u_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <tt class="docutils literal"><span class="pre">snapped</span></tt> is true if the line had to be snapped onto a
gridline and in that case <tt class="docutils literal"><span class="pre">y_fixed</span></tt> holds the snapped
(altered) <span class="math">\(y\)</span> value.
Plotting <span class="math">\(u\)</span> versus the <span class="math">\(x\)</span> coordinate along this line, using
<tt class="docutils literal"><span class="pre">scitools.easyviz</span></tt>, is now a matter of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>  <span class="c"># new plot window</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>  <span class="c"># &#39;r-: red solid line</span>
<span class="n">ev</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Solution&#39;</span><span class="p">)</span>
<span class="n">ev</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="s">&#39;finite element solution&#39;</span><span class="p">)</span>

<span class="c"># or more compactly:</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">uval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Solution&#39;</span><span class="p">,</span>
        <span class="n">legend</span><span class="o">=</span><span class="s">&#39;finite element solution&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A more exciting plot compares the projected numerical flux in
<span class="math">\(x\)</span> direction along the
line <span class="math">\(y=1/2\)</span> with the exact flux:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ev</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">flux2_x</span> <span class="o">=</span> <span class="n">flux_x</span> <span class="k">if</span> <span class="n">flux_x</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
          <span class="n">interpolate</span><span class="p">(</span><span class="n">flux_x</span><span class="p">,</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">flux_x_box</span> <span class="o">=</span> <span class="n">scitools</span><span class="o">.</span><span class="n">BoxMeshField</span><span class="o">.</span><span class="n">dolfin_function2BoxMeshField</span><span class="p">(</span>
          <span class="n">flux2_x</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">),</span> <span class="n">uniform_mesh</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">fluxval</span><span class="p">,</span> <span class="n">y_fixed</span><span class="p">,</span> <span class="n">snapped</span> <span class="o">=</span> \
          <span class="n">flux_x_box</span><span class="o">.</span><span class="n">gridline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_fixed</span>
<span class="n">flux_x_exact</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>
<span class="n">ev</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fluxval</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">flux_x_exact</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span>
        <span class="n">legend</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numerical (projected) flux&#39;</span><span class="p">,</span> <span class="s">&#39;exact flux&#39;</span><span class="p">),</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;Flux in x-direction (at y=</span><span class="si">%g</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">y_fixed</span><span class="p">,</span>
        <span class="n">savefig</span><span class="o">=</span><span class="s">&#39;flux.eps&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As seen from
Figure <a class="reference internal" href="#tut-poisson-2d-fig2b"><em>Finite element function on a structured 2D grid: curve plot of the exact flux and the projected numerical flux</em></a>,
the numerical flux
is accurate except in the boundary elements.</p>
<p>The visualization constructions shown above and used to generate the
figures are found in the program <tt class="docutils literal"><span class="pre">vcp2D.py</span></tt> in the
<tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory.</p>
<div class="figure" id="tut-poisson-2d-fig2a">
<img alt="_images/Poisson2D_Dvc_contour1.png" src="_images/Poisson2D_Dvc_contour1.png" style="width: 480px;" />
<p class="caption"><em>Finite element function on a structured 2D grid: contour plot of the solution</em></p>
</div>
<div class="figure" id="tut-poisson-2d-fig2b">
<img alt="_images/Poisson2D_Dvc_flux_x.png" src="_images/Poisson2D_Dvc_flux_x.png" style="width: 480px;" />
<p class="caption"><em>Finite element function on a structured 2D grid: curve plot of the exact flux and the projected numerical flux</em></p>
</div>
<div class="figure" id="tut-poisson-2d-fig3a">
<img alt="_images/Poisson2D_Dvc_surf1.png" src="_images/Poisson2D_Dvc_surf1.png" style="width: 480px;" />
<p class="caption"><em>Finite element function on a structured 2D grid: surface plot of the solution</em></p>
</div>
<div class="figure" id="tut-poisson-2d-fig3b">
<img alt="_images/Poisson2D_Dvc_mesh1.png" src="_images/Poisson2D_Dvc_mesh1.png" style="width: 480px;" />
<p class="caption"><em>Finite element function on a structured 2D grid: lifted mesh plot of the solution</em></p>
</div>
<p>It should be easy with the information above to transform a finite
element field over a uniform rectangular or box-shaped mesh to the
corresponding <tt class="docutils literal"><span class="pre">BoxMeshField</span></tt> object and perform MATLAB-style
visualizations of the whole field or the field over planes or along
lines through the domain.  By the transformation to a regular grid we
have some more flexibility than what Viper offers. However, we remark
that comprehensive tools like VisIt, MayaVi2, or ParaView also have
the possibility for plotting fields along lines and extracting planes
in 3D geometries, though usually with less degree of control compared
to Gnuplot, MATLAB, and Matplotlib.  For example, in investigations of
numerical accuracy or numerical artifacts one is often interested in
studying curve plots where only the nodal values sampled. This is
straightforward with a structured mesh data structure, but more
difficult in visualization packages utilizing unstructured grids, as
hitting exactly then nodes when sampling a function along a line
through the grid might be non-trivial.</p>
</div>
<div class="section" id="combining-dirichlet-and-neumann-conditions">
<span id="tut-poisson1-dn"></span><h2>Combining Dirichlet and Neumann Conditions<a class="headerlink" href="#combining-dirichlet-and-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>Let us make a slight extension of our two-dimensional Poisson problem
from the section <a class="reference internal" href="#tut-poisson1-bvp"><em>The Poisson equation</em></a>
and add a Neumann boundary condition. The domain is still
the unit square, but now we set the Dirichlet condition
<span class="math">\(u=u_0\)</span> at the left and right sides,
<span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>, while the Neumann condition</p>
<div class="math">
\[-{\partial u\over\partial n}=g\]</div>
<p>is applied to the remaining
sides <span class="math">\(y=0\)</span> and <span class="math">\(y=1\)</span>.
The Neumann condition is also known as a <em>natural boundary condition</em>
(in contrast to an essential boundary condition).</p>
<p id="index-68">Let <span class="math">\(\Gamma_D\)</span> and <span class="math">\(\Gamma_N\)</span>
denote the parts of <span class="math">\(\partial\Omega\)</span> where the Dirichlet and Neumann
conditions apply, respectively.
The complete boundary-value problem can be written as</p>
<div class="math">
\[- \nabla^2 u = f \mbox{ in } \Omega,\]</div>
<div class="math">
\[u = u_0 \mbox{ on } \Gamma_D,\]</div>
<div class="math">
\[- {\partial u\over\partial n} = g \mbox{ on } \Gamma_N  {\thinspace . }\]</div>
<p>Again we choose <span class="math">\(u=1+x^2 + 2y^2\)</span> as the exact solution and adjust <span class="math">\(f\)</span>, <span class="math">\(g\)</span>, and
<span class="math">\(u_0\)</span> accordingly:</p>
<div class="math">
\[\begin{split}f &amp;= -6,\\
g &amp;= \left\lbrace\begin{array}{ll}
-4, &amp; y=1\\
0,  &amp; y=0
\end{array}\right.\\
u_0 &amp;= 1 + x^2 + 2y^2{\thinspace . }\end{split}\]</div>
<p>For ease of programming we may introduce a <span class="math">\(g\)</span> function defined over the whole
of <span class="math">\(\Omega\)</span> such that <span class="math">\(g\)</span> takes on the right values at <span class="math">\(y=0\)</span> and
<span class="math">\(y=1\)</span>. One possible extension is</p>
<div class="math">
\[g(x,y) = -4y{\thinspace . }\]</div>
<p>The first task is to derive the variational problem. This time we cannot
omit the boundary term arising from the integration by parts, because
<span class="math">\(v\)</span> is only zero on <span class="math">\(\Gamma_D\)</span>. We have</p>
<div class="math">
\[ -\int_\Omega (\nabla^2 u)v {\, \mathrm{d}x}
= \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s},\]</div>
<p>and since <span class="math">\(v=0\)</span> on <span class="math">\(\Gamma_D\)</span>,</p>
<div class="math">
\[- \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s}
=
- \int_{\Gamma_N}{\partial u\over
\partial n}v {\, \mathrm{d}s}
= \int_{\Gamma_N}gv {\, \mathrm{d}s},\]</div>
<p>by applying the boundary condition on <span class="math">\(\Gamma_N\)</span>.
The resulting weak form reads</p>
<div class="math" id="equation-tut:poisson:2D:DN:weak">
<span class="eqno">(18)</span>\[     \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x} +
     \int_{\Gamma_N} gv {\, \mathrm{d}s}
     = \int_{\Omega} fv {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>Expressing this equation
in the standard notation <span class="math">\(a(u,v)=L(v)\)</span> is straightforward with</p>
<div class="math" id="equation-tut:poisson2:vard:a">
<span class="eqno">(19)</span>\[     a(u, v) = \int_{\Omega} \nabla u \cdot \nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="equation-tut:poisson2:vard:L">
<span class="eqno">(20)</span>\[     L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
     \int_{\Gamma_N} gv {\, \mathrm{d}s}{\thinspace . }\]</div>
<p id="index-69">How does the Neumann condition impact the implementation?
Starting with any of the previous files <tt class="docutils literal"><span class="pre">d*_p2D.py</span></tt>, say
<tt class="docutils literal"><span class="pre">d4_p2D.py</span></tt>, we realize that the statements remain almost the same.
Only two adjustments are necessary:</p>
<blockquote>
<div><ul class="simple">
<li>The function describing the boundary where Dirichlet conditions
apply must be modified.</li>
<li>The new boundary term must be added to the expression in <tt class="docutils literal"><span class="pre">L</span></tt>.</li>
</ul>
</div></blockquote>
<p>Step 1 can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">on_boundary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
<p>A more compact implementation reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>As pointed out already in the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation  (1)</em></a>,
testing for an exact match of real numbers is
not good programming practice so we introduce a tolerance in the test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Dirichlet_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>The second adjustment of our program concerns the definition of <tt class="docutils literal"><span class="pre">L</span></tt>,
where we have to add a boundary integral and a definition of the <span class="math">\(g\)</span>
function to be integrated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-4*x[1]&#39;</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">ds</span></tt> variable implies a boundary integral, while <tt class="docutils literal"><span class="pre">dx</span></tt>
implies an integral over the domain <span class="math">\(\Omega\)</span>.
No more modifications are necessary.</p>
<p>The file <tt class="docutils literal"><span class="pre">dn1_p2D.py</span></tt> in the <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory
implements this problem. Running the program verifies the implementation:
<span class="math">\(u\)</span> equals the exact solution at all the nodes,
regardless of how many elements we use.</p>
</div>
<div class="section" id="multiple-dirichlet-conditions">
<span id="tut-poisson-multiple-dirichlet"></span><h2>Multiple Dirichlet Conditions<a class="headerlink" href="#multiple-dirichlet-conditions" title="Permalink to this headline">¶</a></h2>
<p>The PDE problem from the previous section applies a function <span class="math">\(u_0(x,y)\)</span>
for setting Dirichlet conditions at two parts of the boundary.
Having a single function to set multiple Dirichlet conditions is
seldom possible. The more general case is to have <span class="math">\(m\)</span> functions for
setting Dirichlet conditions on <span class="math">\(m\)</span> parts of the boundary.
The purpose of this section is to explain how such multiple conditions
are treated in FEniCS programs.</p>
<p id="index-70">Let us
return to the case from the section <a class="reference internal" href="#tut-poisson1-dn"><em>Combining Dirichlet and Neumann Conditions</em></a>
and define two separate functions for
the two Dirichlet conditions:</p>
<div class="math">
\[\begin{split}- \nabla^2 u &amp;= -6 \mbox{ in } \Omega, \\
u &amp;= u_L \mbox{ on } \Gamma_0, \\
u &amp;= u_R \mbox{ on } \Gamma_1, \\
- {\partial u\over\partial n} &amp;= g \mbox{ on } \Gamma_N {\thinspace . }\end{split}\]</div>
<p>Here, <span class="math">\(\Gamma_0\)</span> is the boundary <span class="math">\(x=0\)</span>, while
<span class="math">\(\Gamma_1\)</span> corresponds to the boundary <span class="math">\(x=1\)</span>.
We have that <span class="math">\(u_L = 1 + 2y^2\)</span>, <span class="math">\(u_R = 2 + 2y^2\)</span>, and <span class="math">\(g=-4y\)</span>.
For the left boundary <span class="math">\(\Gamma_0\)</span> we
define
the usual triple of a function for the boundary value,
a function for defining
the boundary of interest, and a <tt class="docutils literal"><span class="pre">DirichletBC</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">left_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">left_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>For the boundary <span class="math">\(x=1\)</span> we write a similar code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">right_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">right_boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>The various essential conditions are then collected in a list
and used in the solution process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0</span><span class="p">,</span> <span class="n">Gamma_1</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>In other problems, where the <span class="math">\(u\)</span> values are constant at a part of the
boundary, we may use a simple <tt class="docutils literal"><span class="pre">Constant</span></tt> object instead of an
<tt class="docutils literal"><span class="pre">Expression</span></tt> object.</p>
<p>Debugging of PDE solvers very often faces the question of whether the
boundary conditions are set correctly or not. To check which Dirichlet
conditions that are actually set in the present problem, we can call
the <tt class="docutils literal"><span class="pre">get_boundary_values</span></tt> method in the <tt class="docutils literal"><span class="pre">DirichletBC</span></tt> objects. This
method returns a dictionary with degrees of freedom as keys and
corresponding  essential conditions as values. In the present
problem we can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="se">\t</span><span class="s"> at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="s">&#39;</span>
              <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">dof</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))</span>
</pre></div>
</div>
<p>The printing of coordinates for each degree of freedom (node here)
is only appropriate when degrees of freedom coincide with function
values at the vertices of the mesh, which is the case for linear
Lagrange elements only. One should therefore make somewhat
more robust code that prints out the coordinates (for convenience
when checking boundary values) only in the case of first-order
Lagrange elements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Lagrange_1st_order</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
<span class="n">coor</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;dof </span><span class="si">%2d</span><span class="s">: u=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">]),</span>
        <span class="k">if</span> <span class="n">Lagrange_1st_order</span><span class="p">:</span>  <span class="c"># print vertex coor.</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s"> at point </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                  <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coor</span><span class="p">[</span><span class="n">dof</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;&#39;</span>
</pre></div>
</div>
<p>The output for a mesh made by <tt class="docutils literal"><span class="pre">UnitSquareMesh(3,</span> <span class="pre">2)</span></tt> becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dof</span>  <span class="mi">0</span><span class="p">:</span> <span class="n">u</span><span class="o">=</span><span class="mi">1</span>      <span class="n">at</span> <span class="n">point</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">dof</span>  <span class="mi">8</span><span class="p">:</span> <span class="n">u</span><span class="o">=</span><span class="mi">3</span>      <span class="n">at</span> <span class="n">point</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">dof</span>  <span class="mi">4</span><span class="p">:</span> <span class="n">u</span><span class="o">=</span><span class="mf">1.5</span>    <span class="n">at</span> <span class="n">point</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">dof</span>  <span class="mi">3</span><span class="p">:</span> <span class="n">u</span><span class="o">=</span><span class="mi">2</span>      <span class="n">at</span> <span class="n">point</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">dof</span> <span class="mi">11</span><span class="p">:</span> <span class="n">u</span><span class="o">=</span><span class="mi">4</span>      <span class="n">at</span> <span class="n">point</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">dof</span>  <span class="mi">7</span><span class="p">:</span> <span class="n">u</span><span class="o">=</span><span class="mf">2.5</span>    <span class="n">at</span> <span class="n">point</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>The file <tt class="docutils literal"><span class="pre">dn2_p2D.py</span></tt> contains a complete program which
demonstrates the constructions above.
An extended example with multiple Neumann conditions would have
been quite natural now, but this requires marking various parts
of the boundary using the mesh function concept and is therefore
left to the section <a class="reference internal" href="#tut-poisson-mat-neumann"><em>Multiple Neumann, Robin, and Dirichlet Condition</em></a>.</p>
</div>
<div class="section" id="a-linear-algebra-formulation">
<span id="tut-poisson1-linalg"></span><h2>A Linear Algebra Formulation<a class="headerlink" href="#a-linear-algebra-formulation" title="Permalink to this headline">¶</a></h2>
<p>Given <span class="math">\(a(u,v)=L(v)\)</span>, the discrete solution <span class="math">\(u\)</span> is computed by
inserting <span class="math">\(u=\sum_{j=1}^N U_j \phi_j\)</span> into <span class="math">\(a(u,v)\)</span> and demanding
<span class="math">\(a(u,v)=L(v)\)</span> to be fulfilled for <span class="math">\(N\)</span> test functions
<span class="math">\(\hat\phi_1,\ldots,\hat\phi_N\)</span>. This implies</p>
<div class="math">
\[\sum_{j=1}^N a(\phi_j,\hat\phi_i) U_j = L(\hat\phi_i),\quad i=1,\ldots,N,\]</div>
<p>which is nothing but a linear system,</p>
<div class="math">
\[AU = b,\]</div>
<p>where the entries in <span class="math">\(A\)</span> and <span class="math">\(b\)</span> are given by</p>
<div class="math">
\[\begin{split}A_{ij} &amp;= a(\phi_j, \hat{\phi}_i), \\
b_i &amp;= L(\hat\phi_i){\thinspace . }\end{split}\]</div>
<span class="target" id="index-71"></span><span class="target" id="index-72"></span><p id="index-73">The examples so far have specified the left- and right-hand side
of the variational formulation and then asked FEniCS to
assemble the linear system and solve it.
An alternative to is explicitly call functions for assembling the
coefficient matrix <span class="math">\(A\)</span> and the right-side vector <span class="math">\(b\)</span>, and then solve
the linear system <span class="math">\(AU=b\)</span> with respect to the <span class="math">\(U\)</span> vector.
Instead of <tt class="docutils literal"><span class="pre">solve(a</span> <span class="pre">==</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">b)</span></tt> we now write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The variables <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> are as before. That is, <tt class="docutils literal"><span class="pre">a</span></tt> refers to the
bilinear form involving a <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> object (say <tt class="docutils literal"><span class="pre">u</span></tt>)
and a <tt class="docutils literal"><span class="pre">TestFunction</span></tt> object (<tt class="docutils literal"><span class="pre">v</span></tt>), and <tt class="docutils literal"><span class="pre">L</span></tt> involves a
<tt class="docutils literal"><span class="pre">TestFunction</span></tt> object (<tt class="docutils literal"><span class="pre">v</span></tt>). From <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt>,
the <tt class="docutils literal"><span class="pre">assemble</span></tt> function can
compute <span class="math">\(A\)</span> and <span class="math">\(b\)</span>.</p>
<p>The matrix <span class="math">\(A\)</span> and vector <span class="math">\(b\)</span> are first assembled without incorporating
essential (Dirichlet) boundary conditions. Thereafter, the
call <tt class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></tt> performs the necessary modifications of
the linear system such that <tt class="docutils literal"><span class="pre">u</span></tt> is guaranteed to equal the prescribed
boundary values.
When we have multiple Dirichlet conditions stored in a list <tt class="docutils literal"><span class="pre">bcs</span></tt>,
as explained in the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>, we must apply
each condition in <tt class="docutils literal"><span class="pre">bcs</span></tt> to the system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># bcs is a list of DirichletBC objects</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-74">There is an alternative function <tt class="docutils literal"><span class="pre">assemble_system</span></tt>, which can
assemble the system and take boundary conditions into account in one call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">assemble_system</span></tt> function incorporates the boundary conditions
in the element matrices and vectors, prior to assembly.
The conditions are also incorporated in a symmetric way to preserve
eventual symmetry of the coefficient matrix.</p>
<p>With <tt class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></tt> the
matrix <tt class="docutils literal"><span class="pre">A</span></tt> is modified in an unsymmetric way.</p>
<p>Note that the solution <tt class="docutils literal"><span class="pre">u</span></tt> is, as before, a <tt class="docutils literal"><span class="pre">Function</span></tt> object.
The degrees of freedom, <span class="math">\(U=A^{-1}b\)</span>, are filled
into <tt class="docutils literal"><span class="pre">u</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">Vector</span></tt> object (<tt class="docutils literal"><span class="pre">u.vector()</span></tt>)
by the <tt class="docutils literal"><span class="pre">solve</span></tt> function.</p>
<p>The object <tt class="docutils literal"><span class="pre">A</span></tt> is of type <tt class="docutils literal"><span class="pre">Matrix</span></tt>, while <tt class="docutils literal"><span class="pre">b</span></tt> and
<tt class="docutils literal"><span class="pre">u.vector()</span></tt> are of type <tt class="docutils literal"><span class="pre">Vector</span></tt>. We may convert the
matrix and vector data to <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays by calling the
<tt class="docutils literal"><span class="pre">array()</span></tt> method as shown before. If you wonder how essential
boundary conditions are incorporated in the linear system, you can
print out <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> before and after the
<tt class="docutils literal"><span class="pre">bc.apply(A,</span> <span class="pre">b)</span></tt> call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>  <span class="c"># print for small meshes only</span>
    <span class="k">print</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
</pre></div>
</div>
<p>With access to the elements in <tt class="docutils literal"><span class="pre">A</span></tt> through a <tt class="docutils literal"><span class="pre">numpy</span></tt> array we can easily
perform computations on this matrix, such as computing the eigenvalues
(using the <tt class="docutils literal"><span class="pre">eig</span></tt> function in <tt class="docutils literal"><span class="pre">numpy.linalg</span></tt>). We can alternatively dump
<tt class="docutils literal"><span class="pre">A.array()</span></tt> and <tt class="docutils literal"><span class="pre">b.array()</span></tt> to file in MATLAB format and invoke
MATLAB or Octave to analyze the linear system.
Dumping the arrays to MATLAB format is done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.io</span>
<span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="s">&#39;Ab.mat&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">A</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">()})</span>
</pre></div>
</div>
<p>Writing <tt class="docutils literal"><span class="pre">load</span> <span class="pre">Ab.mat</span></tt> in MATLAB or Octave will then make
the array variables <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> available for computations.</p>
<p id="index-75">Matrix processing in Python or MATLAB/Octave is only feasible for
small PDE problems since the <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays or matrices in MATLAB
file format are dense matrices. DOLFIN also has an interface to the
eigensolver package SLEPc, which is a preferred tool for computing the
eigenvalues of large, sparse matrices of the type encountered in PDE
problems (see <tt class="docutils literal"><span class="pre">demo/la/eigenvalue</span></tt> in the DOLFIN source code tree
for a demo).</p>
<p id="index-76">A complete code where the linear system <span class="math">\(AU=b\)</span> is explicitly assembled and
solved is found in the file <tt class="docutils literal"><span class="pre">dn3_p2D.py</span></tt> in the directory
<tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>. This code solves the same problem as in
<tt class="docutils literal"><span class="pre">dn2_p2D.py</span></tt>
(the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>).  For small
linear systems, the program writes out <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> before and
after incorporation of essential boundary conditions and illustrates
the difference between <tt class="docutils literal"><span class="pre">assemble</span></tt> and <tt class="docutils literal"><span class="pre">assemble_system</span></tt>.
The reader is encouraged to run the code for a <span class="math">\(2\times 1\)</span>
mesh (<tt class="docutils literal"><span class="pre">UnitSquareMesh(2,</span> <span class="pre">1)</span></tt> and study the output of <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>By default, <tt class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></tt> applies sparse LU decomposition
as solver. Specification of an iterative solver and preconditioner
is done through two optional arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Appropriate names of solvers and preconditioners are found in
the section <a class="reference internal" href="#tut-app-solver-prec"><em>Linear Solvers and Preconditioners</em></a>.</p>
<span class="target" id="index-77"></span><p id="index-78">To control tolerances in the stopping criterion and the maximum
number of iterations, one can explicitly form a <tt class="docutils literal"><span class="pre">KrylovSolver</span></tt> object
and set items in its <tt class="docutils literal"><span class="pre">parameters</span></tt> attribute
(see also the section <a class="reference internal" href="#tut-poisson1-solver-problem"><em>Linear Variational Problem and Solver Objects</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="n">KrylovSolver</span><span class="p">(</span><span class="s">&#39;cg&#39;</span><span class="p">,</span> <span class="s">&#39;ilu&#39;</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-4</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The program <tt class="docutils literal"><span class="pre">dn4_p2D.py</span></tt> is a modification of <tt class="docutils literal"><span class="pre">dn3_p2D.py</span></tt>
illustrating this latter approach.</p>
<p id="index-79">The choice of start vector for the iterations in a linear solver is often
important. With the <tt class="docutils literal"><span class="pre">solver.solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></tt> call the default start vector
is the zero vector. A start vector
with random numbers in the interval <span class="math">\([-100,100]\)</span> can be computed as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">size</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">U</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;nonzero_initial_guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we must turn off the default behavior of setting the start
vector (&#8220;initial guess&#8221;) to zero.
A random start vector is included in the <tt class="docutils literal"><span class="pre">dn4_p2D.py</span></tt> code.</p>
<p>Creating the linear system explicitly in a program can have some
advantages in more advanced problem settings. For example, <span class="math">\(A\)</span> may
be constant throughout a time-dependent simulation, so we can avoid
recalculating <span class="math">\(A\)</span> at every time level and save a significant amount
of simulation time. The sections <a class="reference internal" href="#tut-timedep-diffusion1-impl"><em>Implementation  (2)</em></a>
and <a class="reference internal" href="#tut-timedep-diffusion1-noassemble"><em>Avoiding Assembly</em></a> deal with this topic
in detail.</p>
</div>
<div class="section" id="parameterizing-the-number-of-space-dimensions">
<span id="tut-poisson-nd"></span><h2>Parameterizing the Number of Space Dimensions<a class="headerlink" href="#parameterizing-the-number-of-space-dimensions" title="Permalink to this headline">¶</a></h2>
<p id="index-80">FEniCS makes it is easy to write a unified simulation code that can
operate in 1D, 2D, and 3D. We will conveniently make use of this
feature in forthcoming examples.  As an appetizer, go back to the
introductory program <tt class="docutils literal"><span class="pre">d1_p2D.py</span></tt> in the <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory
and change the mesh construction from <tt class="docutils literal"><span class="pre">UnitSquareMesh(6,</span> <span class="pre">4)</span></tt> to
<tt class="docutils literal"><span class="pre">UnitCubeMesh(6,</span> <span class="pre">4,</span> <span class="pre">5)</span></tt>. Now the domain is the unit cube partitioned into
<span class="math">\(6\times 4\times 5\)</span> boxes, and each box is divided into six
tetrahedra-shaped finite elements for computations.  Run the program
and observe that we can solve a 3D problem without any other
modifications (!). The visualization allows you to rotate the cube and
observe the function values as colors on the boundary.</p>
<p>The forthcoming material introduces some convenient
technicalities such that the same program can run in 1D, 2D, or 3D
without any modifications.
Consider the simple model problem</p>
<div class="math">
\[u''(x) = 2\hbox{ in }[0,1],\quad u(0)=0,\ u(1)=1,\]</div>
<p>with exact solution <span class="math">\(u(x)=x^2\)</span>. Our aim is to formulate and solve this
problem in a 2D and a 3D domain as well.
We may generalize the domain <span class="math">\([0,1]\)</span> to a rectangle or box of any size
in the <span class="math">\(y\)</span> and <span class="math">\(z\)</span> directions and pose homogeneous Neumann
conditions <span class="math">\(\partial u/\partial n = 0\)</span> at all additional boundaries
<span class="math">\(y=\mbox{const}\)</span> and <span class="math">\(z=\mbox{const}\)</span> to ensure that <span class="math">\(u\)</span> only varies with
<span class="math">\(x\)</span>. For example, let us choose
a unit hypercube as domain: <span class="math">\(\Omega = [0,1]^d\)</span>, where <span class="math">\(d\)</span> is the number
of space dimensions. The generalized <span class="math">\(d\)</span>-dimensional Poisson problem
then reads</p>
<div class="math" id="equation-tut:poisson1:ddim">
<span class="eqno">(21)</span>\[\begin{split}       \begin{array}{rcll}
         \nabla^2 u  &amp;=  2 &amp;\mbox{in } \Omega, \\
         u  &amp;=  0 &amp;\mbox{on } \Gamma_0,\\
         u  &amp;=  1 &amp;\mbox{on } \Gamma_1,\\
     {\partial u\over\partial n}  &amp;=  0 &amp;\mbox{on } \partial\Omega\backslash\left(
     \Gamma_0\cup\Gamma_1\right),
       \end{array}\end{split}\]</div>
<p>where <span class="math">\(\Gamma_0\)</span> is the side of the hypercube where <span class="math">\(x=0\)</span>, and
where <span class="math">\(\Gamma_1\)</span> is the side where <span class="math">\(x=1\)</span>.</p>
<p id="index-81">Implementing a PDE for any <span class="math">\(d\)</span> is no more
complicated than solving a problem with a specific number of dimensions.
The only non-trivial part of the code is actually to define the mesh.
We use the command line for the user-input to the program. The first argument
can be the degree of the polynomial in the finite element basis functions.
Thereafter, we supply the
cell divisions in the various spatial directions. The number of
command-line arguments will then imply the number of space dimensions.
For example, writing <tt class="docutils literal"><span class="pre">3</span> <span class="pre">10</span> <span class="pre">3</span> <span class="pre">4</span></tt> on the command line means that
we want to approximate <span class="math">\(u\)</span> by piecewise polynomials of degree 3,
and that the domain is a three-dimensional cube with <span class="math">\(10\times 3\times 4\)</span>
divisions in the <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, and <span class="math">\(z\)</span> directions, respectively.</p>
<p>The Python code can be quite compact:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">divisions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
<span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span>
<span class="n">domain_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">UnitIntervalMesh</span><span class="p">,</span> <span class="n">UnitSquareMesh</span><span class="p">,</span> <span class="n">UnitCubeMesh</span><span class="p">]</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">domain_type</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
</pre></div>
</div>
<p>First note that although <tt class="docutils literal"><span class="pre">sys.argv[2:]</span></tt> holds the divisions of
the mesh, all elements of the list <tt class="docutils literal"><span class="pre">sys.argv[2:]</span></tt> are string objects,
so we need to explicitly convert each element to an integer.
The construction <tt class="docutils literal"><span class="pre">domain_type[d-1]</span></tt> will pick the right name of the
object used to define the domain and generate the mesh.
Moreover, the argument <tt class="docutils literal"><span class="pre">*divisions</span></tt>
sends all the component of the list <tt class="docutils literal"><span class="pre">divisions</span></tt> as separate
arguments. For example, in a 2D problem where <tt class="docutils literal"><span class="pre">divisions</span></tt> has
two elements, the statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">domain_type</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">divisions</span><span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The next part of the program is to set up the boundary conditions.
Since the Neumann conditions have <span class="math">\(\partial u/\partial n=0\)</span> we can
omit the boundary integral from the weak form. We then only
need to take care of Dirichlet conditions at two sides:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
<span class="k">def</span> <span class="nf">Dirichlet_boundary0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">def</span> <span class="nf">Dirichlet_boundary1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">bc0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Dirichlet_boundary0</span><span class="p">)</span>
<span class="n">bc1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Dirichlet_boundary1</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc0</span><span class="p">,</span> <span class="n">bc1</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that this code is independent of the number of space dimensions.
So are the statements defining and solving
the variational problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is found in the file <tt class="docutils literal"><span class="pre">paD.py</span></tt> (Poisson problem in &#8220;anyD&#8221;).</p>
<p>If we want to parameterize the direction in which <span class="math">\(u\)</span> varies, say by
the space direction number <tt class="docutils literal"><span class="pre">e</span></tt>, we only need to replace <tt class="docutils literal"><span class="pre">x[0]</span></tt> in the
code by <tt class="docutils literal"><span class="pre">x[e]</span></tt>. The parameter <tt class="docutils literal"><span class="pre">e</span></tt> could be given as a second
command-line argument.  The reader is encouraged to perform this
modification.</p>
</div>
</div>
<div class="section" id="nonlinear-problems">
<span id="tut-poisson-nonlinear"></span><h1>Nonlinear Problems<a class="headerlink" href="#nonlinear-problems" title="Permalink to this headline">¶</a></h1>
<p>Now we shall address how to solve nonlinear PDEs in FEniCS. Our
sample PDE for implementation is taken as a nonlinear Poisson equation:</p>
<div class="math">
\[-\nabla\cdot\left( q(u)\nabla u\right) = f{\thinspace . }\]</div>
<p>The coefficient <span class="math">\(q(u)\)</span> makes the equation nonlinear (unless <span class="math">\(q(u)\)</span>
is constant in <span class="math">\(u\)</span>).</p>
<p>To be able to easily verify our implementation,
we choose the domain, <span class="math">\(q(u)\)</span>, <span class="math">\(f\)</span>, and the boundary
conditions such that we have
a simple, exact solution <span class="math">\(u\)</span>. Let
<span class="math">\(\Omega\)</span> be the unit hypercube <span class="math">\([0, 1]^d\)</span>
in <span class="math">\(d\)</span> dimensions, <span class="math">\(q(u)=(1+u)^m\)</span>, <span class="math">\(f=0\)</span>, <span class="math">\(u=0\)</span> for <span class="math">\(x_0=0\)</span>, <span class="math">\(u=1\)</span>
for <span class="math">\(x_0=1\)</span>, and <span class="math">\(\partial u/\partial n=0\)</span> at all other boundaries
<span class="math">\(x_i=0\)</span> and <span class="math">\(x_i=1\)</span>, <span class="math">\(i=1,\ldots,d-1\)</span>. The coordinates are now represented by
the symbols <span class="math">\(x_0,\ldots,x_{d-1}\)</span>. The exact solution is then</p>
<div class="math">
\[u(x_0,\ldots,x_d) = \left((2^{m+1}-1)x_0 + 1\right)^{1/(m+1)} - 1{\thinspace . }\]</div>
<p>We refer to the section <a class="reference internal" href="#tut-poisson-nd"><em>Parameterizing the Number of Space Dimensions</em></a> for details on formulating a PDE
problem in <span class="math">\(d\)</span> space dimensions.</p>
<p>The variational formulation of our model problem reads:
Find <span class="math">\(u \in V\)</span> such that</p>
<div class="math" id="equation-tut:poisson:nonlinear1">
<span class="eqno">(22)</span>\[       F(u; v) = 0 \quad \forall v \in \hat{V},\]</div>
<p>where</p>
<div class="math" id="equation-tut:poisson:nonlinear2">
<span class="eqno">(23)</span>\[     F(u; v) = \int_\Omega q(u)\nabla u\cdot \nabla v {\, \mathrm{d}x},\]</div>
<p>and</p>
<div class="math">
\[\begin{split}\hat{V} &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } x_0=0\mbox{ and }x_0=1\}, \\
 V      &amp;= \{v \in H^1(\Omega) : v = 0 \mbox{ on } x_0=0\mbox{ and } v = 1\mbox{ on }x_0=1\}{\thinspace . }\end{split}\]</div>
<p>The discrete problem arises as usual by restricting <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span> to a
pair of discrete spaces. As usual, we omit any subscript on discrete
spaces and simply say <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span> are chosen finite dimensional
according to some mesh with some element type.
Similarly, we let <span class="math">\(u\)</span> be the discrete solution and use <span class="math">\(u_{\mbox{e}}\)</span> for
the exact solution if it becomes necessary to distinguish between the two.</p>
<p>The discrete nonlinear problem is then wirtten as: find <span class="math">\(u\in V\)</span> such that</p>
<div class="math" id="equation-tut:poisson:nonlinear:d">
<span class="eqno">(24)</span>\[       F(u; v) = 0 \quad \forall v \in \hat{V},\]</div>
<p>with <span class="math">\(u = \sum_{j=1}^N U_j \phi_j\)</span>. Since <span class="math">\(F\)</span> is a nonlinear function
of <span class="math">\(u\)</span>, the variational statement gives rise to a system of
nonlinear algebraic equations.</p>
<p>FEniCS can be used in alternative ways for solving a nonlinear PDE
problem. We shall in the following subsections go through four
solution strategies:</p>
<blockquote>
<div><ol class="arabic simple">
<li>a simple Picard-type iteration,</li>
<li>a Newton method at the algebraic level,</li>
<li>a Newton method at the PDE level, and</li>
<li>an automatic approach where FEniCS attacks the nonlinear variational
problem directly.</li>
</ol>
</div></blockquote>
<p>The &#8220;black box&#8221; strategy 4 is definitely the simplest one from a
programmer&#8217;s point of view, but the others give more manual control of
the solution process for nonlinear equations (which also has some
pedagogical advantages, especially for newcomers to nonlinear finite
element problems).</p>
<div class="section" id="picard-iteration">
<span id="tut-nonlinear-picard"></span><h2>Picard Iteration<a class="headerlink" href="#picard-iteration" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-82"></span><p id="index-83">Picard iteration is an easy way of handling nonlinear PDEs: we simply
use a known, previous solution in the nonlinear terms so that these
terms become linear in the unknown <span class="math">\(u\)</span>. The strategy is also known as
the method of successive substitutions.
For our particular problem,
we use a known, previous solution in the coefficient <span class="math">\(q(u)\)</span>.
More precisely, given a solution <span class="math">\(u^k\)</span> from iteration <span class="math">\(k\)</span>, we seek a
new (hopefully improved) solution <span class="math">\(u^{k+1}\)</span> in iteration <span class="math">\(k+1\)</span> such
that <span class="math">\(u^{k+1}\)</span> solves the <em>linear problem</em>,</p>
<div class="math" id="equation-tut:poisson:nonlinear:picard1">
<span class="eqno">(25)</span>\[     \nabla\cdot \left(q(u^k)\nabla u^{k+1}\right) = 0,\quad k=0,1,\ldots\]</div>
<p>The iterations require an initial guess <span class="math">\(u^0\)</span>.
The hope is that <span class="math">\(u^{k} \rightarrow u\)</span> as <span class="math">\(k\rightarrow\infty\)</span>, and that
<span class="math">\(u^{k+1}\)</span> is sufficiently close to the exact
solution <span class="math">\(u\)</span> of the discrete problem after just a few iterations.</p>
<p>We can easily formulate a variational problem for <span class="math">\(u^{k+1}\)</span> from
the last equation.
Equivalently, we can approximate <span class="math">\(q(u)\)</span> by <span class="math">\(q(u^k)\)</span> in
<span class="math">\(\int_\Omega q(u)\nabla u\cdot \nabla v {\, \mathrm{d}x}\)</span>
to obtain the same linear variational problem.
In both cases, the problem consists of seeking
<span class="math">\(u^{k+1} \in V\)</span> such that</p>
<div class="math" id="equation-tut:poisson:nonlinear:picard2">
<span class="eqno">(26)</span>\[       \tilde F(u^{k+1}; v) = 0 \quad \forall v \in \hat{V},\quad k=0,1,\ldots,\]</div>
<p>with</p>
<div class="math" id="equation-tut:poisson:nonlinear:picard3">
<span class="eqno">(27)</span>\[     \tilde F(u^{k+1}; v) = \int_\Omega q(u^k)\nabla u^{k+1}\cdot \nabla v {\, \mathrm{d}x}
     {\thinspace . }\]</div>
<p>Since this is a linear problem in the unknown <span class="math">\(u^{k+1}\)</span>, we can equivalently
use the formulation</p>
<div class="math">
\[a(u^{k+1},v) = L(v),\]</div>
<p>with</p>
<div class="math">
\[a(u,v) = \int_\Omega q(u^k)\nabla u\cdot \nabla v {\, \mathrm{d}x}\]</div>
<div class="math">
\[L(v) = 0{\thinspace . }\]</div>
<p>The iterations can be stopped when <span class="math">\(\epsilon\equiv ||u^{k+1}-u^k||
&lt; \mbox{tol}\)</span>, where <span class="math">\(\mbox{tol}\)</span> is a small tolerance, say <span class="math">\(10^{-5}\)</span>, or
when the number of iterations exceed some critical limit. The latter
case will pick up divergence of the method or unacceptable slow
convergence.</p>
<p id="index-84">In the solution algorithm we only need to store <span class="math">\(u^k\)</span> and <span class="math">\(u^{k+1}\)</span>,
called <tt class="docutils literal"><span class="pre">u_k</span></tt> and <tt class="docutils literal"><span class="pre">u</span></tt> in the code below.
The algorithm can then be expressed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="n">m</span>

<span class="c"># Define variational problem for Picard iteration</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_k</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>  <span class="c"># previous (known) u</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># Picard iterations</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>     <span class="c"># new unknown function</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0</span>           <span class="c"># error measure ||u-u_k||</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0E-5</span>        <span class="c"># tolerance</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c"># iteration counter</span>
<span class="n">maxiter</span> <span class="o">=</span> <span class="mi">25</span>        <span class="c"># max no of iterations allowed</span>
<span class="k">while</span> <span class="n">eps</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
    <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">-</span> <span class="n">u_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">Inf</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;iter=</span><span class="si">%d</span><span class="s">: norm=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">iter</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">u_k</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>   <span class="c"># update for next iteration</span>
</pre></div>
</div>
<p>We need to define the previous solution in the iterations, <tt class="docutils literal"><span class="pre">u_k</span></tt>,
as a finite element function so that <tt class="docutils literal"><span class="pre">u_k</span></tt> can be updated with
<tt class="docutils literal"><span class="pre">u</span></tt> at the end of the loop. We may create the initial
<tt class="docutils literal"><span class="pre">Function</span> <span class="pre">u_k</span></tt>
by interpolating
an <tt class="docutils literal"><span class="pre">Expression</span></tt> or a <tt class="docutils literal"><span class="pre">Constant</span></tt>
to the same vector space as <tt class="docutils literal"><span class="pre">u</span></tt> lives in (<tt class="docutils literal"><span class="pre">V</span></tt>).</p>
<p>In the code above we demonstrate how to use
<tt class="docutils literal"><span class="pre">numpy</span></tt> functionality to compute the norm of
the difference between the two most recent solutions. Here we apply
the maximum norm (<span class="math">\(\ell_\infty\)</span> norm) on the difference of the solution vectors
(<tt class="docutils literal"><span class="pre">ord=1</span></tt> and <tt class="docutils literal"><span class="pre">ord=2</span></tt> give the <span class="math">\(\ell_1\)</span> and <span class="math">\(\ell_2\)</span> vector
norms - other norms are possible for <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays,
see <tt class="docutils literal"><span class="pre">pydoc</span> <span class="pre">numpy.linalg.norm</span></tt>).</p>
<p>The file <tt class="docutils literal"><span class="pre">picard_np.py</span></tt> contains the complete code for
this nonlinear Poisson problem.
The implementation is <span class="math">\(d\)</span> dimensional, with mesh
construction and setting of Dirichlet conditions as explained in
the section <a class="reference internal" href="#tut-poisson-nd"><em>Parameterizing the Number of Space Dimensions</em></a>.
For a <span class="math">\(33\times 33\)</span> grid with <span class="math">\(m=2\)</span> we need 9 iterations for convergence
when the tolerance is <span class="math">\(10^{-5}\)</span>.</p>
</div>
<div class="section" id="a-newton-method-at-the-algebraic-level">
<span id="tut-nonlinear-newton-algebraic"></span><h2>A Newton Method at the Algebraic Level<a class="headerlink" href="#a-newton-method-at-the-algebraic-level" title="Permalink to this headline">¶</a></h2>
<p id="index-85">After having discretized our nonlinear PDE problem, we may
use Newton&#8217;s method to solve the system of nonlinear algebraic equations.
From the continuous variational problem,
the discrete version results in a
system of equations for the unknown parameters <span class="math">\(U_1,\ldots, U_N\)</span></p>
<div class="math" id="equation-tut:nonlinear:Newton:F1">
<span class="eqno">(28)</span>\[     F_i(U_1,\ldots,U_N) \equiv
     \sum_{j=1}^N
     \int_\Omega \left( q\left(\sum_{\ell=1}^NU_\ell\phi_\ell\right)
     \nabla \phi_j U_j\right)\cdot \nabla \hat\phi_i {\, \mathrm{d}x} = 0,\quad i=1,\ldots,N{\thinspace . }\]</div>
<p>Newton&#8217;s method for the system <span class="math">\(F_i(U_1,\ldots,U_j)=0\)</span>, <span class="math">\(i=1,\ldots,N\)</span>
can be formulated as</p>
<div class="math">
\[\sum_{j=1}^N
{\partial \over\partial U_j} F_i(U_1^k,\ldots,U_N^k)\delta U_j
= -F_i(U_1^k,\ldots,U_N^k),\quad i=1,\ldots,N,\]</div>
<div class="math">
\[U_j^{k+1} = U_j^k + \omega\delta U_j,\quad j=1,\ldots,N,\]</div>
<p>where <span class="math">\(\omega\in [0,1]\)</span> is a relaxation parameter, and <span class="math">\(k\)</span> is
an iteration index. An initial guess <span class="math">\(u^0\)</span> must
be provided to start the algorithm.</p>
<p id="index-86">The original Newton method has <span class="math">\(\omega=1\)</span>, but in problems where it is
difficult to obtain convergence,
so-called <em>under-relaxation</em> with <span class="math">\(\omega &lt; 1\)</span> may help. It means that
one takes a smaller step than what is suggested by Newton&#8217;s method.</p>
<p id="index-87">We need, in a program, to compute the Jacobian
matrix <span class="math">\(\partial F_i/\partial U_j\)</span>
and the right-hand side vector <span class="math">\(-F_i\)</span>.
Our present problem has <span class="math">\(F_i\)</span> given by above.
The derivative <span class="math">\(\partial F_i/\partial U_j\)</span> becomes</p>
<div class="math" id="equation-tut:poisson:nonlinear:dFdU">
<span class="eqno">(29)</span>\[     \int\limits_\Omega \left\lbrack
      q'(\sum_{\ell=1}^NU_\ell^k\phi_\ell)\phi_j
     \nabla (\sum_{j=1}^NU_j^k\phi_j)\cdot \nabla \hat\phi_i
     +
     q\left(\sum_{\ell=1}^NU_\ell^k\phi_\ell\right)
     \nabla \phi_j \cdot \nabla \hat\phi_i
     \right\rbrack
      {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>The following results were used to obtain the previous equation:</p>
<div class="math">
\[{\partial u\over\partial U_j} = {\partial\over\partial U_j}
\sum_{j=1}^NU_j\phi_j = \phi_j,\quad {\partial\over\partial U_j}\nabla u = \nabla\phi_j,\quad {\partial\over\partial U_j}q(u) = q'(u)\phi_j{\thinspace . }\]</div>
<p>We can reformulate the Jacobian matrix
by introducing the short
notation <span class="math">\(u^k = \sum_{j=1}^NU_j^k\phi_j\)</span>:</p>
<div class="math">
\[{\partial F_i\over\partial U_j} =
\int_\Omega \left\lbrack
q'(u^k)\phi_j
\nabla u^k \cdot \nabla \hat\phi_i
+
q(u^k)
\nabla \phi_j \cdot \nabla \hat\phi_i
\right\rbrack {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>In order to make FEniCS compute this matrix, we need to formulate a
corresponding variational problem. Looking at the
linear system of equations in Newton&#8217;s method,</p>
<div class="math">
\[\sum_{j=1}^N {\partial F_i\over\partial U_j}\delta U_j = -F_i,\quad
i=1,\ldots,N,\]</div>
<p>we can introduce <span class="math">\(v\)</span> as a general test function replacing <span class="math">\(\hat\phi_i\)</span>,
and we can identify the unknown
<span class="math">\(\delta u = \sum_{j=1}^N\delta U_j\phi_j\)</span>. From the linear system
we can now go &#8220;backwards&#8221; to construct the corresponding linear
discrete weak form to be solved in each Newton iteration:</p>
<div class="math" id="equation-tut:nonlinear:Newton:aLF">
<span class="eqno">(30)</span>\[     \int_\Omega \left\lbrack
     q'(u^k)\delta u
     \nabla u^k \cdot \nabla v
     +
     q(u^k)
     \nabla \delta u\cdot \nabla v
     \right\rbrack {\, \mathrm{d}x} = - \int_\Omega q(u^k)
     \nabla u^k\cdot \nabla v {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>This variational form fits the standard notation
<span class="math">\(a(\delta u,v)=L(v)\)</span> with</p>
<div class="math">
\[\begin{split}a(\delta u,v) &amp;=
\int_\Omega \left\lbrack
q'(u^k)\delta u
\nabla u^k \cdot \nabla v
+
q(u^k)
\nabla \delta u \cdot \nabla v
\right\rbrack
 {\, \mathrm{d}x}\\
L(v) &amp;= - \int_\Omega q(u^k)
\nabla u^k\cdot \nabla v {\, \mathrm{d}x}{\thinspace . }\end{split}\]</div>
<p>Note the important feature in Newton&#8217;s method
that the
previous solution <span class="math">\(u^k\)</span> replaces <span class="math">\(u\)</span>
in the formulas when computing the matrix
<span class="math">\(\partial F_i/\partial U_j\)</span> and vector <span class="math">\(F_i\)</span> for the linear system in
each Newton iteration.</p>
<p id="index-88">We now turn to the implementation.
To obtain a good initial guess <span class="math">\(u^0\)</span>, we can solve a simplified, linear
problem, typically with <span class="math">\(q(u)=1\)</span>, which yields the standard Laplace
equation <span class="math">\(\nabla^2 u^0 =0\)</span>. The recipe for solving this problem
appears in the sections <a class="reference internal" href="#tut-poisson1-varform"><em>Variational Formulation</em></a>,
<a class="reference internal" href="#tut-poisson1-impl"><em>Implementation  (1)</em></a>, and <a class="reference internal" href="#tut-poisson1-dn"><em>Combining Dirichlet and Neumann Conditions</em></a>.
The code for computing <span class="math">\(u^0\)</span> becomes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
<span class="k">def</span> <span class="nf">left_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="k">def</span> <span class="nf">right_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">left_boundary</span><span class="p">)</span>
<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">right_boundary</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0</span><span class="p">,</span> <span class="n">Gamma_1</span><span class="p">]</span>

<span class="c"># Define variational problem for initial guess (q(u)=1, i.e., m=0)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
<span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
<span class="n">u_k</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U_k</span> <span class="o">=</span> <span class="n">u_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U_k</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">u_k</span></tt> denotes the solution function for the previous
iteration, so that the solution
after each Newton iteration is <tt class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">u_k</span> <span class="pre">+</span> <span class="pre">omega*du</span></tt>.
Initially, <tt class="docutils literal"><span class="pre">u_k</span></tt> is the initial guess we call <span class="math">\(u^0\)</span> in the mathematics.</p>
<p>The Dirichlet boundary conditions for <span class="math">\(\delta u\)</span>, in
the problem to be solved in each Newton
iteration, are somewhat different than the conditions for <span class="math">\(u\)</span>.
Assuming that <span class="math">\(u^k\)</span> fulfills the
Dirichlet conditions for <span class="math">\(u\)</span>, <span class="math">\(\delta u\)</span> must be zero at the boundaries
where the Dirichlet conditions apply, in order for <span class="math">\(u^{k+1}=u^k + \omega\delta u\)</span> to fulfill
the right boundary values. We therefore define an additional list of
Dirichlet boundary conditions objects for <span class="math">\(\delta u\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Gamma_0_du</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left_boundary</span><span class="p">)</span>
<span class="n">Gamma_1_du</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">right_boundary</span><span class="p">)</span>
<span class="n">bcs_du</span> <span class="o">=</span> <span class="p">[</span><span class="n">Gamma_0_du</span><span class="p">,</span> <span class="n">Gamma_1_du</span><span class="p">]</span>
</pre></div>
</div>
<p>The nonlinear coefficient and its derivative must be defined
before coding the weak form of the Newton system:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="n">m</span>

<span class="k">def</span> <span class="nf">Dq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">du</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="c"># u = u_k + omega*du</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="n">inner</span><span class="p">(</span><span class="n">Dq</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span><span class="o">*</span><span class="n">du</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_k</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_k</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The Newton iteration loop is very similar to the Picard iteration loop
in the section <a class="reference internal" href="#tut-nonlinear-picard"><em>Picard Iteration</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>  <span class="c"># u = u_k + omega*du</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mf">1.0</span>       <span class="c"># relaxation parameter</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0E-5</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">maxiter</span> <span class="o">=</span> <span class="mi">25</span>
<span class="k">while</span> <span class="n">eps</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">iter</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
    <span class="nb">iter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">assemble_system</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs_du</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="nb">ord</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">Inf</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;Norm:&#39;</span><span class="p">,</span> <span class="n">eps</span>
    <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="o">+</span> <span class="n">omega</span><span class="o">*</span><span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">u_k</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>There are other ways of implementing the
update of the solution as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u_k</span><span class="p">)</span>  <span class="c"># u = u_k</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>

<span class="c"># or</span>
<span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">+=</span> <span class="n">omega</span><span class="o">*</span><span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">axpy(a,</span> <span class="pre">y)</span></tt> operation adds a scalar <tt class="docutils literal"><span class="pre">a</span></tt> times a <tt class="docutils literal"><span class="pre">Vector</span></tt>
<tt class="docutils literal"><span class="pre">y</span></tt> to a <tt class="docutils literal"><span class="pre">Vector</span></tt> object.  It is usually a fast operation
calling up an optimized BLAS routine for the calculation.</p>
<p>Mesh construction for a <span class="math">\(d\)</span>-dimensional problem with arbitrary degree of
the Lagrange elements can be done as
explained in the section <a class="reference internal" href="#tut-poisson-nd"><em>Parameterizing the Number of Space Dimensions</em></a>.
The complete program appears in the file <tt class="docutils literal"><span class="pre">alg_newton_np.py</span></tt>.</p>
</div>
<div class="section" id="a-newton-method-at-the-pde-level">
<span id="tut-nonlinear-newton-pdelevel"></span><h2>A Newton Method at the PDE Level<a class="headerlink" href="#a-newton-method-at-the-pde-level" title="Permalink to this headline">¶</a></h2>
<p id="index-89">Although Newton&#8217;s method in PDE problems is normally formulated at the
linear algebra level, i.e., as a solution method for systems of nonlinear
algebraic equations, we can also formulate the method at the PDE level.
This approach yields a linearization of the PDEs before they are discretized.
FEniCS users will probably find this technique simpler to apply than
the more standard method in the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><em>A Newton Method at the Algebraic Level</em></a>.</p>
<p>Given an approximation to the solution field, <span class="math">\(u^k\)</span>, we seek a
perturbation <span class="math">\(\delta u\)</span> so that</p>
<div class="math">
\[u^{k+1} = u^k + \delta u\]</div>
<p>fulfills the nonlinear PDE.
However, the problem for <span class="math">\(\delta u\)</span> is still nonlinear and nothing is
gained. The idea is therefore to assume that <span class="math">\(\delta u\)</span> is sufficiently
small so that we can linearize the problem with respect to <span class="math">\(\delta u\)</span>.
Inserting <span class="math">\(u^{k+1}\)</span> in the PDE,
linearizing the <span class="math">\(q\)</span> term as</p>
<div class="math">
\[q(u^{k+1}) = q(u^k) + q'(u^k)\delta u + {\cal O}((\delta u)^2)
\approx q(u^k) + q'(u^k)\delta u,\]</div>
<p>and dropping nonlinear terms in <span class="math">\(\delta u\)</span>,
we get</p>
<div class="math">
\[\nabla\cdot\left( q(u^k)\nabla u^k\right) +
\nabla\cdot\left( q(u^k)\nabla\delta u\right) +
\nabla\cdot\left( q'(u^k)\delta u\nabla u^k\right) = 0{\thinspace . }\]</div>
<p>We may collect the terms with the unknown <span class="math">\(\delta u\)</span> on the left-hand side,</p>
<div class="math">
\[\nabla\cdot\left( q(u^k)\nabla\delta u\right) +
\nabla\cdot\left( q'(u^k)\delta u\nabla u^k\right) =
-\nabla\cdot\left( q(u^k)\nabla u^k\right),\]</div>
<p>The weak form of this PDE is derived by multiplying by a test function <span class="math">\(v\)</span>
and integrating over <span class="math">\(\Omega\)</span>, integrating as usual
the second-order derivatives by parts:</p>
<div class="math">
\[\int_\Omega \left(
q(u^k)\nabla\delta u\cdot \nabla v
+ q'(u^k)\delta u\nabla u^k\cdot \nabla v\right) {\, \mathrm{d}x}
= -\int_\Omega q(u^k)\nabla u^k\cdot \nabla v {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>The variational problem reads: find <span class="math">\(\delta u\in V\)</span> such that
<span class="math">\(a(\delta u,v) = L(v)\)</span> for all <span class="math">\(v\in \hat V\)</span>, where</p>
<div class="math" id="equation-tut:nonlinear:poisson:pdelevel:eqa">
<span class="eqno">(31)</span>\[     a(\delta u,v) =
     \int_\Omega \left(
     q(u^k)\nabla\delta u\cdot \nabla v
     + q'(u^k)\delta u\nabla u^k\cdot \nabla v\right) {\, \mathrm{d}x},\]</div>
<div class="math" id="equation-tut:nonlinear:poisson:pdelevel:eqL">
<span class="eqno">(32)</span>\[     L(v) = -
     \int_\Omega q(u^k)\nabla u^k\cdot \nabla v {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>The function spaces <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>, being continuous or discrete,
are as in the
linear Poisson problem from the section <a class="reference internal" href="#tut-poisson1-varform"><em>Variational Formulation</em></a>.</p>
<p>We must provide some initial guess, e.g., the solution of the
PDE with <span class="math">\(q(u)=1\)</span>. The corresponding weak form <span class="math">\(a_0(u^0,v)=L_0(v)\)</span>
has</p>
<div class="math">
\[a_0(u,v)=\int_\Omega\nabla u\cdot \nabla v {\, \mathrm{d}x},\quad L_0(v)=0{\thinspace . }\]</div>
<p>Thereafter, we enter a loop and solve
<span class="math">\(a(\delta u,v)=L(v)\)</span> for <span class="math">\(\delta u\)</span> and compute a new approximation
<span class="math">\(u^{k+1} = u^k + \delta u\)</span>. Note that <span class="math">\(\delta u\)</span> is a correction, so if
<span class="math">\(u^0\)</span> satisfies the prescribed
Dirichlet conditions on some part <span class="math">\(\Gamma_D\)</span> of the boundary,
we must demand <span class="math">\(\delta u=0\)</span> on <span class="math">\(\Gamma_D\)</span>.</p>
<p>Looking at the equations just derived,
we see that the variational form is the same as for the Newton method
at the algebraic level in the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><em>A Newton Method at the Algebraic Level</em></a>. Since Newton&#8217;s method at the
algebraic level required some &#8220;backward&#8221; construction of the
underlying weak forms, FEniCS users may prefer Newton&#8217;s method at the
PDE level, which this author finds more straightforward, although not so
commonly documented in the literature on numerical methods for PDEs.
There is seemingly no need for differentiations to derive a Jacobian
matrix, but a mathematically equivalent derivation is done when
nonlinear terms are linearized using the first two Taylor series terms
and when products in the perturbation <span class="math">\(\delta u\)</span> are neglected.</p>
<p id="index-90">The implementation is identical to the one in
the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><em>A Newton Method at the Algebraic Level</em></a> and is found in
the file <tt class="docutils literal"><span class="pre">pde_newton_np.py</span></tt>. The reader is encouraged to go
through this code to be convinced that the present method actually
ends up with the same program as needed for the Newton method at
the linear algebra level in the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><em>A Newton Method at the Algebraic Level</em></a>.</p>
</div>
<div class="section" id="solving-the-nonlinear-variational-problem-directly">
<span id="tut-nonlinear-newton-auto"></span><h2>Solving the Nonlinear Variational Problem Directly<a class="headerlink" href="#solving-the-nonlinear-variational-problem-directly" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-91"></span><p id="index-92">The previous hand-calculations and manual implementation of
Picard or Newton methods can be automated by tools in FEniCS.
In a nutshell, one can just write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">problem</span> <span class="o">=</span> <span class="n">NonlinearVariationalProblem</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">NonlinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">F</span></tt> corresponds to the nonlinear form <span class="math">\(F(u;v)\)</span>,
<tt class="docutils literal"><span class="pre">u</span></tt> is the unknown <tt class="docutils literal"><span class="pre">Function</span></tt> object, <tt class="docutils literal"><span class="pre">bcs</span></tt>
represents the essential boundary conditions (in general a list of
<tt class="docutils literal"><span class="pre">DirichletBC</span></tt> objects), and
<tt class="docutils literal"><span class="pre">J</span></tt> is a variational form for the Jacobian of <tt class="docutils literal"><span class="pre">F</span></tt>.</p>
<p>Let us explain in detail how to use the built-in tools for
nonlinear variational problems and their solution.
The appropriate <tt class="docutils literal"><span class="pre">F</span></tt> form
is straightforwardly defined as follows, assuming <tt class="docutils literal"><span class="pre">q(u)</span></tt> is
coded as a Python function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>     <span class="c"># most recently computed solution</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>Note here that <tt class="docutils literal"><span class="pre">u_</span></tt> is a <tt class="docutils literal"><span class="pre">Function</span></tt> (not a <tt class="docutils literal"><span class="pre">TrialFunction</span></tt>).
An alternative and perhaps more intuitive formula for <span class="math">\(F\)</span> is to
define <span class="math">\(F(u;v)\)</span> directly in terms of
a trial function for <span class="math">\(u\)</span> and a test function for <span class="math">\(v\)</span>, and then
create the proper <tt class="docutils literal"><span class="pre">F</span></tt> by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>  <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>     <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">)</span>
</pre></div>
</div>
<p>The latter statement is equivalent to <span class="math">\(F(u=u_{-}; v)\)</span>, where <span class="math">\(u_{-}\)</span> is
an existing finite element function representing the most recently
computed approximation to the solution.
(Note that <span class="math">\(u^k\)</span> and <span class="math">\(u^{k+1}\)</span> in the previous notation
correspond to <span class="math">\(u_{-}\)</span> and <span class="math">\(u\)</span> in the present
notation. We have changed notation to better align the mathematics with
the associated UFL code.)</p>
<p id="index-93">The derivative <span class="math">\(J\)</span> (<tt class="docutils literal"><span class="pre">J</span></tt>) of <span class="math">\(F\)</span> (<tt class="docutils literal"><span class="pre">F</span></tt>) is formally the
Gateaux derivative <span class="math">\(DF(u^k; \delta u, v)\)</span>
of <span class="math">\(F(u;v)\)</span> at <span class="math">\(u=u_{-}\)</span> in the direction of <span class="math">\(\delta u\)</span>.
Technically, this Gateaux derivative is derived by computing</p>
<div class="math" id="equation-tut:poisson:nonlinear:Gateaux1">
<span class="eqno">(33)</span>\[     \lim_{\epsilon\rightarrow 0}{d\over d\epsilon} F_i(u_{-} + \epsilon\delta u; v)
     {\thinspace . }\]</div>
<p>The <span class="math">\(\delta u\)</span> is now the trial function and <span class="math">\(u_{-}\)</span> is the previous
approximation to the solution <span class="math">\(u\)</span>.
We start with</p>
<div class="math">
\[{d\over d\epsilon}\int_\Omega \nabla v\cdot\left( q(u_{-} + \epsilon\delta u)
\nabla (u_{-} + \epsilon\delta u)\right) {\, \mathrm{d}x}\]</div>
<p>and obtain</p>
<div class="math">
\[\int_\Omega \nabla v\cdot\left\lbrack
q'(u_{-} + \epsilon\delta u)\delta u
\nabla (u_{-} + \epsilon\delta u)
+
q(u_{-} + \epsilon\delta u)
\nabla \delta u
\right\rbrack {\, \mathrm{d}x},\]</div>
<p>which leads to</p>
<div class="math">
\[\int_\Omega \nabla v\cdot\left\lbrack
q'(u_{-})\delta u
\nabla (u_{-})
+
q(u_{-})
\nabla \delta u
\right\rbrack {\, \mathrm{d}x},\]</div>
<p>as <span class="math">\(\epsilon\rightarrow 0\)</span>.
This last expression is the Gateaux derivative of <span class="math">\(F\)</span>. We may use <span class="math">\(J\)</span> or
<span class="math">\(a(\delta u, v)\)</span> for this derivative, the latter having the advantage
that we easily recognize the expression as a bilinear form. However, in
the forthcoming code examples <tt class="docutils literal"><span class="pre">J</span></tt> is used as variable name for
the Jacobian.</p>
<p>The specification of <tt class="docutils literal"><span class="pre">J</span></tt>
goes as follows if <tt class="docutils literal"><span class="pre">du</span></tt> is the <tt class="docutils literal"><span class="pre">TrialFunction</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>      <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

<span class="n">J</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">du</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="n">inner</span><span class="p">(</span><span class="n">Dq</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">du</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The alternative specification of <tt class="docutils literal"><span class="pre">F</span></tt>, with <tt class="docutils literal"><span class="pre">u</span></tt> as
<tt class="docutils literal"><span class="pre">TrialFunction</span></tt>, leads to</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>  <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>      <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">)</span>

<span class="n">J</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> \
    <span class="n">inner</span><span class="p">(</span><span class="n">Dq</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<span class="target" id="index-94"></span><span class="target" id="index-95"></span><p id="index-96">The UFL language, used to specify weak forms, supports differentiation
of forms. This feature facilitates automatic <em>symbolic</em> computation of the
Jacobian <tt class="docutils literal"><span class="pre">J</span></tt> by calling the function <tt class="docutils literal"><span class="pre">derivative</span></tt> with <tt class="docutils literal"><span class="pre">F</span></tt>, the most
recently computed solution (<tt class="docutils literal"><span class="pre">Function</span></tt>), and the unknown
(<tt class="docutils literal"><span class="pre">TrialFunction</span></tt>) as parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>      <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u_</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>

<span class="n">J</span>  <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">du</span><span class="p">)</span>  <span class="c"># Gateaux derivative in dir. of du</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>  <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>      <span class="c"># the most recently computed solution</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">F</span>  <span class="o">=</span> <span class="n">action</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">)</span>

<span class="n">J</span>  <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>   <span class="c"># Gateaux derivative in dir. of u</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">derivative</span></tt> function is obviously
very convenient in problems where differentiating <tt class="docutils literal"><span class="pre">F</span></tt> by hand
implies lengthy calculations.</p>
<p>The preferred implementation of <tt class="docutils literal"><span class="pre">F</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt>, depending on whether
<tt class="docutils literal"><span class="pre">du</span></tt> or <tt class="docutils literal"><span class="pre">u</span></tt> is the <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> object,
is a matter of personal taste. Derivation of the Gateaux derivative
by hand, as shown above, is most naturally matched by an
implementation where <tt class="docutils literal"><span class="pre">du</span></tt> is the <tt class="docutils literal"><span class="pre">TrialFunction</span></tt>, while
use of automatic symbolic differentiation with the aid of the <tt class="docutils literal"><span class="pre">derivative</span></tt>
function is most naturally matched by an implementation where
<tt class="docutils literal"><span class="pre">u</span></tt> is the <tt class="docutils literal"><span class="pre">TrialFunction</span></tt>.
We have implemented both approaches in two files:
<tt class="docutils literal"><span class="pre">vp1_np.py</span></tt> with
<tt class="docutils literal"><span class="pre">u</span></tt> as <tt class="docutils literal"><span class="pre">TrialFunction</span></tt>, and
<tt class="docutils literal"><span class="pre">vp2_np.py</span></tt> with <tt class="docutils literal"><span class="pre">du</span></tt> as <tt class="docutils literal"><span class="pre">TrialFunction</span></tt>.
The directory
<tt class="docutils literal"><span class="pre">stationary/nonlinear_poisson</span></tt> contains both files.
The first command-line argument determines if the Jacobian is to
be automatically derived or computed from the hand-derived formula.</p>
<span class="target" id="index-97"></span><span class="target" id="index-98"></span><p id="index-99">The following code defines the nonlinear variational problem and
an associated solver based on Newton&#8217;s method. We here demonstrate
how key parameters in
Newton&#8217;s method can be set, as well as the choice of
solver and preconditioner, and associated parameters, for the
linear system occurring in the Newton iteration.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">problem</span> <span class="o">=</span> <span class="n">NonlinearVariationalProblem</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="n">solver</span>  <span class="o">=</span> <span class="n">NonlinearVariationalSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>

<span class="n">prm</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parameters</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;newton_solver&#39;</span><span class="p">][</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-8</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;newton_solver&#39;</span><span class="p">][</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;newton_solver&#39;</span><span class="p">][</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">prm</span><span class="p">[</span><span class="s">&#39;newton_solver&#39;</span><span class="p">][</span><span class="s">&#39;relaxation_parameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="k">if</span> <span class="n">iterative_solver</span><span class="p">:</span>
    <span class="n">prm</span><span class="p">[</span><span class="s">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;gmres&#39;</span>
    <span class="n">prm</span><span class="p">[</span><span class="s">&#39;preconditioner&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ilu&#39;</span>
    <span class="n">prm</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;absolute_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-9</span>
    <span class="n">prm</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;relative_tolerance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1E-7</span>
    <span class="n">prm</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;maximum_iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">prm</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;gmres&#39;</span><span class="p">][</span><span class="s">&#39;restart&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">prm</span><span class="p">[</span><span class="s">&#39;krylov_solver&#39;</span><span class="p">][</span><span class="s">&#39;preconditioner&#39;</span><span class="p">][</span><span class="s">&#39;ilu&#39;</span><span class="p">][</span><span class="s">&#39;fill_level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">set_log_level</span><span class="p">(</span><span class="n">PROGRESS</span><span class="p">)</span>

<span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>A list of available parameters and their default values can as
usual be printed by calling <tt class="docutils literal"><span class="pre">info(prm,</span> <span class="pre">True)</span></tt>.
The <tt class="docutils literal"><span class="pre">u_</span></tt> we feed to the nonlinear variational problem object
is filled with the solution by the call <tt class="docutils literal"><span class="pre">solver.solve()</span></tt>.</p>
</div>
</div>
<div class="section" id="time-dependent-problems">
<span id="tut-timedep"></span><h1>Time-Dependent Problems<a class="headerlink" href="#time-dependent-problems" title="Permalink to this headline">¶</a></h1>
<p>The examples in the section <a class="reference internal" href="#tut-fundamentals"><em>Fundamentals</em></a> illustrate that solving
linear, stationary PDE problems with the aid of FEniCS is easy and
requires little programming.  That is, FEniCS automates the spatial
discretization by the finite element method.  The solution of
nonlinear problems, as we showed in the section <a class="reference internal" href="#tut-poisson-nonlinear"><em>Nonlinear Problems</em></a>, can also be automated (cf. The section <a class="reference internal" href="#tut-nonlinear-newton-auto"><em>Solving the Nonlinear Variational Problem Directly</em></a>), but many scientists will prefer to
code the solution strategy of the nonlinear problem themselves and
experiment with various combinations of strategies in difficult
problems. Time-dependent problems are somewhat similar in this
respect: we have to add a time discretization scheme, which is often
quite simple, making it natural to explicitly code the details of the
scheme so that the programmer has full control.  We shall explain how
easily this is accomplished through examples.</p>
<div class="section" id="a-diffusion-problem-and-its-discretization">
<span id="tut-timedep-diffusion1"></span><h2>A Diffusion Problem and Its Discretization<a class="headerlink" href="#a-diffusion-problem-and-its-discretization" title="Permalink to this headline">¶</a></h2>
<p id="index-100">Our time-dependent
model problem for teaching purposes is naturally the simplest
extension of the Poisson problem into the time domain, i.e.,
the diffusion problem</p>
<div class="math" id="equation-tut:diffusion:pde1">
<span class="eqno">(34)</span>\[\begin{split}     {\partial u\over\partial t} = \nabla^2 u + f \mbox{ in } \Omega, \hbox{ for } t&gt;0,\end{split}\]</div>
<div class="math" id="equation-tut:diffusion:pde1:bc">
<span class="eqno">(35)</span>\[\begin{split}         u = u_0 \mbox{ on } \partial \Omega,\hbox{ for } t&gt;0,\end{split}\]</div>
<div class="math" id="equation-tut:diffusion:pde1:ic">
<span class="eqno">(36)</span>\[         u = I   \mbox{ at } t=0{\thinspace . }\]</div>
<p>Here, <span class="math">\(u\)</span> varies with space and time, e.g., <span class="math">\(u=u(x,y,t)\)</span> if the spatial
domain <span class="math">\(\Omega\)</span> is two-dimensional. The source function <span class="math">\(f\)</span> and the
boundary values <span class="math">\(u_0\)</span> may also vary with space and time.
The initial condition <span class="math">\(I\)</span> is a function of space only.</p>
<p>A straightforward approach to solving time-dependent
PDEs by the finite element method is to first discretize the
time derivative by a finite difference approximation, which yields
a recursive set of stationary problems, and then turn each stationary
problem into a variational formulation.</p>
<p>Let superscript <span class="math">\(k\)</span> denote
a quantity at time <span class="math">\(t_k\)</span>,
where <span class="math">\(k\)</span> is an integer counting time levels. For example, <span class="math">\(u^k\)</span> means
<span class="math">\(u\)</span> at time level <span class="math">\(k\)</span>.
A finite difference discretization in time first consists in
sampling the PDE at some time level, say <span class="math">\(k\)</span>:</p>
<div class="math" id="equation-tut:diffusion:pde1:tk {\partial \over\partial t}u^k = \nabla^2 u^k + f^k{\thinspace . }">
</div>
<p>The time-derivative can be approximated by a finite difference.
For simplicity and stability reasons we choose a
simple backward difference:</p>
<div class="math" id="equation-tut:diffusion:BE {\partial \over\partial t}u^k\approx {u^k - u^{k-1}\over{{\Delta t}}},">
</div>
<p>where <span class="math">\({{\Delta t}}\)</span> is the time discretization parameter.
Inserting this approximation in the PDE yields</p>
<div class="math" id="equation-tut:diffusion:pde1:BE">
<span class="eqno">(39)</span>\[     {u^k - u^{k-1}\over{{\Delta t}}} = \nabla^2 u^k + f^k{\thinspace . }\]</div>
<p>This is our time-discrete version of the diffusion PDE
problem. Reordering the last equation
so that <span class="math">\(u^k\)</span> appears
on the left-hand side only,
yields
a recursive set of
spatial (stationary) problems for <span class="math">\(u^k\)</span> (assuming <span class="math">\(u^{k-1}\)</span> is known from
computations at the previous time level):</p>
<div class="math" id="equation-tut:diffusion:pde1:u0">
<span class="eqno">(40)</span>\[     u^0 = I,\]</div>
<div class="math" id="equation-tut:diffusion:pde1:uk">
<span class="eqno">(41)</span>\[     u^k - {{\Delta t}}\nabla^2 u^k =  u^{k-1} + {{\Delta t}} f^k,\quad k=1,2,\ldots\]</div>
<p>Given <span class="math">\(I\)</span>, we can solve for <span class="math">\(u^0\)</span>, <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and so on.</p>
<p>We use a finite element method
to solve the
time-discrete equations which still have spatial differential operators.
This requires turning the equations into weak forms.
As usual, we multiply by a test function <span class="math">\(v\in \hat V\)</span> and integrate
second-derivatives by parts. Introducing the symbol <span class="math">\(u\)</span> for <span class="math">\(u^k\)</span>
(which is natural in the program too), the resulting weak
form can be conveniently written in the standard notation:
<span class="math">\(a_0(u,v)=L_0(v)\)</span> for the initial step
and <span class="math">\(a(u,v)=L(v)\)</span> for a general step, where</p>
<div class="math" id="equation-tut:diffusion:pde1:a0">
<span class="eqno">(42)</span>\[     a_0(u,v) = \int_\Omega uv {\, \mathrm{d}x},\]</div>
<div class="math" id="equation-tut:diffusion:pde1:L0">
<span class="eqno">(43)</span>\[     L_0(v) = \int_\Omega Iv {\, \mathrm{d}x},\]</div>
<div class="math" id="equation-tut:diffusion:pde1:a">
<span class="eqno">(44)</span>\[     a(u,v) = \int_\Omega\left( uv + {{\Delta t}}
     \nabla u\cdot \nabla v\right) {\, \mathrm{d}x},\]</div>
<div class="math" id="equation-tut:diffusion:pde1:L">
<span class="eqno">(45)</span>\[     L(v) = \int_\Omega \left(u^{k-1} + {{\Delta t}}  f^k\right)v {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>The continuous variational problem is to find
<span class="math">\(u^0\in V\)</span> such that <span class="math">\(a_0(u^0,v)=L_0(v)\)</span> holds for all <span class="math">\(v\in\hat V\)</span>,
and then find <span class="math">\(u^k\in V\)</span>
such that <span class="math">\(a(u^k,v)=L(v)\)</span> for all <span class="math">\(v\in\hat V\)</span>,
<span class="math">\(k=1,2,\ldots\)</span>.</p>
<p>Approximate solutions in space
are found by
restricting the functional spaces <span class="math">\(V\)</span> and <span class="math">\(\hat V\)</span>
to finite-dimensional spaces,
exactly as we have done in the Poisson problems.
We shall use the symbol <span class="math">\(u\)</span> for the finite element
approximation at time <span class="math">\(t_k\)</span>. In case we need to distinguish this
space-time discrete approximation from the exact solution of
the continuous diffusion problem, we use <span class="math">\(u_{\mbox{e}}\)</span> for the latter.
By <span class="math">\(u^{k-1}\)</span> we mean, from now on, the finite element approximation
of the solution at time <span class="math">\(t_{k-1}\)</span>.</p>
<p>Note that the forms <span class="math">\(a_0\)</span> and <span class="math">\(L_0\)</span> are identical to the forms
met in the section <a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a>, except that the test and trial
functions are now
scalar fields and not vector fields.
Instead of solving
an equation for <span class="math">\(u^0\)</span>
by a finite
element method, i.e., projecting <span class="math">\(I\)</span> onto <span class="math">\(V\)</span> via
the problem <span class="math">\(a_0(u,v)=L_0(v)\)</span>, we could simply interpolate <span class="math">\(u^0\)</span> from
<span class="math">\(I\)</span>. That is, if <span class="math">\(u^0=\sum_{j=1}^N U^0_j\phi_j\)</span>, we
simply set <span class="math">\(U_j=I(x_j,y_j)\)</span>, where <span class="math">\((x_j,y_j)\)</span> are the coordinates of
node number <span class="math">\(j\)</span>. We refer to these two strategies as computing
the initial condition by either projecting <span class="math">\(I\)</span> or interpolating <span class="math">\(I\)</span>.
Both operations are easy to compute through one statement, using either
the <tt class="docutils literal"><span class="pre">project</span></tt> or <tt class="docutils literal"><span class="pre">interpolate</span></tt> function.</p>
</div>
<div class="section" id="implementation-2">
<span id="tut-timedep-diffusion1-impl"></span><h2>Implementation  (2)<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h2>
<p>Our program needs to perform the time stepping explicitly, but can
rely on FEniCS to easily compute <span class="math">\(a_0\)</span>, <span class="math">\(L_0\)</span>, <span class="math">\(a\)</span>, and <span class="math">\(L\)</span>, and solve
the linear systems for the unknowns.  We realize that <span class="math">\(a\)</span> does not
depend on time, which means that its associated matrix also will be
time independent. Therefore, it is wise to explicitly create matrices
and vectors as in the section <a class="reference internal" href="#tut-poisson1-linalg"><em>A Linear Algebra Formulation</em></a>.  The matrix <span class="math">\(A\)</span>
arising from <span class="math">\(a\)</span> can be computed prior to the time stepping, so that
we only need to compute the right-hand side <span class="math">\(b\)</span>, corresponding to <span class="math">\(L\)</span>,
in each pass in the time loop. Let us express the solution procedure
in algorithmic form, writing <span class="math">\(u\)</span> for the unknown spatial function at
the new time level (<span class="math">\(u^k\)</span>) and <span class="math">\(u_1\)</span> for the spatial solution at one
earlier time level (<span class="math">\(u^{k-1}\)</span>):</p>
<blockquote>
<div><ul class="simple">
<li>define Dirichlet boundary condition (<span class="math">\(u_0\)</span>, Dirichlet boundary, etc.)</li>
<li>if <span class="math">\(u_1\)</span> is to be computed by projecting <span class="math">\(I\)</span>:<ul>
<li>define <span class="math">\(a_0\)</span> and <span class="math">\(L_0\)</span></li>
<li>assemble matrix <span class="math">\(M\)</span> from <span class="math">\(a_0\)</span> and vector <span class="math">\(b\)</span> from <span class="math">\(L_0\)</span></li>
<li>solve <span class="math">\(MU=b\)</span> and store <span class="math">\(U\)</span> in <span class="math">\(u_1\)</span></li>
</ul>
</li>
<li>else:  (interpolation)<ul>
<li>let <span class="math">\(u_1\)</span> interpolate <span class="math">\(I\)</span></li>
</ul>
</li>
<li>define <span class="math">\(a\)</span> and <span class="math">\(L\)</span></li>
<li>assemble matrix <span class="math">\(A\)</span> from <span class="math">\(a\)</span></li>
<li>set some stopping time <span class="math">\(T\)</span></li>
<li><span class="math">\(t={{\Delta t}}\)</span></li>
<li>while <span class="math">\(t\leq T\)</span><ul>
<li>assemble vector <span class="math">\(b\)</span> from <span class="math">\(L\)</span></li>
<li>apply essential boundary conditions</li>
<li>solve <span class="math">\(AU=b\)</span> for <span class="math">\(U\)</span> and store in <span class="math">\(u\)</span></li>
<li><span class="math">\(t\leftarrow t + {{\Delta t}}\)</span></li>
<li><span class="math">\(u_1 \leftarrow u\)</span> (be ready for next step)</li>
</ul>
</li>
</ul>
</div></blockquote>
<p>Before starting the coding, we shall construct a problem where it is
easy to determine if the calculations are correct. The simple backward
time difference is exact for linear functions, so we decide to have
a linear variation in time. Combining a second-degree polynomial in space
with a linear term in time,</p>
<div class="math" id="equation-tut:diffusion:pde1:u0test u = 1 + x^2 + \alpha y^2 + \beta t,">
</div>
<p>yields a function whose computed values at the nodes may be exact,
regardless of the size of the elements and <span class="math">\({{\Delta t}}\)</span>, as long as the
mesh is uniformly partitioned.
We realize by inserting the simple solution in the PDE problem
that <span class="math">\(u_0\)</span> must be given as
<a href="#equation-tut:diffusion:pde1:u0test">(?)</a> and that <span class="math">\(f(x,y,t)=\beta - 2 - 2\alpha\)</span>
and <span class="math">\(I(x,y)=1+x^2+\alpha y^2\)</span>.</p>
<p id="index-101">A new programming issue is how to deal with functions that vary in
space <em>and time</em>, such as the the boundary condition
<span class="math">\(u_0\)</span>.
A natural solution is
to apply an <tt class="docutils literal"><span class="pre">Expression</span></tt> object with time <span class="math">\(t\)</span> as a parameter,
in addition to the parameters <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> (see
the section <a class="reference internal" href="#tut-poisson-membrane"><em>Solving a Real Physical Problem</em></a> for <tt class="docutils literal"><span class="pre">Expression</span></tt>
objects with parameters):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The time parameter can later be updated by assigning values to <tt class="docutils literal"><span class="pre">u0.t</span></tt>.</p>
<p>Given a <tt class="docutils literal"><span class="pre">mesh</span></tt> and an associated function space <tt class="docutils literal"><span class="pre">V</span></tt>, we
can specify the <span class="math">\(u_0\)</span> function as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">alpha</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + alpha*x[1]*x[1] + beta*t&#39;</span><span class="p">,</span>
                <span class="p">{</span><span class="s">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span> <span class="s">&#39;beta&#39;</span><span class="p">:</span> <span class="n">beta</span><span class="p">})</span>
<span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>This function expression has the components of <tt class="docutils literal"><span class="pre">x</span></tt> as independent
variables, while <tt class="docutils literal"><span class="pre">alpha</span></tt>, <tt class="docutils literal"><span class="pre">beta</span></tt>, and <tt class="docutils literal"><span class="pre">t</span></tt> are parameters.
The parameters can either be set through a dictionary at construction time,
as demonstrated for <tt class="docutils literal"><span class="pre">alpha</span></tt> and <tt class="docutils literal"><span class="pre">beta</span></tt>, or anytime through
attributes in the function
object, as shown for the <tt class="docutils literal"><span class="pre">t</span></tt> parameter.</p>
<p>The essential boundary conditions, along the whole boundary in this case,
are set in the usual way,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>  <span class="c"># define the Dirichlet boundary</span>
    <span class="k">return</span> <span class="n">on_boundary</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>We shall use <tt class="docutils literal"><span class="pre">u</span></tt> for the unknown <span class="math">\(u\)</span> at the new time level and
<tt class="docutils literal"><span class="pre">u_1</span></tt> for <span class="math">\(u\)</span> at the previous time level.  The initial value of
<tt class="docutils literal"><span class="pre">u_1</span></tt>, implied by the initial condition on <span class="math">\(u\)</span>, can be computed
by either projecting or interpolating <span class="math">\(I\)</span>.
The <span class="math">\(I(x,y)\)</span> function is available in the program through
<tt class="docutils literal"><span class="pre">u0</span></tt>,
as long as <tt class="docutils literal"><span class="pre">u0.t</span></tt> is zero.
We can then do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="c"># or</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we could, as an equivalent alternative to using <tt class="docutils literal"><span class="pre">project</span></tt>, define
<span class="math">\(a_0\)</span> and <span class="math">\(L_0\)</span> as we did in the section <a class="reference internal" href="#tut-poisson-gradu"><em>Computing Derivatives</em></a> and form
the associated variational problem.
To actually recover the exact solution
to machine precision,
it is important not to compute the discrete initial condition by
projecting <span class="math">\(I\)</span>, but by interpolating <span class="math">\(I\)</span> so that the nodal values are
exact at <span class="math">\(t=0\)</span> (projection results in approximative values at the nodes).</p>
<p>The definition of <span class="math">\(a\)</span> and <span class="math">\(L\)</span> goes as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.3</span>      <span class="c"># time step</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c"># assemble only once, before the time stepping</span>
</pre></div>
</div>
<p>Finally, we perform the time stepping in a loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># the unknown at a new time level</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">2</span>             <span class="c"># total simulation time</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>

<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">u_1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>Observe that <tt class="docutils literal"><span class="pre">u0.t</span></tt> must be updated before the <tt class="docutils literal"><span class="pre">bc.apply</span></tt>
statement, to enforce computation of Dirichlet conditions at the
current time level.</p>
<p>The time loop above does not contain any comparison of the numerical
and the exact solution, which we must include in order to verify the
implementation.  As in many previous examples, we compute the
difference between the array of nodal values of <tt class="docutils literal"><span class="pre">u</span></tt> and the array of
the interpolated exact solution.  The following code is to be included
inside the loop, after <tt class="docutils literal"><span class="pre">u</span></tt> is found:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">maxdiff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">-</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">())</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;Max error, t=</span><span class="si">%.2f</span><span class="s">: </span><span class="si">%-10.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">maxdiff</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-102">The right-hand side vector <tt class="docutils literal"><span class="pre">b</span></tt> must obviously
be recomputed at each time level.
With the construction <tt class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">assemble(L)</span></tt>, a new
vector for <tt class="docutils literal"><span class="pre">b</span></tt> is allocated in memory in every pass of the time loop.
It would be much more memory friendly to reuse the storage of the <tt class="docutils literal"><span class="pre">b</span></tt>
we already have.
This is easily accomplished by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, we send in our previous <tt class="docutils literal"><span class="pre">b</span></tt>, which is then filled with new values
and returned from <tt class="docutils literal"><span class="pre">assemble</span></tt>. Now there will be only a single
memory allocation of the right-hand side vector. Before the time loop
we set <tt class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">None</span></tt> such that <tt class="docutils literal"><span class="pre">b</span></tt> is defined in the first call to
<tt class="docutils literal"><span class="pre">assemble</span></tt>.</p>
<p>The complete program code for this time-dependent case is stored in the
file <tt class="docutils literal"><span class="pre">d1_d2D.py</span></tt> in the directory <tt class="docutils literal"><span class="pre">transient/diffusion</span></tt>.</p>
</div>
<div class="section" id="avoiding-assembly">
<span id="tut-timedep-diffusion1-noassemble"></span><h2>Avoiding Assembly<a class="headerlink" href="#avoiding-assembly" title="Permalink to this headline">¶</a></h2>
<p id="index-103">The purpose of this section is to present a technique for speeding
up FEniCS simulators for time-dependent problems where it is
possible to perform all assembly operations prior to the time loop.
There are two costly operations in the time loop: assembly of the
right-hand side <span class="math">\(b\)</span> and solution of the linear system via the
<tt class="docutils literal"><span class="pre">solve</span></tt> call. The assembly process involves work proportional to
the number of degrees of freedom <span class="math">\(N\)</span>, while the solve operation
has a work estimate of <span class="math">\({\cal O}( N^{\alpha})\)</span>, for some <span class="math">\(\alpha\geq 1\)</span>. As
<span class="math">\(N\rightarrow\infty\)</span>, the solve operation will dominate for <span class="math">\(\alpha&gt;1\)</span>,
but for the values of <span class="math">\(N\)</span> typically used on smaller computers, the
assembly step may still
represent a considerable part of the total work at each
time level. Avoiding repeated assembly can therefore contribute to a
significant speed-up of a finite element code in time-dependent problems.</p>
<p>To see how repeated assembly can be avoided, we look at the <span class="math">\(L(v)\)</span>
form,
which in general varies with
time through <span class="math">\(u^{k-1}\)</span>, <span class="math">\(f^k\)</span>, and possibly also with <span class="math">\({{\Delta t}}\)</span>
if the time step is adjusted during the simulation.
The technique for avoiding repeated assembly consists in
expanding the finite element functions in sums over the basis functions
<span class="math">\(\phi_i\)</span>, as explained
in the section <a class="reference internal" href="#tut-poisson1-linalg"><em>A Linear Algebra Formulation</em></a>, to identify matrix-vector
products that build up the complete system. We have
<span class="math">\(u^{k-1}=\sum_{j=1}^NU^{k-1}_j\phi_j\)</span>, and we can expand <span class="math">\(f^k\)</span> as
<span class="math">\(f^{k}=\sum_{j=1}^NF^{k}_j\phi_j\)</span>. Inserting these expressions in <span class="math">\(L(v)\)</span>
and using
<span class="math">\(v=\hat\phi_i\)</span> result in</p>
<div class="math">
\[\begin{split}\int_\Omega \left(u^{k-1} + {{\Delta t}}f^k\right)v {\, \mathrm{d}x} &amp;=
\int_\Omega \left(\sum_{j=1}^N U^{k-1}_j\phi_j + {{\Delta t}}\sum_{j=1}^N F^{k}_j\phi_j\right)\hat\phi_i {\, \mathrm{d}x},\\
&amp;=\sum_{j=1}^N\left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)U^{k-1}_j
 + {{\Delta t}}\sum_{j=1}^N\left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)F^{k}_j{\thinspace . }\end{split}\]</div>
<p>Introducing <span class="math">\(M_{ij} = \int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\)</span>, we see that
the last expression can be written</p>
<div class="math">
\[\sum_{j=1}^NM_{ij}U^{k-1}_j + {{\Delta t}} \sum_{j=1}^NM_{ij}F^{k}_j,\]</div>
<p>which is nothing but two matrix-vector products,</p>
<div class="math">
\[MU^{k-1} + {{\Delta t}} MF^k,\]</div>
<p>if <span class="math">\(M\)</span> is the matrix with entries <span class="math">\(M_{ij}\)</span> and</p>
<div class="math">
\[U^{k-1}=(U^{k-1}_1,\ldots,U^{k-1}_N)^T,\]</div>
<p>and</p>
<div class="math">
\[F^k=(F^{k}_1,\ldots,F^{k}_N)^T{\thinspace . }\]</div>
<p>We have immediate access to <span class="math">\(U^{k-1}\)</span>
in the program since that is the vector
in the <tt class="docutils literal"><span class="pre">u_1</span></tt> function. The <span class="math">\(F^k\)</span> vector can easily be
computed by interpolating the prescribed <span class="math">\(f\)</span> function (at each time level if
<span class="math">\(f\)</span> varies with time). Given <span class="math">\(M\)</span>, <span class="math">\(U^{k-1}\)</span>, and <span class="math">\(F^k\)</span>, the right-hand side
<span class="math">\(b\)</span> can be calculated as</p>
<div class="math">
\[b = MU^{k-1} + {{\Delta t}} MF^k {\thinspace . }\]</div>
<p>That is, no assembly is necessary to compute <span class="math">\(b\)</span>.</p>
<p>The coefficient matrix <span class="math">\(A\)</span> can also be split into two terms.
We insert <span class="math">\(v=\hat\phi_i\)</span> and <span class="math">\(u^k = \sum_{j=1}^N U^k_j\phi_j\)</span> in
the relevant equations to get</p>
<div class="math">
\[\sum_{j=1}^N \left(\int_\Omega \hat\phi_i\phi_j {\, \mathrm{d}x}\right)U^k_j + {{\Delta t}}
\sum_{j=1}^N \left(\int_\Omega \nabla\hat\phi_i\cdot\nabla\phi_j {\, \mathrm{d}x}\right)U^k_j,\]</div>
<p>which can be written as a sum of matrix-vector products,</p>
<div class="math">
\[MU^k + {{\Delta t}} KU^k = (M + {{\Delta t}} K)U^k,\]</div>
<p>if we identify the matrix <span class="math">\(M\)</span> with entries <span class="math">\(M_{ij}\)</span> as above and
the matrix <span class="math">\(K\)</span> with entries</p>
<div class="math">
\[K_{ij} = \int_\Omega \nabla\hat\phi_i\cdot\nabla\phi_j {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>The matrix <span class="math">\(M\)</span> is often called the &#8220;mass matrix&#8221; while &#8220;stiffness matrix&#8221;
is a common nickname for <span class="math">\(K\)</span>. The associated bilinear forms for these
matrices, as we need them for the assembly process in a FEniCS
program, become</p>
<div class="math" id="equation-tut:diffusion:pde1:aK">
<span class="eqno">(47)</span>\[     a_K(u,v) = \int_\Omega\nabla u\cdot\nabla v {\, \mathrm{d}x},\]</div>
<div class="math" id="equation-tut:diffusion:pde1:aM">
<span class="eqno">(48)</span>\[     a_M(u,v) = \int_\Omega uv {\, \mathrm{d}x} {\thinspace . }\]</div>
<p>The linear system at each time level, written as <span class="math">\(AU^k=b\)</span>,
can now be computed by first computing <span class="math">\(M\)</span> and <span class="math">\(K\)</span>, and then forming
<span class="math">\(A=M+{{\Delta t}} K\)</span> at <span class="math">\(t=0\)</span>, while <span class="math">\(b\)</span> is computed as
<span class="math">\(b=MU^{k-1} + {{\Delta t}}MF^k\)</span> at each time level.</p>
<p id="index-104">The following modifications are needed in the <tt class="docutils literal"><span class="pre">d1_d2D.py</span></tt>
program from the previous section in order to implement the new
strategy of avoiding assembly at each time level:</p>
<blockquote>
<div><ul class="simple">
<li>Define separate forms <span class="math">\(a_M\)</span> and <span class="math">\(a_K\)</span></li>
<li>Assemble <span class="math">\(a_M\)</span> to <span class="math">\(M\)</span> and <span class="math">\(a_K\)</span> to <span class="math">\(K\)</span></li>
<li>Compute <span class="math">\(A=M+{{\Delta t}}\)</span>, <span class="math">\(K\)</span></li>
<li>Define <span class="math">\(f\)</span> as an <tt class="docutils literal"><span class="pre">Expression</span></tt></li>
<li>Interpolate the formula for <span class="math">\(f\)</span> to a finite element function <span class="math">\(F^k\)</span></li>
<li>Compute <span class="math">\(b=MU^{k-1} + {{\Delta t}}MF^k\)</span></li>
</ul>
</div></blockquote>
<p>The relevant code segments become</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1.</span>
<span class="n">a_K</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">a_M</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>

<span class="c"># 2. and 3.</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a_M</span><span class="p">)</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a_K</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">K</span>

<span class="c"># 4.</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;beta - 2 - 2*alpha&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

<span class="c"># 5. and 6.</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
    <span class="n">f_k</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">F_k</span> <span class="o">=</span> <span class="n">f_k</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">u_1</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="n">F_k</span>
</pre></div>
</div>
<p>The complete program appears in the file <tt class="docutils literal"><span class="pre">d2_d2D.py</span></tt>.</p>
</div>
<div class="section" id="a-physical-example">
<span id="tut-timedep-diffusion2-sin"></span><h2>A Physical Example<a class="headerlink" href="#a-physical-example" title="Permalink to this headline">¶</a></h2>
<p id="index-105">With the basic programming techniques for time-dependent problems from
the sections <a class="reference internal" href="#tut-timedep-diffusion1-noassemble"><em>Avoiding Assembly</em></a>-<a class="reference internal" href="#tut-timedep-diffusion1-impl"><em>Implementation  (2)</em></a>
we are ready to attack more physically realistic examples.
The next example concerns the question: How is the temperature in the
ground affected by day and night variations at the earth&#8217;s surface?
We consider some box-shaped domain <span class="math">\(\Omega\)</span> in <span class="math">\(d\)</span> dimensions with
coordinates <span class="math">\(x_0,\ldots,x_{d-1}\)</span> (the problem is meaningful in 1D, 2D, and 3D).
At the top of the domain, <span class="math">\(x_{d-1}=0\)</span>, we have an oscillating
temperature</p>
<div class="math">
\[T_0(t) = T_R + T_A\sin (\omega t),\]</div>
<p>where <span class="math">\(T_R\)</span> is some reference temperature, <span class="math">\(T_A\)</span> is the amplitude of
the temperature variations at the surface, and <span class="math">\(\omega\)</span> is the frequency
of the temperature oscillations.
At all other boundaries we assume
that the temperature does not change anymore when we move away from
the boundary, i.e., the normal derivative is zero.
Initially, the temperature can be taken as <span class="math">\(T_R\)</span> everywhere.
The heat conductivity properties of the soil in the
ground may vary with space so
we introduce a variable coefficient <span class="math">\(\kappa\)</span> reflecting this property.
Figure <a class="reference internal" href="#tut-timedep-diffusion2-sin-fig1"><em>Sketch of a (2D) problem involving heating and cooling of the ground due to an oscillating surface temperature</em></a> shows a sketch of the
problem, with a small region where the heat conductivity is much lower.</p>
<div class="figure" id="tut-timedep-diffusion2-sin-fig1">
<img alt="_images/daynight.png" src="_images/daynight.png" style="width: 480px;" />
<p class="caption"><em>Sketch of a (2D) problem involving heating and cooling of the ground due to an oscillating surface temperature</em></p>
</div>
<p>The initial-boundary value problem for this problem reads</p>
<div class="math">
\[\varrho c{\partial T\over\partial t} = \nabla\cdot\left( \kappa\nabla T\right)\hbox{ in }\Omega\times (0,t_{\hbox{stop}}],\]</div>
<div class="math">
\[T = T_0(t)\hbox{ on }\Gamma_0,\]</div>
<div class="math">
\[{\partial T\over\partial n} = 0\hbox{ on }\partial\Omega\backslash\Gamma_0,\]</div>
<div class="math">
\[T = T_R\hbox{ at }t =0{\thinspace . }\]</div>
<p>Here, <span class="math">\(\varrho\)</span> is the density of the soil, <span class="math">\(c\)</span> is the
heat capacity, <span class="math">\(\kappa\)</span> is the thermal conductivity
(heat conduction coefficient)
in the soil, and <span class="math">\(\Gamma_0\)</span> is the surface boundary <span class="math">\(x_{d-1}=0\)</span>.</p>
<p>We use a <span class="math">\(\theta\)</span>-scheme in time, i.e., the evolution equation
<span class="math">\(\partial P/\partial t=Q(t)\)</span> is discretized as</p>
<div class="math">
\[{P^k - P^{k-1}\over{{\Delta t}}} = \theta Q^k + (1-\theta )Q^{k-1},\]</div>
<p>where <span class="math">\(\theta\in[0,1]\)</span> is a weighting factor: <span class="math">\(\theta =1\)</span> corresponds
to the backward difference scheme, <span class="math">\(\theta =1/2\)</span> to the Crank-Nicolson
scheme, and <span class="math">\(\theta =0\)</span> to a forward difference scheme.
The <span class="math">\(\theta\)</span>-scheme applied to our PDE results in</p>
<div class="math">
\[\varrho c{T^k-T^{k-1}\over{{\Delta t}}} =
\theta \nabla\cdot\left( \kappa\nabla T^k\right)
+ (1-\theta) \nabla\cdot\left( k\nabla T^{k-1}\right){\thinspace . }\]</div>
<p>Bringing this time-discrete PDE into weak form follows the technique shown
many times earlier in this tutorial. In the standard notation
<span class="math">\(a(T,v)=L(v)\)</span> the weak form has</p>
<div class="math">
\[a(T,v) = \int_\Omega
\left( \varrho c Tv + \theta{{\Delta t}} \kappa\nabla T\cdot \nabla v\right) {\, \mathrm{d}x},\]</div>
<div class="math">
\[L(v) = \int_\Omega \left( \varrho c T^{k-1}v - (1-\theta){{\Delta t}}
\kappa\nabla T^{k-1}\cdot \nabla v\right) {\, \mathrm{d}x}{\thinspace . }\]</div>
<p>Observe that boundary integrals vanish because of the Neumann boundary
conditions.</p>
<span class="target" id="index-106"></span><p id="index-107">The size of a 3D box is taken as <span class="math">\(W\times W\times D\)</span>, where <span class="math">\(D\)</span> is
the depth and <span class="math">\(W=D/2\)</span> is the width.
We give the degree of the basis functions at the command line, then <span class="math">\(D\)</span>,
and then the divisions of the domain in the various directions.
To make a box, rectangle, or interval of arbitrary (not unit) size,
we have the DOLFIN classes <tt class="docutils literal"><span class="pre">BoxMesh</span></tt>, <tt class="docutils literal"><span class="pre">RectangleMesh</span></tt>, and
<tt class="docutils literal"><span class="pre">IntervalMesh</span></tt> at our disposal. The mesh and the function space
can be created by the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">degree</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">D</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">D</span><span class="o">/</span><span class="mf">2.0</span>
<span class="n">divisions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">:]]</span>
<span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span>  <span class="c"># no of space dimensions</span>
<span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">IntervalMesh</span><span class="p">(</span><span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">D</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">BoxMesh</span><span class="p">(</span><span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
               <span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;Lagrange&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">RectangleMesh</span></tt> and <tt class="docutils literal"><span class="pre">BoxMesh</span></tt> objects are defined by the coordinates
of the &#8220;minimum&#8221; and &#8220;maximum&#8221; corners.</p>
<p>Setting Dirichlet conditions at the upper boundary can be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T_R</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">T_A</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span>

<span class="n">T_0</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;T_R + T_A*sin(omega*t)&#39;</span><span class="p">,</span>
                 <span class="n">T_R</span><span class="o">=</span><span class="n">T_R</span><span class="p">,</span> <span class="n">T_A</span><span class="o">=</span><span class="n">T_A</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">surface</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1E-14</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">T_0</span><span class="p">,</span> <span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p>The <span class="math">\(\kappa\)</span> function can be defined as a constant <span class="math">\(\kappa_1\)</span> inside
the particular rectangular area with a special soil composition, as
indicated in Figure <a class="reference internal" href="#tut-timedep-diffusion2-sin-fig1"><em>Sketch of a (2D) problem involving heating and cooling of the ground due to an oscillating surface temperature</em></a>. Outside
this area <span class="math">\(\kappa\)</span> is a constant <span class="math">\(\kappa_0\)</span>.
The domain of the rectangular area is taken as</p>
<div class="math">
\[[-W/4, W/4]\times [-W/4, W/4]\times [-D/2, -D/2 + D/4]\]</div>
<p>in 3D, with <span class="math">\([-W/4, W/4]\times [-D/2, -D/2 + D/4]\)</span> in 2D and
<span class="math">\([-D/2, -D/2 + D/4]\)</span> in 1D.
Since we need some testing in the definition of the <span class="math">\(\kappa(\boldsymbol{x})\)</span>
function, the most straightforward approach is to define a subclass
of <tt class="docutils literal"><span class="pre">Expression</span></tt>, where we can use a full Python method instead of
just a C++ string formula for specifying a function.
The method that defines the function is called <tt class="docutils literal"><span class="pre">eval</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Kappa</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;x: spatial point, value[0]: function value.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c"># no of space dimensions</span>
        <span class="n">material</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># 0: outside, 1: inside</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">D</span><span class="o">/</span><span class="mf">4.</span><span class="p">:</span>
                <span class="n">material</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">D</span><span class="o">/</span><span class="mf">4.</span> <span class="ow">and</span> \
               <span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mf">4.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">W</span><span class="o">/</span><span class="mf">4.</span><span class="p">:</span>
                <span class="n">material</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">D</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">D</span><span class="o">/</span><span class="mf">4.</span> <span class="ow">and</span> \
               <span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mf">4.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">W</span><span class="o">/</span><span class="mf">4.</span> <span class="ow">and</span> <span class="o">-</span><span class="n">W</span><span class="o">/</span><span class="mf">4.</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">W</span><span class="o">/</span><span class="mf">4.</span><span class="p">:</span>
                <span class="n">material</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kappa_0</span> <span class="k">if</span> <span class="n">material</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">kappa_1</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">eval</span></tt> method gives great flexibility in defining functions,
but a downside is that C++ calls up <tt class="docutils literal"><span class="pre">eval</span></tt> in Python for
each point <tt class="docutils literal"><span class="pre">x</span></tt>, which is a slow process, and the number of calls
is proportional to the number of nodes in the mesh.
Function expressions in terms of strings are compiled to efficient
C++ functions, being called from C++, so we should try to express functions
as string expressions if possible. (The <tt class="docutils literal"><span class="pre">eval</span></tt> method can also be
defined through C++ code, but this is much
more complicated and not covered here.)
Using inline if-tests in C++, we can make string expressions for
<span class="math">\(\kappa\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">kappa_str</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">kappa_str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;x[0] &gt; -D/2 &amp;&amp; x[0] &lt; -D/2 + D/4 ? kappa_1 : kappa_0&#39;</span>
<span class="n">kappa_str</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;x[0] &gt; -W/4 &amp;&amp; x[0] &lt; W/4 &#39;</span>\
               <span class="s">&#39;&amp;&amp; x[1] &gt; -D/2 &amp;&amp; x[1] &lt; -D/2 + D/4 ? &#39;</span>\
               <span class="s">&#39;kappa_1 : kappa_0&#39;</span>
<span class="n">kappa_str</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;x[0] &gt; -W/4 &amp;&amp; x[0] &lt; W/4 &#39;</span>\
               <span class="s">&#39;x[1] &gt; -W/4 &amp;&amp; x[1] &lt; W/4 &#39;</span>\
               <span class="s">&#39;&amp;&amp; x[2] &gt; -D/2 &amp;&amp; x[2] &lt; -D/2 + D/4 ?&#39;</span>\
               <span class="s">&#39;kappa_1 : kappa_0&#39;</span>

<span class="n">kappa</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="n">kappa_str</span><span class="p">[</span><span class="n">d</span><span class="p">],</span>
                   <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">kappa_0</span><span class="o">=</span><span class="n">kappa_0</span><span class="p">,</span> <span class="n">kappa_1</span><span class="o">=</span><span class="n">kappa_1</span><span class="p">)</span>
</pre></div>
</div>
<p>Let <tt class="docutils literal"><span class="pre">T</span></tt> denote the unknown spatial temperature function at the
current time level, and let <tt class="docutils literal"><span class="pre">T_1</span></tt> be the corresponding function
at one earlier time level.
We are now ready to define the initial condition and the
<tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> forms of our problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T_prev</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">T_R</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>

<span class="n">rho</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">period</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span>
<span class="n">t_stop</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">period</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">period</span><span class="o">/</span><span class="mi">20</span>  <span class="c"># 20 time steps per period</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span>\
    <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">T_prev</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">v</span> <span class="o">-</span>
     <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">T_1</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span><span class="o">*</span><span class="n">dx</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># variable used for memory savings in assemble calls</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># unknown at the current time level</span>
</pre></div>
</div>
<p>We could, alternatively, break <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> up in subexpressions
and assemble a mass matrix and stiffness matrix, as exemplified in
the section <a class="reference internal" href="#tut-timedep-diffusion1-noassemble"><em>Avoiding Assembly</em></a>, to avoid
assembly of <tt class="docutils literal"><span class="pre">b</span></tt> at every time level. This modification is
straightforward and left as an exercise. The speed-up can be significant
in 3D problems.</p>
<p>The time loop is very similar to what we have displayed in
the section <a class="reference internal" href="#tut-timedep-diffusion1-impl"><em>Implementation  (2)</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c"># unknown at the current time level</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">dt</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">t_stop</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">tensor</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
    <span class="n">T_0</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>
    <span class="c"># visualization statements</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">T_prev</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code in <tt class="docutils literal"><span class="pre">sin_daD.py</span></tt> contains several
statements related to visualization and animation of the solution, both as a
finite element field (<tt class="docutils literal"><span class="pre">plot</span></tt> calls) and as a curve in the
vertical direction. The code also plots the exact analytical solution,</p>
<div class="math">
\[T(x,t) = T_R + T_Ae^{ax}\sin (\omega t + ax),\quad a =\sqrt{\omega\varrho c\over 2\kappa},\]</div>
<p>which is valid when <span class="math">\(\kappa = \kappa_0=\kappa_1\)</span>.</p>
<p>Implementing this analytical solution as a Python function
taking scalars and numpy arrays as arguments requires a word of caution.
A straightforward function like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">T_exact</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">kappa_0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">T_R</span> <span class="o">+</span> <span class="n">T_A</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>will not work and result in an error message from UFL. The reason is that
the names <tt class="docutils literal"><span class="pre">exp</span></tt> and <tt class="docutils literal"><span class="pre">sin</span></tt> are those imported
by the <tt class="docutils literal"><span class="pre">from</span> <span class="pre">dolfin</span> <span class="pre">import</span> <span class="pre">*</span></tt> statement, and these names
come from UFL and are aimed at being used in variational forms.
In the <tt class="docutils literal"><span class="pre">T_exact</span></tt> function where <tt class="docutils literal"><span class="pre">x</span></tt> may be a scalar or a
<tt class="docutils literal"><span class="pre">numpy</span></tt> array, we therefore need to explicitly specify
<tt class="docutils literal"><span class="pre">numpy.exp</span></tt> and <tt class="docutils literal"><span class="pre">numpy.sin</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">T_exact</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">kappa_0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">T_R</span> <span class="o">+</span> <span class="n">T_A</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is found in the file
The reader
is encouraged to play around with the code and test out various parameter
sets:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(T_R=0\)</span>, <span class="math">\(T_A=1\)</span>, <span class="math">\(\kappa_0 = \kappa_1=0.2\)</span>, <span class="math">\(\varrho = c = 1\)</span>, <span class="math">\(\omega = 2\pi\)</span></li>
<li><span class="math">\(T_R=0\)</span>, <span class="math">\(T_A=1\)</span>, <span class="math">\(\kappa_0=0.2\)</span>, <span class="math">\(\kappa_1=0.01\)</span>, <span class="math">\(\varrho = c = 1\)</span>, <span class="math">\(\omega = 2\pi\)</span></li>
<li><span class="math">\(T_R=0\)</span>, <span class="math">\(T_A=1\)</span>, <span class="math">\(\kappa_0=0.2\)</span>, <span class="math">\(\kappa_1=0.001\)</span>, <span class="math">\(\varrho = c = 1\)</span>, <span class="math">\(\omega = 2\pi\)</span></li>
<li><span class="math">\(T_R=10\)</span> C, <span class="math">\(T_A=10\)</span> C, <span class="math">\(\kappa_0= 2.3 \hbox{ K}^{-1}\hbox{Ns}^{-1}\)</span>,
<span class="math">\(\kappa_1= 100 \hbox{ K}^{-1}\hbox{Ns}^{-1}\)</span>,
<span class="math">\(\varrho = 1500\hbox{ kg/m}^3\)</span>,
<span class="math">\(c = 1480\hbox{ Nm}\cdot\hbox{kg}^{-1}\hbox{K}^{-1}\)</span>,
<span class="math">\(\omega = 2\pi/24\)</span> 1/h  <span class="math">\(= 7.27\cdot 10^{-5}\)</span> 1/s, <span class="math">\(D=1.5\)</span> m</li>
<li>As above, but <span class="math">\(\kappa_0= 12.3 \hbox{ K}^{-1}\hbox{Ns}^{-1}\)</span> and
<span class="math">\(\kappa_1= 10^4 \hbox{ K}^{-1}\hbox{Ns}^{-1}\)</span></li>
</ol>
</div></blockquote>
<p>Data set number 4 is relevant for real temperature variations in
the ground (not necessarily the large value of <span class="math">\(\kappa_1\)</span>),
while data set number 5
exaggerates the effect of a large heat conduction contrast so that
it becomes clearly visible in an animation.</p>
</div>
</div>
<div class="section" id="creating-more-complex-domains">
<span id="tut-prepro"></span><h1>Creating More Complex Domains<a class="headerlink" href="#creating-more-complex-domains" title="Permalink to this headline">¶</a></h1>
<p>Up to now we have been very fond of the unit square as domain,
which is an appropriate choice for initial versions of a
PDE solver. The strength of the finite element method, however, is its
ease of handling domains with complex shapes. This section
shows some methods that can be used to create different types of
domains and meshes.</p>
<p>Domains of complex shape must normally be constructed in separate
preprocessor programs. Two relevant preprocessors are Triangle for
2D domains and NETGEN for 3D domains.</p>
<div class="section" id="built-in-mesh-generation-tools">
<span id="tut-prepro-builtin"></span><h2>Built-In Mesh Generation Tools<a class="headerlink" href="#built-in-mesh-generation-tools" title="Permalink to this headline">¶</a></h2>
<p>DOLFIN has a few tools for creating various types of meshes over
domains with simple
shape:
<tt class="docutils literal"><span class="pre">UnitIntervalMesh</span></tt>,
<tt class="docutils literal"><span class="pre">UnitSquareMesh</span></tt>,
<tt class="docutils literal"><span class="pre">UnitCubeMesh</span></tt>,
<tt class="docutils literal"><span class="pre">IntervalMesh</span></tt>,
<tt class="docutils literal"><span class="pre">RectangleMesh</span></tt>,
<tt class="docutils literal"><span class="pre">BoxMesh</span></tt>,
<tt class="docutils literal"><span class="pre">UnitCircleMesh</span></tt>,
and
<tt class="docutils literal"><span class="pre">UnitSphere</span></tt>.</p>
<span class="target" id="index-108"></span><span class="target" id="index-109"></span><span class="target" id="index-110"></span><span class="target" id="index-111"></span><span class="target" id="index-112"></span><span class="target" id="index-113"></span><span class="target" id="index-114"></span><p id="index-115">Some of these names have been briefly met in previous sections.
The hopefully self-explanatory code snippet below summarizes
typical constructions of meshes with the aid of these tools:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># 1D domains</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitIntervalMesh</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>     <span class="c"># 20 cells, 21 vertices</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">IntervalMesh</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c"># domain [-1,1]</span>

<span class="c"># 2D domains (6x10 divisions, 120 cells, 77 vertices)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c"># &#39;right&#39; diagonal is default</span>
<span class="c"># The diagonals can be right, left or crossed</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;crossed&#39;</span><span class="p">)</span>

<span class="c"># Domain [0,3]x[0,2] with 6x10 divisions and left diagonals</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;left&#39;</span><span class="p">)</span>

<span class="c"># 6x10x5 boxes in the unit cube, each box gets 6 tetrahedra:</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCubeMesh</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c"># Domain [-1,1]x[-1,0]x[-1,2] with 6x10x5 divisions</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">BoxMesh</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c"># 10 divisions in radial directions</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitCircleMesh</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSphere</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transforming-mesh-coordinates">
<span id="tut-mesh-transform-cyl"></span><h2>Transforming Mesh Coordinates<a class="headerlink" href="#transforming-mesh-coordinates" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-116"></span><span class="target" id="index-117"></span><p id="index-118">A mesh that is denser toward a boundary is often desired to increase
accuracy in that region. Given a mesh with uniformly spaced
coordinates <span class="math">\(x_0,\ldots,x_{M-1}\)</span> in <span class="math">\([a,b]\)</span>, the coordinate transformation
<span class="math">\(\xi = (x-a)/(b-a)\)</span> maps <span class="math">\(x\)</span> onto <span class="math">\(\xi\in [0,1]\)</span>. A new mapping
<span class="math">\(\eta = \xi^s\)</span>, for some <span class="math">\(s&gt;1\)</span>, stretches the mesh toward <span class="math">\(\xi=0\)</span> (<span class="math">\(x=a\)</span>),
while <span class="math">\(\eta = \xi^{1/s}\)</span> makes a stretching toward <span class="math">\(\xi=1\)</span> (<span class="math">\(x=b\)</span>).
Mapping the <span class="math">\(\eta\in[0,1]\)</span> coordinates back to <span class="math">\([a,b]\)</span> gives new,
stretched <span class="math">\(x\)</span> coordinates,</p>
<div class="math">
\[\bar x = a + (b-a)\left({x-a\over b-a}\right)^s\]</div>
<p>toward <span class="math">\(x=a\)</span>, or</p>
<div class="math">
\[\bar x = a + (b-a)\left({x-a\over b-a}\right)^{1/s}\]</div>
<p>toward <span class="math">\(x=b\)</span></p>
<p>One way of creating more complex geometries is to transform the
vertex coordinates in a rectangular mesh according to some formula.
Say we want to create a part of a hollow cylinder of <span class="math">\(\Theta\)</span> degrees,
with inner radius <span class="math">\(a\)</span> and outer radius <span class="math">\(b\)</span>. A standard mapping from polar
coordinates to Cartesian coordinates can be used to generate the
hollow cylinder. Given a rectangle in <span class="math">\((\bar x, \bar y)\)</span> space such that
<span class="math">\(a\leq \bar x\leq b\)</span> and <span class="math">\(0\leq \bar y\leq 1\)</span>, the mapping</p>
<div class="math">
\[\hat x = \bar x\cos (\Theta \bar y),\quad \hat y = \bar x\sin (\Theta \bar y),\]</div>
<p>takes a point in the rectangular <span class="math">\((\bar x,\bar y)\)</span>
geometry and maps it to a point
<span class="math">\((\hat x, \hat y)\)</span> in a hollow cylinder.</p>
<p>The corresponding Python code for first stretching the mesh and
then mapping it onto a hollow cylinder looks as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Theta</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">5.0</span>
<span class="n">nr</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c"># divisions in r direction</span>
<span class="n">nt</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c"># divisions in theta direction</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="s">&#39;crossed&#39;</span><span class="p">)</span>

<span class="c"># First make a denser mesh towards r=a</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">s</span> <span class="o">=</span> <span class="mf">1.3</span>

<span class="k">def</span> <span class="nf">denser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">))</span><span class="o">**</span><span class="n">s</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span> <span class="o">=</span> <span class="n">denser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">xy_bar_coor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">xy_bar_coor</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;stretched mesh&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cylinder</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Theta</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Theta</span><span class="o">*</span><span class="n">s</span><span class="p">)]</span>

<span class="n">x_hat</span><span class="p">,</span> <span class="n">y_hat</span> <span class="o">=</span> <span class="n">cylinder</span><span class="p">(</span><span class="n">x_bar</span><span class="p">,</span> <span class="n">y_bar</span><span class="p">)</span>
<span class="n">xy_hat_coor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_hat</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">xy_hat_coor</span>
<span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;hollow cylinder&#39;</span><span class="p">)</span>
<span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>The result of calling <tt class="docutils literal"><span class="pre">denser</span></tt> and <tt class="docutils literal"><span class="pre">cylinder</span></tt> above is a list of two
vectors, with the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> coordinates, respectively.
Turning this list into a <tt class="docutils literal"><span class="pre">numpy</span></tt> array object results in a <span class="math">\(2\times M\)</span>
array, <span class="math">\(M\)</span> being the number of vertices in the mesh. However,
<tt class="docutils literal"><span class="pre">mesh.coordinates()</span></tt> is by a convention an <span class="math">\(M\times 2\)</span> array so we
need to take the transpose. The resulting mesh is displayed
in Figure <a class="reference internal" href="#tut-mesh-transform-cyl-fig1"><em>Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side</em></a>.</p>
<div class="figure" id="tut-mesh-transform-cyl-fig1">
<img alt="_images/hollow_cylinder.png" src="_images/hollow_cylinder.png" style="width: 480px;" />
<p class="caption"><em>Hollow cylinder generated by mapping a rectangular mesh, stretched toward the left side</em></p>
</div>
<p>Setting boundary conditions in meshes created from mappings like the one
illustrated above is most conveniently done by using a mesh function
to mark parts of the boundary. The marking is easiest to perform
before the mesh is mapped since one can then conceptually work with
the sides in a pure rectangle.</p>
</div>
</div>
<div class="section" id="handling-domains-with-different-materials">
<h1>Handling Domains with Different Materials<a class="headerlink" href="#handling-domains-with-different-materials" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-119"></span><p id="index-120">Solving PDEs in domains made up of different materials is a frequently
encountered task. In FEniCS, these kind of problems are handled by
defining subdomains inside the domain. The subdomains may represent the
various materials. We can thereafter define material properties through
functions, known in FEniCS as <em>mesh functions</em>,
that are piecewise constant in each subdomain.
A simple example with
two materials (subdomains) in 2D will
demonstrate the basic steps in the process.</p>
<div class="section" id="working-with-two-subdomains">
<span id="tut-possion-2d-2mat-problem"></span><h2>Working with Two Subdomains<a class="headerlink" href="#working-with-two-subdomains" title="Permalink to this headline">¶</a></h2>
<p>Suppose we want to solve</p>
<div class="math" id="equation-tut:poisson:2D:2mat:varcoeff2">
<span class="eqno">(49)</span>\[         \nabla\cdot \left\lbrack k(x,y)\nabla u(x,y)\right\rbrack = 0,\]</div>
<p>in a domain <span class="math">\(\Omega\)</span> consisting of two subdomains where <span class="math">\(k\)</span> takes on
a different value in each subdomain.
For simplicity, yet without loss of generality, we choose for the current
implementation
the domain <span class="math">\(\Omega = [0,1]\times [0,1]\)</span> and divide it into two equal
subdomains,</p>
<div class="math">
\[\Omega_0 = [0, 1]\times [0,1/2],\quad
\Omega_1 = [0, 1]\times (1/2,1]{\thinspace . }\]</div>
<p>We define <span class="math">\(k(x,y)=k_0\)</span> in <span class="math">\(\Omega_0\)</span> and <span class="math">\(k(x,y)=k_1\)</span> in <span class="math">\(\Omega_1\)</span>,
where <span class="math">\(k_0&gt;0\)</span> and <span class="math">\(k_1&gt;0\)</span> are given constants.
As boundary conditions, we choose <span class="math">\(u=0\)</span> at <span class="math">\(y=0\)</span>, <span class="math">\(u=1\)</span> at <span class="math">\(y=1\)</span>,
and <span class="math">\(\partial u/\partial n=0\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(x=1\)</span>.
One can show that the exact solution is now given by</p>
<div class="math">
\[\begin{split}u(x, y) = \left\lbrace\begin{array}{ll}
{2yk_1\over k_0+k_1}, &amp; y \leq 1/2\\
{(2y-1)k_0 + k_1\over k_0+k_1}, &amp; y \geq 1/2
\end{array}\right.\end{split}\]</div>
<p>As long as the element boundaries coincide with the internal boundary
<span class="math">\(y=1/2\)</span>, this piecewise linear solution should be exactly recovered
by Lagrange elements of any degree. We use this property to verify
the implementation.</p>
<p>Physically, the present problem may correspond to heat conduction, where
the heat conduction in <span class="math">\(\Omega_1\)</span> is ten times more efficient than
in <span class="math">\(\Omega_0\)</span>. An alternative interpretation is flow in porous media
with two geological layers, where the layers&#8217; ability to transport
the fluid differs by a factor of 10.</p>
</div>
<div class="section" id="implementation-3">
<span id="tut-possion-2d-2mat-impl"></span><h2>Implementation  (3)<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-121"></span><p id="index-122">The new functionality in this subsection regards how to
define the subdomains
<span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>. For this purpose we need to
use subclasses of class <tt class="docutils literal"><span class="pre">SubDomain</span></tt>,
not only plain functions as we have used so far
for specifying boundaries. Consider the boundary function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>for defining the boundary <span class="math">\(x=0\)</span>. Instead of using such a stand-alone
function, we can create an instance (or object)
of a subclass of <tt class="docutils literal"><span class="pre">SubDomain</span></tt>,
which implements the <tt class="docutils literal"><span class="pre">inside</span></tt> method as an alternative to the
<tt class="docutils literal"><span class="pre">boundary</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">()</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">boundary</span><span class="p">)</span>
</pre></div>
</div>
<p>A word about computer science terminology may be used here:
The term <em>instance</em>
means a Python object of a particular type (such as <tt class="docutils literal"><span class="pre">SubDomain</span></tt>,
<tt class="docutils literal"><span class="pre">Function</span></tt>
<tt class="docutils literal"><span class="pre">FunctionSpace</span></tt>, etc.).
Many use <em>instance</em> and <em>object</em>
as interchangeable terms. In other computer programming languages one may
also use the term <em>variable</em> for the same thing.
We mostly use the well-known  term <em>object</em> in this text.</p>
<p>A subclass of <tt class="docutils literal"><span class="pre">SubDomain</span></tt> with an <tt class="docutils literal"><span class="pre">inside</span></tt> method offers
functionality for marking parts of the domain or
the boundary. Now we need to define one class for the
subdomain <span class="math">\(\Omega_0\)</span>
where <span class="math">\(y\leq 1/2\)</span> and another for the subdomain <span class="math">\(\Omega_1\)</span> where <span class="math">\(y\geq 1/2\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Omega0</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="bp">False</span>

<span class="k">class</span> <span class="nc">Omega1</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="bp">False</span>
</pre></div>
</div>
<p>Notice the use of <tt class="docutils literal"><span class="pre">&lt;=</span></tt> and <tt class="docutils literal"><span class="pre">&gt;=</span></tt> in both tests. For a cell to
belong to, e.g., <span class="math">\(\Omega_1\)</span>, the <tt class="docutils literal"><span class="pre">inside</span></tt> method must return
<tt class="docutils literal"><span class="pre">True</span></tt> for all the vertices <tt class="docutils literal"><span class="pre">x</span></tt> of the cell. So to make the
cells at the internal boundary <span class="math">\(y=1/2\)</span> belong to <span class="math">\(\Omega_1\)</span>, we need
the test <tt class="docutils literal"><span class="pre">x[1]</span> <span class="pre">&gt;=</span> <span class="pre">0.5</span></tt>.</p>
<p>The next task is to use a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> to mark all
cells in <span class="math">\(\Omega_0\)</span> with the subdomain number 0 and all cells in <span class="math">\(\Omega_1\)</span>
with the subdomain number 1.
Our convention is to number subdomains as <span class="math">\(0,1,2,\ldots\)</span>.</p>
<p>A <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> is a discrete function that can be evaluated at a set
of so-called <em>mesh entities</em>. Examples of mesh entities are
cells, facets, and vertices. A <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> over cells is suitable to
represent subdomains (materials), while a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> over
facets is used to represent pieces of external or internal boundaries.
Mesh functions over vertices can be used to describe continuous fields.</p>
<p>Since we need to define subdomains of <span class="math">\(\Omega\)</span>
in the present example, we must make use
of a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> over cells. The
<tt class="docutils literal"><span class="pre">MeshFunction</span></tt> constructor is fed with three arguments: 1) the type
of value: <tt class="docutils literal"><span class="pre">'int'</span></tt> for integers, <tt class="docutils literal"><span class="pre">'uint'</span></tt> for positive
(unsigned) integers, <tt class="docutils literal"><span class="pre">'double'</span></tt> for real numbers, and
<tt class="docutils literal"><span class="pre">'bool'</span></tt> for logical values; 2) a <tt class="docutils literal"><span class="pre">Mesh</span></tt> object, and 3)
the topological dimension of the mesh entity in question: cells
have topological dimension equal to the number of space dimensions in
the PDE problem, and facets have one dimension lower.
Alternatively, the constructor can take just a filename
and initialize the <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> from data in a file.</p>
<p>We start with creating a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> whose
values are non-negative integers (<tt class="docutils literal"><span class="pre">'uint'</span></tt>)
for numbering the subdomains.
The mesh entities of interest are the cells, which have dimension 2
in a two-dimensional problem (1 in 1D, 3 in 3D). The appropriate code for
defining the <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> for two subdomains then reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&#39;uint&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c"># Mark subdomains with numbers 0 and 1</span>
<span class="n">subdomain0</span> <span class="o">=</span> <span class="n">Omega0</span><span class="p">()</span>
<span class="n">subdomain0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">subdomain1</span> <span class="o">=</span> <span class="n">Omega1</span><span class="p">()</span>
<span class="n">subdomain1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">subdomains.array()</span></tt> returns a <tt class="docutils literal"><span class="pre">numpy</span></tt> array of the
subdomain values. That is, <tt class="docutils literal"><span class="pre">subdomain.array()[i]</span></tt> is
the subdomain value of cell number <tt class="docutils literal"><span class="pre">i</span></tt>. This array is used to
look up the subdomain or material number of a specific element.</p>
<p>We need a function <tt class="docutils literal"><span class="pre">k</span></tt> that is constant in
each subdomain <span class="math">\(\Omega_0\)</span> and <span class="math">\(\Omega_1\)</span>. Since we want <tt class="docutils literal"><span class="pre">k</span></tt>
to be a finite element function, it is natural to choose
a space of functions that are constant over each element.
The family of discontinuous Galerkin methods, in FEniCS
denoted by <tt class="docutils literal"><span class="pre">'DG'</span></tt>, is suitable for this purpose. Since we
want functions that are piecewise constant, the value of
the degree parameter is zero:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">V0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&#39;DG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">k</span>  <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V0</span><span class="p">)</span>
</pre></div>
</div>
<p>To fill <tt class="docutils literal"><span class="pre">k</span></tt> with the right values in each element, we loop over
all cells (i.e., indices in <tt class="docutils literal"><span class="pre">subdomain.array()</span></tt>),
extract the corresponding subdomain number of a cell,
and assign the corresponding <span class="math">\(k\)</span> value to the <tt class="docutils literal"><span class="pre">k.vector()</span></tt> array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>  <span class="c"># values of k in the two subdomains</span>
<span class="k">for</span> <span class="n">cell_no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">())):</span>
    <span class="n">subdomain_no</span> <span class="o">=</span> <span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">()[</span><span class="n">cell_no</span><span class="p">]</span>
    <span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[</span><span class="n">cell_no</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_values</span><span class="p">[</span><span class="n">subdomain_no</span><span class="p">]</span>
</pre></div>
</div>
<p>Long loops in Python are known to be slow, so for large meshes
it is preferable to avoid such loops and instead use <em>vectorized code</em>.
Normally this implies that the loop must be replaced by
calls to functions from the <tt class="docutils literal"><span class="pre">numpy</span></tt> library that operate on complete
arrays (in efficient C code). The functionality we want in the present
case is to compute an array of the same size as
<tt class="docutils literal"><span class="pre">subdomain.array()</span></tt>, but where the value <tt class="docutils literal"><span class="pre">i</span></tt> of an entry
in <tt class="docutils literal"><span class="pre">subdomain.array()</span></tt> is replaced by <tt class="docutils literal"><span class="pre">k_values[i]</span></tt>.
Such an operation is carried out by the <tt class="docutils literal"><span class="pre">numpy</span></tt> function <tt class="docutils literal"><span class="pre">choose</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">help</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subdomains</span><span class="o">.</span><span class="n">array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">help</span><span class="p">,</span> <span class="n">k_values</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">help</span></tt> array is required since <tt class="docutils literal"><span class="pre">choose</span></tt> cannot work with
<tt class="docutils literal"><span class="pre">subdomain.array()</span></tt> because this array has elements of
type <tt class="docutils literal"><span class="pre">uint32</span></tt>. We must therefore transform this array to an array
<tt class="docutils literal"><span class="pre">help</span></tt> with standard <tt class="docutils literal"><span class="pre">int32</span></tt> integers.</p>
<p>Having the <tt class="docutils literal"><span class="pre">k</span></tt> function ready for finite element computations, we
can proceed in the normal manner with defining essential boundary
conditions, as in the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>,
and the <span class="math">\(a(u,v)\)</span> and <span class="math">\(L(v)\)</span> forms, as in
the section <a class="reference internal" href="#tut-possion-2d-varcoeff"><em>A Variable-Coefficient Poisson Problem</em></a>.
All the details can be found in the file <tt class="docutils literal"><span class="pre">mat2_p2D.py</span></tt>.</p>
</div>
<div class="section" id="multiple-neumann-robin-and-dirichlet-condition">
<span id="tut-poisson-mat-neumann"></span><h2>Multiple Neumann, Robin, and Dirichlet Condition<a class="headerlink" href="#multiple-neumann-robin-and-dirichlet-condition" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-123"></span><span class="target" id="index-124"></span><span class="target" id="index-125"></span><p id="index-126">Let us go back to the model problem from
the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>
where we had both Dirichlet and Neumann conditions.
The term <tt class="docutils literal"><span class="pre">v*g*ds</span></tt> in the expression for <tt class="docutils literal"><span class="pre">L</span></tt> implies a
boundary integral over the complete boundary, or in FEniCS terms,
an integral over all exterior facets.
However, the contributions from the parts of the boundary where we have
Dirichlet conditions are erased when the linear system is modified by
the Dirichlet conditions.
We would like, from an efficiency point of view, to integrate <tt class="docutils literal"><span class="pre">v*g*ds</span></tt>
only over the parts of the boundary where we actually have Neumann conditions.
And more importantly,
in other problems one may have different Neumann conditions or
other conditions like the Robin type condition.
With the mesh function concept we can mark
different parts of the boundary and integrate over specific parts.
The same concept can also be used to treat multiple Dirichlet conditions.
The forthcoming text illustrates how this is done.</p>
<p>Essentially, we still stick to the model problem from
the section <a class="reference internal" href="#tut-poisson-multiple-dirichlet"><em>Multiple Dirichlet Conditions</em></a>, but replace the
Neumann condition at <span class="math">\(y=0\)</span> by a <em>Robin condition</em>:</p>
<div class="math">
\[-{\partial u\over\partial n} = p(u-q),\]</div>
<p>where <span class="math">\(p\)</span> and <span class="math">\(q\)</span> are specified functions.
The Robin condition is
most often used to model heat transfer to the surroundings and arise
naturally from Newton&#8217;s cooling law.</p>
<p>Since we have prescribed a simple solution in our model problem,
<span class="math">\(u=1+x^2+2y^2\)</span>, we adjust <span class="math">\(p\)</span> and <span class="math">\(q\)</span> such that the condition holds
at <span class="math">\(y=0\)</span>. This implies that <span class="math">\(q=1+x^2+2y^2\)</span> and <span class="math">\(p\)</span> can be arbitrary
(the normal derivative at <span class="math">\(y=0\)</span>: <span class="math">\(\partial u/\partial n = -\partial u/\partial y = -4y=0\)</span>).</p>
<p>Now we have four parts of the boundary: <span class="math">\(\Gamma_N\)</span> which corresponds to
the upper side <span class="math">\(y=1\)</span>, <span class="math">\(\Gamma_R\)</span> which corresponds to the lower part
<span class="math">\(y=0\)</span>, <span class="math">\(\Gamma_0\)</span> which corresponds to the left part <span class="math">\(x=0\)</span>, and
<span class="math">\(\Gamma_1\)</span> which corresponds to the right part <span class="math">\(x=1\)</span>. The
complete boundary-value problem reads</p>
<div class="math" id="equation-tut:poisson:2D:DN3">
<span class="eqno">(50)</span>\[         - \nabla^2 u = -6 \mbox{ in } \Omega,\]</div>
<div class="math" id="equation-tut:poisson:2D:DN3:bc1">
<span class="eqno">(51)</span>\[         u = u_L \mbox{ on } \Gamma_0,\]</div>
<div class="math" id="equation-tut:poisson:2D:DN3:bc2">
<span class="eqno">(52)</span>\[         u = u_R \mbox{ on } \Gamma_1,\]</div>
<div class="math" id="equation-tut:poisson:2D:DN3:bc3">
<span class="eqno">(53)</span>\[         - {\partial u\over\partial n} = p(u-q) \mbox{ on } \Gamma_R,\]</div>
<div class="math" id="equation-tut:poisson:2D:DN3:bc4">
<span class="eqno">(54)</span>\[         - {\partial u\over\partial n} = g \mbox{ on } \Gamma_N{\thinspace . }\]</div>
<p>The involved prescribed functions are <span class="math">\(u_L= 1 + 2y^2\)</span>,
<span class="math">\(u_R = 2 + 2y^2\)</span>, <span class="math">\(q=1+x^2+2y^2\)</span>, <span class="math">\(p\)</span> is arbitrary, and <span class="math">\(g=-4y\)</span>.</p>
<p>Integration by parts of <span class="math">\(-\int_\Omega v\nabla^2 u {\, \mathrm{d}x}\)</span> becomes
as usual</p>
<div class="math">
\[ -\int_\Omega v\nabla^2 u {\, \mathrm{d}x}
= \int_\Omega\nabla u\cdot \nabla v {\, \mathrm{d}x} - \int_{\partial\Omega}{\partial u\over
\partial n}v {\, \mathrm{d}s}{\thinspace . }\]</div>
<p>The boundary integral vanishes on <span class="math">\(\Gamma_0\cup\Gamma_1\)</span>, and
we split the parts over <span class="math">\(\Gamma_N\)</span> and <span class="math">\(\Gamma_R\)</span> since we have
different conditions at those parts:</p>
<div class="math">
\[- \int_{\partial\Omega}v{\partial u\over\partial n} {\, \mathrm{d}s}
=
-\int_{\Gamma_N}v{\partial u\over\partial n} {\, \mathrm{d}s} -
\int_{\Gamma_R}v{\partial u\over\partial n} {\, \mathrm{d}s}
= \int_{\Gamma_N}vg {\, \mathrm{d}s} +
\int_{\Gamma_R}vp(u-q) {\, \mathrm{d}s}{\thinspace . }\]</div>
<p>The weak form then becomes</p>
<div class="math">
\[\int_{\Omega} \nabla u\cdot \nabla v {\, \mathrm{d}x} +
\int_{\Gamma_N} gv {\, \mathrm{d}s} + \int_{\Gamma_R}p(u-q)v {\, \mathrm{d}s}
= \int_{\Omega} fv {\, \mathrm{d}x},\]</div>
<p>We want to write this weak form in the standard
notation <span class="math">\(a(u,v)=L(v)\)</span>, which
requires that we identify all integrals with <em>both</em> <span class="math">\(u\)</span> and <span class="math">\(v\)</span>,
and collect these in <span class="math">\(a(u,v)\)</span>, while the remaining integrals with
<span class="math">\(v\)</span> and not <span class="math">\(u\)</span> go
into <span class="math">\(L(v)\)</span>.
The integral from the Robin condition must of this reason be split in two
parts:</p>
<div class="math">
\[\int_{\Gamma_R}p(u-q)v {\, \mathrm{d}s}
= \int_{\Gamma_R}puv {\, \mathrm{d}s} - \int_{\Gamma_R}pqv {\, \mathrm{d}s}{\thinspace . }\]</div>
<p>We then have</p>
<div class="math" id="equation-tut:poisson:2D:DN3:var:a">
<span class="eqno">(55)</span>\[     a(u, v) = \int_{\Omega} \nabla u\cdot \nabla v {\, \mathrm{d}x}
     + \int_{\Gamma_R}puv {\, \mathrm{d}s},\]</div>
<div class="math" id="equation-tut:poisson:2D:DN3:var:L">
<span class="eqno">(56)</span>\[     L(v) = \int_{\Omega} fv {\, \mathrm{d}x} -
     \int_{\Gamma_N} g v {\, \mathrm{d}s} + \int_{\Gamma_R}pqv {\, \mathrm{d}s}{\thinspace . }\]</div>
<p id="index-127">A natural starting point for implementation is the
<tt class="docutils literal"><span class="pre">dn2_p2D.py</span></tt>
program in the directory <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>. The new aspects
are</p>
<blockquote>
<div><ul class="simple">
<li>definition of a mesh function over the boundary,</li>
<li>marking each side as a subdomain, using the mesh function,</li>
<li>splitting a boundary integral into parts.</li>
</ul>
</div></blockquote>
<p>Task 1 makes use of the <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> object, but contrary to
the section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><em>Implementation  (3)</em></a>, this is not a function over
cells, but a function over cell facets. The topological dimension of
cell facets is one lower than the cell interiors, so in a two-dimensional
problem the dimension
becomes 1. In general, the facet dimension
is given as <tt class="docutils literal"><span class="pre">mesh.topology().dim()-1</span></tt>,
which we use in the code for ease of direct reuse in other problems.
The construction of a <tt class="docutils literal"><span class="pre">MeshFunction</span></tt> object to mark boundary parts
now reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">boundary_parts</span> <span class="o">=</span> \
  <span class="n">MeshFunction</span><span class="p">(</span><span class="s">&quot;uint&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>As in the section <a class="reference internal" href="#tut-possion-2d-2mat-impl"><em>Implementation  (3)</em></a> we
use a subclass of <tt class="docutils literal"><span class="pre">SubDomain</span></tt> to identify the various parts
of the mesh function. Problems with domains of more complicated geometries may
set the mesh function for marking boundaries as part of the mesh
generation.
In our case, the <span class="math">\(y=0\)</span> boundary can be marked by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LowerRobinBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_R</span> <span class="o">=</span> <span class="n">LowerRobinBoundary</span><span class="p">()</span>
<span class="n">Gamma_R</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The code for the <span class="math">\(y=1\)</span> boundary is similar and is seen in
<tt class="docutils literal"><span class="pre">dnr_p2D.py</span></tt>.</p>
<p>The Dirichlet boundaries are marked similarly, using subdomain number 2 for <span class="math">\(\Gamma_0\)</span> and 3 for <span class="math">\(\Gamma_1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LeftBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_0</span> <span class="o">=</span> <span class="n">LeftBoundary</span><span class="p">()</span>
<span class="n">Gamma_0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">RightBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>   <span class="c"># tolerance for coordinate comparisons</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>

<span class="n">Gamma_1</span> <span class="o">=</span> <span class="n">RightBoundary</span><span class="p">()</span>
<span class="n">Gamma_1</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Specifying the <tt class="docutils literal"><span class="pre">DirichletBC</span></tt> objects may now make use of
the mesh function (instead of a <tt class="docutils literal"><span class="pre">SubDomain</span></tt> subclass object)
and an indicator for which subdomain each condition
should be applied to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_L</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
<span class="n">u_R</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;2 + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_L</span><span class="p">,</span> <span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
       <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u_R</span><span class="p">,</span> <span class="n">boundary_parts</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Some functions need to be defined before we can go on with the
<tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> of the variational problem:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;-4*x[1]&#39;</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;1 + x[0]*x[0] + 2*x[1]*x[1]&#39;</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>  <span class="c"># arbitrary function can go here</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">6.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The new aspect of the variational problem is the two distinct
boundary integrals.
Having a mesh function over exterior cell facets (our
<tt class="docutils literal"><span class="pre">boundary_parts</span></tt> object), where subdomains (boundary parts) are
numbered as <span class="math">\(0,1,2,\ldots\)</span>, the special symbol <tt class="docutils literal"><span class="pre">ds(0)</span></tt>
implies integration over subdomain (part) 0, <tt class="docutils literal"><span class="pre">ds(1)</span></tt> denotes
integration over subdomain (part) 1, and so on.
The idea of multiple <tt class="docutils literal"><span class="pre">ds</span></tt>-type objects generalizes to volume
integrals too: <tt class="docutils literal"><span class="pre">dx(0)</span></tt>, <tt class="docutils literal"><span class="pre">dx(1)</span></tt>, etc., are used to
integrate over subdomain 0, 1, etc.,  inside <span class="math">\(\Omega\)</span>.</p>
<p>The variational problem can be defined as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">nabla_grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">nabla_grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">ds</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>For the <tt class="docutils literal"><span class="pre">ds(0)</span></tt> and <tt class="docutils literal"><span class="pre">ds(1)</span></tt> symbols to work we must obviously
connect them (or <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt>) to the mesh function marking
parts of the boundary. This is done by a certain keyword argument
to the <tt class="docutils literal"><span class="pre">assemble</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">exterior_facet_domains</span><span class="o">=</span><span class="n">boundary_parts</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">exterior_facet_domains</span><span class="o">=</span><span class="n">boundary_parts</span><span class="p">)</span>
</pre></div>
</div>
<p>Then essential boundary conditions are enforced, and the system can
be solved in the usual way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
<span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The complete code is in the <tt class="docutils literal"><span class="pre">dnr_p2D.py</span></tt> file in the
<tt class="docutils literal"><span class="pre">stationary/poisson</span></tt> directory.</p>
</div>
</div>
<div class="section" id="more-examples">
<h1>More Examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">¶</a></h1>
<p>Many more topics could be treated in a FEniCS tutorial, e.g., how
to solve systems of PDEs, how to work with mixed finite element
methods, how to create more complicated meshes and mark boundaries,
and how to create more advanced visualizations.  However, to limit the
size of this tutorial, the examples end here.
There are, fortunately, a rich set of FEniCS demos.
The FEniCS documentation explains a collection of PDE solvers in detail:
the Poisson equation, the mixed formulation for the Poission equation,
the Biharmonic equation, the equations of hyperelasticity, the
Cahn-Hilliard equation, and the incompressible Navier-Stokes equations.
Both Python and C++ versions of these solvers are explained.
An eigenvalue solver is also documented.
In the <tt class="docutils literal"><span class="pre">dolfin/demo</span></tt> directory of the DOLFIN source code tree you can
find programs for these and many other examples, including
the advection-diffusion equation,
the equations of elastodynamics,
a reaction-diffusion equation,
various finite element methods for the Stokes problem,
discontinuous Galerkin methods for
the Poisson and advection-diffusion equations,
and an eigenvalue problem arising from electromagnetic waveguide
problem with Nedelec elements.
There are also numerous demos on how to apply various functionality in
FEniCS, e.g., mesh refinement and error control,
moving meshes (for ALE methods),
computing functionals over subsets of the mesh (such as
lift and drag on bodies in flow), and
creating separate subdomain meshes from a parent mesh.</p>
<p>The project cbc.solve (<a class="reference external" href="https://launchpad.net/cbc.solve">https://launchpad.net/cbc.solve</a>) offers
more complete PDE solvers for the Navier-Stokes equations, the
equations of hyperelasticity, fluid-structure interaction, viscous
mantle flow, and the bidomain model of electrophysiology.  Most of
these solvers are described in the &#8220;FEniCS book&#8221; <a class="reference internal" href="#ref01">[Ref01]</a>
(<a class="reference external" href="https://launchpad.net/fenics-book">https://launchpad.net/fenics-book</a>).  Another project, cbc.rans
(<a class="reference external" href="https://launchpad.net/cbc.rans">https://launchpad.net/cbc.rans</a>), offers an environment for very
flexible and easy implementation of Navier-Stokes solvers and
turbulence <a class="reference internal" href="#ref02">[Ref02]</a> <a class="reference internal" href="#ref03">[Ref03]</a>. For example, cbc.rans
contains an elliptic relaxation model for turbulent flow involving 18
nonlinear PDEs.  FEniCS proved to be an ideal environment for
implementing such complicated PDE models.  The easy construction of
systems of nonlinear PDEs in cbc.rans has been further generalized to
simplify the implementation of large systems of nonlinear PDEs in
general.  The functionality is found in the cbc.pdesys package
(<a class="reference external" href="https://launchpad.net/cbcpdesys">https://launchpad.net/cbcpdesys</a>).</p>
</div>
<div class="section" id="miscellaneous-topics">
<h1>Miscellaneous Topics<a class="headerlink" href="#miscellaneous-topics" title="Permalink to this headline">¶</a></h1>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-128"></span><span class="target" id="index-129"></span><span class="target" id="index-130"></span><span class="target" id="index-131"></span><span class="target" id="index-132"></span><span class="target" id="index-133"></span><span class="target" id="index-134"></span><span class="target" id="index-135"></span><p id="index-136">Below we explain some key terms used in this tutorial.</p>
<blockquote>
<div><dl class="docutils">
<dt>FEniCS: name of a software suite composed of many individual software</dt>
<dd>components (see <tt class="docutils literal"><span class="pre">fenicsproject.org</span></tt>). Some components are DOLFIN and
Viper, explicitly referred to in this tutorial. Others are
FFC and FIAT, heavily used by the programs appearing in this tutorial,
but never explicitly used from the programs.</dd>
<dt>DOLFIN: a FEniCS component, more precisely a C++ library, with</dt>
<dd>a Python interface, for performing important actions in finite element
programs. DOLFIN makes use of many other FEniCS components and
many external software packages.</dd>
<dt>Viper:  a FEniCS component for quick visualization of finite element</dt>
<dd>meshes and solutions.</dd>
<dt>UFL:    a FEniCS component implementing the <em>unified form language</em></dt>
<dd>for specifying finite element forms in FEniCS programs.
The definition of the forms, typically called <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">L</span></tt> in
this tutorial, must have legal UFL syntax. The same applies to
the definition of functionals (see the section <a class="reference internal" href="#tut-poisson1-functionals"><em>Computing Functionals</em></a>).</dd>
<dt>Class (Python): a programming construction for creating objects</dt>
<dd>containing a set of variables and functions. Most
types of FEniCS objects are defined through the class concept.</dd>
<dt>Instance (Python): an object of a particular type, where the type is</dt>
<dd>implemented as a class. For instance,
<tt class="docutils literal"><span class="pre">mesh</span> <span class="pre">=</span> <span class="pre">UnitIntervalMesh(10)</span></tt> creates
an instance of class <tt class="docutils literal"><span class="pre">UnitIntervalMesh</span></tt>, which is reached by the
name <tt class="docutils literal"><span class="pre">mesh</span></tt>. (Class <tt class="docutils literal"><span class="pre">UnitIntervalMesh</span></tt> is actually just
an interface to a corresponding C++ class in the DOLFIN C++ library.)</dd>
<dt>Class method (Python): a function in a class, reached by dot</dt>
<dd>notation: <tt class="docutils literal"><span class="pre">instance_name.method_name</span></tt></dd>
<dt>argument <tt class="docutils literal"><span class="pre">self</span></tt> (Python): required first parameter in class methods,</dt>
<dd>representing a particular object of the class.
Used in method definitions, but never in calls to a method.
For example, if <tt class="docutils literal"><span class="pre">method(self,</span> <span class="pre">x)</span></tt> is the definition of
<tt class="docutils literal"><span class="pre">method</span></tt> in a class <tt class="docutils literal"><span class="pre">Y</span></tt>, <tt class="docutils literal"><span class="pre">method</span></tt> is called as
<tt class="docutils literal"><span class="pre">y.method(x)</span></tt>, where <tt class="docutils literal"><span class="pre">y</span></tt> is an instance of class <tt class="docutils literal"><span class="pre">Y</span></tt>.
In a call like <tt class="docutils literal"><span class="pre">y.method(x)</span></tt>, <tt class="docutils literal"><span class="pre">method</span></tt> is invoked with
<tt class="docutils literal"><span class="pre">self=y</span></tt>.</dd>
<dt>Class attribute (Python): a variable in a class, reached by</dt>
<dd>dot notation: <tt class="docutils literal"><span class="pre">instance_name.attribute_name</span></tt></dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="overview-of-objects-and-functions">
<h2>Overview of Objects and Functions<a class="headerlink" href="#overview-of-objects-and-functions" title="Permalink to this headline">¶</a></h2>
<p>Most classes in FEniCS have an explanation of the purpose and usage
that can be seen by using the general documentation command
<tt class="docutils literal"><span class="pre">pydoc</span></tt> for Python objects. You can type</p>
<div class="highlight-console" id="index-137"><div class="highlight"><pre><span class="go">pydoc dolfin.X</span>
</pre></div>
</div>
<p>to look up documentation of a Python class <tt class="docutils literal"><span class="pre">X</span></tt> from the DOLFIN
library (<tt class="docutils literal"><span class="pre">X</span></tt> can be <tt class="docutils literal"><span class="pre">UnitSquareMesh</span></tt>, <tt class="docutils literal"><span class="pre">Function</span></tt>,
<tt class="docutils literal"><span class="pre">Viper</span></tt>, etc.). Below is an overview of the most important classes
and functions
in FEniCS programs, in the order they typically appear within programs.</p>
<p><tt class="docutils literal"><span class="pre">UnitSquareMesh(nx,</span> <span class="pre">ny)</span></tt>: generate mesh over the unit square
<span class="math">\([0,1]\times [0,1]\)</span> using <tt class="docutils literal"><span class="pre">nx</span></tt> divisions in <span class="math">\(x\)</span> direction and
<tt class="docutils literal"><span class="pre">ny</span></tt> divisions in <span class="math">\(y\)</span> direction. Each of the <tt class="docutils literal"><span class="pre">nx*ny</span></tt> squares
are divided into two cells of triangular shape.</p>
<p><tt class="docutils literal"><span class="pre">UnitIntervalMesh</span></tt>, <tt class="docutils literal"><span class="pre">UnitCubeMesh</span></tt>, <tt class="docutils literal"><span class="pre">UnitCircleMesh</span></tt>, <tt class="docutils literal"><span class="pre">UnitSphere</span></tt>,
<tt class="docutils literal"><span class="pre">IntervalMesh</span></tt>, <tt class="docutils literal"><span class="pre">RectangleMesh</span></tt>, and <tt class="docutils literal"><span class="pre">BoxMesh</span></tt>: generate mesh over
domains of simple geometric shape, see the section <a class="reference internal" href="#tut-prepro"><em>Creating More Complex Domains</em></a>.</p>
<p><tt class="docutils literal"><span class="pre">FunctionSpace(mesh,</span> <span class="pre">element_type,</span> <span class="pre">degree)</span></tt>:
a function space defined over a mesh, with a given element type
(e.g., <tt class="docutils literal"><span class="pre">'Lagrange'</span></tt> or <tt class="docutils literal"><span class="pre">'DG'</span></tt>), with basis functions as polynomials of
a specified degree.</p>
<p><tt class="docutils literal"><span class="pre">Expression(formula,</span> <span class="pre">p1=v1,</span> <span class="pre">p2=v2,</span> <span class="pre">...)</span></tt>:
a scalar- or vector-valued function, given as a
mathematical expression <tt class="docutils literal"><span class="pre">formula</span></tt> (string) written in C++ syntax.
The spatial coordinates in the expression are named
<tt class="docutils literal"><span class="pre">x[0]</span></tt>, <tt class="docutils literal"><span class="pre">x[1]</span></tt>, and <tt class="docutils literal"><span class="pre">x[2]</span></tt>, while time and other
physical parameters can be represented as symbols <tt class="docutils literal"><span class="pre">p1</span></tt>, <tt class="docutils literal"><span class="pre">p2</span></tt>,
etc., with corresponding values <tt class="docutils literal"><span class="pre">v1</span></tt>, <tt class="docutils literal"><span class="pre">v2</span></tt>, etc., initialized
through keyword arguments. These parameters become attributes,
whose values can be modified when desired.</p>
<p><tt class="docutils literal"><span class="pre">Function(V)</span></tt>: a scalar- or vector-valued finite element field in
the function space <tt class="docutils literal"><span class="pre">V</span></tt>. If <tt class="docutils literal"><span class="pre">V</span></tt> is a <tt class="docutils literal"><span class="pre">FunctionSpace</span></tt> object,
<tt class="docutils literal"><span class="pre">Function(V)</span></tt> becomes a scalar field, and with <tt class="docutils literal"><span class="pre">V</span></tt> as a
<tt class="docutils literal"><span class="pre">VectorFunctionSpace</span></tt> object, <tt class="docutils literal"><span class="pre">Function(V)</span></tt> becomes a
vector field.</p>
<p><tt class="docutils literal"><span class="pre">SubDomain</span></tt>: class for defining a subdomain, either a part of the
boundary, an internal boundary, or a part of the domain.
The programmer must subclass <tt class="docutils literal"><span class="pre">SubDomain</span></tt> and implement the
<tt class="docutils literal"><span class="pre">inside(self,</span> <span class="pre">x,</span> <span class="pre">on_boundary)</span></tt> function
(see the section <a class="reference internal" href="#tut-poisson1-impl"><em>Implementation  (1)</em></a>) for telling whether a
point <tt class="docutils literal"><span class="pre">x</span></tt> is inside the subdomain or not.</p>
<p><tt class="docutils literal"><span class="pre">Mesh</span></tt>: class for representing a finite element mesh, consisting of
cells, vertices, and optionally faces, edges, and facets.</p>
<p><tt class="docutils literal"><span class="pre">MeshFunction</span></tt>: tool for marking parts of the domain or the boundary.
Used for variable coefficients (&#8220;material properties&#8221;, see
the section <a class="reference internal" href="#tut-possion-2d-2mat-problem"><em>Working with Two Subdomains</em></a>) or for
boundary conditions (see the section <a class="reference internal" href="#tut-poisson-mat-neumann"><em>Multiple Neumann, Robin, and Dirichlet Condition</em></a>).</p>
<p><tt class="docutils literal"><span class="pre">DirichletBC(V,</span> <span class="pre">value,</span> <span class="pre">where)</span></tt>: specification of Dirichlet (essential)
boundary conditions via a function space <tt class="docutils literal"><span class="pre">V</span></tt>, a function
<tt class="docutils literal"><span class="pre">value(x)</span></tt> for computing the value of the condition at a point <tt class="docutils literal"><span class="pre">x</span></tt>,
and a specification <tt class="docutils literal"><span class="pre">where</span></tt> of the boundary, either as a
<tt class="docutils literal"><span class="pre">SubDomain</span></tt> subclass instance, a plain function, or as a
<tt class="docutils literal"><span class="pre">MeshFunction</span></tt> instance.
In the latter case, a 4th argument is provided to describe which subdomain
number that describes the relevant boundary.</p>
<p><tt class="docutils literal"><span class="pre">TestFunction(V)</span></tt>: define a test function on a space <tt class="docutils literal"><span class="pre">V</span></tt> to be used
in a variational form.</p>
<p><tt class="docutils literal"><span class="pre">TrialFunction(V)</span></tt>: define a trial function on a space <tt class="docutils literal"><span class="pre">V</span></tt> to be used
in a variational form to represent the unknown in a finite element problem.</p>
<p><tt class="docutils literal"><span class="pre">assemble(X)</span></tt>: assemble a matrix, a right-hand side, or a functional,
given a from <tt class="docutils literal"><span class="pre">X</span></tt> written with UFL syntax.</p>
<p><tt class="docutils literal"><span class="pre">assemble_system(a,</span> <span class="pre">L,</span> <span class="pre">bcs)</span></tt>: assemble the matrix and the right-hand
side from a bilinear (<tt class="docutils literal"><span class="pre">a</span></tt>) and linear (<tt class="docutils literal"><span class="pre">L</span></tt>) form written with UFL
syntax. The <tt class="docutils literal"><span class="pre">bcs</span></tt> parameter holds one or more <tt class="docutils literal"><span class="pre">DirichletBC</span></tt> objects.</p>
<p><tt class="docutils literal"><span class="pre">LinearVariationalProblem(a,</span> <span class="pre">L,</span> <span class="pre">u,</span> <span class="pre">bcs)</span></tt>: define a variational problem,
given a bilinear (<tt class="docutils literal"><span class="pre">a</span></tt>) and linear (<tt class="docutils literal"><span class="pre">L</span></tt>) form, written with UFL
syntax, and one or more <tt class="docutils literal"><span class="pre">DirichletBC</span></tt> objects stored in <tt class="docutils literal"><span class="pre">bcs</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">LinearVariationalSolver(problem)</span></tt>: create solver object for a linear
variational problem object (<tt class="docutils literal"><span class="pre">problem</span></tt>).</p>
<p><tt class="docutils literal"><span class="pre">solve(A,</span> <span class="pre">U,</span> <span class="pre">b)</span></tt>: solve a linear system with <tt class="docutils literal"><span class="pre">A</span></tt> as coefficient
matrix (<tt class="docutils literal"><span class="pre">Matrix</span></tt> object), <tt class="docutils literal"><span class="pre">U</span></tt> as unknown (<tt class="docutils literal"><span class="pre">Vector</span></tt> object),
and <tt class="docutils literal"><span class="pre">b</span></tt> as right-hand side (<tt class="docutils literal"><span class="pre">Vector</span></tt> object).
Usually, <tt class="docutils literal"><span class="pre">U</span> <span class="pre">=</span> <span class="pre">u.vector()</span></tt>, where
<tt class="docutils literal"><span class="pre">u</span></tt> is a <tt class="docutils literal"><span class="pre">Function</span></tt> object representing the unknown finite
element function of the problem, while
<tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are computed by calls to <tt class="docutils literal"><span class="pre">assemble</span></tt>
or <tt class="docutils literal"><span class="pre">assemble_system</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">plot(q)</span></tt>: quick visualization of a mesh, function, or mesh function
<tt class="docutils literal"><span class="pre">q</span></tt>, using the Viper component in FEniCS.</p>
<p><tt class="docutils literal"><span class="pre">interpolate(func,</span> <span class="pre">V)</span></tt>: interpolate a formula or finite
element function <tt class="docutils literal"><span class="pre">func</span></tt> onto the function space <tt class="docutils literal"><span class="pre">V</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">project(func,</span> <span class="pre">V)</span></tt>: project a formula or finite element function <tt class="docutils literal"><span class="pre">func</span></tt>
onto the function space <tt class="docutils literal"><span class="pre">V</span></tt>.</p>
</div>
<div class="section" id="user-defined-functions">
<span id="tut-app-cpp-functions"></span><h2>User-Defined Functions<a class="headerlink" href="#user-defined-functions" title="Permalink to this headline">¶</a></h2>
<p>When defining a function in terms of a mathematical expression inside
a string formula, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">myfunc</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(x[0])*cos(x[1])&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>the expression contained in the first argument
will be turned into a C++ function
and compiled to gain efficiency. Therefore,
the syntax used in the expression must be valid C++ syntax.
Most Python syntax for mathematical expressions are also valid C++ syntax,
but power expressions make an exception: <tt class="docutils literal"><span class="pre">p**a</span></tt> must be written as
<tt class="docutils literal"><span class="pre">pow(p,a)</span></tt> in C++ (this is also an alternative Python syntax).
The following mathematical functions can be used directly
in C++
expressions when defining <tt class="docutils literal"><span class="pre">Expression</span></tt> objects:
<tt class="docutils literal"><span class="pre">cos</span></tt>, <tt class="docutils literal"><span class="pre">sin</span></tt>, <tt class="docutils literal"><span class="pre">tan</span></tt>, <tt class="docutils literal"><span class="pre">acos</span></tt>, <tt class="docutils literal"><span class="pre">asin</span></tt>,
<tt class="docutils literal"><span class="pre">atan</span></tt>, <tt class="docutils literal"><span class="pre">atan2</span></tt>, <tt class="docutils literal"><span class="pre">cosh</span></tt>, <tt class="docutils literal"><span class="pre">sinh</span></tt>, <tt class="docutils literal"><span class="pre">tanh</span></tt>, <tt class="docutils literal"><span class="pre">exp</span></tt>,
<tt class="docutils literal"><span class="pre">frexp</span></tt>, <tt class="docutils literal"><span class="pre">ldexp</span></tt>, <tt class="docutils literal"><span class="pre">log</span></tt>, <tt class="docutils literal"><span class="pre">log10</span></tt>, <tt class="docutils literal"><span class="pre">modf</span></tt>,
<tt class="docutils literal"><span class="pre">pow</span></tt>, <tt class="docutils literal"><span class="pre">sqrt</span></tt>, <tt class="docutils literal"><span class="pre">ceil</span></tt>, <tt class="docutils literal"><span class="pre">fabs</span></tt>, <tt class="docutils literal"><span class="pre">floor</span></tt>, and <tt class="docutils literal"><span class="pre">fmod</span></tt>.
Moreover, the number <span class="math">\(\pi\)</span> is available as the symbol <tt class="docutils literal"><span class="pre">pi</span></tt>.
All the listed functions are taken from the <tt class="docutils literal"><span class="pre">cmath</span></tt> C++ header file, and
one may hence
consult documentation of <tt class="docutils literal"><span class="pre">cmath</span></tt> for more information on the
various functions.</p>
<p>Parameters in expression strings must be initialized via keyword
arguments when creating the <tt class="docutils literal"><span class="pre">Expression</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">myfunc</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s">&#39;sin(w_x*x[0])*cos(w_y*x[1])&#39;</span><span class="p">,</span>
                     <span class="n">w_x</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span> <span class="n">w_y</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="linear-solvers-and-preconditioners">
<span id="tut-app-solver-prec"></span><h2>Linear Solvers and Preconditioners<a class="headerlink" href="#linear-solvers-and-preconditioners" title="Permalink to this headline">¶</a></h2>
<p>The following solution methods for linear
systems can be accessed in FEniCS programs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'lu'</span></tt></td>
<td>sparse LU factorization (Gaussian elim.)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'cholesky'</span></tt></td>
<td>sparse Cholesky factorization</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'cg'</span></tt></td>
<td>Conjugate gradient method</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'gmres'</span></tt></td>
<td>Generalized minimal residual method</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'bicgstab'</span></tt></td>
<td>Biconjugate gradient stabilized method</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'minres'</span></tt></td>
<td>Minimal residual method</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'tfqmr'</span></tt></td>
<td>Transpose-free quasi-minimal residual method</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'richardson'</span></tt></td>
<td>Richardson method</td>
</tr>
</tbody>
</table>
<p>Possible choices of preconditioners include</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'none'</span></tt></td>
<td>No preconditioner</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'ilu'</span></tt></td>
<td>Incomplete LU factorization</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'icc'</span></tt></td>
<td>Incomplete Cholesky factorization</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'jacobi'</span></tt></td>
<td>Jacobi iteration</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'bjacobi'</span></tt></td>
<td>Block Jacobi iteration</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'sor'</span></tt></td>
<td>Successive over-relaxation</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'amg'</span></tt></td>
<td>Algebraic multigrid (BoomerAMG or ML)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'additive_schwarz'</span></tt></td>
<td>Additive Schwarz</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'hypre_amg'</span></tt></td>
<td>Hypre algebraic multigrid (BoomerAMG)</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'hypre_euclid'</span></tt></td>
<td>Hypre parallel incomplete LU factorization</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">'hypre_parasails'</span></tt></td>
<td>Hypre parallel sparse approximate inverse</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">'ml_amg'</span></tt></td>
<td>ML algebraic multigrid</td>
</tr>
</tbody>
</table>
<p>Many of the choices listed above
are only offered by a specific backend, so setting the backend
appropriately is necessary for being able to choose a desired
linear solver or preconditioner.</p>
<p>An up-to-date list of the available solvers and preconditioners
in FEniCS can be produced by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">list_linear_solver_methods</span><span class="p">()</span>
<span class="n">list_krylov_solver_preconditioners</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-backend-specific-solver">
<span id="tut-epetra"></span><h2>Using a Backend-Specific Solver<a class="headerlink" href="#using-a-backend-specific-solver" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-138"></span><p id="index-139">The linear algebra backend determines the specific data structures
that are used in the <tt class="docutils literal"><span class="pre">Matrix</span></tt> and <tt class="docutils literal"><span class="pre">Vector</span></tt> classes. For example, with
the PETSc backend, <tt class="docutils literal"><span class="pre">Matrix</span></tt> encapsulates a PETSc matrix storage
structure, and <tt class="docutils literal"><span class="pre">Vector</span></tt> encapsulates a PETSc vector storage structure.
Sometimes one wants to perform operations directly on (say) the
underlying PETSc objects. These can be fetched by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A_PETSc</span> <span class="o">=</span>
<span class="n">down_cast</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span> <span class="n">b_PETSc</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span> <span class="n">U_PETSc</span> <span class="o">=</span>
<span class="n">down_cast</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">u</span></tt> is a <tt class="docutils literal"><span class="pre">Function</span></tt>, <tt class="docutils literal"><span class="pre">A</span></tt> is a
<tt class="docutils literal"><span class="pre">Matrix</span></tt>, and <tt class="docutils literal"><span class="pre">b</span></tt> is a <tt class="docutils literal"><span class="pre">Vector</span></tt>.  The same syntax applies if we want
to fetch the underlying Epetra, uBLAS, or MTL4 matrices and vectors.</p>
<span class="target" id="index-140"></span><p id="index-141">Sometimes one wants to implement tailored solution algorithms, using
special features of the underlying numerical packages.
Here is an example where we create an ML preconditioned Conjugate
Gradient solver by programming with Trilinos-specific objects directly.
Given a linear system
<span class="math">\(AU=b\)</span>, represented by a <tt class="docutils literal"><span class="pre">Matrix</span></tt> object <tt class="docutils literal"><span class="pre">A</span></tt>,
and two <tt class="docutils literal"><span class="pre">Vector</span></tt> objects <tt class="docutils literal"><span class="pre">U</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> in a
Python program, the purpose is to
set up a solver using the Aztec Conjugate Gradient method from
Trilinos&#8217; Aztec library and combine that solver with the
algebraic multigrid preconditioner ML
from the ML library in Trilinos. Since the various parts of
Trilinos are mirrored in Python through the PyTrilinos package,
we can operate directly
on Trilinos-specific objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">PyTrilinos</span> <span class="kn">import</span> <span class="n">Epetra</span><span class="p">,</span> <span class="n">AztecOO</span><span class="p">,</span> <span class="n">TriUtils</span><span class="p">,</span> <span class="n">ML</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;&#39;&#39;You Need to have PyTrilinos with</span>
<span class="s">Epetra, AztecOO, TriUtils and ML installed</span>
<span class="s">for this demo to run&#39;&#39;&#39;</span>
    <span class="nb">exit</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">has_la_backend</span><span class="p">(</span><span class="s">&#39;Epetra&#39;</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;Warning: Dolfin is not compiled with Trilinos&#39;</span>
    <span class="nb">exit</span><span class="p">()</span>

<span class="n">parameters</span><span class="p">[</span><span class="s">&#39;linear_algebra_backend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Epetra&#39;</span>

<span class="c"># create matrix A and vector b in the usual way</span>
<span class="c"># u is a Function</span>

<span class="c"># Fetch underlying Epetra objects</span>
<span class="n">A_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">mat</span><span class="p">()</span>
<span class="n">b_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>
<span class="n">U_epetra</span> <span class="o">=</span> <span class="n">down_cast</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span>

<span class="c"># Sets up the parameters for ML using a python dictionary</span>
<span class="n">ML_param</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;max levels&quot;</span>        <span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s">&quot;output&quot;</span>            <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
            <span class="s">&quot;smoother: type&quot;</span>    <span class="p">:</span> <span class="s">&quot;ML symmetric Gauss-Seidel&quot;</span><span class="p">,</span>
            <span class="s">&quot;aggregation: type&quot;</span> <span class="p">:</span> <span class="s">&quot;Uncoupled&quot;</span><span class="p">,</span>
            <span class="s">&quot;ML validate parameter list&quot;</span> <span class="p">:</span> <span class="bp">False</span>
<span class="p">}</span>

<span class="c"># Create the preconditioner</span>
<span class="n">prec</span> <span class="o">=</span> <span class="n">ML</span><span class="o">.</span><span class="n">MultiLevelPreconditioner</span><span class="p">(</span><span class="n">A_epetra</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
<span class="n">prec</span><span class="o">.</span><span class="n">SetParameterList</span><span class="p">(</span><span class="n">ML_param</span><span class="p">)</span>
<span class="n">prec</span><span class="o">.</span><span class="n">ComputePreconditioner</span><span class="p">()</span>

<span class="c"># Create solver and solve system</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">AztecOO</span><span class="o">.</span><span class="n">AztecOO</span><span class="p">(</span><span class="n">A_epetra</span><span class="p">,</span> <span class="n">U_epetra</span><span class="p">,</span> <span class="n">b_epetra</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetPrecOperator</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetAztecOption</span><span class="p">(</span><span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_solver</span><span class="p">,</span> <span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_cg</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">SetAztecOption</span><span class="p">(</span><span class="n">AztecOO</span><span class="o">.</span><span class="n">AZ_output</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">Iterate</span><span class="p">(</span><span class="n">MaxIters</span><span class="o">=</span><span class="mi">1550</span><span class="p">,</span> <span class="n">Tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

<span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="installing-fenics">
<span id="tut-app-install"></span><h2>Installing FEniCS<a class="headerlink" href="#installing-fenics" title="Permalink to this headline">¶</a></h2>
<p>The FEniCS software components are available for Linux, Windows and Mac OS
X platforms. Detailed information on how to get FEniCS running on such
machines are available at the <tt class="docutils literal"><span class="pre">fenicsproject.org</span></tt> website.
Here are just some quick descriptions and recommendations by the author.</p>
<p>To make the installation of FEniCS as painless and reliable as
possible, the reader is strongly recommended to use Ubuntu Linux.
(Even though Mac users now can get FEniCS by a one-click install, I
recommend using Ubuntu on Mac, unless you have high Unix competence
and much experience with compiling and linking C++ libraries on Mac OS
X.)  Any standard PC can easily be equipped with Ubuntu Linux, which
may live side by side with either Windows or Mac OS X or another Linux
installation.  Basically, you download Ubuntu from
<tt class="docutils literal"><span class="pre">www.ubuntu.com/getubuntu/download</span></tt>, burn the file on a CD or copy it
to a memory stick, reboot the machine with the CD or memory stick, and
answer some usually straightforward questions (if necessary).  On
Windows, Wubi is a tool that automatically installs Ubuntu on the
machine. Just give a user~name and password for the Ubuntu
installation, and Wubi performs the rest.  The graphical user
interface (GUI) of Ubuntu is quite similar to both Windows 7 and Mac
OS X, but to be efficient when doing science with FEniCS this author
recommends to run programs in a terminal window and write them in a
text editor like Emacs or Vim. You can employ an integrated
development environment such as Eclipse, but intensive FEniCS
developers and users tend to find terminal windows and plain text
editors more user friendly.</p>
<p>Instead of making it possible to boot your machine with the Linux
Ubuntu operating system, you can run Ubuntu in a separate window in
your existing operation system. There are several solutions to chose
among: the free <em>VirtualBoxMesh</em> and <em>VMWare Player</em>, or the
commercial tools <em>VMWare Fusion</em> and <em>Parallels</em> (just
search for the names to download the programs).</p>
<p>Once the Ubuntu window
is up and running, FEniCS is painlessly installed by</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">sudo apt-get install fenics</span>
</pre></div>
</div>
<p>Sometimes the FEniCS software in a standard Ubuntu installation
lacks some recent features and bug fixes. Visiting the detailed
download page on <a class="reference external" href="fenicsproject.org">fenicsproject.org</a> and copying a few Unix
commands is all you have to do to install a newer version of the
software.</p>
</div>
<div class="section" id="books-on-the-finite-element-method">
<span id="tut-appendix-books"></span><h2>Books on the Finite Element Method<a class="headerlink" href="#books-on-the-finite-element-method" title="Permalink to this headline">¶</a></h2>
<p>There are a large number of books on the finite element method.  The
books typically fall in either of two categories: the abstract
mathematical version of the method and the engineering &#8220;structural
analysis&#8221; formulation. FEniCS builds heavily on concepts in the
abstract mathematical exposition.  An easy-to-read book, which
provides a good general background for using FEniCS, is Gockenbach
<a class="reference internal" href="#ref04">[Ref04]</a>. The book by Donea and Huerta
<a class="reference internal" href="#ref05">[Ref05]</a> has a similar style, but aims at readers with
interest in fluid flow problems. Hughes <a class="reference internal" href="#ref06">[Ref06]</a> is also
highly recommended, especially for those interested in solid mechanics
and heat transfer applications.</p>
<p>Readers with background in the engineering &#8220;structural analysis&#8221;
version of the finite element method may find Bickford
<a class="reference internal" href="#ref07">[Ref07]</a> as an attractive bridge over to the abstract
mathematical formulation that FEniCS builds upon.  Those who have a
weak background in differential equations in general should consult a
more fundamental book, and Eriksson {em et
al}. <a class="reference internal" href="#ref08">[Ref08]</a> is a very good choice.  On the
other hand, FEniCS users with a strong background in mathematics and
interest in the mathematical properties of the finite element method,
will appreciate the texts by Brenner and Scott <a class="reference internal" href="#ref09">[Ref09]</a>,
Braess <a class="reference internal" href="#ref10">[Ref10]</a>, Ern and Guermond <a class="reference internal" href="#ref11">[Ref11]</a>,
Quarteroni and Valli <a class="reference internal" href="#ref12">[Ref12]</a>, or Ciarlet <a class="reference internal" href="#ref13">[Ref13]</a>.</p>
</div>
<div class="section" id="books-on-python">
<span id="tut-appendix-pybooks"></span><h2>Books on Python<a class="headerlink" href="#books-on-python" title="Permalink to this headline">¶</a></h2>
<p>Two very popular introductory books on Python are
&#8220;Learning Python&#8221;  by Lutz <a class="reference internal" href="#ref14">[Ref14]</a> and
&#8220;Practical Python&#8221;  by Hetland <a class="reference internal" href="#ref15">[Ref15]</a>.
More advanced and comprehensive books include
&#8220;Programming Python&#8221; by Lutz <a class="reference internal" href="#ref16">[Ref16]</a>,
and &#8220;Python Cookbook&#8221; <a class="reference internal" href="#ref17">[Ref17]</a> and &#8220;Python in a Nutshell&#8221;
<a class="reference internal" href="#ref18">[Ref18]</a> by Martelli.
The web page <tt class="docutils literal"><span class="pre">http://wiki.python.org/moin/PythonBooks</span></tt>
lists numerous additional books.
Very few texts teach Python in a mathematical and numerical context,
but the references <a class="reference internal" href="#ref19">[Ref19]</a> <a class="reference internal" href="#ref20">[Ref20]</a> <a class="reference internal" href="#ref21">[Ref21]</a>
are exceptions.</p>
</div>
<div class="section" id="acknowledgments">
<h2>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Permalink to this headline">¶</a></h2>
<p>The author is very thankful to Johan Hake, Anders Logg, Kent-Andre
Mardal, and Kristian Valen-Sendstad for promptly answering all my
questions about FEniCS functionality and for implementing all my
requests.  I will in particular thank Professor Douglas Arnold for
very valuable feedback on the text. Øystein Sørensen pointed out a lot
of typos and contributed with many helpful comments.  Many errors and
typos were also reported by Mauricio Angeles, Ida Drøsdal, Hans
Ekkehard Plesser, and Marie Rognes.
Ekkehard Ellmann as well as two anonymous reviewers
provided a series of suggestions and improvements.</p>
</div>
</div>
<div class="section" id="troubleshooting">
<span id="tut-trouble"></span><h1>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permalink to this headline">¶</a></h1>
<div class="section" id="compilation-problems">
<span id="index-142"></span><h2>Compilation Problems<a class="headerlink" href="#compilation-problems" title="Permalink to this headline">¶</a></h2>
<p id="index-143">Expressions and variational forms in a FEniCS program need to be
compiled to C++ and linked with libraries if the expressions or forms
have been modified since last time they were compiled.  The tool
Instant, which is part of the FEniCS software suite, is used for
compiling and linking C++ code so that it can be used with Python.</p>
<p>Sometimes the compilation fails. You can see from the
series of error messages which statement in the Python program that
led to a compilation problem. Make sure to scroll back and identify
whether the problematic line is associated with an expression,
variational form, or the solve step.</p>
<p>The final line in the output of error messages points to a log file
from the compilation where one can examine the error messages from the
compiler. It is usually the last lines of this log file that are of
interest. Occasionally, the compiler&#8217;s message can quickly lead to an
understanding of the problem.
A more fruitful approach is normally to examine the below list
of common compilation problems and their remedies.</p>
<div class="section" id="problems-with-the-instant-cache">
<h3>Problems with the Instant cache<a class="headerlink" href="#problems-with-the-instant-cache" title="Permalink to this headline">¶</a></h3>
<p>Instant remembers information about previous compilations and versions
of your program. Sometimes removal of this information can solve
the problem. Just run</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">instant-clean</span>
</pre></div>
</div>
<p>in a terminal window whenever you encounter a compilation problem.</p>
</div>
<div class="section" id="syntax-errors-in-expressions">
<h3>Syntax errors in expressions<a class="headerlink" href="#syntax-errors-in-expressions" title="Permalink to this headline">¶</a></h3>
<p>If the compilation problem arises from line with an <tt class="docutils literal"><span class="pre">Expression</span></tt>
object, examine the syntax of the expression carefully. The section <a class="reference internal" href="#tut-app-cpp-functions"><em>User-Defined Functions</em></a> contains some information on valid
syntax. You may also want to examine the log file, pointed to in the
last line in the output of error messages. The compiler&#8217;s message
about the syntax problem may lead you to a solution.</p>
<p>Some common problems are</p>
<blockquote>
<div><ol class="arabic simple">
<li>using <tt class="docutils literal"><span class="pre">a**b</span></tt> for exponentiation (illegal in C++) instead of <tt class="docutils literal"><span class="pre">pow(a,</span> <span class="pre">b)</span></tt>,</li>
<li>forgetting that the spatial coordinates are denoted by a vector <tt class="docutils literal"><span class="pre">x</span></tt>,</li>
<li>forgetting that the <span class="math">\(x\)</span>, <span class="math">\(y\)</span>, and <span class="math">\(z\)</span> coordinates in space correspond
to <tt class="docutils literal"><span class="pre">x[0]</span></tt>, <tt class="docutils literal"><span class="pre">x[1]</span></tt>, and <tt class="docutils literal"><span class="pre">x[2]</span></tt>, respectively.</li>
</ol>
</div></blockquote>
<p>Failure to initialize parameters in the expressions lead to a
compilation error where this problem is explicitly pointed out.</p>
</div>
<div class="section" id="problems-in-the-solve-step">
<h3>Problems in the solve step<a class="headerlink" href="#problems-in-the-solve-step" title="Permalink to this headline">¶</a></h3>
<p>Sometimes the problem lies in the solve step where a variational form
is turned into a system of algebraic equations.
The error message <em>Unable to extract all indicies</em> points to a problem with the
variational form. Common errors include</p>
<blockquote>
<div><ol class="arabic simple">
<li>missing either the <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> or the <tt class="docutils literal"><span class="pre">TestFunction</span></tt> object,</li>
<li>no terms without <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> objects.</li>
<li>mathematically invalid operations in the variational form.</li>
</ol>
</div></blockquote>
<p>The first problem implies that one cannot make a matrix system or
system of nonlinear algebraic equations out of the variational form.
The second problem means that there is no &#8220;right-hand side&#8221; terms in the PDE
with known quantities. Sometimes this is seemingly the case mathematically
because the &#8220;right-hand side&#8221; is zero. Variational forms must represent this
case as <tt class="docutils literal"><span class="pre">Constant(0)*v*dx</span></tt> where <tt class="docutils literal"><span class="pre">v</span></tt> is a <tt class="docutils literal"><span class="pre">TestFunction</span></tt> object.
An example of the third problem is to take the <tt class="docutils literal"><span class="pre">inner</span></tt> product of
a scalar and a vector (causing in this particular case
the error message to be &#8220;Shape mismatch&#8221;).</p>
<p>The message <em>Unable to extract common cell; missing cell definition in
form or expression</em> will typically arise from a term in the form where
a test function (holding mesh and cell information) is missing.
For example, a zero right-hand side <tt class="docutils literal"><span class="pre">Constant(0)*dx</span></tt> will generate
this error.</p>
</div>
<div class="section" id="unable-to-convert-object-to-a-ufl-form">
<h3>Unable to convert object to a UFL form<a class="headerlink" href="#unable-to-convert-object-to-a-ufl-form" title="Permalink to this headline">¶</a></h3>
<p>One common reason for the above error message is that a form is
written without being multiplied by <tt class="docutils literal"><span class="pre">dx</span></tt> or <tt class="docutils literal"><span class="pre">ds</span></tt>.</p>
</div>
<div class="section" id="ufl-reports-that-a-numpy-array-cannot-be-converted-to-any-ufl-type">
<h3>UFL reports that a numpy array cannot be converted to any UFL type<a class="headerlink" href="#ufl-reports-that-a-numpy-array-cannot-be-converted-to-any-ufl-type" title="Permalink to this headline">¶</a></h3>
<p>One reason may be that there are mathematical functions like <tt class="docutils literal"><span class="pre">sin</span></tt> and
<tt class="docutils literal"><span class="pre">exp</span></tt> operating on <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays. The problem is that
the <tt class="docutils literal"><span class="pre">from</span> <span class="pre">dolfin</span> <span class="pre">import</span> <span class="pre">*</span></tt> statement imports <tt class="docutils literal"><span class="pre">sin</span></tt>, <tt class="docutils literal"><span class="pre">cos</span></tt>,
and similar mathematical functions from UFL and these are aimed at
taking <cite>Function or ``TrialFunction`</cite>
objects as arguments and not <tt class="docutils literal"><span class="pre">numpy</span></tt> arrays.
The remedy is to use prefix mathematical functions aimed at
<tt class="docutils literal"><span class="pre">numpy</span></tt> arrays with <tt class="docutils literal"><span class="pre">numpy</span></tt>, or <tt class="docutils literal"><span class="pre">np</span></tt> if <tt class="docutils literal"><span class="pre">numpy</span></tt> is imported as <tt class="docutils literal"><span class="pre">np</span></tt>:
<tt class="docutils literal"><span class="pre">numpy.exp</span></tt> or <tt class="docutils literal"><span class="pre">np.exp</span></tt>, for instance.
Normally, boundary conditions and analytical solutions are represented
by <tt class="docutils literal"><span class="pre">Expression</span></tt> objects and then this problem does not arise.
The problem usually arises when pure Python functions with, e.g., analytical
solutions are introduced for, e.g., plotting.</p>
</div>
<div class="section" id="all-programs-fail-to-compile">
<h3>All programs fail to compile<a class="headerlink" href="#all-programs-fail-to-compile" title="Permalink to this headline">¶</a></h3>
<p>When encoutering a compilation problem where the Instant log file says
something about missing double quote in an <tt class="docutils literal"><span class="pre">Expression</span></tt>, try compiling
a previously working program. If that program faces the same problem,
reboot Ubuntu and try again.  If the problem persists, try running the
Update Manager (because unfinished updates can cause compiler
problems), reboot and try again.</p>
</div>
</div>
<div class="section" id="plotting-problems">
<h2>Plotting Problems<a class="headerlink" href="#plotting-problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-plot-disapperas-quickly-from-the-screen">
<span id="index-144"></span><h3>The plot disapperas quickly from the screen<a class="headerlink" href="#the-plot-disapperas-quickly-from-the-screen" title="Permalink to this headline">¶</a></h3>
<p>You have forgotten to insert emp{interactive()} as the last statement in
the program.</p>
</div>
</div>
<div class="section" id="problems-with-expression-objects">
<h2>Problems with Expression Objects<a class="headerlink" href="#problems-with-expression-objects" title="Permalink to this headline">¶</a></h2>
<div class="section" id="there-seems-to-be-some-bug-in-an-expression-object">
<h3>There seems to be some bug in an Expression object<a class="headerlink" href="#there-seems-to-be-some-bug-in-an-expression-object" title="Permalink to this headline">¶</a></h3>
<p>Run the command <tt class="docutils literal"><span class="pre">instant-clean</span></tt> to ensure that everything is
(re)compiled.  Check the formulas in string expressions carefully, and
make sure that divisions do not lead to integer division (i.e., at
least one of the operands in a division must be a floating-point
variable).</p>
</div>
<div class="section" id="i-get-a-segmentation-fault-when-using-an-expression-object">
<h3>I get a segmentation fault when using an Expression object<a class="headerlink" href="#i-get-a-segmentation-fault-when-using-an-expression-object" title="Permalink to this headline">¶</a></h3>
<p>One reason may be that the point vector <tt class="docutils literal"><span class="pre">x</span></tt> has indices out of
bounds, e.g., that you access <tt class="docutils literal"><span class="pre">x[2]</span></tt> but the mesh is only a 2D mesh.
Also recall that the components of emp{x} are <tt class="docutils literal"><span class="pre">x[0]</span></tt>, <tt class="docutils literal"><span class="pre">x[1]</span></tt>, etc.
Accessing <tt class="docutils literal"><span class="pre">x[2]</span></tt>  as the &#8220;y&#8221; coordinate is a common error.</p>
</div>
</div>
<div class="section" id="other-problems">
<h2>Other Problems<a class="headerlink" href="#other-problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="only-parts-of-the-program-are-executed">
<h3>Only parts of the program are executed<a class="headerlink" href="#only-parts-of-the-program-are-executed" title="Permalink to this headline">¶</a></h3>
<p>Check if a call to <tt class="docutils literal"><span class="pre">interactive()</span></tt> appears in the middle of the program.
The computations are halted by this call and not continued before
you press <tt class="docutils literal"><span class="pre">q</span></tt> in a plot window. Most people thus prefer to
have <tt class="docutils literal"><span class="pre">interactive()</span></tt> as the last statement.</p>
</div>
<div class="section" id="i-get-an-error-in-the-definition-of-the-boundary">
<h3>I get an error in the definition of the boundary<a class="headerlink" href="#i-get-an-error-in-the-definition-of-the-boundary" title="Permalink to this headline">¶</a></h3>
<p>Consider this code and error message:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DirichletBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>  <span class="c"># define the Dirichlet boundary</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1E-14</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">xleft_boundary</span><span class="p">)</span>

<span class="n">Error</span><span class="p">:</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">The</span> <span class="n">truth</span> <span class="n">value</span> <span class="n">of</span> <span class="n">an</span> <span class="n">array</span> <span class="k">with</span> <span class="n">more</span> <span class="n">than</span>
<span class="n">one</span> <span class="n">element</span> <span class="ow">is</span> <span class="n">ambiguous</span><span class="o">.</span> <span class="n">Use</span> <span class="n">a</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>The reason for this error message
is that <tt class="docutils literal"><span class="pre">x</span></tt> is a point vector, not just a number.
In the <tt class="docutils literal"><span class="pre">inside</span></tt> function one must work with the
components of <tt class="docutils literal"><span class="pre">x</span></tt>: <tt class="docutils literal"><span class="pre">x[0]</span></tt>, <tt class="docutils literal"><span class="pre">x[1]</span></tt>, etc.</p>
</div>
<div class="section" id="the-solver-in-a-nonlinear-problems-does-not-converge">
<h3>The solver in a nonlinear problems does not converge<a class="headerlink" href="#the-solver-in-a-nonlinear-problems-does-not-converge" title="Permalink to this headline">¶</a></h3>
<p>There can be many reasons for this common problem:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The form (variational formulation) is not consistent with the
PDE(s).</li>
<li>The boundary conditions in a Newton method are wrong. The
correction vector must have vanishing essential conditions where
the complete solution has zero or non-zero values.</li>
<li>The initial guess for the solution is not appropriate. In some
problems, a simple function equal to 0 just leads to a zero
solution or a divergent solver. Try 1 as initial guess, or
(better) try to identify a linear problem that can be used to
compute an appropriate initial guess, see the section <a class="reference internal" href="#tut-nonlinear-newton-algebraic"><em>A Newton Method at the Algebraic Level</em></a>.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="how-to-debug-a-fenics-program">
<h2>How To Debug a FEniCS Program?<a class="headerlink" href="#how-to-debug-a-fenics-program" title="Permalink to this headline">¶</a></h2>
<p>Here is an action list you may follow.</p>
<p><strong>Step 1.</strong>
Examine the weak form and its implementation carefully.
Check that all terms are multiplied by <tt class="docutils literal"><span class="pre">dx</span></tt> or <tt class="docutils literal"><span class="pre">ds</span></tt>, and that the
terms do not vanish; check that at least one term has both a
<tt class="docutils literal"><span class="pre">TrialFunction</span></tt> and a <tt class="docutils literal"><span class="pre">TestFunction</span></tt> (term with unknown); and check
that at least one term has no <tt class="docutils literal"><span class="pre">TrialFunction</span></tt> (known term).</p>
<p><strong>Step 2.</strong>
Check that Dirichlet boundary conditions are set correctly.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># bcs is list of DirichletBC objects</span>
<span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">:</span>
<span class="n">bc_dict</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">get_boundary_values</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">bc_dict</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;dof </span><span class="si">%d</span><span class="s">: value=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dof</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="n">dof</span><span class="p">])</span>
</pre></div>
</div>
<p>See also an expanded version of this snippet in <tt class="docutils literal"><span class="pre">dn2_p2D.py</span></tt>, located
in the directory <tt class="docutils literal"><span class="pre">stationary/poisson</span></tt>.</p>
<p>A next step in the debugging, if these values are wrong, is to
call the functions that define the boundary parts. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">coor</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">my_boundary_function</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on the boundary&#39;</span> <span class="o">%</span> <span class="n">coor</span>

<span class="c"># or, in case of a SubDomain subclass my_subdomain_object,</span>
<span class="k">for</span> <span class="n">coor</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">my_subdomain_object</span><span class="o">.</span><span class="n">inside</span><span class="p">(</span><span class="n">coor</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> is on the boundary&#39;</span> <span class="o">%</span> <span class="n">coor</span>
</pre></div>
</div>
<p>You may map the solution to a structured grid with structured data,
i.e., a <tt class="docutils literal"><span class="pre">BoxMeshField</span></tt>, see the chapters <a class="reference internal" href="#tut-quickviz"><em>Quick Visualization with VTK</em></a>
and <a class="reference internal" href="#tut-timedep-diffusion2-sin"><em>A Physical Example</em></a>, and then examine the solution field
along grid lines in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions. For example, you can
easily check that correct
Dirichlet conditions are set, e.g.,
at the upper boundary (check <tt class="docutils literal"><span class="pre">u_box[:,-1]</span></tt>).</p>
<p><strong>Step 4.</strong>
Switching to a simple set of coefficients and boundary conditions,
such that the solution becomes simple too,
but still obeys the same PDE, may help since it is then easier to
examine numerical values in the solution array.</p>
<p><strong>Step 5.</strong>
Formulate a corresponding 1D problem. Often this can be
done by just running the problem with a 1D mesh. Doing hand calculations
of element matrices and vectors, and comparing the assembled system
from these hand calculations with the assembled system from the
FEniCS program can uncover bugs. For nonlinear problems, or problems
with variable coefficients, it is usually wise to choose simple
coefficients so that the problem becomes effectively linear and the
hand calculations are managable.</p>
</div>
</div>
<div class="section" id="what-s-new">
<h1>What&#8217;s New<a class="headerlink" href="#what-s-new" title="Permalink to this headline">¶</a></h1>
<p>This tutorial features several extensions and
changes to the first FEniCS book version of &#8220;A FEniCS Tutorial&#8221;:</p>
<ul class="simple">
<li>Included a troubleshooting list with common problems and solutions
(the section <a class="reference internal" href="#tut-trouble"><em>Troubleshooting</em></a>).</li>
<li>Added how to check Dirichlet conditions by printing
<tt class="docutils literal"><span class="pre">bc.get_boundary_values()</span></tt> (<tt class="docutils literal"><span class="pre">dn2_p2D.py</span></tt>).</li>
</ul>
</div>
<div class="section" id="bibliography">
<h1>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h1>
<table class="docutils citation" frame="void" id="ref01" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Ref01]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id7">3</a>)</em> <strong>A. Logg, K.-A. Mardal and G. N. Wells</strong>. Automated Solution of Partial Differential Equations by the Finite Element Method,
Springer,
2012.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref02" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[Ref02]</a></td><td><strong>M. Mortensen, H. P. Langtangen and G. N. Wells</strong>. A FEniCS-Based Programming Framework for Modeling Turbulent Flow by the Reynolds-Averaged Navier-Stokes Equations,
<em>Advances in Water Resources</em>,
2011.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref03" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[Ref03]</a></td><td><strong>M. Mortensen, H. P. Langtangen and J. Myre</strong>. Cbc.rans - a New Flexible, Programmable Software Framework for Computational Fluid Dynamics,
Sixth National Conference on Computational Mechanics (MekIT&#8216;11),
edited by <strong>H. I. Andersson and B. Skallerud</strong>,
Tapir,
2011.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref04" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[Ref04]</a></td><td><strong>M. Gockenbach</strong>. <em>Understanding and Implementing the Finite Element Method</em>,
SIAM,
2006.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref05" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[Ref05]</a></td><td><strong>J. Donea and A. Huerta</strong>. <em>Finite Element Methods for Flow Problems</em>,
Wiley Press,
2003.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref06" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[Ref06]</a></td><td><strong>T. J. R. Hughes</strong>. <em>The Finite Element Method: Linear Static and Dynamic Finite Element    Analysis</em>,
Prentice-Hall,
1987.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref07" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[Ref07]</a></td><td><strong>W. B. Bickford</strong>. <em>A First Course in the Finite Element Method</em>,
Irwin,
1994.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref08" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[Ref08]</a></td><td><strong>K. Eriksson, D. Estep, P. Hansbo and C. Johnson</strong>. <em>Computational Differential Equations</em>,
Cambridge University Press,
1996.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref09" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[Ref09]</a></td><td><strong>S. C. Brenner and L. R. Scott</strong>. <em>The Mathematical Theory of Finite Element Methods</em>,
Springer,
2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[Ref10]</a></td><td><strong>D. Braess</strong>. <em>Finite Elements</em>,
Cambridge University Press,
2007.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[Ref11]</a></td><td><strong>A. Ern and J.-L. Guermond</strong>. <em>Theory and Practice of Finite Elements</em>,
Springer,
2004.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[Ref12]</a></td><td><strong>A. Quarteroni and A. Valli</strong>. <em>Numerical Approximation of Partial Differential Equations</em>,
Springer,
1994.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[Ref13]</a></td><td><strong>P. G. Ciarlet</strong>. <em>The Finite Element Method for Elliptic Problems</em>,
SIAM,
2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[Ref14]</a></td><td><strong>M. Lutz</strong>. <em>Learning Python</em>,
O&#8217;Reilly,
2007.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[Ref15]</a></td><td><strong>M. L. Hetland</strong>. <em>Practical Python</em>,
APress,
2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[Ref16]</a></td><td><strong>M. Lutz</strong>. <em>Programming Python</em>,
O&#8217;Reilly,
2006.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[Ref17]</a></td><td><strong>A. Martelli and D. Ascher</strong>. <em>Python Cookbook</em>,
O&#8217;Reilly,
2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[Ref18]</a></td><td><strong>A. Martelli</strong>. <em>Python in a Nutshell</em>,
O&#8217;Reilly,
2006.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[Ref19]</a></td><td><strong>H. P. Langtangen</strong>. <em>Python Scripting for Computational Science</em>,
Springer,
2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[Ref20]</a></td><td><strong>H. P. Langtangen</strong>. <em>A Primer on Scientific Programming With Python</em>,
Springer,
2011.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ref21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[Ref21]</a></td><td><strong>J. Kiusalaas</strong>. <em>Numerical Methods in Engineering With Python</em>,
Cambridge University Press,
2005.</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<div class="wrapper">
  <div class="footer">
    <div class="footer-nav">
      <div class="span-6">
	<h4>Usage documentation</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/documentation/tutorial/">Tutorial</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/python/">Python API</a></li>
	  <li><a href="http://fenicsproject.org/documentation/dolfin/dev/cpp/">C++ API</a></li>
          <li><a href="http://fenicsproject.org/releases/">Release notes</a></li>
	</ul>
      </div>
      <div class="span-6">
	<h4>Developer resources</h4>
	<ul>
	  <li><a href="http://fenicsproject.org/buildbot/">Buildbot</a></li>
	  <li><a href="http://fenicsproject.org/benchbot/">Benchbot</a></li>
	  <li><a href="http://fenicsproject.org/support/launchpad_pages.html">FEniCS on Launchpad</a></li>
	</ul>
      </div>
      <div class="span-6 last">
	<h4>Search this site</h4>
	<div id="searchbox">
	  <form class="search" action="/search.html" method="get">
	    <input type="text" name="q" size="18" />
	    <input type="submit" value="Go" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>
    </div>
    &copy; <a href="http://fenicsproject.org/">The FEniCS Project</a>. (<a href="http://fenicsproject.org/disclaimer.html">Disclaimer</a>)
  </div>
</div>

  </body>
</html>