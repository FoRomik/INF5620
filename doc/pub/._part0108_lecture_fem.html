<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study Guide: Introduction to Finite Element Methods">
<meta name="keywords" content="approximation of general vectors,Galerkin method,projection,approximation of functions,approximation by sines,collocation method (approximation),approximation collocation,Lagrange (interpolating) polynomial,sparse matrices,trial function,test function,trial space,test space,integration by parts,mixed finite elements">



<style type="text/css">
    /* bloodish style */

    body {
      font-family: Helvetica, Verdana, Arial, Sans-serif;
      color: #404040;
      background: #ffffff;
    }
    h1 { font-size: 1.8em;  color: #8A0808; }
    h2 { font-size: 1.5em;  color: #8A0808; }
    h3, h4 { color: #8A0808; }
    a { color: #8A0808; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #bababa;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #f8f8f8;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Why finite elements? ', 1, None, '___sec0'),
              (' Domain for flow around a dolphin ', 2, None, '___sec1'),
              (' The flow ', 2, None, '___sec2'),
              (' Basic ingredients of the finite element method ',
               2,
               None,
               '___sec3'),
              (' Our learning strategy ', 2, None, '___sec4'),
              (' Approximation set-up ', 2, None, '___sec5'),
              (' How to determine the coefficients? ', 2, None, '___sec6'),
              (' Approximation of planar vectors; problem ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' Approximation of planar vectors; vector space terminology ',
               2,
               None,
               '___sec8'),
              (' The least squares method; principle ', 2, None, '___sec9'),
              (' The least squares method; calculations ',
               2,
               None,
               '___sec10'),
              (' The projection (or Galerkin) method ', 2, None, '___sec11'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 2, None, '___sec13'),
              (' The projection (or Galerkin) method ', 2, None, '___sec14'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec17'),
              (' Example: linear approximation; problem ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Example: linear approximation; solution ',
               2,
               None,
               '___sec19'),
              (' Example: linear approximation; plot ', 2, None, '___sec20'),
              (' Implementation of the least squares method; ideas ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Implementation of the least squares method; code ',
               2,
               None,
               '___sec22'),
              (' Implementation of the least squares method; plotting ',
               2,
               None,
               '___sec23'),
              (' Implementation of the least squares method; application ',
               2,
               None,
               '___sec24'),
              (' Perfect approximation; parabola approximating parabola ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Perfect approximation; the general result ',
               2,
               None,
               '___sec26'),
              (' Perfect approximation; proof of the general result ',
               2,
               None,
               '___sec27'),
              (' Finite-precision/numerical computations ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Ill-conditioning (1) ', 2, None, '___sec29'),
              (' Ill-conditioning (2) ', 2, None, '___sec30'),
              (' Fourier series approximation; problem and code ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Fourier series approximation; plot ', 2, None, '___sec32'),
              (' Fourier series approximation; improvements ',
               2,
               None,
               '___sec33'),
              (' Fourier series approximation; final results ',
               2,
               None,
               '___sec34'),
              (' Orthogonal basis functions ', 2, None, '___sec35'),
              (' The collocation or interpolation method; ideas and math ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' The collocation or interpolation method; implementation ',
               2,
               None,
               '___sec37'),
              (' The collocation or interpolation method; approximating a parabola by linear functions ',
               2,
               None,
               '___sec38'),
              (' Lagrange polynomials; motivation and ideas ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Lagrange polynomials; formula and code ',
               2,
               None,
               '___sec40'),
              (' Lagrange polynomials; successful example ',
               2,
               None,
               '___sec41'),
              (' Lagrange polynomials; a less successful example ',
               2,
               None,
               '___sec42'),
              (' Lagrange polynomials; oscillatory behavior ',
               2,
               None,
               '___sec43'),
              (' Lagrange polynomials; remedy for strong oscillations ',
               2,
               None,
               '___sec44'),
              (' Lagrange polynomials; recalculation with Chebyshev nodes ',
               2,
               None,
               '___sec45'),
              (' Lagrange polynomials; less oscillations with Chebyshev nodes ',
               2,
               None,
               '___sec46'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' So far: basis functions have been global ',
               2,
               None,
               '___sec48'),
              (' In the finite element method we use basis functions with local support ',
               2,
               None,
               '___sec49'),
              (' The linear combination of hat functions is a piecewise linear function ',
               2,
               None,
               '___sec50'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example on elements with two nodes (P1 elements) ',
               2,
               None,
               '___sec52'),
              (' Illustration of two basis functions on the mesh ',
               2,
               None,
               '___sec53'),
              (' Example on elements with three nodes (P2 elements) ',
               2,
               None,
               '___sec54'),
              (' Some corresponding basis functions (P2 elements) ',
               2,
               None,
               '___sec55'),
              (' Examples on elements with four nodes per element (P3 elements) ',
               2,
               None,
               '___sec56'),
              (' Some corresponding basis functions (P3 elements) ',
               2,
               None,
               '___sec57'),
              (' The numbering does not need to be regular from left to right ',
               2,
               None,
               '___sec58'),
              (' Interpretation of the coefficients $c_i$ ',
               2,
               None,
               '___sec59'),
              (' Properties of the basis functions ', 2, None, '___sec60'),
              (' How to construct quadratic $\\basphi_i$ (P2 elements) ',
               2,
               None,
               '___sec61'),
              (' Example on linear $\\basphi_i$ (P1 elements) ',
               2,
               None,
               '___sec62'),
              (' Example on cubic $\\basphi_i$ (P3 elements) ',
               2,
               None,
               '___sec63'),
              (' Calculating the linear system for $c_i$ ',
               1,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Computing a specific matrix entry (1) ',
               2,
               None,
               '___sec65'),
              (' Computing a specific matrix entry (2) ',
               2,
               None,
               '___sec66'),
              (' Calculating a general row in the matrix; figure ',
               2,
               None,
               '___sec67'),
              (' Calculating a general row in the matrix; details ',
               2,
               None,
               '___sec68'),
              (' Calculation of the right-hand side ', 2, None, '___sec69'),
              (' Specific example: two elements; linear system and solution ',
               2,
               None,
               '___sec70'),
              (' Specific example: two elements; plot ', 2, None, '___sec71'),
              (' Specific example: what about four elements? ',
               2,
               None,
               '___sec72'),
              (' Assembly of elementwise computations ',
               1,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Split the integrals into elementwise integrals ',
               2,
               None,
               '___sec74'),
              (' The element matrix ', 2, None, '___sec75'),
              (' Illustration of the matrix assembly: regularly numbered P1 elements ',
               2,
               None,
               '___sec76'),
              (' Illustration of the matrix assembly: regularly numbered P3 elements ',
               2,
               None,
               '___sec77'),
              (' Illustration of the matrix assembly: irregularly numbered P1 elements ',
               2,
               None,
               '___sec78'),
              (' Assembly of the right-hand side ', 2, None, '___sec79'),
              (' Mapping to a reference element ',
               1,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Affine mapping ', 2, None, '___sec81'),
              (' Integral transformation ', 2, None, '___sec82'),
              (' Advantages of the reference element ', 2, None, '___sec83'),
              (' Standardized basis functions for P1 elements ',
               2,
               None,
               '___sec84'),
              (' Standardized basis functions for P2 elements ',
               2,
               None,
               '___sec85'),
              (' Integration over a reference element; element matrix ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Integration over a reference element; element vector ',
               2,
               None,
               '___sec87'),
              (" Tedious calculations! Let's use symbolic software ",
               2,
               None,
               '___sec88'),
              (' Implementation ', 1, None, '___sec89'),
              (' Compute finite element basis functions ',
               2,
               None,
               '___sec90'),
              (' Compute the element matrix ', 2, None, '___sec91'),
              (' Example on symbolic and numeric element matrix ',
               2,
               None,
               '___sec92'),
              (' Compute the element vector ', 2, None, '___sec93'),
              (' Fallback on numerical integration if symbolic integration fails ',
               2,
               None,
               '___sec94'),
              (' Linear system assembly and solution ', 2, None, '___sec95'),
              (' Linear system solution ', 2, None, '___sec96'),
              (' Example on computing approximations ', 2, None, '___sec97'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' General result: the coefficient matrix is sparse ',
               2,
               None,
               '___sec99'),
              (' Exemplifying the sparsity for P2 elements ',
               2,
               None,
               '___sec100'),
              (' Matrix sparsity pattern for regular/random numbering of P1 elements ',
               2,
               None,
               '___sec101'),
              (' Matrix sparsity pattern for regular/random numbering of P3 elements ',
               2,
               None,
               '___sec102'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Approximate $f\\sim x^9$ by various elements; code ',
               2,
               None,
               '___sec104'),
              (' Approximate $f\\sim x^9$ by various elements; plot ',
               2,
               None,
               '___sec105'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Interpolation/collocation with finite elements ',
               2,
               None,
               '___sec107'),
              (' Differential equation models ',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              (' Residual-minimizing principles ',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              (' The least squares method ', 3, None, '___sec110'),
              (' The Galerkin method ', 3, None, '___sec111'),
              (' The Method of Weighted Residuals ', 3, None, '___sec112'),
              (' Test and Trial Functions ', 3, None, '___sec113'),
              (' The collocation method ', 3, None, '___sec114'),
              (' Examples on using the principles ',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              (' The model problem ', 3, None, '___sec116'),
              (' Basis functions ', 3, None, '___sec117'),
              (' The residual ', 3, None, '___sec118'),
              (' The least squares method ', 3, None, '___sec119'),
              (' The Galerkin method ', 3, None, '___sec120'),
              (' The collocation method ', 3, None, '___sec121'),
              (' Comparison ', 3, None, '___sec122'),
              (' Integration by parts ',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              (' Boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Example ', 3, None, '___sec125'),
              (' Abstract notation for variational formulations ',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              (' Example ', 3, None, '___sec127'),
              (' Bilinear and linear forms ', 3, None, '___sec128'),
              (' More examples on variational formulations ',
               2,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              (' Variable coefficient ', 3, None, '___sec130'),
              (' First-order derivative in the equation and boundary condition ',
               3,
               None,
               '___sec131'),
              (' Example on computing with Dirichlet and Neumann conditions ',
               2,
               None,
               '___sec132'),
              (' Nonlinear terms ', 3, None, '___sec133'),
              (' Variational problems and optimization of functionals ',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              (' Computing with finite elements ',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              (' Computation in the global physical domain ',
               2,
               None,
               '___sec136'),
              (' Elementwise computations ', 2, None, '___sec137'),
              (' Boundary conditions: specified value ',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              (' General construction of a boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Example ', 3, None, '___sec140'),
              (' Modification of the linear system ',
               2,
               'fem:deq:1D:essBC:Bfunc:modsys',
               'fem:deq:1D:essBC:Bfunc:modsys'),
              (' Symmetric modification of the linear system ',
               2,
               None,
               '___sec142'),
              (' Modification of the element matrix and vector ',
               2,
               None,
               '___sec143'),
              (' Boundary conditions: specified derivative ',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              (' The variational formulation ', 2, None, '___sec145'),
              (' The finite element algorithm ', 1, None, '___sec146'),
              (' Variational formulations in 2D and 3D ',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              (' Example ', 3, None, '___sec148'),
              (' Transformation to a reference cell in 2D and 3D ',
               2,
               None,
               '___sec149'),
              (' Systems of differential equations ',
               1,
               'fem:sys',
               'fem:sys'),
              (' Variational forms ', 2, 'fem:sys:vform', 'fem:sys:vform'),
              (' A worked example ', 2, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              (' Identical function spaces for the unknowns ',
               2,
               None,
               '___sec153'),
              (' Variational form of each individual PDE ',
               3,
               None,
               '___sec154'),
              (' Compound scalar variational form ', 3, None, '___sec155'),
              (' Decoupled linear systems ', 3, None, '___sec156'),
              (' Coupled linear systems ', 3, None, '___sec157'),
              (' Different function spaces for the unknowns ',
               2,
               None,
               '___sec158')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
%\newcommand{\If}{\mathcal{I}}     % for FEM
\newcommand{\If}{I}     % for FEM
%\newcommand{\Ifd}{\mathcal{I}_d}  % for FEM
\newcommand{\Ifd}{I_d}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0108"></a>
<!-- begin top navigation -->
<a href="._part0107_lecture_fem.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>
<!-- end top navigation -->

<p>
<!-- !split -->

<h2>Comparison of finite element and finite difference approximation <a name="fem:approx:fe:fd"></a></h2>

<p>

<ul>
 <p><li> Finite difference approximation of a function \( f(x) \): simply
   choose \( u_i = f(x_i) \) (interpolation)</li>
 <p><li> Galerkin/projection and least squares method:
   must derive and solve a linear system</li>
 <p><li> What is really the difference?</li>
</ul>

<h3>Interpolation/collocation with finite elements  <a name="___sec107"></a></h3>

<p>
Let \( \xno{i} \), \( i\in\If \), be the nodes in the mesh.
Collocation means

<p>
$$
\begin{equation}
u(\xno{i})=f(\xno{i}),\quad i\in\If,
\end{equation}
$$

which translates to

<p>
$$ \sum_{j\in\If} c_j \basphi_j(\xno{i}) = f(\xno{i}),$$

but \( \basphi_j(\xno{i})=0 \) if \( i\neq j \) so the sum collapses to one
term \( c_i\basphi_i(\xno{i}) = c_i \), and we have the result

<p>
$$
\begin{equation}
c_i = f(\xno{i})
\tp
\end{equation}
$$


<p>

<ul>
 <p><li> Same result as the standard finite difference approach</li>
 <p><li> \( u \) <em>interpolates</em> \( f \) at the node points</li>
 <p><li> \( u \) has a variation between the node points dictated by the \( \basphi_i \)
   functions</li>
</ul>

<h3>Differential equation models <a name="fem:deq:1D:models"></a></h3>

<p>
Abstract differential equation:
$$
\begin{equation}
\mathcal{L}(u) = 0,\quad x\in\Omega\tp  \end{equation}
$$


<p>
Examples:

<p>
$$
\begin{align}
\mathcal{L}(u) &= \frac{d^2u}{dx^2} - f(x),
\tag{28}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(x)\frac{du}{dx}\right) + f(x),
\tag{29}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(u)\frac{du}{dx}\right) - \alpha u + f(x),
\tag{30}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(a(u)\frac{du}{dx}\right) + f(u,x)
\tag{31}
\tp 
\end{align}
$$


<p>
$$
\begin{equation}
{\cal B}_0(u)=0,\ x=0,\quad {\cal B}_1(u)=0,\ x=L
\end{equation}
$$


<p>
There are three common choices of boundary conditions:
$$
\begin{align}
{\cal B}_i(u) &= u - g,\quad \hbox{(Dirichlet condition)},\\ 
{\cal B}_i(u) &= -a \frac{du}{dx} - g,\quad \hbox{(Neumann condition)},\\ 
{\cal B}_i(u) &= -a \frac{du}{dx} - a(u-g),\quad \hbox{(Robin condition)}
\tp 
\end{align}
$$


<p>
From now on we shall use \( \uex(x) \) as symbol for the <em>exact</em> solution,
fulfilling

<p>
$$
\begin{equation}
\mathcal{L}(\uex)=0,\quad x\in\Omega,
\end{equation}
$$

while \( u(x) \) denotes an <em>approximate</em> solution of the differential
equation.

<h3>Residual-minimizing principles <a name="fem:deq:1D:residual:min"></a></h3>

<p>
The fundamental idea is to seek an approximate solution
\( u \) in some space \( V \) with basis

<p>
$$
\begin{equation*} \{ \baspsi_0(x),\ldots,\baspsi_N(x)\},\end{equation*}
$$

which means that \( u \) can always be expressed as

<p>
$$
\begin{equation*} u(x) = \sum_{j\in\If} c_j\baspsi_j(x),\end{equation*}
$$

for some unknown coefficients \( c_0,\ldots,c_N \).

<p>
Inserting this \( u \) in the equation gives a nonzero <em>residual</em> \( R \):

<p>
$$
\begin{equation}
R = \mathcal{L}(u) = \mathcal{L}(\sum_j c_j \baspsi_j),
\end{equation}
$$


<p>

<ul>
 <p><li> \( R \) measures how well \( u \) fulfills the differential equation, but says
   nothing about the <em>error</em> \( \uex - u \)</li>
 <p><li> We cannot know \( \uex - u \)</li>
 <p><li> Therefore, we aim to minimize \( R \)</li>
 <p><li> Find \( c_0,\ldots,c_N \) such that \( R(x; c_0,\ldots,c_N) \) is small</li>
</ul>

<h4>The least squares method  <a name="___sec110"></a></h4>

<p>
Idea: minimize

<p>
$$
\begin{equation}
\int_{\Omega} R^2 dx
\end{equation}
$$


<p>
With the inner product

<p>
$$
\begin{equation}
(f,g) = \int_{\Omega} f(x)g(x) dx,
\end{equation}
$$


<p>
the least-squares method can be defined as

<p>
$$
\begin{equation}
\min_{c_0,\ldots,c_N} E = (R,R)\tp  \end{equation}
$$

Differentiating with respect to the free parameters \( c_0,\ldots,c_N \)
gives the \( N+1 \) equations

<p>
$$
\begin{equation}
\int_{\Omega} 2R\frac{\partial R}{\partial c_i} dx = 0\quad
\Leftrightarrow\quad (R,\frac{\partial R}{\partial c_i})=0,\quad
i\in\If\tp 
\tag{32}
\end{equation}
$$

<h4>The Galerkin method  <a name="___sec111"></a></h4>

<p>
Idea: make \( R \) orthogonal to \( V \),

<p>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in V\tp 
\tag{33}
\end{equation}
$$


<p>
Equivalent statement:

<p>
$$
\begin{equation}
(R,\baspsi_i)=0,\quad i\in\If,
\tag{34}
\end{equation}
$$

This statement generates \( N+1 \) equations for \( c_0,\ldots,c_N \).

<h4>The Method of Weighted Residuals  <a name="___sec112"></a></h4>

<p>
Generalization of the Galerkin method: demand \( R \)
orthogonal to some space \( W \), possibly \( W\neq V \):

<p>
$$
\begin{equation}
(R,v)=0,\quad \forall v\in W\tp 
\tag{35}
\end{equation}
$$

If \( \{w_0,\ldots,w_N\} \) is a basis for \( W \), we can equivalently
express the method of weighted residuals as

<p>
$$
\begin{equation}
(R,w_i)=0,\quad i\in\If\tp 
\tag{36}
\end{equation}
$$

This gives \( N+1 \) equations for \( c_0,\ldots,c_N \).

<p>
Note: The least-squares method can also be viewed as a weighted residual
method with \( w_i = \partial R/\partial c_i \).

<h4>Test and Trial Functions  <a name="___sec113"></a></h4>

<p>

<ul>
 <p><li> \( \baspsi_j \) used in \( \sum_jc_j\baspsi_j \): <em>trial function</em></li>
 <p><li> \( \baspsi_i \) or \( w_i \) used as weight in Galerkin's method: <em>test function</em></li>
</ul>

<h4>The collocation method  <a name="___sec114"></a></h4>

<p>
Idea: demand \( R=0 \) at \( N+1 \) points.

<p>
$$
\begin{equation}
R(\xno{i}; c_0,\ldots,c_N)=0,\quad i\in\If\tp 
\tag{37}
\end{equation}
$$


<p>
Note: The collocation method is a weighted residual method with
delta functions as weights.

<p>
$$
\begin{equation}
\int_{\Omega} f(x)\delta (x-\xno{i}) dx = f(\xno{i}),\quad \xno{i}\in\Omega\tp 
\tag{38}
\end{equation}
$$


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Approximation of delta functions by narrow Gaussian functions. <a name="fem:deq:1D:fig:Dirac"></a> </p></center>
<p><img src="fig-fem/delta_func_weight.png" align="bottom" width=400></p>
</center>

<h3>Examples on using the principles <a name="fem:deq:1D:ex:sines"></a></h3>

<h4>The model problem  <a name="___sec116"></a></h4>

<p>
$$
\begin{equation}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=0
\tp 
\tag{39}
\end{equation}
$$

<h4>Basis functions  <a name="___sec117"></a></h4>

<p>
$$
\begin{equation}
\baspsi_i(x) = \sinL{i},\quad i\in\If\tp 
\tag{40}
\end{equation}
$$


<p>
Note: \( \baspsi_i(0)=\baspsi_i(L)=0 \), which ensures that \( u \)
fulfills the boundary conditions:

<p>
$$ u(0) = \sum_jc_j\baspsi_j(0) = 0,\quad u(L) = \sum_jc_j\baspsi_j(L)
\tp $$


<p>
Another useful property is the orthogonality on \( \Omega \):

<p>
$$
\begin{equation}
\int\limits_0^L \sinL{i}\sinL{j}\, dx = \left\lbrace
\begin{array}{ll} \half L & i=j  \\ 0, & i\neq j
\end{array}\right.
\end{equation}
$$


<p>
That is, the coefficient matrix becomes diagonal (\( \baspsi_i\baspsi_j=0 \)).

<h4>The residual  <a name="___sec118"></a></h4>

<p>
$$
\begin{align}
R(x;c_0,\ldots,c_N) &= u''(x) + f(x),\nonumber\\ 
&= \frac{d^2}{dx^2}\left(\sum_{j\in\If} c_j\baspsi_j(x)\right)
+ f(x),\nonumber\\ 
&= -\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\tp 
\tag{41}
\end{align}
$$

<h4>The least squares method  <a name="___sec119"></a></h4>

<p>
$$
(R,\frac{\partial R}{\partial c_i}) = 0,\quad i\in\If\tp 
$$


<p>
We need an expression for
\( \partial R/\partial c_i \):

<p>
$$
\begin{equation}
\frac{\partial R}{\partial c_i} =
\frac{\partial}{\partial c_i}
\left(\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\right)
= \baspsi_i''(x)\tp  \end{equation}
$$

Because:
$$
\frac{\partial}{\partial c_i}\left(c_0\baspsi_0'' + c_1\baspsi_1'' + \cdots +
c_{i-1}\baspsi_{i-1}'' + c_i\baspsi_{i}'' + c_{i+1}\baspsi_{i+1}''
+ \cdots + c_N\baspsi_N'' \right) = \baspsi_{i}''
$$


<p>
The governing equations for \( c_0,\ldots,c_N \) are then

<p>
$$
\begin{equation}
(\sum_j c_j \baspsi_j'' + f,\baspsi_i'')=0,\quad i\in\If,
\end{equation}
$$

which can be rearranged as

<p>
$$
\begin{equation}
\sum_{j\in\If}(\baspsi_i'',\baspsi_j'')c_j = -(f,\baspsi_i''),\quad i\in\If\tp  \end{equation}
$$

This is nothing but a linear system

<p>
$$
\begin{equation*} \sum_{j\in\If}A_{i,j}c_j = b_i,\quad i\in\If,
\end{equation*}
$$

with

<p>
$$
\begin{align}
A_{i,j} &= (\baspsi_i'',\baspsi_j'')\nonumber\\ 
& = \pi^4(i+1)^2(j+1)^2L^{-4}\int_0^L \sinL{i}\sinL{j}\, dx\nonumber\\ 
&= \left\lbrace
\begin{array}{ll} {1\over2}L^{-3}\pi^4(i+1)^4 & i=j  \\ 0, & i\neq j
\end{array}\right.
\\ 
b_i &= -(f,\baspsi_i'') = (i+1)^2\pi^2L^{-2}\int_0^Lf(x)\sinL{i}\, dx
\end{align}
$$

Since the coefficient matrix is diagonal we can easily solve for

<p>
$$
\begin{equation}
c_i = \frac{2L}{\pi^2(i+1)^2}\int_0^Lf(x)\sinL{i}\, dx\tp 
\tag{42}
\end{equation}
$$

With the special choice of \( f(x)=2 \) the integral becomes

<p>
$$
\begin{equation*} \frac{L\cos(\pi i) + L}{\pi (i+1)},\end{equation*}
$$


<p>
The solution becomes:

<p>
$$
\begin{equation}
u(x) = \sum_{k=0}^{N/2} \frac{8L^2}{\pi^3(2k+1)^3}\sinL{2k}\tp  \end{equation}
$$


<p>
The coefficients decay very fast: \( c_2 = c_0/27 \), \( c_4=c_0/125 \).
The first term therefore suffices:

<p>
$$
\begin{equation*} u(x) \approx \frac{8L^2}{\pi^3}\sin\left(\pi\frac{x}{L}\right)\tp  \end{equation*}
$$

<h4>The Galerkin method  <a name="___sec120"></a></h4>

<p>
$$
\begin{equation*}
(u''+f,v)=0,\quad \forall v\in V,
\end{equation*}
$$

or

<p>
$$
\begin{equation}
(u'',v) = -(f,v),\quad\forall v\in V\tp  \end{equation}
$$


<p>
This is called a <em>variational formulation</em> of the differential equation problem.

<p>
\( \forall v\in V \) means for all basis functions:

<p>
$$
\begin{equation}
(\sum_{j\in\If} c_j\baspsi_j'', \baspsi_i)=-(f,\baspsi_i),\quad i\in\If\tp  \end{equation}
$$


<p>
For the particular choice of the sine basis functions, we
get in fact the same linear system
as in the least squares method
(because \( \baspsi''= -(i+1)^2\pi^2L^{-2}\baspsi \)).

<h4>The collocation method  <a name="___sec121"></a></h4>

<p>
Residual must vanish at selected points, or equivalently, the
differential equation with approximation \( u \) inserted, must be
fulfilled at selected points:

<p>
$$
\begin{equation}
-\sum_{j\in\If} c_j\baspsi_j''(\xno{i}) = f(\xno{i}),\quad i\in\If
\tp 
\end{equation}
$$

This is a linear system with entries

<p>
$$
\begin{equation*} A_{i,j}=-\baspsi_j''(\xno{i})=
(j+1)^2\pi^2L^{-2}\sin\left((j+1)\pi \frac{x_i}{L}\right),\end{equation*}
$$

and \( b_i=2 \).

<p>
Special case: \( N=0 \), \( x_0=L/2 \)
$$ c_0=2L^2/\pi^2 $$

<h4>Comparison  <a name="___sec122"></a></h4>

<p>

<ul>
 <p><li> Exact solution: \( u(x)=x(L-x) \)</li>
 <p><li> Galerkin or least squares (\( N=0 \)): \( u(x)=8L^2\pi^{-3}\sin (\pi x/L) \)</li>
 <p><li> Collocation method (\( N=0 \)): \( u(x)=2L^2\pi^{-2}\sin (\pi x/L) \).</li>
 <p><li> Max error in Galerkin/least sq.: \( -0.008L^2 \)</li>
 <p><li> Max error in collocation: \( 0.047L^2 \)</li>
</ul>

<h3>Integration by parts <a name="fem:deq:1D:varform"></a></h3>

<p>

<ul>
 <p><li> Finite elements: \( \baspsi_i = \baspsi_i \)</li>
 <p><li> Problem: \( \baspsi_i' \) is discontinuous (at cell boundaries)
   and we need \( \baspsi_i'' \) in the Galerkin or least squares methods</li>
 <p><li> Remedy: integrate by parts - then we only need \( \baspsi_i' \)</li>
</ul>

Given
$$
\begin{equation*} -(u'',v) = (f,v)\quad\forall v\in V\tp
\end{equation*}
$$

Integrate by parts:

<p>
$$
\begin{align}
\int_0^L u''(x)v(x) dx &= - \int_0^Lu'(x)v'(x)dx
+ [vu']_0^L\nonumber\\ 
&= - \int_0^Lu'(x)v'(x) dx
+ u'(L)v(L) - u'(0)v(0)\tp 
\tag{43}
\end{align}
$$


<p>
Recall that \( v(0)=v(L)=0 \), i.e.,
\( \baspsi_i(0)=\baspsi_i(L)=0 \) because we demand so where we have
Dirichlet conditions.

<p>
Advantageous features of integration by parts:

<p>

<ul>
  <p><li> Only first-order derivatives</li>
  <p><li> Symmatric coefficient matrix</li>
  <p><li> Incorporation of \( u' \) boundary conditions (later)</li>
</ul>

<h3>Boundary function  <a name="___sec124"></a></h3>
<a name="fem:deq:1D:essBC:Bfunc"></a>

<p>

<ul>
 <p><li> What about nonzero Dirichlet conditions?</li>
 <p><li> E.g. \( u(L)=D \)</li>
 <p><li> Problem: \( u(L) = \sum_j c_j\baspsi_j(L)=0 \) - always</li>
 <p><li> Remedy: \( u(x) = B(x) + \sum_j c_j\baspsi_j(x) \)</li>
 <p><li> \( u(0)=B(0) \), \( u(L)=B(L) \)</li>
 <p><li> \( B(x) \) must fulfill the Dirichlet conditions on \( u \)</li>
 <p><li> No restrictions of how \( B(x) \) varies in the interior</li>
</ul>

<h4>Example  <a name="___sec125"></a></h4>

<p>
\( u(0)=0 \) and \( u(L)=D \). Choose

<p>
$$ B(x) = \frac{D}{L}x:\qquad B(0)=0,\ B(L)=D \tp $$


<p>
$$
\begin{equation}
u(x) = \frac{x}{L}D + \sum_{j\in\If} c_j\baspsi_j(x),
\tag{44}
\end{equation}
$$


<p>
$$ u(0) = 0,\quad u(L) = 0\tp  $$

<h3>Abstract notation for variational formulations <a name="fem:deq:1D:varform:abstract"></a></h3>

<p>
The finite element literature (and much FEniCS documentation)
applies an abstract notation for the variational formulation:
*Find \( u-B\in V \) such that
$$ a(u,v) = L(v)\quad \forall v\in V\tp $$

<h4>Example  <a name="___sec127"></a></h4>

<p>
Given a variational formulation for \( -u''=f \):

<p>
$$ \int_{\Omega} u' v'dx = \int_{\Omega} fvdx\quad\hbox{or}\quad (u',v') = (f,v)
\quad\forall v\in V$$

we identify

<p>
$$ a(u,v) = (u',v'),\quad L(v) = (f,v)\tp  $$


<p>
Then we can write
$$ a(u,v) = L(v)\quad \forall v\in V,$$

if

<h4>Bilinear and linear forms  <a name="___sec128"></a></h4>

<p>
\( a(u,v) \) is a <em>bilinear form</em> and \( L(v) \) is a <em>linear form</em>.

<p>
Linear form:

<p>
$$ L(\alpha_1 v_1 + \alpha_2 v_2)
=\alpha_1 L(v_1) + \alpha_2 L(v_2),
$$


<p>
Bilinear form:
$$
\begin{align*}
a(\alpha_1 u_1 + \alpha_2 u_2, v) &= \alpha_1 a(u_1,v) + \alpha_2 a(u_2, v),
\\ 
a(u, \alpha_1 v_1 + \alpha_2 v_2) &= \alpha_1 a(u,v_1) + \alpha_2 a(u, v_2)
\tp 
\end{align*}
$$


<p>
In nonlinear problems the abstract form is \( F(u;v)=0 \) $\forall v\in V$.

<p>
The abstract form \( a(u,v)=L(v) \) is equivalent with a linear system

<p>
$$ \sum_{j\in\If} A_{i,j}c_j=b_i,\quad i\in\If$$

with
$$
\begin{align*}
A_{i,j} &= a(\baspsi_j,\baspsi_i),\\ 
b_i &= L(\baspsi_i) \tp 
\end{align*}
$$

<h3>More examples on variational formulations <a name="fem:deq:1D:varform:ex"></a></h3>

<h4>Variable coefficient  <a name="___sec130"></a></h4>

<p>
Consider the problem

<p>
$$
\begin{equation}
-\frac{d}{dx}\left( a(x)\frac{du}{dx}\right) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u(L)=D\tp 
\end{equation}
$$


<p>
Two new features:

<p>

<ul>
 <p><li> a variable coefficient \( a(x) \)</li>
 <p><li> nonzero Dirichlet conditions at \( x=0 \) <em>and</em> \( x=L \)</li>
</ul>

A boundary function handles nonzero Dirichlet conditions:

<p>
$$
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_i(x),\quad \baspsi_i(0)=\baspsi_i(L)=0
$$


<p>
One possible choice of \( B \) is:

<p>
$$ B(x) = C + \frac{1}{L}(D-C)x
\tp 
$$


<p>
The residual:

<p>
$$ R = -\frac{d}{dx}\left( a\frac{du}{dx}\right) -f\tp $$


<p>
Galerkin's method:

<p>
$$
(R, v) = 0,\quad \forall v\in V,
$$


<p>
Written in terms of integrals:

<p>
$$
\int_{\Omega} \left(\frac{d}{dx}\left( a\frac{du}{dx}\right) -f\right)v dx = 0,\quad \forall v\in V \tp 
$$


<p>
Integration by parts:

<p>
$$ -\int_{\Omega} \frac{d}{dx}\left( a(x)\frac{du}{dx}\right) vdx
= \int_{\Omega} a(x)\frac{du}{dx}\frac{dv}{dx}dx -
\left[a\frac{du}{dx}v\right]_0^L
\tp 
$$

Must have \( v=0 \) where we have Dirichlet conditions: boundary terms vanish.

<p>
The final variational formulation:

<p>
$$
\int_{\Omega} a(x)\frac{du}{dx}\frac{dv}{dx}dx = \int_{\Omega} f(x)vdx,\quad
\forall v\in V,
$$


<p>
Alternative, compact notation:

<p>
$$
(a u',v') = (f,v),\quad \forall v\in V
\tp 
$$


<p>
The abstract notation is

<p>
$$ a(u,v)=L(v)\quad\forall v\in V,$$

with
$$ a(u,v)= (au',v'),\quad L(v)=(f,v) \tp  $$

Do not mix the \( a \) in \( a(\cdot,\cdot) \) (notation) and \( a(x) \) (function
name).

<p>
Can derive the linear system by inserting \( u=B + \sum_jc_j\baspsi_j \) and
\( v=\baspsi_i \):

<p>
$$ \sum_{j\in\If} (a\baspsi_j', \baspsi_i')c_j  =
(f,\baspsi_i) + (a(D-C)L^{-1},\baspsi_i'),
\quad i\in\If,
$$

or \( \sum_j A_{i,j}c_j=b_i \) with

<p>
$$
\begin{align*}
A_{i,j} &= (a\baspsi_j', \baspsi_i') = \int_{\Omega} a(x)\baspsi_j'(x),
\baspsi_i'(x)dx,\\ 
b_i &= (f,\baspsi_i) + (a(D-C)L^{-1},\baspsi_i')=
\int_{\Omega} \left(f(x)\baspsi_i(x) + a(x)\frac{D-C}{L}\baspsi_i'(x)\right)dx
\tp 
\end{align*}
$$

<h4>First-order derivative in the equation and boundary condition  <a name="___sec131"></a></h4>

<p>
Model:

<p>
$$
\begin{equation}
-u''(x) + bu'(x) = f(x),\quad x\in\Omega =[0,L],\ 
u(0)=C,\ u'(L)=E\tp 
\end{equation}
$$


<p>
New features:

<p>

<ul>
 <p><li> first-order derivative \( u' \) in the equation</li>
 <p><li> boundary condition with \( u' \): \( u'(L)=E \)</li>
</ul>

Initial steps:

<p>

<ul>
 <p><li> Must force \( \baspsi_i(0)=0 \) because of Dirichlet condition at \( x=0 \)</li>
 <p><li> Boundary function: \( B(x)=C(L-x)/L \)</li>
 <p><li> No requirements on \( \baspsi_i(L) \) (no Dirichlet condition at \( x=L \))</li>
</ul>

$$ u = \frac{C}{L}(L-x) + \sum_{j\in\If} c_j \baspsi_i(x)
\tp 
$$


<p>
Galerkin's method: multiply by \( v \), integrate over \( \Omega \), integrate
by parts.

<p>
$$  (-u'' + bu' - f, v) = 0,\quad\forall v\in V,$$


<p>
$$  (-u'',v) + (bu',v) - (f, v) = 0,\quad\forall v\in V,$$


<p>
$$ (u',v') + (bu',v) = (f,v) + [u' v]_0^L, \quad\forall v\in V,$$


<p>
$$ (u'v') + (bu',v) = (f,v) + Ev(L), \quad\forall v\in V,$$

when \( [u' v]_0^L = u'(L)v(L) = E v(L) \) because
\( v(0)=0 \) and \( u'(L)=E \).

<p>
Important:

<p>

<ul>
  <p><li> The boundary term can be used to implement Neumann conditions</li>
  <p><li> Forgetting the boundary term implies the condition \( u'=0 \) (!)</li>
  <p><li> Such conditions are called <em>natural boundary conditions</em></li>
</ul>

Abstract notation:

<p>
$$ a(u,v)=L(v)\quad\forall v\in V,$$

with the particular formulas
$$ a(u,v)=(u',v') + (bu',v),\quad L(v)= (f+C,v) + E v(L)\tp $$


<p>
Linear system: insert \( u=B+\sum_jc_j\baspsi_j \) and \( v=\baspsi_i \),

<p>
$$ \sum_{j\in\If} \underbrace{((\baspsi_j',\baspsi_i') + (b\baspsi_j',\baspsi_i))}_{A_{i,j}} c_j = \underbrace{(f,\baspsi_i) + (bCL^{-1},\baspsi_i') + E \baspsi_i(L)}_{b_i}
\tp 
$$


<p>
Observation: \( A_{i,j} \) is not symmetric because of the term

<p>
$$
(b\baspsi_j',\baspsi_i)=\int_{\Omega} b\baspsi_j'\baspsi_i dx
 \neq \int_{\Omega} b \baspsi_i' \baspsi_jdx = (\baspsi_i',b\baspsi_j)
\tp 
$$

<h3>Example on computing with Dirichlet and Neumann conditions  <a name="___sec132"></a></h3>

<p>
Let us solve

<p>
$$
\begin{equation*} -u''(x)=f(x),\quad x\in \Omega=[0,1],\quad u'(0)=C,\ u(1)=D,\end{equation*}
$$


<p>

<ul>
 <p><li> Use a <em>global</em> polynomial basis \( \baspsi_i\sim x^i \) on \( [0,1] \)</li>
 <p><li> Because of \( u(1)=D \): \( \baspsi_i(1)=0 \)</li>
 <p><li> Basis: \( \baspsi_i(x)=(1-x)^{i+1} \), \( i\in\If \)</li>
 <p><li> \( B(x)=Dx \)</li>
</ul>

We have

<p>
$$ A_{i,j} = (\baspsi_j,\baspsi_i) = \int_{0}^1 \baspsi_i'(x)\baspsi_j'(x)dx
= \int_0^1 (i+1)(j+1)(1-x)^{i+j} dx,
$$

and

<p>
$$
\begin{align*}
b_i &= (2,\baspsi_i) - (D,\baspsi_i') -C\baspsi_i(0)\\ 
&= \int_0^1 \left( 2(1-x)^{i+1} - D(i+1)(1-x)^i\right)dx  -C\baspsi_i(0)
\end{align*}
$$


<p>
With \( N=1 \):

<p>
$$
\begin{equation*}
\left(\begin{array}{cc}
1 & 1\\ 
1 & 4/3
\end{array}\right)
\left(\begin{array}{c}
c_0\\ 
c_1
\end{array}\right)
=
\left(\begin{array}{c}
-C+D+1\\ 
2/3 -C + D
\end{array}\right)
\end{equation*}
$$


<p>
$$ c_0=-C+D+2, \quad c_1=-1,$$


<p>
$$ u(x) = 1 -x^2 + D + C(x-1) \tp  $$

This is also the exact solution (as expected when \( V \) contains second-degree
polynomials).

<h4>Nonlinear terms  <a name="___sec133"></a></h4>

<p>
The techniques used to derive variational
forms also apply in nonlinear cases.

<p>
Consider
$$
\begin{equation}
-(a(u)u')' = f(u),\quad x\in [0,L],\ u(0)=0,\ u'(L)=E
\tp 
\end{equation}
$$


<p>
Using the Galerkin principle, we multiply by \( v\in V \) and integrate,

<p>
$$ -\int_0^L \frac{d}{dx}\left(a(u)\frac{du}{dx}\right)v dx =
\int_0^L f(u)v\, dx\quad\forall v\in V
\tp 
$$

Integration by parts is not affected by \( a(u) \):

<p>
$$ \int_0^L a(u)\frac{du}{dx}\frac{dv}{dx} dx =
\int_0^L f(u)v\, dx + [avu']_0^L\quad\forall v\in V
\tp 
$$

\( [vu']_0^L=v(L)E \) since \( v(0)=0 \) and \( u'(L)=E \).

<p>
$$ (a(u)u', v') = (f(u),v) + a(L)v(L)E\quad\forall v\in V
\tp 
$$


<p>
Since the problem is nonlinear, we cannot identify a <em>bilinear</em> form
\( a(u,v) \) and a <em>linear</em> form \( L(v) \).
An abstract notation is typically <em>find \( u \) such that</em>

<p>
$$ F(u;v) = 0\quad\forall v\in V,$$

here with
$$ F(u;v) = (a(u)u', v') - (f(u),v) - a(L)v(L)E
\tp 
$$


<p>
By inserting \( u=\sum_j c_j\baspsi_j \) we get a <em>nonlinear system of
algebraic equations</em> for the unknowns \( c_0,\ldots,c_N \). Such systems must
be solved by constructing a sequence of linear systems whose solutions
converge to the solution of the nonlinear system. Frequently applied
methods are Picard iteration and Newton's method.

<h3>Variational problems and optimization of functionals <a name="fem:deq:1D:optimization"></a></h3>

<p>
If \( a(u,v)=a(v,u) \), it can be shown that the variational statement
\( a(u,v)=L(v)\ \forall v\in V \) is equivalent to minimizing the functional

<p>
$$ F(v) = \frac{1}{2}a(v,v) - L(v) $$

That is, find \( u \) such that

<p>
$$ F(u)\leq F(v)\quad\forall v\in V\tp $$


<p>
Traditional use of finite elements, especially in structural analysis,
often starts with \( F(v) \) and
then derives \( a(u,v)=L(v) \).

<h2>Computing with finite elements <a name="fem:deq:1D:fem1"></a></h2>

<p>
Given

<p>
$$ -u''(x) = 2,\quad x\in (0,L),\ u(0)=u(L)=0,$$

with variational formulation

<p>
$$ (u',v') = (2,v)\quad\forall v\in V\tp  $$


<p>
Tasks:

<p>

<ul>
 <p><li> Solve for \( u \) using finite elements</li>
 <p><li> show all details</li>
 <p><li> Uniformly spaced nodes</li>
 <p><li> P1 elements</li>
</ul>

Since \( u(0)=0 \) and \( u(L)=0 \), \( c_0=c_N=0 \), and we can use a
sum over basis functions associated with internal nodes only:

<p>
$$
\begin{equation*}
u(x) = \sum_{j=1}^{N-1}c_j\basphi_j(x)\tp 
\end{equation*}
$$

<h3>Computation in the global physical domain  <a name="___sec136"></a></h3>

<p>
We are to compute

<p>
$$
\begin{equation*}
A_{i,j}=\int_0^L\basphi_i'(x)\basphi_j'(x) dx,\quad
b_i=\int_0^L2\basphi_i(x) dx
\tp  \end{equation*}
$$


<p>
Need \( \basphi_i'(x) \) in the formulas:

<p>
$$
\begin{equation}
\basphi_i'(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
h^{-1},
& \xno{i-1} \leq x < \xno{i},\\ 
-h^{-1},
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{45}
\end{equation}
$$


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Illustration of the derivative of piecewise linear basis functions associated with nodes in cell 1.  <a name="fem:approx:fe:fig:dP1"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_dbasis_p1_4e_lab.png" align="bottom" width=600></p>
</center>

<p>
We realize that \( \basphi_i' \) and \( \basphi_j' \) has no overlap, and hence their
product vanishes, unless \( i \) and \( j \) are nodes belonging to the same
element. The only nonzero contributions to the coefficient matrix are
therefore

<p>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
2 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 2
\end{array}
\right)
\left(
\begin{array}{c}
c_1 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N-1}
\end{array}
\right)
=
\left(
\begin{array}{c}
2h \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
2h
\end{array}
\right)
\tag{46}
\end{equation}
$$


<p>
\( c_j=u(\xno{j}) \) so we introduce \( u_j=c_j \) to easily compare with
the finite difference method. The equation corresponding to row \( i \):

<p>
$$
\begin{equation}
-\frac{1}{h}u_{i-1} + \frac{2}{h}u_{i} - \frac{1}{h}u_{i+1} = 2h\tp 
\tag{47}
\end{equation}
$$


<p>
Standard finite difference approximation of \( -u''(x)=2 \), with
\( u''(x_i)\approx [D_x D_x u]_i \) and \( \Delta x = h \),
yields

<p>
$$
\begin{equation}
-\frac{u_{i-1} - 2u_{i} + u_{i+1}}{h^2} = 2,
\end{equation}
$$


<p>

<ul>
 <p><li> The finite element and the finite difference method give the
   same equation (in this example)</li>
</ul>

<h3>Elementwise computations  <a name="___sec137"></a></h3>

<p>
We follow the same elementwise set-up as for approximating \( f \) by \( u \).

<p>
Present element matrix:

<p>
$$
\begin{equation*}
A_{i,j}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) dx
= \int_{-1}^1 \frac{d}{dx}\refphi_r(X)\frac{d}{dx}\refphi_s(X)
\frac{h}{2} dX,\quad i=q(e,r),\ j=q(e,s),\ r,s=1,2
\tp 
\end{equation*}
$$


<p>
\( \refphi_r(X) \) are known as functions of \( X \), but
we need \( d\refphi_r(X)/dx \).

<p>
Given

<p>
$$
\begin{equation*} \refphi_0(X)=\half(1-X),\quad\refphi_1(X)=\half(1+X),\end{equation*}
$$

we can easily compute \( d\refphi_r/ dX \):

<p>
$$
\begin{equation*}\frac{d\refphi_0}{dX} = -\half,\quad  \frac{d\refphi_1}{dX} = \half\tp  \end{equation*}
$$

From the chain rule,

<p>
$$
\begin{equation}
\frac{d\refphi_r}{dx} = \frac{d\refphi_r}{dX}\frac{dX}{dx}
= \frac{2}{h}\frac{d\refphi_r}{dX}\tp  \end{equation}
$$

The transformed integral is then:

<p>
$$
\begin{equation*}
A_{i,j}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) dx
= \int_{-1}^1 \frac{2}{h}\frac{d\refphi_r}{dX}\frac{2}{h}\frac{d\refphi_s}{dX}
\frac{h}{2} dX
\tp 
\end{equation*}
$$


<p>
The right-hand side is transformed according to

<p>
$$
\begin{equation*} b_i^{(e)} = \int_{\Omega^{(e)}} 2\basphi_i(x) dx =
\int_{-1}^12\refphi_r(X)\frac{h}{2} dX,\quad i=q(e,r),\ r=1,2
\tp 
\end{equation*}
$$


<p>
We have to compute the matrix entries one by one...

<p>
$$
\begin{align*}
\tilde A_{0,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\frac{1}{2}\right)
\frac{2}{h}\left(-\frac{1}{2}\right)\frac{2}{h} dX = \frac{1}{h}\\ 
\tilde A_{0,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\frac{1}{2}\right)
\frac{2}{h}\left(\frac{1}{2}\right)\frac{2}{h} dX = -\frac{1}{h}\\ 
\tilde A_{1,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\frac{1}{2}\right)
\frac{2}{h}\left(-\frac{1}{2}\right)\frac{2}{h} dX = -\frac{1}{h}\\ 
\tilde A_{1,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\frac{1}{2}\right)
\frac{2}{h}\left(\frac{1}{2}\right)\frac{2}{h} dX = \frac{1}{h}
\end{align*}
$$

The element vector entries become
$$
\begin{align*}
\tilde b_0^{(e)} &= \int_{-1}^12\half(1-X)\frac{h}{2} dX = h\\ 
\tilde b_1^{(e)} &= \int_{-1}^12\half(1+X)\frac{h}{2} dX = h\tp 
\end{align*}
$$


<p>
In matrix/vector notation:

<p>
$$
\begin{equation}
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1\\ 
1
\end{array}\right)\tp 
\tag{48}
\end{equation}
$$


<p>
Must assemble - but first see how to incorporate boundary conditions.

<h2>Boundary conditions: specified value <a name="fem:deq:1D:essBC"></a></h2>

<h3>General construction of a boundary function <a name="fem:deq:1D:essBC:Bfunc"></a></h3>

<p>

<ul>
  <p><li> \( B(x) \) is not always easy to construct (extend to the interior of \( \Omega \)),
    at least not in 2D and 3D</li>
  <p><li> With finite element \( \basphi_i \), \( B(x) \) can be constructed in
    a completely general way</li>
</ul>

$$
\begin{equation}
B(x) = \sum_{j\in D} U_j\basphi_j(x), \end{equation}
$$

where \( D \) are the nodes with Dirichlet conditions and \( U_j \) the known values.

<p>
In 1D
$$
\begin{equation}
B(x) = U_0\basphi_0(x) + U_N\basphi_N(x)\tp  \end{equation}
$$


<p>
Unknowns: \( c_1,\ldots,c_{N-1} \),

<p>
$$
\begin{equation}
u(x) = U_0\basphi_0(x) + U_N\basphi_N(x) + \sum_{j=1}^{N-1} c_j\basphi_j(x)\tp  \end{equation}
$$

<h4>Example  <a name="___sec140"></a></h4>

<p>
$$ -u''=2, \quad u(0)=0,\ u(L)=D\tp  $$


<p>
The expansion for \( u(x) \) reads

<p>
$$
u(x) = 0\cdot\basphi_0(x) + D\basphi_N(x) +
\sum_{j=1}^{N-1} c_j\basphi_j(x)
\tp 
$$

Inserting this expression in \( -(u'',\basphi_i)=(f,\basphi_i) \) and
integrating by parts results in a linear system with

<p>
$$
A_{i,j} = \int_0^L \basphi_i'(x)\basphi_j'(x) dx,\quad
b_i = \int_0^L (f(x) - D\basphi_N'(x))\basphi_i(x) dx,
$$

for \( i,j = 1,\ldots,N-1 \).

<h3>Modification of the linear system <a name="fem:deq:1D:essBC:Bfunc:modsys"></a></h3>

<p>

<ul>
 <p><li> \( B(x) \) and a reduced set of unknowns (e.g., \( c_1,\ldots,c_{N-1} \))
   are not so convenient in implementations</li>
 <p><li> We shall look at a less strict mathematical procedure that
   gives simpler impelementation</li>
 <p><li> Step 1: compute everything as there were no Dirichlet conditions</li>
 <p><li> Step 2: modify the linear system such that all known \( c_j \) get
   their right boundary values</li>
</ul>

Linear system from \( -u''=f \) without taking Dirichlet conditions into
account (\( u=\sum_{j\in\If}c_j\basphi_j \)):

<p>
$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
h \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
h
\end{array}
\right)
\tag{49}
\end{equation}
$$


<p>
Actions:

<p>

<ul>
 <p><li> General: replace row \( i \) by \( c_i=K \) if \( u \) at \( \xno{i} \) is prescrined as \( K \)</li>
 <p><li> Here: replace the first and last row by \( c_0=0 \) and \( c_N=D \)</li>
</ul>

$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h\\ 
D
\end{array}
\right)
\tag{50}
\end{equation}
$$

<h3>Symmetric modification of the linear system  <a name="___sec142"></a></h3>

<p>

<ul>
 <p><li> The modification above destroys symmetry of the matrix (\( A_{0,1}\neq A_{1,0} \))</li>
 <p><li> Symmetry is often important in 2D and 3D (faster computations)</li>
 <p><li> A more complex modification preserves symmetry</li>
</ul>

Algorithm for incorporating \( c_i=K \):

<p>

<ol>
<p><li> Subtract column \( i \) times \( K \) from the right-hand side</li>
<p><li> Zero out column and row no \( i \)</li>
<p><li> Place 1 on the diagonal</li>
<p><li> Set \( b_i=K \)</li>
</ol>

$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
1 & 0 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
0 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & 0 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 0 & 1
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
0 \\ 
2h\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
2h +D/h\\ 
D
\end{array}
\right)
\tag{51}
\end{equation}
$$

<h3>Modification of the element matrix and vector  <a name="___sec143"></a></h3>

<p>

<ul>
 <p><li> Modification of the linear system can be done in the
   the element matrix and vector instead</li>
 <p><li> Exactly the same procedure</li>
</ul>

Last degree of freedom in the last element is prescribed:

<p>
$$
\begin{equation}
\tilde A^{(N-1)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h\\ 
D
\end{array}\right)\tp 
\tag{52}
\end{equation}
$$


<p>
Or symmetric modification:

<p>
$$
\begin{equation}
\tilde A^{(N-1)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 0\\ 
0 & 1
\end{array}\right),\quad
\tilde b^{(N-1)} = \left(\begin{array}{c}
h + D/h\\ 
D
\end{array}\right)\tp 
\tag{53}
\end{equation}
$$

<h2>Boundary conditions: specified derivative <a name="fem:deq:1D:BC:nat"></a></h2>

<p>
Focus now: how to incorporate \( u'(0)=C \) with finite elements.

<h3>The variational formulation  <a name="___sec145"></a></h3>

<p>
Start with the Galerkin method:

<p>
$$
\begin{equation*} \int_0^L(u''(x)+f(x))\basphi_i(x) dx = 0,\quad i\in\If,\end{equation*}
$$


<p>
Integration of \( u''\basphi_i \) by parts:

<p>
$$
\begin{equation*} \int_0^Lu'(x)'\basphi_i'(x) dx -(u'(L)\basphi_i(L) - u'(0)\basphi_i(0)) =
\int_0^L f(x)\basphi_i(x) dx
\tp 
\end{equation*}
$$


<p>

<ul>
 <p><li> Since \( \basphi_i(L)=0 \), \( u'(L)\basphi_i(L)=0 \)</li>
 <p><li> \( u'(0)\basphi_i(0) = C\basphi_i(0) \) since \( u'(0)=C \)</li>
</ul>

$$
\begin{equation*} \int_0^Lu'(x)\basphi_i'(x) dx + C\basphi_i(0) =
\int_0^L f(x)\basphi_i(x) dx,\quad i\in\If\tp  \end{equation*}
$$

Inserting

<p>
$$
\begin{equation*} u(x) = B(x) + \sum_{j=0}^{N-1} c_j\basphi_j(x),
\quad B(x) = D\basphi_N(x),
\end{equation*}
$$

<!-- \frac{x}{L}D -->
leads to the linear system

<p>
$$
\begin{equation}
\sum_{j=0}^{N-1}\left(
\int_0^L \basphi_i'(x)\basphi_j'(x) dx \right)c_j =
\int_0^L\left(f(x)\basphi_i(x) -D\basphi_N'(x)\basphi_i(x)\right) dx
 - C\basphi_i(0),
\tag{54}
\end{equation}
$$

for \( i=0,\ldots,N-1 \).

<p>
Alternatively, we may just work with

<p>
$$
\begin{equation*} u(x) = \sum_{j=0}^{N} c_j\basphi_j(x),
\end{equation*}
$$

and modify the last equation to \( c_N=D \) in the linear system.

<p>
The extra term with \( C \) affects only the element vector from the
first element:

<p>
$$
\begin{equation}
\tilde A^{(0)} =
A = \frac{1}{h}\left(\begin{array}{rr}
1 & 1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(0)} = \left(\begin{array}{c}
h - C\\ 
h
\end{array}\right)\tp 
\tag{55}
\end{equation}
$$

<h2>The finite element algorithm  <a name="___sec146"></a></h2>

<p>
The problem at hand determines the integrals in the variational
formulation.

<p>
Request these functions from the user:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">integrand_lhs(phi, r, s, x)
boundary_lhs(phi, r, s, x)
integrand_rhs(phi, r, x)
boundary_rhs(phi, r, x)
</pre></div>
<p>
Given a mesh in terms of <code>vertices</code>, <code>cells</code>, and <code>dof_map</code>,
the rest is (almost) automatic.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&lt;</span>Declare <span style="color: #008000; font-weight: bold">global</span> matrix <span style="color: #AA22FF; font-weight: bold">and</span> rhs: A, b<span style="color: #666666">&gt;</span>

<span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(cells)):

    <span style="color: #408080; font-style: italic"># Compute element matrix and vector</span>
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(dof_map[e])  <span style="color: #408080; font-style: italic"># no of dofs in this element</span>
    h <span style="color: #666666">=</span> vertices[cells[e][<span style="color: #666666">1</span>]] <span style="color: #666666">-</span> vertices[cells[e][<span style="color: #666666">1</span>]]
    <span style="color: #666666">&lt;</span>Declare element matrix <span style="color: #AA22FF; font-weight: bold">and</span> vector: A_e, b_e<span style="color: #666666">&gt;</span>

    <span style="color: #408080; font-style: italic"># Integrate over the reference cell</span>
    points, weights <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>numerical integration rule<span style="color: #666666">&gt;</span>
    <span style="color: #008000; font-weight: bold">for</span> X, w <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(points, weights):
        phi <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>basis functions <span style="color: #AA22FF; font-weight: bold">and</span> derivatives at X<span style="color: #666666">&gt;</span>
        detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>
        x <span style="color: #666666">=</span> <span style="color: #666666">&lt;</span>affine mapping <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">X</span><span style="color: #666666">&gt;</span>
        <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
                A_e[r,s] <span style="color: #666666">+=</span> integrand_lhs(phi, r, s, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w
            b_e[r] <span style="color: #666666">+=</span> integrand_rhs(phi, r, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w

    <span style="color: #408080; font-style: italic"># Add boundary terms</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            A_e[r,s] <span style="color: #666666">+=</span> boundary_lhs(phi, r, s, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w
        b_e[r] <span style="color: #666666">+=</span> boundary_rhs(phi, r, x)<span style="color: #666666">*</span>detJ<span style="color: #666666">*</span>w

    <span style="color: #408080; font-style: italic"># Incorporate essential boundary conditions</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        global_dof <span style="color: #666666">=</span> dof_map[e][r]
        <span style="color: #008000; font-weight: bold">if</span> global_dof <span style="color: #AA22FF; font-weight: bold">in</span> essbc_dofs:
            <span style="color: #408080; font-style: italic"># dof r is subject to an essential condition</span>
            value <span style="color: #666666">=</span> essbc_docs[global_dof]
            <span style="color: #408080; font-style: italic"># Symmetric modification</span>
            b_e <span style="color: #666666">-=</span> value<span style="color: #666666">*</span>A_e[:,r]
            A_e[r,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            A_e[:,r] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            A_e[r,r] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
            b_e[r] <span style="color: #666666">=</span> value

    <span style="color: #408080; font-style: italic"># Assemble</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
            A[dof_map[e][r], dof_map[e][r]] <span style="color: #666666">+=</span> A_e[r,s]
        b[dof_map[e][r] <span style="color: #666666">+=</span> b_e[r]

<span style="color: #666666">&lt;</span>solve linear system<span style="color: #666666">&gt;</span>
</pre></div>

<h2>Variational formulations in 2D and 3D <a name="fem:deq:2D:varform"></a></h2>

<p>
How to do integration by parts is the major difference when moving to
2D and 3D.

<p>
Consider

<p>
$$ \nabla^2 u \quad\hbox{or}\quad \nabla\cdot\left( a(\x)\nabla u\right)
\tp 
$$

with explicit 2D expressions
$$ \nabla^2 u = \nabla\cdot\nabla u =
\frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2},
$$

and
$$
\nabla\cdot\left( a(\x)\nabla u\right) =
\frac{\partial}{\partial x}\left( a(x,y)\frac{\partial u}{\partial x}\right) +
\frac{\partial}{\partial y}\left( a(x,y)\frac{\partial u}{\partial y}\right)
\tp 
$$


<p>
The general rule for integrating by parts is

<p>
$$
\begin{equation}
-\int_{\Omega} \nabla\cdot (a(\x)\nabla u) v\dx =
\int_{\Omega} a(\x)\nabla u\cdot\nabla v \dx -
\int_{\partial\Omega} a\frac{\partial u}{\partial n} v \ds,
\tag{56}
\end{equation}
$$


<p>

<ul>
 <p><li> \( \int_\Omega ()\dx \): area (2D) or volume (3D) integral</li>
 <p><li> \( \int_{\partial\Omega} ()\ds \): line(2D) or surface (3D) integral</li>
</ul>

Let us divide the boundary into two parts:

<p>

<ul>
 <p><li> \( \partial\Omega_N \), where we have Neumann conditions
   \( -a\frac{\partial u}{\partial n} = g \), and</li>
 <p><li> \( \partial\Omega_D \), where we have Dirichlet conditions
   \( u = u_0 \).</li>
</ul>

The test functions \( v \) are required to vanish on \( \partial\Omega_D \).

<h4>Example  <a name="___sec148"></a></h4>

<p>
A general and widely appearing PDE problem:

<p>
$$
\begin{align}
\v\cdot\nabla u + \alpha u &= \nabla\cdot\left( a\nabla u\right) + f,
\quad\x\in\Omega,\\ 
u &= u_0,\quad\x\in\partial\Omega_D,\\ 
-a\frac{\partial u}{\partial n} &= g,\quad\x\in\partial\Omega_N
\tp 
\end{align}
$$


<p>

<ul>
 <p><li> Known: \( a \), \( \alpha \), \( f \), \( u_0 \), and \( g \).</li>
 <p><li> Second-order PDE: must have <em>exactly one boundary condition at each
   point of the boundary</em></li>
 <p><li> \( \partial\Omega_N\cup\partial\Omega_D \) = entire boundary</li>
</ul>

The unknown function can be expanded as

<p>
$$ u = u_0 + \sum_{j\in\If} c_j\basphi_j \tp $$


<p>
Galerkin's method: multiply by \( v\in V \) and integrate over \( \Omega \),

<p>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
\int_{\Omega} \nabla\cdot\left( a\nabla u\right)\dx + \int_{\Omega}fv \dx
\tp 
$$

Integrate second-order term by parts,

<p>
$$
\int_{\Omega} \nabla\cdot\left( a\nabla u\right) v \dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds,
$$

resulting in

<p>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v\dx
+ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
+ \int_{\Omega} fv \dx
\tp 
$$

Note: \( v\neq 0 \) only on \( \partial\Omega_N \):
$$ \int_{\partial\Omega} a\frac{\partial u}{\partial n} v\ds
= \int_{\partial\Omega_N} a\frac{\partial u}{\partial n} v\ds,
$$

Insert flux condition \( a\frac{\partial u}{\partial n}=-g \) on \( \partial\Omega_N \):
$$
-\int_{\partial\Omega_N} gv\ds\tp 
$$

The final variational form:

<p>
$$
\int_{\Omega} (\v\cdot\nabla u + \alpha u)v\dx =
-\int_{\Omega} a\nabla u\cdot\nabla v \dx
- \int_{\partial\Omega} g v\ds
+ \int_{\Omega} fv \dx
\tp 
$$


<p>
With inner product notation:

<p>
$$
(\v\cdot\nabla u, v) + (\alpha u,v) =
- (a\nabla u,\nabla v) - (g,v)_{N} + (f,v)
\tp 
$$

\( (g,v)_{N} \): line or surface integral over \( \partial\Omega_N \).

<p>
Inserting the \( u \) expansion results in
a linear system with

<p>
$$
A_{i,j} = (\v\cdot\nabla \basphi_j, \basphi_i) + (\alpha \basphi_j ,\basphi_i) + (a\nabla \basphi_j,\nabla \basphi_i)
$$


<p>
$$
b_i = (g,\basphi_i)_{N} + (f,\basphi_i) -
(\v\cdot\nabla u_0, \basphi_i) + (\alpha u_0 ,\basphi_i) +
(a\nabla u_0,\nabla \basphi_i),
$$

<h3>Transformation to a reference cell in 2D and 3D  <a name="___sec149"></a></h3>

<p>
We consider an integral of the type

<p>
$$
\begin{equation}
\int_{{\Omega}^{(e)}} a(\x)\nabla\basphi_i\cdot\nabla\basphi_j\dx
\end{equation}
$$

in the physical domain.

<p>
Goal: integrate this term over the reference cell.

<p>
Mapping from reference to physical coordinates:

<p>
$$ \x(\X), $$

with Jacobian, \( J \), given by
$$ J_{i,j}=\frac{\partial x_j}{\partial X_i}\tp $$


<p>

<ul>
 <p><li> Step 1: \( \dx \rightarrow \det J\dX \).</li>
 <p><li> Step 2: express \( \nabla\basphi_i \) by an expression with \( \refphi_r \) (\( i=q(e,r) \))</li>
 <p><li> We want \( \nabla_{\x}\refphi_r(\X) \) (derivatives wrt \( \x \))</li>
 <p><li> What we readily have: \( \nabla_{\X}\refphi_r(\X) \) (derivative wrt \( \X \))</li>
 <p><li> Need to transform \( \nabla_{\X}\refphi_r(\X) \) to \( \nabla_{\x}\refphi_r(\X) \)</li>
</ul>

Can derive

<p>
$$
\begin{align*}
\nabla_{\X}\refphi_r &= J\cdot\nabla_{\x}\basphi_i,\\ 
\nabla_{\x}\basphi_i &= J^{-1}\cdot\nabla_{\X}\refphi_r\tp 
\end{align*}
$$


<p>
Integral transformation from physical to reference coordinates:

<p>
$$
\begin{equation}
\int_{\Omega}^{(e)} a(\x)\nabla_{\x}\basphi_i\cdot\nabla_{\x}\basphi_j\dx
\int_{\tilde\Omega^r} a(\x(\X))(J^{-1}\cdot\nabla_{\X}\refphi_r)\cdot
(J^{-1}\cdot\nabla\refphi_s)\det J\dX
\end{equation}
$$

<h2>Systems of differential equations <a name="fem:sys"></a></h2>

<p>
Consider \( m+1 \) unknown functions: \( u^{(0)},\ldots, u^{(m)} \) governed
by \( m+1 \) differential equations:

<p>
$$
\begin{align*}
\mathcal{L}_0(u^{(0)},\ldots,u^{(m)}) &= 0,\\ 
&\vdots\\ 
\mathcal{L}_{m}(u^{(0)},\ldots,u^{(m)}) &= 0,
\end{align*}
$$

<h3>Variational forms <a name="fem:sys:vform"></a></h3>

<p>

<ul>
 <p><li> First approach: treat each equation as a scalar equation</li>
 <p><li> For equation no. \( i \), use test function \( v^{(i)}\in V^{(i)} \)</li>
</ul>

$$
\begin{align}
\int_\Omega \mathcal{L}^{(0)}(u^{(0)},\ldots,u^{(m)}) v^{(0)}\dx &= 0,
\tag{57}\\ 
&\vdots\\ 
\int_\Omega \mathcal{L}^{(m)}(u^{(0)},\ldots,u^{(m)}) v^{(m)}\dx &= 0
\tag{58}
\tp 
\end{align}
$$

Terms with second-order derivatives may be integrated by parts, with
Neumann conditions inserted in boundary integrals.

<p>
$$ V^{(i)} = \hbox{span}\{\basphi_0^{(i)},\ldots,\basphi_{N_i}^{(i)}\},$$


<p>
$$ u^{(i)} = B^{(i)}(\x) + \sum_{j=0}^{N_i} c_j^{(i)} \basphi_j^{(i)}(\x),
$$


<p>
Can derive \( m \) coupled linear systems for the unknowns
\( c_j^{(i)} \), \( j=0,\ldots,N_i \),
\( i=0,\ldots,m \).

<p>

<ul>
 <p><li> Second approach: work with vectors (and vector notation)</li>
 <p><li> \( \u = (u^{(0)},\ldots,u^{(m)}) \)</li>
 <p><li> \( \v = (u^{(0)},\ldots,u^{(m)}) \)</li>
 <p><li> \( \u, \v \in  \V = V^{(0)}\times \cdots \times V^{(m)} \)</li>
 <p><li> Note: if \( \boldsymbol{B} = (B^{(0)},\ldots,B^{(m)}) \) is needed for
   nonzero Dirichlet conditions, \( \u - \boldsymbol{B}\in \V \) (not \( \u \) in \( \V \))</li>
 <p><li> \( \boldsymbol{\mathcal{L}}(\u ) = 0 \)</li>
 <p><li> \( \boldsymbol{\mathcal{L}}(\u ) = (\mathcal{L}^{(0)}(\u),\ldots, \mathcal{L}^{(m)}(\u)) \)</li>
</ul>

The variational form is derived by taking the <em>inner product</em> of
\( \boldsymbol{\mathcal{L}}(\u ) \) and \( \v \):

<p>
$$
\begin{equation}
\int_\Omega \boldsymbol{\mathcal{L}}(\u )\cdot\v = 0\quad\forall\v\in\V\tp 
\tag{59}
\end{equation}
$$


<p>

<ul>
 <p><li> Observe: this is a scalar equation (!).</li>
 <p><li> Can derive \( m \) independent equation by choosing \( m \) independent \( \v \)</li>
 <p><li> E.g.: \( \v = (v^{(0)},0,\ldots,0) \) recovers <a href="#mjx-eqn-57">(57)</a></li>
 <p><li> E.g.: \( \v = (0,\ldots,0,v^{(m)} \) recovers <a href="#mjx-eqn-58">(58)</a></li>
</ul>

<h3>A worked example <a name="fem:sys:uT:ex"></a></h3>

<p>
$$
\begin{align}
\mu \nabla^2 w &= -\beta,
\tag{60}\\ 
\kappa\nabla^2 T &= - \mu ||\nabla w||^2 \quad (= \mu \nabla w\cdot\nabla w)
\tp 
\tag{61}
\end{align}
$$


<p>

<ul>
 <p><li> Unknowns: \( w(x,y) \), \( T(x,y) \)</li>
 <p><li> Known constants: \( \mu \), \( \beta \), \( \kappa \)</li>
 <p><li> Application: fluid flow in a straight pipe, \( w \) is velocity, \( T \) is
   temperature</li>
 <p><li> \( \Omega \): cross section of the pipe</li>
 <p><li> Boundary conditions: \( w=0 \) and \( T=T_0 \) on \( \partial\Omega \)</li>
 <p><li> Note: \( T \) depends on \( w \), but \( w \) does not depend on \( T \) (one-way coupling)</li>
</ul>

<h3>Identical function spaces for the unknowns  <a name="___sec153"></a></h3>

<p>
Let \( w, (T-T_0) \in V \) with test functions \( v\in V \).

<p>
$$ V = \hbox{span}\{\basphi_0(x,y),\ldots,\basphi_N(x,y)\}, $$


<p>
$$
\begin{equation}
w = \sum_{j=0}^N c^{(w)}_j \basphi_j,\quad T = T_0 + \sum_{j=0}^N c^{(T)}_j
\basphi_j\tp 
\tag{62}
\end{equation}
$$

<h4>Variational form of each individual PDE  <a name="___sec154"></a></h4>

<p>
Inserting <a href="#mjx-eqn-62">(62)</a>
in the PDEs, results in the residuals

<p>
$$
\begin{align}
R_w &= \mu \nabla^2 w + \beta,
\tag{63}\\ 
R_T &= \kappa\nabla^2 T + \mu ||\nabla w||^2
\tp 
\tag{64}
\end{align}
$$


<p>
Galerkin's method: make residual orthogonal to \( V \),

<p>
$$
\begin{align*}
\int_\Omega R_w v \dx &=0\quad\forall v\in V,\\ 
\int_\Omega R_T v \dx &=0\quad\forall v\in V
\tp 
\end{align*}
$$


<p>
Integrate by parts and use \( v=0 \) on \( \partial\Omega \) (Dirichlet conditions!):

<p>
$$
\begin{align}
\int_\Omega \mu \nabla w\cdot\nabla v \dx &= \int_\Omega \beta v\dx
\quad\forall v\in V,
\tag{65}\\ 
\int_\Omega \kappa \nabla T\cdot\nabla v \dx &= \int_\Omega \mu
\nabla w\cdot\nabla w\, v\dx \quad\forall v\in V
\tag{66}
\tp 
\end{align}
$$

<h4>Compound scalar variational form  <a name="___sec155"></a></h4>

<p>

<ul>
 <p><li> Test vector function \( \v\in\V = V\times V \)</li>
 <p><li> Take the inner product of \( \v \) and the system of PDEs (and integrate)</li>
</ul>

$$ \int_{\Omega} (R_w, R_T)\cdot\v \dx = 0\quad\forall\v\in\V
\tp $$


<p>
With \( \v = (v_0,v_1) \):

<p>
$$ \int_{\Omega} (R_w v_0 + R_T v_1) \dx = 0\quad\forall\v\in\V
\tp $$


<p>
$$
\begin{equation}
\int_\Omega (\mu\nabla w\cdot\nabla v_0 + \kappa\nabla T\cdot\nabla v_1)\dx
= \int_\Omega (\beta v_0 + \mu\nabla w\cdot\nabla w\, v_1)\dx,
\quad\forall \v\in\V
\tag{67}
\end{equation}
$$


<p>
Choosing \( v_0=v \) and \( v_1=0 \) gives the variational form
<a href="#mjx-eqn-65">(65)</a>, while \( v_0=0 \) and \( v_1=v \) gives
<a href="#mjx-eqn-66">(66)</a>.

<p>
Alternative inner product notation:

<p>
$$
\begin{align}
\mu (\nabla w,\nabla v) &= (\beta, v)
\quad\forall v\in V,
\tag{68}\\ 
\kappa(\nabla T,\nabla v) &= \mu(\nabla w\cdot\nabla w, v)\quad\forall v\in V
\tag{69}
\tp 
\end{align}
$$

<h4>Decoupled linear systems  <a name="___sec156"></a></h4>

<p>
$$
\begin{align}
\sum_{j=0}^N A^{(w)}_{i,j} c^{(w)}_j &= b_i^{(w)},\quad i=0,\ldots,N,
\tag{70}\\ 
\sum_{j=0}^N A^{(T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N,
\tag{71}\\ 
A^{(w)}_{i,j} &= \mu(\nabla \basphi_j,\nabla\basphi_i),\\ 
b_i^{(w)} &= (\beta, \basphi_i),\\ 
A^{(T)}_{i,j} &= \kappa(\nabla \basphi_j,\nabla\basphi_i),\\ 
b_i^{(T)} &= (\mu\nabla w_{-}\cdot (\sum_k
c^{(w)}_k\nabla\basphi_k), \basphi_i)
\tp 
\end{align}
$$


<p>
Matrix-vector form (alternative notation):

<p>
$$
\begin{align}
\mu K c^{(w)} &= b^{(w)},\\ 
\kappa K c^{(T)} &= b^{(T)},
\end{align}
$$

where

<p>
$$
\begin{align*}
K_{i,j} &= (\nabla \basphi_j,\nabla \basphi_i),\\ 
b^{(w)} &= (b_0^{(w)},\ldots,b_{N}^{(w)}),\\ 
b^{(T)} &= (b_0^{(T)},\ldots,b_{N}^{(T)}),\\ 
c^{(w)} &= (c_0^{(w)},\ldots,c_{N}^{(w)}),\\ 
c^{(T)} &= (c_0^{(T)},\ldots,c_{N}^{(T)})\tp 
\end{align*}
$$


<p>

<ul>
 <p><li> First solve the system for \( c^{(w)} \)</li>
 <p><li> Then solve the system for \( c^{(T)} \)</li>
</ul>

<h4>Coupled linear systems  <a name="___sec157"></a></h4>

<p>

<ul>
 <p><li> Pretend two-way coupling, i.e., need to solve for \( w \) and \( T \) simultaneously</li>
 <p><li> Want to derive <em>one system</em> for \( c_j^{(w)} \) and \( c_j^{(T)} \), \( j=0,\ldots,N \)</li>
 <p><li> The system is nonlinear because of \( \nabla w\cdot\nabla w \)</li>
 <p><li> Linearization: pretend an iteration where \( \hat w \) is computed
   in the previous iteration and set \( \nabla w\cdot\nabla w
   \approx \nabla\hat w\cdot\nabla w \) (so the term becomes linear in \( w \))</li>
</ul>

$$
\begin{align}
\sum_{j=0}^N A^{(w,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^N A^{(w,T)}_{i,j} c^{(T)}_j
&= b_i^{(w)},\quad i=0,\ldots,N,
\tag{72}\\ 
\sum_{j=0}^N A^{(T,w)}_{i,j} c^{(w)}_j + \sum_{j=0}^N A^{(T,T)}_{i,j} c^{(T)}_j &= b_i^{(T)},\quad i=0,\ldots,N,
\tag{73}\\ 
A^{(w,w)}_{i,j} &= \mu(\nabla \basphi_j,\basphi_i),\\ 
A^{(w,T)}_{i,j} &= 0,\\ 
b_i^{(w)} &= (\beta, \basphi_i),\\ 
A^{(w,T)}_{i,j} &= \mu(\nabla w_{-}\cdot\nabla\basphi_j), \basphi_i),\\ 
A^{(T,T)}_{i,j} &= \kappa(\nabla \basphi_j,\basphi_i),\\ 
b_i^{(T)} &= 0
\tp 
\end{align}
$$


<p>
Alternative notation:

<p>
$$
\begin{align}
\mu K c^{(w)} &= b^{(w)},\\ 
L c^{(w)} + \kappa K c^{(T)} & =0,
\end{align}
$$

\( L \) is the matrix from the \( \nabla w_{-}\cdot\nabla \) operator:
\( L_{i,j} = A^{(w,T)}_{i,j} \).

<p>
Corresponding block form:

<p>
$$
\left(\begin{array}{cc}
\mu K & 0\\ 
L & \kappa K
\end{array}\right)
\left(\begin{array}{c}
c^{(w)}\\ 
c^{(T)}
\end{array}\right) =
\left(\begin{array}{c}
b^{(w)}\\ 
0
\end{array}\right)
\tp 
$$

<h3>Different function spaces for the unknowns  <a name="___sec158"></a></h3>

<p>

<ul>
 <p><li> Generalization: \( w\in V^{(w)} \) and \( T\in V^{(T)} \),
   \( V^{(w)} \neq V^{(T)} \)</li>
 <p><li> This is called a <em>mixed finite element method</em></li>
</ul>

$$
\begin{align*}
V^{(w)} &= \hbox{span}\{\basphi_0^{(w)},\ldots,\basphi_{N_w}^{(w)}\},\\ 
V^{(T)} &= \hbox{span}\{\basphi_0^{(T)},\ldots,\basphi_{N_T}^{(T)}\}
\tp 
\end{align*}
$$


<p>
$$
\begin{align}
\int_\Omega \mu \nabla w\cdot\nabla v^{(w)} \dx &= \int_\Omega \beta v^{(w)}\dx
\quad\forall v^{(w)}\in V^{(w)},
\tag{74}\\ 
\int_\Omega \kappa \nabla T\cdot\nabla v^{(T)} \dx &= \int_\Omega \mu
\nabla w\cdot\nabla w\, v^{(T)}\dx \quad\forall v^{(T)}\in V^{(T)}
\tag{75}
\tp 
\end{align}
$$


<p>
Take the inner product with \( \v = (v^{(w)}, v^{(T)}) \) and integrate:

<p>
$$
\begin{equation}
\int_\Omega (\mu\nabla w\cdot\nabla v^{(w)} +
\kappa\nabla T\cdot\nabla v^{(T)})\dx
= \int_\Omega (\beta v^{(w)} + \mu\nabla w\cdot\nabla w\, v^{(T)})\dx,
\tag{76}
\end{equation}
$$

valid \( \forall \v\in\V = V^{(w)}\times V^{(T)} \).

<p>
<!-- begin bottom navigation -->
<a href="._part0107_lecture_fem.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

