
# Information about all exercises in the file main_decay.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_decay.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['schemes_cooling.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:schemes',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Show in detail how we can apply the ideas of the Forward Euler,\nBackward Euler, Crank-Nicolson, and $\\theta$-rule\ndiscretizations to derive explicit\ncomputational formulas for new temperature values in Newton's law of\ncooling (see Section ref{decay:app:Newton:cooling}):\n\n!bt\n\\begin{equation}\n{dT\\over dt} = -k(T-T_s),\\quad T(0)=T_0\\ts\nlabel{decay:Newton:cooling}\n\\end{equation}\n\n!et\nHere, $T$ is the temperature of the body, $T_s$ is the temperature\nof the surroundings, $t$ is time, $k$ is the heat transfer\ncoefficient, and $T_0$ is the initial temperature of the body.\n\n# Can introduce $u=T-T_s$, or much better for illustration of the\n# thinking: operate directly on the T equation",
  'title': "Derive schemes for Newton's law of cooling",
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['cooling.py'],
  'heading': '=====',
  'hints': ['For verification, try to find an exact solution of the\ndiscrete equations. A trick is to introduce $u=T-T_s$, observe\nthat $u^{n}=(T_0-T_s)A^n$ for some amplification factor $A$,\nand then express this formula in terms of $T^n$.'],
  'keywords': None,
  'label': 'decay:app:exer:cooling:py',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Formulate a $\\theta$-rule for the three schemes in Exercise\nref{decay:app:exer:cooling:schemes} such that you can get the three\nschemes from a single formula by varying the $\\theta$ parameter.\nImplement the $\\theta$ scheme in a function `cooling(T0, k, T_s,\nt_end, dt, theta=0.5)`, where `T0` is the initial temperature, `k` is\nthe heat transfer coefficient, `T_s` is the temperature of the\nsurroundings, `t_end` is the end time of the simulation, `dt` is the\ntime step, and `theta` corresponds to $\\theta$.  The `cooling`\nfunction should return the temperature as an array `T` of values at\nthe mesh points and the time mesh `t`.  Construct verification\nexamples to check that the implementation works.',
  'title': "Implement schemes for Newton's law of cooling",
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['detective.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:murder',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': '# URL: "http://www.biology.arizona.edu/BioMath/tutorials/Applications/Cooling.html"\n\nA detective measures the temperature of a dead body to be\n26.7 C at 2 pm. One hour later\nthe temperature is 25.8 C. The question is when\ndeath occurred.\n\nAssume that Newton\'s law of cooling (ref{decay:Newton:cooling}) is an\nappropriate mathematical model for the evolution of the temperature in\nthe body.  First, determine $k$ in (ref{decay:Newton:cooling}) by\nformulating a Forward Euler approximation with one time steep from\ntime 2 am to time 3 am, where knowing the two temperatures allows for\nfinding $k$. Assume the temperature in the air to be 20 C. Thereafter,\nsimulate the temperature evolution from the time of murder, taken as\n$t=0$, when $T=37\\hbox{ C}$, until the temperature reaches 25.8 C. The\ncorresponding time allows for answering when death occurred.',
  'title': 'Find time of murder from body temperature',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['pyproblems.txt'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:intdiv',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Explain what happens in the following computations, where\nsome are mathematically unexpected:\n!bc ipy\n>>> dt = 3\n>>> T = 8\n>>> Nt = T/dt\n>>> Nt\n2\n>>> theta = 1; a = 1\n>>> (1 - (1-theta)*a*dt)/(1 + theta*dt*a)\n0\n\n!ec',
  'title': 'Experiment with integer division',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_v1_err.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay1err',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the `solver` function in the "`decay_v1.py`":\n"http://tinyurl.com/jvzzcfn/decay/decay_v1.py" file\nand the following call:\n!bc pycod\nu, t = solver(I=1, a=1, T=7, dt=2, theta=1)\n\n!ec\nThe output becomes\n!bc dat\nt= 0.000 u=1\nt= 2.000 u=0\nt= 4.000 u=0\nt= 6.000 u=0\n\n!ec\nPrint out the result of all intermediate computations and use\n`type(v)` to see the object type of the result stored in `v`.\nExamine the intermediate calculations and explain\nwhy `u` is wrong and why we compute up to $t=6$ only even though we\nspecified $T=7$.',
  'title': 'Experiment with wrong computations',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_plot_error.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:plot:error',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Solve the problem $u'=-au$, $u(0)=I$, using the Forward Euler, Backward\nEuler, and Crank-Nicolson schemes. For each scheme, plot the error function\n$e^n = \\uex(t_n)-u^n$ for $\\Delta t$, $\\frac{1}{4}\\Delta t$, and\n$\\frac{1}{8}\\Delta t$, where $\\uex$ is the exact solution of the ODE and\n$u^n$ is the numerical solution at mesh point $t_n$.",
  'title': 'Plot the error function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_compare_theta.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:plot:dtconst',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Make a program that imports the `solver` function from the\n`decay_mod` module and offers a function `compare(dt, I, a)` for\ncomparing, in a plot, the methods corresponding to $\\theta=0,0.5,1$\nand the exact solution.  This plot shows the accuracy of the methods\nfor a given time mesh. Read input data for the problem from the\ncommand line using appropriate functions in the `decay_mod` module\n(the `--dt` option for giving several time step values can be reused:\njust use the first time step value for the computations).',
  'title': 'Compare methods for a given time mesh',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_memsave_v2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:inexact:output',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The "`decay_memsave.py`":\n"http://tinyurl.com/jvzzcfn/decay/decay_memsave.py" program\nwrites the time values and solution values to a file which looks\nlike\n!bc\n0.0000000000000000E+00  1.0000000000000000E+00\n2.0000000000000001E-01  8.3333333333333337E-01\n4.0000000000000002E-01  6.9444444444444453E-01\n6.0000000000000009E-01  5.7870370370370383E-01\n8.0000000000000004E-01  4.8225308641975323E-01\n1.0000000000000000E+00  4.0187757201646102E-01\n1.2000000000000000E+00  3.3489797668038418E-01\n1.3999999999999999E+00  2.7908164723365347E-01\n\n!ec \nModify the file output such that it looks like\n!bc dat\n0.000  1.00000\n0.200  0.83333\n0.400  0.69444\n0.600  0.57870\n0.800  0.48225\n1.000  0.40188\n1.200  0.33490\n1.400  0.27908\n\n!ec\nRun the modified program\n!bc sys\nTerminal> python decay_memsave_v2.py --T 10 --theta 1 \\ \n          --dt 0.2 --makeplot\n\n!ec\nThe program just prints `Bug in the implementation!` and does not\nshow the plot. What went wrong?',
  'title': 'Change formatting of numbers and debug',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['doctest_roots.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:doctest1',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Type in the following program and equip the `roots` function with a doctest:\n\n!bc pypro\nimport sys\n# This sqrt(x) returns real if x>0 and complex if x<0\nfrom numpy.lib.scimath import sqrt\n\ndef roots(a, b, c):\n    """\n    Return the roots of the quadratic polynomial\n    p(x) = a*x**2 + b*x + c.\n\n    The roots are real or complex objects.\n    """\n    q = b**2 - 4*a*c\n    r1 = (-b + sqrt(q))/(2*a)\n    r2 = (-b - sqrt(q))/(2*a)\n    return r1, r2\n\na, b, c = [float(arg) for arg in sys.argv[1:]]\nprint roots(a, b, c)\n\n!ec\nMake sure to test both real and complex roots.\nWrite out numbers with 14 digits or less.',
  'title': 'Write a doctest',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['test_roots.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:nosetest1',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Make a nose test for the `roots` function in Problem ref{decay:exer:doctest1}.',
  'title': 'Write a nose test',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['q_module.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:module1',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Let\n!bt\n\\[ q(t) = \\frac{RAe^{at}}{R + A(e^{at} - 1)}\n\\thinspace .\n\\]\n\n!et\nMake a Python module `q_module` containing two functions `q(t)` and\n`dqdt(t)` for computing $q(t)$ and $q\'(t)$, respectively. Perform a\n`from numpy import *` in this module. Import `q` and `dqdt` in another\nfile using the "star import" construction `from q_module import\n*`. All objects available in this file is given by `dir()`. Print\n`dir()` and `len(dir())`.  Then change the import of `numpy` in\n`q_module.py` to `import numpy as np`. What is the effect of this\nimport on the number of objects in `dir()` in a file that does `from\nq_module import *`?\n\n#\\frac{du}{dt}=au\\left(1-\\frac{u}{R}\\right),\\quad u(0)=A,',
  'title': 'Make a module',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_class_exper.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay_class:exper',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We want to solve the exponential decay problem $u\'=-au$, $u(0)=I$,\nfor several $\\Delta t$ values and $\\theta=0,0.5,1$.\nFor each $\\Delta t$ value, we want to make a plot where the\nthree solutions corresponding to $\\theta=0,0.5,1$ appear along with\nthe exact solution.\nWrite a function `experiment` to accomplish this. The function should\nimport the classes `Problem`, `Solver`, and `Visualizer` from the\n"`decay_class`":\n"http://tinyurl.com/jvzzcfn/decay/decay_class.py"\nmodule and make use of these. A new command-line option `--dt_values`\nmust be added to allow the user to specify the $\\Delta t$ values on\nthe command line (the options `--dt` and `--theta` implemented\nby the `decay_class` module have then no effect\nwhen running the `experiment` function).\nNote that the classes in the `decay_class` module should *not* be\nmodified.',
  'title': 'Make use of a class implementation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_class2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay_class2',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the file "`decay_class.py`": "http://tinyurl.com/jvzzcfn/decay/decay_class.py"\nwhere the exponential decay problem $u\'=-au$, $u(0)=I$, is implemented\nvia the classes `Problem`, `Solver`, and `Visualizer`.\nExtend the classes to handle the more general problem\n!bt\n\\[ u\'(t) = -a(t)u(t) + b(t),\\quad u(0)=I,\\ t\\in (0,T],\\]\n\n!et\nusing the $\\theta$-rule for discretization.\n\nIn the case with arbitrary functions $a(t)$ and $b(t)$ the problem class\nis no longer guaranteed to provide an exact solution. Let\nthe `exact_solution` in class `Problem` return `None` if the exact\nsolution for the particular problem is not available. Modify classes\n`Solver` and `Visualizer` accordingly.\n\nAdd test functions `test_*()` for the nose testing tool in the module.\nAlso add a demo example where the environment suddenly changes\n(modeled as an abrupt change in the decay rate $a$):\n!bt\n\\[ a(t) =\\left\\lbrace\\begin{array}{ll}\n1, & 0\\leq t\\leq t_p,\\\\ \nk, & t> t_p,\\end{array}\\right.\n\\]\n\n!et\nwhere $t_p$ is the point of time the environment changes. Take $t_p=1$\nand make plots that illustrate the effect of having $k\\gg 1$ and $k\\ll 1$.',
  'title': 'Generalize a class implementation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_class3.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay_class3',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Solve Exercise ref{decay:exer:decay_class2} by utilizing the\nclass implementations in\n"`decay_class_oo.py`": "http://tinyurl.com/jvzzcfn/decay/decay_class_oo.py".',
  'title': 'Generalize an advanced class implementation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_plot_fd_exp_error.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:analysis:exer:fd:exp:plot',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "The purpose of this exercise is to visualize the accuracy of finite difference\napproximations of the derivative of a given function.\nFor any finite difference approximation, take the Forward Euler difference\nas an example, and any specific function, take  $u=e^{-at}$,\nwe may introduce an error fraction\nspecific\n!bt\n\\[ E = \\frac{[D_t^+ u]^n}{u'(t_n)} = \\frac{\\exp{(-a(t_n+\\Delta t))} - \\exp{(-at_n)}}{-a\\exp{(-at_n)}} = -\\frac{1}{a\\Delta t}\\left(\\exp{(-a\\Delta t)}  - 1\\right),\n\\]\n\n!et\nand view $E$ as a function of $\\Delta t$. We expect that\n$\\lim_{\\Delta t\\rightarrow 0}E=1$, while $E$ may deviate significantly from\nunit for large $\\Delta t$. How the error depends on $\\Delta t$ is best\nvisualized in a graph where we use a logarithmic scale on for $\\Delta t$,\nso we can cover many orders of magnitude of that quantity. Here is\na code segment creating an array of 100 intervals, on the logarithmic\nscale, ranging from $10^{-6}$ to $1$ and then plotting $E$ versus\n$p=a\\Delta t$ with logarithmic scale on the $\\Delta t$ axis:\n\n!bc pycod\nfrom numpy import logspace, exp\nfrom matplotlib.pyplot import plot\np = logspace(-6, 1, 101)\ny = -(exp(-p)-1)/p\nsemilog(p, y)\n\n!ec\nIllustrate such errors for the finite difference operators $[D_t^+u]^n$\n(forward), $[D_t^-u]^n$ (backward), and $[D_t u]^n$ (centered).\n\nPerform a Taylor series expansions of the error fractions and find\nthe leading order $r$ in the expressions of type\n$1 + C\\Delta t^r + \\Oof{\\Delta t^{r+1}}$, where $C$ is some constant.",
  'title': 'Visualize the accuracy of finite differences $u=e^{-at}$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:analysis:exer:growth',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': ['growth_exper.py'],
             'hints': ['Modify the `decay_exper1.py` code to suit your needs.'],
             'solution': '',
             'text': 'Run experiments with $\\theta$ and $\\Delta t$ to uncover numerical\nartifacts (the exact solution is a monotone, growing function).\nUse the insight to design a set of experiments that aims to\ndemonstrate all types of numerical artifacts for different choices\nof $\\Delta t$ while $a$ is fixed.'},
            {'answer': '',
             'file': ['growth_exper.pdf', 'growth_exper.html'],
             'hints': ['Use examples from Section ref{decay:exper:report} to\nsee how scientific reports can be written.'],
             'solution': '',
             'text': 'Write a scientific report about the findings.'},
            {'answer': '',
             'file': ['growth_ampf.py'],
             'hints': ['Modify the "`decay_ampf_plot.py`": "http://tinyurl.com/jvzzcfn/decay/decay_ampf_plot.py" code.'],
             'solution': '',
             'text': 'Plot the amplification factors for the various schemes together with\nthe exact one for $a<0$ and use the plot to explain the observations\nmade in the experiments.'}],
  'text': "This exercise asks you to solve the ODE $u'=-au$ with $a<0$\nsuch that the ODE models\nexponential growth instead of exponential decay.\nA central theme is to investigate numerical artifacts and non-physical\nsolution behavior.",
  'title': 'Explore the $\\theta$-rule for exponential growth',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['test_precision.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:precision',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'It is claimed in Section ref{decay:MMS} that most numerical methods will\nreproduce a linear exact solution to machine precision. Test this\nassertion using the nose test function `test_linear_solution` in the\n"`decay_vc.py`": "http://tinyurl.com/jvzzcfn/decay/decay_vc.py" program.\nVary the parameter `c` from very small, via `c=1` to many larger values,\nand print out the maximum difference between the numerical solution\nand the exact solution. What is the relevant value of the `places`\n(or `delta`) argument to `nose.tools.assert_almost_equal` in each\ncase?',
  'title': 'Experiment with precision in tests and the size of $u$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_backward2step.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:bw2',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the 2-step backward method (ref{decay:fd2:bw:2step}) for the\nmodel $u'(t) = -a(t)u(t) + b(t)$, $u(0)=I$.  Allow the first step to\nbe computed by either the Backward Euler scheme or the Crank-Nicolson\nscheme. Verify the implementation by choosing $a(t)$ and $b(t)$ such\nthat the exact solution is linear in $t$ (see Section\nref{decay:MMS}). Show mathematically that a linear solution is indeed a\nsolution of the discrete equations.\n\nCompute convergence rates (see Section ref{decay:convergence:rate}) in\na test case $a=\\hbox{const}$ and $b=0$, where we easily have an exact\nsolution, and determine if the choice of a first-order scheme\n(Backward Euler) for the first step has any impact on the overall\naccuracy of this scheme. The expected error goes like $\\Oof{\\Delta t^2}$.",
  'title': 'Implement the 2-step backward scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_AdamsBashforth2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:AB2',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the 2nd-order Adams-Bashforth method (ref{decay:fd2:AB2})\nfor the decay problem $u'=-a(t)u + b(t)$, $u(0)=I$, $t\\in (0, T]$.\nUse the Forward Euler method for the first step such that the overall\nscheme is explicit. Verify the implementation using an exact\nsolution that is linear in time.\nAnalyze the scheme by searching for solutions $u^n=A^n$ when $a=\\hbox{const}$\nand $b=0$. Compare this second-order secheme to the Crank-Nicolson scheme.",
  'title': 'Implement the 2nd-order Adams-Bashforth scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_AdamsBashforth3.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:AB3',
  'no': 17,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the 3rd-order Adams-Bashforth method (ref{decay:fd2:AB3})\nfor the decay problem $u'=-a(t)u + b(t)$, $u(0)=I$, $t\\in (0, T]$.\nSince the scheme is explicit, allow it to be started by two steps with\nthe Forward Euler method.  Investigate experimentally the case where\n$b=0$ and $a$ is a constant: Can we have oscillatory solutions for\nlarge $\\Delta t$?",
  'title': 'Implement the 3rd-order Adams-Bashforth scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_RK2_Taylor2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:RK2:Taylor:analysis',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Show that the schemes (ref{decay:fd2:RK2:s2}) and\n(ref{decay:fd2:Taylor2}) are identical in the case $f(u,t)=-a$, where\n$a>0$ is a constant. Assume that the numerical solution reads\n$u^n=A^n$ for some unknown amplification factor $A$ to be determined.\nFind $A$ and derive stability criteria. Can the scheme produce\noscillatory solutions of $u'=-au$? Plot the numerical and exact\namplification factor.",
  'title': 'Analyze explicit 2nd-order methods',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_leapfrog.py', 'decay_leapfrog.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:leapfrog1',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement the Leapfrog scheme for the model equation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show mathematically that a linear solution in $t$ fulfills the\nForward Euler scheme for the first step and the Leapfrog scheme\nfor the subsequent steps. Use this linear solution to verify\nthe implementation, and automate the verification through a nose test.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "Create a manufactured solution $u(t)=\\sin(t)$ for the ODE\n$u'=-au+b$.\nCompute the convergence rate of the Leapfrog scheme using this\nmanufactured solution. The expected convergence rate of the\nLeapfrog scheme is $\\Oof{\\Delta t^2}$. Does the use of a\n1st-order method for the first step impact the convergence rate?"},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up a set of experiments to demonstrate that the Leapfrog scheme\n(ref{decay:fd2:leapfrog}) is associated with numerical artifacts\n(instabilities). Document the main results from this investigation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Analyze and explain the\ninstabilities of the Leapfrog scheme (ref{decay:fd2:leapfrog}):\n\n * Choose $a=\\mbox{const}$ and $b=0$.\n * Assume that an exact solution of the discrete equations has\n   the form $u^n=A^n$, where $A$ is an amplification factor to\n   be determined.\n * Compute $A$ either by and or with the aid of `sympy`.\n   The polynomial for $A$ has two roots, $A_1$ and $A_2$. We let\n   $u^n$ be a linear combination $u^n=C_1A_1^n + C_2A_2^n$.\n * Show that one of the roots is the explanation of the instability.\n * Determine $C_1$ and $C_2$ and compare $A$ with the exact\n   expression, using a Taylor series approximation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Since the original Leapfrog scheme\nis unconditionally unstable\nas time grows, it demands some stabilization.\nThis can be done by filtering, where we first find $u^{n+1}$\nfrom the original Leapfrog scheme and then replace $u^{n+1}$\nby the average $\\gamma (u^{n-1} - 2u^n + u^{n+1}$, where $\\gamma$\ncan be taken as 0.6.\nImplement the filtered Leapfrog\nscheme and check that it can handle tests where the original\nLeapfrog scheme is unstable.'}],
  'text': "A Leapfrog scheme\nfor the ODE $u'(t) = -a(t)u(t) + b(t)$ is defined by\n\n!bt\n\\[ \\brack D_{2t}u = -au+b\\rbrack^n\\ts\\]\n\n!et\nA separate scheme is needed to compute $u^1$, and the Forward Euler\nscheme is a candidate.\n\n\n\n\n#A possible test case is\n#$u'=-au + b$, $u(0)=0$, where $\\uex(t)=b/a + (I - b/a)e^{-at}$ if\n#$a$ and $b$ are constants.",
  'title': 'Implement and investigate the Leapfrog scheme',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_schemes_oo.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:uni',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Consider the linear ODE problem $u'(t)=-a(t)u(t) + b(t)$, $u(0)=I$.\nExplicit schemes for this problem can be written in the general form\n!bt\n\\begin{equation}\nu^{n+1} = \\sum_{j=0}^m c_ju^{n-j},\nlabel{decay:analysis:exer:sumcj}\n\\end{equation}\n\n!et\nfor some choice of $c_0,\\ldots,c_m$.\nFind expressions for the $c_j$ coefficients in case of the\n$\\theta$-rule, the three-level backward scheme,\nthe Leapfrog scheme, the 2nd-order Runge-Kutta method,\nand the 3rd-order Adams-Bashforth scheme.\n\nMake a class `ExpDecay` that implements the\ngeneral updating formula (ref{decay:analysis:exer:sumcj}).\nThe formula cannot be applied for $n<m$, and for those $n$ values, other\nschemes must be used. Assume for simplicity that we just\nrepeat Crank-Nicolson steps until (ref{decay:analysis:exer:sumcj}) can be used.\nUse a subclass\nto specify the list $c_0,\\ldots,c_m$ for a particular method, and\nimplement subclasses for all the mentioned schemes.\nVerify the implementation by testing with a linear solution, which should\nbe exactly reproduced by all methods.",
  'title': 'Make a unified implementation of many schemes',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['osc_cooling.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:osc',
  'no': 19,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "The surrounding temperature $T_s$ in Newton's law of cooling\n(ref{decay:Newton:cooling}) may vary in time. Assume that the\nvariations are periodic with period $P$ and amplitude $a$ around\na constant mean temperature $T_m$:\n!bt\n\\begin{equation}\nT_s(t) = T_m + a\\sin\\left(\\frac{2\\pi}{P}t\\right)\n\\thinspace .\n\\end{equation}\n\n!et\nSimulate a process with the following data: $k=20 \\hbox{ min}^{-1}$,\n$T(0)=5$ C, $T_m=25$ C, $a=2.5$ C, and $P=1$ h. Also experiment with\n$P=10$ min and $P=3$ h. Plot $T$ and $T_s$ in the same plot.",
  'title': 'Simulate an oscillating cooling process',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['carbon14.py'],
  'heading': '=====',
  'hints': ['Use simulations with $5,730\\pm 40$ y as input\nand find the corresponding interval for the result.'],
  'keywords': None,
  'label': 'decay:app:exer:radio:C14',
  'no': 20,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The "Carbon-14": "http://en.wikipedia.org/wiki/Carbon-14" isotope,\nwhose radioactive decay is used extensively in dating organic material\nthat is tens of thousands of years old, has a half-life of $5,730$\nyears.  Determine the age of an organic material that contains 8.4 percent\nof its initial amount of Carbon-14.  Use a time unit of 1 year in the\ncomputations.  The uncertainty in the half time of Carbon-14 is $\\pm\n40$ years.  What is the corresponding uncertainty in the estimate of\nthe age?',
  'title': 'Radioactive decay of Carbon-14',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['stochastic_decay.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:stoch:nuclear',
  'no': 21,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to implement the stochastic model\ndescribed in Section ref{decay:app:nuclear} and show that its\nmean behavior approximates the solution of the corresponding\nODE model.\n\nThe simulation goes on for a time interval $[0,T]$ divided into\n$N_t$ intervals of length $\\Delta t$. We start with $N_0$\natoms. In some time interval, we have $N$ atoms that have survived.\nSimulate $N$ Bernoulli trials with probability $\\lambda\\Delta t$\nin this interval by drawing $N$ random numbers, each being 0 (survival)\nor 1 (decay), where the probability of getting 1 is $\\lambda\\Delta t$.\nWe are interested in the number of decays, $d$, and the number of\nsurvived atoms in the next interval is then $N-d$.\nThe Bernoulli trials\nare simulated by drawing $N$ uniformly distributed real numbers on\n$[0,1]$ and saying that 1 corresponds to a value less than $\\lambda\\Delta t$:\n\n!bc pycod\n# Given lambda_, dt, N\nimport numpy as np\nuniform = np.random.uniform(N)\nBernoulli_trials = np.asarray(uniform < lambda_*dt, dtype=np.int)\nd = Bernoulli_trials.size\n\n!ec\nObserve that `uniform < lambda_*dt` is a boolean array whose true\nand false values become 1 and 0, respectively, when converted to an\ninteger array.\n\nRepeat the simulation over $[0,T]$ a large number of times, compute the average\nvalue of $N$ in each interval, and compare with the solution of\nthe corresponding ODE model.',
  'title': 'Simulate stochastic radioactive decay',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['radioactive_decay_2subst.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:radio:twosubst',
  'no': 22,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Consider two radioactive substances A and B. The nuclei in substance A\ndecay to form nuclei of type B with a half-life $A_{1/2}$, while\nsubstance B decay to form type A nuclei with a half-life $B_{1/2}$.\nLetting $u_A$ and $u_B$ be the fractions of the initial amount of\nmaterial in substance A and B, respectively, the following system of\nODEs governs the evolution of $u_A(t)$ and $u_B(t)$:\n!bt\n\\begin{equation}\n\\frac{1}{\\ln 2} u_A' = u_B/B_{1/2} - u_A/A_{1/2},\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{1}{\\ln 2} u_B' = u_A/A_{1/2} - u_B/B_{1/2},\n\\end{equation}\n\n!et\nwith $u_A(0)=u_B(0)=1$.\n\nMake a simulation program that solves for $u_A(t)$ and $u_B(t)$.\nVerify the implementation by computing analytically\nthe limiting values of\n$u_A$ and $u_B$ as $t\\rightarrow \\infty$ (assume $u_A',u_B'\\rightarrow 0$)\nand comparing these with those obtained numerically.\n\nRun the program for the case of $A_{1/2}=10$ minutes and $B_{1/2}=50$ minutes.\nUse a time unit of 1 minute. Plot $u_A$ and $u_B$ versus time in the same\nplot.",
  'title': 'Radioactive decay of two substances',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['atmospheric_pressure.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:atm1',
  'no': 23,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the models for atmospheric pressure in\nSection ref{decay:app:atm}.\nMake a program with three functions,\n\n * one computing the pressure $p(z)$ using a seven-layer model\n   and varying $L$,\n * one computing $p(z)$ using a seven-layer model,\n   but with constant temperature in each layer, and\n * one computing $p(z)$ based on the\n   one-layer model.\n\nHow can these implementations be verified? Should ease of verification\nimpact how you code the functions?\nCompare the three models in a plot.',
  'title': 'Simulate the pressure drop in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vertical_motion.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:prog',
  'no': 24,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the Stokes' drag model (ref{decay:app:fallingbody:model:S})\nand the quadratic drag model (ref{decay:app:fallingbody:model:q}) from\nSection ref{decay:app:drag}, using the Crank-Nicolson\nscheme and a geometric mean for $|v|v$ as explained, and assume\nconstant fluid density.\nAt each time level, compute the Reynolds number\nRe and choose the Stokes' drag model if $\\hbox{Re} < 1$ and the\nquadratic drag model otherwise.\n\nThe computation of the numerical solution should take place either in\na stand-alone function (as in Section ref{decay:py1}) or in a solver class\nthat looks up a problem class for physical data (as in Section\nref{decay:prog:se:class}). Create a module (see Section\nref{decay:prog:se:module}) and equip it with nose tests (see Section\nref{decay:prog:se:nose}) for automatically verifying the code.\n\nVerification tests can be based on\n\n * the terminal velocity (see Section ref{decay:app:drag}),\n * the exact solution when $\\varrho = 0$ (see Section ref{decay:app:drag}),\n * the method of manufactured solutions (see Section ref{decay:MMS})\n   combined with computing\n   convergence rates (see Section ref{decay:convergence:rate}).\n\nUse, e.g., a quadratic polynomial for the velocity in the method of\nmanufactured solutions. The expected error is $\\Oof{\\Delta t^2}$\nfrom the centered finite difference approximation and the geometric\nmean for $|v|v$.\n\nA solution that is linear in $t$ will also be an exact solution of the\ndiscrete equations in many problems.  Show that this is true for\nlinear drag (by adding a source term that is linear in $t$), but not\nfor quadratic drag because of the geometric mean approximation.  Use\nthe method of manufactured solutions to add a source term *in the\ndiscrete equations for quadratic drag* such that a linear function of\n$t$ is a solution. Add a nose test for checking that the linear\nfunction is reproduced to machine precision in the case of both linear\nand quadratic drag.\n\nApply the software to a case involving a ball rising in water.  The\nbuoyancy force is here the driving force, but the drag will be\nsignificant and balance the other forces after some time.  A soccer\nball has radius 11 cm and mass 0.43 kg.  Start the motion from rest, set\nthe density of water to $1000\\hbox{ kg/m}^3$, and use a drag\ncoefficient for a ball: 0.45. Plot the velocity of the rising ball.",
  'title': 'Make a program for vertical motion in a fluid',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['skydiving.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:parachute',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up the differential equation problem that governs the velocity\nof the motion.\nThe parachute jumper is subject to the gravity force and a quadratic\ndrag force. Assume constant density.\nAdd an extra source term be used for program verification.\nIdentify the input data to the problem.'},
            {'answer': '',
             'file': None,
             'hints': ['Use the Crank-Nicolson scheme with a geometric average of $|v|v$ in time to\nlinearize the equation of motion with quadratic drag.',
                       'You can either use functions or classes for implementation.\nIf you choose functions, make a function\n`solver` that takes all the input data in the problem as\narguments and that returns the velocity (as a mesh function) and\nthe time mesh. In case of a class-based implementation, introduce\na problem class with the physical data\nand a solver class with the numerical data and a `solve` method\nthat stores the velocity and the mesh in the class.'],
             'solution': '',
             'text': 'Make a Python module for computing the velocity of the motion.\nAlso equip the module with functionality for plotting the velocity.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that a linear function of $t$ does not fulfill the discrete\nequations because of the geometric mean used for the quadratic drag\nterm.  Fit a source term, as in the method of manufactured solutions,\nsuch that a linear function of $t$ is a solution of the discrete\nequations. Make a nose test to check that this solution is reproduced\nto machine precision.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The expected error in this problem goes like $\\Delta t^2$ because we\nuse a centered finite difference approximation with error $\\Oof{\\Delta t^2}$\nand a geometric mean approximation with error $\\Oof{\\Delta t^2}$.\nUse the method of manufactured solutions combined with computing\nconvergence rate to verify the code. Make a nose test for checking\nthat the convergence rate is correct.'},
            {'answer': '',
             'file': None,
             'hints': ['You can either make a function `forces(v, t, plot=None)`\nthat returns the forces (as mesh functions) and `t` and shows\na plot on the screen and also saves the plot to a file with name `plot`\nif `plot` is not `None`, or you can extend the solver class with\ncomputation of forces and include plotting of forces in the\nvisualization class.'],
             'solution': '',
             'text': 'Compute the drag force, the gravity\nforce, and the buoyancy force as a function of time. Create\na plot with these three forces.'},
            {'answer': '',
             'file': None,
             'hints': ['Meade and Struthers cite{parachute_1999} provide some data relevant\nto "skydiving": "http://en.wikipedia.org/wiki/Parachuting".\nThe mass of the human body and equipment\ncan be set to $100$ kg.\nA skydiver in spread-eagle formation has a cross-section of 0.5 $\\hbox{m}^2$\nin the horizontal plane.\nThe density of air decreases varies altitude, but can be taken\nas constant, 1 $\\hbox{kg/m}^3$, for altitudes relevant to\nskydiving (0-4000 m).\nThe drag coefficient for a man in upright position can be set to 1.2.\nStart with a zero velocity.\nA free fall typically has a terminating velocity of 45 m/s. (This value\ncan be used to tune other parameters.)'],
             'solution': '',
             'text': 'Compute the velocity of\na skydiver in free fall before the parachute opens.'},
            {'answer': '',
             'file': None,
             'hints': ['Following Meade and Struthers cite{parachute_1999}, one can set the\ncross-section area perpendicular to the motion to 44 $\\hbox{m}^2$\nwhen the parachute is open. The drag coefficient for an open\nparachute can be taken as 1.8, but tuned using the known value\nof the typical terminating velocity reached before landing:\n5.3 m/s. The parachute is released after 10 s.'],
             'solution': '',
             'text': 'The next task is to simulate\na parachute jumper during free fall and after the parachute opens.\nAt the time the parachute opens, the drag coefficient and the cross-sectional\narea change dramatically.\nGeneralize the solver function to a new function `solver_parachute` where\nthe drag coefficient and the cross-sectional area have different\nvalues before and after time $t_p$ when the parachute is released.\n\nUse the program to simulate a jump from $z=3000$ m to the ground $z=0$.'}],
  'text': 'The aim of this project is to develop a general solver for the\nvertical motion of a body with quadratic air drag, verify the solver,\napply the solver to a skydiver in free fall, and finally apply the\nsolver to a complete parachute jump.\n\nAll the pieces of software implemented in this project\nshould be realized as Python functions and/or classes and collected\nin one module.',
  'title': 'Simulate parachuting',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['falling_in_variable_density.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:atm1',
  'no': 25,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Vertical motion of a body in the atmosphere needs to take into\naccount a varying air density if the range of altitudes is\nmany kilometers. In this case, $\\varrho$ varies with the altitude $z$.\nThe equation of motion for the body is given in\nSection ref{decay:app:drag}. Let us assume quadratic drag force\n(otherwise the body has to be very, very small).\nA differential equation problem for the air density, based on\nthe information for the one-layer atmospheric model in\nSection ref{decay:app:atm}, can be set up as\n\n!bt\n\\begin{equation}\np'(z) = -\\frac{Mg}{R^*(T_0+Lz)} p,\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\varrho = p \\frac{M}{R^*T}\n\\thinspace .\n\\end{equation}\n\n!et\nTo evaluate $p(z)$ we need the altitude $z$. From the principle that the\nvelocity is the derivative of the position we have that\n\n!bt\n\\begin{equation}\nz'(t) = v(t),\n\\end{equation}\n\n!et\nwhere $v$ is the velocity of the body.\n\nExplain in detail how the governing equations can be discretized\nby the Forward Euler and the Crank-Nicolson methods.",
  'title': 'Formulate vertical motion in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['falling_in_variable_density.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:atm2',
  'no': 26,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the Forward Euler or the Crank-Nicolson scheme\nderived in Exercise ref{decay:app:exer:drag:atm1}.\nDemonstrate the effect of air density variation on a falling\nhuman, e.g., the famous fall of "Felix Baumgartner": "http://en.wikipedia.org/wiki/Felix_Baumgartner". The drag coefficient can be set to 1.2.\n\n__Remark.__\nIn the Crank-Nicolson scheme one must solve a $3\\times 3$ system of\nequations at each time level, since $p$, $\\varrho$, and $v$ are\ncoupled, while each equation can be stepped forward at a time with the\nForward Euler scheme.',
  'title': 'Simulate vertical motion in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['signum.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:signum',
  'no': 27,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Consider the ODE problem\n!bt\n\\[\ny'(x) = \\left\\lbrace\\begin{array}{ll}\n-1, & x < 0,\\\\ \n1, & x \\geq 0\n\\end{array}\\right.\\quad x\\in (-1, 1],\n\\quad y(1-)=1,\n\\]\n\n!et\nwhich has the solution $y(x)=|x|$.\nUsing a mesh $x_0=-1$, $x_1=0$, and $x_2=1$, calculate by hand\n$y_1$ and $y_2$ from the Forward Euler, Backward Euler, Crank-Nicolson,\nand Leapfrog methods. Use all of the former three methods for computing\nthe $y_1$ value to be used in the Leapfrog calculation of $y_2$.\nThereafter, visualize how these schemes perform for a uniformly partitioned\nmesh with $N=10$ and $N=11$ points.",
  'title': 'Compute $y=|x|$ by solving an ODE',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['random_interest.py'],
  'heading': '=====',
  'hints': ['The following code snippet computes $p^{n+1}$:\n129 <<<!!CODE_BLOCK  pycod',
            'If $u_i(t)$ is the value of the fortune in experiment number $i$,\n$i=0,\\ldots,N-1$,\nthe mean evolution of the fortune is\n227 <<<!!MATH_BLOCK\nand the standard deviation is\n228 <<<!!MATH_BLOCK\nSuppose $u_i(t)$ is stored in an array `u`.\nThe mean and the standard deviation of the fortune\nis most efficiently computed by\nusing two accumulation arrays, `sum_u` and `sum_u2`, and\nperforming `sum_u += u` and `sum_u2 += u**2` after every experiment.\nThis technique avoids storing all the $u_i(t)$ time series for\ncomputing the statistics.'],
  'keywords': None,
  'label': 'decay:app:exer:interest',
  'no': 28,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The goal of this exercise is to compute the value of a fortune subject\nto inflation and a random interest rate.\nSuppose that the inflation is constant at $i$ percent per year and that the\nannual interest rate, $p$, changes randomly at each time step,\nstarting at some value $p_0$ at $t=0$.\nThe random change is from a value $p^n$ at $t=t_n$ to\n$p_n +\\Delta p$ with probability 0.25 and $p_n -\\Delta p$ with probability 0.25.\nNo change occurs with probability 0.5. There is also no change if\n$p^{n+1}$ exceeds 15 or becomes below 1.\nUse a time step of one month, $p_0=i$, initial fortune scaled to 1,\nand simulate 1000 scenarios of\nlength 20 years. Compute the mean evolution of one unit of money and the\ncorresponding\nstandard deviation. Plot the mean curve along with the mean plus one\nstandard deviation and the mean minus one standard deviation. This will\nillustrate the uncertainty in the mean curve.',
  'title': 'Simulate growth of a fortune with random interest rate',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:pop:at',
  'no': 29,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': ['population_drop.py'],
             'hints': [],
             'solution': '',
             'text': 'Assume that there is a sudden drop (increase) in the birth (death)\nrate at time $t=t_r$,\nbecause of limited nutrition or food supply:\n!bt\n\\[ a(t) =\\left\\lbrace\\begin{array}{ll}\nr_0, & t< t_r,\\\\ \nr_0 - A, & t\\geq t_r,\\end{array}\\right.\n\\]\n\n!et\nThis drop in population growth is compensated by a sudden net immigration\nat time $t_f>t_r$:\n!bt\n\\[ f(t) =\\left\\lbrace\\begin{array}{ll}\n0, & t< t_f,\\\\ \nf_0, & t\\geq t_a,\\end{array}\\right.\n\\]\n\n!et\nStart with $r_0$ and make $A>r_0$. Experiment with\nthese and other parameters to\nillustrate the interplay of growth and decay in such a problem.'},
            {'answer': '',
             'file': ['population_osc.py'],
             'hints': [],
             'solution': '',
             'text': 'Now we assume that the environmental conditions changes periodically with\ntime so that we may take\n!bt\n\\[ r(t) = r_0 + A\\sin\\left(\\frac{2\\pi}{P}t\\right)\n\\thinspace .\n\\]\n\n!et\nThat is, the combined birth and death rate oscillates around $r_0$ with\na maximum change of $\\pm A$ repeating over a period of length $P$ in time.\nSet $f=0$ and experiment with the other parameters to illustrate typical\nfeatures of the solution.'}],
  'text': 'We shall study a population modeled by (ref{decay:app:pop:ueq}) where\nthe environment, represented by $r$ and $f$, undergoes changes with time.',
  'title': 'Simulate a population in a changing environment',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['logistic_CN.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:pop:logistic1',
  'no': 30,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Solve the logistic ODE\n(ref{decay:app:pop:logistic}) using a Crank-Nicolson scheme where\n$(u^{n+1/2})^2$ is approximated by a *geometric mean*:\n!bt\n\\[ (u^{n+1/2})^2 \\approx u^{n+1}u^n\n\\thinspace .\n\\]\n\n!et\nThis trick makes the discrete equation linear in $u^{n+1}$.',
  'title': 'Simulate logistic growth',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['interest_modeling.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:interest:derive',
  'no': 31,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The ODE model (ref{decay:app:interest:eq2}) was derived under the assumption\nthat $r$ was constant. Perform an alternative derivation without\nthis assumption: 1) start with (ref{decay:app:interest:eq1});\n2) introduce a time step $\\Delta t$ instead of $m$: $\\Delta t = 1/m$ if\n$t$ is measured in years; 3) divide by $\\Delta t$ and take the\nlimit $\\Delta t\\rightarrow 0$. Simulate a case where the inflation is\nat a constant level $I$ percent per year and the interest rate oscillates:\n$r=-I/2 + r_0\\sin(2\\pi t)$.\nCompare solutions for $r_0=I, 3I/2, 2I$.',
  'title': 'Rederive the equation for continuous compound interest',
  'type': 'Exercise',
  'type_visible': True}]