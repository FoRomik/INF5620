<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study Guide: Finite difference methods for wave motion">
<meta name="keywords" content="waves on a string,wave equation 1D,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,unit testing,software testing nose,vectorization,scalar code,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,stencil Neumann boundary,index set notation,wave equation 2D, implementation,Cython,C extension module,wrapper code,Fortran subroutine,row-major ordering,column-major ordering,Fortran array storage,C/Python array storage,wave equation 1D, analytical properties,wave equation 1D, exact numerical solution,stability criterion,wave equation 1D, stability">



<style type="text/css">
    /* solarized style */
    body {
      margin:5;
      padding:0;
      border:0;	/* Remove the border around the viewport in old versions of IE */
      width:100%;
      background: #fdf6e3;
      min-width:600px;	/* Minimum width of layout - remove if not required */
      font-family: Verdana, Helvetica, Arial, sans-serif;
      font-size: 1.0em;
      line-height: 1.3em;
      color: #657b83;
    }
    a { color: #657b83; text-decoration:none; }
    a:hover { color: #b58900; background: #eee8d5; text-decoration:none; }
    h1, h2, h3 { margin:.8em 0 .2em 0; padding:0; line-height: 125%; }
    h2 { font-variant: small-caps; }
    pre {
      background: #fdf6e3;
      -webkit-box-shadow: inset 0 0 2px #000000;
      -moz-box-shadow: inset 0 0 2px #000000;
      box-shadow: inset 0 0 2px #000000;
      color: #586e75;
      margin-left: 0px;
      font-family: 'Droid Sans Mono', monospace;
      padding: 2px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      -moz-background-clip: padding;
      -webkit-background-clip: padding-box;
      background-clip: padding-box;
    }
    tt { font-family: "Courier New", Courier; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p { text-indent: 0px; }
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #FFBF00;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #fbeed5;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods for waves on a string ',
               1,
               'wave:string',
               'wave:string'),
              (' The complete initial-boundary value problem ',
               2,
               None,
               '___sec1'),
              (' Input data in the problem ', 2, None, '___sec2'),
              (' Demo of a vibrating string ($C=0.8$) ', 2, None, '___sec3'),
              (' Demo of a vibrating string ($C=1.0012$) ',
               2,
               None,
               '___sec4'),
              (' Step 1: Discretizing the domain ',
               2,
               'wave:string:mesh',
               'wave:string:mesh'),
              (' The discrete solution ',
               2,
               'wave:string:numerical:sol',
               'wave:string:numerical:sol'),
              (' Step 2: Fulfilling the equation at the mesh points ',
               2,
               'wave:string:samplingPDE',
               'wave:string:samplingPDE'),
              (' Step 3: Replacing derivatives by finite differences ',
               2,
               'wave:string:fd',
               'wave:string:fd'),
              (' Step 3: Algebraic version of the PDE ', 2, None, '___sec9'),
              (' Step 3: Algebraic version of the initial conditions ',
               2,
               None,
               '___sec10'),
              (' Step 4: Formulating a recursive algorithm ',
               2,
               'wave:string:alg',
               'wave:string:alg'),
              (' The Courant number ', 2, None, '___sec12'),
              (' The finite difference stencil ', 2, None, '___sec13'),
              (' The stencil for the first time level ', 2, None, '___sec14'),
              (' The algorithm ', 2, None, '___sec15'),
              (' Moving finite difference stencil ', 2, None, '___sec16'),
              (' Sketch of an implementation (1) ',
               2,
               'wave:string:impl',
               'wave:string:impl'),
              (' PDE solvers should save memory ', 2, None, '___sec18'),
              (' Sketch of an implementation (2) ', 2, None, '___sec19'),
              (' Verification ', 1, None, '___sec20'),
              (' A slightly generalized model problem ',
               2,
               'wave:pde2:fd',
               'wave:pde2:fd'),
              (' Discrete model for the generalized model problem ',
               2,
               None,
               '___sec22'),
              (' Modified equation for the first time level ',
               2,
               None,
               '___sec23'),
              (' Using an analytical solution of physical significance ',
               2,
               None,
               '___sec24'),
              (' Manufactured solution: principles ', 2, None, '___sec25'),
              (' Manufactured solution: example ', 2, None, '___sec26'),
              (' Testing a manufactured solution ', 2, None, '___sec27'),
              (' Constructing an exact solution of the discrete equations ',
               2,
               None,
               '___sec28'),
              (' Analytical work with the PDE problem ', 2, None, '___sec29'),
              (' Analytical work with the discrete equations (1) ',
               2,
               None,
               '___sec30'),
              (' Analytical work with the discrete equations (1) ',
               2,
               None,
               '___sec31'),
              (' Testing with the exact discrete solution ',
               2,
               None,
               '___sec32'),
              (' Implementation ', 1, 'wave:pde1:impl', 'wave:pde1:impl'),
              (' The algorithm ', 2, None, '___sec34'),
              (' What do to with the solution? ', 2, None, '___sec35'),
              (' Making a solver function ', 2, None, '___sec36'),
              (' Verification: exact quadratic solution ',
               2,
               None,
               '___sec37'),
              (' Visualization: animating $u(x,t)$ ', 2, None, '___sec38'),
              (' Making movie files ', 2, None, '___sec39'),
              (' Running a case ',
               2,
               'wave:pde1:guitar:data',
               'wave:pde1:guitar:data'),
              (' Implementation of the case ', 2, None, '___sec41'),
              (' Resulting movie for $C=0.8$ ', 2, None, '___sec42'),
              (' The benefits of scaling ', 2, None, '___sec43'),
              (' Vectorization ',
               1,
               'wave:pde1:impl:vec',
               'wave:pde1:impl:vec'),
              (' Operations on slices of arrays ', 2, None, '___sec45'),
              (' Test the understanding ', 2, None, '___sec46'),
              (' Vectorization of finite difference schemes (1) ',
               2,
               None,
               '___sec47'),
              (' Vectorization of finite difference schemes (2) ',
               2,
               None,
               '___sec48'),
              (' Vectorized implementation in the solver function ',
               2,
               None,
               '___sec49'),
              (' Verification of the vectorized version ',
               2,
               None,
               '___sec50'),
              (' Efficiency measurements ', 2, None, '___sec51'),
              (' Generalization: reflecting boundaries ',
               1,
               None,
               '___sec52'),
              (' Neumann boundary condition ',
               2,
               'wave:pde2:Neumann',
               'wave:pde2:Neumann'),
              (' Discretization of derivatives at the boundary (1) ',
               2,
               'wave:pde2:Neumann:discr',
               'wave:pde2:Neumann:discr'),
              (' Discretization of derivatives at the boundary (2) ',
               2,
               None,
               '___sec55'),
              (' Visualization of modified boundary stencil ',
               2,
               None,
               '___sec56'),
              (' Implementation of Neumann conditions ',
               2,
               'wave:pde2:Neumann:impl',
               'wave:pde2:Neumann:impl'),
              (' Index set notation ', 2, 'wave:indexset', 'wave:indexset'),
              (' Index set notation in code ', 2, None, '___sec59'),
              (' Index sets in action (1) ', 2, None, '___sec60'),
              (' Index sets in action (2) ', 2, None, '___sec61'),
              (' Alternative implementation via ghost cells ',
               2,
               'wave:pde1:Neumann:ghost',
               'wave:pde1:Neumann:ghost'),
              (' Implementation of ghost cells (1) ', 2, None, '___sec63'),
              (' Implementation of ghost cells (2) ', 2, None, '___sec64'),
              (' Generalization: variable wave velocity ',
               1,
               'wave:pde2:var:c',
               'wave:pde2:var:c'),
              (' The model PDE with a variable coefficient ',
               2,
               None,
               '___sec66'),
              (' Discretizing the variable coefficient (1) ',
               2,
               'wave:pde2:var:c:ideas',
               'wave:pde2:var:c:ideas'),
              (' Discretizing the variable coefficient (2) ',
               2,
               None,
               '___sec68'),
              (' Discretizing the variable coefficient (3) ',
               2,
               None,
               '___sec69'),
              (' Computing the coefficient between mesh points ',
               2,
               'wave:pde2:var:c:means',
               'wave:pde2:var:c:means'),
              (' Discretization of variable-coefficient wave equation in operator notation ',
               2,
               None,
               '___sec71'),
              (' Neumann condition and a variable coefficient ',
               2,
               'wave:pde2:var:c:Neumann',
               'wave:pde2:var:c:Neumann'),
              (' Implementation of variable coefficients ',
               2,
               'wave:pde2:var:c:impl',
               'wave:pde2:var:c:impl'),
              (' A more general model PDE with variable coefficients ',
               2,
               None,
               '___sec74'),
              (' Generalization: damping ', 2, None, '___sec75'),
              (' Building a general 1D wave equation solver ',
               1,
               'wave:pde2:software',
               'wave:pde2:software'),
              (' Collection of initial conditions ', 2, None, '___sec77'),
              (' Finite difference methods for 2D and 3D wave equations ',
               1,
               'wave:2D3D',
               'wave:2D3D'),
              (' Examples on wave equations written out in 2D/3D ',
               2,
               'wave:2D3D:models',
               'wave:2D3D:models'),
              (' Boundary and initial conditions ', 2, None, '___sec80'),
              (' Example: 2D propagation of Gaussian function ',
               2,
               None,
               '___sec81'),
              (' Mesh ', 2, 'wave:2D3D:mesh', 'wave:2D3D:mesh'),
              (' Discretization ', 2, 'wave:2D3D:models', 'wave:2D3D:models'),
              (' Special stencil for the first time step ',
               2,
               None,
               '___sec84'),
              (' Variable coefficients (1) ', 2, None, '___sec85'),
              (' Variable coefficients (2) ', 2, None, '___sec86'),
              (' Neumann boundary condition in 2D ', 2, None, '___sec87'),
              (' Implementation of 2D/3D problems ',
               1,
               'wave:2D3D:impl',
               'wave:2D3D:impl'),
              (' Algorithm ', 2, None, '___sec89'),
              (' Scalar computations: mesh ',
               2,
               'wave2D3D:impl:scalar',
               'wave2D3D:impl:scalar'),
              (' Scalar computations: arrays ', 2, None, '___sec91'),
              (' Scalar computations: initial condition ',
               2,
               None,
               '___sec92'),
              (' Scalar computations: primary stencil ', 2, None, '___sec93'),
              (' Vectorized computations: mesh coordinates ',
               2,
               'wave2D3D:impl:vectorized',
               'wave2D3D:impl:vectorized'),
              (' Vectorized computations: stencil ', 2, None, '___sec95'),
              (' Verification: quadratic solution (1) ',
               2,
               'wave2D3D:impl:verify',
               'wave2D3D:impl:verify'),
              (' Verification: quadratic solution (2) ', 2, None, '___sec97'),
              (' Migrating loops to Cython ',
               1,
               'wave2D3D:impl:Cython',
               'wave2D3D:impl:Cython'),
              (' Declaring variables and annotating the code ',
               2,
               None,
               '___sec99'),
              (' Cython version of the functions ', 2, None, '___sec100'),
              (' Visual inspection of the C translation ',
               2,
               None,
               '___sec101'),
              (' Building the extension module ', 2, None, '___sec102'),
              (' Calling the Cython function from Python ',
               2,
               None,
               '___sec103'),
              (' Migrating loops to Fortran ', 1, None, '___sec104'),
              (' The Fortran subroutine ', 2, None, '___sec105'),
              (' Building the Fortran module with f2py ',
               2,
               None,
               '___sec106'),
              (' How to avoid array copying ', 2, None, '___sec107'),
              (' Efficiency of translating to Fortran ',
               2,
               None,
               '___sec108'),
              (' Migrating loops to C via Cython ', 1, None, '___sec109'),
              (' The C code ', 2, None, '___sec110'),
              (' The Cython interface file ', 2, None, '___sec111'),
              (' Building the extension module ', 2, None, '___sec112'),
              (' Migrating loops to C via f2py ', 1, None, '___sec113'),
              (' The C code and the Fortran interface file ',
               2,
               None,
               '___sec114'),
              (' Building the extension module ', 2, None, '___sec115'),
              (' Migrating loops to C++ via f2py ', 2, None, '___sec116'),
              (' Analysis of the difference equations ',
               1,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Properties of the solution of the wave equation ',
               2,
               'wave:pde1:properties',
               'wave:pde1:properties'),
              (' Demo of the splitting of $I(x)$ into two waves ',
               2,
               None,
               '___sec119'),
              (' Representation of waves as sum of sine/cosine waves ',
               2,
               None,
               '___sec120'),
              (' Analysis of the finite difference scheme ',
               2,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Preliminary results ', 2, None, '___sec122'),
              (' Numerical wave propagation (1) ', 2, None, '___sec123'),
              (' Numerical wave propagation (2) ', 2, None, '___sec124'),
              (' Numerical wave propagation (3) ', 2, None, '___sec125'),
              (' Why $C\\leq 1$ is a stability criterion ',
               2,
               None,
               '___sec126'),
              (' Numerical dispersion relation ', 2, None, '___sec127'),
              (' The special case $C=1$ ', 2, None, '___sec128'),
              (' Computing the error in wave velocity ',
               2,
               None,
               '___sec129'),
              (' Visualizing the error in wave velocity ',
               2,
               None,
               '___sec130'),
              (' Taylor expanding the error in wave velocity ',
               2,
               None,
               '___sec131'),
              (' Example on effect of wrong wave velocity (1) ',
               2,
               None,
               '___sec132'),
              (' Example on effect of wrong wave velocity (1) ',
               2,
               None,
               '___sec133'),
              (' Extending the analysis to 2D (and 3D) ',
               2,
               'wave:pde1:analysis:2D3D',
               'wave:pde1:analysis:2D3D'),
              (' Discrete wave components in 2D ', 2, None, '___sec135'),
              (' Stability criterion in 2D ', 2, None, '___sec136'),
              (' Stability criterion in 3D ', 2, None, '___sec137'),
              (' Numerical dispersion relation in 2D (1) ',
               2,
               None,
               '___sec138'),
              (' Numerical dispersion relation in 2D (2) ',
               2,
               None,
               '___sec139'),
              (' Numerical dispersion relation in 2D (3) ',
               2,
               None,
               '___sec140')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\If}{\mathcal{I}}     % for FEM
\newcommand{\Ifd}{\mathcal{I}_d}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- ------------------- main content ---------------------- -->


<title>Study Guide: Finite difference methods for wave motion</title>

<center><h1>Study Guide: Finite difference methods for wave motion</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Oct 5, 2013</h4></center> <!-- date -->
<p>
<!-- !split -->

<h2>Table of contents</h2>

<p>
<a href="#wave:string"> Finite difference methods for waves on a string </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> The complete initial-boundary value problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Input data in the problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> Demo of a vibrating string (\( C=0.8 \)) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Demo of a vibrating string (\( C=1.0012 \)) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:string:mesh"> Step 1: Discretizing the domain </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:string:numerical:sol"> The discrete solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:string:samplingPDE"> Step 2: Fulfilling the equation at the mesh points </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:string:fd"> Step 3: Replacing derivatives by finite differences </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> Step 3: Algebraic version of the PDE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> Step 3: Algebraic version of the initial conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:string:alg"> Step 4: Formulating a recursive algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> The Courant number </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> The finite difference stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> The stencil for the first time level </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec15"> The algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> Moving finite difference stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:string:impl"> Sketch of an implementation (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> PDE solvers should save memory </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Sketch of an implementation (2) </a><br>
<a href="#___sec20"> Verification </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde2:fd"> A slightly generalized model problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> Discrete model for the generalized model problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> Modified equation for the first time level </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Using an analytical solution of physical significance </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Manufactured solution: principles </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> Manufactured solution: example </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Testing a manufactured solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec28"> Constructing an exact solution of the discrete equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> Analytical work with the PDE problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> Analytical work with the discrete equations (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec31"> Analytical work with the discrete equations (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec32"> Testing with the exact discrete solution </a><br>
<a href="#wave:pde1:impl"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> The algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec35"> What do to with the solution? </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec36"> Making a solver function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec37"> Verification: exact quadratic solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec38"> Visualization: animating \( u(x,t) \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec39"> Making movie files </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde1:guitar:data"> Running a case </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Implementation of the case </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> Resulting movie for \( C=0.8 \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec43"> The benefits of scaling </a><br>
<a href="#wave:pde1:impl:vec"> Vectorization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec45"> Operations on slices of arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> Test the understanding </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> Vectorization of finite difference schemes (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Vectorization of finite difference schemes (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> Vectorized implementation in the solver function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Verification of the vectorized version </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec51"> Efficiency measurements </a><br>
<a href="#___sec52"> Generalization: reflecting boundaries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde2:Neumann"> Neumann boundary condition </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde2:Neumann:discr"> Discretization of derivatives at the boundary (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec55"> Discretization of derivatives at the boundary (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec56"> Visualization of modified boundary stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde2:Neumann:impl"> Implementation of Neumann conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:indexset"> Index set notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec59"> Index set notation in code </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec60"> Index sets in action (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec61"> Index sets in action (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde1:Neumann:ghost"> Alternative implementation via ghost cells </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec63"> Implementation of ghost cells (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec64"> Implementation of ghost cells (2) </a><br>
<a href="#wave:pde2:var:c"> Generalization: variable wave velocity </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec66"> The model PDE with a variable coefficient </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde2:var:c:ideas"> Discretizing the variable coefficient (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec68"> Discretizing the variable coefficient (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec69"> Discretizing the variable coefficient (3) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde2:var:c:means"> Computing the coefficient between mesh points </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec71"> Discretization of variable-coefficient wave equation in operator notation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde2:var:c:Neumann"> Neumann condition and a variable coefficient </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde2:var:c:impl"> Implementation of variable coefficients </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec74"> A more general model PDE with variable coefficients </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec75"> Generalization: damping </a><br>
<a href="#wave:pde2:software"> Building a general 1D wave equation solver </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec77"> Collection of initial conditions </a><br>
<a href="#wave:2D3D"> Finite difference methods for 2D and 3D wave equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:2D3D:models"> Examples on wave equations written out in 2D/3D </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec80"> Boundary and initial conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec81"> Example: 2D propagation of Gaussian function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:2D3D:mesh"> Mesh </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:2D3D:models"> Discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec84"> Special stencil for the first time step </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec85"> Variable coefficients (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec86"> Variable coefficients (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec87"> Neumann boundary condition in 2D </a><br>
<a href="#wave:2D3D:impl"> Implementation of 2D/3D problems </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec89"> Algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave2D3D:impl:scalar"> Scalar computations: mesh </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec91"> Scalar computations: arrays </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec92"> Scalar computations: initial condition </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec93"> Scalar computations: primary stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave2D3D:impl:vectorized"> Vectorized computations: mesh coordinates </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec95"> Vectorized computations: stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave2D3D:impl:verify"> Verification: quadratic solution (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec97"> Verification: quadratic solution (2) </a><br>
<a href="#wave2D3D:impl:Cython"> Migrating loops to Cython </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec99"> Declaring variables and annotating the code </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec100"> Cython version of the functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec101"> Visual inspection of the C translation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec102"> Building the extension module </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec103"> Calling the Cython function from Python </a><br>
<a href="#___sec104"> Migrating loops to Fortran </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec105"> The Fortran subroutine </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec106"> Building the Fortran module with f2py </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec107"> How to avoid array copying </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec108"> Efficiency of translating to Fortran </a><br>
<a href="#___sec109"> Migrating loops to C via Cython </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec110"> The C code </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec111"> The Cython interface file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec112"> Building the extension module </a><br>
<a href="#___sec113"> Migrating loops to C via f2py </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec114"> The C code and the Fortran interface file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec115"> Building the extension module </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec116"> Migrating loops to C++ via f2py </a><br>
<a href="#wave:pde1:analysis"> Analysis of the difference equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde1:properties"> Properties of the solution of the wave equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec119"> Demo of the splitting of \( I(x) \) into two waves </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec120"> Representation of waves as sum of sine/cosine waves </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde1:analysis"> Analysis of the finite difference scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec122"> Preliminary results </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec123"> Numerical wave propagation (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec124"> Numerical wave propagation (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec125"> Numerical wave propagation (3) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec126"> Why \( C\leq 1 \) is a stability criterion </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec127"> Numerical dispersion relation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec128"> The special case \( C=1 \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec129"> Computing the error in wave velocity </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec130"> Visualizing the error in wave velocity </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec131"> Taylor expanding the error in wave velocity </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec132"> Example on effect of wrong wave velocity (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec133"> Example on effect of wrong wave velocity (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#wave:pde1:analysis:2D3D"> Extending the analysis to 2D (and 3D) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec135"> Discrete wave components in 2D </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec136"> Stability criterion in 2D </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec137"> Stability criterion in 3D </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec138"> Numerical dispersion relation in 2D (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec139"> Numerical dispersion relation in 2D (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec140"> Numerical dispersion relation in 2D (3) </a><br>

<p>
<!-- !split -->

<h2>Finite difference methods for waves on a string <a name="wave:string"></a></h2>

<p>
Waves on a string can be modeled by the <em>wave equation</em>

<p>
$$ \frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2} $$


<p>
\( u(x,t) \) is the displacement of the string

<p>
<a href="http://phet.colorado.edu/sims/wave-on-a-string/wave-on-a-string_en.html">Demo of waves on a string</a>.

<p>
<!-- !split -->

<h3>The complete initial-boundary value problem  <a name="___sec1"></a></h3>

<p>
$$
\begin{align}
\frac{\partial^2 u}{\partial t^2} &=
c^2 \frac{\partial^2 u}{\partial x^2}, \quad &x\in (0,L),\ t\in (0,T]
\label{wave:pde1}\\ 
u(x,0) &= I(x), \quad &x\in [0,L]
\label{wave:pde1:ic:u}\\ 
\frac{\partial}{\partial t}u(x,0) &= 0, \quad &x\in [0,L]
\label{wave:pde1:ic:ut}\\ 
u(0,t) & = 0, \quad  &t\in (0,T]
\label{wave:pde1:bc:0}\\ 
u(L,t) & = 0, \quad  &t\in (0,T]
\label{wave:pde1:bc:L}
\end{align}
$$


<p>
<!-- !split -->

<h3>Input data in the problem  <a name="___sec2"></a></h3>

<p>

<ul>
 <p><li> Initial condition \( u(x,0)=I(x) \): initial string shape</li>
 <p><li> Initial condition \( u_t(x,0)=0 \): string starts from rest</li>
 <p><li> \( c=\sqrt{T/\varrho} \): velocity of waves on the string</li>
 <p><li> (\( T \) is the tension in the string, \( \varrho \) is density of the string)</li>
 <p><li> Two boundary conditions on \( u \): \( u=0 \) means fixed ends (no displacement)</li>
</ul>

Rule for number of initial and boundary conditions:

<p>

<ul>
 <p><li> \( u_{tt} \) in the PDE: two initial conditions, on \( u \) and \( u_t \)</li>
 <p><li> \( u_{t} \) (and no \( u_{tt} \)) in the PDE: one initial conditions, on \( u \)</li>
 <p><li> \( u_{xx} \) in the PDE: one boundary condition on \( u \) at each boundary point</li>
</ul>

<!-- !split -->

<h3>Demo of a vibrating string (\( C=0.8 \))  <a name="___sec3"></a></h3>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
<source src='mov-wave/guitar_C0.8/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/guitar_C0.8/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>

<ul>
 <p><li> Our numerical method is sometimes exact (!)</li>
 <p><li> Our numerical method is sometimes subject to serious
   non-physical effects</li>
</ul>

<!-- !split -->

<h3>Demo of a vibrating string (\( C=1.0012 \))  <a name="___sec4"></a></h3>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
<source src='mov-wave/guitar_C1.0012/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/guitar_C1.0012/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
Ooops!

<p>
<!-- !split -->

<h3>Step 1: Discretizing the domain <a name="wave:string:mesh"></a></h3>

<p>
Mesh in time:

<p>
$$
\begin{equation}
0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T \tp  \end{equation}
$$


<p>
Mesh in space:

<p>
$$
\begin{equation}
0 = x_0 < x_1 < x_2 < \cdots < x_{N_x-1} < x_{N_x} = L \tp  \end{equation}
$$


<p>
Uniform mesh with constant mesh spacings \( \Delta t \) and \( \Delta x \):

<p>
$$
\begin{equation}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
t_i = n\Delta t,\ n=0,\ldots,N_t\tp
\end{equation}
$$


<p>
<!-- !split -->

<h3>The discrete solution <a name="wave:string:numerical:sol"></a></h3>

<p>

<ul>
 <p><li> The numerical solution is a mesh function: \( u_i^n \approx \uex(x_i,t_n) \)</li>
 <p><li> Finite difference stencil (or scheme): equation for \( u^n_i \) involving
   neighboring space-time points</li>
</ul>

<center><p><img src="mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/wave_PDE_Dirichlet_n_interior.png" align="bottom" width=500></p></center>

<p>
<!-- !split -->

<h3>Step 2: Fulfilling the equation at the mesh points <a name="wave:string:samplingPDE"></a></h3>

<p>
Let the PDE be satisfied at all <em>interior</em> mesh points:

<p>
$$
\begin{equation}
\frac{\partial^2}{\partial t^2} u(x_i, t_n) =
c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),
\label{wave:pde1:step2}
\end{equation}
$$

for \( i=1,\ldots,N_x-1 \) and \( n=1,\ldots,N_t-1 \).

<p>
For \( n=0 \) we have the initial conditions \( u=I(x) \) and \( u_t=0 \),
and at the boundaries \( i=0,N_x \) we have the boundary condition \( u=0 \).

<p>
<!-- !split -->

<h3>Step 3: Replacing derivatives by finite differences <a name="wave:string:fd"></a></h3>

<p>
Widely used finite difference formula for
the second-order derivative:

<p>
$$ \frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}= [D_tD_t u]^n_i$$


<p>
and

<p>
$$ \frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
$$


<p>
<!-- !split -->

<h3>Step 3: Algebraic version of the PDE  <a name="___sec9"></a></h3>

<p>
Replace derivatives by differences:

<p>
$$
\begin{equation}
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},
\label{wave:pde1:step3b}
\end{equation}
$$


<p>
In operator notation:

<p>
$$
\begin{equation}
[D_tD_t u = c^2 D_xD_x]^{n}_i
\tp 
\label{wave:pde1:step3a}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Step 3: Algebraic version of the initial conditions  <a name="___sec10"></a></h3>

<p>

<ul>
 <p><li> Need to replace the derivative in the initial condition
   \( u_t(x,0)=0 \) by a finite difference approximation</li>
 <p><li> The differences for \( u_{tt} \) and \( u_{xx} \) have second-order accuracy</li>
 <p><li> Use a centered difference for \( u_t(x,0) \)</li>
</ul>

$$ [D_{2t} u]^n_i = 0,\quad n=0\quad\Rightarrow\quad
u^{n-1}_i=u^{n+1}_i,\quad i=0,\ldots,N_x$$


<p>
The other initial condition \( u(x,0)=I(x) \) can be computed by

<p>
$$ u_i^0 = I(x_i),\quad i=0,\ldots,N_x$$


<p>
<!-- !split -->

<h3>Step 4: Formulating a recursive algorithm <a name="wave:string:alg"></a></h3>

<p>

<ul>
 <p><li> Nature of the algorithm: compute \( u \) in space at \( t=\Delta t, 2\Delta t, 3\Delta t,... \)</li>
 <p><li> Three time levels are involved in the general discrete equation:
   \( n+1 \), \( n \), \( n-1 \)</li>
 <p><li> \( u^n_i \) and \( u^{n-1}_i \) are then already computed for \( i=0,\ldots,N_x \),
   and \( u^{n+1}_i \) is the unknown quantity</li>
</ul>

Write out \( [D_tD_t u = c^2 D_xD_x]^{n}_i \)
and solve for \( u^{n+1}_i \),

<p>
$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right)
\label{wave:pde1:step4}
\end{equation}
$$


<p>
<!-- !split -->

<h3>The Courant number  <a name="___sec12"></a></h3>

<p>
$$
\begin{equation}
C = c\frac{\Delta t}{\Delta x},
\end{equation}
$$

is known as the (dimensionless) <em>Courant number</em>

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Notice.</b>
There is only one parameter, \( C \), in the discrete model:
\( C \) lumps mesh parameters with the wave velocity \( c \).
The value \( C \) and the smoothness of \( I(x) \)
govern the quality of the numerical solution.
</div>
<p>
<!-- !split -->

<h3>The finite difference stencil  <a name="___sec13"></a></h3>

<p>
<center><p><img src="mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/wave_PDE_Dirichlet_n_interior.png" align="bottom" width=500></p></center>

<p>
<!-- !split -->

<h3>The stencil for the first time level  <a name="___sec14"></a></h3>

<p>

<ul>
 <p><li> Problem: the stencil for \( n=1 \) involves \( u^{-1}_i \), but time
   \( t=-\Delta t \) is outside the mesh</li>
 <p><li> Remedy: use the initial condition \( u_t=0 \) together with the
   stencil to eliminate \( u^{-1}_i \)</li>
</ul>

Initial condition:

<p>
$$ [D_{2t}u=0]^0_i\quad\Rightarrow\quad u^{-1}_i=u^1_i$$


<p>
Insert in stencil \( [D_tD_tu = c^2D_xD_x]^0_i \) to get

<p>
$$
\begin{equation}
u_i^1 = u^0_i - \half
C^2\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right)
\tp 
\label{wave:pde1:step4:1}
\end{equation}
$$


<p>
<!-- !split -->

<h3>The algorithm  <a name="___sec15"></a></h3>

<p>

<ol>
<p><li> Compute \( u^0_i=I(x_i) \) for \( i=0,\ldots,N_x \)</li>
<p><li> Compute \( u^1_i \) by \eqref{wave:pde1:step4:1} and set \( u_i^1=0 \)
   for the boundary points \( i=0 \) and \( i=N_x \), for \( n=1,2,\ldots,N-1 \),</li>
<p><li> For each time level \( n=1,2,\ldots,N_t-1 \)</li>

<ol>
  <p><li> apply \eqref{wave:pde1:step4} to find \( u^{n+1}_i \) for \( i=1,\ldots,N_x-1 \)</li>
  <p><li> set \( u^{n+1}_i=0 \) for the boundary points \( i=0 \), \( i=N_x \).</li>
</ol>

</ol>

<!-- !split -->

<h3>Moving finite difference stencil  <a name="___sec16"></a></h3>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
<source src='mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/index.html">web page</a>
or a <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.flv">movie file</a>.

<p>
<!-- !split -->

<h3>Sketch of an implementation (1) <a name="wave:string:impl"></a></h3>

<p>

<ul>
 <p><li> Arrays:</li>

<ul>
   <p><li> <code>u[i]</code> stores \( u^{n+1}_i \)</li>
   <p><li> <code>u_1[i]</code> stores \( u^n_i \)</li>
   <p><li> <code>u_2[i]</code> stores \( u^{n-1}_i \)</li>
</ul>

</ul>

<div class="alert alert-block alert-notice alert-text-normal"><b>Naming convention.</b>
<code>u</code> is the unknown to be computed (a spatial mesh
function), <code>u_k</code> is the computed spatial mesh function <code>k</code>
time steps back in time.
</div>
<p>
<!-- !split -->

<h3>PDE solvers should save memory  <a name="___sec18"></a></h3>

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Important to minimize the memory usage.</b>
The algorithm only needs to access the
<em>three most recent time levels</em>, so we need only three arrays for
\( u_i^{n+1} \), \( u_i^n \), and \( u_i^{n-1} \), \( i=0,\ldots,N_x \).
Storing all the solutions in a two-dimensional array of
size \( (N_x+1)\times (N_t+1) \)
would be possible in this simple one-dimensional PDE problem, but not
in large 2D problems and not even in small 3D problems.
</div>
<p>
<!-- !split -->

<h3>Sketch of an implementation (2)  <a name="___sec19"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Given mesh points as arrays x and t (x[i], t[n])</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
C = c*dt/dx            <span style="color: #228B22"># Courant number</span>
Nt = <span style="color: #658b00">len</span>(t)-<span style="color: #B452CD">1</span>
C2 = C**<span style="color: #B452CD">2</span>              <span style="color: #228B22"># Help variable in the scheme</span>

<span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #228B22"># Apply special formula for first step, incorporating du/dt=0</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = u_1[i] - <span style="color: #B452CD">0.5</span>*C**<span style="color: #B452CD">2</span>(u_1[i+<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i-<span style="color: #B452CD">1</span>])
u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>   <span style="color: #228B22"># Enforce boundary conditions</span>

<span style="color: #228B22"># Switch variables before next step</span>
u_2[:], u_1[:] = u_1, u

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
    <span style="color: #228B22"># Update all inner mesh points at time t[n+1]</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = <span style="color: #B452CD">2</span>u_1[i] - u_2[i] - \ 
               C**<span style="color: #B452CD">2</span>(u_1[i+<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i-<span style="color: #B452CD">1</span>])

    <span style="color: #228B22"># Insert boundary conditions</span>
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #228B22"># Switch variables before next step</span>
    u_2[:], u_1[:] = u_1, u
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h2>Verification  <a name="___sec20"></a></h2>

<p>

<ul>
 <p><li> Think about testing and verification before you start implementing
   the algorithm!</li>
 <p><li> Powerful testing tool: method of manufactured solutions and
   computation of convergence rates</li>
 <p><li> Will need a source term in the PDE and \( u_t(x,0)\neq 0 \)</li>
 <p><li> Even more powerful method: exact solution of the scheme</li>
</ul>

<!-- !split -->

<h3>A slightly generalized model problem <a name="wave:pde2:fd"></a></h3>

<p>
Add source term \( f \) and nonzero initial condition \( u_t(x,0) \):

<p>
$$
\begin{align}
u_{tt} &= c^2 u_{xx} + f(x,t),
\label{wave:pde2}\\ 
u(x,0) &= I(x), \quad &x\in [0,L]
\label{wave:pde2:ic:u}\\ 
u_t(x,0) &= V(x), \quad &x\in [0,L]
\label{wave:pde2:ic:ut}\\ 
u(0,t) & = 0, \quad & t>0,
\label{wave:pde2:bc:0}\\ 
u(L,t) & = 0, \quad  &t>0\tp
\label{wave:pde2:bc:L}
\end{align}
$$


<p>
<!-- !split -->

<h3>Discrete model for the generalized model problem  <a name="___sec22"></a></h3>

<p>
$$
\begin{equation}
[D_tD_t u = c^2 D_xD_x + f]^{n}_i
\tp 
\label{wave:pde2:fdop}
\end{equation}
$$


<p>
Writing out and solving for the unknown \( u^{n+1}_i \):

<p>
$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i
\label{wave:pde2:step3b}
\tp 
\end{equation}
$$


<p>
<!-- !split -->

<h3>Modified equation for the first time level  <a name="___sec23"></a></h3>

<p>
Centered difference for \( u_t(x,0) = V(x) \):

<p>
$$ [D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,$$


<p>
Inserting this in the stencil \eqref{wave:pde2:step3b} for \( n=0 \) leads to

<p>
$$
\begin{equation}
u^{1}_i = u^0_i - \Delta t V_i + \frac{1}{2}
C^2
\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \frac{1}{2}\Delta t^2 f^n_i
\label{wave:pde2:step3c}
\tp 
\end{equation}
$$


<p>
<!-- !split -->

<h3>Using an analytical solution of physical significance  <a name="___sec24"></a></h3>

<p>

<ul>
 <p><li> Standing waves occur in real life on a string</li>
 <p><li> Can be analyzed mathematically (known exact solution)</li>
</ul>

$$
\begin{equation}
\uex(x,y,t)) = A\sin\left(\frac{\pi}{L}x\right)
\cos\left(\frac{\pi}{L}ct\right)\tp
\label{wave:pde2:test:ue}
\end{equation}
$$


<p>

<ul>
 <p><li> PDE data: \( f=0 \), boundary conditions
   \( \uex(0,t)=\uex(L,0)=0 \), initial
   conditions \( I(x)=A\sin\left(\frac{\pi}{L}x\right) \) and \( V=0 \)</li>
 <p><li> Note: \( u_i^{n+1}\neq\uex(x_i,t_{n+1} \), and we do not know
   the error, so testing must aim at reproducing the expected
   convergence rates</li>
</ul>

<!-- !split -->

<h3>Manufactured solution: principles  <a name="___sec25"></a></h3>

<p>

<ul>
 <p><li> Disadvantage with the previous physical solution:
   it does not test \( V\neq 0 \) and \( f\neq 0 \)</li>
 <p><li> Method of manufactured solution:</li>

<ul>
   <p><li> Choose some \( \uex(x,t) \)</li>
   <p><li> Insert in PDE and fit \( f \)</li>
   <p><li> Set boundary and initial conditions compatible with the chosen \( \uex(x,t) \)</li>
</ul>

</ul>

<!-- !split -->

<h3>Manufactured solution: example  <a name="___sec26"></a></h3>

<p>
$$ \uex(x,t) = x(L-x)\sin t\tp$$


<p>
PDE \( u_{tt}=c^2u_{xx}+f \):

<p>
$$ -x(L-x)\sin t = -2\sin t + f\quad\Rightarrow f = (2 - x(L-x))\sin t\tp$$


<p>
Initial conditions become

<p>
$$
\begin{align*}
u(x,0) &= I(x) = 0,\\ 
u_t(x,0) &= V(x) = (2 - x(L-x))\cos t\tp
\end{align*}
$$


<p>
Boundary conditions:

<p>
$$ u(x,0) = u(x,L) = 0\tp $$


<p>
<!-- !split -->

<h3>Testing a manufactured solution  <a name="___sec27"></a></h3>

<p>

<ul>
 <p><li> Introduce common mesh parameter: \( h=\Delta t \), \( \Delta x =ch/C \)</li>
 <p><li> This \( h \) keeps \( C \) and \( \Delta t/\Delta x \) constant</li>
 <p><li> Select coarse mesh \( h \): \( h_0 \)</li>
 <p><li> Run experiments with \( h_i=2^{-i}h_0 \) (halving the cell size), \( i=0,\ldots,m \)</li>
 <p><li> Record the error \( E_i \) and \( h_i \) in each experiment</li>
 <p><li> Compute pariwise convergence rates \( r_i=
   \ln E_{i+1}/E_{i}/\ln h_{i+1}/h_{i} \)</li>
 <p><li> Verification: \( r_i\rightarrow 2 \) as \( i \) increases</li>
</ul>

<!-- !split -->

<h3>Constructing an exact solution of the discrete equations  <a name="___sec28"></a></h3>

<p>

<ul>
 <p><li> Manufactured solution with computation of
   convergence rates: much manual work</li>
 <p><li> Simpler and more powerful: use an exact solution for \( u^{n}_i \)</li>
 <p><li> A linear or quadratic \( \uex \) in \( x \) and \( t \) is often a good candidate</li>
</ul>

<!-- !split -->

<h3>Analytical work with the PDE problem  <a name="___sec29"></a></h3>

<p>
Here, choose \( \uex \) such that \( \uex(x,0)=\uex(L,0)=0 \):

<p>
$$ \uex (x,t) = x(L-x)(1+\frac{1}{2}t), $$


<p>
Insert in the PDE and find \( f \):

<p>
$$ f(x,t)=2(1+t)c^2\tp$$


<p>
Initial conditions:

<p>
$$ I(x) = x(L-x),\quad V(x)=\frac{1}{2}x(L-x)\tp $$


<p>
<!-- !split -->

<h3>Analytical work with the discrete equations (1)  <a name="___sec30"></a></h3>

<p>
We want to show that \( \uex \) also solves the discrete equations!

<p>
Useful preliminary result:
$$
\begin{align}
\lbrack D_tD_t t^2\rbrack^n &= \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
= (n+1)^2 -n^2 + (n-1)^2 = 2,\\ 
\lbrack D_tD_t t\rbrack^n &= \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
= \frac{((n+1) -n + (n-1))\Delta t}{\Delta t^2} = 0
\tp 
\end{align}
$$


<p>
Hence,
$$ [D_tD_t \uex]^n_i = x_i(L-x_i)[D_tD_t (1+\frac{1}{2}t)]^n =
x_i(L-x_i)\frac{1}{2}[D_tD_t t]^n = 0\tp$$


<p>
<!-- !split -->

<h3>Analytical work with the discrete equations (1)  <a name="___sec31"></a></h3>

<p>
$$
\begin{align*}
\lbrack D_xD_x \uex\rbrack^n_i &=
(1+\frac{1}{2}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i =
(1+\frac{1}{2}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\ 
&= -2(1+\frac{1}{2}t_n)
\tp 
\end{align*}
$$


<p>
Now, \( f^n_i = 2(1+\frac{1}{2}t_n)c^2 \) and we get

<p>
$$ [D_tD_t \uex - c^2D_xD_x\uex - f]^n_i = 0 - c^2(-1)2(1 + \frac{1}{2}t_n
+ 2(1+\frac{1}{2}t_n)c^2 = 0\tp$$


<p>
Moreover, \( \uex(x_i,0)=I(x_i) \),
\( \partial \uex/\partial t = V(x_i) \) at \( t=0 \), and
\( \uex(x_0,t)=\uex(x_{N_x},0)=0 \). Also the modified scheme for the
first time step is fulfilled by \( \uex(x_i,t_n) \).

<p>
<!-- !split -->

<h3>Testing with the exact discrete solution  <a name="___sec32"></a></h3>

<p>

<ul>
 <p><li> We have established that \( u^{n+1}_i = \uex(x_i,t_{n+1})=x_i(L-x_i)(1+t_{n+1}/2) \)</li>
 <p><li> Run <em>one</em> simulation with one choice of \( c \), \( \Delta t \), and \( \Delta x \)</li>
 <p><li> Check that \( \max_i |u^{n+1}_i - \uex(x_i,t_{n+1})|<\epsilon \),
   \( \epsilon\sim 10^{-14} \) (machine precision + some round-off errors)</li>
 <p><li> This is the simplest and best verification test</li>
</ul>

<!-- !bpop -->
Later we show that the exact solution of the discrete equations
can be obtained by \( C=1 \) (!)
<!-- !epop -->

<p>
<!-- !split -->

<h2>Implementation <a name="wave:pde1:impl"></a></h2>

<p>
<!-- !split -->

<h3>The algorithm  <a name="___sec34"></a></h3>

<p>

<ol>
<p><li> Compute \( u^0_i=I(x_i) \) for \( i=0,\ldots,N_x \)</li>
<p><li> Compute \( u^1_i \) by \eqref{wave:pde1:step4:1} and set \( u_i^1=0 \)
   for the boundary points \( i=0 \) and \( i=N_x \), for \( n=1,2,\ldots,N-1 \),</li>
<p><li> For each time level \( n=1,2,\ldots,N_t-1 \)</li>

<ol>
  <p><li> apply \eqref{wave:pde1:step4} to find \( u^{n+1}_i \) for \( i=1,\ldots,N_x-1 \)</li>
  <p><li> set \( u^{n+1}_i=0 \) for the boundary points \( i=0 \), \( i=N_x \).</li>
</ol>

</ol>

<!-- !split -->

<h3>What do to with the solution?  <a name="___sec35"></a></h3>

<p>

<ul>
 <p><li> Different problem settings demand different actions with the
   computed \( u^{n+1}_i \) at each time step</li>
 <p><li> Solution: let the solver function make a callback to a
   user function where the user can do whatever is desired with
   the solution</li>
 <p><li> Advantage: solver just solves and user uses the solution</li>
</ul>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">user_action</span>(u, x, t, n):
    <span style="color: #228B22"># u[i] at spatial mesh points x[i] at time t[n]</span>
    <span style="color: #228B22"># plot u</span>
    <span style="color: #228B22"># or store u</span>
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Making a solver function  <a name="___sec36"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, V, f, c, L, Nx, C, T, user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u_tt=c^2*u_xx + f on (0,L)x(0,T].&quot;&quot;&quot;</span>
    x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)     <span style="color: #228B22"># Mesh points in space</span>
    dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
    dt = C*dx/c
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>) <span style="color: #228B22"># Mesh points in time</span>
    C2 = C**<span style="color: #B452CD">2</span>                    <span style="color: #228B22"># Help variable in the scheme</span>
    <span style="color: #8B008B; font-weight: bold">if</span> f <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> f == <span style="color: #B452CD">0</span> :
        f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">if</span> V <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> V == <span style="color: #B452CD">0</span>:
        V = <span style="color: #8B008B; font-weight: bold">lambda</span> x: <span style="color: #B452CD">0</span>

    u   = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution array at new time level</span>
    u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution at 1 time level back</span>
    u_2 = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution at 2 time levels back</span>

    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>;  t0 = time.clock()  <span style="color: #228B22"># for measuring CPU time</span>

    <span style="color: #228B22"># Load initial condition into u_1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,Nx+<span style="color: #B452CD">1</span>):
        u_1[i] = I(x[i])

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u_1, x, t, <span style="color: #B452CD">0</span>)

    <span style="color: #228B22"># Special formula for first time step</span>
    n = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = u_1[i] + dt*V(x[i]) + \ 
               <span style="color: #B452CD">0.5</span>*C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
               <span style="color: #B452CD">0.5</span>*dt**<span style="color: #B452CD">2</span>*f(x[i], t[n])
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u, x, t, <span style="color: #B452CD">1</span>)

    <span style="color: #228B22"># Switch variables before next step</span>
    u_2[:], u_1[:] = u_1, u

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        <span style="color: #228B22"># Update all inner points at time t[n+1]</span>
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
            u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
                     C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
                     dt**<span style="color: #B452CD">2</span>*f(x[i], t[n])

        <span style="color: #228B22"># Insert boundary conditions</span>
        u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>
        <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            <span style="color: #8B008B; font-weight: bold">if</span> user_action(u, x, t, n+<span style="color: #B452CD">1</span>):
                <span style="color: #8B008B; font-weight: bold">break</span>

        <span style="color: #228B22"># Switch variables before next step</span>
        u_2[:], u_1[:] = u_1, u

    cpu_time = t0 - time.clock()
    <span style="color: #8B008B; font-weight: bold">return</span> u, x, t, cpu_time
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Verification: exact quadratic solution  <a name="___sec37"></a></h3>

<p>
Exact solution of the PDE problem <em>and</em> the discrete equations:
\( \uex (x,t) = x(L-x)(1+\frac{1}{2}t) \)

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">nose.tools</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">nt</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Check that u(x,t)=x(L-x)(1+t/2) is exactly reproduced.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(x, t):
        <span style="color: #8B008B; font-weight: bold">return</span> x*(L-x)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> exact_solution(x, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">V</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*exact_solution(x, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x, t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)*c**<span style="color: #B452CD">2</span>

    L = <span style="color: #B452CD">2.5</span>
    c = <span style="color: #B452CD">1.5</span>
    Nx = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># Very coarse mesh</span>
    C = <span style="color: #B452CD">0.75</span>
    T = <span style="color: #B452CD">18</span>

    u, x, t, cpu = solver(I, V, f, c, L, Nx, C, T)
    u_e = exact_solution(x, t[-<span style="color: #B452CD">1</span>])
    diff = <span style="color: #658b00">abs</span>(u - u_e).max()
    nt.assert_almost_equal(diff, <span style="color: #B452CD">0</span>, places=<span style="color: #B452CD">14</span>)
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Visualization: animating \( u(x,t) \)  <a name="___sec38"></a></h3>

<p>
Make a <code>viz</code> function for animating the curve, with plotting
in a <code>user_action</code> function <code>plot_u</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">viz</span>(I, V, f, c, L, Nx, C, T, umin, umax, animate=<span style="color: #658b00">True</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Run solver and visualize u at each time level.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>, <span style="color: #008b45; text-decoration: underline">glob</span>, <span style="color: #008b45; text-decoration: underline">os</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_u</span>(u, x, t, n):
        <span style="color: #CD5555">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
        plt.plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>,
                 xlabel=<span style="color: #CD5555">&#39;x&#39;</span>, ylabel=<span style="color: #CD5555">&#39;u&#39;</span>,
                 axis=[<span style="color: #B452CD">0</span>, L, umin, umax],
                 title=<span style="color: #CD5555">&#39;t=%f&#39;</span> % t[n], show=<span style="color: #658b00">True</span>)
        <span style="color: #228B22"># Let the initial condition stay on the screen for 2</span>
        <span style="color: #228B22"># seconds, else insert a pause of 0.2 s between each plot</span>
        time.sleep(<span style="color: #B452CD">2</span>) <span style="color: #8B008B; font-weight: bold">if</span> t[n] == <span style="color: #B452CD">0</span> <span style="color: #8B008B; font-weight: bold">else</span> time.sleep(<span style="color: #B452CD">0.2</span>)
        plt.savefig(<span style="color: #CD5555">&#39;frame_%04d.png&#39;</span> % n)  <span style="color: #228B22"># for movie making</span>

    <span style="color: #228B22"># Clean up old movie frames</span>
    <span style="color: #8B008B; font-weight: bold">for</span> filename <span style="color: #8B008B">in</span> glob.glob(<span style="color: #CD5555">&#39;frame_*.png&#39;</span>):
        os.remove(filename)

    user_action = plot_u <span style="color: #8B008B; font-weight: bold">if</span> animate <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">None</span>
    u, x, t, cpu = solver(I, V, f, c, L, Nx, C, T, user_action)

    <span style="color: #228B22"># Make movie files</span>
    fps = <span style="color: #B452CD">4</span>  <span style="color: #228B22"># Frames per second</span>
    plt.movie(<span style="color: #CD5555">&#39;frame_*.png&#39;</span>, encoder=<span style="color: #CD5555">&#39;html&#39;</span>, fps=fps,
              output_file=<span style="color: #CD5555">&#39;movie.html&#39;</span>)
    codec2ext = <span style="color: #658b00">dict</span>(flv=<span style="color: #CD5555">&#39;flv&#39;</span>, libx64=<span style="color: #CD5555">&#39;mp4&#39;</span>, libvpx=<span style="color: #CD5555">&#39;webm&#39;</span>,
                     libtheora=<span style="color: #CD5555">&#39;ogg&#39;</span>)
    filespec = <span style="color: #CD5555">&#39;frame_%04d.png&#39;</span>
    movie_program = <span style="color: #CD5555">&#39;avconv&#39;</span>  <span style="color: #228B22"># or &#39;ffmpeg&#39;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> codec <span style="color: #8B008B">in</span> codec2ext:
        ext = codec2ext[codec]
        cmd = <span style="color: #CD5555">&#39;%(movie_program)s -r %(fps)d -i %(filespec)s &#39;</span>\ 
              <span style="color: #CD5555">&#39;-vcodec %(codec)s movie.%(ext)s&#39;</span> % <span style="color: #658b00">vars</span>()
        os.system(cmd)
</pre></div>
</td></tr></table><p>
Note: <code>plot_u</code> is function inside function and remembers the
local variables in <code>viz</code> (known as a closure).

<p>
<!-- !split -->

<h3>Making movie files  <a name="___sec39"></a></h3>

<p>

<ul>
 <p><li> Store spatial curve in a file, for each time level</li>
 <p><li> Name files like <code>'something_%04d.png' % frame_counter</code></li>
 <p><li> Combine files to a movie</li>
</ul>

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; scitools movie <span style="color: #00688B">encoder</span>=html <span style="color: #00688B">output_file</span>=movie.html <span style="color: #CD5555">\ </span>
          <span style="color: #00688B">fps</span>=4 frame_*.png  <span style="color: #228B22"># web page with a player</span>
Terminal&gt; avconv -r 4 -i frame_%04d.png -vcodec flv       movie.flv
Terminal&gt; avconv -r 4 -i frame_%04d.png -vcodec libtheora movie.ogg
Terminal&gt; avconv -r 4 -i frame_%04d.png -vcodec libx264   movie.mp4
Terminal&gt; avconv -r 4 -i frame_%04d.png -vcodec libtheora movie.ogg
Terminal&gt; avconv -r 4 -i frame_%04d.png -vcodec libpvx    movie.webm
</pre></div>
</td></tr></table><p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Important.</b>

<ul>
 <p><li> Zero padding (<code>%04d</code>) is essential for correct sequence of
   frames in <code>something_*.png</code> (Unix alphanumeric sort)</li>
 <p><li> Remove old <code>frame_*.png</code> files before making a new movie</li>
</ul>
</div>
<p>
<!-- !split -->

<h3>Running a case <a name="wave:pde1:guitar:data"></a></h3>

<p>

<ul>
 <p><li> Vibrations of a guitar string</li>
 <p><li> Triangular initial shape (at rest)</li>
</ul>

$$
\begin{equation}
I(x) = \left\lbrace
\begin{array}{ll}
ax/x_0, & x < x_0,\\ 
a(L-x)/(L-x_0), & \hbox{otherwise}
\end{array}\right.
\label{wave:pde1:guitar:I}
\end{equation}
$$


<p>
Appropriate data:

<p>

<ul>
  <p><li> \( L=75 \) cm, \( x_0=0.8L \), \( a=5 \) mm, \( N_x=50 \), time frequency
    \( \nu = 440 \) Hz</li>
</ul>

<!-- !split -->

<h3>Implementation of the case  <a name="___sec41"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">guitar</span>(C):
    <span style="color: #CD5555">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    L = <span style="color: #B452CD">0.75</span>
    x0 = <span style="color: #B452CD">0.8</span>*L
    a = <span style="color: #B452CD">0.005</span>
    freq = <span style="color: #B452CD">440</span>
    wavelength = <span style="color: #B452CD">2</span>*L
    c = freq*wavelength
    omega = <span style="color: #B452CD">2</span>*pi*freq
    num_periods = <span style="color: #B452CD">1</span>
    T = <span style="color: #B452CD">2</span>*pi/omega*num_periods
    Nx = <span style="color: #B452CD">50</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> a*x/x0 <span style="color: #8B008B; font-weight: bold">if</span> x &lt; x0 <span style="color: #8B008B; font-weight: bold">else</span> a/(L-x0)*(L-x)

    umin = -<span style="color: #B452CD">1.2</span>*a;  umax = -umin
    cpu = viz(I, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0</span>, c, L, Nx, C, T, umin, umax, animate=<span style="color: #658b00">True</span>)
</pre></div>
</td></tr></table><p>
Program: <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_u0_s.py"><tt>wave1D_u0_s.py</tt></a>.

<p>
<!-- !split -->

<h3>Resulting movie for \( C=0.8 \)  <a name="___sec42"></a></h3>

<p>

<div>
<video  loop controls width='800' height='365' preload='none'>
<source src='mov-wave/guitar_C0.8/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/guitar_C0.8/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/guitar_C0.8/index.html">Movie of the vibrating string</a>

<p>
<!-- !split -->

<h3>The benefits of scaling  <a name="___sec43"></a></h3>

<p>

<ul>
 <p><li> It is difficult to figure out all the physical parameters of a case</li>
 <p><li> And it is not necessary because of a powerful: <em>scaling</em></li>
</ul>

Introduce new \( x \), \( t \), and \( u \) without dimension:

<p>
$$ \bar x = \frac{x}{L},\quad \bar t = \frac{c}{L}t,\quad
\bar u = \frac{u}{a}
\tp 
$$


<p>
Insert this in the PDE (with \( f=0 \)) and dropping bars

<p>
$$ u_{tt} = u_{xx}$$


<p>
Initial condition: set \( a=1 \), \( L=1 \), and
\( x_0\in [0,1] \) in \eqref{wave:pde1:guitar:I}.

<p>
In the code: set <code>a=c=L=1</code>, <code>x0=0.8</code>, and there is no need to calculate with
wavelengths and frequencies to estimate \( c \)!

<p>
Just one challenge: determine the period of the waves and an
appropriate end time (see the text for details).

<p>
<!-- !split -->

<h2>Vectorization <a name="wave:pde1:impl:vec"></a></h2>

<p>

<ul>
 <p><li> Problem: Python loops over long arrays are slow</li>
 <p><li> One remedy: use vectorized (<code>numpy</code>) code instead of explicit loops</li>
 <p><li> Other remedies: use Cython, port spatial loops to Fortran or C</li>
 <p><li> Speedup: 100-1000 (varies with \( N_x \))</li>
</ul>

Next: vectorized loops

<p>
<!-- !split -->

<h3>Operations on slices of arrays  <a name="___sec45"></a></h3>

<p>

<ul>
 <p><li> Introductory example: compute \( d_i = u_{i+1}-u_i \)</li>
</ul>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">n = u.size
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, n-<span style="color: #B452CD">1</span>):
    d[i] = u[i+<span style="color: #B452CD">1</span>] - u[i]
</pre></div>
</td></tr></table><p>

<ul>
 <p><li> Note: all the differences here are independent of each other.</li>
 <p><li> Therefore \( d = (u_1,u_2,\ldots,u_n) - (u_0,u_1,\ldots,u_{n-1}) \)</li>
 <p><li> In <code>numpy</code> code: <code>u[1:n] - u[0:n-1]</code> or just <code>u[1:] - u[:-1]</code></li>
</ul>

<center><p><img src="fig-wave/vectorized_diff.png" align="bottom" width=400,></p></center>

<p>
<!-- !split -->

<h3>Test the understanding  <a name="___sec46"></a></h3>

<p>
Newcomers to vectorization are encouraged to choose
a small array <code>u</code>, say with five elements,
and simulate with pen and paper
both the loop version and the vectorized version.

<p>
<!-- !split -->

<h3>Vectorization of finite difference schemes (1)  <a name="___sec47"></a></h3>

<p>
Finite difference schemes basically contains differences between array
elements with shifted indices. Consider the updating formula

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>):
    u2[i] = u[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u[i] + u[i+<span style="color: #B452CD">1</span>]
</pre></div>
</td></tr></table><p>
The vectorization consists of replacing the loop by arithmetics on
slices of arrays of length <code>n-2</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2 = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:]
u2 = u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:n]   <span style="color: #228B22"># alternative</span>
</pre></div>
</td></tr></table><p>
Note: <code>u2</code> gets length <code>n-2</code>.

<p>
If <code>u2</code> is already an array of length <code>n</code>, do update on "inner" elements

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]  = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:]
u2[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:n]   <span style="color: #228B22"># alternative</span>
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Vectorization of finite difference schemes (2)  <a name="___sec48"></a></h3>

<p>
Include a function evaluation too:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x):
    <span style="color: #8B008B; font-weight: bold">return</span> x**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>

<span style="color: #228B22"># Scalar version</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>):
    u2[i] = u[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u[i] + u[i+<span style="color: #B452CD">1</span>] + f(x[i])

<span style="color: #228B22"># Vectorized version</span>
u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:] + f(x[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>])
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Vectorized implementation in the solver function  <a name="___sec49"></a></h3>

<p>
Scalar loop:
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = <span style="color: #B452CD">2</span>*u_1[i] - u_2[i] + \ 
           C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])
</pre></div>
</td></tr></table><p>
Vectorized loop:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = - u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
          C2*(u_1[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">2</span>:])
</pre></div>
</td></tr></table><p>
or
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:Nx] = <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:Nx]- u_2[<span style="color: #B452CD">1</span>:Nx] + \ 
          C2*(u_1[<span style="color: #B452CD">0</span>:Nx-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:Nx] + u_1[<span style="color: #B452CD">2</span>:Nx+<span style="color: #B452CD">1</span>])
</pre></div>
</td></tr></table><p>
Program: <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_u0_sv.py"><tt>wave1D_u0_sv.py</tt></a>

<p>
<!-- !split -->

<h3>Verification of the vectorized version  <a name="___sec50"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Check the scalar and vectorized versions work for</span>
<span style="color: #CD5555">    a quadratic u(x,t)=x(L-x)(1+t/2) that is exactly reproduced.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># The following function must work for x as array or scalar</span>
    exact_solution = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: x*(L - x)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)
    I = <span style="color: #8B008B; font-weight: bold">lambda</span> x: exact_solution(x, <span style="color: #B452CD">0</span>)
    V = <span style="color: #8B008B; font-weight: bold">lambda</span> x: <span style="color: #B452CD">0.5</span>*exact_solution(x, <span style="color: #B452CD">0</span>)
    <span style="color: #228B22"># f is a scalar (zeros_like(x) works for scalar x too)</span>
    f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: zeros_like(x) + <span style="color: #B452CD">2</span>*c**<span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    L = <span style="color: #B452CD">2.5</span>
    c = <span style="color: #B452CD">1.5</span>
    Nx = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># Very coarse mesh</span>
    C = <span style="color: #B452CD">1</span>
    T = <span style="color: #B452CD">18</span>  <span style="color: #228B22"># Long time integration</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assert_no_error</span>(u, x, t, n):
        u_e = exact_solution(x, t[n])
        diff = <span style="color: #658b00">abs</span>(u - u_e).max()
        nt.assert_almost_equal(diff, <span style="color: #B452CD">0</span>, places=<span style="color: #B452CD">13</span>)

    solver(I, V, f, c, L, Nx, C, T,
           user_action=assert_no_error, version=<span style="color: #CD5555">&#39;scalar&#39;</span>)
    solver(I, V, f, c, L, Nx, C, T,
           user_action=assert_no_error, version=<span style="color: #CD5555">&#39;vectorized&#39;</span>)
</pre></div>
</td></tr></table><p>
Note:

<p>

<ul>
 <p><li> Compact code with lambda functions</li>
 <p><li> The scalar \( f \) value needs careful coding: return constant array
   if vectorized code, else number</li>
</ul>

<!-- !split -->

<h3>Efficiency measurements  <a name="___sec51"></a></h3>

<p>

<ul>
 <p><li> Run <code>wave1D_u0_sv.py</code> for \( N_x \) as 50,100,200,400,800
   and measuring the CPU time</li>
 <p><li> Observe substantial speed-up: vectorized version is
   about \( N_x/5 \) times faster</li>
</ul>

Much bigger improvements for 2D and 3D codes!

<p>
<!-- !split -->

<h2>Generalization: reflecting boundaries  <a name="___sec52"></a></h2>

<p>

<ul>
 <p><li> Boundary condition \( u=0 \): \( u \) changes sign</li>
 <p><li> Boundary condition \( u_x=0 \): wave is perfectly reflected</li>
 <p><li> How can we implement \( u_x \)? (more complicated than \( u=0 \))</li>
</ul>


<div>
<video  loop controls width='500' height='365' preload='none'>
<source src='mov-wave/demo_BC_gaussian/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/demo_BC_gaussian/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<a href="http://phet.colorado.edu/sims/wave-on-a-string/wave-on-a-string_en.html">Demo of boundary conditions</a>

<p>
<!-- !split -->

<h3>Neumann boundary condition <a name="wave:pde2:Neumann"></a></h3>

<p>
$$
\begin{equation}
 \frac{\partial u}{\partial n} \equiv \normalvec\cdot\nabla u = 0
\label{wave:pde1:Neumann:0}
\tp 
\end{equation}
$$


<p>
For a 1D domain \( [0,L] \):

<p>
$$
\left.\frac{\partial}{\partial n}\right\vert_{x=L} =
\frac{\partial}{\partial x},\quad
\left.\frac{\partial}{\partial n}\right\vert_{x=0} = -
\frac{\partial}{\partial x}
$$


<p>
Boundary condition terminology:

<p>

<ul>
  <p><li> \( u_x \) specified: <a href="http://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann</a> condition</li>
  <p><li> \( u \) specified: <a href="http://en.wikipedia.org/wiki/Dirichlet_conditions">Dirichlet</a> condition</li>
</ul>

<!-- !split -->

<h3>Discretization of derivatives at the boundary (1) <a name="wave:pde2:Neumann:discr"></a></h3>

<p>

<ul>
 <p><li> How can we incorporate the condition \( u_x=0 \)
   in the finite difference scheme?</li>
 <p><li> We used centeral differences for \( u_{tt} \) and \( u_{xx} \): \( \Oof{\Delta t^2, \Delta x^2} \) accuracy</li>
 <p><li> Also for \( u_t(x,0) \)</li>
 <p><li> Should use central difference for \( u_x \) to preserve second order accuracy</li>
</ul>

$$
\begin{equation}
\frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
\tp 
\label{wave:pde1:Neumann:0:cd}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Discretization of derivatives at the boundary (2)  <a name="___sec55"></a></h3>

<p>
$$
\frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
$$


<p>

<ul>
 <p><li> Problem: \( u_{-1}^n \) is outside the mesh (fictitious value)</li>
 <p><li> Remedy: use the stencil at the boundary to eliminate \( u_{-1}^n \);
   just replace \( u_{-1}^n \) by \( u_{1}^n \)</li>
</ul>

$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i  + 2u^n_i + 2C^2
\left(u^{n}_{i+1}-u^{n}_{i}\right),\quad i=0 \tp  \end{equation}
$$


<p>
<!-- !split -->

<h3>Visualization of modified boundary stencil  <a name="___sec56"></a></h3>

<p>
Discrete equation
for computing \( u^3_0 \) in terms of \( u^2_0 \), \( u^1_0 \), and
\( u^2_1 \):

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
<source src='mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
Animation
in a <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/index.html">web page</a>
or a <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.flv">movie file</a>.

<p>
<!-- !split -->

<h3>Implementation of Neumann conditions <a name="wave:pde2:Neumann:impl"></a></h3>

<p>

<ul>
 <p><li> Use the general stencil for interior points also on the boundary</li>
 <p><li> Replace \( u_{i-1}^n \) by \( u_{i+1}^n \) for \( i=0 \)</li>
 <p><li> Replace \( u_{i+1}^n \) by \( u_{i-1}^n \) for \( i=N_x \)</li>
</ul>

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">i = 0
ip1 = i+1
im1 = ip1  # i-1 -&gt; i+1
u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])

i = Nx
im1 = i-1
ip1 = im1  # i+1 -&gt; i-1
u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])

# Or just one loop over all points

for i in range(0, Nx+1):
    ip1 = i+1 if i &lt; Nx else i-1
    im1 = i-1 if i &gt; 0  else i+1
    u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])
</pre></div>
</td></tr></table><p>
Program <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn0.py"><tt>wave1D_dn0.py</tt></a>

<p>
<!-- !split -->

<h3>Index set notation <a name="wave:indexset"></a></h3>

<p>

<ul>
 <p><li> Tedious to write index sets like \( i=0,\ldots,N_x \) and
   \( n=0,\ldots,N_t \)</li>
 <p><li> Notation not valid if \( i \) or \( n \) starts at 1 instead...</li>
 <p><li> Both in math and code it is advantageous to use <em>index sets</em></li>
 <p><li> \( i\in\Ix \) instead of \( i=0,\ldots,N_x \)</li>
 <p><li> Definition: \( \Ix =\{0,\ldots,N_x\} \)</li>
 <p><li> The first index: \( i=\setb{\Ix} \)</li>
 <p><li> The last index: \( i=\sete{\Ix} \)</li>
 <p><li> All interior points: \( i\in\seti{\Ix} \), \( \seti{\Ix}=\{1,\ldots,N_x-1\} \)</li>
 <p><li> \( \setl{\Ix} \) means \( \{0,\ldots,N_x-1\} \)</li>
 <p><li> \( \setr{\Ix} \) means \( \{1,\ldots,N_x\} \)</li>
</ul>

<!-- !split -->

<h3>Index set notation in code  <a name="___sec59"></a></h3>

<p>
<table border="1">
<tr><td align="center"><b>        Notation       </b></td> <td align="center"><b>         Python        </b></td> </tr>
<tr><td align="left">   \( \Ix \)                </td> <td align="left">   <code>Ix</code>          </td> </tr>
<tr><td align="left">   \( \setb{\Ix} \)         </td> <td align="left">   <code>Ix[0]</code>       </td> </tr>
<tr><td align="left">   \( \sete{\Ix} \)         </td> <td align="left">   <code>Ix[-1]</code>      </td> </tr>
<tr><td align="left">   \( \setl{\Ix} \)         </td> <td align="left">   <code>Ix[1:]</code>      </td> </tr>
<tr><td align="left">   \( \setr{\Ix} \)         </td> <td align="left">   <code>Ix[:-1]</code>     </td> </tr>
<tr><td align="left">   \( \seti{\Ix} \)         </td> <td align="left">   <code>Ix[1:-1]</code>    </td> </tr>
</table>
<p>
<!-- !split -->

<h3>Index sets in action (1)  <a name="___sec60"></a></h3>

<p>
Index sets for a problem in the \( x,t \) plane:

<p>
$$
\begin{equation}
\Ix = \{0,\ldots,N_x\},\quad \It = \{0,\ldots,N_t\},
\end{equation}
$$


<p>
Implemented in Python as

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>)
It = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt+<span style="color: #B452CD">1</span>)
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Index sets in action (2)  <a name="___sec61"></a></h3>

<p>
A finite difference scheme can with the index set notation be specified as

<p>
$$
\begin{align*}
u^{n+1}_i &= -u^{n-1}_i  + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i}+u^{n}_{i-1}\right),
\quad i\in\seti{\Ix},\ n\in\seti{\It},\\ 
u_i &= 0,
\quad i=\setb{\Ix},\ n\in\seti{\It},\\ 
u_i &= 0,
\quad i=\sete{\Ix},\ n\in\seti{\It},
\end{align*}
$$


<p>
Corresponding implementation:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> It[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
        u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
               C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])
    i = Ix[<span style="color: #B452CD">0</span>];  u[i] = <span style="color: #B452CD">0</span>
    i = Ix[-<span style="color: #B452CD">1</span>]; u[i] = <span style="color: #B452CD">0</span>
</pre></div>
</td></tr></table><p>
Program <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn.py"><tt>wave1D_dn.py</tt></a>

<p>
<!-- !split -->

<h3>Alternative implementation via ghost cells <a name="wave:pde1:Neumann:ghost"></a></h3>

<p>

<ul>
 <p><li> Instead of modifying the stencil at the boundary,
   we extend the mesh to cover \( u_{-1}^n \) and \( u_{N_x+1}^n \)</li>
 <p><li> The extra left and right cell are called <em>ghost cells</em></li>
 <p><li> The extra points are called <em>ghost points</em></li>
 <p><li> The \( u_{-1}^n \) and \( u_{N_x+1}^n \) values are called <em>ghost values</em></li>
 <p><li> Update ghost values as \( u_{i-1}^n = u_{i+1}^n \) for \( i=0 \) and \( i=N_x \)</li>
 <p><li> Then the stencil becomes right at the boundary</li>
</ul>

<!-- !split -->

<h3>Implementation of ghost cells (1)  <a name="___sec63"></a></h3>

<p>
Add ghost points:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u   = zeros(Nx+<span style="color: #B452CD">3</span>)
u_1 = zeros(Nx+<span style="color: #B452CD">3</span>)
u_2 = zeros(Nx+<span style="color: #B452CD">3</span>)

x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># Mesh points without ghost points</span>
</pre></div>
</td></tr></table><p>

<ul>
 <p><li> A major indexing problem arises with ghost cells since
   Python indices <em>must</em> start at 0.</li>
 <p><li> <code>u[-1]</code> will always mean the last element in <code>u</code></li>
 <p><li> Math indexing: \( -1,0,1,2,\ldots,N_x+1 \)</li>
 <p><li> Python indexing: <code>0,..,Nx+2</code></li>
 <p><li> Remedy: use index sets</li>
</ul>

<!-- !split -->

<h3>Implementation of ghost cells (2)  <a name="___sec64"></a></h3>

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u = zeros(Nx+3)
Ix = range(1, u.shape[0]-1)

# Boundary values: u[Ix[0]], u[Ix[-1]]

# Set initial conditions
for i in Ix:
    u_1[i] = I(x[i-Ix[0]])  # Note i-Ix[0]

# Loop over all physical mesh points
for i in Ix:
    u[i] = - u_2[i] + 2*u_1[i] + \ 
           C2*(u_1[i-1] - 2*u_1[i] + u_1[i+1])

# Update ghost values
i = Ix[0]          # x=0 boundary
u[i-1] = u[i+1]
i = Ix[-1]         # x=L boundary
u[i-1] = u[i+1]
</pre></div>
</td></tr></table><p>
Program: <a href="http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn0_ghost.py"><tt>wave1D_dn0_ghost.py</tt></a>.

<p>
<!-- !split -->

<h2>Generalization: variable wave velocity <a name="wave:pde2:var:c"></a></h2>

<p>
Heterogeneous media: varying \( c=c(x) \)

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
<source src='mov-wave/pulse1_in_two_media/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/pulse1_in_two_media/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split -->

<h3>The model PDE with a variable coefficient  <a name="___sec66"></a></h3>

<p>
$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) + f(x,t)
\label{wave:pde2:var:c:pde}
\tp 
\end{equation}
$$


<p>
This equation sampled at a mesh point \( (x_i,t_n) \):
$$
\frac{\partial^2 }{\partial t^2} u(x_i,t_n) =
\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) + f(x_i,t_n),
$$


<p>
<!-- !split -->

<h3>Discretizing the variable coefficient (1) <a name="wave:pde2:var:c:ideas"></a></h3>

<p>
The principal idea is to <em>first discretize the outer derivative</em>.

<p>
Define
$$ \phi = q(x)
\frac{\partial u}{\partial x}\tp
$$


<p>
Then use a centered derivative around \( x=x_i \) for the derivative of \( \phi \):

<p>
$$
\left[\frac{\partial\phi}{\partial x}\right]^n_i
\approx \frac{\phi_{i+\frac{1}{2}} - \phi_{i-\frac{1}{2}}}{\Delta x}
= [D_x\phi]^n_i
\tp 
$$


<p>
<!-- !split -->

<h3>Discretizing the variable coefficient (2)  <a name="___sec68"></a></h3>

<p>
Then discretize the inner operators:
$$
\phi_{i+\frac{1}{2}}  = q_{i+\frac{1}{2}}
\left[\frac{\partial u}{\partial x}\right]^n_{i+\frac{1}{2}}
\approx q_{i+\frac{1}{2}} \frac{u^n_{i+1} - u^n_{i}}{\Delta x}
= [q D_x u]_{i+\frac{1}{2}}^n
\tp 
$$


<p>
Similarly,
$$
\phi_{i-\frac{1}{2}}  = q_{i-\frac{1}{2}}
\left[\frac{\partial u}{\partial x}\right]^n_{i-\frac{1}{2}}
\approx q_{i-\frac{1}{2}} \frac{u^n_{i} - u^n_{i-1}}{\Delta x}
= [q D_x u]_{i-\frac{1}{2}}^n
\tp 
$$


<p>
<!-- !split -->

<h3>Discretizing the variable coefficient (3)  <a name="___sec69"></a></h3>

<p>
These intermediate results are now combined to

<p>
$$
\begin{equation}
\left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\approx \frac{1}{\Delta x^2}
\left( q_{i+\frac{1}{2}} \left({u^n_{i+1} - u^n_{i}}\right)
- q_{i-\frac{1}{2}} \left({u^n_{i} - u^n_{i-1}}\right)\right)
\label{wave:pde2:var:c:formula}
\tp 
\end{equation}
$$


<p>
In operator notation:
$$
\begin{equation}
\left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\approx [D_xq D_x u]^n_i
\label{wave:pde2:var:c:formula:op}
\tp 
\end{equation}
$$


<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Remark.</b>
Many are tempted to use the chain rule on the
term \( \frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) \), but this is not a good idea!
</div>
<p>
<!-- Needs some better explanation here - maybe the exact solution of a -->
<!-- poisson type problem (piecewise linear solution) failes if we use -->
<!-- the chain rule? -->

<p>
<!-- !split -->

<h3>Computing the coefficient between mesh points <a name="wave:pde2:var:c:means"></a></h3>

<p>

<ul>
 <p><li> Given \( q(x) \): compute \( q_{i+\frac{1}{2}} \) as \( q(x_{i+\frac{1}{2}}) \)</li>
 <p><li> Given \( q \) at the mesh points: \( q_i \), use an average</li>
</ul>

$$
\begin{align}
q_{i+\frac{1}{2}} &\approx
\frac{1}{2}\left( q_{i} + q_{i+1}\right) =
[\overline{q}^{x}]_i
\quad &\hbox{(arithmetic mean)}
\label{wave:pde2:var:c:mean:arithmetic}\\ 
q_{i+\frac{1}{2}} &\approx
2\left( \frac{1}{q_{i}} + \frac{1}{q_{i+1}}\right)^{-1}
\quad &\hbox{(harmonic mean)}
\label{wave:pde2:var:c:mean:harmonic}\\ 
q_{i+\frac{1}{2}} &\approx
\left(q_{i}q_{i+1}\right)^{1/2}
\quad &\hbox{(geometric mean)}
\label{wave:pde2:var:c:mean:geometric}
\end{align}
$$


<p>
The arithmetic mean in \eqref{wave:pde2:var:c:mean:arithmetic} is by
far the most used averaging technique.

<p>
<!-- !split -->

<h3>Discretization of variable-coefficient wave equation in operator notation  <a name="___sec71"></a></h3>

<p>
$$
\begin{equation}
\lbrack D_tD_t u = D_x\overline{q}^{x}D_x u + f\rbrack^{n}_i
\tp 
\label{wave:pde2:var:c:scheme:op}
\end{equation}
$$


<p>
We clearly see the type of finite differences and averaging!

<p>
Write out and solve wrt \( u_i^{n+1} \):

<p>
$$
\begin{align}
u^{n+1}_i &= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2\times \nonumber\\ 
&\quad  \left(
\frac{1}{2}(q_{i} + q_{i+1})(u_{i+1}^n - u_{i}^n) -
\frac{1}{2}(q_{i} + q_{i-1})(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\\ 
& \quad \Delta t^2 f^n_i
\tp 
\label{wave:pde2:var:c:scheme:impl}
\end{align}
$$


<p>
<!-- !split -->

<h3>Neumann condition and a variable coefficient <a name="wave:pde2:var:c:Neumann"></a></h3>

<p>
Consider \( \partial u/\partial x=0 \) at \( x=L=N_x\Delta x \):

<p>
$$ \frac{u_{i+1}^{n} - u_{i-1}^n}{2\Delta x} = 0\quad u_{i+1}^n = u_{i-1}^n,
\quad i=N_x\tp
$$


<p>
Insert \( u_{i+1}^n=u_{i-1}^n \) in the stencil
\eqref{wave:pde2:var:c:scheme:impl}
for \( i=N_x \) and obtain

<p>
$$
u^{n+1}_i \approx
- u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
2q_{i}(u_{i-1}^n - u_{i}^n) + \Delta t^2 f^n_i
$$


<p>
(We have used \( q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}}\approx 2q_i \).)

<p>
Alternative: assume \( dq/dx=0 \) (simpler).

<p>
<!-- !split -->

<h3>Implementation of variable coefficients <a name="wave:pde2:var:c:impl"></a></h3>

<p>
Assume <code>c[i]</code> holds \( c_i \) the spatial mesh points

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
           C2*(<span style="color: #B452CD">0.5</span>*(q[i] + q[i+<span style="color: #B452CD">1</span>])*(u_1[i+<span style="color: #B452CD">1</span>] - u_1[i])  - \ 
               <span style="color: #B452CD">0.5</span>*(q[i] + q[i-<span style="color: #B452CD">1</span>])*(u_1[i] - u_1[i-<span style="color: #B452CD">1</span>])) + \ 
           dt2*f(x[i], t[n])
</pre></div>
</td></tr></table><p>
Here: <code>C2=(dt/dx)**2</code>

<p>
Vectorized version:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = - u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
          C2*(<span style="color: #B452CD">0.5</span>*(q[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + q[<span style="color: #B452CD">2</span>:])*(u_1[<span style="color: #B452CD">2</span>:] - u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]) -
              <span style="color: #B452CD">0.5</span>*(q[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + q[:-<span style="color: #B452CD">2</span>])*(u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] - u_1[:-<span style="color: #B452CD">2</span>])) + \ 
          dt2*f(x[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>], t[n])
</pre></div>
</td></tr></table><p>
Neumann condition \( u_x=0 \): same ideas as in 1D (modified stencil
or ghost cells).

<p>
<!-- !split -->

<h3>A more general model PDE with variable coefficients  <a name="___sec74"></a></h3>

<p>
$$
\begin{equation}
\varrho(x)\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) + f(x,t)
\label{wave:pde2:var:c:pde2}
\tp 
\end{equation}
$$


<p>
A natural scheme is

<p>
$$
\begin{equation}
[\varrho D_tD_t u = D_x\overline{q}^xD_x u + f]^n_i
\tp 
\end{equation}
$$


<p>
Or

<p>
$$
\begin{equation}
[D_tD_t u = \varrho^{-1}D_x\overline{q}^xD_x u + f]^n_i
\tp 
\end{equation}
$$


<p>
No need to average \( \varrho \), just sample at \( i \)

<p>
<!-- !split -->

<h3>Generalization: damping  <a name="___sec75"></a></h3>

<p>
Why do waves die out?

<p>

<ul>
 <p><li> Damping (non-elastic effects, air resistance)</li>
 <p><li> 2D/3D: conservation of energy makes an amplitude reduction by
   \( 1/\sqrt{r} \) (2D) or \( 1/r \) (3D)</li>
</ul>

Simplest damping model (for physical behavior, see <a href="http://phet.colorado.edu/sims/wave-on-a-string/wave-on-a-string_en.html">demo</a>):

<p>
$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} + \color{red}{b\frac{\partial u}{\partial t}}
= c^2\frac{\partial^2 u}{\partial x^2} + f(x,t),
\label{wave:pde3}
\end{equation}
$$


<p>
\( b \geq 0 \): prescribed damping coefficient.

<p>
Discretization via centered differences to ensure \( \Oof{\Delta t^2} \) error:

<p>
$$
\begin{equation}
[D_tD_t u + bD_{2t}u = c^2D_xD_x u + f]^n_i
\tp 
\label{wave:pde3:fd}
\end{equation}
$$


<p>
Need special formula for \( u^1_i \) + special stencil (or ghost cells)
for Neumann conditions.

<p>
<!-- !split -->

<h2>Building a general 1D wave equation solver <a name="wave:pde2:software"></a></h2>

<p>
The program <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py"><tt>wave1D_dn_vc.py</tt></a>
solves a fairly general 1D wave equation:

<p>
$$
\begin{align}
u_t &= (c^2(x)u_x)_x + f(x,t),\quad &x\in (0,L),\ t\in (0,T]
\label{wave:pde2:software:ueq}\\ 
u(x,0) &= I(x),\quad &x\in [0,L]
\label{wave:pde2:software:u0}\\ 
u_t(x,0) &= V(t),\quad &x\in [0,L]
\label{wave:pde2:software:ut0}\\ 
u(0,t) &= U_0(t)\hbox{ or } u_x(0,t)=0,\quad &t\in (0,T]
\label{wave:pde2:software:bc0}\\ 
u(L,t) &= U_L(t)\hbox{ or } u_x(L,t)=0,\quad &t\in (0,T]
\label{wave:pde2:software:bcL}
\end{align}
$$


<p>
Can be adapted to many needs.

<p>
<!-- !split -->

<h3>Collection of initial conditions  <a name="___sec77"></a></h3>

<p>
The function <code>pulse</code> in <code>wave1D_dn_vc.py</code> offers four
initial conditions:

<p>

<ol>
<p><li> a rectangular pulse ("plug")</li>
<p><li> a Gaussian function (<code>gaussian</code>)</li>
<p><li> a "cosine hat": one period of \( 1 + \cos (\pi x \), \( x\in [-1,1] \)</li>
<p><li> half a "cosine hat": half a period of \( \cos \pi x \),
   \( x\in [-\frac{1}{2},\frac{1}{2}] \)</li>
</ol>

Can locate the initial pulse at \( x=0 \) or in the middle

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; import wave1D_dn_vc as w
&gt;&gt;&gt; w.pulse(loc=&#39;left&#39;, pulse_tp=&#39;cosinehat&#39;, Nx=50, every_frame=10)
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h2>Finite difference methods for 2D and 3D wave equations <a name="wave:2D3D"></a></h2>

<p>
Constant wave velocity \( c \):

<p>
$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} = c^2\nabla^2 u\hbox{ for }\xpoint\in\Omega\subset\Real^d,\ t\in (0,T]
\label{wave:2D3D:model1}
\end{equation}
$$


<p>
Variable wave velocity:

<p>
$$
\begin{equation}
\varrho\frac{\partial^2 u}{\partial t^2} = \nabla\cdot (q\nabla u) + f\hbox{ for }\xpoint\in\Omega\subset\Real^d,\ t\in (0,T]
\label{wave:2D3D:model2}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Examples on wave equations written out in 2D/3D  <a name="___sec79"></a></h3>
<a name="wave:2D3D:models"></a>

<p>
3D, constant \( c \):

<p>
$$
\begin{equation*} \nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}
\tp  \end{equation*}
$$


<p>
2D, variable \( c \):

<p>
$$
\begin{equation}
\varrho(x,y)
\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x,y)
\frac{\partial u}{\partial x}\right)
+
\frac{\partial}{\partial y}\left( q(x,y)
\frac{\partial u}{\partial y}\right)
+ f(x,y,t)
\tp 
\end{equation}
$$


<p>
Compact notation:

<p>
$$
\begin{align}
u_{tt} &= c^2(u_{xx} + u_{yy} + u_{zz}) + f,
\label{wave:2D3D:model1:v2}\\ 
\varrho u_{tt} &= (q u_x)_x + (q u_z)_z + (q u_z)_z + f
\label{wave:2D3D:model2:v2}
\tp 
\end{align}
$$


<p>
<!-- !split -->

<h3>Boundary and initial conditions  <a name="___sec80"></a></h3>

<p>
We need <em>one</em> boundary condition at <em>each point</em> on \( \partial\Omega \):

<p>

<ol>
 <p><li> \( u \) is prescribed (\( u=0 \) or known incoming wave)</li>
 <p><li> \( \partial u/\partial n = \normalvec\cdot\nabla u \) prescribed
    (\( =0 \): reflecting boundary)</li>
 <p><li> open boundary (radiation) condition: \( u_t + \boldsymbol{c}\cdot\nabla u =0 \)
    (let waves travel undisturbed out of the domain)</li>
</ol>

PDEs with <em>second-order</em> time derivative need <em>two</em> initial conditions:

<p>

<ol>
 <p><li> \( u=I \),</li>
 <p><li> \( u_t = V \).</li>
</ol>

<!-- !split -->

<h3>Example: 2D propagation of Gaussian function  <a name="___sec81"></a></h3>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
<source src='mov-wave/Gaussian2D/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/Gaussian2D/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split -->

<h3>Mesh <a name="wave:2D3D:mesh"></a></h3>

<p>

<ul>
 <p><li> Mesh point: \( (x_i,y_j,z_k,t_n) \)</li>
 <p><li> \( x \) direction: \( x_0 < x_1 <\cdots < x_{N_x} \)</li>
 <p><li> \( y \) direction: \( y_0 < y_1 <\cdots < y_{N_y} \)</li>
 <p><li> \( z \) direction: \( z_0 < z_1 <\cdots < z_{N_z} \)</li>
 <p><li> \( u^{n}_{i,j,k} \approx \uex(x_i,y_j,z_k,t_n) \)</li>
</ul>

<!-- !split -->

<h3>Discretization <a name="wave:2D3D:models"></a></h3>

<p>
$$
[D_tD_t u = c^2(D_xD_x u + D_yD_yu) + f]^n_{i,j,k},
$$

Written out in detail:

<p>
$$
\begin{align*}
\frac{u^{n+1}_{i,j} - 2u^{n}_{i,j} + u^{n-1}_{i,j}}{\Delta t^2}
&= c^2
\frac{u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}}{\Delta x^2}
+ \nonumber\\ 
&\quad c^2\frac{u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}}{\Delta y^2}
+ f^n_{i,j},
\end{align*}
$$


<p>
\( u^{n-1}_{i,j} \) and \( u^n_{i,j} \) are known, solve for
\( u^{n+1}_{i,j} \):

<p>
$$ u^{n+1}_{i,j} = 2u^n_{i,j} + u^{n-1}_{i,j} + c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}\tp$$


<p>
<!-- !split -->

<h3>Special stencil for the first time step  <a name="___sec84"></a></h3>

<p>

<ul>
 <p><li> The stencil for \( u^1_{i,j} \) (\( n=0 \)) involves \( u^{-1}_{i,j} \)
   which is outside the time mesh</li>
 <p><li> Remedy: use discretized \( u_t(x,0)=V \) and the stencil for \( n=0 \)
   to develop a special stencil (as in the 1D case)</li>
</ul>

$$ [D_{2t}u = V]^0_{i,j}\quad\Rightarrow\quad u^{-1}_{i,j} = u^1_{i,j} - 2\Delta t V_{i,j}
\tp 
$$


<p>
$$ u^{n+1}_{i,j} = u^n_{i,j} -2\Delta V_{i,j} + \frac{1}{2}
c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}\tp$$


<p>
<!-- !split -->

<h3>Variable coefficients (1)  <a name="___sec85"></a></h3>

<p>
3D wave equation:

<p>
$$ \varrho u_{tt} = (qu_x)_x + (qu_y)_y + (qu_z)_z + f(x,y,z,t) $$


<p>
Just apply the 1D discretization for each term:

<p>
$$
\begin{equation}
[\varrho D_tD_t u = (D_x\overline{q}^x D_x u +
D_y\overline{q}^y D_yu + D_z\overline{q}^z D_z u) + f]^n_{i,j,k}
\tp 
\end{equation}
$$


<p>
Need special formula for \( u^1_{i,j,k} \)
(use \( [D_{2t}u=V]^0 \) and stencil for \( n=0 \)).

<p>
<!-- !split -->

<h3>Variable coefficients (2)  <a name="___sec86"></a></h3>

<p>
Written out:

<p>
$$
\begin{align*}
u^{n+1}_{i,j,k} &= - u^{n-1}_{i,j,k}  + 2u^{n}_{i,j,k} + \\ 
&= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i+1,j,k})(u^{n}_{i+1,j,k} - u^{n}_{i,j,k}) - \\ 
&\qquad\quad \frac{1}{2}(q_{i-1,j,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i-1,j,k})) + \\ 
&= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i,j+1,k})(u^{n}_{i,j+1,k} - u^{n}_{i,j,k}) - \\ 
&\qquad\quad\frac{1}{2}(q_{i,j-1,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j-1,k})) + \\ 
&= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i,j,k+1})(u^{n}_{i,j,k+1} - u^{n}_{i,j,k}) -\\ 
&\qquad\quad \frac{1}{2}(q_{i,j,k-1} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j,k-1})) + \\ 
+ &\qquad \Delta t^2 f^n_{i,j,k}
\tp 
\end{align*}
$$


<p>
<!-- !split -->

<h3>Neumann boundary condition in 2D  <a name="___sec87"></a></h3>

<p>
Use ideas from 1D! Example: \( \frac{\partial u}{\partial n} \) at \( y=0 \),
\( \frac{\partial u}{\partial n} = -\frac{\partial u}{\partial y} \)

<p>
Boundary condition discretization:

<p>
$$ [-D_{2y} u = 0]^n_{i,0}\quad\Rightarrow\quad \frac{u^n_{i,1}-u^n_{i,-1}}{2\Delta y} = 0,\ i\in\Ix\tp
$$


<p>
Insert \( u^n_{i,-1}=u^n_{i,1} \) in the stencil for \( u^{n+1}_{i,j=0} \) to
obtain a modified stencil on the boundary.

<p>
Pattern: use interior stencil also on the bundary, but replace
\( j-1 \) by \( j+1 \)

<p>
Alternative: use ghost cells and ghost values

<p>
<!-- Should have fig -->

<p>
<!-- !split -->

<h2>Implementation of 2D/3D problems <a name="wave:2D3D:impl"></a></h2>

<p>
$$
\begin{align}
u_t &= c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad &(x,y)\in \Omega,\ t\in (0,T],\\ 
u(x,y,0) &= I(x,y),\quad &(x,y)\in\Omega,\\ 
u_t(x,y,0) &= V(x,y),\quad &(x,y)\in\Omega,\\ 
u &= 0,\quad &(x,y)\in\partial\Omega,\ t\in (0,T],
\end{align}
$$


<p>
\( \Omega = [0,L_x]\times [0,L_y] \)

<p>
Discretization:

<p>
$$ [D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j},
$$


<p>
<!-- !split -->

<h3>Algorithm  <a name="___sec89"></a></h3>

<p>

<ol>
<p><li> Set initial condition \( u^0_{i,j}=I(x_i,y_j) \)</li>
<p><li> Compute \( u^1_{i,j} = \cdots \) for \( i\in\seti{\Ix} \) and \( j\in\seti{\Iy} \)</li>
<p><li> Set \( u^1_{i,j}=0 \) for the boundaries \( i=0,N_x \), \( j=0,N_y \)</li>
<p><li> For \( n=1,2,\ldots,N_t \):</li>

<ol>
 <p><li> Find \( u^{n+1}_{i,j} = \cdots \)
    for \( i\in\seti{\Ix} \) and \( j\in\seti{\Iy} \)</li>
 <p><li> Set \( u^{n+1}_{i,j}=0 \) for the boundaries \( i=0,N_x \), \( j=0,N_y \)</li>
</ol>

</ol>

<!-- !split -->

<h3>Scalar computations: mesh <a name="wave2D3D:impl:scalar"></a></h3>

<p>
Program: <a href="http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0.py"><tt>wave2D_u0.py</tt></a>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, V, f, c, Lx, Ly, Nx, Ny, dt, T,
           user_action=<span style="color: #658b00">None</span>, version=<span style="color: #CD5555">&#39;scalar&#39;</span>):
</pre></div>
</td></tr></table><p>
Mesh:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">x = linspace(<span style="color: #B452CD">0</span>, Lx, Nx+<span style="color: #B452CD">1</span>)                  <span style="color: #228B22"># mesh points in x dir</span>
y = linspace(<span style="color: #B452CD">0</span>, Ly, Ny+<span style="color: #B452CD">1</span>)                  <span style="color: #228B22"># mesh points in y dir</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
dy = y[<span style="color: #B452CD">1</span>] - y[<span style="color: #B452CD">0</span>]
Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
t = linspace(<span style="color: #B452CD">0</span>, N*dt, N+<span style="color: #B452CD">1</span>)                 <span style="color: #228B22"># mesh points in time</span>
Cx2 = (c*dt/dx)**<span style="color: #B452CD">2</span>;  Cy2 = (c*dt/dy)**<span style="color: #B452CD">2</span>    <span style="color: #228B22"># help variables</span>
dt2 = dt**<span style="color: #B452CD">2</span>
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Scalar computations: arrays  <a name="___sec91"></a></h3>

<p>
Store \( u^{n+1}_{i,j} \), \( u^{n}_{i,j} \), and
\( u^{n-1}_{i,j} \) in three two-dimensional arrays:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u   = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>))   <span style="color: #228B22"># solution array</span>
u_1 = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>))   <span style="color: #228B22"># solution at t-dt</span>
u_2 = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>))   <span style="color: #228B22"># solution at t-2*dt</span>
</pre></div>
</td></tr></table><p>
\( u^{n+1}_{i,j} \) corresponds to <code>u[i,j]</code>, etc.

<p>
<!-- !split -->

<h3>Scalar computations: initial condition  <a name="___sec92"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">0</span>])
Iy = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">1</span>])
It = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, t.shape[<span style="color: #B452CD">0</span>])

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix:
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy:
        u_1[i,j] = I(x[i], y[j])

<span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
    user_action(u_1, x, xv, y, yv, t, <span style="color: #B452CD">0</span>)
</pre></div>
</td></tr></table><p>
Arguments <code>xv</code> and <code>yv</code>: for vectorized computations

<p>
<!-- !split -->

<h3>Scalar computations: primary stencil  <a name="___sec93"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">advance_scalar</span>(u, u_1, u_2, f, x, y, t, n, Cx2, Cy2, dt,
                   V=<span style="color: #658b00">None</span>, step1=<span style="color: #658b00">False</span>):
    Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">0</span>]);  Iy = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">1</span>])
    dt2 = dt**<span style="color: #B452CD">2</span>
    <span style="color: #8B008B; font-weight: bold">if</span> step1:
        Cx2 = <span style="color: #B452CD">0.5</span>*Cx2;  Cy2 = <span style="color: #B452CD">0.5</span>*Cy2; dt2 = <span style="color: #B452CD">0.5</span>*dt2
        D1 = <span style="color: #B452CD">1</span>;  D2 = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">else</span>:
        D1 = <span style="color: #B452CD">2</span>;  D2 = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
            u_xx = u_1[i-<span style="color: #B452CD">1</span>,j] - <span style="color: #B452CD">2</span>*u_1[i,j] + u_1[i+<span style="color: #B452CD">1</span>,j]
            u_yy = u_1[i,j-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i,j] + u_1[i,j+<span style="color: #B452CD">1</span>]
            u[i,j] = D1*u_1[i,j] - D2*u_2[i,j] + \ 
                     Cx2*u_xx + Cy2*u_yy + dt2*f(x[i], y[j], t[n])
            <span style="color: #8B008B; font-weight: bold">if</span> step1:
                u[i,j] += dt*V(x[i], y[j])
    <span style="color: #228B22"># Boundary condition u=0</span>
    j = Iy[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix: u[i,j] = <span style="color: #B452CD">0</span>
    j = Iy[-<span style="color: #B452CD">1</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix: u[i,j] = <span style="color: #B452CD">0</span>
    i = Ix[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy: u[i,j] = <span style="color: #B452CD">0</span>
    i = Ix[-<span style="color: #B452CD">1</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy: u[i,j] = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
</td></tr></table><p>
<code>D1</code> and <code>D2</code>: allow <code>advance_scalar</code> to be used also for \( u^1_{i,j} \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u = advance_scalar(u, u_1, u_2, f, x, y, t,
                   n, <span style="color: #B452CD">0.5</span>*Cx2, <span style="color: #B452CD">0.5</span>*Cy2, <span style="color: #B452CD">0.5</span>*dt2, D1=<span style="color: #B452CD">1</span>, D2=<span style="color: #B452CD">0</span>)
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Vectorized computations: mesh coordinates <a name="wave2D3D:impl:vectorized"></a></h3>

<p>
Mesh with \( 30\times 30 \) cells: vectorization reduces the CPU
time by a factor of 70 (!).

<p>
Need special coordinate arrays <code>xv</code> and <code>yv</code> such that \( I(x,y) \)
and \( f(x,y,t) \) can be vectorized:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> newaxis
xv = x[:,newaxis]
yv = y[newaxis,:]

u_1[:,:] = I(xv, yv)
f_a[:,:] = f(xv, yv, t)
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Vectorized computations: stencil  <a name="___sec95"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">advance_vectorized</span>(u, u_1, u_2, f_a, Cx2, Cy2, dt,
                       V=<span style="color: #658b00">None</span>, step1=<span style="color: #658b00">False</span>):
    dt2 = dt**<span style="color: #B452CD">2</span>
    <span style="color: #8B008B; font-weight: bold">if</span> step1:
        Cx2 = <span style="color: #B452CD">0.5</span>*Cx2;  Cy2 = <span style="color: #B452CD">0.5</span>*Cy2; dt2 = <span style="color: #B452CD">0.5</span>*dt2
        D1 = <span style="color: #B452CD">1</span>;  D2 = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">else</span>:
        D1 = <span style="color: #B452CD">2</span>;  D2 = <span style="color: #B452CD">1</span>
    u_xx = u_1[:-<span style="color: #B452CD">2</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">2</span>:,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]
    u_yy = u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">2</span>:]
    u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = D1*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] - D2*u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
                   Cx2*u_xx + Cy2*u_yy + dt2*f_a[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]
    <span style="color: #8B008B; font-weight: bold">if</span> step1:
        u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] += dt*V[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]
    <span style="color: #228B22"># Boundary condition u=0</span>
    j = <span style="color: #B452CD">0</span>
    u[:,j] = <span style="color: #B452CD">0</span>
    j = u.shape[<span style="color: #B452CD">1</span>]-<span style="color: #B452CD">1</span>
    u[:,j] = <span style="color: #B452CD">0</span>
    i = <span style="color: #B452CD">0</span>
    u[i,:] = <span style="color: #B452CD">0</span>
    i = u.shape[<span style="color: #B452CD">0</span>]-<span style="color: #B452CD">1</span>
    u[i,:] = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Verification: quadratic solution (1) <a name="wave2D3D:impl:verify"></a></h3>

<p>
Manufactured solution:

<p>
$$
\begin{equation}
\uex(x,y,t) = x(L_x-x)y(L_y-y)(1+\frac{1}{2}t)
\tp 
\label{wave2D3D:impl:verify:quadratic}
\end{equation}
$$


<p>
Requires \( f=2c^2(1+\frac{1}{2}t)(y(L_y-y) +
x(L_x-x)) \).

<p>
This \( \uex \) is ideal because it also solves the discrete equations!

<p>
<!-- !split -->

<h3>Verification: quadratic solution (2)  <a name="___sec97"></a></h3>

<p>

<ul>
 <p><li> \( [D_t D_t 1]^n=0 \)</li>
 <p><li> \( [D_t D_t t]^n=0 \)</li>
 <p><li> \( [D_t D_t t^2]=2 \)</li>
 <p><li> \( D_tD_t \) is a linear operator: \( [D_tD_t (au+bv)]^n = a[D_tD_t u]^n +
   b[D_tD_t v]^n \)</li>
</ul>

$$
\begin{align*}
[D_xD_x \uex]^n_{i,j} &= [y(L_y-y)(1+\frac{1}{2}t) D_xD_x x(L_x-x)]^n_{i,j}\\ 
&= y_j(L_y-y_j)(1+\frac{1}{2}t_n)2\tp
\end{align*}
$$


<p>

<ul>
 <p><li> Similar calculations for \( [D_yD_y\uex]^n_{i,j} \) and
   \( [D_tD_t \uex]^n_{i,j} \) terms</li>
 <p><li> Must also check the equation for \( u^1_{i,j} \)</li>
</ul>

<!-- !split -->

<h2>Migrating loops to Cython <a name="wave2D3D:impl:Cython"></a></h2>

<p>

<ul>
 <p><li> Vectorization: 5-10 times slower than pure C or Fortran code</li>
 <p><li> Cython: extension of Python for translating functions to C</li>
 <p><li> Principle: declare variables with type</li>
</ul>

<!-- !split -->

<h3>Declaring variables and annotating the code  <a name="___sec99"></a></h3>

<p>
Pure Python code:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">advance_scalar</span>(u, u_1, u_2, f, x, y, t,
                   n, Cx2, Cy2, dt2, D1=<span style="color: #B452CD">2</span>, D2=<span style="color: #B452CD">1</span>):
    Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">0</span>]);  Iy = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">1</span>])
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
            u_xx = u_1[i-<span style="color: #B452CD">1</span>,j] - <span style="color: #B452CD">2</span>*u_1[i,j] + u_1[i+<span style="color: #B452CD">1</span>,j]
            u_yy = u_1[i,j-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i,j] + u_1[i,j+<span style="color: #B452CD">1</span>]
            u[i,j] = D1*u_1[i,j] - D2*u_2[i,j] + \ 
                     Cx2*u_xx + Cy2*u_yy + dt2*f(x[i], y[j], t[n])
</pre></div>
</td></tr></table><p>

<ul>
 <p><li> Copy this function and put it in a file with <code>.pyx</code> extension.</li>
 <p><li> Add type of variables:</li>

<ul>
  <p><li> <code>function(a, b)</code> \( \rightarrow \) <code>cpdef function(int a, double b)</code></li>
  <p><li> <code>v = 1.2</code> \( \rightarrow \) <code>cdef double v = 1.2</code></li>
  <p><li> Array declaration: <code>np.ndarray[np.float64_t, ndim=2, mode='c'] u</code></li>
</ul>

</ul>

<!-- !split -->

<h3>Cython version of the functions  <a name="___sec100"></a></h3>

<p>

<!-- code=cython (from !bc cycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">cimport</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">cimport</span> <span style="color: #008b45; text-decoration: underline">cython</span>
<span style="color: #8B008B; font-weight: bold">ctypedef</span> np.float64_t DT    <span style="color: #228B22"># data type</span>

<span style="color: #707a7c">@cython</span>.boundscheck(<span style="color: #658b00">False</span>)  <span style="color: #228B22"># turn off array bounds check</span>
<span style="color: #707a7c">@cython</span>.wraparound(<span style="color: #658b00">False</span>)   <span style="color: #228B22"># turn off negative indices (u[-1,-1])</span>
<span style="color: #8B008B; font-weight: bold">cpdef</span> <span style="color: #008b45">advance</span>(
    np.ndarray[DT, ndim=<span style="color: #B452CD">2</span>, mode=<span style="color: #CD5555">&#39;c&#39;</span>] u,
    np.ndarray[DT, ndim=<span style="color: #B452CD">2</span>, mode=<span style="color: #CD5555">&#39;c&#39;</span>] u_1,
    np.ndarray[DT, ndim=<span style="color: #B452CD">2</span>, mode=<span style="color: #CD5555">&#39;c&#39;</span>] u_2,
    np.ndarray[DT, ndim=<span style="color: #B452CD">2</span>, mode=<span style="color: #CD5555">&#39;c&#39;</span>] f,
    double Cx2, double Cy2, double dt2):

    <span style="color: #8B008B; font-weight: bold">cdef</span> <span style="color: #a7a7a7; font-weight: bold">int</span> <span style="color: #008b45">Nx</span>, <span style="color: #008b45">Ny</span>, <span style="color: #008b45">i</span>, <span style="color: #008b45">j</span>
    <span style="color: #8B008B; font-weight: bold">cdef</span> <span style="color: #a7a7a7; font-weight: bold">double</span> <span style="color: #008b45">u_xx</span>, <span style="color: #008b45">u_yy</span>
    Nx = u.shape[<span style="color: #B452CD">0</span>]-<span style="color: #B452CD">1</span>
    Ny = u.shape[<span style="color: #B452CD">1</span>]-<span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">xrange</span>(<span style="color: #B452CD">1</span>, Nx):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">xrange</span>(<span style="color: #B452CD">1</span>, Ny):
            u_xx = u_1[i-<span style="color: #B452CD">1</span>,j] - <span style="color: #B452CD">2</span>*u_1[i,j] + u_1[i+<span style="color: #B452CD">1</span>,j]
            u_yy = u_1[i,j-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i,j] + u_1[i,j+<span style="color: #B452CD">1</span>]
            u[i,j] = <span style="color: #B452CD">2</span>*u_1[i,j] - u_2[i,j] + \ 
                     Cx2*u_xx + Cy2*u_yy + dt2*f[i,j]
</pre></div>
</td></tr></table><p>
Note: from now in we skip the code for setting boundary values

<p>
<!-- !split -->

<h3>Visual inspection of the C translation  <a name="___sec101"></a></h3>

<p>
See how effective Cython can translate this code to C:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; cython -a wave2D_u0_loop_cy.pyx
</pre></div>
</td></tr></table><p>
Load <code>wave2D_u0_loop_cy.html</code> in a browser (white: pure C, yellow: still Python):

<p>
<center><p><img src="fig-wave/wave2D_u0_loop_cy1.png" align="bottom" width=600,></p></center>

<p>
Can click on <code>wave2D_u0_loop_cy.c</code> to see the generated C code...

<p>
<!-- !split -->

<h3>Building the extension module  <a name="___sec102"></a></h3>

<p>

<ul>
 <p><li> Cython code must be translated to C</li>
 <p><li> C code must be compiled</li>
 <p><li> Compiled C code must be linked to Python C libraries</li>
 <p><li> Result: <em>C extension module</em> (<code>.so</code> file) that can be
   loaded as a standard Python module</li>
 <p><li> Use a <code>setup.py</code> script to build the extension module</li>
</ul>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">distutils.core</span> <span style="color: #8B008B; font-weight: bold">import</span> setup
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">distutils.extension</span> <span style="color: #8B008B; font-weight: bold">import</span> Extension
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">Cython.Distutils</span> <span style="color: #8B008B; font-weight: bold">import</span> build_ext

cymodule = <span style="color: #CD5555">&#39;wave2D_u0_loop_cy&#39;</span>
setup(
  name=cymodule
  ext_modules=[Extension(cymodule, [cymodule + <span style="color: #CD5555">&#39;.pyx&#39;</span>],)],
  cmdclass={<span style="color: #CD5555">&#39;build_ext&#39;</span>: build_ext},
)
</pre></div>
</td></tr></table><p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python setup.py build_ext --inplace
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Calling the Cython function from Python  <a name="___sec103"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">wave2D_u0_loop_cy</span>
advance = wave2D_u0_loop_cy.advance
...
<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> It[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>:                  <span style="color: #228B22"># time loop</span>
    f_a[:,:] = f(xv, yv, t[n])     <span style="color: #228B22"># precompute, size as u</span>
    u = advance(u, u_1, u_2, f_a, x, y, t, Cx2, Cy2, dt2)
</pre></div>
</td></tr></table><p>
Efficiency:

<p>

<ul>
 <p><li> \( 120\times 120 \) cells in space:</li>

<ul>
    <p><li> Pure Python: 1370 CPU time units</li>
    <p><li> Vectorized <code>numpy</code>: 5.5</li>
    <p><li> Cython: 1</li>
</ul>

 <p><li> \( 60\times 60 \) cells in space:</li>

<ul>
    <p><li> Pure Python: 1000 CPU time units</li>
    <p><li> Vectorized <code>numpy</code>: 6</li>
    <p><li> Cython: 1</li>
</ul>

</ul>

<!-- !split -->

<h2>Migrating loops to Fortran  <a name="___sec104"></a></h2>

<p>

<ul>
 <p><li> Write the <code>advance</code> function in pure Fortran</li>
 <p><li> Use <code>f2py</code> to generate C code for calling Fortran from Python</li>
 <p><li> Full manual control of the translation to Fortran</li>
</ul>

<!-- !split -->

<h3>The Fortran subroutine  <a name="___sec105"></a></h3>

<p>

<!-- code=fortran (from !bc fcod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">      <span style="color: #8B008B; font-weight: bold">subroutine </span><span style="color: #00688B">advance</span>(<span style="color: #00688B">u</span>, <span style="color: #00688B">u_1</span>, <span style="color: #00688B">u_2</span>, <span style="color: #00688B">f</span>, <span style="color: #00688B">Cx2</span>, <span style="color: #00688B">Cy2</span>, <span style="color: #00688B">dt2</span>, <span style="color: #00688B">Nx</span>, <span style="color: #00688B">Ny</span>)
      <span style="color: #a7a7a7; font-weight: bold">integer </span><span style="color: #00688B">Nx</span>, <span style="color: #00688B">Ny</span>
      <span style="color: #a7a7a7; font-weight: bold">real</span>*<span style="color: #B452CD">8</span> <span style="color: #00688B">u</span>(<span style="color: #B452CD">0</span>:<span style="color: #00688B">Nx</span>,<span style="color: #B452CD">0</span>:<span style="color: #00688B">Ny</span>), <span style="color: #00688B">u_1</span>(<span style="color: #B452CD">0</span>:<span style="color: #00688B">Nx</span>,<span style="color: #B452CD">0</span>:<span style="color: #00688B">Ny</span>), <span style="color: #00688B">u_2</span>(<span style="color: #B452CD">0</span>:<span style="color: #00688B">Nx</span>,<span style="color: #B452CD">0</span>:<span style="color: #00688B">Ny</span>)
      <span style="color: #a7a7a7; font-weight: bold">real</span>*<span style="color: #B452CD">8</span> <span style="color: #00688B">f</span>(<span style="color: #B452CD">0</span>:<span style="color: #00688B">Nx</span>, <span style="color: #B452CD">0</span>:<span style="color: #00688B">Ny</span>), <span style="color: #00688B">Cx2</span>, <span style="color: #00688B">Cy2</span>, <span style="color: #00688B">dt2</span>
      <span style="color: #a7a7a7; font-weight: bold">integer </span><span style="color: #00688B">i</span>, <span style="color: #00688B">j</span>
<span style="color: #00688B">Cf2py</span> <span style="color: #8B008B; font-weight: bold">intent</span>(<span style="color: #00688B">in</span>, <span style="color: #00688B">out</span>) <span style="color: #00688B">u</span>

<span style="color: #00688B">C</span>     <span style="color: #00688B">Scheme</span> <span style="color: #00688B">at</span> <span style="color: #00688B">interior</span> <span style="color: #00688B">points</span>
      <span style="color: #8B008B; font-weight: bold">do </span><span style="color: #00688B">j</span> = <span style="color: #B452CD">1</span>, <span style="color: #00688B">Ny</span>-<span style="color: #B452CD">1</span>
         <span style="color: #8B008B; font-weight: bold">do </span><span style="color: #00688B">i</span> = <span style="color: #B452CD">1</span>, <span style="color: #00688B">Nx</span>-<span style="color: #B452CD">1</span>
            <span style="color: #00688B">u</span>(<span style="color: #00688B">i</span>,<span style="color: #00688B">j</span>) = <span style="color: #B452CD">2</span>*<span style="color: #00688B">u_1</span>(<span style="color: #00688B">i</span>,<span style="color: #00688B">j</span>) - <span style="color: #00688B">u_2</span>(<span style="color: #00688B">i</span>,<span style="color: #00688B">j</span>) +
     &amp;      <span style="color: #00688B">Cx2</span>*(<span style="color: #00688B">u_1</span>(<span style="color: #00688B">i</span>-<span style="color: #B452CD">1</span>,<span style="color: #00688B">j</span>) - <span style="color: #B452CD">2</span>*<span style="color: #00688B">u_1</span>(<span style="color: #00688B">i</span>,<span style="color: #00688B">j</span>) + <span style="color: #00688B">u_1</span>(<span style="color: #00688B">i</span>+<span style="color: #B452CD">1</span>,<span style="color: #00688B">j</span>)) +
     &amp;      <span style="color: #00688B">Cy2</span>*(<span style="color: #00688B">u_1</span>(<span style="color: #00688B">i</span>,<span style="color: #00688B">j</span>-<span style="color: #B452CD">1</span>) - <span style="color: #B452CD">2</span>*<span style="color: #00688B">u_1</span>(<span style="color: #00688B">i</span>,<span style="color: #00688B">j</span>) + <span style="color: #00688B">u_1</span>(<span style="color: #00688B">i</span>,<span style="color: #00688B">j</span>+<span style="color: #B452CD">1</span>)) +
     &amp;      <span style="color: #00688B">dt2</span>*<span style="color: #00688B">f</span>(<span style="color: #00688B">i</span>,<span style="color: #00688B">j</span>)
         <span style="color: #8B008B; font-weight: bold">end do</span>
<span style="color: #8B008B; font-weight: bold">      end do</span>
</pre></div>
</td></tr></table><p>
Note: <code>Cf2py</code> comment declares <code>u</code> as input argument and return value
back to Python

<p>
<!-- !split -->

<h3>Building the Fortran module with f2py  <a name="___sec106"></a></h3>

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; f2py -m wave2D_u0_loop_f77 -h wave2D_u0_loop_f77.pyf <span style="color: #CD5555">\ </span>
          --overwrite-signature wave2D_u0_loop_f77.f
Terminal&gt; f2py -c wave2D_u0_loop_f77.pyf --build-dir build_f77 <span style="color: #CD5555">\ </span>
          -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_f77.f
</pre></div>
</td></tr></table><p>
<code>f2py</code> changes the argument list (!)
<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; import wave2D_u0_loop_f77
&gt;&gt;&gt; print wave2D_u0_loop_f77.__doc__
This module &#39;wave2D_u0_loop_f77&#39; is auto-generated with f2py....
Functions:
  u = advance(u,u_1,u_2,f,cx2,cy2,dt2,
      nx=(shape(u,0)-1),ny=(shape(u,1)-1))
</pre></div>
</td></tr></table><p>

<ul>
 <p><li> Array limits have default values</li>
 <p><li> Examine doc strings from <code>f2py</code>!</li>
</ul>

<!-- !split -->

<h3>How to avoid array copying  <a name="___sec107"></a></h3>

<p>

<ul>
 <p><li> Two-dimensional arrays are stored row by row in Python and C</li>
 <p><li> Two-dimensional arrays are stored column by column in Fortran</li>
 <p><li> <code>f2py</code> takes a copy of a <code>numpy</code> (C) array and transposes it
   when calling Fortran</li>
 <p><li> Such copies are time and memory consuming</li>
 <p><li> Remedy: declare <code>numpy</code> arrays with Fortran storage</li>
</ul>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">order = <span style="color: #CD5555">&#39;Fortran&#39;</span> <span style="color: #8B008B; font-weight: bold">if</span> version == <span style="color: #CD5555">&#39;f77&#39;</span> <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #CD5555">&#39;C&#39;</span>
u   = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>), order=order)
u_1 = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>), order=order)
u_2 = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>), order=order)
</pre></div>
</td></tr></table><p>
Option <code>-DF2PY_REPORT_ON_ARRAY_COPY=1</code> makes <code>f2py</code> write out
array copying:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; f2py -c wave2D_u0_loop_f77.pyf --build-dir build_f77 <span style="color: #CD5555">\ </span>
          -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_f77.f
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Efficiency of translating to Fortran  <a name="___sec108"></a></h3>

<p>

<ul>
 <p><li> Same efficiency (in this example) as Cython and C</li>
 <p><li> About 5 times faster than vectorized <code>numpy</code> code</li>
 <p><li> \( >1000 \) faster than pure Python code</li>
</ul>

<!-- !split -->

<h2>Migrating loops to C via Cython  <a name="___sec109"></a></h2>

<p>

<ul>
 <p><li> Write the <code>advance</code> function in pure C</li>
 <p><li> Use Cython to generate C code for calling C from Python</li>
 <p><li> Full manual control of the translation to C</li>
</ul>

<!-- !split -->

<h3>The C code  <a name="___sec110"></a></h3>

<p>

<ul>
 <p><li> <code>numpy</code> arrays transferred to C are one-dimensional in C</li>
 <p><li> Need to translate <code>[i,j]</code> indices to single indices</li>
</ul>

<p>

<!-- code=c (from !bc ccod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22">/* Translate (i,j) index to single array index */</span>
<span style="color: #1e889b">#define idx(i,j) (i)*(Ny+1) + j</span>

<span style="color: #a7a7a7; font-weight: bold">void</span> <span style="color: #008b45">advance</span>(<span style="color: #a7a7a7; font-weight: bold">double</span>* u, <span style="color: #a7a7a7; font-weight: bold">double</span>* u_1, <span style="color: #a7a7a7; font-weight: bold">double</span>* u_2, <span style="color: #a7a7a7; font-weight: bold">double</span>* f,
	     <span style="color: #a7a7a7; font-weight: bold">double</span> Cx2, <span style="color: #a7a7a7; font-weight: bold">double</span> Cy2, <span style="color: #a7a7a7; font-weight: bold">double</span> dt2,
	     <span style="color: #a7a7a7; font-weight: bold">int</span> Nx, <span style="color: #a7a7a7; font-weight: bold">int</span> Ny)
{
  <span style="color: #a7a7a7; font-weight: bold">int</span> i, j;
  <span style="color: #228B22">/* Scheme at interior points */</span>
  <span style="color: #8B008B; font-weight: bold">for</span> (i=<span style="color: #B452CD">1</span>; i&lt;=Nx-<span style="color: #B452CD">1</span>; i++) {
    <span style="color: #8B008B; font-weight: bold">for</span> (j=<span style="color: #B452CD">1</span>; j&lt;=Ny-<span style="color: #B452CD">1</span>; j++) {
        u[idx(i,j)] = <span style="color: #B452CD">2</span>*u_1[idx(i,j)] - u_2[idx(i,j)] +
        Cx2*(u_1[idx(i-<span style="color: #B452CD">1</span>,j)] - <span style="color: #B452CD">2</span>*u_1[idx(i,j)] + u_1[idx(i+<span style="color: #B452CD">1</span>,j)]) +
        Cy2*(u_1[idx(i,j-<span style="color: #B452CD">1</span>)] - <span style="color: #B452CD">2</span>*u_1[idx(i,j)] + u_1[idx(i,j+<span style="color: #B452CD">1</span>)]) +
        dt2*f[idx(i,j)];
	}
    }
  }
}
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>The Cython interface file  <a name="___sec111"></a></h3>

<p>

<!-- code=cython (from !bc cycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">cimport</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">cimport</span> <span style="color: #008b45; text-decoration: underline">cython</span>

<span style="color: #8B008B; font-weight: bold">cdef</span> <span style="color: #8B008B; font-weight: bold">extern</span> <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #CD5555">&quot;wave2D_u0_loop_c.h&quot;</span>:
    void advance(double* u, double* u_1, double* u_2, double* f,
                 double Cx2, double Cy2, double dt2,
                 <span style="color: #658b00">int</span> Nx, <span style="color: #658b00">int</span> Ny)

<span style="color: #707a7c">@cython</span>.boundscheck(<span style="color: #658b00">False</span>)
<span style="color: #707a7c">@cython</span>.wraparound(<span style="color: #658b00">False</span>)
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">advance_cwrap</span>(
    np.ndarray[double, ndim=<span style="color: #B452CD">2</span>, mode=<span style="color: #CD5555">&#39;c&#39;</span>] u,
    np.ndarray[double, ndim=<span style="color: #B452CD">2</span>, mode=<span style="color: #CD5555">&#39;c&#39;</span>] u_1,
    np.ndarray[double, ndim=<span style="color: #B452CD">2</span>, mode=<span style="color: #CD5555">&#39;c&#39;</span>] u_2,
    np.ndarray[double, ndim=<span style="color: #B452CD">2</span>, mode=<span style="color: #CD5555">&#39;c&#39;</span>] f,
    double Cx2, double Cy2, double dt2):
    advance(&amp;u[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>], &amp;u_1[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>], &amp;u_2[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>], &amp;f[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>],
            Cx2, Cy2, dt2,
            u.shape[<span style="color: #B452CD">0</span>]-<span style="color: #B452CD">1</span>, u.shape[<span style="color: #B452CD">1</span>]-<span style="color: #B452CD">1</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Building the extension module  <a name="___sec112"></a></h3>

<p>
Compile and link the extension module with a <code>setup.py</code> file:

<p>

<!-- code=python (from !bc pypro) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">distutils.core</span> <span style="color: #8B008B; font-weight: bold">import</span> setup
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">distutils.extension</span> <span style="color: #8B008B; font-weight: bold">import</span> Extension
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">Cython.Distutils</span> <span style="color: #8B008B; font-weight: bold">import</span> build_ext

sources = [<span style="color: #CD5555">&#39;wave2D_u0_loop_c.c&#39;</span>, <span style="color: #CD5555">&#39;wave2D_u0_loop_c_cy.pyx&#39;</span>]
module = <span style="color: #CD5555">&#39;wave2D_u0_loop_c_cy&#39;</span>
setup(
  name=module,
  ext_modules=[Extension(module, sources,
                         libraries=[], <span style="color: #228B22"># C libs to link with</span>
                         )],
  cmdclass={<span style="color: #CD5555">&#39;build_ext&#39;</span>: build_ext},
)
</pre></div>
</td></tr></table><p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python setup.py build_ext --inplace
</pre></div>
</td></tr></table><p>
In Python:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">wave2D_u0_loop_c_cy</span>
advance = wave2D_u0_loop_c_cy.advance_cwrap
...
f_a[:,:] = f(xv, yv, t[n])
u = advance(u, u_1, u_2, f_a, Cx2, Cy2, dt2)
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h2>Migrating loops to C via f2py  <a name="___sec113"></a></h2>

<p>

<ul>
 <p><li> Write the <code>advance</code> function in pure C</li>
 <p><li> Use <code>f2py</code> to generate C code for calling C from Python</li>
 <p><li> Full manual control of the translation to C</li>
</ul>

<!-- !split -->

<h3>The C code and the Fortran interface file  <a name="___sec114"></a></h3>

<p>

<ul>
 <p><li> Write the C function <code>advance</code> as before</li>
 <p><li> Write a Fortran 90 module defining the signature of
   the <code>advance</code> function</li>
 <p><li> Or: write a Fortran 77 function defining the signature and
   let <code>f2py</code> generate the Fortran 90 module</li>
</ul>

Fortran 77 signature (note <code>intent(c)</code>):

<p>

<!-- code=fortran (from !bc fpro) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">      <span style="color: #8B008B; font-weight: bold">subroutine </span><span style="color: #00688B">advance</span>(<span style="color: #00688B">u</span>, <span style="color: #00688B">u_1</span>, <span style="color: #00688B">u_2</span>, <span style="color: #00688B">f</span>, <span style="color: #00688B">Cx2</span>, <span style="color: #00688B">Cy2</span>, <span style="color: #00688B">dt2</span>, <span style="color: #00688B">Nx</span>, <span style="color: #00688B">Ny</span>)
<span style="color: #00688B">Cf2py</span> <span style="color: #8B008B; font-weight: bold">intent</span>(<span style="color: #00688B">c</span>) <span style="color: #00688B">advance</span>
      <span style="color: #a7a7a7; font-weight: bold">integer </span><span style="color: #00688B">Nx</span>, <span style="color: #00688B">Ny</span>, <span style="color: #00688B">N</span>
      <span style="color: #a7a7a7; font-weight: bold">real</span>*<span style="color: #B452CD">8</span> <span style="color: #00688B">u</span>(<span style="color: #B452CD">0</span>:<span style="color: #00688B">Nx</span>,<span style="color: #B452CD">0</span>:<span style="color: #00688B">Ny</span>), <span style="color: #00688B">u_1</span>(<span style="color: #B452CD">0</span>:<span style="color: #00688B">Nx</span>,<span style="color: #B452CD">0</span>:<span style="color: #00688B">Ny</span>), <span style="color: #00688B">u_2</span>(<span style="color: #B452CD">0</span>:<span style="color: #00688B">Nx</span>,<span style="color: #B452CD">0</span>:<span style="color: #00688B">Ny</span>)
      <span style="color: #a7a7a7; font-weight: bold">real</span>*<span style="color: #B452CD">8</span> <span style="color: #00688B">f</span>(<span style="color: #B452CD">0</span>:<span style="color: #00688B">Nx</span>, <span style="color: #B452CD">0</span>:<span style="color: #00688B">Ny</span>), <span style="color: #00688B">Cx2</span>, <span style="color: #00688B">Cy2</span>, <span style="color: #00688B">dt2</span>
<span style="color: #00688B">Cf2py</span> <span style="color: #8B008B; font-weight: bold">intent</span>(<span style="color: #00688B">in</span>, <span style="color: #00688B">out</span>) <span style="color: #00688B">u</span>
<span style="color: #00688B">Cf2py</span> <span style="color: #8B008B; font-weight: bold">intent</span>(<span style="color: #00688B">c</span>) <span style="color: #00688B">u</span>, <span style="color: #00688B">u_1</span>, <span style="color: #00688B">u_2</span>, <span style="color: #00688B">f</span>, <span style="color: #00688B">Cx2</span>, <span style="color: #00688B">Cy2</span>, <span style="color: #00688B">dt2</span>, <span style="color: #00688B">Nx</span>, <span style="color: #00688B">Ny</span>
      <span style="color: #8B008B; font-weight: bold">return</span>
<span style="color: #8B008B; font-weight: bold">      end</span>
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Building the extension module  <a name="___sec115"></a></h3>

<p>
Generate Fortran 90 module (<code>wave2D_u0_loop_c_f2py.pyf</code>):

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; f2py -m wave2D_u0_loop_c_f2py <span style="color: #CD5555">\ </span>
          -h wave2D_u0_loop_c_f2py.pyf --overwrite-signature <span style="color: #CD5555">\ </span>
          wave2D_u0_loop_c_f2py_signature.f
</pre></div>
</td></tr></table><p>
The compile and build step must list the C files:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; f2py -c wave2D_u0_loop_c_f2py.pyf <span style="color: #CD5555">\ </span>
          --build-dir tmp_build_c <span style="color: #CD5555">\ </span>
          -DF2PY_REPORT_ON_ARRAY_COPY=1 wave2D_u0_loop_c.c
</pre></div>
</td></tr></table><p>
<!-- !split -->

<h3>Migrating loops to C++ via f2py  <a name="___sec116"></a></h3>

<p>

<ul>
 <p><li> C++ can be used as an alternative to C</li>
 <p><li> C++ code often applies sophisticated arrays</li>
 <p><li> Challenge: translate from <code>numpy</code> C arrays to C++ array classes</li>
 <p><li> Can use SWIG to make C++ classes available as Python classes</li>
 <p><li> Easier (and more efficient):</li>

<ul>
   <p><li> Make C API to the C++ code</li>
   <p><li> Wrap C API with <code>f2py</code></li>
   <p><li> Send <code>numpy</code> arrays to C API and let C translate <code>numpy</code> arrays
     into C++ array classes</li>
</ul>

</ul>

<!-- !split -->

<h2>Analysis of the difference equations  <a name="___sec117"></a></h2>
<a name="wave:pde1:analysis"></a>

<p>
<!-- !split -->

<h3>Properties of the solution of the wave equation <a name="wave:pde1:properties"></a></h3>

<p>
$$
\begin{equation*} \frac{\partial^2 u}{\partial t^2} =
c^2 \frac{\partial^2 u}{\partial x^2}
\end{equation*}
$$


<p>
Solutions:

<p>
$$
\begin{equation}
u(x,t) = g_R(x-ct) + g_L(x+ct),
\label{wave:pde1:gensol}
\end{equation}
$$


<p>
If \( u(x,0)=I(x) \) and \( u_t(x,0)=0 \):

<p>
$$
\begin{equation}
u(x,t) = \half I(x-ct) + \half I(x+ct) \tp 
\label{wave:pde1:gensol2}
\end{equation}
$$


<p>
Two waves: one traveling to the right and one to the left

<p>
<!-- !split -->

<h3>Demo of the splitting of \( I(x) \) into two waves  <a name="___sec119"></a></h3>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
<source src='mov-wave/demo_BC_gaussian/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/demo_BC_gaussian/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split -->

<h3>Representation of waves as sum of sine/cosine waves  <a name="___sec120"></a></h3>

<p>
Build \( I(x) \) of wave components \( e^{ikx} = \cos kx + i\sin kx \):

<p>
$$
\begin{equation} I(x) \approx \sum_{k\in K} b_k e^{ikx} \tp 
\label{wave:Fourier:I}
\end{equation}
$$


<p>

<ul>
 <p><li> \( k \) is the frequency of a component (\( \lambda = 2\pi/k \) corresponding wave length)</li>
 <p><li> \( K \) is some set of all \( k \) needed to approximate \( I(x) \) well</li>
 <p><li> \( b_k \) must be computed (Fourier coefficients)</li>
</ul>

Since \( u(x,t)=\half I(x-ct) + \half I(x+ct) \):

<p>
$$
\begin{equation}
u(x,t) = \half \sum_{k\in K} b_k e^{ik(x - ct)}
+ \half \sum_{k\in K} b_k e^{ik(x + ct)} \tp 
\label{wave:Fourier:u1}
\end{equation}
$$


<p>
Our interest: one component \( e^{i(kx -\omega t)} \), \( \omega = kc \)

<p>
<!-- !split -->

<h3>Analysis of the finite difference scheme <a name="wave:pde1:analysis"></a></h3>

<p>
A similar discrete \( u^n_q = e^{i(kx_q - \tilde\omega t_n)} \) solves

<p>
$$
\begin{equation}
[D_tD_t u = c^2 D_xD_x u]^n_q
\label{wave:pde1:analysis:scheme}
\end{equation}
$$


<p>
Note: different frequency \( \tilde\omega\neq\omega \)

<p>

<ul>
 <p><li> How accurate is \( \tilde\omega \) compared to \( \omega \)?</li>
 <p><li> What about the wave amplitude?</li>
</ul>

<!-- !split -->

<h3>Preliminary results  <a name="___sec122"></a></h3>

<p>
$$
\begin{equation*}
[D_tD_t e^{i\omega t}]^n = -\frac{4}{\Delta t^2}\sin^2\left(
\frac{\omega\Delta t}{2}\right)e^{i\omega n\Delta t}
\tp 
\end{equation*}
$$


<p>
By \( \omega\rightarrow k \),
\( t\rightarrow x \), \( n\rightarrow q \)) it follows that

<p>
$$
\begin{equation*}
[D_xD_x e^{ikx}]_q = -\frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right)e^{ikq\Delta x} \tp 
\end{equation*}
$$


<p>
<!-- !split -->

<h3>Numerical wave propagation (1)  <a name="___sec123"></a></h3>

<p>
Inserting a basic wave component \( u=e^{i(kx_q-\tilde\omega t_n)} \) in
the scheme \eqref{wave:pde1:analysis:scheme} requires computation of

<p>
$$
\begin{align}
\lbrack D_tD_t e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q &= \lbrack D_tD_t e^{-i\tilde\omega t}\rbrack^ne^{ikq\Delta x}\nonumber\\ &= -\frac{4}{\Delta t^2}\sin^2\left(
\frac{\tilde\omega\Delta t}{2}\right)e^{-i\tilde\omega n\Delta t}e^{ikq\Delta x}\\ 
\lbrack D_xD_x e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q &= \lbrack D_xD_x e^{ikx}\rbrack_q e^{-i\tilde\omega n\Delta t}\nonumber\\ &= -\frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right)e^{ikq\Delta x}e^{-i\tilde\omega n\Delta t} \tp  \end{align}
$$


<p>
<!-- !split -->

<h3>Numerical wave propagation (2)  <a name="___sec124"></a></h3>

<p>
The complete scheme,

<p>
$$
\begin{equation*}
\lbrack D_tD_t e^{ikx}e^{-i\tilde\omega t} = c^2D_xD_x e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q
\end{equation*}
$$


<p>
leads to an equation for \( \tilde\omega \):

<p>
$$
\begin{equation}
\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
= C^2\sin^2\left(\frac{k\Delta x}{2}\right),
\label{wave:pde1:analysis:sineq1}
\end{equation}
$$

where \( C = \frac{c\Delta t}{\Delta x} \) is the Courant number

<p>
<!-- !split -->

<h3>Numerical wave propagation (3)  <a name="___sec125"></a></h3>

<p>
Taking the square root of \eqref{wave:pde1:analysis:sineq1}:

<p>
$$
\begin{equation}
\sin\left(\frac{\tilde\omega\Delta t}{2}\right)
= C\sin\left(\frac{k\Delta x}{2}\right),
\label{wave:pde1:analysis:sineq2}
\end{equation}
$$


<p>

<ul>
 <p><li> Exact \( \omega \) is real</li>
 <p><li> Look for a real solution \( \tilde\omega \) of \eqref{wave:pde1:analysis:sineq2}</li>
 <p><li> Then the sine functions are in \( [-1,1] \)</li>
 <p><li> Lef-hand side in \( [-1,1] \) requires \( C\leq 1 \)</li>
</ul>

Stability criterion
$$
\begin{equation}
C = \frac{c\Delta t}{\Delta x} \leq 1 \tp 
\label{wave:pde1:stability}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Why \( C\leq 1 \) is a stability criterion  <a name="___sec126"></a></h3>

<p>
Assume \( C>1 \). Then

<p>
$$
\underline{\sin\left(\frac{\tilde\omega\Delta t}{2}\right)}{>1} = C\sin\left(\frac{k\Delta x}{2}\right)
$$


<p>

<ul>
 <p><li> \( |\sin x| >1 \) implies complex \( x \)</li>
 <p><li> Here: complex \( \tilde\omega = \tilde\omega_r \pm i\tilde\omega_i \)</li>
 <p><li> One \( \tilde\omega_i < 0 \) gives \( \exp(i\cdot i\tilde\omega_i) =
   \exp (\tilde\omega_i) \) and exponential growth</li>
</ul>

<!-- !split -->

<h3>Numerical dispersion relation  <a name="___sec127"></a></h3>

<p>

<ul>
 <p><li> How close is \( \tilde\omega \) to \( \omega \)</li>
 <p><li> Can solve for an explicit formula for \( \tilde\omega \)</li>
</ul>

$$
\begin{equation}
\tilde\omega = \frac{2}{\Delta t}
\sin^{-1}\left( C\sin\left(\frac{k\Delta x}{2}\right)\right) \tp 
\label{wave:pde1:disprel}
\end{equation}
$$


<p>

<ul>
 <p><li> \( \omega = kc \) is the <em>analytical dispersion relation</em></li>
 <p><li> \( \tilde\omega = \tilde\omega(k, c, \Delta x, \Delta t) \) is the
   <em>numerical dispersion relation</em></li>
 <p><li> Speed of waves: \( c=\omega/k \), \( \tilde c = \tilde\omega/k \)</li>
 <p><li> The numerical wave component has a wrong, mesh-dependent speed</li>
</ul>

<!-- !split -->

<h3>The special case \( C=1 \)  <a name="___sec128"></a></h3>

<p>

<ul>
 <p><li> For \( C=1 \), \( \tilde\omega = \omega \)</li>
 <p><li> The numerical solution is exact (at the mesh points)!</li>
 <p><li> The only requirement is constant \( c \)</li>
</ul>

<!-- !split -->

<h3>Computing the error in wave velocity  <a name="___sec129"></a></h3>

<p>

<ul>
 <p><li> Introduce \( p=k\Delta x/2 \)</li>
 <p><li> \( p \) measures no of mesh points in space
   per wave length in space</li>
 <p><li> Study error in wave velocity through \( \tilde c/c \) as function of \( p \)</li>
</ul>

$$
\begin{equation*}
r(C, p) = \frac{\tilde c}{c} = \frac{1}{Cp}{\sin}^{-1}\left(C\sin p\right),
\quad C\in (0,1],\ p\in (0,\pi/2]\tp
\end{equation*}
$$


<p>
<!-- !split -->

<h3>Visualizing the error in wave velocity  <a name="___sec130"></a></h3>

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">def r(C, p):
    return 2/(C*p)*asin(C*sin(p))
</pre></div>
</td></tr></table><p>
<center><p><img src="fig-wave/disprel.png" align="bottom" width=600,></p></center>

<p>
Note: the shortest
waves have the largest error, and short waves move too
slowly.

<p>
<!-- !split -->

<h3>Taylor expanding the error in wave velocity  <a name="___sec131"></a></h3>

<p>
For small \( p \), Taylor expand \( \tilde\omega \) as polynomial in \( p \):

<p>

<!-- code=python (from !bc py) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; C, p = symbols(<span style="color: #CD5555">&#39;C p&#39;</span>)
&gt;&gt;&gt; rs = r(C, p).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">7</span>)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> rs
<span style="color: #B452CD">1</span> - p**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> + p**<span style="color: #B452CD">4</span>/<span style="color: #B452CD">120</span> - p**<span style="color: #B452CD">6</span>/<span style="color: #B452CD">5040</span> + C**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> -
C**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">4</span>/<span style="color: #B452CD">12</span> + <span style="color: #B452CD">13</span>*C**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">6</span>/<span style="color: #B452CD">720</span> + <span style="color: #B452CD">3</span>*C**<span style="color: #B452CD">4</span>*p**<span style="color: #B452CD">4</span>/<span style="color: #B452CD">40</span> -
C**<span style="color: #B452CD">4</span>*p**<span style="color: #B452CD">6</span>/<span style="color: #B452CD">16</span> + <span style="color: #B452CD">5</span>*C**<span style="color: #B452CD">6</span>*p**<span style="color: #B452CD">6</span>/<span style="color: #B452CD">112</span> + O(p**<span style="color: #B452CD">7</span>)

&gt;&gt;&gt; <span style="color: #228B22"># Factorize each term and drop the remainder O(...) term</span>
&gt;&gt;&gt; rs_factored = [factor(term) <span style="color: #8B008B; font-weight: bold">for</span> term <span style="color: #8B008B">in</span> rs.lseries(p)]
&gt;&gt;&gt; rs_factored = <span style="color: #658b00">sum</span>(rs_factored)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> rs_factored
p**<span style="color: #B452CD">6</span>*(C - <span style="color: #B452CD">1</span>)*(C + <span style="color: #B452CD">1</span>)*(<span style="color: #B452CD">225</span>*C**<span style="color: #B452CD">4</span> - <span style="color: #B452CD">90</span>*C**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>)/<span style="color: #B452CD">5040</span> +
p**<span style="color: #B452CD">4</span>*(C - <span style="color: #B452CD">1</span>)*(C + <span style="color: #B452CD">1</span>)*(<span style="color: #B452CD">3</span>*C - <span style="color: #B452CD">1</span>)*(<span style="color: #B452CD">3</span>*C + <span style="color: #B452CD">1</span>)/<span style="color: #B452CD">120</span> +
p**<span style="color: #B452CD">2</span>*(C - <span style="color: #B452CD">1</span>)*(C + <span style="color: #B452CD">1</span>)/<span style="color: #B452CD">6</span> + <span style="color: #B452CD">1</span>
</pre></div>
</td></tr></table><p>
Leading error term is \( \frac{1}{6}(C^2-1)p^2 \) or

<p>
$$
\begin{equation}
\frac{1}{6}\left(\frac{k\Delta x}{2}\right)^2(C^2-1)
= \frac{k^2}{24}\left( c^2\Delta t^2 - \Delta x^2\right) =
\Oof{\Delta t^2, \Delta x^2}\tp
\end{equation}
$$


<p>
<!-- !split -->

<h3>Example on effect of wrong wave velocity (1)  <a name="___sec132"></a></h3>

<p>
Smooth wave, few short waves (small \( k \)) in \( I(x) \):

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
<source src='mov-wave/pulse1_in_two_media/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/pulse1_in_two_media/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split -->

<h3>Example on effect of wrong wave velocity (1)  <a name="___sec133"></a></h3>

<p>
Not so smooth wave, significant short waves (small \( k \)) in \( I(x) \):

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
<source src='mov-wave/pulse2_in_two_media/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
<source src='mov-wave/pulse2_in_two_media/movie.ogg'  type='video/ogg; codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split -->

<h3>Extending the analysis to 2D (and 3D) <a name="wave:pde1:analysis:2D3D"></a></h3>

<p>
$$ u(x,y,t) = g(k_xx + k_yy - \omega t) $$


<p>
is a typically solution of

<p>
$$ u_{tt} = c^2(u_{xx} + u_{yy}) $$


<p>
Can build solutions by adding complex Fourier components
of the form

<p>
$$
e^{i(k_xx + k_yy - \omega t)}
$$


<p>
<!-- !split -->

<h3>Discrete wave components in 2D  <a name="___sec135"></a></h3>

<p>
$$
\begin{equation}
\lbrack D_tD_t u = c^2(D_xD_x u + D_yD_y u)\rbrack^n_{q,r}
\tp 
\label{wave:pde1:analysis:scheme2D}
\end{equation}
$$


<p>
This equation admits a Fourier component

<p>
$$
\begin{equation}
u^n_{q,r} = e^{i(k_x q\Delta x + k_y r\Delta y
- \tilde\omega n\Delta t)}\tp
\label{wave:pde1:analysis:numsol2D}
\end{equation}
$$


<p>
Inserting the expression and using formulas from the 1D analysis:

<p>
$$
\begin{equation}
\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
= C_x^2\sin^2 p_x
+ C_y^2\sin^2 p_y, \end{equation}
$$


<p>
where

<p>
$$ C_x = \frac{c^2\Delta t^2}{\Delta x^2},\quad
C_y = \frac{c^2\Delta t^2}{\Delta y^2}, \quad
p_x = \frac{k_x\Delta x}{2},\quad
p_y = \frac{k_y\Delta y}{2}\tp
$$


<p>
<!-- !split -->

<h3>Stability criterion in 2D  <a name="___sec136"></a></h3>

<p>
Rreal-valued \( \tilde\omega \) requires

<p>
$$
\begin{equation}
C_x^2 + C_y^2 \leq 1 \tp 
\label{wave:pde1:analysis:2DstabC}
\end{equation}
$$


<p>
or

<p>
$$
\begin{equation}
\Delta t \leq \frac{1}{c} \left( \frac{1}{\Delta x^2} +
\frac{1}{\Delta y^2}\right)^{-\halfi}
\label{wave:pde1:analysis:2Dstab}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Stability criterion in 3D  <a name="___sec137"></a></h3>

<p>
$$
\begin{equation}
\Delta t \leq \frac{1}{c}\left( \frac{1}{\Delta x^2} +
\frac{1}{\Delta y^2} + \frac{1}{\Delta z^2}\right)^{-\halfi}
\end{equation}
$$


<p>
For \( c^2=c^2(\xpoint) \) we must use
the worst-case value \( \bar c = \sqrt{\max_{\xpoint\in\Omega} c^2(\xpoint)} \)
and a safety factor \( \beta\leq 1 \):

<p>
$$
\begin{equation}
\Delta t \leq \beta \frac{1}{\bar c}
\left( \frac{1}{\Delta x^2} +
\frac{1}{\Delta y^2} + \frac{1}{\Delta z^2}\right)^{-\halfi}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Numerical dispersion relation in 2D (1)  <a name="___sec138"></a></h3>

<p>
$$
\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(
\left( C_x^2\sin^2 p_x + C_y^2\sin^ p_y\right)^{\frac{1}{2}}\right)
$$


<p>
For visualization, introduce \( \theta \):

<p>
$$ k_x = k\sin\theta,\quad k_y=k\cos\theta,
\quad p_x=\frac{1}{2} kh\cos\theta,\quad p_y=\frac{1}{2} kh\sin\theta\tp$$


<p>
Also: \( \Delta x=\Delta y=h \). Then \( C_x=C_y=c\Delta t/h\equiv C \).

<p>
Now \( \tilde\omega \) depends on

<p>

<ul>
  <p><li> \( C \) reflecting the number cells a wave is displaced during a time step</li>
  <p><li> \( kh \) reflecting the number of cells per wave length in space</li>
  <p><li> \( \theta \) expressing the direction of the wave</li>
</ul>

<!-- !split -->

<h3>Numerical dispersion relation in 2D (2)  <a name="___sec139"></a></h3>

<p>
$$ \frac{\tilde c}{c} = \frac{1}{Ckh}
\sin^{-1}\left(C\left(\sin^2 (\frac{1}{2}kh\cos\theta)
+ \sin^2(\frac{1}{2}kh\sin\theta) \right)^{\frac{1}{2}}\right)\tp
$$


<p>
Can make color contour plots of \( 1-\tilde c/c \) in
<em>polar coordinates</em> with \( \theta \) as the angular coordinate and
\( kh \) as the radial coordinate.

<p>
<!-- !split -->

<h3>Numerical dispersion relation in 2D (3)  <a name="___sec140"></a></h3>

<p>
<center><p><img src="fig-wave/disprel2D.png" align="bottom" width=800></p></center>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

