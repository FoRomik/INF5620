<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study Guide: Approximation of functions with finite elements">
<meta name="keywords" content="approximation of general vectors,Galerkin method,projection,approximation of functions,approximation by sines,collocation method (approximation),approximation collocation,Lagrange (interpolating) polynomial,sparse matrices">



<style type="text/css">
    /* bloodish style */

    body {
      font-family: Helvetica, Verdana, Arial, Sans-serif;
      color: #404040;
      background: #ffffff;
    }
    h1 { font-size: 1.8em;  color: #8A0808; }
    h2 { font-size: 1.5em;  color: #8A0808; }
    h3, h4 { color: #8A0808; }
    a { color: #8A0808; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #bababa;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #f8f8f8;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Why finite elements? ', 1, None, '___sec0'),
              (' Domain for flow around a dolphin ', 2, None, '___sec1'),
              (' The flow ', 2, None, '___sec2'),
              (' Basic ingredients of the finite element method ',
               2,
               None,
               '___sec3'),
              (' Our learning strategy ', 2, None, '___sec4'),
              (' Approximation set-up ', 2, None, '___sec5'),
              (' How to determine the coefficients? ', 2, None, '___sec6'),
              (' Approximation of planar vectors; problem ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' Approximation of planar vectors; vector space terminology ',
               2,
               None,
               '___sec8'),
              (' The least squares method; principle ', 2, None, '___sec9'),
              (' The least squares method; calculations ',
               2,
               None,
               '___sec10'),
              (' The projection (or Galerkin) method ', 2, None, '___sec11'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 2, None, '___sec13'),
              (' The projection (or Galerkin) method ', 2, None, '___sec14'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec17'),
              (' Example: linear approximation; problem ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Example: linear approximation; solution ',
               2,
               None,
               '___sec19'),
              (' Example: linear approximation; plot ', 2, None, '___sec20'),
              (' Implementation of the least squares method; ideas ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Implementation of the least squares method; code ',
               2,
               None,
               '___sec22'),
              (' Implementation of the least squares method; plotting ',
               2,
               None,
               '___sec23'),
              (' Implementation of the least squares method; application ',
               2,
               None,
               '___sec24'),
              (' Perfect approximation; parabola approximating parabola ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Perfect approximation; the general result ',
               2,
               None,
               '___sec26'),
              (' Perfect approximation; proof of the general result ',
               2,
               None,
               '___sec27'),
              (' Finite-precision/numerical computations ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Ill-conditioning (1) ', 2, None, '___sec29'),
              (' Ill-conditioning (2) ', 2, None, '___sec30'),
              (' Fourier series approximation; problem and code ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Fourier series approximation; plot ', 2, None, '___sec32'),
              (' Fourier series approximation; improvements ',
               2,
               None,
               '___sec33'),
              (' Fourier series approximation; final results ',
               2,
               None,
               '___sec34'),
              (' Orthogonal basis functions ', 2, None, '___sec35'),
              (' The collocation or interpolation method; ideas and math ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' The collocation or interpolation method; implementation ',
               2,
               None,
               '___sec37'),
              (' The collocation or interpolation method; approximating a parabola by linear functions ',
               2,
               None,
               '___sec38'),
              (' Lagrange polynomials; motivation and ideas ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Lagrange polynomials; formula and code ',
               2,
               None,
               '___sec40'),
              (' Lagrange polynomials; successful example ',
               2,
               None,
               '___sec41'),
              (' Lagrange polynomials; a less successful example ',
               2,
               None,
               '___sec42'),
              (' Lagrange polynomials; oscillatory behavior ',
               2,
               None,
               '___sec43'),
              (' Lagrange polynomials; remedy for strong oscillations ',
               2,
               None,
               '___sec44'),
              (' Lagrange polynomials; recalculation with Chebyshev nodes ',
               2,
               None,
               '___sec45'),
              (' Lagrange polynomials; less oscillations with Chebyshev nodes ',
               2,
               None,
               '___sec46'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' So far: basis functions have been global ',
               2,
               None,
               '___sec48'),
              (' In the finite element method we use basis functions with local support ',
               2,
               None,
               '___sec49'),
              (' The linear combination of hat functions is a piecewise linear function ',
               2,
               None,
               '___sec50'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example on elements with two nodes (P1 elements) ',
               2,
               None,
               '___sec52'),
              (' Illustration of two basis functions on the mesh ',
               2,
               None,
               '___sec53'),
              (' Example on elements with three nodes (P2 elements) ',
               2,
               None,
               '___sec54'),
              (' Some corresponding basis functions (P2 elements) ',
               2,
               None,
               '___sec55'),
              (' Examples on elements with four nodes per element (P3 elements) ',
               2,
               None,
               '___sec56'),
              (' Some corresponding basis functions (P3 elements) ',
               2,
               None,
               '___sec57'),
              (' The numbering does not need to be regular from left to right ',
               2,
               None,
               '___sec58'),
              (' Interpretation of the coefficients $c_i$ ',
               2,
               None,
               '___sec59'),
              (' Properties of the basis functions ', 2, None, '___sec60'),
              (' How to construct quadratic $\\basphi_i$ (P2 elements) ',
               2,
               None,
               '___sec61'),
              (' Example on linear $\\basphi_i$ (P1 elements) ',
               2,
               None,
               '___sec62'),
              (' Example on cubic $\\basphi_i$ (P3 elements) ',
               2,
               None,
               '___sec63'),
              (' Calculating the linear system for $c_i$ ',
               1,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Computing a specific matrix entry (1) ',
               2,
               None,
               '___sec65'),
              (' Computing a specific matrix entry (2) ',
               2,
               None,
               '___sec66'),
              (' Calculating a general row in the matrix; figure ',
               2,
               None,
               '___sec67'),
              (' Calculating a general row in the matrix; details ',
               2,
               None,
               '___sec68'),
              (' Calculation of the right-hand side ', 2, None, '___sec69'),
              (' Specific example: two elements; linear system and solution ',
               2,
               None,
               '___sec70'),
              (' Specific example: two elements; plot ', 2, None, '___sec71'),
              (' Specific example: what about four elements? ',
               2,
               None,
               '___sec72'),
              (' Assembly of elementwise computations ',
               1,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Split the integrals into elementwise integrals ',
               2,
               None,
               '___sec74'),
              (' The element matrix ', 2, None, '___sec75'),
              (' Illustration of the matrix assembly: regularly numbered P1 elements ',
               2,
               None,
               '___sec76'),
              (' Illustration of the matrix assembly: regularly numbered P3 elements ',
               2,
               None,
               '___sec77'),
              (' Illustration of the matrix assembly: irregularly numbered P1 elements ',
               2,
               None,
               '___sec78'),
              (' Assembly of the right-hand side ', 2, None, '___sec79'),
              (' Mapping to a reference element ',
               1,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Affine mapping ', 2, None, '___sec81'),
              (' Integral transformation ', 2, None, '___sec82'),
              (' Advantages of the reference element ', 2, None, '___sec83'),
              (' Standardized basis functions for P1 elements ',
               2,
               None,
               '___sec84'),
              (' Standardized basis functions for P2 elements ',
               2,
               None,
               '___sec85'),
              (' Integration over a reference element; element matrix ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Integration over a reference element; element vector ',
               2,
               None,
               '___sec87'),
              (" Tedious calculations! Let's use symbolic software ",
               2,
               None,
               '___sec88'),
              (' Implementation ', 1, None, '___sec89'),
              (' Compute finite element basis functions ',
               2,
               None,
               '___sec90'),
              (' Compute the element matrix ', 2, None, '___sec91'),
              (' Example on symbolic and numeric element matrix ',
               2,
               None,
               '___sec92'),
              (' Compute the element vector ', 2, None, '___sec93'),
              (' Fallback on numerical integration if symbolic integration fails ',
               2,
               None,
               '___sec94'),
              (' Linear system assembly and solution ', 2, None, '___sec95'),
              (' Linear system solution ', 2, None, '___sec96'),
              (' Example on computing approximations ', 2, None, '___sec97'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' General result: the coefficient matrix is sparse ',
               2,
               None,
               '___sec99'),
              (' Exemplifying the sparsity for P2 elements ',
               2,
               None,
               '___sec100'),
              (' Matrix sparsity pattern for regular/random numbering of P1 elements ',
               2,
               None,
               '___sec101'),
              (' Matrix sparsity pattern for regular/random numbering of P3 elements ',
               2,
               None,
               '___sec102'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Approximate $f\\sim x^9$ by various elements; code ',
               2,
               None,
               '___sec104'),
              (' Approximate $f\\sim x^9$ by various elements; plot ',
               2,
               None,
               '___sec105'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Interpolation/collocation with finite elements ',
               2,
               None,
               '___sec107')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
%\newcommand{\If}{\mathcal{I}}     % for FEM
\newcommand{\If}{I}     % for FEM
%\newcommand{\Ifd}{\mathcal{I}_d}  % for FEM
\newcommand{\Ifd}{I_d}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- ------------------- main content ---------------------- -->


<title>Study Guide: Approximation of functions with finite elements</title>

<center><h1>Study Guide: Approximation of functions with finite elements</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Oct 16, 2013</h4></center> <!-- date -->
<p>
<!-- !split -->

<h2>Table of contents</h2>

<p>
<a href="#___sec0"> Why finite elements? </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Domain for flow around a dolphin </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> The flow </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> Basic ingredients of the finite element method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Our learning strategy </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> Approximation set-up </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec6"> How to determine the coefficients? </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:vec:plane"> Approximation of planar vectors; problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> Approximation of planar vectors; vector space terminology </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> The least squares method; principle </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> The least squares method; calculations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> The projection (or Galerkin) method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:vec:Np1dim"> Approximation of general vectors </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> The least squares method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> The projection (or Galerkin) method </a><br>
<a href="#fem:approx:global"> Approximation of functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:LS"> The least squares method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> The projection (or Galerkin) method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:global:linear"> Example: linear approximation; problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Example: linear approximation; solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> Example: linear approximation; plot </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:global:LS:code"> Implementation of the least squares method; ideas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> Implementation of the least squares method; code </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> Implementation of the least squares method; plotting </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Implementation of the least squares method; application </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:global:exact"> Perfect approximation; parabola approximating parabola </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> Perfect approximation; the general result </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Perfect approximation; proof of the general result </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:global:illconditioning"> Finite-precision/numerical computations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> Ill-conditioning (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> Ill-conditioning (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:global:Fourier"> Fourier series approximation; problem and code </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec32"> Fourier series approximation; plot </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> Fourier series approximation; improvements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> Fourier series approximation; final results </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec35"> Orthogonal basis functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:global:interp"> The collocation or interpolation method; ideas and math </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec37"> The collocation or interpolation method; implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec38"> The collocation or interpolation method; approximating a parabola by linear functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:global:Lagrange"> Lagrange polynomials; motivation and ideas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec40"> Lagrange polynomials; formula and code </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Lagrange polynomials; successful example </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> Lagrange polynomials; a less successful example </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec43"> Lagrange polynomials; oscillatory behavior </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec44"> Lagrange polynomials; remedy for strong oscillations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec45"> Lagrange polynomials; recalculation with Chebyshev nodes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> Lagrange polynomials; less oscillations with Chebyshev nodes </a><br>
<a href="#fem:approx:fe"> Finite element basis functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> So far: basis functions have been global </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> In the finite element method we use basis functions with local support </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> The linear combination of hat functions is a piecewise linear function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:fe:def:elements:nodes"> Elements and nodes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec52"> Example on elements with two nodes (P1 elements) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Illustration of two basis functions on the mesh </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec54"> Example on elements with three nodes (P2 elements) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec55"> Some corresponding basis functions (P2 elements) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec56"> Examples on elements with four nodes per element (P3 elements) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec57"> Some corresponding basis functions (P3 elements) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec58"> The numbering does not need to be regular from left to right </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec59"> Interpretation of the coefficients \( c_i \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec60"> Properties of the basis functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec61"> How to construct quadratic \( \basphi_i \) (P2 elements) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec62"> Example on linear \( \basphi_i \) (P1 elements) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec63"> Example on cubic \( \basphi_i \) (P3 elements) </a><br>
<a href="#fem:approx:global:linearsystem"> Calculating the linear system for \( c_i \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec65"> Computing a specific matrix entry (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec66"> Computing a specific matrix entry (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec67"> Calculating a general row in the matrix; figure </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec68"> Calculating a general row in the matrix; details </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec69"> Calculation of the right-hand side </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec70"> Specific example: two elements; linear system and solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec71"> Specific example: two elements; plot </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec72"> Specific example: what about four elements? </a><br>
<a href="#fem:approx:fe:elementwise"> Assembly of elementwise computations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec74"> Split the integrals into elementwise integrals </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec75"> The element matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec76"> Illustration of the matrix assembly: regularly numbered P1 elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec77"> Illustration of the matrix assembly: regularly numbered P3 elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec78"> Illustration of the matrix assembly: irregularly numbered P1 elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec79"> Assembly of the right-hand side </a><br>
<a href="#fem:approx:fe:mapping"> Mapping to a reference element </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec81"> Affine mapping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec82"> Integral transformation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec83"> Advantages of the reference element </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec84"> Standardized basis functions for P1 elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec85"> Standardized basis functions for P2 elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:fe:intg:ref"> Integration over a reference element; element matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec87"> Integration over a reference element; element vector </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec88"> Tedious calculations! Let's use symbolic software </a><br>
<a href="#___sec89"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec90"> Compute finite element basis functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec91"> Compute the element matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec92"> Example on symbolic and numeric element matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec93"> Compute the element vector </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec94"> Fallback on numerical integration if symbolic integration fails </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec95"> Linear system assembly and solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec96"> Linear system solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec97"> Example on computing approximations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:fe:A:structure"> The structure of the coefficient matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec99"> General result: the coefficient matrix is sparse </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec100"> Exemplifying the sparsity for P2 elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec101"> Matrix sparsity pattern for regular/random numbering of P1 elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec102"> Matrix sparsity pattern for regular/random numbering of P3 elements </a><br>
&nbsp; &nbsp; &nbsp; <a href="#fem:approx:fe:impl:sparse"> Sparse matrix storage and solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec104"> Approximate \( f\sim x^9 \) by various elements; code </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec105"> Approximate \( f\sim x^9 \) by various elements; plot </a><br>
<a href="#fem:approx:fe:fd"> Comparison of finite element and finite difference approximation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec107"> Interpolation/collocation with finite elements </a><br>

<p>
<!-- !split -->

<h2>Why finite elements?  <a name="___sec0"></a></h2>

<p>

<ul>
 <p><li> Can with ease solve PDEs in domains with <em>complex geometry</em></li>
 <p><li> Can with ease provide higher-order approximations</li>
 <p><li> Has (in simpler stationary problems) a rigorus mathematical
   analysis framework (not much considered here)
<!-- The theoretical framework is not powerful enough to uncover the -->
<!-- serious limitations of the method in time-dependent problems -->
<!-- and the necessary adjustments) --></li>
</ul>

<!-- !split -->

<h3>Domain for flow around a dolphin  <a name="___sec1"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_mesh.png" align="bottom" width=400,></p></center>

<p>
<!-- !split -->

<h3>The flow  <a name="___sec2"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_flow.gif" align="bottom" width=400,></p></center>

<p>
<!-- !split -->

<h3>Basic ingredients of the finite element method  <a name="___sec3"></a></h3>

<p>

<ul>
 <p><li> Transform the PDE problem to a <em>variational form</em></li>
 <p><li> Define function approximation over <em>finite elements</em></li>
 <p><li> Use a machinery to derive <em>linear systems</em></li>
 <p><li> Solve linear systems</li>
</ul>

<!-- !split -->

<h3>Our learning strategy  <a name="___sec4"></a></h3>

<p>

<ul>
 <p><li> Start with approximation of functions, not PDEs</li>
 <p><li> Introduce finite element <em>approximations</em></li>
 <p><li> See later how this is applied to PDEs</li>
</ul>

Reason: the finite element method has many concepts and a jungle of details.
This strategy minimizes the mixing of ideas, concepts, and technical details.

<p>
<!-- !split -->

<h3>Approximation set-up  <a name="___sec5"></a></h3>

<p>
General idea:

<p>
$$
\begin{equation}
 u(x) = \sum_{i=0}^N c_i\baspsi_i(x),
\label{fem:u}
\end{equation}
$$


<p>
where

<p>

<ul>
 <p><li> \( \baspsi_i(x) \) are prescribed functions</li>
 <p><li> \( c_i \), \( i=0,\ldots,N \) are unknown coefficients to be determined</li>
</ul>

<!-- !split -->

<h3>How to determine the coefficients?  <a name="___sec6"></a></h3>

<p>

<ul>
 <p><li> least squares method</li>
 <p><li> projection or Galerkin method</li>
 <p><li> interpolation (or collocation) method</li>
</ul>

<div class="alert alert-block alert-block alert-text-normal"><b>Underlying motivation for our notation.</b>
Our mathematical framework for doing this is phrased in a way such
that it becomes easy to understand and use the <a href="http://fenicsproject.org">FEniCS</a> software package for finite element computing.
</div>
<p>
<!-- !split -->

<h3>Approximation of planar vectors; problem <a name="fem:approx:vec:plane"></a></h3>

<p>
Given a vector \( \f = (3,5) \), find an approximation
to \( \f \) directed along a given line.

<p>
<center><p><img src="fig-fem/vecapprox_plane.png" align="bottom" width=200></p></center>

<p>
<!-- !split -->

<h3>Approximation of planar vectors; vector space terminology  <a name="___sec8"></a></h3>

<p>
$$
\begin{equation}
V = \mbox{span}\,\{ \psib_0\}\tp  \end{equation}
$$


<p>

<ul>
 <p><li> \( \psib_0 \) is a basis vector in the space \( V \)</li>
 <p><li> Seek \( \u = c_0\psib_0\in V \)</li>
 <p><li> Determine \( c_0 \) such that \( \u \) is the "best" approximation to \( \f \)</li>
 <p><li> Visually, "best" is obvious</li>
</ul>

Define

<p>

<ul>
 <p><li> the error \( \e = \f - \u \)</li>
 <p><li> the (Eucledian) scalar product of two vectors: \( (\u,\v) \)</li>
 <p><li> the norm of \( \e \): \( ||\e|| = \sqrt{(\e, \e)} \)</li>
</ul>

<!-- !split -->

<h3>The least squares method; principle  <a name="___sec9"></a></h3>

<p>

<ul>
 <p><li> Idea: find \( c_0 \) such that \( ||\e|| \) is minimized</li>
 <p><li> Actually, we always minimize \( E=||\e||^2 \)</li>
</ul>

$$
\begin{equation*}
\frac{\partial E}{\partial c_0} = 0
\tp  \end{equation*}
$$


<p>
<!-- !split -->

<h3>The least squares method; calculations  <a name="___sec10"></a></h3>

<p>
$$
\begin{equation}
E(c_0) = (\e,\e) = (\f,\f) - 2c_0(\f,\psib_0) + c_0^2(\psib_0,\psib_0)
\end{equation}
$$


<p>
$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\psib_0) + 2c_0 (\psib_0,\psib_0) = 0
\label{fem:vec:dEdc0:v1}
\end{equation}
$$


<p>
$$
\begin{equation}
c_0 = \frac{(\f,\psib_0)}{(\psib_0,\psib_0)}
\label{fem:vec:c0}
\end{equation}
$$


<p>
$$
\begin{equation}
c_0 = \frac{3a + 5b}{a^2 + b^2}
\end{equation}
$$


<p>
Observation for later: the vanishing derivative \eqref{fem:vec:dEdc0:v1}
can be alternatively written as

<p>
$$
\begin{equation}
(\e, \psib_0) = 0
\tp
\label{fem:vec:dEdc0:Galerkin}
\end{equation}
$$


<p>
<!-- !split -->

<h3>The projection (or Galerkin) method  <a name="___sec11"></a></h3>

<p>

<ul>
 <p><li> Backgrund: minimizing \( ||\e||^2 \) implies that \( \e \) is
   orthogonal to <em>any</em> vector \( \v \) in the space \( V \)
   (visually clear, but can easily be computed too)</li>
 <p><li> Alternative idea: demand \( (\e, \v) = 0,\quad\forall\v\in V \)</li>
 <p><li> Equivalent statement: \( (\e, \psib_0)=0 \) (see notes for why)</li>
 <p><li> Insert \( \e = \f - c_0\psib_0 \) and solve for \( c_0 \)</li>
 <p><li> Same equation for \( c_0 \) and hence same solution as in the least squares
   method</li>
</ul>

<!-- !split -->

<h3>Approximation of general vectors <a name="fem:approx:vec:Np1dim"></a></h3>

<p>
Given a vector \( \f \), find an approximation \( \u\in V \):

<p>
$$
\begin{equation*}
V = \hbox{span}\,\{\psib_0,\ldots,\psib_N\}
\tp
\end{equation*}
$$


<p>

<ul>
 <p><li> We have a set of linearly independent basis vectors
   \( \psib_0,\ldots,\psib_N \)</li>
 <p><li> Any \( \u\in V \) can then be written as \( \u = \sum_{j=0}^Nc_j\psib_j \)</li>
</ul>

<!-- !split -->

<h3>The least squares method  <a name="___sec13"></a></h3>

<p>
Idea: find \( c_0,\ldots,c_N \) such that \( E= ||\e||^2 \) is minimized, \( \e=\f-\u \).

<p>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\psib_j,\f -\sum_jc_j\psib_j)
\nonumber\\ 
&= (\f,\f) - 2\sum_{j=0}^Nc_j(\f,\psib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)\tp
\end{align*}
$$


<p>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\tp
\end{equation*}
$$


<p>
After some work we end up with a <em>linear system</em>

<p>
$$
\begin{align}
\sum_{j=0}^N A_{i,j}c_j &= b_i,\quad i=0,\ldots,N\\ 
A_{i,j} &= (\psib_i,\psib_j)\\ 
b_i &= (\psib_i, \f)
\end{align}
$$


<p>
<!-- !split -->

<h3>The projection (or Galerkin) method  <a name="___sec14"></a></h3>

<p>
Can be shown that minimizing \( ||\e|| \) implies that
\( \e \) is orthogonal to all \( \v\in V \):

<p>
$$
(\e,\v)=0,\quad \forall\v\in V,
$$

which implies that \( \e \) most be orthogonal to each basis vector:

<p>
$$
\begin{equation}
(\e,\psib_i)=0,\quad i=0,\ldots,N\tp
\label{fem:approx:vec:Np1dim:Galerkin0}
\end{equation}
$$


<p>
This orthogonality condition is the principle of the projection
(or Galerkin) method. Leads to
the same linear system as in the least squares method.

<p>
<!-- !split -->

<h2>Approximation of functions <a name="fem:approx:global"></a></h2>

<p>
Let \( V \) be a <em>function space</em> spanned by a set of <em>basis functions</em>
\( \baspsi_0,\ldots,\baspsi_N \),

<p>
$$
\begin{equation*}
V = \hbox{span}\,\{\baspsi_0,\ldots,\baspsi_N\},\end{equation*}
$$


<p>
Find \( u\in V \) as a linear
combination of the basis functions:

<p>
$$
\begin{equation}
u = \sum_{j\in\If} c_j\baspsi_j,\quad\If = \{0,1,\ldots,N\}
\label{fem:approx:ufem}
\end{equation}
$$


<p>
<!-- !split -->

<h3>The least squares method <a name="fem:approx:LS"></a></h3>

<p>

<ul>
 <p><li> Extend the ideas from the vector case: minimize the (square) norm
   of the error.</li>
 <p><li> What norm? \( (f,g) = \int_\Omega f(x)g(x)\, dx \)</li>
</ul>

$$
\begin{equation}
E = (e,e) = (f-u,f-u) = (f(x)-\sum_{j\in\If} c_j\baspsi_j(x), f(x)-\sum_{j\in\If} c_j\baspsi_j(x))
\label{fem:approx:LS:E}
\end{equation}
$$


<p>
$$
\begin{equation}
E(c_0,\ldots,c_N) = (f,f) -2\sum_{j\in\If} c_j(f,\baspsi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\baspsi_p,\baspsi_q)
\end{equation}
$$


<p>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=\in\If
\end{equation*}
$$


<p>
After computations <em>identical to the vector case</em>, we get a linear system

<p>
$$
\begin{align}
\sum_{j\in\If}^N A_{i,j}c_j &= b_i,\quad i\in\If
\label{fem:approx:vec:Np1dim:eqsys}\\ 
A_{i,j} &= (\baspsi_i,\baspsi_j)
\label{fem:approx:Aij}\\ 
b_i &= (f,\baspsi_i)
\label{fem:approx:bi}
\end{align}
$$


<p>
<!-- !split -->

<h3>The projection (or Galerkin) method  <a name="___sec17"></a></h3>

<p>
As before, minimizing \( (e,e) \) is equivalent to the projection (or Galerkin)
method

<p>
$$
\begin{equation}
(e,v)=0,\quad\forall v\in V,
\label{fem:approx:Galerkin}
\end{equation}
$$

which means, as before,

<p>
$$
\begin{equation}
(e,\baspsi_i)=0,\quad i\in\If\tp
\label{fem:approx:Galerkin0}
\end{equation}
$$


<p>
With the same algebra as in the multi-dimensional vector case,
we get the same linear system as arose from the least squares method.

<p>
<!-- !split -->

<h3>Example: linear approximation; problem <a name="fem:approx:global:linear"></a></h3>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b>Problem.</b>
Approximate a parabola \( f(x) = 10(x-1)^2 - 1 \) by a straight line.
</div>
<p>
$$
\begin{equation*} V = \hbox{span}\,\{1, x\}\tp  \end{equation*}
$$

That is, \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=x \), and \( N=1 \).
We seek

<p>
$$
\begin{equation*}
u=c_0\baspsi_0(x) + c_1\baspsi_1(x) = c_0 + c_1x,\end{equation*}
$$


<p>
<!-- !split -->

<h3>Example: linear approximation; solution  <a name="___sec19"></a></h3>

<p>
$$
\begin{align}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_1^21\cdot 1\, dx = 1\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_1^2 1\cdot x\, dx = 3/2\\ 
A_{1,0} &= A_{0,1} = 3/2,\\ 
A_{1,1} &= (\baspsi_1,\baspsi_1) = \int_1^2 x\cdot x\,dx = 7/3
\end{align}
$$


<p>
$$
\begin{align}
b_1 &= (f,\baspsi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3\\ 
b_2 &= (f,\baspsi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3
\end{align}
$$

Solution of 2x2 linear system:

<p>
$$
\begin{equation}
c_0 = -38/3,\quad c_1 = 10,\quad u(x) = 10x - \frac{38}{3}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Example: linear approximation; plot  <a name="___sec20"></a></h3>

<p>
<center><p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p></center>

<p>
<!-- !split -->

<h3>Implementation of the least squares method; ideas <a name="fem:approx:global:LS:code"></a></h3>

<p>
Consider symbolic computation of the linear system,
where

<p>

<ul>
 <p><li> \( f(x) \) is given as a <code>sympy</code> expression <code>f</code> (involving
   the symbol <code>x</code>),</li>
 <p><li> <code>phi</code> is a list of \( \sequencei{\baspsi} \),</li>
 <p><li> <code>Omega</code> is a 2-tuple/list holding the domain \( \Omega \)</li>
</ul>

Carry out the integrations, solve the linear system, and
return \( u(x)=\sum_jc_j\baspsi_j(x) \)

<p>
<!-- !split -->

<h3>Implementation of the least squares method; code  <a name="___sec22"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sm</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">least_squares</span>(f, phi, Omega):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i, N<span style="color: #666666">+1</span>):
            A[i,j] <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(phi[i]<span style="color: #666666">*</span>phi[j],
                                  (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
            A[j,i] <span style="color: #666666">=</span> A[i,j]
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(phi[i]<span style="color: #666666">*</span>f, (x, Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>]))
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(phi)):
        u <span style="color: #666666">+=</span> c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>phi[i]
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
Observe: symmetric coefficient matrix so we can halve the integrations.

<p>
<!-- !split -->

<h3>Implementation of the least squares method; plotting  <a name="___sec23"></a></h3>

<p>
Compare \( f \) and \( u \) visually:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">comparison_plot</span>(f, u, Omega, filename<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp.pdf&#39;</span>):
    x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #408080; font-style: italic"># Turn f and u to ordinary Python functions</span>
    f <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>lambdify([x], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&quot;numpy&quot;</span>)
    u <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>lambdify([x], u, modules<span style="color: #666666">=</span><span style="color: #BA2121">&quot;numpy&quot;</span>)
    resolution <span style="color: #666666">=</span> <span style="color: #666666">401</span>  <span style="color: #408080; font-style: italic"># no of points in plot</span>
    xcoor  <span style="color: #666666">=</span> linspace(Omega[<span style="color: #666666">0</span>], Omega[<span style="color: #666666">1</span>], resolution)
    exact  <span style="color: #666666">=</span> f(xcoor)
    approx <span style="color: #666666">=</span> u(xcoor)
    plot(xcoor, approx)
    hold(<span style="color: #BA2121">&#39;on&#39;</span>)
    plot(xcoor, exact)
    legend([<span style="color: #BA2121">&#39;approximation&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>])
    savefig(filename)
</pre></div>
<p>
All code in module <a href="http://tinyurl.com/jvzzcfn/fem/approx1D.py"><tt>approx1D.py</tt></a>

<p>
<!-- !split -->

<h3>Implementation of the least squares method; application  <a name="___sec24"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2-1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> least_squares(f<span style="color: #666666">=</span>f, phi<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, x], Omega<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> comparison_plot(f, u, Omega<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
</pre></div>
<p>
<center><p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p></center>

<p>
<!-- !split -->

<h3>Perfect approximation; parabola approximating parabola <a name="fem:approx:global:exact"></a></h3>

<p>

<ul>
 <p><li> What if we add \( \baspsi_2=x^2 \) to the space \( V \)?</li>
 <p><li> That is, approximating a parabola by any parabola?</li>
 <p><li> (Hopefully we get the exact parabola!)</li>
</ul>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">approx1D</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2-1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> least_squares(f<span style="color: #666666">=</span>f, phi<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, x, x<span style="color: #666666">**2</span>], Omega<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, <span style="color: #666666">2</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> u
<span style="color: #666666">10*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x <span style="color: #666666">+</span> <span style="color: #666666">9</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> sm<span style="color: #666666">.</span>expand(f)
<span style="color: #666666">10*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">20*</span>x <span style="color: #666666">+</span> <span style="color: #666666">9</span>
</pre></div>
<p>
<!-- !split -->

<h3>Perfect approximation; the general result  <a name="___sec26"></a></h3>

<p>

<ul>
 <p><li> What if we use \( \phi_i(x)=x^i \) for \( i=0,\ldots,N=40 \)?</li>
 <p><li> The output from <code>least_squares</code> is \( c_i=0 \) for \( i>2 \)</li>
</ul>

<div class="alert alert-block alert-block alert-text-normal"><b>General result.</b>
If \( f\in V \), least squares and projection/Galerkin give \( u=f \).
</div>
<p>
<!-- !split -->

<h3>Perfect approximation; proof of the general result  <a name="___sec27"></a></h3>

<p>
If \( f\in V \), \( f=\sum_{j\in\If}d_j\baspsi_j \), for
some  \( \sequencei{d} \). Then

<p>
$$
\begin{equation*}
b_i = (f,\baspsi_i) = \sum_{j\in\If}d_j(\baspsi_j, \baspsi_i)
= \sum_{j\in\If} d_jA_{i,j}\tp
\end{equation*}
$$

The linear system \( \sum_j A_{i,j}c_j = b_i \), \( i\in\If \), is then

<p>
$$
\begin{equation*}
\sum_{j\in\If}c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},\quad i\in\If,
\end{equation*}
$$

which implies that \( c_i=d_i \) for \( i\in\If \) and \( u \) is identical to \( f \).

<p>
<!-- !split -->

<h3>Finite-precision/numerical computations <a name="fem:approx:global:illconditioning"></a></h3>

<p>
The previous computations were symbolic. What if we solve the
linear system numerically with standard arrays?

<p>
<table border="1">
<tr><td align="center"><b>        exact         </b></td> <td align="center"><b>  <code>sympy</code>  </b></td> <td align="center"><b> <code>numpy32</code> </b></td> <td align="center"><b> <code>numpy64</code> </b></td> </tr>
<tr><td align="right">   9                       </td> <td align="right">   9.62                    </td> <td align="right">   5.57                    </td> <td align="right">   8.98                    </td> </tr>
<tr><td align="right">   -20                     </td> <td align="right">   -23.39                  </td> <td align="right">   -7.65                   </td> <td align="right">   -19.93                  </td> </tr>
<tr><td align="right">   10                      </td> <td align="right">   17.74                   </td> <td align="right">   -4.50                   </td> <td align="right">   9.96                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -9.19                   </td> <td align="right">   4.13                    </td> <td align="right">   -0.26                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   5.25                    </td> <td align="right">   2.99                    </td> <td align="right">   0.72                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.18                    </td> <td align="right">   -1.21                   </td> <td align="right">   -0.93                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -2.48                   </td> <td align="right">   -0.41                   </td> <td align="right">   0.73                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   1.81                    </td> <td align="right">   -0.013                  </td> <td align="right">   -0.36                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.66                   </td> <td align="right">   0.08                    </td> <td align="right">   0.11                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.12                    </td> <td align="right">   0.04                    </td> <td align="right">   -0.02                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.001                  </td> <td align="right">   -0.02                   </td> <td align="right">   0.002                   </td> </tr>
</table>
<p>

<ul>
  <p><li> Column 2: <code>sympy.mpmath.fp.matrix</code> and <code>sympy.mpmath.fp.lu_solve</code></li>
  <p><li> Column 3: <code>numpy</code> arrays with <code>numpy.float32</code> entries</li>
  <p><li> Column 4: <code>numpy</code> arrays with <code>numpy.float64</code> entries</li>
</ul>

<!-- !split -->

<h3>Ill-conditioning (1)  <a name="___sec29"></a></h3>

<p>
Observations:

<p>

<ul>
 <p><li> Significant round-off errors in the numerical computations (!)</li>
 <p><li> But if we plot the approximations they look good (!)</li>
</ul>

Problem: The basis functions \( x^i \) become almost linearly dependent for
large \( N \).

<p>
<center><p><img src="fig-fem/ill_conditioning.png" align="bottom" width=400></p></center>

<p>
<!-- !split -->

<h3>Ill-conditioning (2)  <a name="___sec30"></a></h3>

<p>

<ul>
  <p><li> Almost linearly dependent basis functions give almost singular matrices</li>
  <p><li> Such matrices are said to be <em>ill conditioned</em>, and Gaussian elimination
    is severely affected by round-off errors</li>
  <p><li> The basis \( 1, x, x^2, x^3, x^4, \ldots \) is a bad basis</li>
  <p><li> Polynomials are fine as basis, but the more orthogonal they are,
    \( (\baspsi_i,\baspsi_j)\approx 0 \), the better</li>
</ul>

<!-- !split -->

<h3>Fourier series approximation; problem and code <a name="fem:approx:global:Fourier"></a></h3>

<p>
Consider

<p>
$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\tp  \end{equation*}
$$


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">N <span style="color: #666666">=</span> <span style="color: #666666">3</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> sin, pi
phi <span style="color: #666666">=</span> [sin(pi<span style="color: #666666">*</span>(i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
f <span style="color: #666666">=</span> <span style="color: #666666">10*</span>(x<span style="color: #666666">-1</span>)<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">1</span>
Omega <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>]
u <span style="color: #666666">=</span> least_squares(f, phi, Omega)
comparison_plot(f, u, Omega)
</pre></div>
<p>
<!-- !split -->

<h3>Fourier series approximation; plot  <a name="___sec32"></a></h3>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-fem/parabola_ls_sines4_12.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h3>Fourier series approximation; improvements  <a name="___sec33"></a></h3>

<p>

<ul>
 <p><li> Considerably improvement by \( N=11 \)</li>
 <p><li> But always discrepancy of \( f(0)-u(0)=9 \) at \( x=0 \), because all the
   \( \baspsi_i(0)=0 \) and hence \( u(0)=0 \)</li>
 <p><li> Possible remedy: add a term that leads to correct boundary values</li>
</ul>

$$
\begin{equation}
u(x) = f(0)(1-x) + xf(1) + \sum_{j\in\If} c_j\baspsi_j(x)
\tp
\end{equation}
$$

The extra term ensures \( u(0)=f(0) \) and \( u(1)=f(1) \) and
is a strikingly good help to get a good
approximation!

<p>
<!-- !split -->

<h3>Fourier series approximation; final results  <a name="___sec34"></a></h3>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-fem/parabola_ls_sines4_12_wfterm.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h3>Orthogonal basis functions  <a name="___sec35"></a></h3>

<p>
This choice of sine functions as basis functions is popular because

<p>

<ul>
 <p><li> the basis functions are orthogonal: \( (\baspsi_i,\baspsi_j)=0 \)</li>
 <p><li> implying that \( A_{i,j} \) is a diagonal matrix</li>
 <p><li> implying that we can solve for \( c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx \)</li>
</ul>

In general for an orthogonal basis, \( A_{i,j} \) is diagonal and we can
easily solve for \( c_i \):

<p>
$$
c_i = \frac{b_i}{A_{i,i}} = \frac{(f,\baspsi_i)}{(\baspsi_i,\baspsi_i)}
\tp
$$


<p>
<!-- !split -->

<h3>The collocation or interpolation method; ideas and math <a name="fem:approx:global:interp"></a></h3>

<p>
Here is another idea for approximating \( f(x) \) by \( u(x)=\sum_jc_j\baspsi_j \):

<p>

<ul>
 <p><li> Force \( u(\xno{i}) = f(\xno{i}) \) at some selected <em>collocation</em> points
   \( \sequencei{x} \)</li>
 <p><li> Then \( u \) interpolates \( f \)</li>
 <p><li> The method is known as <em>interpolation</em> or <em>collocation</em></li>
</ul>

$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i}),
\quad i\in\If,N\tp
\end{equation}
$$


<p>
This is a linear system with no need for integration:

<p>
$$
\begin{align}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If\\ 
A_{i,j} &= \baspsi_j(\xno{i})\\ 
b_i &= f(\xno{i})
\end{align}
$$


<p>
No symmetric matrix: \( \baspsi_j(\xno{i})\neq \baspsi_i(\xno{j}) \) in general

<p>
<!-- !split -->

<h3>The collocation or interpolation method; implementation  <a name="___sec37"></a></h3>

<p>
<code>points</code> holds the interpolation/collocation points

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">interpolation</span>(f, phi, points):
    N <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi) <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, N<span style="color: #666666">+1</span>))
    b <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, <span style="color: #666666">1</span>))
    x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
    <span style="color: #408080; font-style: italic"># Turn phi and f into Python functions</span>
    phi <span style="color: #666666">=</span> [sm<span style="color: #666666">.</span>lambdify([x], phi[i]) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>)]
    f <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>lambdify([x], f)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">+1</span>):
            A[i,j] <span style="color: #666666">=</span> phi[j](points[i])
        b[i,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> f(points[i])
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
    u <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(phi)):
        u <span style="color: #666666">+=</span> c[i,<span style="color: #666666">0</span>]<span style="color: #666666">*</span>phi[i](x)
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
<!-- !split -->

<h3>The collocation or interpolation method; approximating a parabola by linear functions  <a name="___sec38"></a></h3>

<p>

<ul>
 <p><li> Potential difficulty: how to choose \( \xno{i} \)?</li>
 <p><li> The results are sensitive to the points!</li>
</ul>

\( (4/3,5/3) \) vs \( (1,2) \):

<p>
<center><p><img src="fig-fem/parabola_inter.png" align="bottom" width=700,></p></center>

<p>
<!-- !split -->

<h3>Lagrange polynomials; motivation and ideas <a name="fem:approx:global:Lagrange"></a></h3>

<p>
Motivation:

<p>

<ul>
 <p><li> The interpolation/collocation method avoids integration</li>
 <p><li> With a diagonal matrix \( A_{i,j} = \baspsi_j(\xno{i}) \) we
   can solve the linear system by hand</li>
</ul>

The <em>Lagrange interpolating polynomials</em> \( \baspsi_j \) have the property that

<p>
$$ \basphi_i(\xno{j}) =\delta_{ij},\quad \delta_{ij} =
\left\lbrace\begin{array}{ll}
1, & i=j,\\ 
0, & i\neq j,
\end{array}\right.
$$


<p>
Hence, \( c_i = f(x_i) \) and

<p>
$$
\begin{equation}
u(x) = \sum_{j\in\If} f(\xno{i})\baspsi_i(x)
\end{equation}
$$


<p>

<ul>
 <p><li> Lagrange polynomials and interpolation/collocation look convenient</li>
 <p><li> Lagrange polynomials are very much used in the finite element method</li>
</ul>

<!-- !split -->

<h3>Lagrange polynomials; formula and code  <a name="___sec40"></a></h3>

<p>
$$
\begin{equation}
\baspsi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N},
\label{fem:approx:global:Lagrange:poly}
\end{equation}
$$


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Lagrange_polynomial</span>(x, i, points):
    p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(points)):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #666666">!=</span> i:
            p <span style="color: #666666">*=</span> (x <span style="color: #666666">-</span> points[k])<span style="color: #666666">/</span>(points[i] <span style="color: #666666">-</span> points[k])
    <span style="color: #008000; font-weight: bold">return</span> p
</pre></div>
<p>
<!-- !split -->

<h3>Lagrange polynomials; successful example  <a name="___sec41"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_ls_interp_sin_4.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h3>Lagrange polynomials; a less successful example  <a name="___sec42"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_interp_abs_8_15.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h3>Lagrange polynomials; oscillatory behavior  <a name="___sec43"></a></h3>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-fem/Lagrange_basis_12.png" align="bottom" width=500></p></center>

<p>
Problem: strong oscillations near the boundaries for larger \( N \) values.

<p>
<!-- !split -->

<h3>Lagrange polynomials; remedy for strong oscillations  <a name="___sec44"></a></h3>

<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

<p>
$$
\begin{equation}
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N,
\end{equation}
$$

on an interval \( [a,b] \).

<p>
<!-- !split -->

<h3>Lagrange polynomials; recalculation with Chebyshev nodes  <a name="___sec45"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h3>Lagrange polynomials; less oscillations with Chebyshev nodes  <a name="___sec46"></a></h3>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-fem/Lagrange_basis_Cheb_12.png" align="bottom" width=500></p></center>

<p>
<!-- !split -->

<h2>Finite element basis functions <a name="fem:approx:fe"></a></h2>

<p>
<!-- !split -->

<h3>So far: basis functions have been global  <a name="___sec48"></a></h3>

<p>
\( \baspsi_i(x) \neq 0 \) for most \( x\in\Omega \)

<p>
<center><p><img src="fig-fem/u_example_sin.png" align="bottom" width=600></p></center>

<p>
<!-- !split -->

<h3>In the finite element method we use basis functions with local support  <a name="___sec49"></a></h3>

<p>

<ul>
 <p><li> <em>Local support</em>: \( \baspsi_i(x) \neq 0 \) for \( x \) in a
   small subdomain of \( \Omega \)</li>
 <p><li> Typically hat-shaped</li>
 <p><li> \( u(x) \) based on these \( \baspsi_i \) is a piecewise polynomial
   defined over many (small) subdomains</li>
</ul>

<!-- !split -->

<h3>The linear combination of hat functions is a piecewise linear function  <a name="___sec50"></a></h3>

<p>
<center><p><img src="fig-fem/u_example_fe2.png" align="bottom" width=600></p></center>

<p>
<!-- !split -->

<h3>Elements and nodes <a name="fem:approx:fe:def:elements:nodes"></a></h3>

<p>
Split \( \Omega \) into non-overlapping subdomains called <em>elements</em>:

<p>
$$
\begin{equation}
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(N_e)}\tp  \end{equation}
$$


<p>
On each element, introduce points called <em>nodes</em>: \( \xno{0},\ldots,\xno{N_n} \)

<p>

<ul>
 <p><li> The finite element basis functions are named \( \basphi_i(x) \)</li>
 <p><li> \( \basphi_i=1 \) at node \( i \) and 0 at all other nodes</li>
 <p><li> \( \basphi_i \) is a Lagrange polynomial on each element</li>
 <p><li> For nodes at the boundary between two elements, \( \basphi_i \) is made
   up of a Lagrange polynomial over each element</li>
</ul>

<!-- !split -->

<h3>Example on elements with two nodes (P1 elements)  <a name="___sec52"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D.png" align="bottom" width=500></p></center>

<p>
Data structure: <code>nodes</code> holds coordinates or nodes, <code>elements</code> holds the
node numbers in each element

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">1.2</span>, <span style="color: #666666">2.4</span>, <span style="color: #666666">3.6</span>, <span style="color: #666666">4.8</span>, <span style="color: #666666">5</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>], [<span style="color: #666666">3</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>]]
</pre></div>
<p>
<!-- !split -->

<h3>Illustration of two basis functions on the mesh  <a name="___sec53"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>
<!-- !split -->

<h3>Example on elements with three nodes (P2 elements)  <a name="___sec54"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_P2.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.125</span>, <span style="color: #666666">0.25</span>, <span style="color: #666666">0.375</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0.625</span>, <span style="color: #666666">0.75</span>, <span style="color: #666666">0.875</span>, <span style="color: #666666">1.0</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>, <span style="color: #666666">6</span>], [<span style="color: #666666">6</span>, <span style="color: #666666">7</span>, <span style="color: #666666">8</span>]]
</pre></div>
<p>
<!-- !split -->

<h3>Some corresponding basis functions (P2 elements)  <a name="___sec55"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p></center>

<p>
<!-- !split -->

<h3>Examples on elements with four nodes per element (P3 elements)  <a name="___sec56"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_d4_stretched.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">d <span style="color: #666666">=</span> <span style="color: #666666">3</span>  <span style="color: #408080; font-style: italic"># d+1 nodes per element</span>
num_elements <span style="color: #666666">=</span> <span style="color: #666666">4</span>
num_nodes <span style="color: #666666">=</span> num_elements<span style="color: #666666">*</span>d <span style="color: #666666">+</span> <span style="color: #666666">1</span>
nodes <span style="color: #666666">=</span> [i<span style="color: #666666">*0.5</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_nodes)]
elements <span style="color: #666666">=</span> [[i<span style="color: #666666">*</span>d<span style="color: #666666">+</span>j <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>)] <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_elements)]
</pre></div>
<p>
<!-- !split -->

<h3>Some corresponding basis functions (P3 elements)  <a name="___sec57"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600></p></center>

<p>
<!-- !split -->

<h3>The numbering does not need to be regular from left to right  <a name="___sec58"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_random_numbering.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nodes <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">5.5</span>, <span style="color: #666666">4.2</span>, <span style="color: #666666">0.3</span>, <span style="color: #666666">2.2</span>, <span style="color: #666666">3.1</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">3</span>, <span style="color: #666666">0</span>], [<span style="color: #666666">5</span>, <span style="color: #666666">2</span>]]
</pre></div>
<p>
<!-- !split -->

<h3>Interpretation of the coefficients \( c_i \)  <a name="___sec59"></a></h3>

<p>
Important property: \( c_i \)
is the value of \( u \) at node \( i \), \( \xno{i} \):

<p>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) =
c_i\basphi_i(\xno{i}) = c_i
\label{fem:approx:fe:phi:prop1}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Properties of the basis functions  <a name="___sec60"></a></h3>

<p>
\( \basphi_i(x) \) is mostly zero throughout the domain:

<p>

<ul>
 <p><li> \( \basphi_i(x) \neq 0 \) only on those elements that contain global node \( i \),</li>
 <p><li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) if and only if \( i \) and \( j \) are global node
   numbers in the same element.</li>
</ul>

Since \( A_{i,j} \) is the integral of
\( \basphi_i\basphi_j \) it means that
<em>most of the elements in the coefficient matrix will be zero</em>
(important for implementation!).

<p>
<!-- !split -->

<h3>How to construct quadratic \( \basphi_i \) (P2 elements)  <a name="___sec61"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p></center>

<p>

<ol>
<p><li> Associate Lagrange polynomials with the nodes in an element</li>
<p><li> When the polynomial is 1 on the element boundary, combine it
   with the polynomial in the neighboring element</li>
</ol>

<!-- !split -->

<h3>Example on linear \( \basphi_i \) (P1 elements)  <a name="___sec62"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=600></p></center>

<p>
$$
\begin{equation}
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
(x - \xno{i-1})/h,
& \xno{i-1} \leq x < \xno{i},\\ 
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\label{fem:approx:fe:phi:1:formula2}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Example on cubic \( \basphi_i \) (P3 elements)  <a name="___sec63"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600,></p></center>

<p>
<!-- !split -->

<h2>Calculating the linear system for \( c_i \) <a name="fem:approx:global:linearsystem"></a></h2>

<p>
<!-- !split -->

<h3>Computing a specific matrix entry (1)  <a name="___sec65"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>
\( A_{2,3}=\int_\Omega\basphi_2\basphi_3 dx \): \( \basphi_2\basphi_3\neq 0 \)
only over element 2. There,

<p>
$$ \basphi_3(x) = (x-x_2)/h,\quad \basphi_2(x) = 1- (x-x_2)/h$$


<p>
$$
A_{2,3} = \int_\Omega \basphi_2\basphi_{3}\dx =
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right) \frac{x - x_{2}}{h}
 \dx = \frac{h}{6}\tp
$$


<p>
<!-- !split -->

<h3>Computing a specific matrix entry (2)  <a name="___sec66"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>
$$ A_{2,2} =
\int_{\xno{1}}^{\xno{2}}
\left(\frac{x - \xno{1}}{h}\right)^2\dx +
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right)^2\dx
= \frac{h}{3}\tp
$$


<p>
<!-- !split -->

<h3>Calculating a general row in the matrix; figure  <a name="___sec67"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_im1.png" align="bottom" width=500></p></center>

<p>
$$ A_{i,i-1} = \int_\Omega \basphi_i\basphi_{i-1}\dx = \hbox{?}$$


<p>
<!-- !split -->

<h3>Calculating a general row in the matrix; details  <a name="___sec68"></a></h3>

<p>
$$
\begin{align*}
A_{i,i-1} &= \int_\Omega \basphi_i\basphi_{i-1}\dx\\ 
&=
\underbrace{\int_{\xno{i-2}}^{\xno{i-1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_i=0} +
\int_{\xno{i}}^{\xno{i}} \basphi_i\basphi_{i-1}\dx +
\underbrace{\int_{\xno{i}}^{\xno{i+1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_{i-1}=0}\\ 
&= \int_{\xno{i-1}}^{\xno{i}}
\underbrace{\frac{x - x_{i}}{h}}_{\basphi_i(x)}
\underbrace{\left(1 - \frac{x - \xno{i-1}}{h}\right)}_{\basphi_{i-1}(x)} \dx =
\frac{h}{6}
\tp
\end{align*}
$$


<p>

<ul>
 <p><li> \( A_{i,i+1}=A_{i,i-1} \) due to symmetry</li>
 <p><li> \( A_{i,i}=h/3 \) (same calculation as for \( A_{2,2} \))</li>
 <p><li> \( A_{0,0}=A_{N,N}=h/3 \) (only one element)</li>
</ul>

<!-- !split -->

<h3>Calculation of the right-hand side  <a name="___sec69"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_f.png" align="bottom" width=500></p></center>

<p>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i(x)f(x)\dx
= \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)\dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)
\dx\tp
\label{fem:approx:fe:bi:formula1}
\end{equation}
$$


<p>
Need a specific \( f(x) \) to do more...

<p>
<!-- !split -->

<h3>Specific example: two elements; linear system and solution  <a name="___sec70"></a></h3>

<p>

<ul>
 <p><li> \( f(x)=x(1-x) \) on \( \Omega=[0,1] \)</li>
 <p><li> Two equal-sized elements \( [0,0.5] \) and \( [0.5,1] \)</li>
</ul>

$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\ 
1 & 4 & 1\\ 
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\ 
12 - 14h\\ 
10 -17h
\end{array}\right)\tp
\end{equation*}
$$


<p>
$$
\begin{equation*} c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2\tp  \end{equation*}
$$


<p>
<!-- !split -->

<h3>Specific example: two elements; plot  <a name="___sec71"></a></h3>

<p>
$$
\begin{equation*} u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)\end{equation*}
$$


<p>
<center><p><img src="fig-fem/fe_p1_x2_2e.png" align="bottom" width=400></p></center>

<p>
<!-- !split -->

<h3>Specific example: what about four elements?  <a name="___sec72"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p1_x2_2e_4e.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h2>Assembly of elementwise computations <a name="fem:approx:fe:elementwise"></a></h2>

<p>
<!-- !split -->

<h3>Split the integrals into elementwise integrals  <a name="___sec74"></a></h3>

<p>
$$
\begin{equation}
A_{i,j} = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} A^{(e)}_{i,j},\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_jdx\tp
\label{fem:approx:fe:elementwise:Asplit}
\end{equation}
$$


<p>
Important:

<p>

<ul>
 <p><li> \( A^{(e)}_{i,j}\neq 0 \) if and only if \( i \) and \( j \) are nodes in element
   \( e \) (otherwise no overlap between the basis functions)</li>
 <p><li> all the nonzero elements in \( A^{(e)}_{i,j} \) are collected in an
   <em>element matrix</em></li>
</ul>

<!-- !split -->

<h3>The element matrix  <a name="___sec75"></a></h3>

<p>
$$
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad r,s\in\Ifd=\{0,\ldots,d\},
$$


<p>
$$
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)}dx,\quad r,s\in\Ifd\tp
$$


<p>

<ul>
 <p><li> \( r,s \) run over <em>local node numbers</em> within an element, while \( i,j \) run
   over <em>global node numbers</em>.</li>
 <p><li> \( i=q(e,r) \): mapping of local node number \( r \) in element
   \( e \) to the global node number \( i \). Math equivalent to <code>i=elements[e][r]</code>.</li>
 <p><li> Add contribution from an element into the global coefficient matrix
   (<em>assembly</em>)</li>
</ul>

$$
\begin{equation}
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s\in\Ifd\tp
\end{equation}
$$


<p>
<!-- !split -->

<h3>Illustration of the matrix assembly: regularly numbered P1 elements  <a name="___sec76"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_regular_2x2/fe_assembly_regular_2x2.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>
<!-- !split -->

<h3>Illustration of the matrix assembly: regularly numbered P3 elements  <a name="___sec77"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_regular_4x4/fe_assembly_regular_4x4.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>
<!-- !split -->

<h3>Illustration of the matrix assembly: irregularly numbered P1 elements  <a name="___sec78"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_irregular/fe_assembly_irregular.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>
<!-- !split -->

<h3>Assembly of the right-hand side  <a name="___sec79"></a></h3>

<p>
Split in elementwise contributions:

<p>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} b^{(e)}_{i},\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)dx\tp  \end{equation}
$$


<p>
Important:

<p>

<ul>
  <p><li> \( b_i^{(e)}\neq 0 \) if and only if global node \( i \) is a node in element \( e \)
    (otherwise \( \basphi_i=0 \))</li>
  <p><li> The \( d+1 \) nonzero \( b_i^{(e)} \) can be collected in an <em>element vector</em></li>
</ul>

$$
\begin{equation*}
\tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\},\quad r\in\Ifd\tp
\end{equation*}
$$


<p>
Assembly:

<p>
$$
\begin{equation}
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r,s\in\Ifd\tp
\end{equation}
$$


<p>
<!-- !split -->

<h2>Mapping to a reference element <a name="fem:approx:fe:mapping"></a></h2>

<p>
Instead of computing

<p>
$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx\end{equation*}
$$

over some element
\( \Omega^{(e)} = [x_L, x_R] \),
we now map \( [x_L, x_R] \) to
a standardized reference element domain \( [-1,1] \) with local coordinate \( X \).

<p>
<!-- !split -->

<h3>Affine mapping  <a name="___sec81"></a></h3>

<p>
$$
\begin{equation}
x = \half (x_L + x_R) + \half (x_R - x_L)X\tp
\label{fem:approx:fe:affine:mapping}
\end{equation}
$$

or rewritten as
$$
\begin{equation}
x = x_m + \frac{1}{2}hX, \qquad x_m=(x_L+x_R)/2
\label{fem:approx:fe:affine:mapping2}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Integral transformation  <a name="___sec82"></a></h3>

<p>
Integrating on
the reference element is a matter of just changing the integration
variable from \( x \) to \( X \). Introduce local basis function

<p>
$$
\begin{equation}
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
\end{equation}
$$

The integral transformation reads

<p>
$$
\begin{equation}
\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\frac{dx}{dX}dX\tp  \end{equation}
$$


<p>
Introduce the notation
\( \det J = dx/dX = h/2 \) (2D/3D must use \( \det J \))

<p>
$$
\begin{equation}
\tilde A^{(e)}_{r,s}
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
\label{fem:approx:fe:mapping:Ae}
\tp
\end{equation}
$$


<p>
$$
\begin{equation}
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
\label{fem:approx:fe:mapping:be}
\tp
\end{equation}
$$


<p>
<!-- !split -->

<h3>Advantages of the reference element  <a name="___sec83"></a></h3>

<p>

<ul>
  <p><li> Always the same domain for integration: \( [-1,1] \)</li>
  <p><li> We only need formulas for \( \refphi_r(X) \) on the reference elements
    (no need for piecewise polynomial definition)</li>
  <p><li> All geometric information (length and location) is "factored out"
    in the mapping and \( \det J \)</li>
</ul>

<!-- !split -->

<h3>Standardized basis functions for P1 elements  <a name="___sec84"></a></h3>

<p>
$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\label{fem:approx:fe:mapping:P1:phi0}\\ 
\refphi_1(X) &= \half (1 + X)
\label{fem:approx:fe:mapping:P1:phi1}
\end{align}
$$


<p>
<!-- !split -->

<h3>Standardized basis functions for P2 elements  <a name="___sec85"></a></h3>

<p>
P2 elements:

<p>
$$
\begin{align}
\refphi_0(X) &= \half (X-1)X\\ 
\refphi_1(X) &= 1 - X^2\\ 
\refphi_2(X) &= \half (X+1)X
\end{align}
$$


<p>
Easy to generalize to arbitrary order!

<p>
<!-- !split -->

<h3>Integration over a reference element; element matrix <a name="fem:approx:fe:intg:ref"></a></h3>

<p>
P1 elements and \( f(x)=x(1-x) \).

<p>
$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1-X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3},
\label{fem:approx:fe:intg:ref:Ae00}\\ 
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6},\\ 
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0},
\label{fem:approx:fe:intg:ref:Ae10}\\ 
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\label{fem:approx:fe:intg:ref:Ae11}
\tp
\end{align}
$$


<p>
<!-- !split -->

<h3>Integration over a reference element; element vector  <a name="___sec87"></a></h3>

<p>
$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1-X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\label{fem:approx:fe:intg:ref:be0}\\ 
\tilde b^{(e)}_{1}
&= \int_{-1}^1 f(x(X))\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1+X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\tp
\end{align}
$$


<p>
\( x_m \): element midpoint.

<p>
<!-- !split -->

<h3>Tedious calculations! Let's use symbolic software  <a name="___sec88"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sm</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x, x_m, h, X <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x x_m h X&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> sm<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/8*</span>(<span style="color: #666666">1-</span>X)<span style="color: #666666">**2</span>, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
h<span style="color: #666666">/3</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sm<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/8*</span>(<span style="color: #666666">1+</span>X)<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>X), (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
h<span style="color: #666666">/6</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> x_m <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>X
<span style="color: #666666">&gt;&gt;&gt;</span> b_0 <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/4*</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>X), (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> b_0
<span style="color: #666666">-</span>h<span style="color: #666666">**3/24</span> <span style="color: #666666">+</span> h<span style="color: #666666">**2*</span>x_m<span style="color: #666666">/6</span> <span style="color: #666666">-</span> h<span style="color: #666666">**2/12</span> <span style="color: #666666">-</span> h<span style="color: #666666">*</span>x_m<span style="color: #666666">**2/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">*</span>x_m<span style="color: #666666">/2</span>
</pre></div>
<p>
Can printe out in LaTeX too (convenient for copying into reports):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> sm<span style="color: #666666">.</span>latex(b_0, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>)
<span style="color: #666666">-</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">24</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">3</span>} <span style="color: #666666">+</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">6</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">2</span>} x_{m}
<span style="color: #666666">-</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">12</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">2</span>} <span style="color: #666666">-</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">2</span>} h x_{m}<span style="color: #666666">^</span>{<span style="color: #666666">2</span>}
<span style="color: #666666">+</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">2</span>} h x_{m}
</pre></div>
<p>
<!-- !split -->

<h2>Implementation  <a name="___sec89"></a></h2>

<p>

<ul>
 <p><li> Coming functions appear in <a href="http://tinyurl.com/jvzzcfn/fem/fe_approx1D.py"><tt>fe_approx1D.py</tt></a></li>
 <p><li> Functions can operate in symbolic or numeric mode</li>
 <p><li> The code documents all steps in finite element calculations!</li>
</ul>

<!-- !split -->

<h3>Compute finite element basis functions  <a name="___sec90"></a></h3>

<p>
Let \( \refphi_r(X) \) be a Lagrange polynomial of degree <code>d</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sm</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">phi_r</span>(r, X, d):
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(X, sm<span style="color: #666666">.</span>Symbol):
        h <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>, d)  <span style="color: #408080; font-style: italic"># node spacing</span>
        nodes <span style="color: #666666">=</span> [<span style="color: #666666">2*</span>i<span style="color: #666666">*</span>h <span style="color: #666666">-</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>)]
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #408080; font-style: italic"># assume X is numeric: use floats for nodes</span>
        nodes <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, d<span style="color: #666666">+1</span>)
    <span style="color: #008000; font-weight: bold">return</span> Lagrange_polynomial(X, r, nodes)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Lagrange_polynomial</span>(x, i, points):
    p <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(points)):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #666666">!=</span> i:
            p <span style="color: #666666">*=</span> (x <span style="color: #666666">-</span> points[k])<span style="color: #666666">/</span>(points[i] <span style="color: #666666">-</span> points[k])
    <span style="color: #008000; font-weight: bold">return</span> p

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">basis</span>(d<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Return the complete basis.&quot;&quot;&quot;</span>
    X <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;X&#39;</span>)
    phi <span style="color: #666666">=</span> [phi_r(r, X, d) <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d<span style="color: #666666">+1</span>)]
    <span style="color: #008000; font-weight: bold">return</span> phi
</pre></div>
<p>
<!-- !split -->

<h3>Compute the element matrix  <a name="___sec91"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_matrix</span>(phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi)
    A_e <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((n, n))
    X <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;X&#39;</span>)
    <span style="color: #008000; font-weight: bold">if</span> symbolic:
        h <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;h&#39;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>  <span style="color: #408080; font-style: italic"># dx/dX</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(r, n):
            A_e[r,s] <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(phi[r]<span style="color: #666666">*</span>phi[s]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
            A_e[s,r] <span style="color: #666666">=</span> A_e[r,s]
    <span style="color: #008000; font-weight: bold">return</span> A_e
</pre></div>
<p>
<!-- !split -->

<h3>Example on symbolic and numeric element matrix  <a name="___sec92"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> phi
[<span style="color: #666666">1/2</span> <span style="color: #666666">-</span> X<span style="color: #666666">/2</span>, <span style="color: #666666">1/2</span> <span style="color: #666666">+</span> X<span style="color: #666666">/2</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> element_matrix(phi, Omega_e<span style="color: #666666">=</span>[<span style="color: #666666">0.1</span>, <span style="color: #666666">0.2</span>], symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>)
[h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> element_matrix(phi, Omega_e<span style="color: #666666">=</span>[<span style="color: #666666">0.1</span>, <span style="color: #666666">0.2</span>], symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
[<span style="color: #666666">0.0333333333333333</span>, <span style="color: #666666">0.0166666666666667</span>]
[<span style="color: #666666">0.0166666666666667</span>, <span style="color: #666666">0.0333333333333333</span>]
</pre></div>
<p>
<!-- !split -->

<h3>Compute the element vector  <a name="___sec93"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_vector</span>(f, phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>):
    n <span style="color: #666666">=</span> <span style="color: #008000">len</span>(phi)
    b_e <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros((n, <span style="color: #666666">1</span>))
    <span style="color: #408080; font-style: italic"># Make f a function of X</span>
    X <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;X&#39;</span>)
    <span style="color: #008000; font-weight: bold">if</span> symbolic:
        h <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;h&#39;</span>)
    <span style="color: #008000; font-weight: bold">else</span>:
        h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]
    x <span style="color: #666666">=</span> (Omega_e[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> Omega_e[<span style="color: #666666">1</span>])<span style="color: #666666">/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>X  <span style="color: #408080; font-style: italic"># mapping</span>
    f <span style="color: #666666">=</span> f<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;x&#39;</span>, x)  <span style="color: #408080; font-style: italic"># substitute mapping formula for x</span>
    detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>  <span style="color: #408080; font-style: italic"># dx/dX</span>
    <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        b_e[r] <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
    <span style="color: #008000; font-weight: bold">return</span> b_e
</pre></div>
<p>
Note <code>f.subs('x', x)</code>: replace <code>x</code> by \( x(X) \) such that <code>f</code> contains <code>X</code>

<p>
<!-- !split -->

<h3>Fallback on numerical integration if symbolic integration fails  <a name="___sec94"></a></h3>

<p>

<ul>
  <p><li> Element matrix: only polynomials and <code>sympy</code> always succeeds</li>
  <p><li> Element vector: \( \int f\refphi \dx \) can fail
    (<code>sympy</code> then returns an <code>Integral</code> object instead of a number)</li>
</ul>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">element_vector</span>(f, phi, Omega_e, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>):
        <span style="color: #666666">...</span>
        I <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>integrate(f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))  <span style="color: #408080; font-style: italic"># try...</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(I, sm<span style="color: #666666">.</span>Integral):
            h <span style="color: #666666">=</span> Omega_e[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> Omega_e[<span style="color: #666666">0</span>]  <span style="color: #408080; font-style: italic"># Ensure h is numerical</span>
            detJ <span style="color: #666666">=</span> h<span style="color: #666666">/2</span>
            integrand <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>lambdify([X], f<span style="color: #666666">*</span>phi[r]<span style="color: #666666">*</span>detJ)
            I <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>mpmath<span style="color: #666666">.</span>quad(integrand, [<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>])
        b_e[r] <span style="color: #666666">=</span> I
        <span style="color: #666666">...</span>
</pre></div>
<p>
<!-- !split -->

<h3>Linear system assembly and solution  <a name="___sec95"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">assemble</span>(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>):
    N_n, N_e <span style="color: #666666">=</span> <span style="color: #008000">len</span>(nodes), <span style="color: #008000">len</span>(elements)
    zeros <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>zeros <span style="color: #008000; font-weight: bold">if</span> symbolic <span style="color: #008000; font-weight: bold">else</span> np<span style="color: #666666">.</span>zeros
    A <span style="color: #666666">=</span> zeros((N_n, N_n))
    b <span style="color: #666666">=</span> zeros((N_n, <span style="color: #666666">1</span>))
    <span style="color: #008000; font-weight: bold">for</span> e <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_e):
        Omega_e <span style="color: #666666">=</span> [nodes[elements[e][<span style="color: #666666">0</span>]], nodes[elements[e][<span style="color: #666666">-1</span>]]]

        A_e <span style="color: #666666">=</span> element_matrix(phi, Omega_e, symbolic)
        b_e <span style="color: #666666">=</span> element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #008000; font-weight: bold">for</span> r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(elements[e])):
            <span style="color: #008000; font-weight: bold">for</span> s <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] <span style="color: #666666">+=</span> A_e[r,s]
            b[elements[e][r]] <span style="color: #666666">+=</span> b_e[r]
    <span style="color: #008000; font-weight: bold">return</span> A, b
</pre></div>
<p>
<!-- !split -->

<h3>Linear system solution  <a name="___sec96"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> symbolic:
    c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)           <span style="color: #408080; font-style: italic"># sympy arrays, symbolic Gaussian elim.</span>
<span style="color: #008000; font-weight: bold">else</span>:
    c <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)  <span style="color: #408080; font-style: italic"># numpy arrays, numerical solve</span>
</pre></div>
<p>
Note: the symbolic computation of <code>A</code> and <code>b</code> and the symbolic
solution can be very tedious.

<p>
<!-- !split -->

<h3>Example on computing approximations  <a name="___sec97"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> h, x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;h x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, h, <span style="color: #666666">2*</span>h]
<span style="color: #666666">&gt;&gt;&gt;</span> elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,   <span style="color: #666666">0</span>]
[h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[  <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> b
[     h<span style="color: #666666">**2/6</span> <span style="color: #666666">-</span> h<span style="color: #666666">**3/12</span>]
[      h<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">7*</span>h<span style="color: #666666">**3/6</span>]
[<span style="color: #666666">5*</span>h<span style="color: #666666">**2/6</span> <span style="color: #666666">-</span> <span style="color: #666666">17*</span>h<span style="color: #666666">**3/12</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
<span style="color: #666666">&gt;&gt;&gt;</span> c
[                           h<span style="color: #666666">**2/6</span>]
[<span style="color: #666666">12*</span>(<span style="color: #666666">7*</span>h<span style="color: #666666">**2/12</span> <span style="color: #666666">-</span> <span style="color: #666666">35*</span>h<span style="color: #666666">**3/72</span>)<span style="color: #666666">/</span>(<span style="color: #666666">7*</span>h)]
[  <span style="color: #666666">7*</span>(<span style="color: #666666">4*</span>h<span style="color: #666666">**2/7</span> <span style="color: #666666">-</span> <span style="color: #666666">23*</span>h<span style="color: #666666">**3/21</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>h)]
</pre></div>
<p>
Numerical computations:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>]]
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d<span style="color: #666666">=1</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[ <span style="color: #666666">0.166666666666667</span>, <span style="color: #666666">0.0833333333333333</span>,                  <span style="color: #666666">0</span>]
[<span style="color: #666666">0.0833333333333333</span>,  <span style="color: #666666">0.333333333333333</span>, <span style="color: #666666">0.0833333333333333</span>]
[                 <span style="color: #666666">0</span>, <span style="color: #666666">0.0833333333333333</span>,  <span style="color: #666666">0.166666666666667</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> b
[          <span style="color: #666666">0.03125</span>]
[<span style="color: #666666">0.104166666666667</span>]
[          <span style="color: #666666">0.03125</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> c <span style="color: #666666">=</span> A<span style="color: #666666">.</span>LUsolve(b)
<span style="color: #666666">&gt;&gt;&gt;</span> c
[<span style="color: #666666">0.0416666666666666</span>]
[ <span style="color: #666666">0.291666666666667</span>]
[<span style="color: #666666">0.0416666666666666</span>]
</pre></div>
<p>
<!-- !split -->

<h3>The structure of the coefficient matrix <a name="fem:approx:fe:A:structure"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> d<span style="color: #666666">=1</span>; N_e<span style="color: #666666">=8</span>; Omega<span style="color: #666666">=</span>[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]  <span style="color: #408080; font-style: italic"># 8 linear elements on [0,1]</span>
<span style="color: #666666">&gt;&gt;&gt;</span> phi <span style="color: #666666">=</span> basis(d)
<span style="color: #666666">&gt;&gt;&gt;</span> f <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)
<span style="color: #666666">&gt;&gt;&gt;</span> nodes, elements <span style="color: #666666">=</span> mesh_symbolic(N_e, d, Omega)
<span style="color: #666666">&gt;&gt;&gt;</span> A, b <span style="color: #666666">=</span> assemble(nodes, elements, phi, f, symbolic<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> A
[h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,     <span style="color: #666666">0</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>,   h<span style="color: #666666">/6</span>,   <span style="color: #666666">0</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, <span style="color: #666666">2*</span>h<span style="color: #666666">/3</span>, h<span style="color: #666666">/6</span>]
[  <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,     <span style="color: #666666">0</span>,   h<span style="color: #666666">/6</span>, h<span style="color: #666666">/3</span>]
</pre></div>
<p>
Note: do this by hand to understand what is going on!

<p>
<!-- !split -->

<h3>General result: the coefficient matrix is sparse  <a name="___sec99"></a></h3>

<p>

<ul>
 <p><li> Sparse = most of the entries are zeros</li>
 <p><li> Below: P1 elements</li>
</ul>

$$
\begin{equation}
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
\end{equation}
$$


<p>
<!-- !split -->

<h3>Exemplifying the sparsity for P2 elements  <a name="___sec100"></a></h3>

<p>
$$
\begin{equation}
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 &
  0\\0 & 0 & 2 & 16 & 2 & 0 & 0
  & 0 & 0\\0 & 0 & - 1 & 2 & 8
  & 2 & - 1 & 0 & 0\\0 & 0 & 0 & 0 &
  2 & 16 & 2 & 0 & 0\\0 & 0 & 0
  & 0 & - 1 & 2 & 8 &
  2 & - 1\\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
\end{equation}
$$


<p>
<!-- !split -->

<h3>Matrix sparsity pattern for regular/random numbering of P1 elements  <a name="___sec101"></a></h3>

<p>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>

<center><p><img src="fig-fem/sparsity_pattern_1D_30.png" align="bottom" width=800></p></center>

<p>
<!-- !split -->

<h3>Matrix sparsity pattern for regular/random numbering of P3 elements  <a name="___sec102"></a></h3>

<p>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>

<center><p><img src="fig-fem/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p></center>

<p>
<!-- !split -->

<h3>Sparse matrix storage and solution <a name="fem:approx:fe:impl:sparse"></a></h3>

<p>
The minimum storage requirements for the coefficient matrix \( A_{i,j} \):

<p>

<ul>
 <p><li> P1 elements: only 3 nonzero entires per row</li>
 <p><li> P2 elements: only 5 nonzero entires per row</li>
 <p><li> P2 elements: only 7 nonzero entires per row</li>
 <p><li> It is important to utilize sparse storage and sparse solvers</li>
 <p><li> In Python: <code>scipy.sparse</code> package</li>
</ul>

<!-- !split -->

<h3>Approximate \( f\sim x^9 \) by various elements; code  <a name="___sec104"></a></h3>

<p>
Compute a mesh with <code>N_e</code> elements, basis functions of
degree <code>d</code>, and approximate a given symbolic expression
<code>f</code> by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sm</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">fe_approx1D</span> <span style="color: #008000; font-weight: bold">import</span> approximate
x <span style="color: #666666">=</span> sm<span style="color: #666666">.</span>Symbol(<span style="color: #BA2121">&#39;x&#39;</span>)

approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=4</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=2</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, d<span style="color: #666666">=1</span>, N_e<span style="color: #666666">=8</span>)
approximate(f<span style="color: #666666">=</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">**8</span>, symbolic<span style="color: #666666">=</span><span style="color: #008000">False</span>, d<span style="color: #666666">=2</span>, N_e<span style="color: #666666">=4</span>)
</pre></div>
<p>
<!-- !split -->

<h3>Approximate \( f\sim x^9 \) by various elements; plot  <a name="___sec105"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p1_p2_x9_248e.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h2>Comparison of finite element and finite difference approximation <a name="fem:approx:fe:fd"></a></h2>

<p>

<ul>
 <p><li> Finite difference approximation of a function \( f(x) \): simply
   choose \( u_i = f(x_i) \) (interpolation)</li>
 <p><li> Galerkin/projection and least squares method:
   must derive and solve a linear system</li>
 <p><li> What is really the difference?</li>
</ul>

<h3>Interpolation/collocation with finite elements  <a name="___sec107"></a></h3>

<p>
Let \( \xno{i} \), \( i\in\If \), be the nodes in the mesh.
Collocation means

<p>
$$
\begin{equation}
u(\xno{i})=f(\xno{i}),\quad i\in\If,
\end{equation}
$$

which translates to

<p>
$$ \sum_{j\in\If} c_j \basphi_j(\xno{i}) = f(\xno{i}),$$

but \( \basphi_j(\xno{i})=0 \) if \( i\neq j \) so the sum collapses to one
term \( c_i\basphi_i(\xno{i}) = c_i \), and we have the result

<p>
$$
\begin{equation}
c_i = f(\xno{i})
\tp
\end{equation}
$$


<p>

<ul>
 <p><li> Same result as the standard finite difference approach</li>
 <p><li> \( u \) <em>interpolates</em> \( f \) at the node points</li>
 <p><li> \( u \) has a variation between the node points dictated by the \( \basphi_i \)
   functions</li>
</ul>


<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

