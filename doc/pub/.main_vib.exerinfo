
# Information about all exercises in the file main_vib.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_vib.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['vib_undamped_verify_linear.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:verify:linear',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Add a source term to the ODE problem (ref{vib:ode1}),\n$u'+\\omega^2u=f(t)$, and a more general initial condition $u'(0)=V$,\nwhere $V$ is a given constant.  Discretize this equation according to\n$[D_tD_t u + \\omega^2 u = f]^n_i$ and derive a new equation for the\nfirst time step ($u^1$).  Let $\\uex(x,t)= ct+I$ and show that this is\na solution of the ODE if $f(x,t)=\\omega^2(ct+I)$ and $V=c$.  Show that\n$[D_tD_t t]^n_i=0$ and therefore that $\\uex$ *also* solves the\ndiscrete equations. Implement the modified problem and make a nose\ntest with the linear $\\uex$ to verify the solution.",
  'title': 'Use a linear function for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_undamped_verify_quadratic.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:verify:quadratic',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'This is a variation of Exercise ref{vib:exer:undamped:verify:linear}\nwhere we test a quadratic function rather than a linear.\nLet $\\uex(x,t)= at^2 + ct+I$, find the corresponding $f$ term,\nand show that $\\uex$ fulfills all discrete equations.\nYou will need to show that $[D_tD_t t^2]^n = 2$.',
  'title': 'Use a quadratic function for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_phase_error_growth.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:phase:err:growth',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider an exact solution $I\\cos (\\omega t)$ and an\napproximation $I\\cos(\\tilde\\omega t)$.\nDefine the phase error as time lag between the peak $I$\nin the exact solution and the corresponding peak in the approximation\nafter $m$ periods of oscillations. Show that this phase error\nis linear in $m$.',
  'title': 'Show linear growth of the phase with time',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_adjust_w.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:w:adjust',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'According to (ref{vib:ode1:tildeomega:series}), the numerical\nfrequency deviates from the exact frequency by a (dominating) amount\n$\\omega^3\\Delta t^2/24 >0$. Replace the `w` parameter in the algorithm\nin the `solver` function (in `vib_undamped.py`) by `w*(1 -\n(1./24)*w**2*dt**2` and test how this adjustment in the numerical\nalgorithm improves the accuracy.',
  'title': 'Improve the accuracy by adjusting the frequency',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_undamped_adaptive.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:adaptive',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Adaptive methods for solving ODEs aim at adjusting $\\Delta t$ such\nthat the error is within a user-prescribed tolerance. Implement the\nequation $u\'\'+u=0$ in the "Odespy": "https://github.com/hplgit/odespy"\nsoftware. Use the example ref[from Section\nref{decay:fd2:adaptiveRK}][in cite{Langtangen:deq:decay}]["on adaptive\nschemes":\n"http://hplgit.github.io/INF5620/doc/pub/decay-sphinx/._part0007_main_decay.html#example-adaptive-runge-kutta-methods"\nin cite{Langtangen:deq:decay}].  Run the scheme with a very low\ntolerance (say $10^{-14}$) and for a long time, check the number of\ntime points in the solver\'s mesh (`len(solver.t_all)`), and compare\nthe phase error with that produced by the simple finite difference\nmethod from Section ref{vib:ode1:fdm} with the same number of (equally\nspaced) mesh points. The question is whether it pays off to use an\nadaptive solver or if equally many points with a simple method gives\nabout the same accuracy.',
  'title': 'See if adaptive methods improve the phase error',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_first_step.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:step4b:alt',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "As an alternative to the derivation of (ref{vib:ode1:step4b}) for\ncomputing $u^1$, one can use a Taylor polynomial with three terms\nfor $u^1$:\n\n!bt\n\\[ u(t_1) \\approx u(0) + u'(0)\\Delta t + \\frac{1}{2}u''(0)\\Delta t^2\\]\n\n!et\nWith $u''=-\\omega^2 u$ and $u'(0)=0$, show that this method also leads to\n(ref{vib:ode1:step4b}). Generalize the condition on $u'(0)$ to\nbe $u'(0)=V$ and compute $u^1$ in this case with both methods.",
  'title': 'Use a Taylor polynomial to compute $u^1$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_largest_wdt.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:wdt:limit',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': '# Short: Find the largest relevant value of $\\omega\\Delta t$\n\n\nSketch the function on a given mesh which has the highest possible\nfrequency. That is, this oscillatory "cos-like" function has its\nmaxima and minima at every two grid points.  Find an expression for\nthe frequency of this function, and use the result to find the largest\nrelevant value of $\\omega\\Delta t$ when $\\omega$ is the frequency\nof an oscillating function and $\\Delta t$ is the mesh spacing.',
  'title': 'Find the minimal resolution of an oscillatory function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_plot_fd_exp_error.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:fd:exp:plot',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "# Short: Visualize the accuracy of finite differences\n\n\nWe introduce the error fraction\n!bt\n\\[ E = \\frac{[D_tD_t u]^n}{u''(t_n)} \\]\n\n!et\nto measure the error in the finite difference approximation $D_tD_tu$ to\n$u''$.\nCompute $E$\nfor the specific choice of a cosine/sine function of the\nform $u=\\exp{(i\\omega t)}$ and show that\n!bt\n\\[ E = \\left(\\frac{2}{\\omega\\Delta t}\\right)^2\n\\sin^2(\\frac{\\tilde\\omega\\Delta t}{2})\n\\thinspace .\n\\]\n\n!et\nPlot $E$ as a function of $p=\\omega\\Delta t$. The relevant\nvalues of $p$ are $[0,\\pi]$ (see Exercise ref{vib:exer:wdt:limit}\nfor why $p>\\pi$ does not make sense).\nThe deviation of the curve from unity visualizes the error in the\napproximation. Also expand $E$ as a Taylor polynomial in $p$ up to\nfourth degree (use, e.g., `sympy`).",
  'title': 'Visualize the accuracy of finite differences for a cosine function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_verify_linear.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:verify:linear',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'This is a continuation of Exercise ref{vib:exer:undamped:verify:linear} where\nwe consider the extended model problem (ref{vib:ode2}).\nPrescribe $\\uex = Vt + I$, which fulfills the initial conditions, and\nshow that this $\\uex$ solves (ref{vib:ode2}) if $F(t)=I+(c+t)V$.\nImport the `solver` function from `vib.py` and add a nose test using\nthis linear solution.',
  'title': 'Use a linear function for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_verify_discrete_omega.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:discrete:omega',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Write a nose test function that employs the exact discrete solution\n(ref{vib:ode1:un:exact}) to verify the implementation of the\n`solver` function in the file `vib_undamped.py`.',
  'title': 'Use an exact discrete solution for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_conv_rate.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:conv:rate',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to perform convergence tests of\nthe problem (ref{vib:ode2}) when $s(u)=\\omega^2u$ and $F(t)=A\\sin\\phi t$.\nFind the complete analytical solution to the problem in this case\n(most textbooks on mechanics list the various elements you need to\nwrite down the exact solution).\nModify the `convergence_rate` function from the `vib_undamped.py`\nprogram to perform experiments with the extended model.\nVerify that the error is of order $\\Delta t^2$.',
  'title': 'Use analytical solution for convergence rate tests',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_amplitude_errors.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:odespy',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Use the program `vib_odespy.py` from Section ref{vib:undamped:1stODE}\nand the amplitude estimation from the `amplitudes` function\nin the `vib_undamped.py` file (see Section ref{vib:ode1:empirical})\nto investigate how well famous methods for 1st-order ODEs\ncan preserve the amplitude of $u$ in undamped oscillations.\nTest, for example, the 3rd- and 4th-order Runge-Kutta methods\n(`RK3`, `RK4`), the Crank-Nicolson method (`CrankNicolson`),\nthe 2nd- and 3rd-order Adams-Bashforth methods (`AdamsBashforth2`,\n`AdamsBashforth3`), and a 2nd-order Backwards scheme (`Backward2Step`).\nThe relevant governing equations are listed in\nSection ref{vib:model2:ueq}.',
  'title': 'Investigate the amplitude errors of many solvers',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_memsave.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:memsave',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The program "`vib.py`":\n"https://github.com/hplgit/INF5620/blob/gh-pages/src/vib/vib.py"\nstore the complete solution $u^0,u^1,\\ldots,u^{N_t}$ in memory, which is\nconvenient for later plotting.\nMake a memory minimizing version of this program where only the last three\n$u^{n+1}$, $u^n$, and $u^{n-1}$ values are stored in memory.\nWrite each computed $(t_{n+1}, u^{n+1})$ pair to file.\nVisualize the data in the file (a cool solution is to\nread one line at a time and\nplot the $u$ value using the line-by-line plotter in the\n`visualize_front_ascii` function - this technique makes it trivial\nto visualize very long time simulations).',
  'title': 'Minimize memory usage of a vibration solver',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_class.py'],
  'heading': '=====',
  'hints': ['Use the ideas and examples\nref[from Section ref{decay:prog:se:class} and ref{decay:prog:se:class2}][in cite{Langtangen:deq:decay}][for an "ODE model": "http://hplgit.github.com/INF5620/doc/pub/decay-sphinx/main_decay.html#implementing-simple-problem-and-solver-classes"].\nMore specifically, make a superclass `Problem` for holding the scalar\nphysical parameters of a problem and let subclasses implement the\n$s(u)$ and $F(t)$ functions as methods.\nTry to call up as much existing functionality in `vib.py` as possible.'],
  'keywords': None,
  'label': 'vib:exer:gen:class',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Reimplement the `vib.py`\nprogram\nusing a class `Problem` to hold all the physical parameters of the problem,\na class `Solver` to hold the numerical parameters and compute the\nsolution, and a class `Visualizer` to display the solution.\n\n\n# mech systems: horizontal, vertical/hanging\n# pendulum\n# bumpy road\n# moored ship\n# electrical circuits, see ode2.p.tex\n# 0D blood flow?\n# waves: 1D blood flow\n# general particle laws and velocity verlet, make exercises\n# see URL: "http://en.wikipedia.org/wiki/Velocity_Verlet"\n\n# in vb_odespy examples: add 20 RK4 1000 to show RK4 in the long run\n\n# mu\'\' + bu\' + ku = F(t)\n# set up analytical solution for reference\n# compare for F = sin qt, demonstrate resonance by having\n# F = sin q t and q = piecewise constant in time with four\n# levels: 0.1, 0.75 1, 1.25, 2 of the resonance frequency,\n# make each platou act for a while to see the effect\n\n# mu\'\' + bu\' + s(u) = F(t) as exercise, pendulum\n# mu\'\' + f(x) + s() = F(t) via odespy RK4\n\n# odespy: ForwardBackward on a 2n system? Need special formula for first\n# step to ensure dt^2 accuracy there.\n\n# apps: planet around a star, box horizontal and vertical, bumpy,\n# jumping washing machine, pendulum, moored ship, look to Irgens\n\nBIBFILE: ../papers.pub',
  'title': 'Implement the solver via classes',
  'type': 'Exercise',
  'type_visible': True}]