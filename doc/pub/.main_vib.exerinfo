
# Information about all exercises in the file main_vib.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_vib.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['vib_undamped_verify_mms.pdf', 'vib_undamped_verify_mms.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:verify:linquad',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Derive the equation for the\nfirst time step ($u^1$).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'For verification purposes,\nwe use the method of manufactured solutions (MMS) with the\nchoice of $\\uex(x,t)= ct+d$.\nFind restrictions on $c$ and $d$ from\nthe initial conditions. Compute the corresponding source term $f$ by term.\nShow that $[D_tD_t t]^n=0$ and use the fact\nthat the $D_tD_t$ operator is linear,\n$[D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0$, to show that\n$\\uex$ is also a perfect solution of the discrete equations.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Use `sympy` to do the symbolic calculations above. Here is a\nsketch of the program `vib_undamped_verify_mms.py`:\n\n!bc pycod\nimport sympy as sm\nV, t, I, w, dt = sm.symbols(\'V t I w dt\')  # global symbols\nf = None  # global variable for the source term in the ODE\n\ndef ode_source_term(u):\n    """Return the terms in the ODE that the source term\n    must balance, here u\'\' + w**2*u.\n    u is symbolic Python function of t."""\n    return sm.diff(u(t), t, t) + w**2*u(t)\n\ndef residual_discrete_eq(u):\n    """Return the residual of the discrete eq. with u inserted."""\n    R = ...\n    return sm.simplify(R)\n\ndef residual_discrete_eq_step1(u):\n    """Return the residual of the discrete eq. at the first\n    step with u inserted."""\n    R = ...\n    return sm.simplify(R)\n\ndef DtDt(u, dt):\n    """Return 2nd-order finite difference for u_tt.\n    u is a symbolic Python function of t.\n    """\n    return ...\n\ndef main(u):\n    """\n    Given some chosen solution u (as a function of t, implemented\n    as a Python function), use the method of manufactured solutions\n    to compute the source term f, and check if u also solves\n    the discrete equations.\n    """\n    print \'=== Testing exact solution: %s ===\' % u\n    print "Initial conditions u(0)=%s, u\'(0)=%s:" % \\ \n          (u(t).subs(t, 0), sm.diff(u(t), t).subs(t, 0))\n\n    # Method of manufactured solution requires fitting f\n    global f  # source term in the ODE\n    f = sm.simplify(ode_lhs(u))\n\n    # Residual in discrete equations (should be 0)\n    print \'residual step1:\', residual_discrete_eq_step1(u)\n    print \'residual:\', residual_discrete_eq(u)\n\ndef linear():\n    main(lambda t: V*t + I)\n\nif __name__ == \'__main__\':\n    linear()\n\n!ec\nFill in the various functions such that the calls in the `main`\nfunction works.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The purpose now is to choose a quadratic function\n$\\uex = bt^2 + ct + d$ as exact solution. Extend the `sympy`\ncode above with a function `quadratic` for fitting `f` and checking\nif the discrete equations are fulfilled. (The function is very similar\nto `linear`.)\n\n#Check with hand calculations that the `sympy` implementation\n#is correct.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Will a polynomial of degree three fulfill the discrete equations?'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement a `solver` function for computing the numerical\nsolution of this problem.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a nose test for checking that the quadratic solution\nis computed to correctly (too machine precision, but the\nround-off errors accumulate and increase with $T$) by the `solver`\nfunction.'}],
  'text': "Consider the ODE problem\n\n!bt\n\\[ u'' + \\omega^2u=f(t), \\quad u(0)=I,\\ u'(0)=V,\\ t\\in(0,T]\\tp\\]\n\n!et\nDiscretize this equation according to\n$[D_tD_t u + \\omega^2 u = f]^n$.",
  'title': 'Use linear/quadratic functions for verification',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_phase_error_growth.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:phase:err:growth',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider an exact solution $I\\cos (\\omega t)$ and an\napproximation $I\\cos(\\tilde\\omega t)$.\nDefine the phase error as time lag between the peak $I$\nin the exact solution and the corresponding peak in the approximation\nafter $m$ periods of oscillations. Show that this phase error\nis linear in $m$.',
  'title': 'Show linear growth of the phase with time',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_adjust_w.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:w:adjust',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'According to (ref{vib:ode1:tildeomega:series}), the numerical\nfrequency deviates from the exact frequency by a (dominating) amount\n$\\omega^3\\Delta t^2/24 >0$. Replace the `w` parameter in the algorithm\nin the `solver` function in `vib_undamped.py` by `w*(1 -\n(1./24)*w**2*dt**2` and test how this adjustment in the numerical\nalgorithm improves the accuracy (use $\\Delta t =0.1$ and simulate\nfor 80 periods, with and without adjustment of $\\omega$).\n\n# How does this go if',
  'title': 'Improve the accuracy by adjusting the frequency',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_undamped_adaptive.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:adaptive',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Adaptive methods for solving ODEs aim at adjusting $\\Delta t$ such\nthat the error is within a user-prescribed tolerance. Implement the\nequation $u\'\'+u=0$ in the "Odespy": "https://github.com/hplgit/odespy"\nsoftware. Use the example ref[from Section\nref{decay:fd2:adaptiveRK}][in cite{Langtangen:deq:decay}]["on adaptive\nschemes": "http://tinyurl.com/k3sdbuv/pub/decay-sphinx/._part0007_main_decay.html#example-adaptive-runge-kutta-methods"\nin cite{Langtangen:deq:decay}].  Run the scheme with a very low\ntolerance (say $10^{-14}$) and for a long time, check the number of\ntime points in the solver\'s mesh (`len(solver.t_all)`), and compare\nthe phase error with that produced by the simple finite difference\nmethod from Section ref{vib:ode1:fdm} with the same number of (equally\nspaced) mesh points. The question is whether it pays off to use an\nadaptive solver or if equally many points with a simple method gives\nabout the same accuracy.',
  'title': 'See if adaptive methods improve the phase error',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_first_step.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:step4b:alt',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "As an alternative to the derivation of (ref{vib:ode1:step4b}) for\ncomputing $u^1$, one can use a Taylor polynomial with three terms\nfor $u^1$:\n\n!bt\n\\[ u(t_1) \\approx u(0) + u'(0)\\Delta t + \\frac{1}{2}u''(0)\\Delta t^2\\]\n\n!et\nWith $u''=-\\omega^2 u$ and $u'(0)=0$, show that this method also leads to\n(ref{vib:ode1:step4b}). Generalize the condition on $u'(0)$ to\nbe $u'(0)=V$ and compute $u^1$ in this case with both methods.",
  'title': 'Use a Taylor polynomial to compute $u^1$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_largest_wdt.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:wdt:limit',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': '# Short: Find the largest relevant value of $\\omega\\Delta t$\n\n\nSketch the function on a given mesh which has the highest possible\nfrequency. That is, this oscillatory "cos-like" function has its\nmaxima and minima at every two grid points.  Find an expression for\nthe frequency of this function, and use the result to find the largest\nrelevant value of $\\omega\\Delta t$ when $\\omega$ is the frequency\nof an oscillating function and $\\Delta t$ is the mesh spacing.',
  'title': 'Find the minimal resolution of an oscillatory function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_plot_fd_exp_error.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:fd:exp:plot',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "# Short: Visualize the accuracy of finite differences\n\n\nWe introduce the error fraction\n!bt\n\\[ E = \\frac{[D_tD_t u]^n}{u''(t_n)} \\]\n\n!et\nto measure the error in the finite difference approximation $D_tD_tu$ to\n$u''$.\nCompute $E$\nfor the specific choice of a cosine/sine function of the\nform $u=\\exp{(i\\omega t)}$ and show that\n!bt\n\\[ E = \\left(\\frac{2}{\\omega\\Delta t}\\right)^2\n\\sin^2(\\frac{\\omega\\Delta t}{2})\n\\tp\n\\]\n\n!et\nPlot $E$ as a function of $p=\\omega\\Delta t$. The relevant\nvalues of $p$ are $[0,\\pi]$ (see Exercise ref{vib:exer:wdt:limit}\nfor why $p>\\pi$ does not make sense).\nThe deviation of the curve from unity visualizes the error in the\napproximation. Also expand $E$ as a Taylor polynomial in $p$ up to\nfourth degree (use, e.g., `sympy`).",
  'title': 'Visualize the accuracy of finite differences for a cosine function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['test_error_conv.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:energy:convrate',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "We consider the ODE problem $u'' + \\omega^2u=0$, $u(0)=I$, $u'(0)=V$,\nfor $t\\in (0,T]$. The total energy of the solution\n$E(t)=\\frac{1}{2}(u')^2 + \\frac{1}{2}\\omega^2 u^2$ should stay\nconstant.\nThe error in energy can be computed as explained in\nSection ref{vib:model1:energy}.\n\nMake a nose test in a file `test_error_conv.py`, where code from\n`vib_undamped.py` is imported, but the `convergence_rates` and\n`test_convergence_rates` functions are copied and modified to also\nincorporate computations of the error in energy and the convergence\nrate of this error. The expected rate is 2.",
  'title': 'Verify convergence rates of the error in energy',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_verify_mms.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:verify:gen:linear',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'This exercise is a generalization of Problem\nref{vib:exer:undamped:verify:linquad} to the extended model problem\n(ref{vib:ode2}) where the damping term is either linear or quadratic.\nSolve the various subproblems and see how the results and problem\nsettings change with the generalized ODE in case of linear or\nquadratic damping. By modifying the code from Problem\nref{vib:exer:undamped:verify:linquad}, `sympy` will do most\nof the work required to analyze the generalized problem.',
  'title': 'Use linear/quadratic functions for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_verify_discrete_omega.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:discrete:omega',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Write a nose test function in a separate file\nthat employs the exact discrete solution\n(ref{vib:ode1:un:exact}) to verify the implementation of the\n`solver` function in the file `vib_undamped.py`.\nJust import `solver` and make functions for the exact discrete\nsolution and the nose test.',
  'title': 'Use an exact discrete solution for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_conv_rate.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:conv:rate',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to perform convergence tests of\nthe problem (ref{vib:ode2}) when $s(u)=\\omega^2u$ and $F(t)=A\\sin\\phi t$.\nFind the complete analytical solution to the problem in this case\n(most textbooks on mechanics list the various elements you need to\nwrite down the exact solution).\nModify the `convergence_rate` function from the `vib_undamped.py`\nprogram to perform experiments with the extended model.\nVerify that the error is of order $\\Delta t^2$.',
  'title': 'Use analytical solution for convergence rate tests',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_amplitude_errors.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:odespy',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Use the program `vib_undamped_odespy.py` from Section ref{vib:undamped:1stODE}\nand the amplitude estimation from the `amplitudes` function\nin the `vib_undamped.py` file (see Section ref{vib:ode1:empirical})\nto investigate how well famous methods for 1st-order ODEs\ncan preserve the amplitude of $u$ in undamped oscillations.\nTest, for example, the 3rd- and 4th-order Runge-Kutta methods\n(`RK3`, `RK4`), the Crank-Nicolson method (`CrankNicolson`),\nthe 2nd- and 3rd-order Adams-Bashforth methods (`AdamsBashforth2`,\n`AdamsBashforth3`), and a 2nd-order Backwards scheme (`Backward2Step`).\nThe relevant governing equations are listed in\nSection ref{vib:model2x2:ueq}.',
  'title': 'Investigate the amplitude errors of many solvers',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_memsave.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:memsave',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The program "`vib.py`": "http://tinyurl.com/jvzzcfn/vib/vib.py"\nstore the complete solution $u^0,u^1,\\ldots,u^{N_t}$ in memory, which is\nconvenient for later plotting.\nMake a memory minimizing version of this program where only the last three\n$u^{n+1}$, $u^n$, and $u^{n-1}$ values are stored in memory.\nWrite each computed $(t_{n+1}, u^{n+1})$ pair to file.\nVisualize the data in the file (a cool solution is to\nread one line at a time and\nplot the $u$ value using the line-by-line plotter in the\n`visualize_front_ascii` function - this technique makes it trivial\nto visualize very long time simulations).',
  'title': 'Minimize memory usage of a vibration solver',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_class.py'],
  'heading': '=====',
  'hints': ['Use the ideas and examples\nref[from Section ref{decay:prog:se:class} and ref{decay:prog:se:class2}][in cite{Langtangen:deq:decay}][for an "ODE model": "http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#implementing-simple-problem-and-solver-classes"].\nMore specifically, make a superclass `Problem` for holding the scalar\nphysical parameters of a problem and let subclasses implement the\n$s(u)$ and $F(t)$ functions as methods.\nTry to call up as much existing functionality in `vib.py` as possible.'],
  'keywords': None,
  'label': 'vib:exer:gen:class',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Reimplement the `vib.py`\nprogram\nusing a class `Problem` to hold all the physical parameters of the problem,\na class `Solver` to hold the numerical parameters and compute the\nsolution, and a class `Visualizer` to display the solution.',
  'title': 'Implement the solver via classes',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_scheme_equivalence.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:schemes:equiv',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Show that the schemes from Sections\nref{vib:ode1:fdm},\nref{vib:model2x2:EulerCromer}, and\nref{vib:model2x2:staggered} are all equivalent.',
  'title': 'Show equivalence between schemes',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_DtDt_fw_bw.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:DtDt:asDtpDtm',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Show that the difference $[D_t D_tu]^n$ is equal to $[D_t^+D_t^-u]^n$\nand $D_t^-D_t^+u]^n$. That is, instead of applying a centered difference\ntwice one can alternatively apply a mixture forward and backward\ndifferences.',
  'title': 'Interpret $[D_tD_t u]^n$ as a forward-backward difference',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_gen_bwdamping.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:quad:damping:fwbw',
  'no': 17,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the generalized model with quadratic damping, expressed\nas a system of two first-order equations as in Section ref{vib:ode2:staggered}:\n\n!bt\n\\begin{align*}\nu\' &= v,\\\\ \nv\' &= \\frac{1}{m}\\left( F(t) - \\beta |v|v - s(u)\\right)\\tp\n\\end{align*}\n\n!et\nHowever, contrary to what is done in Section ref{vib:ode2:staggered},\nwe want to apply the idea of the forward-backward discretization\nin Section ref{vib:model2x2:EulerCromer}. Express the idea in operator\nnotation and write out the scheme. Unfortunately, the backward\ndifference for the $v$ equation creates a nonlinearity $|v^{n+1}|v^{n}$.\nTo linearize this nonlinearity, use the known value $v^n$ inside\nthe absolute value factor, i.e., $|v^{n+1}|v^{n}\\approx |v^n|v^{n+1}$.\nShow that the resulting scheme is equivalent to the one in\nSection ref{vib:ode2:staggered} for some time level $n\\geq 1$.\n\nWhat we learn from this exercise is that the first-order differences\nand the linearization trick play together in "the right way" such that\nthe scheme is as good as when we (in Section ref{vib:ode2:staggered})\ncarefully apply centered differences and a geometric mean on a\nstaggered mesh to achieve second-order accuracy.  There is a\ndifference in the handling of the initial conditions, though, as\nexplained at the end of Section ref{vib:model2x2:EulerCromer}.',
  'title': 'Use the forward-backward scheme with quadratic damping',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_gen_bwdamping.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:quad:damping:bw',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'As an alternative to discretizing the damping terms $\\beta u\'$ and\n$\\beta |u\'|u\'$ by centered differences, we may apply\nbackward differences:\n\n!bt\n\\begin{align*}\n[u\']^n &\\approx [D_t^-u]^n,\\\\ \n& [|u\'|u\']^n &\\approx [|D_t^-u|D_t^-u]^n\n= |[D_t^-u]^n|[D_t^-u]^n\\tp\n\\end{align*}\n\n!et\nThe advantage of the backward difference is that the damping term is\nevaluated using known values $u^n$ and $u^{n-1}$ only.\nExtend the "`vib.py`": "http://tinyurl.com/jvzzcfn/vib/vib.py" code with a scheme based\non using backward differences in the damping terms. Add statements\nto compare the original approach with centered difference and the\nnew idea launched in this exercise. Perform numerical experiments\nto investigate how much accuracy that is lost by using the backward\ndifferences.\n\n\n# mech systems: horizontal, vertical/hanging\n# box with mu*M*g*v/|v| friction force, treat nonlinearity with geometric mean\n# pendulum\n# bumpy road\n# moored ship\n# electrical circuits, see ode2.p.tex\n# 0D blood flow?\n# waves: 1D blood flow\n# general particle laws and velocity verlet, make exercises\n# see URL: "http://en.wikipedia.org/wiki/Velocity_Verlet"\n\n# in vb_odespy examples: add 20 RK4 1000 to show RK4 in the long run\n\n# mu\'\' + bu\' + ku = F(t)\n# set up analytical solution for reference\n# compare for F = sin qt, demonstrate resonance by having\n# F = sin q t and q = piecewise constant in time with four\n# levels: 0.1, 0.75 1, 1.25, 2 of the resonance frequency,\n# make each platou act for a while to see the effect\n\n# mu\'\' + bu\' + s(u) = F(t) as exercise, pendulum\n# mu\'\' + f(x) + s() = F(t) via odespy RK4\n\n# odespy: ForwardBackward on a 2n system? Need special formula for first\n# step to ensure dt^2 accuracy there.\n\n# apps: planet around a star, box horizontal and vertical, bumpy,\n# jumping washing machine, pendulum, moored ship, look to Irgens',
  'title': 'Use a backward difference for the damping term',
  'type': 'Exercise',
  'type_visible': True}]