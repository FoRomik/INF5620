<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for wave motion">
<meta name="keywords" content="waves on a string,wave equation 1D,wave equation 1D, finite difference method,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,unit testing,software testing nose,vectorization,scalar code,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,stencil Neumann boundary,index set notation,geometric mean,arithmetic mean,harmonic average,averaging geometric,averaging arithmetic,averaging harmonic,wave equation 1D, analytical properties,Fourier series,Fourier transform,discrete Fourier transform,wave equation 1D, exact numerical solution,Courant number,stability criterion,wave equation 1D, stability,wave equation 2D, implementation,index set notation,Cython,declaration of variables in Cython,C extension module,wrapper code,Fortran subroutine,row-major ordering,column-major ordering,Fortran array storage,C/Python array storage,radiation condition,open boundary condition">



<style type="text/css">
    /* solarized style */
    body {
      margin:5;
      padding:0;
      border:0;	/* Remove the border around the viewport in old versions of IE */
      width:100%;
      background: #fdf6e3;
      min-width:600px;	/* Minimum width of layout - remove if not required */
      font-family: Verdana, Helvetica, Arial, sans-serif;
      font-size: 1.0em;
      line-height: 1.3em;
      color: #657b83;
    }
    a { color: #657b83; text-decoration:none; }
    a:hover { color: #b58900; background: #eee8d5; text-decoration:none; }
    h1, h2, h3 { margin:.8em 0 .2em 0; padding:0; line-height: 125%; }
    h2 { font-variant: small-caps; }
    pre {
      background: #fdf6e3;
      -webkit-box-shadow: inset 0 0 2px #000000;
      -moz-box-shadow: inset 0 0 2px #000000;
      box-shadow: inset 0 0 2px #000000;
      color: #586e75;
      margin-left: 0px;
      font-family: 'Droid Sans Mono', monospace;
      padding: 2px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      -moz-background-clip: padding;
      -webkit-background-clip: padding-box;
      background-clip: padding-box;
    }
    tt { font-family: "Courier New", Courier; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p { text-indent: 0px; }
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #FFBF00;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #fbeed5;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods for waves on a string ',
               1,
               'wave:string',
               'wave:string'),
              (' Discretizing the domain ',
               2,
               'wave:string:mesh',
               'wave:string:mesh'),
              (' Uniform meshes ', 3, None, '___sec2'),
              (' The discrete solution ',
               2,
               'wave:string:numerical:sol',
               'wave:string:numerical:sol'),
              (' Fulfilling the equation at the mesh points ',
               2,
               'wave:string:samplingPDE',
               'wave:string:samplingPDE'),
              (' Replacing derivatives by finite differences ',
               2,
               'wave:string:fd',
               'wave:string:fd'),
              (' Algebraic version of the PDE ', 3, None, '___sec6'),
              (' Algebraic version of the initial conditions ',
               3,
               None,
               '___sec7'),
              (' Formulating a recursive algorithm ',
               2,
               'wave:string:alg',
               'wave:string:alg'),
              (' Sketch of an implementation ',
               2,
               'wave:string:impl',
               'wave:string:impl'),
              (' Verification ', 1, None, '___sec10'),
              (' A slightly generalized model problem ',
               2,
               'wave:pde2:fd',
               'wave:pde2:fd'),
              (' Using an analytical solution of physical significance ',
               2,
               'wave:pde2:fd:standing:waves',
               'wave:pde2:fd:standing:waves'),
              (' Manufactured solution ',
               2,
               'wave:pde2:fd:MMS',
               'wave:pde2:fd:MMS'),
              (' Constructing an exact solution of the discrete equations ',
               2,
               'wave:pde2:fd:verify:quadratic',
               'wave:pde2:fd:verify:quadratic'),
              (' Implementation ', 1, 'wave:pde1:impl', 'wave:pde1:impl'),
              (' Making a solver function ',
               2,
               'wave:pde1:impl:solver',
               'wave:pde1:impl:solver'),
              (' Verification: exact quadratic solution ',
               2,
               'wave:pde1:impl:verify:quadratic',
               'wave:pde1:impl:verify:quadratic'),
              (' Visualization: animating the solution ',
               2,
               'wave:pde1:impl:animate',
               'wave:pde1:impl:animate'),
              (' Visualization via SciTools ', 3, None, '___sec19'),
              (' Making movie files ', 3, None, '___sec20'),
              (' Skipping frames for animation speed ', 3, None, '___sec21'),
              (' Visualization via Matplotlib ', 3, None, '___sec22'),
              (' Running a case ',
               2,
               'wave:pde1:guitar:data',
               'wave:pde1:guitar:data'),
              (' The benefits of scaling ', 2, None, '___sec24'),
              (' Vectorization ',
               1,
               'wave:pde1:impl:vec',
               'wave:pde1:impl:vec'),
              (' Operations on slices of arrays ',
               2,
               'wave:pde1:impl:vec:slices:basics',
               'wave:pde1:impl:vec:slices:basics'),
              (' Finite difference schemes expressed as slices ',
               2,
               'wave:pde1:impl:vec:slices:fdm',
               'wave:pde1:impl:vec:slices:fdm'),
              (' Verification ',
               2,
               'wave:pde1:impl:vec:verify:quadratic',
               'wave:pde1:impl:vec:verify:quadratic'),
              (' Efficiency measurements ', 2, None, '___sec29'),
              (' Exercises ', 1, None, '___sec30'),
              (' Exercise 1: Simulate a standing wave ',
               2,
               'wave:exer:standingwave',
               'wave:exer:standingwave'),
              (' Exercise 2: Add storage of solution in a user action function ',
               2,
               'wave:exer:store:list',
               'wave:exer:store:list'),
              (' Exercise 3: Use a class for the user action function ',
               2,
               'wave:exer:store:list:class',
               'wave:exer:store:list:class'),
              (' Exercise 4: Compare several Courant numbers in one movie ',
               2,
               'wave:exer:multiple:C',
               'wave:exer:multiple:C'),
              (' Project 5: Calculus with 1D mesh functions ',
               2,
               'wave:exer:mesh1D:calculus',
               'wave:exer:mesh1D:calculus'),
              (' Generalization: reflecting boundaries ',
               1,
               'wave:pde2:Neumann',
               'wave:pde2:Neumann'),
              (' Neumann boundary condition ',
               2,
               'wave:pde2:Neumann:bc',
               'wave:pde2:Neumann:bc'),
              (' Discretization of derivatives at the boundary ',
               2,
               'wave:pde2:Neumann:discr',
               'wave:pde2:Neumann:discr'),
              (' Implementation of Neumann conditions ',
               2,
               'wave:pde2:Neumann:impl',
               'wave:pde2:Neumann:impl'),
              (' Index set notation ', 2, 'wave:indexset', 'wave:indexset'),
              (' Alternative implementation via ghost cells ',
               2,
               'wave:pde1:Neumann:ghost',
               'wave:pde1:Neumann:ghost'),
              (' Idea ', 3, None, '___sec42'),
              (' Implementation ', 3, None, '___sec43'),
              (' Generalization: variable wave velocity ',
               1,
               'wave:pde2:var:c',
               'wave:pde2:var:c'),
              (' The model PDE with a variable coefficient ',
               2,
               None,
               '___sec45'),
              (' Discretizing the variable coefficient ',
               2,
               'wave:pde2:var:c:ideas',
               'wave:pde2:var:c:ideas'),
              (' Computing the coefficient between mesh points ',
               2,
               'wave:pde2:var:c:means',
               'wave:pde2:var:c:means'),
              (' How a variable coefficient affects the stability ',
               2,
               'wave:pde2:var:c:stability',
               'wave:pde2:var:c:stability'),
              (' Neumann condition and a variable coefficient ',
               2,
               'wave:pde2:var:c:Neumann',
               'wave:pde2:var:c:Neumann'),
              (' Implementation of variable coefficients ',
               2,
               'wave:pde2:var:c:impl',
               'wave:pde2:var:c:impl'),
              (' A more general model PDE with variable coefficients ',
               2,
               None,
               '___sec51'),
              (' Generalization: damping ', 2, None, '___sec52'),
              (' Building a general 1D wave equation solver ',
               1,
               'wave:pde2:software',
               'wave:pde2:software'),
              (' User action function as a class ', 2, None, '___sec54'),
              (' Pulse propagation in two media ', 2, None, '___sec55'),
              (' Exercises ', 1, None, '___sec56'),
              (' Exercise 6: Find the analytical solution to a damped wave equation ',
               2,
               'wave:exer:standingwave:damped:uex',
               'wave:exer:standingwave:damped:uex'),
              (' Problem 7: Explore symmetry boundary conditions ',
               2,
               'wave:exer:symmetry:bc',
               'wave:exer:symmetry:bc'),
              (' Exercise 8: Send pulse waves through a layered medium ',
               2,
               'wave:app:exer:pulse1D',
               'wave:app:exer:pulse1D'),
              (' Exercise 9: Compare discretizations of a Neumann condition ',
               2,
               None,
               '___sec60'),
              (' Analysis of the difference equations ',
               1,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Properties of the solution of the wave equation ',
               2,
               'wave:pde1:properties',
               'wave:pde1:properties'),
              (' More precise definition of Fourier representations ',
               2,
               'wave:pde1:Fourier',
               'wave:pde1:Fourier'),
              (' Analysis of the finite difference scheme ',
               2,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Preliminary results ', 3, None, '___sec65'),
              (' Numerical wave propagation ', 3, None, '___sec66'),
              (' Numerical dispersion relation ', 3, None, '___sec67'),
              (' Extending the analysis to 2D and 3D ',
               2,
               'wave:pde1:analysis:2D3D',
               'wave:pde1:analysis:2D3D'),
              (' Finite difference methods for 2D and 3D wave equations ',
               1,
               'wave:2D3D',
               'wave:2D3D'),
              (' Multi-dimensional wave equations ',
               2,
               'wave:2D3D:models',
               'wave:2D3D:models'),
              (' Mesh ', 2, 'wave:2D3D:mesh', 'wave:2D3D:mesh'),
              (' Discretization ', 2, 'wave:2D3D:models', 'wave:2D3D:models'),
              (' Discretizing the PDEs ', 3, None, '___sec73'),
              (' Handling boundary conditions where is $u$ known ',
               3,
               None,
               '___sec74'),
              (' Discretizing the Neumann condition ', 3, None, '___sec75'),
              (' Implementation ', 1, 'wave:2D3D:impl', 'wave:2D3D:impl'),
              (' Scalar computations ',
               2,
               'wave2D3D:impl:scalar',
               'wave2D3D:impl:scalar'),
              (' Domain and mesh ', 3, None, '___sec78'),
              (' Solution arrays ', 3, None, '___sec79'),
              (' Index sets ', 3, None, '___sec80'),
              (' Computing the solution ', 3, None, '___sec81'),
              (' Vectorized computations ',
               2,
               'wave2D3D:impl:vectorized',
               'wave2D3D:impl:vectorized'),
              (' Verification ',
               2,
               'wave2D3D:impl:verify',
               'wave2D3D:impl:verify'),
              (' Testing a quadratic solution ', 3, None, '___sec84'),
              (' Migrating loops to Cython ',
               1,
               'wave2D3D:impl:Cython',
               'wave2D3D:impl:Cython'),
              (' Declaring variables and annotating the code ',
               2,
               None,
               '___sec86'),
              (' Visual inspection of the C translation ',
               2,
               None,
               '___sec87'),
              (' Building the extension module ', 3, None, '___sec88'),
              (' Calling the Cython function ', 2, None, '___sec89'),
              (' Efficiency ', 3, None, '___sec90'),
              (' Migrating loops to Fortran ', 1, None, '___sec91'),
              (' The Fortran subroutine ', 2, None, '___sec92'),
              (' Building the Fortran module with f2py ',
               3,
               None,
               '___sec93'),
              (' How to avoid array copying ', 2, None, '___sec94'),
              (' Efficiency ', 3, None, '___sec95'),
              (' Migrating loops to C via Cython ', 1, None, '___sec96'),
              (' Translating index pairs to single indices ',
               2,
               None,
               '___sec97'),
              (' The complete C code ', 2, None, '___sec98'),
              (' The Cython interface file ', 2, None, '___sec99'),
              (' Building the extension module ', 2, None, '___sec100'),
              (' Efficiency ', 3, None, '___sec101'),
              (' Migrating loops to C via f2py ', 1, None, '___sec102'),
              (' Migrating loops to C++ via f2py ', 2, None, '___sec103'),
              (' Using classes to implement a simulator ',
               1,
               None,
               '___sec104'),
              (' Exercises ', 1, None, '___sec105'),
              (' Exercise 10: Check that a solution fulfills the discrete model ',
               2,
               'wave:exer:quadratic:2D',
               'wave:exer:quadratic:2D'),
              (' Project 11: Calculus with 2D/3D mesh functions ',
               2,
               'wave:exer:mesh3D:calculus',
               'wave:exer:mesh3D:calculus'),
              (' Exercise 12: Implement Neumann conditions in 2D ',
               2,
               'wave:app:exer:wave2D:Neumann',
               'wave:app:exer:wave2D:Neumann'),
              (' Exercise 13: Test the efficiency of compiled loops in 3D ',
               2,
               'wave:exer:3D:f77:cy:efficiency',
               'wave:exer:3D:f77:cy:efficiency'),
              (' Applications of wave equations ', 1, 'wave:app', 'wave:app'),
              (' Waves on a string ',
               2,
               'wave:app:string',
               'wave:app:string'),
              (' Damping ', 3, None, '___sec112'),
              (' External forcing ', 3, None, '___sec113'),
              (' Modeling the tension via springs ', 3, None, '___sec114'),
              (' Waves on a membrane ',
               2,
               'wave:app:membrane',
               'wave:app:membrane'),
              (' Elastic waves in a rod ',
               2,
               'wave:app:elastic:rod',
               'wave:app:elastic:rod'),
              (' The acoustic model for seismic waves ',
               2,
               'wave:app:acoustic:seismic',
               'wave:app:acoustic:seismic'),
              (' Anisotropy ', 3, None, '___sec118'),
              (' Sound waves in liquids and gases ',
               2,
               'wave:app:sound',
               'wave:app:sound'),
              (' Spherical waves ',
               2,
               'wave:app:spherical',
               'wave:app:spherical'),
              (' The linear shallow water equations ',
               2,
               'wave:app:sw:2D',
               'wave:app:sw:2D'),
              (' Wind drag on the surface ', 3, None, '___sec122'),
              (' Bottom drag ', 3, None, '___sec123'),
              (" Effect of the Earth's rotation ", 3, None, '___sec124'),
              (' Waves in blood vessels ',
               2,
               'wave:app:blood',
               'wave:app:blood'),
              (' Electromagnetic waves ',
               2,
               'wave:app:light',
               'wave:app:light'),
              (' Exercises ', 1, 'wave:app:exer', 'wave:app:exer'),
              (' Exercise 14: Simulate waves on a non-homogeneous string ',
               2,
               'wave:app:exer:string:discont',
               'wave:app:exer:string:discont'),
              (' Exercise 15: Simulate damped waves on a string ',
               2,
               'wave:app:exer:string:damping',
               'wave:app:exer:string:damping'),
              (' Exercise 16: Simulate elastic waves in a rod ',
               2,
               'wave:app:exer:rod',
               'wave:app:exer:rod'),
              (' Exercise 17: Simulate spherical waves ',
               2,
               'wave:app:exer:spherical',
               'wave:app:exer:spherical'),
              (' Exercise 18: Explain why numerical noise occurs ',
               2,
               'wave:app:exer:pulse1D:analysis',
               'wave:app:exer:pulse1D:analysis'),
              (' Exercise 19: Investigate harmonic averaging in a 1D model ',
               2,
               'wave:app:exer:pulse1D:harmonic',
               'wave:app:exer:pulse1D:harmonic'),
              (' Problem 20: Implement open boundary conditions ',
               2,
               'wave:app:exer:radiationBC',
               'wave:app:exer:radiationBC'),
              (' Problem 21: Earthquake-generated tsunami over a subsea hill ',
               2,
               'wave:app:exer:tsunami1D:hill',
               'wave:app:exer:tsunami1D:hill'),
              (' Problem 22: Earthquake-generated tsunami over a 3D hill ',
               2,
               'wave:app:exer:tsunami2D:hill',
               'wave:app:exer:tsunami2D:hill'),
              (' Problem 23: Investigate Matplotlib for visualization ',
               2,
               'wave:app:exer:tsunami:hill:viz:matplotlib',
               'wave:app:exer:tsunami:hill:viz:matplotlib'),
              (' Problem 24: Investigate visualization packages ',
               2,
               'wave:app:exer:tsunami:hill:viz:packages',
               'wave:app:exer:tsunami:hill:viz:packages'),
              (' Problem 25: Implement loops in compiled languages ',
               2,
               'wave:app:exer:tsunami2D:hill:compiled',
               'wave:app:exer:tsunami2D:hill:compiled'),
              (' Exercise 26: Simulate seismic waves in 2D ',
               2,
               'wave:app:exer:seismic2D',
               'wave:app:exer:seismic2D'),
              (' Project 27: Model 3D acoustic waves in a room ',
               2,
               'wave:app:exer:acoustics',
               'wave:app:exer:acoustics'),
              (' Project 28: Solve a 1D transport equation ',
               2,
               'wave:app:exer:advec1D',
               'wave:app:exer:advec1D')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0003"></a>
<!-- begin top navigation -->
<a href="._part0002_main_wave-solarized.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0004_main_wave-solarized.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end top navigation -->

<p>
<!-- !split -->

<h2>Generalization: reflecting boundaries <a name="wave:pde2:Neumann"></a></h2>

<p>
The boundary condition \( u=0 \) makes \( u \) change sign at the boundary,
while the condition \( u_x=0 \) perfectly reflects the wave, see
a <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/demo_BC_gaussian/index.html">web page</a>
or a <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/demo_BC_gaussian/movie.flv">movie file</a>
for demonstration.
Our next task is to explain how to implement the boundary
condition \( u_x=0 \), which is
more complicated to express numerically and also to implement than
a given value of \( u \).
We shall present two methods for implementing \( u_x=0 \)
in a finite difference scheme, one based on deriving a modified
stencil at the boundary, and another one based on extending the mesh
with ghost cells and ghost points.

<h3>Neumann boundary condition <a name="wave:pde2:Neumann:bc"></a></h3>

<p>
When a wave hits a boundary and is to be reflected back, one applies
the condition

<p>
$$
\begin{equation}
 \frac{\partial u}{\partial n} \equiv \normalvec\cdot\nabla u = 0
\tag{23}
\thinspace .
\end{equation}
$$

The derivative \( \partial /\partial n \) is in the
outward normal direction from a general boundary.
For a 1D domain \( [0,L] \),
we have that

<p>
$$
\left.\frac{\partial}{\partial n}\right\vert_{x=L} =
\frac{\partial}{\partial x},\quad
\left.\frac{\partial}{\partial n}\right\vert_{x=0} = -
\frac{\partial}{\partial x}\ts
$$


<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Boundary condition terminology.</b>
Boundary conditions
that specify the value of \( \partial u/\partial n \),
or shorter \( u_n \), are known as
<a href="http://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann</a> conditions, while <a href="http://en.wikipedia.org/wiki/Dirichlet_conditions">Dirichlet conditions</a>
refer to specifications of \( u \).
When the values are zero (\( \partial u/\partial n=0 \) or \( u=0 \)) we speak
about <em>homogeneous</em> Neumann or Dirichlet conditions.
</div>
<h3>Discretization of derivatives at the boundary <a name="wave:pde2:Neumann:discr"></a></h3>

<p>
How can we incorporate the condition <a href="#mjx-eqn-23">(23)</a>
in the finite difference scheme?  Since we have used central
differences in all the other approximations to derivatives in the
scheme, it is tempting to implement <a href="#mjx-eqn-23">(23)</a> at
\( x=0 \) and \( t=t_n \) by the difference

<p>
$$
\begin{equation}
\frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
\thinspace .
\tag{24}
\end{equation}
$$

The problem is that \( u_{-1}^n \) is not a \( u \) value that is being
computed since the point is outside the mesh. However, if we combine
<a href="#mjx-eqn-24">(24)</a> with the scheme
<!-- <a href="._part0001_main_wave-solarized.html#mjx-eqn-10">(10)</a> -->
for \( i=0 \),

<p>
$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),
\tag{25}
\end{equation}
$$

we can eliminate the fictitious value \( u_{-1}^n \). We see that
\( u_{-1}^n=u_1^n \) from <a href="#mjx-eqn-24">(24)</a>, which
can be used in <a href="#mjx-eqn-25">(25)</a> to
arrive at a modified scheme for the boundary point \( u_0^{n+1} \):

<p>
$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i  + 2u^n_i + 2C^2
\left(u^{n}_{i+1}-u^{n}_{i}\right),\quad i=0 \thinspace . \end{equation}
$$

Figure <a href="#wave:pde1:fig:Neumann:stencil">4</a> visualizes this equation
for computing \( u^3_0 \) in terms of \( u^2_0 \), \( u^1_0 \), and
\( u^2_1 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Modified stencil at a boundary with a Neumann condition. <a name="wave:pde1:fig:Neumann:stencil"></a> </p></center>
<p><img src="mov-wave/wave1D_PDE_Neumann_stencil_gpl/wave_PDE_Neumann_n_left.png" align="bottom" width=500></p>
</center>

<p>
Similarly, <a href="#mjx-eqn-23">(23)</a> applied at \( x=L \)
is discretized by a central difference

<p>
$$
\begin{equation}
\frac{u_{N_x+1}^n - u_{N_x-1}^n}{2\Delta x} = 0
\thinspace .
\tag{26}
\end{equation}
$$

Combined with the scheme for \( i=N_x \) we get a modified scheme for
the boundary value \( u_{N_x}^{n+1} \):

<p>
$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + 2C^2
\left(u^{n}_{i-1}-u^{n}_{i}\right),\quad i=N_x \thinspace . \end{equation}
$$


<p>
The modification of the scheme at the boundary is also required for
the special formula for the first time step. How the stencil moves
through the mesh and is modified at the boundary can be illustrated
by an animation
in a <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/index.html">web page</a>
or a <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.flv">movie file</a>.

<h3>Implementation of Neumann conditions <a name="wave:pde2:Neumann:impl"></a></h3>

<p>
The implementation of the special formulas for the boundary points
can benefit from using the general formula for the interior points
also at the boundaries,
but replacing \( u_{i-1}^n \) by \( u_{i+1}^n \) when computing
\( u_i^{n+1} \) for \( i=0 \) and
\( u_{i+1}^n \) by \( u_{i-1}^n \) for \( i=N_x \). This is achieved by
just replacing the index
\( i-1 \) by \( i+1 \) for \( i=0 \) and \( i+1 \) by \( i-1 \) for
\( i=N_x \). In a program, we introduce variables to hold the value of
the offset indices: <code>im1</code> for <code>i-1</code> and <code>ip1</code> for <code>i+1</code>.
It is now just a manner of defining <code>im1</code> and <code>ip1</code> properly
for the internal points and the boundary points.
The coding for the latter reads

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">i = 0
ip1 = i+1
im1 = ip1  # i-1 -&gt; i+1
u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])

i = Nx
im1 = i-1
ip1 = im1  # i+1 -&gt; i-1
u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])
</pre></div>
<p>
We can in fact create one loop over both the internal and boundary
points and use only one updating formula:

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">for i in range(0, Nx+1):
    ip1 = i+1 if i &lt; Nx else i-1
    im1 = i-1 if i &gt; 0  else i+1
    u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])
</pre></div>
<p>
The program <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn0.py"><tt>wave1D_dn0.py</tt></a>
contains a complete implementation of the 1D wave equation with
boundary conditions \( u_x = 0 \) at \( x=0 \) and \( x=L \).

<h3>Index set notation <a name="wave:indexset"></a></h3>

<p>
We shall introduce a special notation for index sets, consisting of
writing \( x_i \), \( i\in\Ix \), instead of \( i=0,\ldots,N_x \).
Obviously, \( \Ix \) must be the set \( \Ix =\{0,\ldots,N_x\} \), but it
is often advantageous to have a symbol for this set rather than
specifying all its elements. This saves writing and makes
specification of algorithms and implementation of computer code easier.

<p>
The first index in the set will be denoted \( \setb{\Ix} \)
and the last \( \sete{\Ix} \). Sometimes we need to count from the second
element in the set, and the notation \( \setr{\Ix} \) is then used.
Correspondingly, \( \setl{\Ix} \) means \( \{0,\ldots,N_x-1\} \).  All the
indices corresponding to inner grid points are
\( \seti{\Ix}=\{1,\ldots,N_x-1\} \).  For the time domain we find it
natural to explicitly use 0 as the first index, so we will usually
write \( n=0 \) and \( t_0 \) rather than \( n=\It^0 \). We also avoid notation
like \( x_{\sete{\Ix}} \) and will instead use \( x_i \), \( i=\sete{\Ix} \).

<p>
The Python code associated with index sets applies the following
conventions:

<p>
<table border="1">
<tr><td align="center"><b>        Notation       </b></td> <td align="center"><b>         Python        </b></td> </tr>
<tr><td align="left">   \( \Ix \)                </td> <td align="left">   <code>Ix</code>          </td> </tr>
<tr><td align="left">   \( \setb{\Ix} \)         </td> <td align="left">   <code>Ix[0]</code>       </td> </tr>
<tr><td align="left">   \( \sete{\Ix} \)         </td> <td align="left">   <code>Ix[-1]</code>      </td> </tr>
<tr><td align="left">   \( \setl{\Ix} \)         </td> <td align="left">   <code>Ix[1:]</code>      </td> </tr>
<tr><td align="left">   \( \setr{\Ix} \)         </td> <td align="left">   <code>Ix[:-1]</code>     </td> </tr>
<tr><td align="left">   \( \seti{\Ix} \)         </td> <td align="left">   <code>Ix[1:-1]</code>    </td> </tr>
</table>
<p>
An important feature of the index set notation is that it
keeps our formulas and code independent of how
we count mesh points. For example, the notation \( i\in\Ix \) or \( i=\setb{\Ix} \)
remains the same whether \( \Ix \) is defined as above or as starting at 1,
i.e., \( \Ix=\{1,\ldots,Q\} \). Similarly, we can in the code define
<code>Ix=range(Nx+1)</code> or <code>Ix=range(1,Q)</code>, and expressions
like <code>Ix[0]</code> and <code>Ix[1:-1]</code> remain correct. One application where
the index set notation is convenient is
conversion of code from a language where arrays has base index 0 (e.g.,
Python and C) to languages where the base index is 1 (e.g., MATLAB and
Fortran). Another important application is implementation of
Neumann conditions via ghost points (see next section).

<p>
For the current problem setting in the \( x,t \) plane, we work with
the index sets

<p>
$$
\begin{equation}
\Ix = \{0,\ldots,N_x\},\quad \It = \{0,\ldots,N_t\},
\end{equation}
$$

defined in Python as

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>)
It = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt+<span style="color: #B452CD">1</span>)
</pre></div>
<p>
A finite difference scheme can with the index set notation be specified as

<p>
$$
\begin{align*}
u^{n+1}_i &= -u^{n-1}_i  + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i}+u^{n}_{i-1}\right),
\quad i\in\seti{\Ix},\ n\in\seti{\It},\\ 
u_i &= 0,
\quad i=\setb{\Ix},\ n\in\seti{\It},\\ 
u_i &= 0,
\quad i=\sete{\Ix},\ n\in\seti{\It},
\end{align*}
$$

and implemented by code like

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> It[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
        u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
               C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])
    i = Ix[<span style="color: #B452CD">0</span>];  u[i] = <span style="color: #B452CD">0</span>
    i = Ix[-<span style="color: #B452CD">1</span>]; u[i] = <span style="color: #B452CD">0</span>
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Notice.</b>
The program <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn.py"><tt>wave1D_dn.py</tt></a>
applies the index set notation and
solves the 1D wave equation \( u_{tt}=c^2u_{xx}+f(x,t) \) with
quite general boundary and initial conditions:

<p>

<ul>
  <li> \( x=0 \): \( u=U_0(t) \) or \( u_x=0 \)</li>
  <li> \( x=L \): \( u=U_L(t) \) or \( u_x=0 \)</li>
  <li> \( t=0 \): \( u=I(x) \)</li>
  <li> \( t=0 \): \( u_t=I(x) \)</li>
</ul>

The program combines Dirichlet and Neumann conditions, scalar and vectorized
implementation of schemes, and the index notation into one piece of code.
A lot of test examples are also included in the program:

<p>

<ul>
 <li> A rectangular plug profile as initial condition (easy to use as
   test example as the rectangle should jump one cell per time
   step when \( C=1 \), without any numerical errors).</li>
 <li> A Gaussian function as initial condition.</li>
 <li> A triangular profile as initial condition, which resembles the
   typical initial shape of a guitar string.</li>
 <li> A sinusoidal variation of \( u \) at \( x=0 \) and either \( u=0 \) or
   \( u_x=0 \) at \( x=L \).</li>
 <li> An exact analytical solution \( u(x,t)=\cos(m\pi t/L)\sin(\frac{1}{2}m\pi x/L) \), which can be used for convergence rate tests.</li>
</ul>
</div>
<h3>Alternative implementation via ghost cells <a name="wave:pde1:Neumann:ghost"></a></h3>

<h4>Idea  <a name="___sec42"></a></h4>

<p>
Instead of modifying the scheme at the boundary, we can introduce
extra points outside the domain such that the fictitious values
\( u_{-1}^n \) and \( u_{N_x+1}^n \)
are defined in the mesh.
Adding the intervals \( [-\Delta x,0] \) and \( [L, L+\Delta x] \),
often referred to as <em>ghost cells</em>, to the mesh gives us all the
needed mesh points, corresponding to \( i=-1,0,\ldots,N_x,N_x+1 \).
The extra points \( i=-1 \) and \( i=N_x+1 \) are known as <em>ghost points</em>,
and values at these points, \( u_{-1}^n \) and \( u_{N_x+1}^n \), are
called <em>ghost values</em>.

<p>
The important idea is
to ensure that we always have
$$ u_{-1}^n = u_{1}^n\hbox{ and } u_{N_x-1}^n = u_{N_x+1}^n,$$

because then
the application of the standard scheme at a boundary point \( i=0 \) or \( i=N_x \)
will be correct and guarantee that the solution is compatible with the
boundary condition \( u_x=0 \).

<h4>Implementation  <a name="___sec43"></a></h4>

<p>
The <code>u</code> array now needs extra elements corresponding to the ghost cells
and points. Two new point values are needed:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u   = zeros(Nx+<span style="color: #B452CD">3</span>)
</pre></div>
<p>
The arrays <code>u_1</code> and <code>u_2</code> must be defined accordingly.

<p>
Unfortunately, a major indexing problem arises with ghost cells.
The reason is that Python indices <em>must</em> start
at 0 and <code>u[-1]</code> will always mean the last element in <code>u</code>.
This fact gives, apparently, a mismatch between the mathematical
indices \( i=-1,0,\ldots,N_x+1 \) and the Python indices running over
<code>u</code>: <code>0,..,Nx+2</code>. One remedy is to change the mathematical notation
of the scheme, as in

<p>
$$ u^{n+1}_i = \cdots,\quad i=1,\ldots,N_x+1,$$

meaning that the ghost points correspond to \( i=0 \) and \( i=N_x+1 \).
A better solution is to use the ideas of the section <a href="#wave:indexset">Index set notation</a>:
we hide the specific index value in an index set and operate with
inner and boundary points using the index set notation.

<p>
To this end, we define <code>u</code> with proper length and <code>Ix</code> to be the corresponding
indices for the real physical points:

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u = zeros(Nx+3)
Ix = range(1, u.shape[0]-1)
</pre></div>
<p>
That is, the boundary points have indices <code>Ix[0]</code> and <code>Ix[-1]</code> (as before).
We first update the solution at all physical mesh points (i.e., interior
points in the mesh extended with ghost cells):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix:
    u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
           C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])
</pre></div>
<p>
It remains to update the ghost points. For a boundary condition \( u_x=0 \),
the ghost value must equal to the value at the associated inner mesh
point. Computer code makes this statement precise:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">i = Ix[<span style="color: #B452CD">0</span>]          <span style="color: #228B22"># x=0 boundary</span>
u[i-<span style="color: #B452CD">1</span>] = u[i+<span style="color: #B452CD">1</span>]
i = Ix[-<span style="color: #B452CD">1</span>]         <span style="color: #228B22"># x=L boundary</span>
u[i-<span style="color: #B452CD">1</span>] = u[i+<span style="color: #B452CD">1</span>]
</pre></div>
<p>
The physical solution to be plotted is now in <code>u[1:-1]</code>, so this slice is
the quantity to be returned from a solver function.
A complete implementation appears in the program
<a href="http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn0_ghost.py"><tt>wave1D_dn0_ghost.py</tt></a>.

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Warning.</b>
We have to be careful with how the spatial and temporal mesh
points are stored. Say we let <code>x</code> be the physical mesh points,

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #fbeed5"><pre style="line-height: 125%">x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)
</pre></div>
<p>
"Standard coding" of the initial condition,

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #fbeed5"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix:
    u_1[i] = I(x[i])
</pre></div>
<p>
becomes wrong, since <code>u_1</code> and <code>x</code> have different lengths and the index <code>i</code>
corresponds to two different mesh points. In fact, <code>x[i]</code> corresponds
to <code>u[1+i]</code>. A correct implementation is

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #fbeed5"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix:
    u_1[i] = I(x[i-Ix[<span style="color: #B452CD">0</span>]])
</pre></div>
<p>
Similarly, a source term usually coded as <code>f(x[i], t[n])</code> is incorrect
if <code>x</code> is defined to be the physical points.

<p>
An alternative remedy is to let <code>x</code> also cover the ghost points such that
<code>u[i]</code> is the value at <code>x[i]</code>. This is the recommended approach.
</div>
<p>
The ghost cell is only added to the boundary where we have a Neumann
condition. Suppose we have a Dirichlet condition at \( x=L \) and
a homogeneous Neumann condition at \( x=0 \). The relevant implementation
then becomes

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u = zeros(Nx+<span style="color: #B452CD">2</span>)
Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">0</span>]-<span style="color: #B452CD">1</span>)
...
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix[:-<span style="color: #B452CD">1</span>]:
    u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
           C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
           dt2*f(x[i], t[n])
i = Ix[-<span style="color: #B452CD">1</span>]
u[i] = U_0       <span style="color: #228B22"># set Dirichlet value</span>
i = Ix[<span style="color: #B452CD">0</span>]
u[i-<span style="color: #B452CD">1</span>] = u[i+<span style="color: #B452CD">1</span>]  <span style="color: #228B22"># update ghost value</span>
</pre></div>
<p>
The physical solution to be plotted is now in <code>u[1:]</code>.

<h2>Generalization: variable wave velocity <a name="wave:pde2:var:c"></a></h2>

<p>
Our next generalization of the 1D wave equation <a href="._part0001_main_wave-solarized.html#mjx-eqn-1">(1)</a> or
<a href="._part0001_main_wave-solarized.html#mjx-eqn-12">(12)</a> is to allow for a variable wave velocity \( c \):
\( c=c(x) \), usually motivated by wave motion in a domain composed of
different physical media with different properties for
propagating waves and hence different wave velocities \( c \).
Figure

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Left: wave entering another medium; right: transmitted and reflected wave . <a name="wave:pde1:fig:pulse1:two:media"></a> </p></center>
<p><img src="fig-wave/pulse1_in_two_media.png" align="bottom" width=800></p>
</center>

<h3>The model PDE with a variable coefficient  <a name="___sec45"></a></h3>

<p>
Instead of working with the squared quantity \( c^2(x) \) we
shall for notational convenience introduce \( q(x) = c^2(x) \).
A 1D wave equation with variable wave velocity often takes the form

<p>
$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) + f(x,t)
\tag{27}
\thinspace .
\end{equation}
$$

This equation sampled at a mesh point \( (x_i,t_n) \) reads
$$
\frac{\partial^2 }{\partial t^2} u(x_i,t_n) =
\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) + f(x_i,t_n),
$$

where the only new term is
$$
\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) = \left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\thinspace .
$$

<h3>Discretizing the variable coefficient <a name="wave:pde2:var:c:ideas"></a></h3>

<p>
The principal idea is to first discretize the outer derivative.
Define
$$ \phi = q(x)
\frac{\partial u}{\partial x},
$$

and use a centered derivative around \( x=x_i \) for the derivative of \( \phi \):
$$
\left[\frac{\partial\phi}{\partial x}\right]^n_i
\approx \frac{\phi_{i+\frac{1}{2}} - \phi_{i-\frac{1}{2}}}{\Delta x}
= [D_x\phi]^n_i
\thinspace .
$$

Then discretize
$$
\phi_{i+\frac{1}{2}}  = q_{i+\frac{1}{2}}
\left[\frac{\partial u}{\partial x}\right]^n_{i+\frac{1}{2}}
\approx q_{i+\frac{1}{2}} \frac{u^n_{i+1} - u^n_{i}}{\Delta x}
= [q D_x u]_{i+\frac{1}{2}}^n
\thinspace .
$$

Similarly,
$$
\phi_{i-\frac{1}{2}}  = q_{i-\frac{1}{2}}
\left[\frac{\partial u}{\partial x}\right]^n_{i-\frac{1}{2}}
\approx q_{i-\frac{1}{2}} \frac{u^n_{i} - u^n_{i-1}}{\Delta x}
= [q D_x u]_{i-\frac{1}{2}}^n
\thinspace .
$$

These intermediate results are now combined to
$$
\begin{equation}
\left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\approx \frac{1}{\Delta x^2}
\left( q_{i+\frac{1}{2}} \left({u^n_{i+1} - u^n_{i}}\right)
- q_{i-\frac{1}{2}} \left({u^n_{i} - u^n_{i-1}}\right)\right)
\tag{28}
\thinspace .
\end{equation}
$$

With operator notation we can write the discretization as
$$
\begin{equation}
\left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\approx [D_xq D_x u]^n_i
\tag{29}
\thinspace .
\end{equation}
$$


<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Remark.</b>
Many are tempted to use the chain rule on the
term \( \frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) \), but this is not a good idea
when discretizing such a term.
</div>
<p>
<!-- Needs some better explanation here - maybe the exact solution of a -->
<!-- poisson type problem (piecewise linear solution) failes if we use -->
<!-- the chain rule? -->

<h3>Computing the coefficient between mesh points <a name="wave:pde2:var:c:means"></a></h3>

<p>
If \( q \) is a known function of \( x \), we can easily evaluate
\( q_{i+\frac{1}{2}} \) simply as \( q(x_{i+\frac{1}{2}}) \) with
\( x_{i+\frac{1}{2}} = x_i + \frac{1}{2}\Delta x \).
However, in many cases \( c \), and hence \( q \),
is only known as a discrete function, often at the mesh points \( x_i \).
Evaluating \( q \) between two mesh points \( x_i \) and \( x_{i+1} \) can then
be done by averaging in three ways:

<p>
$$
\begin{align}
q_{i+\frac{1}{2}} &\approx
\frac{1}{2}\left( q_{i} + q_{i+1}\right) =
[\overline{q}^{x}]_i,
\quad &\hbox{(arithmetic mean)}
\tag{30}\\ 
q_{i+\frac{1}{2}} &\approx
2\left( \frac{1}{q_{i}} + \frac{1}{q_{i+1}}\right)^{-1},
\quad &\hbox{(harmonic mean)}
\tag{31}\\ 
q_{i+\frac{1}{2}} &\approx
\left(q_{i}q_{i+1}\right)^{1/2},
\quad &\hbox{(geometric mean)}
\tag{32}
\end{align}
$$

The arithmetic mean in <a href="#mjx-eqn-30">(30)</a> is by
far the most commonly used averaging technique.

<p>
With the operator notation from <a href="#mjx-eqn-30">(30)</a>
we can specify the discretization of the complete variable-coefficient
wave equation in a compact way:
$$
\begin{equation}
\lbrack D_tD_t u = D_x\overline{q}^{x}D_x u + f\rbrack^{n}_i
\thinspace .
\tag{33}
\end{equation}
$$

From this notation we immediately see what kind of differences that
each term is approximated with. The notation \( \overline{q}^{x} \)
also specifies that the variable coefficient is approximated by
an arithmetic mean, the definition being
\( [\overline{q}^{x}]_{i+\frac{1}{2}}=(q_i+q_{i+1})/2 \).
With the notation \( [D_xq D_x u]^n_i \),
we specify that \( q \) is evaluated directly, as a function,
between the mesh points:
\( q(x_{i-\frac{1}{2}}) \) and \( q(x_{i+\frac{1}{2}}) \).

<p>
Before any implementation, it remains to solve
<a href="#mjx-eqn-33">(33)</a> with respect to \( u_i^{n+1} \):

<p>
$$
\begin{align}
u^{n+1}_i &= - u_i^{n-1}  + 2u_i^n + \nonumber\\ 
&\quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
\frac{1}{2}(q_{i} + q_{i+1})(u_{i+1}^n - u_{i}^n) -
\frac{1}{2}(q_{i} + q_{i-1})(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\\ 
& \quad \Delta t^2 f^n_i
\thinspace .
\tag{34}
\end{align}
$$

<h3>How a variable coefficient affects the stability <a name="wave:pde2:var:c:stability"></a></h3>

<p>
The stability criterion derived in the section <a href="._part0004_main_wave-solarized.html#wave:pde1:analysis">Analysis of the finite difference scheme</a>
reads \( \Delta t\leq \Delta x/c \). If \( c=c(x) \), the criterion will depend
on the spatial location. We must therefore choose a \( \Delta t \) that
is small enough such that no mesh cell has \( \Delta x/c(x) >\Delta t \).
That is, we must use the largest \( c \) value in the criterion:

<p>
$$
\begin{equation}
\Delta t \leq \beta \frac{\Delta x}{\max_{x\in [0,L]}c(x)}
\thinspace .
\end{equation}
$$

The parameter \( \beta \) is included as a safety factor: in some problems with a
significantly varying \( c \) it turns out that one must choose \( \beta <1 \) to
have stable solutions (\( \beta =0.9 \) may act as an all-round value).

<h3>Neumann condition and a variable coefficient <a name="wave:pde2:var:c:Neumann"></a></h3>

<p>
Consider a Neumann condition \( \partial u/\partial x=0 \) at \( x=L=N_x\Delta x \),
discretized as

<p>
$$ \frac{u_{i+1}^{n} - u_{i-1}^n}{2\Delta x} = 0\quad u_{i+1}^n = u_{i-1}^n,
$$

for \( i=N_x \). Using the scheme <a href="#mjx-eqn-34">(34)</a>
at the end point \( i=N_x \) with \( u_{i+1}^n=u_{i-1}^n \) results in

<p>
$$
\begin{align}
u^{n+1}_i &= - u_i^{n-1}  + 2u_i^n + \nonumber\\ 
&\quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
q_{i+\frac{1}{2}}(u_{i-1}^n - u_{i}^n) -
q_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\\ 
& \quad \Delta t^2 f^n_i\\ 
&= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
(q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}})(u_{i-1}^n - u_{i}^n) +
\Delta t^2 f^n_i\\ 
&\approx - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
2q_{i}(u_{i-1}^n - u_{i}^n) + \Delta t^2 f^n_i
\thinspace .
\tag{35}
\end{align}
$$

Here we used the approximation

<p>
$$
\begin{align}
q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}} &=
q_i + \left(\frac{dq}{dx}\right)_i \Delta x
+ \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots
+\nonumber\\ 
&\quad q_i - \left(\frac{dq}{dx}\right)_i \Delta x
+ \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots\nonumber\\ 
&= 2q_i + 2\left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + {\cal O}(\Delta x^4)
\nonumber\\ 
&\approx 2q_i
\thinspace .
\end{align}
$$


<p>
An alternative derivation may apply the arithmetic mean of \( q \) in
<a href="#mjx-eqn-34">(34)</a>, leading to the term

<p>
$$ (q_i + \frac{1}{2}(q_{i+1}+q_{i-1}))(u_{i-1}^n-u_i^n)\ts$$

Since \( \frac{1}{2}(q_{i+1}+q_{i-1}) = q_i + {\cal O}(\Delta x^2) \),
we end up with \( 2q_i(u_{i-1}^n-u_i^n) \) for \( i=N_x \) as we did above.

<p>
A common technique in implementations of \( \partial u/\partial x=0 \)
boundary conditions is to assume \( dq/dx=0 \) as well. This implies
\( q_{i+1}=q_{i-1} \) and \( q_{i+1/2}=q_{i-1/2} \) for \( i=N_x \).
The implications for the scheme are

<p>
$$
\begin{align}
u^{n+1}_i &= - u_i^{n-1}  + 2u_i^n + \nonumber\\ 
&\quad \left(\frac{\Delta x}{\Delta t}\right)^2 \left(
q_{i+\frac{1}{2}}(u_{i-1}^n - u_{i}^n) -
q_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\\ 
& \quad \Delta t^2 f^n_i\\ 
&= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta x}{\Delta t}\right)^2
2q_{i-\frac{1}{2}}(u_{i-1}^n - u_{i}^n) +
\Delta t^2 f^n_i
\thinspace .
\tag{36}
\end{align}
$$

<h3>Implementation of variable coefficients <a name="wave:pde2:var:c:impl"></a></h3>

<p>
The implementation of the scheme with a variable wave velocity
may assume that \( c \) is available as an array <code>c[i]</code> at
the spatial mesh points. The following loop is a straightforward
implementation of the scheme <a href="#mjx-eqn-34">(34)</a>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
           C2*(<span style="color: #B452CD">0.5</span>*(q[i] + q[i+<span style="color: #B452CD">1</span>])*(u_1[i+<span style="color: #B452CD">1</span>] - u_1[i])  - \ 
               <span style="color: #B452CD">0.5</span>*(q[i] + q[i-<span style="color: #B452CD">1</span>])*(u_1[i] - u_1[i-<span style="color: #B452CD">1</span>])) + \ 
           dt2*f(x[i], t[n])
</pre></div>
<p>
The coefficient <code>C2</code> is now defined as <code>(dt/dx)**2</code> and <em>not</em> as the
squared Courant number since the wave velocity is variable and appears
inside the parenthesis.

<p>
With Neumann conditions \( u_x=0 \) at the
boundary, we need to combine this scheme with the discrete
version of the boundary condition, as shown in the section <a href="#wave:pde2:var:c:Neumann">Neumann condition and a variable coefficient</a>.
Nevertheless, it would be convenient to reuse the formula for the
interior points and just modify the indices <code>ip1=i+1</code> and <code>im1=i-1</code>
as we did in the section <a href="#wave:pde2:Neumann:impl">Implementation of Neumann conditions</a>. Assuming
\( dq/dx=0 \) at the boundaries, we can implement the scheme at
the boundary with the following code.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">i = <span style="color: #B452CD">0</span>
ip1 = i+<span style="color: #B452CD">1</span>
im1 = ip1
u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
       C2*(<span style="color: #B452CD">0.5</span>*(q[i] + q[ip1])*(u_1[ip1] - u_1[i])  - \ 
           <span style="color: #B452CD">0.5</span>*(q[i] + q[im1])*(u_1[i] - u_1[im1])) + \ 
       dt2*f(x[i], t[n])
</pre></div>
<p>
With ghost cells we can just reuse the formula for the interior
points also at the boundary, provided that the ghost values of both
\( u \) and \( q \) are correctly updated to ensure \( u_x=0 \) and \( q_x=0 \).

<p>
A vectorized version of the scheme with a variable coefficient
at internal points in the mesh becomes

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = - u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
          C2*(<span style="color: #B452CD">0.5</span>*(q[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + q[<span style="color: #B452CD">2</span>:])*(u_1[<span style="color: #B452CD">2</span>:] - u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]) -
              <span style="color: #B452CD">0.5</span>*(q[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + q[:-<span style="color: #B452CD">2</span>])*(u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] - u_1[:-<span style="color: #B452CD">2</span>])) + \ 
          dt2*f(x[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>], t[n])
</pre></div>

<h3>A more general model PDE with variable coefficients  <a name="___sec51"></a></h3>

<p>
Sometimes a wave PDE has a variable coefficient also in front of
the time-derivative term:

<p>
$$
\begin{equation}
\varrho(x)\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) + f(x,t)
\tag{37}
\thinspace .
\end{equation}
$$

A natural scheme is

<p>
$$
\begin{equation}
[\varrho D_tD_t u = D_x\overline{q}^xD_x u + f]^n_i
\thinspace .
\end{equation}
$$

We realize that the \( \varrho \) coefficient poses no particular
difficulty because the only value \( \varrho_i^n \) enters the formula
above (when written out). There is hence no need for any averaging
of \( \varrho \). Often, \( \varrho \) will be moved to the right-hand side,
also without any difficulty:

<p>
$$
\begin{equation}
[D_tD_t u = \varrho^{-1}D_x\overline{q}^xD_x u + f]^n_i
\thinspace .
\end{equation}
$$

<h3>Generalization: damping  <a name="___sec52"></a></h3>

<p>
Waves die out by two mechanisms. In 2D and 3D the energy of the wave
spreads out in space, and energy conservation then requires
the amplitude to decrease. This effect is not present in 1D.
Damping is another cause of amplitude reduction. For example,
the vibrations of a string die out because of damping due to
air resistance and non-elastic effects in the string.

<p>
The simplest way of including damping is to add a first-order derivative
to the equation (in the same way as friction forces enter a vibrating
mechanical system):
$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} + b\frac{\partial u}{\partial t} =
c^2\frac{\partial^2 u}{\partial x^2}
 + f(x,t),
\tag{38}
\end{equation}
$$

where \( b \geq 0 \) is a prescribed damping coefficient.

<p>
A typical discretization of <a href="#mjx-eqn-38">(38)</a> in terms of centered
differences reads

<p>
$$
\begin{equation}
[D_tD_t u + bD_{2t}u = c^2D_xD_x u + f]^n_i
\thinspace .
\tag{39}
\end{equation}
$$

Writing out the equation and solving for the unknown \( u^{n+1}_i \)
gives the scheme

<p>
$$
\begin{equation}
u^{n+1}_i = (1 + \frac{1}{2}b\Delta t)^{-1}((\frac{1}{2}b\Delta t -1)
u^{n-1}_i + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \Delta t^2 f^n_i),
\tag{40}
\end{equation}
$$

for \( i\in\seti{\Ix} \) and \( n\geq 1 \).
New equations must be derived for \( u^1_i \), and for boundary points in case
of Neumann conditions.

<p>
The damping is very small in many wave phenomena and then only evident
for very long time simulations. This makes the standard wave equation
without damping relevant for a lot of applications.

<h2>Building a general 1D wave equation solver <a name="wave:pde2:software"></a></h2>

<p>
The program <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py"><tt>wave1D_dn_vc.py</tt></a>
is a fairly general code for 1D wave propagation problems that
targets the following initial-boundary value problem

<p>
$$
\begin{align}
u_t &= (c^2(x)u_x)_x + f(x,t),\quad &x\in (0,L),\ t\in (0,T]
\tag{41}\\ 
u(x,0) &= I(x),\quad &x\in [0,L]\\ 
u_t(x,0) &= V(t),\quad &x\in [0,L]\\ 
u(0,t) &= U_0(t)\hbox{ or } u_x(0,t)=0,\quad &t\in (0,T]\\ 
u(L,t) &= U_L(t)\hbox{ or } u_x(L,t)=0,\quad &t\in (0,T]
\tag{42}
\end{align}
$$


<p>
The <code>solver</code> function is a natural extension of the simplest
<code>solver</code> function in the initial <code>wave1D_u0_s.py</code> program,
extended with Neumann boundary conditions (\( u_x=0 \)),
a possibly time-varying boundary condition on \( u \) (\( U_0(t) \), \( U_L(t) \)),
and a variable wave velocity. The different code segments needed
to make these extensions are shown and commented upon in the
preceding text.

<p>
The vectorization is only applied inside the time loop, not for the
initial condition or the first time steps, since this initial work
is negligible for long time simulations in 1D problems.

<p>
The following sections explain various more advanced programming
techniques applied in the general 1D wave equation solver.

<h3>User action function as a class  <a name="___sec54"></a></h3>

<p>
A useful feature in the <code>wave1D_dn_vc.py</code> program is the specification of
the <code>user_action</code> function as a class. Although the <code>plot_u</code>
function in the <code>viz</code> function of previous <code>wave1D*.py</code> programs
remembers the local variables in the <code>viz</code> function, it is a
cleaner solution to store the needed variables together with
the function, which is exactly what a class offers.

<p>
A class for flexible plotting, cleaning up files, and making a movie
files like function <code>viz</code> and <code>plot_u</code> did can be coded as follows:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">PlotSolution</span>:
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Class for the user_action function in solver.</span>
<span style="color: #CD5555">    Visualizes the solution only.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>,
                 casename=<span style="color: #CD5555">&#39;tmp&#39;</span>,    <span style="color: #228B22"># Prefix in filenames</span>
                 umin=-<span style="color: #B452CD">1</span>, umax=<span style="color: #B452CD">1</span>,   <span style="color: #228B22"># Fixed range of y axis</span>
                 pause_between_frames=<span style="color: #658b00">None</span>,  <span style="color: #228B22"># Movie speed</span>
                 backend=<span style="color: #CD5555">&#39;matplotlib&#39;</span>,       <span style="color: #228B22"># or &#39;gnuplot&#39;</span>
                 screen_movie=<span style="color: #658b00">True</span>, <span style="color: #228B22"># Show movie on screen?</span>
                 title=<span style="color: #CD5555">&#39;&#39;</span>,          <span style="color: #228B22"># Extra message in title</span>
                 every_frame=<span style="color: #B452CD">1</span>):    <span style="color: #228B22"># Show every_frame frame</span>
        <span style="color: #658b00">self</span>.casename = casename
        <span style="color: #658b00">self</span>.yaxis = [umin, umax]
        <span style="color: #658b00">self</span>.pause = pause_between_frames
        module = <span style="color: #CD5555">&#39;scitools.easyviz.&#39;</span> + backend + <span style="color: #CD5555">&#39;_&#39;</span>
        <span style="color: #8B008B; font-weight: bold">exec</span>(<span style="color: #CD5555">&#39;import %s as plt&#39;</span> % module)
        <span style="color: #658b00">self</span>.plt = plt
        <span style="color: #658b00">self</span>.screen_movie = screen_movie
        <span style="color: #658b00">self</span>.title = title
        <span style="color: #658b00">self</span>.every_frame = every_frame

        <span style="color: #228B22"># Clean up old movie frames</span>
        <span style="color: #8B008B; font-weight: bold">for</span> filename <span style="color: #8B008B">in</span> glob(<span style="color: #CD5555">&#39;frame_*.png&#39;</span>):
            os.remove(filename)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__call__</span>(<span style="color: #658b00">self</span>, u, x, t, n):
        <span style="color: #8B008B; font-weight: bold">if</span> n % <span style="color: #658b00">self</span>.every_frame != <span style="color: #B452CD">0</span>:
            <span style="color: #8B008B; font-weight: bold">return</span>
        title = <span style="color: #CD5555">&#39;t=%f&#39;</span> % t[n]
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.title:
            title = <span style="color: #658b00">self</span>.title + <span style="color: #CD5555">&#39; &#39;</span> + title
        <span style="color: #658b00">self</span>.plt.plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>,
                     xlabel=<span style="color: #CD5555">&#39;x&#39;</span>, ylabel=<span style="color: #CD5555">&#39;u&#39;</span>,
                     axis=[x[<span style="color: #B452CD">0</span>], x[-<span style="color: #B452CD">1</span>],
                           <span style="color: #658b00">self</span>.yaxis[<span style="color: #B452CD">0</span>], <span style="color: #658b00">self</span>.yaxis[<span style="color: #B452CD">1</span>]],
                     title=title,
                     show=<span style="color: #658b00">self</span>.screen_movie)
        <span style="color: #228B22"># pause</span>
        <span style="color: #8B008B; font-weight: bold">if</span> t[n] == <span style="color: #B452CD">0</span>:
            time.sleep(<span style="color: #B452CD">2</span>)  <span style="color: #228B22"># let initial condition stay 2 s</span>
        <span style="color: #8B008B; font-weight: bold">else</span>:
            <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">self</span>.pause <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span>:
                pause = <span style="color: #B452CD">0.2</span> <span style="color: #8B008B; font-weight: bold">if</span> u.size &lt; <span style="color: #B452CD">100</span> <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">0</span>
            time.sleep(pause)

        <span style="color: #658b00">self</span>.plt.savefig(<span style="color: #CD5555">&#39;%s_frame_%04d.png&#39;</span> % (<span style="color: #658b00">self</span>.casename, n))
</pre></div>
<p>
Understanding this class requires quite some familiarity with Python
in general and class programming in particular.

<p>
<!-- Since all the plot frames are to be collected in a separate subdirectory, -->
<!-- we demand a (logical) "casename" from the user that is used as -->
<!-- subdirectory name in the <code>make_movie_file</code> method. The statements -->
<!-- in this method perform actions normally done in the operating -->
<!-- system, but the Python interface via <code>shutil.rmtree</code>, <code>os.mkdir</code>, -->
<!-- <code>os.chdir</code>, etc., works on all platforms where Python works. -->

<p>
The constructor shows how we can flexibly import the plotting engine
as (typically) <code>scitools.easyviz.gnuplot_</code> or
<code>scitools.easyviz.matplotlib_</code> (note the trailing underscore).
With the <code>screen_movie</code> parameter
we can suppress displaying each movie frame on the screen.
Alternatively, for slow movies associated with
fine meshes, one can set
<code>every_frame</code> to, e.g., 10, causing every 10 frames to be shown.

<p>
The <code>__call__</code> method makes <code>PlotSolution</code> instances behave like
functions, so we can just pass an instance, say <code>p</code>, as the
<code>user_action</code> argument in the <code>solver</code> function, and any call to
<code>user_action</code> will be a call to <code>p.__call__</code>.

<h3>Pulse propagation in two media  <a name="___sec55"></a></h3>

<p>
The function <code>pulse</code> in <code>wave1D_dn_vc.py</code> demonstrates wave motion in
heterogeneous media where \( c \) varies. One can specify an interval
where the wave velocity is decreased by a factor <code>slowness_factor</code>
(or increased by making this factor less than one).
Four types of initial conditions are available: a rectangular pulse (<code>plug</code>),
a Gaussian function (<code>gaussian</code>), a "cosine hat" consisting of one
period of the cosine function (<code>cosinehat</code>), and half a period of
a "cosine hat" (<code>half-cosinehat</code>). These peak-shaped initial
conditions can be placed in the middle (<code>loc='center'</code>) or at
the left end (<code>loc='left'</code>) of the domain. The <code>pulse</code>
function is a flexible tool for playing around with various wave
shapes and location of a medium with a different wave velocity:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">pulse</span>(C=<span style="color: #B452CD">1</span>, Nx=<span style="color: #B452CD">200</span>, animate=<span style="color: #658b00">True</span>, version=<span style="color: #CD5555">&#39;vectorized&#39;</span>, T=<span style="color: #B452CD">2</span>,
          loc=<span style="color: #CD5555">&#39;center&#39;</span>, pulse_tp=<span style="color: #CD5555">&#39;gaussian&#39;</span>, slowness_factor=<span style="color: #B452CD">2</span>,
          medium=[<span style="color: #B452CD">0.7</span>, <span style="color: #B452CD">0.9</span>], every_frame=<span style="color: #B452CD">1</span>, sigma=<span style="color: #B452CD">0.05</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Various peaked-shaped initial conditions on [0,1].</span>
<span style="color: #CD5555">    Wave velocity is decreased by the slowness_factor inside</span>
<span style="color: #CD5555">    medium. The loc parameter can be &#39;center&#39; or &#39;left&#39;,</span>
<span style="color: #CD5555">    depending on where the initial pulse is to be located.</span>
<span style="color: #CD5555">    The sigma parameter governs the width of the pulse.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># Use scaled parameters: L=1 for domain length, c_0=1</span>
    <span style="color: #228B22"># for wave velocity outside the domain.</span>
    L = <span style="color: #B452CD">1.0</span>
    c_0 = <span style="color: #B452CD">1.0</span>
    <span style="color: #8B008B; font-weight: bold">if</span> loc == <span style="color: #CD5555">&#39;center&#39;</span>:
        xc = L/<span style="color: #B452CD">2</span>
    <span style="color: #8B008B; font-weight: bold">elif</span> loc == <span style="color: #CD5555">&#39;left&#39;</span>:
        xc = <span style="color: #B452CD">0</span>

    <span style="color: #8B008B; font-weight: bold">if</span> pulse_tp <span style="color: #8B008B">in</span> (<span style="color: #CD5555">&#39;gaussian&#39;</span>,<span style="color: #CD5555">&#39;Gaussian&#39;</span>):
        <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
            <span style="color: #8B008B; font-weight: bold">return</span> exp(-<span style="color: #B452CD">0.5</span>*((x-xc)/sigma)**<span style="color: #B452CD">2</span>)
    <span style="color: #8B008B; font-weight: bold">elif</span> pulse_tp == <span style="color: #CD5555">&#39;plug&#39;</span>:
        <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0</span> <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">abs</span>(x-xc) &gt; sigma <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">elif</span> pulse_tp == <span style="color: #CD5555">&#39;cosinehat&#39;</span>:
        <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
            <span style="color: #228B22"># One period of a cosine</span>
            w = <span style="color: #B452CD">2</span>
            a = w*sigma
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*(<span style="color: #B452CD">1</span> + cos(pi*(x-xc)/a)) \ 
                   <span style="color: #8B008B; font-weight: bold">if</span> xc - a &lt;= x &lt;= xc + a <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">0</span>

    <span style="color: #8B008B; font-weight: bold">elif</span> pulse_tp == <span style="color: #CD5555">&#39;half-cosinehat&#39;</span>:
        <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
            <span style="color: #228B22"># Half a period of a cosine</span>
            w = <span style="color: #B452CD">4</span>
            a = w*sigma
            <span style="color: #8B008B; font-weight: bold">return</span> cos(pi*(x-xc)/a) \ 
                   <span style="color: #8B008B; font-weight: bold">if</span> xc - <span style="color: #B452CD">0.5</span>*a &lt;= x &lt;= xc + <span style="color: #B452CD">0.5</span>*a <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #8B008B; font-weight: bold">raise</span> <span style="color: #008b45; font-weight: bold">ValueError</span>(<span style="color: #CD5555">&#39;Wrong pulse_tp=&quot;%s&quot;&#39;</span> % pulse_tp)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">c</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> c_0/slowness_factor \ 
               <span style="color: #8B008B; font-weight: bold">if</span> medium[<span style="color: #B452CD">0</span>] &lt;= x &lt;= medium[<span style="color: #B452CD">1</span>] <span style="color: #8B008B; font-weight: bold">else</span> c_0

    umin=-<span style="color: #B452CD">0.5</span>; umax=<span style="color: #B452CD">1.5</span>*I(xc)
    casename = <span style="color: #CD5555">&#39;%s_Nx%s_sf%s&#39;</span> % \ 
               (pulse_tp, Nx, slowness_factor)
    action = PlotMediumAndSolution(
        medium, casename=casename, umin=umin, umax=umax,
        every_frame=every_frame, screen_movie=animate)

    solver(I=I, V=<span style="color: #658b00">None</span>, f=<span style="color: #658b00">None</span>, c=c, U_0=<span style="color: #658b00">None</span>, U_L=<span style="color: #658b00">None</span>,
           L=L, Nx=Nx, C=C, T=T,
           user_action=action, version=version,
           dt_safety_factor=<span style="color: #B452CD">1</span>)
</pre></div>
<p>
The <code>PlotMediumAndSolution</code> class used here is a subclass of
<code>PlotSolution</code> where the medium with reduced \( c \) value,
as specified by the <code>medium</code> interval,
is visualized in the plots.

<p>
The reader is encouraged to play around with the <code>pulse</code> function:

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; import wave1D_dn_vc as w
&gt;&gt;&gt; w.pulse(loc=&#39;left&#39;, pulse_tp=&#39;cosinehat&#39;, Nx=50, every_frame=10)
</pre></div>
<p>
To easily kill the graphics by Ctrl-C and restart a new simulation it might be
easier to run the above two statements from the command line
with

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python -c <span style="color: #CD5555">&#39;import wave1D_dn_vc as w; w.pulse(...)&#39;</span>
</pre></div>

<h2>Exercises  <a name="___sec56"></a></h2>

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 6: Find the analytical solution to a damped wave equation <a name="wave:exer:standingwave:damped:uex"></a></h3>

<p>
Consider the wave equation with damping <a href="#mjx-eqn-38">(38)</a>.
The goal is to find an exact solution to a wave problem with damping.
A starting point is the standing wave solution from
<a href="._part0002_main_wave-solarized.html#wave:exer:standingwave">Exercise 1: Simulate a standing wave</a>. It becomes necessary to
include a damping term \( e^{-ct} \) and also have both a sine and cosine
component in time:

<p>
$$ \uex(x,t) =  e^{-\beta t}
\sin kx \left( A\cos\omega t
+ B\sin\omega t\right)
\ts
$$

Find \( k \) from the boundary conditions
\( u(0,t)=u(L,t)=0 \). Then use the PDE to find constraints on
\( \beta \), \( \omega \), \( A \), and \( B \).
Set up a complete initial-boundary value problem
and its solution.
Filename: <code>damped_waves.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Problem 7: Explore symmetry boundary conditions <a name="wave:exer:symmetry:bc"></a></h3>

<p>
<b>a)</b>
Consider the simple "plug" wave where \( \Omega = [-L,L] \) and

<p>
$$
\begin{equation*} I(x) = \left\lbrace\begin{array}{ll}
1, & x\in [-\delta, \delta],\\ 
0, & \hbox{otherwise}
\end{array}\right.
\end{equation*}
$$

for some number \( 0 < \delta < L \).
The boundary conditions can be set to \( u=0 \).
The solution to this problem is symmetric around \( x=0 \).
This means that we can simulate the wave process in only the half
of the domain \( [0,L] \). Argue why the symmetry boundary condition
is \( u_x=0 \) at \( x=0 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Symmetry of a function about \( x=x_0 \) means that
\( f(x_0+h) = f(x_0-h) \).

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>b)</b>
Perform simulations of the complete wave problem from
on \( [-L,L] \). Thereafter, utilize the
symmetry of the solution and run a simulation
in half of the domain \( [0,L] \), using a boundary condition
at \( x=0 \). Compare the two solutions and
make sure that they are the same.

<p>
<b>c)</b>
Prove the symmetry property of the solution
by setting up the complete initial-boundary value problem
and showing that if \( u(x,t) \) is a solution, then also \( u(-x,t) \)
is a solution.

<p>
Filename: <code>wave1D_symmetric</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 8: Send pulse waves through a layered medium <a name="wave:app:exer:pulse1D"></a></h3>

<p>
Use the <code>pulse</code> function in <code>wave1D_dn_vc.py</code> to investigate
sending a pulse, located with its peak at \( x=0 \), through the
medium to the right where it hits another medium for \( x\in [0.7,0.9] \)
where the wave velocity is decreased by a factor \( s_f \).
Report what happens with a Gaussian pulse, a "cosine hat" pulse,
half a "cosine hat" pulse, and a plug pulse for resolutions
\( N_x=40,80,160 \), and \( s_f=2,4 \).  Use \( C=1 \)
in the medium outside \( [0.7,0.9] \). Simulate until \( T=2 \).
Filename: <code>pulse1D.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 9: Compare discretizations of a Neumann condition  <a name="___sec60"></a></h3>

<p>
We have a 1D wave equation with variable wave velocity:
\( u_t=(qu_x)_x \).
A Neumann condition \( u_x \) at \( x=0, L \) can be
discretized as shown in <a href="#mjx-eqn-35">(35)</a>
and <a href="#mjx-eqn-36">(36)</a>.

<p>
The aim of this exercise is to examine the rate of the numerical
error when using different ways of discretizing the Neumann condition.
As test problem, \( q=1+(x-L/2)^4 \) can be used, with \( f(x,t) \)
adapted such that the solution has a simple form, say
\( u(x,t)=\cos (\pi x/L)\cos (\omega t) \) for some \( \omega = \sqrt{q}\pi/L \).

<p>
<b>a)</b>
Perform numerical experiments and find the convergence rate of the
error using
the approximation
and <a href="#mjx-eqn-36">(36)</a>.

<p>
<b>b)</b>
Switch to \( q(x)=\cos(\pi x/L) \), which is symmetric at \( x=0,L \),
and check the convergence rate
of the scheme
<a href="#mjx-eqn-36">(36)</a>. Now,
\( q_{i-1/2} \) is a 2nd-order approximation to \( q_i \),
\( q_{i-1/2}=q_i + 0.25q_i''\Delta x^2 + \cdots \), because \( q_i'=0 \)
for \( i=N_x \) (a similar argument can be applied to the case \( i=0 \)).

<p>
<b>c)</b>
A third discretization can be based on a simple and convenient,
but less accurate, one-sided difference:
\( u_{i}-u_{i-1}=0 \) at \( i=N_x \) and \( u_{i+1}-u_i=0 \) at \( i=0 \).
Derive the resulting scheme in detail and implement it.
Run experiments to establish the rate of convergence.

<p>
<b>d)</b>
A fourth technique is to view the scheme as

<p>
$$ [D_tD_tu]^n_i = \frac{1}{\Delta x}\left(
[qD_xu]_{i+\frac{1}{2}}^n - [qD_xu]_{i-\frac{1}{2}}^n\right)
+ [f]_i^n,$$

and place the boundary at \( x_{i+\frac{1}{2}} \), \( i=N_x \), instead of
exactly at the physical boundary. With this idea,
we can just set \( [qD_xu]_{i+\frac{1}{2}}^n=0 \). Derive the complete scheme
using this technique. The implementation of the boundary condition at
\( L-\Delta x/2 \) is \( \Oof{\Delta x^2} \) accurate, but the interesting question
is what impact the movement of the boundary has on the convergence
rate (compute the errors as usual over the entire mesh).

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<a href="._part0002_main_wave-solarized.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0004_main_wave-solarized.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

