<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Nonlinear differential equation problems">
<meta name="keywords" content="linearization explicit time integration,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),group finite element method,product approximation technique,continuation method,online rendering of LaTeX formulas,continuation method">



<style type="text/css">
    /* blueish style */

    /* Color definitions:  http://www.december.com/html/spec/color0.html
       CSS examples:       http://www.w3schools.com/css/css_examples.asp */

    body {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #000000;
    }
    h1 { font-size: 1.8em; color: #1e36ce; }
    h2 { font-size: 1.6em; color: #1e36ce; }
    h3 { font-size: 1.4em; color: #1e36ce; }
    a { color: #1e36ce; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #bababa;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #f8f8f8;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_gray_notice.png); }
     .alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_gray_summary.png); }
     .alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_gray_warning.png); }
     .alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_gray_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Basic examples using the logistic equation ',
               1,
               'nonlin:timediscrete:logistic',
               'nonlin:timediscrete:logistic'),
              (' Linearization by explicit time discretization ',
               2,
               'nonlin:timediscrete:logistic:FE',
               'nonlin:timediscrete:logistic:FE'),
              (' Exact solution of nonlinear equations ',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              (' Linearization ', 2, None, '___sec3'),
              (' Picard iteration ',
               2,
               'nonlin:timediscrete:logistic:Picard',
               'nonlin:timediscrete:logistic:Picard'),
              (' Stopping criteria ', 3, None, '___sec5'),
              (' A single Picard iteration ', 3, None, '___sec6'),
              (' Linearization by a geometric mean ',
               2,
               'nonlin:timediscrete:logistic:geometric:mean',
               'nonlin:timediscrete:logistic:geometric:mean'),
              (" Newton's method ",
               2,
               'nonlin:timediscrete:logistic:Newton',
               'nonlin:timediscrete:logistic:Newton'),
              (' Relaxation ',
               2,
               'nonlin:timediscrete:logistic:relaxation',
               'nonlin:timediscrete:logistic:relaxation'),
              (' Implementation and experiments ', 2, None, '___sec10'),
              (' Generalization to a general nonlinear ODE ',
               2,
               'nonlin:ode:generic',
               'nonlin:ode:generic'),
              (' Explicit time discretization ', 3, None, '___sec12'),
              (' Backward Euler discretization ', 3, None, '___sec13'),
              (' Crank-Nicolson discretization ', 3, None, '___sec14'),
              (' Systems of nonlinear algebraic equations ',
               1,
               'nonlin:systems:alg',
               'nonlin:systems:alg'),
              (' Picard iteration ',
               2,
               'nonlin:systems:alg:Picard',
               'nonlin:systems:alg:Picard'),
              (" Newton's method ",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              (' Stopping criteria ',
               2,
               'nonlin:systems:alg:terminate',
               'nonlin:systems:alg:terminate'),
              (' Example: A nonlinear ODE model from epidemiology ',
               2,
               'nonlin:systems:alg:SI',
               'nonlin:systems:alg:SI'),
              (' Implicit time discretization ', 3, None, '___sec20'),
              (' A Picard iteration ', 3, None, '___sec21'),
              (" Newton's method ", 3, None, '___sec22'),
              (' Linearization at the differential equation level ',
               1,
               'nonlin:pdelevel',
               'nonlin:pdelevel'),
              (' Explicit time integration ',
               2,
               'nonlin:pdelevel:explicit',
               'nonlin:pdelevel:explicit'),
              (' Picard iteration ',
               2,
               'nonlin:pdelevel:Picard',
               'nonlin:pdelevel:Picard'),
              (" Newton's method ",
               2,
               'nonlin:pdelevel:Newton',
               'nonlin:pdelevel:Newton'),
              (' Discretization of nonlinear differential equations ',
               1,
               'nonlin:alglevel:1D',
               'nonlin:alglevel:1D'),
              (' Finite difference discretizations ',
               2,
               'nonlin:alglevel:1D:fd',
               'nonlin:alglevel:1D:fd'),
              (' Discretization ', 3, None, '___sec29'),
              (' Solution of algebraic equations ', 3, None, '___sec30'),
              (' Finite element discretizations ',
               2,
               'nonlin:alglevel:1D:fe',
               'nonlin:alglevel:1D:fe'),
              (' Remark ', 3, None, '___sec32'),
              (' The group finite element method ',
               2,
               'nonlin:alglevel:1D:fe:group',
               'nonlin:alglevel:1D:fe:group'),
              (' Finite element notation ', 3, None, '___sec34'),
              (' Integrating nonlinear functions ', 3, None, '___sec35'),
              (' Finite element approximation of functions of $u$ ',
               3,
               None,
               '___sec36'),
              (' Application ', 3, None, '___sec37'),
              (' Numerical integration of nonlinear terms ',
               2,
               'nonlin:alglevel:1D:fe:f',
               'nonlin:alglevel:1D:fe:f'),
              (' Finite element discretization of a variable coefficient Laplace term ',
               2,
               'nonlin:alglevel:1D:fe:Laplace',
               'nonlin:alglevel:1D:fe:Laplace'),
              (' Picard iteration defined from the variational form ',
               2,
               'nonlin:alglevel:1D:fe:Picard',
               'nonlin:alglevel:1D:fe:Picard'),
              (" Newton's method defined from the variational form ",
               2,
               'nonlin:alglevel:1D:fe:Newton',
               'nonlin:alglevel:1D:fe:Newton'),
              (' Dirichlet conditions ', 3, None, '___sec42'),
              (' Multi-dimensional PDE problems ', 1, None, '___sec43'),
              (' Finite element discretization ', 2, None, '___sec44'),
              (' Finite difference discretization ', 2, None, '___sec45'),
              (' Continuation methods ', 2, None, '___sec46'),
              (' Exercises ', 1, 'nonlin:exer', 'nonlin:exer'),
              (' Problem 1: Determine if equations are nonlinear or not ',
               2,
               'nonlin:exer:lin:vs:nonlin',
               'nonlin:exer:lin:vs:nonlin'),
              (' Problem 2: Linearize a nonlinear vibration ODE ',
               2,
               'nonlin:exer:vib:geometric:mean',
               'nonlin:exer:vib:geometric:mean'),
              (' Exercise 3: Find the sparsity of the Jacobian ',
               2,
               'nonlin:exer:sparsity:Jacobian',
               'nonlin:exer:sparsity:Jacobian'),
              (" Exercise 4: Newton's method for linear problems ",
               2,
               'nonlin:exer:Newton:linear',
               'nonlin:exer:Newton:linear'),
              (' Exercise 5: Differentiate a highly nonlinear term ',
               2,
               'nonlin:exer:grad:pow:term',
               'nonlin:exer:grad:pow:term'),
              (' Problem 6: Discretize a 1D problem with a nonlinear coefficient ',
               2,
               'nonlin:exer:1D:1pu2:fem',
               'nonlin:exer:1D:1pu2:fem'),
              (' Problem 7: Linearize a 1D problem with a nonlinear coefficient ',
               2,
               'nonlin:exer:1D:1pu2:PicardNewton',
               'nonlin:exer:1D:1pu2:PicardNewton'),
              (' Problem 8: Finite differences for the 1D Bratu problem ',
               2,
               'nonlin:exer:1D:fu:discretize:fd',
               'nonlin:exer:1D:fu:discretize:fd'),
              (' Problem 9: Integrate functions of finite element expansions ',
               2,
               'nonlin:exer:fu:fem:int',
               'nonlin:exer:fu:fem:int'),
              (' Problem 10: Finite elements for the 1D Bratu problem ',
               2,
               'nonlin:exer:1D:fu:discretize:fe',
               'nonlin:exer:1D:fu:discretize:fe'),
              (' Problem 11: Derive the Newton system from a variational form ',
               2,
               'nonlin:exer:dD:heat:nonlinear:c:a',
               'nonlin:exer:dD:heat:nonlinear:c:a'),
              (' Problem 12: Derive algebraic equations for nonlinear 1D heat conduction ',
               2,
               'nonlin:exer:1D:heat:nonlinear:c:a',
               'nonlin:exer:1D:heat:nonlinear:c:a'),
              (' Problem 13: Investigate a 1D problem with a continuation method ',
               2,
               'nonlin:exer:continuation:1DnNflow',
               'nonlin:exer:continuation:1DnNflow'),
              (' Bibliography ', 1, None, '___sec61')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}

\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0001"></a>
<!-- begin top navigation -->
<a href="._main_nonlin000.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._main_nonlin002.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end top navigation -->

<p>
<!-- !split -->

<h2>Systems of nonlinear algebraic equations <a name="nonlin:systems:alg"></a></h2>

<p>
Implicit time discretization methods for a system of ODEs, or a PDE,
lead to <em>systems</em> of nonlinear algebraic equations, written
compactly as

<p>
$$ F(u) = 0,$$

where \( u \) is a vector of unknowns \( u=(u_0,\ldots,u_N) \), and
\( F \) is a vector function: \( F=(F_0,\ldots,F_N) \).
Sometimes the equation system has a special structure because of the
underlying problem, e.g.,

<p>
$$ A(u)u = b(u),$$

with \( A(u) \) as
an \( (N+1)\times (N+1) \) matrix function of \( u \) and \( b \) as a vector
function: \( b=(b_0,\ldots,b_N) \).

<p>
We shall next explain how Picard iteration and Newton's method
can be applied to systems like \( F(u)=0 \) and \( A(u)u=b(u) \).
The exposition has a focus on ideas and practical computations.
More theoretical considerations, including quite general results
on convergence properties
of these methods, can be found in Kelley <a href="._main_nonlin005.html#Kelley_1995">[1]</a>.

<h3>Picard iteration <a name="nonlin:systems:alg:Picard"></a></h3>

<p>
We cannot apply Picard iteration to nonlinear equations unless there is
some special structure. For the commonly arising case
\( A(u)u=b(u) \) we can linearize the
product \( A(u)u \) to \( A(u_{-})u \) and \( b(u) \) as \( b(u_{-}) \).
That is, we use the most previously
computed approximation in \( A \) and \( b \) to arrive at a <em>linear system</em> for
\( u \):

<p>
$$ A(u_{-})u = b(u_{-})\tp$$

A relaxed iteration takes the form

<p>
$$ A(u_{-})u^* = b(u_{-}),\quad u = \omega u^* + (1-\omega)u_{-}\tp$$

In other words, we solve a system of nonlinear algebraic equations as
a sequence of linear systems.

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Algorithm for relaxed Picard iteration.</b>
Given \( A(u)u=b(u) \) and an initial guess \( u_{-} \), iterate until convergence:

<p>

<ol>
<li> solve \( A(u_{-})u^* = b(u_{-}) \) with respect to \( u^* \)</li>
<li> \( u = \omega u^* + (1-\omega) u_{-} \)</li>
<li> \( u_{-}\ \leftarrow\ u \)</li>
</ol>
</div>


<p>
<!-- The iteration is stopped when the -->
<!-- change in the unknown, \( |u - u_{-}| \), or the residual, \( |A(u)u-b| \), -->
<!-- is sufficiently small. -->

<h3>Newton's method <a name="nonlin:systems:alg:Newton"></a></h3>

<p>
The natural starting point for Newton's method is the general
nonlinear vector equation \( F(u)=0 \).
As for a scalar equation, the idea is to approximate \( F \)
around a known value \( u_{-} \) by a linear function \( \hat F \),
calculated from the first two terms of a Taylor expansion of
\( F \). In the multi-variate case these two terms become

<p>
$$ F(u_{-}) + J(u_{-}) \cdot (u - u_{-}),$$

where \( J \) is the <em>Jacobian</em> of \( F \), defined by

<p>
$$ J_{i,j} = \frac{\partial F_i}{\partial u_j}\tp$$

So, the original nonlinear system is approximated by

<p>
$$ \hat F(u) = F(u_{-}) + J(u_{-}) \cdot (u - u_{-})=0,$$

which is linear in \( u \) and can be solved in a two-step procedure:
first solve \( J\delta u = -F(u_{-}) \) with respect to the vector \( \delta u \)
and then update \( u = u_{-} + \delta u \).
A relaxation parameter can easily be incorporated:

<p>
$$ u = \omega(u_{-} +\delta u)
+ (1-\omega)u_{-} = \omega_{-}  + \omega\delta u\tp
$$


<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Algorithm for Newton's method.</b>
Given \( F(u)=0 \) and an initial guess \( u_{-} \), iterate until convergence:

<p>

<ol>
<li> solve \( J\delta u = -F(u_{-}) \) with respect to \( \delta u \)</li>
<li> \( u = u_{-} + \omega)\delta u \)</li>
<li> \( u_{-}\ \leftarrow\ u \)</li>
</ol>
</div>


<p>
For the special system with structure \( A(u)u=b(u) \),

<p>
$$ F_i = \sum_k A_{i,k}(u)u_k - b_i(u),$$

and

<p>
$$
\begin{equation}
J_{i,j} = \sum_k \frac{\partial A_{i,k}}{\partial u_j}u_k
+ A_{i,j} -
\frac{\partial b_i}{\partial u_j}\tp
\end{equation}
$$

We realize that the Jacobian needed in Newton's method consists of
\( A(u_{-}) \) as in the Picard iteration plus two additional terms
arising from the differentiation. Using the notation \( A'(u) \) for
\( \partial A/\partial u \) (a quantity with three indices: \( \partial
A_{i,k}/\partial u_j \)), and \( b'(u) \) for \( \partial b/\partial u \) (a
quantity with two indices: \( \partial b_i/\partial u_j \)), we can write
the linear system to be solved as

<p>
$$ (A + A'u + b')\delta u = -Au + b,$$

or

<p>
$$ (A(u_{-}) + A'(u_{-})u_{-} + b'(u_{i}))\delta u
= -A(u_{-})u_{-} + b(u_{-})\tp$$

Rearranging the terms demonstrates the difference from the system
solved in each Picard iteration:

<p>
$$ \underbrace{A(u_{-})(u_{-}+\delta u) - b(u_{-})}_{\hbox{Picard system}}
+\, \gamma (A'(u_{-})u_{-} + b'(u_{i}))\delta u
= 0\tp$$

Here we have inserted a parameter \( \gamma \) such that \( \gamma=0 \)
gives the Picard system and \( \gamma=1 \) gives the Newton system.
Such a parameter can be handy in software to easily switch between
the methods.

<h3>Stopping criteria <a name="nonlin:systems:alg:terminate"></a></h3>

<p>
Let \( ||\cdot|| \) be the standard Eucledian vector norm. Four termination
criteria are much in use:

<p>

<ul>
 <li> Absolute change in solution: \( ||u - u_{-}||\leq \epsilon_u \)</li>
 <li> Relative change in solution: \( ||u - u_{-}||\leq \epsilon_u ||u_0|| \),
   where \( u_0 \) denotes the start value of \( u_{-} \) in the iteration</li>
 <li> Absolute residual: \( ||F(u)|| \leq \epsilon_r \)</li>
 <li> Relative residual: \( ||F(u)|| \leq \epsilon_r ||F(u_0)|| \)</li>
</ul>

To prevent divergent iterations to run forever,
one terminates the iterations when
the current number of iterations \( k \) exceeds a maximum value \( k_{\max} \).

<p>
The relative criteria are most used since they are not sensitive to
the characteristic size of \( u \). Nevertheless, the relative criteria
can be misleading when the initial start value for the iteration is
very close to the solution, since an unnecessary reduction in
the error measure is enforced. In such cases the absolute criteria
work better. It is common to combine the absolute and relative measures
of the size of the residual,
as in

<p>
$$
\begin{equation}
||F(u)|| \leq \epsilon_{rr} ||F(u_0)|| + \epsilon_{ra},
\end{equation}
$$

where \( \epsilon_{rr} \) is the tolerance in the relative criterion
and \( \epsilon_{ra} \) is the tolerance in the absolute criterion.
With a very good initial guess for the iteration
(typically the solution of a differential
equation at the previous time level), the term \( ||F(u_0)|| \) is small
and \( \epsilon_{ra} \) is the dominating tolerance. Otherwise,
\( \epsilon_{rr} ||F(u_0)|| \) and the relative criterion dominates.

<p>
With the change in solution as criterion we can formulate and combined
absolute and relative measure of the change in the solution:

<p>
$$
\begin{equation}
||\delta u|| \leq \epsilon_{ur} ||u_0|| + \epsilon_{ua},
\end{equation}
$$


<p>
The ultimate termination criterion, combining the residual and
the change in solution tests with a test on the maximum number
of iterations allow, can be expressed as

<p>
$$
\begin{equation}
||F(u)|| \leq \epsilon_{rr} ||F(u_0)|| + \epsilon_{ra}
\hbox{ or }
||\delta u|| \leq \epsilon_{ur} ||u_0|| + \epsilon_{ua}
\hbox{ or }
k>k_{\max}\tp
\end{equation}
$$

<h3>Example: A nonlinear ODE model from epidemiology <a name="nonlin:systems:alg:SI"></a></h3>

<p>
The simplest model spreading of a disease, such as a flu, takes
the form of a \( 2\times 2 \) ODE system

<p>
$$
\begin{align}
S' &= -\beta SI,\\ 
I' &= \beta SI - \nu I,
\end{align}
$$

where \( S(t) \) is the number of people who can get ill (susceptibles)
and \( I(t) \) is the number of people who are ill (infected).
The constants \( \beta >0 \) and \( \nu >0 \) must be given along with
initial conditions \( S(0) \) and \( I(0) \).

<h4>Implicit time discretization  <a name="___sec20"></a></h4>

<p>
A Crank-Nicolson scheme leads to a \( 2\times 2 \) system of nonlinear
algebraic equations in the unknowns \( S^{n+1} \) and \( I^{n+1} \):

<p>
$$
\begin{align}
\frac{S^{n+1}-S^n}{\Delta t} &= -\beta [SI]^{n+\half}
\approx -\frac{\beta}{2}(S^nI^n + S^{n+1}I^{n+1}),\\ 
\frac{I^{n+1}-I^n}{\Delta t} &= \beta [SI]^{n+\half} -
\nu I^{n+\half}
\approx \frac{\beta}{2}(S^nI^n + S^{n+1}I^{n+1}) -
\frac{\nu}{2}(I^n + I^{n+1})\tp
\end{align}
$$

Introducing \( S \) for \( S^{n+1} \), \( S_1 \) for \( S^n \), \( I \) for \( I^{n+1} \),
\( I_1 \) for \( I^n \), we can rewrite the system as

<p>
$$
\begin{align}
F_S(S,I) &= S - S_1 +
\half\Delta t\beta(S_1I_1 + SI) = 0,
\tag{10}
\\ 
F_I(S,I) &= I - I_1 -
\half\Delta t\beta(S_1I_1 + SI) -
\half\Delta t\nu(I_1 + I) =0\tp
\tag{11}
\end{align}
$$

<h4>A Picard iteration  <a name="___sec21"></a></h4>

<p>
We assume that we have approximations \( S_{-} \) and \( I_{-} \) to \( S \) and \( I \).
A way of linearizing the only nonlinear term \( SI \) is to write
\( I_{-}S \) in the \( F_S=0 \) equation and \( S_{-}I \) in the \( F_I=0 \) equation,
which also decouples the equations. Solving the resulting linear
equations with respect to the unknowns \( S \) and \( I \) gives

<p>
$$
\begin{align*}
S &= \frac{S_1 - \half\Delta t\beta S_1I_1}
{1 + \half\Delta t\beta I_{-}},
\\ 
I &= \frac{I_1 + \half\Delta t\beta S_1I_1}
{1 - \half\Delta t\beta S_{-} + \nu}\tp
\end{align*}
$$

The solutions \( S \) and \( I \) are stored in \( S_{-} \) and \( I_{-} \) and
a new iteration is carried out.

<h4>Newton's method  <a name="___sec22"></a></h4>

<p>
The nonlinear system
<a href="#mjx-eqn-10">(10)</a>-<a href="#mjx-eqn-11">(11)</a>
can be written as \( F(u)=0 \) with \( F=(F_S,F_I) \) and \( u=(S,I) \).  The
Jacobian becomes

<p>
$$
\renewcommand*{\arraystretch}{2}
J = \left(\begin{array}{cc}
\frac{\partial}{\partial S} F_S & \frac{\partial}{\partial I}F_S\\ 
\frac{\partial}{\partial S} F_I & \frac{\partial}{\partial I}F_I
\end{array}\right)
= \left(\begin{array}{cc}
1 + \half\Delta t\beta I & \half\Delta t\beta\\ 
- \half\Delta t\beta S & 1 - \half\Delta t\beta I -
\half\Delta t\nu
\end{array}\right)
\tp
\]
The Newton system to be solved in each iteration is then

$$
\begin{align*}
\renewcommand*{\arraystretch}{1.5}
&
\left(\begin{array}{cc}
1 + \half\Delta t\beta I_{-} & \half\Delta t\beta S_{-}\\ 
- \half\Delta t\beta S_{-} & 1 - \half\Delta t\beta I_{-} -
\half\Delta t\nu
\end{array}\right)
\left(\begin{array}{c}
\delta S\\ 
\delta I
\end{array}\right)
=\\ 
& \qquad\qquad
\left(\begin{array}{c}
S_{-} - S_1 + \half\Delta t\beta(S_1I_1 + S_{-}I_{-})\\ 
I_{-} - I_1 - \half\Delta t\beta(S_1I_1 + S_{-}I_{-}) -
\half\Delta t\nu(I_1 + I_{-})
\end{array}\right)
\end{align*}
$$


<p>
<b>Remark.</b>
For this particular system explicit time integration methods work very
well. The 4-th order Runge-Kutta method is an excellent
balance between high accuracy, high efficiency, and simplicity.

<p>
<p>
<!-- begin bottom navigation -->
<a href="._main_nonlin000.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._main_nonlin002.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

