.. Automatically generated reST file from Doconce source
   (https://github.com/hplgit/doconce/)

Finite difference methods for diffusion processes
=================================================

:Author: Hans Petter Langtangen
:Date: Nov 26, 2013

Note: **VERY PRELIMINARY VERSION**








The 1D diffusion equation
=========================

index{diffusion equation, 1D}
index{heat equation, 1D}

The famous *diffusion equation*, also known as the *heat equation*,
reads


.. math::
         \frac{\partial u}{\partial t} =
        \alpha \frac{\partial^2 u}{\partial x^2},
        

where :math:`u(x,t)` is the unknown function to be solved for, :math:`x` is a coordinate
in space, and :math:`t` is time. The coefficient :math:`\alpha` is the *diffusion
coefficient* and determines how fast :math:`u` changes in time. A quick
short form for the diffusion equation is :math:`u_t = \alpha u_{xx}`.

Compared to the wave equation, :math:`u_{tt}=c^2u_{xx}`, which looks very similar,
but the diffusion equation features solutions that are very different from
those of the wave equation. Also, the diffusion equation
makes quite different demands to the numerical
methods.


.. index:: stationary solution


Typical diffusion problems may experience rapid change in the very
beginning, but then the evolution of :math:`u` becomes slower and slower.
The solution is usually very smooth, and after some time, one cannot
recognize the initial shape of :math:`u`. This is in sharp contrast to solutions
of the wave equation where the initial shape is preserved - the solution
is basically a moving initial condition. The standard wave equation
:math:`u_{tt}=c^2u_{xx}` has solutions that propagates with speed :math:`c` forever,
without  changing shape, while the diffusion equation converges to
a *stationary solution* :math:`\bar u(x)` as :math:`t\rightarrow\infty`. In this
limit, :math:`u_t=0`, and :math:`\bar u` is governed by :math:`\bar u''(x)=0`.
This stationary limit of the diffusion equation is called
the *Laplace* equation and arises in a very wide range of applications
throughout the sciences.

It is possible to solve for :math:`u(x,t)` using a explicit scheme,
but the time step restrictions soon become much less favorable than for
an explicit scheme for the wave equation. And of more importance,
since the solution :math:`u` of the diffusion equation is very smooth and changes
slowly, small time steps are not convenient and not
required by accuracy as the diffusion process converges to a stationary
state.

The initial-boundary value problem for 1D diffusion
---------------------------------------------------

To obtain a unique solution of the diffusion equation, or equivalently,
to apply numerical methods, we need initial and boundary conditions.
The diffusion equation goes with one initial condition :math:`u(x,0)=I(x)`, where
:math:`I` is a prescribed function. One boundary condition is required at
each point on the boundary, which in 1D means that :math:`u` must be known,
:math:`u_x` must be known, or some combination of them.

We shall start
with the simplest boundary condition: :math:`u=0`. The complete
initial-boundary value diffusion problem in one
space dimension can then be specified as


.. _Eq:diffu:pde1:

.. math::
   :label: diffu:pde1
        
        \frac{\partial u}{\partial t} =
        \alpha \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]
        
        



.. _Eq:diffu:pde1:ic:u:

.. math::
   :label: diffu:pde1:ic:u
         
        u(x,0) = I(x), \quad  x\in [0,L]
        
        



.. _Eq:diffu:pde1:bc:0:

.. math::
   :label: diffu:pde1:bc:0
         
        u(0,t)  = 0, \quad  t>0,
        
        



.. _Eq:diffu:pde1:bc:L:

.. math::
   :label: diffu:pde1:bc:L
         
        u(L,t)  = 0, \quad  t>0{\thinspace .}
        
        

Equation :eq:`diffu:pde1` is known as a one-dimensional
*diffusion equation*, also often referred to as a
*heat equation*. With only a first-order derivative in time,
only one *initial condition* is needed, while the second-order
derivative in time leads to a demand for two *boundary conditions*.
The parameter :math:`\alpha` must be given and is referred to as the
*diffusion coefficient*.

Diffusion equations like :eq:`diffu:pde1` have a wide range of
applications throughout physical, biological, and financial sciences.
One of the most common applications is propagation of heat, where
:math:`u(x,t)` represents the temperature of some substance at point :math:`x` and
time :math:`t`. The section :ref:`diffu:app` goes into several widely occurring
applications.

.. _diffu:pde1:FE:

Forward Euler scheme
--------------------

.. index:: explicit discretization methods


The first step in the discretization procedure is to replace the
domain :math:`[0,L]\times [0,T]` by a set of mesh points. Here we apply
equally spaced mesh points


.. math::
         x_i=i\Delta x,\quad i=0,\ldots,N_x,

and


.. math::
         t_n=n\Delta t,\quad n=0,\ldots,N_t {\thinspace .}  

Moreover, :math:`u^n_i` denotes the mesh function that
approximates :math:`u(x_i,t_n)` for :math:`i=0,\ldots,N_x` and :math:`n=0,\ldots,N_t`.
Requiring the PDE :eq:`diffu:pde1` to be fulfilled at a mesh point :math:`(x_i,t_n)`
leads to the equation


.. _Eq:diffu:pde1:step2:

.. math::
   :label: diffu:pde1:step2
        
        \frac{\partial}{\partial t} u(x_i, t_n) =
        \alpha\frac{\partial^2}{\partial x^2} u(x_i, t_n),
        
        

The next step is to replace the derivatives by finite difference approximations.
The computationally simplest method arises from
using a forward difference in time and a central difference in
space:


.. _Eq:diffu:pde1:step3a:

.. math::
   :label: diffu:pde1:step3a
        
        [D_t^+ u = \alpha D_xD_x u]^n_i {\thinspace .}
        
        

Written out,


.. _Eq:diffu:pde1:step3b:

.. math::
   :label: diffu:pde1:step3b
        
        \frac{u^{n+1}_i-u^n_i}{\Delta t} = \alpha \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} {\thinspace .}
        
        

We have turned the PDE into algebraic equations, also often called
discrete equations. The key property of the equations is that they
are algebraic, which makes them easy to solve.
As usual, we anticipate that :math:`u^n_i` is already computed such that
:math:`u^{n+1}_i` is the only unknown in :eq:`diffu:pde1:step3b`.
Solving with respect to this unknown is easy:


.. _Eq:diffu:pde1:step4:

.. math::
   :label: diffu:pde1:step4
        
        u^{n+1}_i = u^n_i + \alpha\frac{\Delta t}{\Delta x^2}\left(
        u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right) {\thinspace .}
        
        


The computational algorithm then becomes

 1. compute $u^0_i=I(x_i)$for :math:`i=0,\ldots,N_x`

 2. for :math:`n=0,1,\ldots,N_t`:

   1. apply :eq:`diffu:pde1:step4` for all the internal
      spatial points :math:`i=1,\ldots,N_x-1`

   2. set the boundary values
      :math:`u^{n+1}_i=0` for :math:`i=0` and :math:`i=N_x`


The algorithm is compactly fully specified in Python:


.. code-block:: python

        x = linspace(0, L, Nx+1)    # mesh points in space
        dx = x[1] - x[0]
        t = linspace(0, T, Nt+1)    # mesh points in time
        dt = t[1] - t[0]
        C = a*dt/dx**2
        u   = zeros(Nx+1)
        u_1 = zeros(Nx+1)
        
        # Set initial condition u(x,0) = I(x)
        for i in range(0, Nx+1):
            u_1[i] = I(x[i])
        
        for n in range(0, Nt):
            # Compute u at inner mesh points
            for i in range(1, Nx):
                u[i] = u_1[i] + C*(u_1[i-1] - 2*u_1[i] + u_1[i+1])
        
            # Insert boundary conditions
            u[0] = 0;  u[Nx] = 0
        
            # Update u_1 before next step
            u_1[:]= u


.. _diffu:pde1:BE:

Backward Euler Scheme
---------------------


.. index:: implicit discretization methods


We now apply a backward difference in time in :eq:`diffu:pde1:step2`,
but the same central difference in space:


.. _Eq:diffu:pde1:step3aBE:

.. math::
   :label: diffu:pde1:step3aBE
        
        [D_t^- u = D_xD_x u]^n_i,
        
        

which written out reads


.. _Eq:diffu:pde1:step3bBE:

.. math::
   :label: diffu:pde1:step3bBE
        
        \frac{u^{n}_i-u^{n-1}_i}{\Delta t} = \alpha\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} {\thinspace .}
        
        

Now we assume :math:`u^{n-1}_i` is computed, but all quantities at the "new"
time level :math:`n` are unknown. This time it is not possible to solve
with respect to :math:`u_i^{n}` because this value couples to its neighbors
in space, :math:`u^n_{i-1}` and :math:`u^n_{i+1}`, which are also unknown.
Let us examine this fact for the case when :math:`N_x=3`. Equation :eq:`diffu:pde1:step3bBE` written for :math:`i=1,\ldots,Nx-1= 1,2` becomes


.. math::
        
        \frac{u^{n}_1-u^{n-1}_1}{\Delta t} = \alpha\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2}
        



.. math::
         
        \frac{u^{n}_2-u^{n-1}_2}{\Delta t} = \alpha\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2}
        

The boundary values :math:`u^n_0` and :math:`u^n_3` are known as zero. Collecting the
unknown new values :math:`u^n_1` and :math:`u^n_2` on the left-hand side gives


.. math::
        
        \left(1+  2\alpha\frac{\Delta t}{\Delta x^2}\right) u^{n}_1
        - \alpha\frac{\Delta t}{\Delta x^2} u^{n}_{2}  = u^{n-1}_1,
        



.. math::
         
        - \alpha\frac{\Delta t}{\Delta x^2} u^{n}_{1} +
        \left(1+  2\alpha\frac{\Delta t}{\Delta x^2}\right) u^{n}_2
          = u^{n-1}_2
        {\thinspace .}
        

This is a coupled :math:`2\times 2` system of algebraic equations for
the unknowns :math:`u^n_1` and :math:`u^n_2`.
Discretization methods that lead to a coupled system of equations
for the unknown function at a new time level are said to be
*implicit methods*.
The counterpart, *explicit methods*, refers to discretization
methods where there is a simple explicit formula for the values of
the unknown function at each of the spatial mesh points at the new
time level. From an implementational point of view, implicit methods
are more comprehensive to code since they require
the solution of coupled equations, i.e., a matrix system, at each time level.

In the general case, :eq:`diffu:pde1:step3bBE` gives rise to
a coupled :math:`(Nx-1)\times (Nx-1)` system of algebraic equations for
all the unknown :math:`u^n_i` at the interior spatial points :math:`i=1,\ldots,Nx-1`.
Collecting the unknowns on the left-hand side, and
introducing the quantity


.. math::
        
        C = \alpha\frac{\Delta t}{\Delta x^2},
        

:eq:`diffu:pde1:step3bBE` can be written


.. _Eq:diffu:pde1:step4BE:

.. math::
   :label: diffu:pde1:step4BE
        
        - Cu^n_{i-1} + \left(1+  2C\right) u^{n}_i - Cu^n_{i+1} = u_{i-1}^{n-1},
        
        

for :math:`i=1,\ldots,Nx-1`.
One can either view these equations as a system for where the
:math:`u^{n}_i` values at the internal grid points, :math:`i=1,\ldots,N_x-1`, are
unknown, or we may append the boundary values :math:`u^n_0` and :math:`u^n_{N_x}`
to the system. In the latter case, all :math:`u^n_i` for :math:`i=0,\ldots,N_x`
are unknown and we must add the boundary equations to
the :math:`N_x-1` equations in :eq:`diffu:pde1:step4BE`:


.. _Eq:diffu:pde1:step4BE:BC:0:

.. math::
   :label: diffu:pde1:step4BE:BC:0
        
        u_0^n = 0,
        



.. _Eq:diffu:pde1:step4BE:BC:L:

.. math::
   :label: diffu:pde1:step4BE:BC:L
         
        u_{N_x}^n = 0{\thinspace .}
        
        


A coupled system of algebraic equations can be written on matrix form,
and this is important if we want to call up ready-made software for
solving the system.  The equations :eq:`diffu:pde1:step4BE`
and :eq:`diffu:pde1:step4BE:BC:0`--:eq:`diffu:pde1:step4BE:BC:L`
correspond to the matrix equation


.. math::
         AU = b

where :math:`U=(u^n_0,\ldots,u^n_{N_x})`, and
the matrix :math:`A` has the following structure:


.. _Eq:diffu:pde1:matrix:sparsity:

.. math::
   :label: diffu:pde1:matrix:sparsity
        
        A =
        \left(
        \begin{array}{cccccccccc}
        A_{0,0} & A_{0,1} & 0
        &\cdots &
        \cdots & \cdots & \cdots &
        \cdots & 0 \\
        A_{1,0} & A_{1,1} & 0 & \ddots &   & &  & &  \vdots \\
        0 & A_{2,1} & A_{2,2} & A_{2,3} &
        \ddots & &  &  & \vdots \\
        \vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\
        \vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\
        \vdots & &  & 0 & A_{i,i-1} & A_{i,i} & A_{i,i+1} & \ddots & \vdots \\
        \vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\
        \vdots & & & &  &\ddots  & \ddots &\ddots  & A_{N_x-1,N_x} \\
        0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & A_{N_x,N_x-1} & A_{N_x,N_x}
        \end{array}
        \right)
        
        

The nonzero elements are given by


.. math::
        
        A_{i,i-1} = -C
        



.. math::
         
        A_{i,i} = 1+ 2C
        



.. math::
         
        A_{i,i+1} = -C
        

for the equations for internal points, :math:`i=1,\ldots,N_x-1`. The equations
for the boundary points correspond to


.. math::
        
        A_{0,0} = 1,
        



.. math::
         
        A_{0,1} = 0,
        



.. math::
         
        A_{N_x,N_x-1} = 0,
        



.. math::
         
        A_{N_x,N_x} = 1{\thinspace .}
        

The right-hand side :math:`b` is written as


.. math::
        
        b = \left(\begin{array}{c}
        b_0\\
        b_1\\
        \vdots\\
        b_i\\
        \vdots\\
        b_{N_x}
        \end{array}\right)
        

with


.. math::
        
        b_0 = 0,
        



.. math::
         
        b_i = u^{n-1}_i,\quad i=1,\ldots,N_x-1,
        



.. math::
         
        b_{N_x} = 0 {\thinspace .}  


We observe that the matrix :math:`A` contains quantities that do not change
in time. Therefore, :math:`A` can be formed once and for all before we enter
the recursive formulas for the time evolution.
The right-hand side :math:`b`, however, must be updated at each time step.
This leads to the following computational algorithm, here sketched
with Python code:


.. code-block:: python

        x = linspace(0, L, Nx+1)   # mesh points in space
        dx = x[1] - x[0]
        t = linspace(0, T, N+1)    # mesh points in time
        u   = zeros(Nx+1)
        u_1 = zeros(Nx+1)
        
        # Data structures for the linear system
        A = zeros((Nx+1, Nx+1))
        b = zeros(Nx+1)
        
        for i in range(1, Nx):
            A[i,i-1] = -C
            A[i,i+1] = -C
            A[i,i] = 1 + 2*C
        A[0,0] = A[Nx,Nx] = 1
        
        # Set initial condition u(x,0) = I(x)
        for i in range(0, Nx+1):
            u_1[i] = I(x[i])
        
        import scipy.linalg
        
        for n in range(0, Nt):
            # Compute b and solve linear system
            for i in range(1, Nx):
                b[i] = -u_1[i]
            b[0] = b[Nx] = 0
            u[:] = scipy.linalg.solve(A, b)
        
            # Update u_1 before next step
            u_1[:] = u


.. _diffu:pde1:impl:sparse:

Sparse matrix implementation
----------------------------

We have seen from :eq:`diffu:pde1:matrix:sparsity` that the matrix :math:`A`
is tridiagonal. The code segment above used a full, dense matrix
representation of :math:`A`, which stores a lot of values we know are zero
beforehand, and worse, the solution algorithm computes with all these zeros.
With :math:`N_x+1` unknowns, the work by the solution algorithm is :math:`\frac{1}{3}
(N_x+1)^3` and the storage requirements :math:`(N_x+1)^2`. By utilizing
the fact that :math:`A` is tridiagonal and employing corresponding software
tools, the work and storage demands can be proportional to :math:`N_x` only.

The key idea is to apply a data structure for a
tridiagonal or sparse matrix. The ``scipy.sparse`` package has
relevant utilities. For example, we can store the nonzero diagonals of
a matrix. The package also has linear system solvers that operate on
sparse matrix data structures. The code below illustrates how we
can store only the main diagonal and the upper and lower diagonals.


.. code-block:: python

        # Representation of sparse matrix and right-hand side
        main  = zeros(Nx+1)
        lower = zeros(Nx-1)
        upper = zeros(Nx-1)
        b     = zeros(Nx+1)
        
        # Precompute sparse matrix
        main[:] = 1 + 2*C
        lower[:] = -C  #1
        upper[:] = -C  #1
        # Insert boundary conditions
        main[0] = 1
        main[Nx] = 1
        
        A = scipy.sparse.diags(
            diagonals=[main, lower, upper],
            offsets=[0, -1, 1], shape=(Nx+1, Nx+1),
            format='csr')
        print A.todense()
        
        # Set initial condition
        for i in range(0,Nx+1):
            u_1[i] = I(x[i])
        
        for n in range(0, Nt):
            b = u_1
            b[0] = b[-1] = 0.0  # boundary conditions
            u[:] = scipy.sparse.linalg.spsolve(A, b)
            u_1[:] = u

The ``scipy.sparse.linalg.spsolve`` function utilizes the sparse storage
structure of ``A`` and performs in this case a very efficient Gaussian
elimination solve.


.. _diffu:pde1:theta:

The :math:`\theta` rule
-----------------------

The :math:`\theta` rule provides a family of finite difference approximations
in time:

 * :math:`\theta=0` gives the Forward Euler scheme in time

 * :math:`\theta=1` gives the Backward Euler scheme in time

 * :math:`\theta=\frac{1}{2}` gives the Crank-Nicolson scheme in time

Applied to the 1D diffusion problem we have


.. math::
         \frac{u^{n+1}_i-u^n_i}{\Delta t} =
        \alpha\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
        + (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)
        {\thinspace .}
        

This scheme also leads to a matrix system with entries :math:`1+2C\theta` on
the main diagonal of the matrix, and :math:`-C\theta` on the super- and sub-diagonal.
The right-hand side entry :math:`b_i` is


.. math::
         b_i = u^n_{i} + C(1-\theta)
        \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}{\thinspace .}
        




The Laplace and Poisson equation
--------------------------------

The Laplace equation, :math:`\nabla^2 u = 0`, or the Poisson equation,
:math:`-\nabla^2 u = f`, occur in numerous applications throughout science and
engineering. We can solve 1D variants of the Laplace equations with the listed
software, because we can interpret :math:`u_{xx}=0` as the limiting solution
of :math:`u_t = \alpha u_{xx}` when :math:`u` reach a steady state limit where
:math:`u_t\rightarrow 0`.
Similarly, Poisson's equation :math:`-u_{xx}=f` arises from solving
:math:`u_t = u_{xx} + f` and letting :math:`t\rightarrow` so :math:`u_t\rightarrow 0`.

Technically in a program, we can simulate :math:`t\rightarrow\infty`
by just taking one large time step,
or equivalently, set :math:`\alpha` to a large value. All we need is to have
:math:`C` large. As :math:`C\rightarrow\infty`, we can from the schemes see that
the limiting discrete equation becomes


.. math::
         \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2} = 0,

which is nothing but the discretization :math:`[D_xD_x u]^{n+1}_i=0` of
:math:`u_{xx}=0`.

The Backward Euler scheme can solve the limit equation directly and
hence produce a solution of the 1D Laplace equation.
With the Forward Euler scheme we must do the time stepping since :math:`C>1/2`
is illegal and leads to instability. We may interpret this time stepping
as solving the equation system from :math:`u_{xx}` by iterating on a time
pseudo time variable.

Extensions
----------

These extensions are performed exactly as for a wave equation as they
only affect the spatial derivatives (which are the same as in the
wave equation).

 * Variable coefficients

 * Neumann and Robin conditions

 * 2D and 3D

Future versions of this document will for completeness and
independence of the wave equation document feature info on the three
points. The Robin condition is new, but straightforward to handle:


.. math::
         -{\alpha}\frac{\partial u}{\partial n} = h_T(u-U_s),\quad
        [-{\alpha} D_x u = h_T(u-U_s)]^n_i
        




.. _diffu:pde1:analysis:

Analysis of schemes for the diffusion equation
==============================================


.. _diffu:pde1:analysis:uex:

Properties of the solution
--------------------------

A particular characteristic of diffusive processes, governed
by an equation like


.. _Eq:diffu:pde1:eq:

.. math::
   :label: diffu:pde1:eq
        
        u_t = \alpha u_{xx},
        
        

is that the
initial shape :math:`u(x,0)=I(x)` spreads out in space with time,
along with a decaying amplitude.
Three different examples will illustrate the spreading of :math:`u` in
space and the decay in time.

Similarity solution
~~~~~~~~~~~~~~~~~~~

The diffusion equation :eq:`diffu:pde1:eq` admits solutions
that depend on :math:`\eta = (x-c)/\sqrt{4\alpha t}` for a given value
of :math:`c`. One particular solution
is


.. _Eq:diffu:pdf1:erf:sol:

.. math::
   :label: diffu:pdf1:erf:sol
        
        u(x,t) = a\,\mbox{erf}(\eta) + b,
        
        

where


.. _Eq:diffu:analysis:erf:def:

.. math::
   :label: diffu:analysis:erf:def
        
        \mbox{erf}(\eta) = \frac{2}{\sqrt{\pi}}\int_0^\eta e^{-\zeta^2}d\zeta,
        
        

is the *error function*, and :math:`a` and :math:`b` are arbitrary constants.
The error function lies in :math:`(-1,1)`, is odd around :math:`\eta =0`, and
goes relatively quickly to :math:`\pm 1`:


.. math::
        
        \lim_{\eta\rightarrow -\infty}\mbox{erf}(\eta) &=-1,\\
        \lim_{\eta\rightarrow \infty}\mbox{erf}(\eta) &=1,\\
        \mbox{erf}(\eta) &= -\mbox{erf}(-\eta),\\
        \mbox{erf}(0) &=0,\\
        \mbox{erf}(2) &=0.99532227,\\
        \mbox{erf}(3) &=0.99997791
        {\thinspace .}
        


As :math:`t\rightarrow 0`, the error function approaches a step function centered
at :math:`x=c`. For a diffusion problem posed on the unit interval :math:`[0,1]`,
we may choose the step at :math:`x=1/2` (meaning :math:`c=1/2`), :math:`a=-1/2`, :math:`b=1/2`.
Then


.. _Eq:diffu:analysis:pde1:step:erf:sol:

.. math::
   :label: diffu:analysis:pde1:step:erf:sol
        
        u(x,t) = \frac{1}{2}\left(1 -
        \mbox{erf}\left(\frac{x-\frac{1}{2}}{\sqrt{4\alpha t}}\right)\right) =
        \frac{1}{2}\mbox{erfc}\left(\frac{x-\frac{1}{2}}{\sqrt{4\alpha t}}\right),
        
        

where we have introduced the *complementary error function*
:math:`\mbox{erfc}(\eta) = 1-\mbox{erf}(\eta)`.
The solution :eq:`diffu:analysis:pde1:step:erf:sol`
implies the boundary conditions


.. _Eq:diffu:analysis:pde1:p1:erf:uL:

.. math::
   :label: diffu:analysis:pde1:p1:erf:uL
        
        u(0,t) = \frac{1}{2}\left(1 - \mbox{erf}\left(\frac{-1/2}{\sqrt{4\alpha t}}\right)\right),
         
        



.. _Eq:diffu:analysis:pde1:p1:erf:uR:

.. math::
   :label: diffu:analysis:pde1:p1:erf:uR
         
        u(1,t) = \frac{1}{2}\left(1 - \mbox{erf}\left(\frac{1/2}{\sqrt{4\alpha t}}\right)\right)
        
        {\thinspace .}
        

For small enough :math:`t`, :math:`u(0,t)\approx 1` and :math:`u(1,t)\approx 1`, but as
:math:`t\rightarrow\infty`, :math:`u(x,t)\rightarrow 1/2` on :math:`[0,1]`.

Solution for a Gaussian pulse
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The standard diffusion equation :math:`u_t = \alpha u_{xx}` admits a
Gaussian function as solution:


.. _Eq:diffu:pde1:sol:Gaussian:

.. math::
   :label: diffu:pde1:sol:Gaussian
        
        u(x,t) = \frac{1}{\sqrt{4\pi\alpha t}} \exp{\left({-\frac{(x-c)^2}{4\alpha t}}\right)}
        
        {\thinspace .}
        

At :math:`t=0` this is a Dirac delta function, so for computational
purposes one must start to view the solution at some time :math:`t=t_\epsilon>0`.
Replacing :math:`t` by :math:`t_\epsilon +t` in :eq:`diffu:pde1:sol:Gaussian`
makes it easy to operate with a (new) :math:`t` that starts at :math:`t=0`
with an initial condition with a finite width.
The important feature of :eq:`diffu:pde1:sol:Gaussian` is that
the standard deviation :math:`\sigma` of a sharp initial Gaussian pulse
increases in time according to :math:`\sigma = \sqrt{2\alpha t}`, making
the pulse diffuse and flatten out.

.. Mention combinations of such kernels to build up a general analytical sol?

.. Or maybe an exercise for verification.


Solution for a sine component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For example, :eq:`diffu:pde1:eq`
admits a solution of the form


.. _Eq:diffu:pde1:sol1:

.. math::
   :label: diffu:pde1:sol1
        
        u(x,t) = Qe^{-at}\sin\left( kx\right)
        
        {\thinspace .}
        

The parameters :math:`Q` and :math:`k` can be freely chosen, while
inserting :eq:`diffu:pde1:sol1` in :eq:`diffu:pde1:eq` gives the constraint


.. math::
         a = -\alpha k^2
        {\thinspace .}
        



A very important feature is that the initial shape :math:`I(x)=Q\sin kx`
undergoes a damping :math:`\exp{(-\alpha k^2t)}`, meaning that
rapid oscillations in space, corresponding to large :math:`k`, are very much
faster dampened than slow oscillations in space, corresponding to small
:math:`k`. This feature leads to a smoothing of the initial condition with time.

The following examples illustrates the damping properties of :eq:`diffu:pde1:sol1`. We consider the specific problem


.. math::
        
        u_t &= u_{xx},\quad x\in (0,1),\ t\in (0,T],\\
        u(0,t) &= u(1,t) = 0,\quad t\in (0,T],\\
        u(x,0) & = \sin (\pi x) + 0.1\sin(100\pi x)
        {\thinspace .}
        

The initial condition has been chosen such that adding
two solutions like :eq:`diffu:pde1:sol1` constructs
an analytical solution to the problem:


.. _Eq:diffu:pde1:sol2:

.. math::
   :label: diffu:pde1:sol2
        
        u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)
        
        {\thinspace .}
        

Figure :ref:`diffu:pde1:fig:damping` illustrates the rapid damping of
rapid oscillations :math:`\sin (100\pi x)` and the very much slower damping of the
slowly varying :math:`\sin (\pi x)` term. After about :math:`t=0.5\cdot10^{-4}` the rapid
oscillations do not have a visible amplitude, while we have to wait
until :math:`t\sim 0.5` before the amplitude of the long wave :math:`\sin (\pi x)`
becomes very small.


.. _diffu:pde1:fig:damping:

.. figure:: diffusion_damping.png
   :width: 800

   *Evolution of the solution of a diffusion problem: initial condition (upper left), 1/100 reduction of the small waves (upper right), 1/10 reduction of the long wave (lower left), and 1/100 reduction of the long wave (lower right)*


.. x/sqrt(t) solution, kernel with integral


Analysis of discrete equations
------------------------------

A counterpart to :eq:`diffu:pde1:sol1` is the complex representation
of the same function:


.. math::
         u(x,t) = Qe^{-at}e^{ikx},

where :math:`i=\sqrt{-1}` is the imaginary unit.
We can add such functions, often referred to as wave components,
to make a Fourier representation
of a general solution of the diffusion equation:


.. _Eq:diffu:pde1:u:Fourier:

.. math::
   :label: diffu:pde1:u:Fourier
        
        u(x,t) \approx \sum_{k\in K} b_k e^{-\alpha k^2t}e^{ikx},
        
        

where :math:`K` is a set of an infinite number of :math:`k` values needed to construct
the solution. In practice, however, the series is truncated and
:math:`K` is a finite set of :math:`k` values
need build a good approximate solution.
Note that :eq:`diffu:pde1:sol2` is a special case of
:eq:`diffu:pde1:u:Fourier` where :math:`K=\{\pi, 100\pi\}`, :math:`b_{\pi}=1`,
and :math:`b_{100\pi}=0.1`.

The amplitudes :math:`b_k` of the individual Fourier waves must be determined
from the initial condition. At :math:`t=0` we have :math:`u\approx\sum_kb_k\exp{(ikx)}`
and find :math:`K` and :math:`b_k` such that


.. math::
        
        I(x) \approx \sum_{k\in K} b_k e^{ikx}{\thinspace .}
        

(The relevant formulas for :math:`b_k` come from Fourier analysis, or
equivalently, a least-squares method for approximating :math:`I(x)`
in a function space with basis :math:`\exp{(ikx)}`.)

Much insight about the behavior of numerical methods can be obtained
by investigating how a wave component :math:`\exp{(-\alpha k^2 t)}\exp{(ikx)}`
is treated by the numerical scheme. It appears that such wave
components are also solutions of the schemes, but the damping
factor :math:`\exp{(-\alpha k^2 t)}` varies among the schemes.
To ease the forthcoming algebra, we write the amplification factor
as :math:`A^n`. The exact damping factor is :math:`{A_{\small\mbox{e}}} = \exp{(-\alpha k^2\Delta t)}`.

[[[[
where :math:`i=\sqrt{-1}` and :math:`K` is a set of :math:`k` values needed to build
:math:`I(x)` with sufficient accuracy from basic sinusoidal components
:math:`e^{ikx}`.  Instead of using a specific sine or cosine function for
the spatial variation, we use a complex exponential function to ease
the hand calculations later.  Letting :math:`K` contain infinitely many :math:`k`
values makes the sum converge to :math:`I(x)` under reasonable assumptions
on the smoothness of :math:`I(x)`.


.. _diffu:pde1:analysis:

Analysis of the finite difference schemes
-----------------------------------------

We have seen that a general solution of the diffusion equation
can be built as a linear combination of basic components


.. math::
         e^{-\alpha k^2t}e^{ikx} {\thinspace .}  

A fundamental question is whether such components are also solutions of
the finite difference schemes. This is indeed the case, but the
amplitude :math:`\exp{(-\alpha k^2t)}` might be modified (which also happens when
solving the ODE counterpart :math:`u'=-\alpha u`).
We therefore look for numerical solutions of the form


.. _Eq:diffu:pde1:analysis:uni:

.. math::
   :label: diffu:pde1:analysis:uni
        
        u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx},
        
        

where :math:`A` must be determined by inserting the component into an actual scheme.

Stability  (1)
~~~~~~~~~~~~~~

The exact wave component decays according to :math:`\exp{(-\alpha k^2t)}`.
We should therefore require :math:`|A| < 1` to have a decaying numerical
solution as well. However, if
:math:`-1\leq A<0`, :math:`A^n` will change sign from time level to
time level, and we get stable, non-physical oscillations in the numerical
solutions that are not present in the exact solution.


.. index:: amplification factor


Accuracy  (1)
~~~~~~~~~~~~~

To determine how accurately a finite difference scheme treats one
wave component :eq:`diffu:pde1:analysis:uni`, we see that the basic
deviation from the exact solution is reflected in how well
:math:`A^n` approximates :math:`\exp{(-\alpha k^2t)}=\exp{(-\alpha k^2 n\Delta t)}`,
or how well the numerical amplification factor
:math:`A` approximates the exact amplification factor
:math:`{A_{\small\mbox{e}}} = \exp{(-\alpha k^2 \Delta t)}`.

.. We shall in particular investigate the error :math:`{A_{\small\mbox{e}}} - A` in the

.. amplification factor.



.. _diffu:pde1:analysis:FE:

Analysis of the Forward Euler scheme
------------------------------------

.. 2DO: refer to vib and wave



The Forward Euler finite difference scheme for :math:`u_t = \alpha u_{xx}` can
be written as


.. math::
         [D_t^+ u = \alpha D_xD_x u]^n_q{\thinspace .}  

Inserting a wave component :eq:`diffu:pde1:analysis:uni`
in the scheme demands calculating the terms


.. math::
         e^{ikq\Delta x}[D_t^+ A]^n = e^{ikq\Delta x}A^n\frac{A-1}{\Delta t},

and


.. math::
         A^nD_xD_x [e^{ikx}]_q = A^n\left( - e^{ikq\Delta x}\frac{4}{\Delta x^2}
        \sin^2\left(\frac{k\Delta x}{2}\right)\right)
        {\thinspace .}  

Inserting these terms in the discrete equation and
dividing by :math:`A^n e^{ikq\Delta x}` leads to



.. math::
        
        \frac{A-1}{\Delta t} = -\alpha \frac{4}{\Delta x^2}\sin^2\left(
        \frac{k\Delta x}{2}\right),
        

and consequently


.. math::
        
        A = 1 -4C\sin^2\left(
        \frac{k\Delta x}{2}\right),
        

where :math:`C` is a constant introduced for convenience:


.. math::
        
        C = \frac{\alpha\Delta t}{\Delta x^2}
        {\thinspace .}
        

The complete numerical solution is then


.. math::
        
        u^n_q = \left(1 -4C\sin^2\left(
        \frac{k\Delta x}{2}\right)\right)^ne^{ikq\Delta x}
        {\thinspace .}
        


Stability  (2)
~~~~~~~~~~~~~~

We easily see that :math:`A\leq 1`. However, the :math:`A` can be less than :math:`-1`,
which will lead
to growth of a numerical wave component. The criterion :math:`A\geq -1` implies


.. math::
         4C\sin^2 (p/2)\leq 2
        {\thinspace .}  

The worst case is when :math:`\sin^2 (p/2)=1`, so a sufficient criterion for
stability is


.. math::
        
        C\leq {\frac{1}{2}},
        

or expressed as a condition on :math:`\Delta t`:


.. math::
        
        \Delta t\leq \frac{\Delta x^2}{2\alpha}{\thinspace .}
        

Note that halving the spatial mesh size, :math:`\Delta x \rightarrow {\frac{1}{2}}
\Delta x`, requires :math:`\Delta t` to be reduced by a factor of :math:`1/4`.
The method hence becomes very expensive for fine spatial meshes.

.. 2DO: verification based on exact solutions


Accuracy  (2)
~~~~~~~~~~~~~

Since :math:`A` is expressed in terms of :math:`C` and the parameter we now call
:math:`p=k\Delta x/2`, we also express :math:`{A_{\small\mbox{e}}}` by :math:`C` and :math:`p`:


.. math::
         {A_{\small\mbox{e}}} = \exp{(-\alpha k^2\Delta t)} = \exp{(-4Cp^2)}
        {\thinspace .} 

Computing
the Taylor series expansion of :math:`A/{A_{\small\mbox{e}}}` in terms of :math:`C`
can easily be done with aid of ``sympy``:


.. code-block:: python

        def A_exact(C, p):
            return exp(-C*p**2)
        
        def A_FE(C, p):
            return 1 - 4*C*sin(p)**2
        
        from sympy import *
        C, p = symbols('C p')
        A_err_FE = A_FE(C, p)/A_exact(C, p)
        print A_err_FE.series(C, 0, 6)

The result is


.. math::
         \frac{A}{{A_{\small\mbox{e}}}} = 1 - 4 C \sin^{2}p + 2C p^{2} - 16C^{2} p^{2} \sin^{2}p + 8 C^{2} p^{4} + \cdots
        

Recalling that :math:`C=\alpha\Delta t/\Delta x`, :math:`p=k\Delta x/2`, and that
:math:`\sin^2p\leq 1`, we
realize that the dominating error terms are at most


.. math::
         1 - 4\alpha \frac{\Delta t}{\Delta x^2} +
        \alpha\Delta t - 4\alpha^2\Delta t^2
        + \alpha^2 \Delta t^2\Delta x^2 + \cdots
        {\thinspace .}
        



.. _diffu:pde1:analysis:BE:

Analysis of the Backward Euler scheme
-------------------------------------

Discretizing :math:`u_t = \alpha u_{xx}` by a Backward Euler scheme,


.. math::
         [D_t^- u = \alpha D_xD_x u]^n_q,

and inserting a wave component :eq:`diffu:pde1:analysis:uni`,
leads to calculations similar to those arising from the Forward Euler scheme,
but since


.. math::
         e^{ikq\Delta x}[D_t^- A]^n = A^ne^{ikq\Delta x}\frac{1 - A^{-1}}{\Delta t},

we get


.. math::
        
        \frac{1-A^{-1}}{\Delta t} = -\alpha \frac{4}{\Delta x^2}\sin^2\left(
        \frac{k\Delta x}{2}\right),
        

and then


.. _Eq:diffu:pde1:analysis:BE:A:

.. math::
   :label: diffu:pde1:analysis:BE:A
        
        A = \left(1  + 4C\sin^2p\right)^{-1}
        
        {\thinspace .}
        

The complete numerical solution can be written


.. math::
        
        u^n_q = \left(1  + 4C\sin^2 p\right)^{-n}
        e^{ikq\Delta x} {\thinspace .}
        


Stability  (3)
~~~~~~~~~~~~~~

We see from :eq:`diffu:pde1:analysis:BE:A` that :math:`0<A<1`, which means
that all numerical wave components are stable and non-oscillatory
for any :math:`\Delta t >0`.



.. _diffu:pde1:analysis:CN:

Analysis of the Crank-Nicolson scheme
-------------------------------------

The Crank-Nicolson scheme can be written as


.. math::
         [D_t u = \alpha D_xD_x \overline{u}^x]^{n+\frac{1}{2}}_q, 

or


.. math::
         [D_t u]^{n+\frac{1}{2}}_q = \frac{1}{2}\alpha\left( [D_xD_x u]^{n}_q +
        [D_xD_x u]^{n+1}_q\right)
        {\thinspace .}
        

Inserting :eq:`diffu:pde1:analysis:uni` in the time derivative approximation
leads to


.. math::
         [D_t A^n e^{ikq\Delta x}]^{n+\frac{1}{2}} = A^{n+\frac{1}{2}} e^{ikq\Delta x}\frac{A^{\frac{1}{2}}-A^{-\frac{1}{2}}}{\Delta t} = A^ne^{ikq\Delta x}\frac{A-1}{\Delta t}
        {\thinspace .} 

Inserting :eq:`diffu:pde1:analysis:uni` in the other terms
and dividing by
:math:`A^ne^{ikq\Delta x}` gives the relation


.. math::
        
        \frac{A-1}{\Delta t} = -\frac{1}{2}\alpha\frac{4}{\Delta x^2}
        \sin^2\left(\frac{k\Delta x}{2}\right)
        (1 + A),
        

and after some more algebra,


.. math::
        
        A = \frac{ 1 - 2C\sin^2p}{1 + 2C\sin^2p}
        {\thinspace .}
        

The exact numerical solution is hence


.. math::
        
        u^n_q = \left(\frac{ 1 - 2C\sin^2p}{1 + 2C\sin^2p}\right)^ne^{ikp\Delta x}
        {\thinspace .}
        


Stability  (4)
~~~~~~~~~~~~~~

The criteria :math:`A>-1` and :math:`A<1` are fulfilled for any :math:`\Delta t >0`.

Summary of accuracy of amplification factors
--------------------------------------------

We can plot the various amplification factors against :math:`p=k\Delta x/2` for
different choices of the :math:`C` parameter. Figures :ref:`diffu:pde1:fig:A:err:C20`,
:ref:`diffu:pde1:fig:A:err:C0.5`, and :ref:`diffu:pde1:fig:A:err:C0.1`
show how long and small waves are damped by the various schemes compared
to the exact damping. As long as all schemes are stable, the amplification
factor is positive, except for Crank-Nicolson when :math:`C>0.5`.


.. _diffu:pde1:fig:A:err:C20:

.. figure:: diffusion_A_C20_C2_FDM.png
   :width: 800

   *Amplification factors for large time steps*



.. _diffu:pde1:fig:A:err:C0.5:

.. figure:: diffusion_A_C05_C025_FDM.png
   :width: 800

   *Amplification factors for time steps around the Forward Euler stability limit*



.. _diffu:pde1:fig:A:err:C0.1:

.. figure:: diffusion_A_C01_C001_FDM.png
   :width: 800

   *Amplification factors for small time steps*


The effect of negative amplification factors is that :math:`A^n` changes sign
from one time level to the next, thereby giving rise to oscillations in
time in an animation of the solution. We see from Figure :ref:`diffu:pde1:fig:A:err:C20` that for :math:`C=20`, waves with :math:`p\geq \pi/2` undergo a damping close to
:math:`-1`, which means that the amplitude does not decay and that the wave component
jumps up and down in time. For :math:`C=2` we have a damping of a factor of 0.5
from one time level to the next, which is very much smaller than the
exact damping. Short waves will therefore fail to be effectively dampened.
These waves will manifest themselves as high frequency
oscillatory noise in the solution.

A value :math:`p=\pi/4` corresponds to
four mesh points per wave length of :math:`e^{ikx}`, while
:math:`p=\pi/2` implies only two points per wave length, which is the smallest number
of points we can have to represent the wave on the mesh.

To demonstrate the oscillatory behavior of the Crank-Nicolson scheme, we
choose an initial condition that leads to short waves with
significant amplitude. A discontinuous :math:`I(x)` will in particular serve
this purpose.

Run :math:`C=...`...














.. --- begin exercise ---

Exercise 1: Use an analytical solution to formulate a 1D test
-------------------------------------------------------------

This exercise explores the exact solution :eq:`diffu:pde1:sol:Gaussian`.
We shall formulate a diffusion problem in half of the domain for
half of the Gaussian pulse. Then we shall investigate the
impact of using an incorrect boundary condition, which we in
general cases often are forced due if the solution needs to pass
through finite boundaries undisturbed.


**a)**
The solution :eq:`diffu:pde1:sol:Gaussian` is seen to be symmetric
at :math:`x=c`, because :math:`\partial u/\partial x =0` always vanishes for
:math:`x=c`. Use this property to formulate a complete initial boundary
value problem in 1D involving the diffusion equation :math:`u_t=\alpha u_{xx}`
on :math:`[0,L]` with :math:`u_x(0,t)=0` and :math:`u(L,t)` known.

**b)**
Use the exact solution to set up a convergence rate test for an
implementation of the problem. Investigate if a one-sided
difference for :math:`u_x(0,t)`, say :math:`u_0=u_1`, destroys the second-order
accuracy in space.

**c)**
Imagine that we want to solve the problem numerically on
:math:`[0,L]`, but we do not know the exact solution and cannot of that
reason assign a correct Dirichlet condition at :math:`x=L`.
One idea is to simply set :math:`u(L,t)=0` since this will be an
accurate approximation before the diffused pulse reaches :math:`x=L`
and even thereafter it might be a satisfactory condition.
Let :math:`{u_{\small\mbox{e}}}` be the exact solution and let :math:`u` be the solution
of :math:`u_t=\alpha u_{xx}` with an initial Gaussian pulse and
the boundary conditions :math:`u_x(0,t)=u(L,t)=0`. Derive a diffusion
problem for the error :math:`e={u_{\small\mbox{e}}} - u`. Solve this problem
numerically using an exact Dirichlet condition at :math:`x=L`.
Animate the evolution of the error and make a curve plot of
the error measure


.. math::
         E(t)=\sqrt{\frac{\int_0^L e^2dx}{\int_0^L udx}}{\thinspace .} 

Is this a suitable error measure for the present problem?

**d)**
Instead of using :math:`u(L,t)=0` as approximate boundary condition for
letting the diffused Gaussian pulse out of our finite domain,
one may try :math:`u_x(L,t)=0` since the solution for large :math:`t` is
quite flat. Argue that this condition gives a completely wrong
asymptotic solution as :math:`t\rightarrow 0`. To do this,
integrate the diffusion equation from :math:`0` to :math:`L`, integrate
:math:`u_{xx}` by parts (or use Gauss' divergence theorem in 1D) to
arrive at the important property


.. math::
         \frac{d}{dt}\int_{0}^L u(x,t)dx = 0,

implying that :math:`\int_0^Ludx` must be constant in time, and therefore


.. math::
         \int_{0}^L u(x,t)dx = \int_{0}^LI(x)dx{\thinspace .} 

The integral of the initial pulse is 1.

**e)**
Another idea for an artificial boundary condition at :math:`x=L`
is to use a cooling law


.. _Eq:diffu:pde1:Gaussian:xL:cooling:

.. math::
   :label: diffu:pde1:Gaussian:xL:cooling
        
        -\alpha u_x = q(u - u_S),
        
        

where :math:`q` is an unknown heat transfer coefficient and :math:`u_S` is
the surrounding temperature in the medium outside of :math:`[0,L]`.
(Note that arguing that :math:`u_S` is approximately :math:`u(L,t)` gives
the :math:`u_x=0` condition from the previous subexercise that is
qualitatively wrong for large :math:`t`.)
Develop a diffusion problem for the error in the solution using
:eq:`diffu:pde1:Gaussian:xL:cooling` as boundary condition.
Assume one can take :math:`u_S=0` "outside the domain"
as :math:`u\rightarrow 0` for :math:`x\rightarrow\infty`.
Find a function :math:`q=q(t)` such that the exact solution
obeys the condition :eq:`diffu:pde1:Gaussian:xL:cooling`.
Test some constant values of :math:`q` and animate how the corresponding
error function behaves. Also compute :math:`E(t)` curves as suggested in
subexercise b).

Filename: ``diffu_symmetric_gaussian.py``.

.. --- end exercise ---




.. --- begin exercise ---

Exercise 2: Use an analytical solution to formulate a 2D test
-------------------------------------------------------------

Generalize :eq:`diffu:pde1:sol:Gaussian` to multi dimensions by
assuming that one-dimensional solutions can be multiplied to solve
:math:`u_t = \alpha\nabla^2 u`.
Use this solution to formulate a 2D test case where the peak of
the Gaussian is at the origin and where the domain is a
rectangule in the first quadrant. Use symmetry boundary
conditions :math:`\partial u/\partial n=0` whereever possible, and use
exact Dirichlet conditions on the remaining boundaries.



The solution  is seen to be symmetric
Filename: ``diffu_symmetric_gaussian_2D.pdf``.

.. --- end exercise ---

