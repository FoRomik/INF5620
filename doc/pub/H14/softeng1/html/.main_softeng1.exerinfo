
# Information about all exercises in the file main_softeng1.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_softeng1.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': "Many prefer to do a first implementation of an algorithm as a flat\nprogram and hardcode formulas, here the $f(t)$, into the algorithm.\nUnfortunately, this coding style makes it difficult to reuse a\nwell-tested algorithm. When the flat program works, it is strongly\nrecommended to *refactor* the code (i.e., rearrange the statements)\nsuch that general algorithms are encapsulated in Python functions.\nThe function arguments should be chosen such that the function\ncan be applied for a large class of\nproblems, here all problems that can be expressed as $u'=f(t)$,.",
  'file': ['integrate.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:main2func',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "For simple ODEs of the form\n\n!bt\n\\[ u' = f(t),\\quad u(0)=I,\\ t\\in (0,T]\\]\n\n!et\nwe can find the solution by straightforward integration:\n\n!bt\n\\[ u(t) = \\int_0^t f(\\tau) d\\tau\\tp\\]\n\n!et\nTo compute $u(t)$ for $t\\in [0,T]$, we introduce a uniform time mesh with\npoints $t_n=n\\Delta t$ and apply to Trapezoidal rule to approximate the\nintegral. Suppose we have computed the numerical approximation $u^n$ to\n$u(t_n)$. We have\n\n!bt\n\\[ u(t_{n+1}) = u(t_n) + \\int_{t_n}^{t_{n+1}} f(\\tau)d\\tau\\tp\\]\n\n!et\nUsing the Trapezoidal rule we get\n\n!bt\n\\begin{equation}\nu^{n+1} = u^n + \\frac{1}{2}\\Delta t (f(t_n) + f(t_{n+1}))\\tp\n\\end{equation}\n\n!et\nThe starting value is $u^0=I$.\nA corresponding implementation for the case $f(t)=2t+1$ is given next.\n\n!bc pycod\n# f(t) is 2*t + 1\nT = 2\nfrom numpy import *\ndt = 0.2               # time step\nNt = int(round(T/dt))  # no of mesh points\nu = zeros(Nt+1)\nt = linspace(0, T, Nt+1)\nfor n in range(Nt-1):\n    u[n+1] = u[n] + 0.5*dt*(2*t[n]+1 + 2*t[n+1]+1)\n\n!ec\nThis is a flat program. Refactor the program as a function\n`solver(f, I, T, dt)`, where `f` is the Python implementation of\nthe mathematical function $f(t)$ that is to be integrated. The\nreturn value of `solver` is the pair (`u`, `t`) representing\nthe solution values and the associated time mesh.",
  'title': 'Refactor a flat program in terms of a function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_compare_theta.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:plot:dtconst',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Make a program that imports the `solver` function from the\n`decay_mod` module and offers a function `compare(dt, I, a)` for\ncomparing, in a plot, the methods corresponding to $\\theta=0,0.5,1$\nand the exact solution.  This plot shows the accuracy of the methods\nfor a given time mesh. Read input data for the problem from the\ncommand line using appropriate functions in the `decay_mod` module\n(the `--dt` option for giving several time step values can be reused:\njust use the first time step value for the computations).',
  'title': 'Compare methods for a given time mesh',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['doctest_roots.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:doctest1',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Type in the following program and equip the `roots` function with a doctest:\n\n!bc pypro\nimport sys\n# This sqrt(x) returns real if x>0 and complex if x<0\nfrom numpy.lib.scimath import sqrt\n\ndef roots(a, b, c):\n    """\n    Return the roots of the quadratic polynomial\n    p(x) = a*x**2 + b*x + c.\n\n    The roots are real or complex objects.\n    """\n    q = b**2 - 4*a*c\n    r1 = (-b + sqrt(q))/(2*a)\n    r2 = (-b - sqrt(q))/(2*a)\n    return r1, r2\n\na, b, c = [float(arg) for arg in sys.argv[1:]]\nprint roots(a, b, c)\n\n!ec\nMake sure to test both real and complex roots.\nWrite out numbers with 14 digits or less.',
  'title': 'Write a doctest',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['test_roots.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:nosetest1',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Make a nose test for the `roots` function in Problem ref{decay:exer:doctest1}.',
  'title': 'Write a nose test',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['q_module.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:module1',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Let\n!bt\n\\[ q(t) = \\frac{RAe^{at}}{R + A(e^{at} - 1)}\n\\tp\n\\]\n\n!et\nMake a Python module `q_module` containing two functions `q(t)` and\n`dqdt(t)` for computing $q(t)$ and $q\'(t)$, respectively. Perform a\n`from numpy import *` in this module. Import `q` and `dqdt` in another\nfile using the "star import" construction `from q_module import\n*`. All objects available in this file is given by `dir()`. Print\n`dir()` and `len(dir())`.  Then change the import of `numpy` in\n`q_module.py` to `import numpy as np`. What is the effect of this\nimport on the number of objects in `dir()` in a file that does `from\nq_module import *`?',
  'title': 'Make a module',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_class_exper.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay_class:exper',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We want to solve the exponential decay problem $u\'=-au$, $u(0)=I$,\nfor several $\\Delta t$ values and $\\theta=0,0.5,1$.\nFor each $\\Delta t$ value, we want to make a plot where the\nthree solutions corresponding to $\\theta=0,0.5,1$ appear along with\nthe exact solution.\nWrite a function `experiment` to accomplish this. The function should\nimport the classes `Problem`, `Solver`, and `Visualizer` from the\n"`decay_class`":\n"http://tinyurl.com/nm5587k/decay/decay_class.py"\nmodule and make use of these. A new command-line option `--dt_values`\nmust be added to allow the user to specify the $\\Delta t$ values on\nthe command line (the options `--dt` and `--theta` implemented\nby the `decay_class` module have then no effect\nwhen running the `experiment` function).\nNote that the classes in the `decay_class` module should *not* be\nmodified.',
  'title': 'Make use of a class implementation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_class2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay_class2',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the file "`decay_class.py`": "http://tinyurl.com/nm5587k/decay/decay_class.py"\nwhere the exponential decay problem $u\'=-au$, $u(0)=I$, is implemented\nvia the classes `Problem`, `Solver`, and `Visualizer`.\nExtend the classes to handle the more general problem\n!bt\n\\[ u\'(t) = -a(t)u(t) + b(t),\\quad u(0)=I,\\ t\\in (0,T],\\]\n\n!et\nusing the $\\theta$-rule for discretization.\n\nIn the case with arbitrary functions $a(t)$ and $b(t)$ the problem class\nis no longer guaranteed to provide an exact solution. Let\nthe `u_exact` in class `Problem` return `None` if the exact\nsolution for the particular problem is not available. Modify classes\n`Solver` and `Visualizer` accordingly.\n\nAdd test functions `test_*()` for the nose testing tool in the module.\nAlso add a demo example where the environment suddenly changes\n(modeled as an abrupt change in the decay rate $a$):\n!bt\n\\[ a(t) =\\left\\lbrace\\begin{array}{ll}\n1, & 0\\leq t\\leq t_p,\\\\ \nk, & t> t_p,\\end{array}\\right.\n\\]\n\n!et\nwhere $t_p$ is the point of time the environment changes. Take $t_p=1$\nand make plots that illustrate the effect of having $k\\gg 1$ and $k\\ll 1$.',
  'title': 'Generalize a class implementation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_class3.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:decay_class3',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Solve Exercise ref{decay:exer:decay_class2} by utilizing the\nclass implementations in\n"`decay_class_oo.py`": "http://tinyurl.com/nm5587k/decay/decay_class_oo.py".',
  'title': 'Generalize an advanced class implementation',
  'type': 'Exercise',
  'type_visible': True}]