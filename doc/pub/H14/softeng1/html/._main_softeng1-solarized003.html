<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Scientific software engineering with a simple ODE model as example">
<meta name="keywords" content="user interfaces to programs,command-line arguments,reading the command line,list comprehension,option-value pairs (command line),command-line options and values,reading the command line,convergence rate,dictionary,verification,modules,test block (in Python modules),importing modules,doctests,software testing doctests,unit testing,software testing nose,software testing nose w/doctests,unit testing,software testing unit testing (class-based),problem class,solver class,wrapper (code),visualizer class,problem class,solver class,visualizer class,numerical experiments,scientific experiments,script,Unix wildcard notation,wildcard notation (Unix)">

<title>Scientific software engineering with a simple ODE model as example</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Sample problem and code ', 1, None, '___sec0'),
              (' Mathematical problem ', 2, None, '___sec1'),
              (' Implementation ', 2, None, '___sec2'),
              (' User interfaces ', 1, None, '___sec3'),
              (' Creating command-line interfaces ',
               2,
               'decay:commandline',
               'decay:commandline'),
              (' Reading a sequence of command-line arguments ',
               3,
               None,
               '___sec5'),
              (' Working with an argument parser ', 3, None, '___sec6'),
              (' Creating a graphical web user interface ',
               2,
               None,
               '___sec7'),
              (' Making a compute function ', 3, None, '___sec8'),
              (' Generating the user interface ', 3, None, '___sec9'),
              (' Running the web application ', 3, None, '___sec10'),
              (' Verification ', 1, None, '___sec11'),
              (' Comparison with hand calculations ', 2, None, '___sec12'),
              (' Test function ', 2, None, '___sec13'),
              (' Comparison with an exact discrete solution ',
               2,
               None,
               '___sec14'),
              (' Computing convergence rates ',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              (' Estimating $r$ ', 3, None, '___sec16'),
              (' Implementation ', 3, None, '___sec17'),
              (' Debugging via convergence rates ', 3, None, '___sec18'),
              (' Software engineering ', 1, None, '___sec19'),
              (' Making a module ',
               2,
               'decay:prog:se:module',
               'decay:prog:se:module'),
              (' Prefixing imported functions by the module name ',
               2,
               'decay:prog:se:import',
               'decay:prog:se:import'),
              (' Doctests ',
               2,
               'decay:prog:se:doctest',
               'decay:prog:se:doctest'),
              (' Unit testing with nose ',
               2,
               'decay:prog:se:nose',
               'decay:prog:se:nose'),
              (' Basic use of nose ', 3, None, '___sec24'),
              (' Alternative assert statements ', 3, None, '___sec25'),
              (' Applying nose ', 3, None, '___sec26'),
              (' Installation of nose ', 3, None, '___sec27'),
              (' Using nose to test modules with doctests ',
               3,
               None,
               '___sec28'),
              (' Classical class-based unit testing ',
               2,
               'decay:prog:se:unittest',
               'decay:prog:se:unittest'),
              (' Basic use of unittest ', 3, None, '___sec30'),
              (' Demonstration of unittest ', 3, None, '___sec31'),
              (' Implementing simple problem and solver classes ',
               2,
               'decay:prog:se:class',
               'decay:prog:se:class'),
              (' The problem class ', 3, None, '___sec33'),
              (' The solver class ', 3, None, '___sec34'),
              (' The visualizer class ', 3, None, '___sec35'),
              (' Combining the objects ', 3, None, '___sec36'),
              (' Improving the problem and solver classes ',
               2,
               'decay:prog:se:class2',
               'decay:prog:se:class2'),
              (' A generic class for parameters ', 3, None, '___sec38'),
              (' The problem class ', 3, None, '___sec39'),
              (' The solver class ', 3, None, '___sec40'),
              (' The visualizer class ', 3, None, '___sec41'),
              (' Performing scientific experiments ',
               1,
               'decay:experiments',
               'decay:experiments'),
              (' Software ', 2, None, '___sec43'),
              (' Combining plot files ', 2, None, '___sec44'),
              (' Interpreting output from other programs ',
               2,
               None,
               '___sec45'),
              (' Making a report ',
               2,
               'decay:exper:report',
               'decay:exper:report'),
              (' Plain HTML ', 3, None, '___sec47'),
              (' HTML with MathJax ', 3, None, '___sec48'),
              (' LaTeX ', 3, None, '___sec49'),
              (' Sphinx ', 3, None, '___sec50'),
              (' Markdown ', 3, None, '___sec51'),
              (' Wiki formats ', 3, None, '___sec52'),
              (' DocOnce ', 3, None, '___sec53'),
              (' Worked example ', 3, None, '___sec54'),
              (' Publishing a complete project ',
               2,
               'decay:exper:github',
               'decay:exper:github'),
              (' Exercises ', 1, None, '___sec56'),
              (' Exercise 1: Refactor a flat program in terms of a function ',
               2,
               'decay:exer:main2func',
               'decay:exer:main2func'),
              (' Remarks ', 3, None, '___sec58'),
              (' Exercise 2: Compare methods for a given time mesh ',
               2,
               'decay:exer:plot:dtconst',
               'decay:exer:plot:dtconst'),
              (' Problem 3: Write a doctest ',
               2,
               'decay:exer:doctest1',
               'decay:exer:doctest1'),
              (' Problem 4: Write a nose test ',
               2,
               'decay:exer:nosetest1',
               'decay:exer:nosetest1'),
              (' Problem 5: Make a module ',
               2,
               'decay:exer:module1',
               'decay:exer:module1'),
              (' Exercise 6: Make use of a class implementation ',
               2,
               'decay:exer:decay_class:exper',
               'decay:exer:decay_class:exper'),
              (' Exercise 7: Generalize a class implementation ',
               2,
               'decay:exer:decay_class2',
               'decay:exer:decay_class2'),
              (' Exercise 8: Generalize an advanced class implementation ',
               2,
               'decay:exer:decay_class3',
               'decay:exer:decay_class3'),
              (' Bibliography ', 1, None, '___sec66')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0003"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_softeng1-solarized002.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_softeng1-solarized004.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1>Performing scientific experiments <a name="decay:experiments"></a></h1>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Goal.</b>
<p>
This section explores the behavior of a numerical
method for a differential equation through computer experiments.
In particular, it is shown how scientific experiments
can be set up and reported. We address the ODE problem

$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I,\quad t\in (0,T],
\tag{5}
\end{equation}
$$

numerically discretized by the \( \theta \)-rule:

$$
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
\quad u^0=I\tp
$$

Our aim is to plot \( u^0,u^1,\ldots,u^N \)
together with the exact solution \( \uex = Ie^{-at} \)
for various choices of the parameters in this numerical problem:
\( I \), \( a \), \( \Delta t \), and \( \theta \). We are especially interested
in how the discrete solution compares with the exact solution
when the \( \Delta t \) parameter is varied and \( \theta \) takes on the three values
corresponding to the Forward Euler, Backward Euler, and Crank-Nicolson
schemes (\( \theta=0,1,0.5 \), respectively).
</div>


<h2>Software  <a name="___sec43"></a></h2>

<p>
A verified implementation for computing the numerical
solution \( u^n \) and plotting it together
with the exact solution \( \uex \) is found in the file
<a href="http://tinyurl.com/nm5587k/softeng1/decay_mod.py" target="_self"><tt>decay_mod.py</tt></a>.
This program admits command-line arguments to specify a series of
\( \Delta t \) values and will run a loop over these values and
\( \theta=0,0.5,1 \). We make a slight edit of how the plots are
designed: the numerical solution is specified with line type <code>'r--o'</code>
(dashed red lines with dots at the mesh points), and the <code>show()</code>
command is removed to avoid a lot of plot windows popping up on
the computer screen (but hardcopies of the plot are still stored
in files via <code>savefig</code>). The slightly
modified program has the name
<a href="http://tinyurl.com/nm5587k/softeng1/experiments/decay_mod.py" target="_self"><tt>experiments/decay_mod.py</tt></a>.
All files associated with the scientific investigation are collected
in a subdirectory <code>experiments</code>.

<p>
Running the experiments is easy since the <code>decay_mod.py</code> program
already has the loops over \( \theta \) and \( \Delta t \) implemented.
An experiment with \( I=1 \), \( a=2 \), \( T=5 \), and \( dt=0.5, 0.25, 0.1, 0.05 \)
is run by

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_mod.py --I 1 --a 2 --makeplot \ 
          --T 5 --dt 0.5 0.25 0.1 0.05
</pre></div>

<h2>Combining plot files  <a name="___sec44"></a></h2>

<p>
The <code>decay_mod.py</code> program generates a lot of image files, e.g.,
<code>FE_*.png</code>, <code>BE_*.png</code>, and <code>CN_*.png</code>.
We want to combine all the <code>FE_*.png</code> files in a table
fashion in one file, with two images in each row,
starting with the largest \( \Delta t \) in the upper
left corner and decreasing the value as we go to the right and down.
This can be done using the <a href="http://www.imagemagick.org/script/montage.php" target="_self"><tt>montage</tt></a> program. The often occurring white areas around the plots can
be cropped away by the <code>convert -trim</code> command.
The remaining white can be made transparent for HTML pages with a
non-white background by the command <code>convert -transparent white</code>.

<p>
Also plot files in the PDF format with names <code>FE_*.pdf</code>, <code>BE_*.pdf</code>,
and <code>CN_*.pdf</code> are generated and these should be combined using other
tools: <code>pdftk</code> to combine individual plots into one file with one plot
per page, and <code>pdfnup</code> to combine the pages into a table with multiple
plots per page. The resulting image often has some extra surrounding
white space that can be removed by the <code>pdfcrop</code> program.
The code snippets below contain all details about the
usage of <code>montage</code>, <code>convert</code>, <code>pdftk</code>, <code>pdfnup</code>, and <code>pdfcrop</code>.

<p>
Running manual commands is boring, and errors may easily
sneak in. Both for automating manual work and documenting the
operating system commands we actually issued in the experiment,
we should write a <em>script</em> (little program). An alternative is
to write the commands into an IPython notebook and use the
notebook as the script. A plain script as a standard Python
program in a separate text file will be used here.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Reproducible science.</b>
<p>
A script that automates running our computer experiments
will ensure
that the experiments can easily be rerun by ourselves or others in
the future, either to check the results or redo the experiments with
other input data. Also, whatever we did to produce the results is
documented in every detail in the script.
Automating scripts are therefore essential to making our
research <em>reproducible</em>, which is a fundamental principle in science.
</div>


<p>
The script takes
a list of \( \Delta t \) values on the command line as input and
makes three combined images, one for each \( \theta \) value,
displaying the quality of the numerical solution as \( \Delta t \)
varies. For example,
<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_exper0.py 0.5 0.25 0.1 0.05
</pre></div>
<p>
results in images <code>FE.png</code>, <code>CN.png</code>, <code>BE.png</code>,
<code>FE.pdf</code>, <code>CN.pdf</code>, and <code>BE.pdf</code>,
each with four plots corresponding to the four \( \Delta t \) values.
Each plot compares the numerical solution with the exact one.
The latter image is shown in Figure <a href="#decay:experiments:fig:BE4a">2</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Illustration of the Backward Euler method for four time step values. <a name="decay:experiments:fig:BE4a"></a> </p></center>
<p><img src="fig-softeng1/BE4a.png" align="bottom" width=600,></p>
</center>

<p>
Ideally, the script should be scalable in the sense that it works for
any number of \( \Delta t \) values, which is the case for this particular
implementation:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">os</span>, <span style="color: #008b45; text-decoration: underline">sys</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">run_experiments</span>(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">5</span>):
    <span style="color: #228B22"># The command line must contain dt values</span>
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(sys.argv) &gt; <span style="color: #B452CD">1</span>:
        dt_values = [<span style="color: #658b00">float</span>(arg) <span style="color: #8B008B; font-weight: bold">for</span> arg <span style="color: #8B008B">in</span> sys.argv[<span style="color: #B452CD">1</span>:]]
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Usage: %s dt1 dt2 dt3 ...&#39;</span> %  sys.argv[<span style="color: #B452CD">0</span>]
        sys.exit(<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># abort</span>

    <span style="color: #228B22"># Run module file as a stand-alone application</span>
    cmd = <span style="color: #CD5555">&#39;python decay_mod.py --I %g --a %g --makeplot --T %g&#39;</span> % \
          (I, a, T)
    dt_values_str = <span style="color: #CD5555">&#39; &#39;</span>.join([<span style="color: #658b00">str</span>(v) <span style="color: #8B008B; font-weight: bold">for</span> v <span style="color: #8B008B">in</span> dt_values])
    cmd += <span style="color: #CD5555">&#39; --dt %s&#39;</span> % dt_values_str
    <span style="color: #8B008B; font-weight: bold">print</span> cmd
    failure = os.system(cmd)
    <span style="color: #8B008B; font-weight: bold">if</span> failure:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Command failed:&#39;</span>, cmd; sys.exit(<span style="color: #B452CD">1</span>)

    <span style="color: #228B22"># Combine images into rows with 2 plots in each row</span>
    image_commands = []
    <span style="color: #8B008B; font-weight: bold">for</span> method <span style="color: #8B008B">in</span> <span style="color: #CD5555">&#39;BE&#39;</span>, <span style="color: #CD5555">&#39;CN&#39;</span>, <span style="color: #CD5555">&#39;FE&#39;</span>:
        pdf_files = <span style="color: #CD5555">&#39; &#39;</span>.join([<span style="color: #CD5555">&#39;%s_%g.pdf&#39;</span> % (method, dt)
                              <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values])
        png_files = <span style="color: #CD5555">&#39; &#39;</span>.join([<span style="color: #CD5555">&#39;%s_%g.png&#39;</span> % (method, dt)
                              <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values])
        image_commands.append(
            <span style="color: #CD5555">&#39;montage -background white -geometry 100%&#39;</span> +
            <span style="color: #CD5555">&#39; -tile 2x %s %s.png&#39;</span> % (png_files, method))
        image_commands.append(
            <span style="color: #CD5555">&#39;convert -trim %s.png %s.png&#39;</span> % (method, method))
        image_commands.append(
            <span style="color: #CD5555">&#39;convert %s.png -transparent white %s.png&#39;</span> %
            (method, method))
        image_commands.append(
            <span style="color: #CD5555">&#39;pdftk %s output tmp.pdf&#39;</span> % pdf_files)
        num_rows = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(<span style="color: #658b00">len</span>(dt_values)/<span style="color: #B452CD">2.0</span>))
        image_commands.append(
            <span style="color: #CD5555">&#39;pdfnup --nup 2x%d tmp.pdf&#39;</span> % num_rows)
        image_commands.append(
            <span style="color: #CD5555">&#39;pdfcrop tmp-nup.pdf %s.pdf&#39;</span> % method)

    <span style="color: #8B008B; font-weight: bold">for</span> cmd <span style="color: #8B008B">in</span> image_commands:
        <span style="color: #8B008B; font-weight: bold">print</span> cmd
        failure = os.system(cmd)
        <span style="color: #8B008B; font-weight: bold">if</span> failure:
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Command failed:&#39;</span>, cmd; sys.exit(<span style="color: #B452CD">1</span>)

    <span style="color: #228B22"># Remove the files generated above and by decay_mod.py</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">glob</span> <span style="color: #8B008B; font-weight: bold">import</span> glob
    filenames = glob(<span style="color: #CD5555">&#39;*_*.png&#39;</span>) + glob(<span style="color: #CD5555">&#39;*_*.pdf&#39;</span>) + \
                glob(<span style="color: #CD5555">&#39;*_*.eps&#39;</span>) + glob(<span style="color: #CD5555">&#39;tmp*.pdf&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> filename <span style="color: #8B008B">in</span> filenames:
        os.remove(filename)

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    run_experiments()
</pre></div>
<p>
This file is available as <a href="http://tinyurl.com/nm5587k/softeng1/experiments/decay_exper0.py" target="_self"><tt>experiments/decay_exper0.py</tt></a>.

<p>
We may comment upon many useful constructs in this script:

<ul>
 <li> <code>[float(arg) for arg in sys.argv[1:]]</code> builds a list of real numbers
   from all the command-line arguments.</li>
 <li> <code>failure = os.system(cmd)</code> runs an operating system command, e.g.,
   another program. The execution is successful only if <code>failure</code> is zero.</li>
 <li> Unsuccessful execution usually makes it meaningless to continue
   the program, and therefore we abort the program with <code>sys.exit(1)</code>.
   Any argument different from 0 signifies to the computer's operating system
   that our program stopped with a failure.</li>
 <li> <code>['%s_%s.png' % (method, dt) for dt in dt_values]</code> builds a list of
   filenames from a list of numbers (<code>dt_values</code>).</li>
 <li> All <code>montage</code>, <code>convert</code>, <code>pdftk</code>, <code>pdfnup</code>, and <code>pdfcrop</code>
   commands for creating
   composite figures are stored in a
   list and later executed in a loop.</li>
 <li> <code>glob('*_*.png')</code> returns a list of the names of all files in the
   current directory where the filename matches the <a href="http://en.wikipedia.org/wiki/Glob_(programming)" target="_self">Unix wildcard notation</a>
   <code>*_*.png</code> (meaning any text, underscore, any text, and then <code>.png</code>).</li>
 <li> <code>os.remove(filename)</code> removes the file with name <code>filename</code>.</li>
</ul>

<h2>Interpreting output from other programs  <a name="___sec45"></a></h2>

<p>
Programs that run other programs, like <code>decay_exper0.py</code> does, will often
need to interpret output from those programs. Let us demonstrate how
this is done in Python by extracting the relations between \( \theta \),
\( \Delta t \), and the error \( E \) as written to the terminal window
by the <code>decay_mod.py</code> program, when being executed by
<code>decay_exper0.py</code>. We will

<ul>
  <li> read the output from the <code>decay_mod.py</code> program</li>
  <li> interpret this output and store the \( E \) values in arrays for each
    \( \theta \) value</li>
  <li> plot \( E \) versus \( \Delta t \), for each \( \theta \), in a log-log plot</li>
</ul>

The simple <code>os.system(cmd)</code> call does not allow us to read the
output from running <code>cmd</code>. Instead we need to invoke a bit more
involved procedure:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">subprocess</span> <span style="color: #8B008B; font-weight: bold">import</span> Popen, PIPE, STDOUT
p = Popen(cmd, shell=<span style="color: #658b00">True</span>, stdout=PIPE, stderr=STDOUT)
output, dummy = p.communicate()
failure = p.returncode
<span style="color: #8B008B; font-weight: bold">if</span> failure:
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Command failed:&#39;</span>, cmd; sys.exit(<span style="color: #B452CD">1</span>)
</pre></div>
<p>
The command stored in <code>cmd</code> is run and all text that is written to
the standard output <em>and</em> the standard error is available in the
string <code>output</code>. Or in other words, the text in <code>output</code> is what appeared in the
terminal window while running <code>cmd</code>.

<p>
Our next task is to run through the <code>output</code> string, line by line,
and if the current line prints \( \theta \), \( \Delta t \), and \( E \),
we split the line into these three pieces and store the data.
The chosen storage structure is a dictionary <code>errors</code> with keys <code>dt</code>
to hold the \( \Delta t \) values in a list, and three \( \theta \) keys to hold
the corresponding \( E \) values in a list. The relevant code lines are

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">errors = {<span style="color: #CD5555">&#39;dt&#39;</span>: dt_values, <span style="color: #B452CD">1</span>: [], <span style="color: #B452CD">0</span>: [], <span style="color: #B452CD">0.5</span>: []}
<span style="color: #8B008B; font-weight: bold">for</span> line <span style="color: #8B008B">in</span> output.splitlines():
    words = line.split()
    <span style="color: #8B008B; font-weight: bold">if</span> words[<span style="color: #B452CD">0</span>] <span style="color: #8B008B">in</span> (<span style="color: #CD5555">&#39;0.0&#39;</span>, <span style="color: #CD5555">&#39;0.5&#39;</span>, <span style="color: #CD5555">&#39;1.0&#39;</span>):  <span style="color: #228B22"># line with E?</span>
        <span style="color: #228B22"># typical line: 0.0   1.25:    7.463E+00</span>
        theta = <span style="color: #658b00">float</span>(words[<span style="color: #B452CD">0</span>])
        E = <span style="color: #658b00">float</span>(words[<span style="color: #B452CD">2</span>])
        errors[theta].append(E)
</pre></div>
<p>
Note that we do not bother to store the \( \Delta t \) values as we
read them from <code>output</code>, because we already have these values in
the <code>dt_values</code> list.

<p>
We are now ready to plot \( E \) versus \( \Delta t \) for \( \theta=0,0.5,1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
plt.loglog(errors[<span style="color: #CD5555">&#39;dt&#39;</span>], errors[<span style="color: #B452CD">0</span>], <span style="color: #CD5555">&#39;ro-&#39;</span>)
plt.hold(<span style="color: #CD5555">&#39;on&#39;</span>)
plt.loglog(errors[<span style="color: #CD5555">&#39;dt&#39;</span>], errors[<span style="color: #B452CD">0.5</span>], <span style="color: #CD5555">&#39;b+-&#39;</span>)
plt.loglog(errors[<span style="color: #CD5555">&#39;dt&#39;</span>], errors[<span style="color: #B452CD">1</span>], <span style="color: #CD5555">&#39;gx-&#39;</span>)
plt.legend([<span style="color: #CD5555">&#39;FE&#39;</span>, <span style="color: #CD5555">&#39;CN&#39;</span>, <span style="color: #CD5555">&#39;BE&#39;</span>], loc=<span style="color: #CD5555">&#39;upper left&#39;</span>)
plt.xlabel(<span style="color: #CD5555">&#39;log(time step)&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;log(error)&#39;</span>)
plt.title(<span style="color: #CD5555">&#39;Error vs time step&#39;</span>)
plt.savefig(<span style="color: #CD5555">&#39;error.png&#39;</span>)
plt.savefig(<span style="color: #CD5555">&#39;error.pdf&#39;</span>)
</pre></div>
<p>
Plots occasionally need some manual adjustments. Here, the axis of
the log-log plot look nicer if we adapt them strictly to the data,
see Figure <a href="#decay:exper:Evsdt">3</a>.
To this end, we need to compute \( \min E \) and \( \max E \), and later
specify the extent of the axes:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Find min/max for the axis</span>
E_min = <span style="color: #B452CD">1E+20</span>; E_max = -E_min
<span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>:
    E_min = <span style="color: #658b00">min</span>(E_min, <span style="color: #658b00">min</span>(errors[theta]))
    E_max = <span style="color: #658b00">max</span>(E_max, <span style="color: #658b00">max</span>(errors[theta]))

plt.loglog(errors[<span style="color: #CD5555">&#39;dt&#39;</span>], errors[<span style="color: #B452CD">0</span>], <span style="color: #CD5555">&#39;ro-&#39;</span>)
...
plt.axis([<span style="color: #658b00">min</span>(dt_values), <span style="color: #658b00">max</span>(dt_values), E_min, E_max])
...
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Default plot (left) and manually adjusted axes (right). <a name="decay:exper:Evsdt"></a> </p></center>
<p><img src="fig-softeng1/error_plot_improvement.png" align="bottom" width=800,></p>
</center>

<p>
The complete program, incorporating the code snippets above, is found
in <a href="http://tinyurl.com/nm5587k/softeng1/experiments/decay_exper1.py" target="_self"><tt>experiments/decay_exper1.py</tt></a>.
This example can hopefully act as template for numerous
other occasions
where one needs to run experiments, extract data from the output
of programs, make plots, and combine several plots in a figure file.
The <code>decay_exper1.py</code> program
is organized as a module, and other files can then easily extend
the functionality, as illustrated in the next section.

<h2>Making a report <a name="decay:exper:report"></a></h2>

<p>
The results of running computer experiments are best documented in a
little report containing the problem to be solved, key code segments,
and the plots from a series of experiments. At least the part of the
report containing the plots should be automatically generated by the
script that performs the set of experiments, because in that script we
know exactly which input data that were used to generate a specific
plot, thereby ensuring that each figure is connected to the
right data. Take a look at an
example at <a href="http://hplgit.github.io/teamods/writing_reports/sphinx-cloud/" target="_self"><tt>http://hplgit.github.io/teamods/writing_reports/sphinx-cloud/</tt></a>  to see what we have in
mind.

<h3>Plain HTML  <a name="___sec47"></a></h3>

<p>
Scientific reports can be written in a variety of formats. Here we
begin with the <a href="http://en.wikipedia.org/wiki/HTML" target="_self">HTML</a> format
which allows efficient viewing of all the experiments in any web
browser. The program
<a href="http://tinyurl.com/nm5587k/softeng1/experiments/decay_exper1_html.py" target="_self"><tt>decay_exper1_html.py</tt></a> calls
<code>decay_exper1.py</code> to perform the experiments and then runs
statements for creating an HTML file with a summary, a
section on the mathematical problem, a section on the numerical
method, a section on the <code>solver</code> function implementing the
method, and a section with subsections containing figures that show
the results of experiments where \( \Delta t \) is varied for
\( \theta=0,0.5,1 \). The mentioned
Python file contains all the details for writing
this <a href="http://hplgit.github.io/teamods/writing_reports/_static/report_html.html.html" target="_self">HTML report</a>.
You can view the report on <a href="http://hplgit.github.io/teamods/writing_reports/_static/report_html.html" target="_self"><tt>http://hplgit.github.io/teamods/writing_reports/_static/report_html.html</tt></a>.

<h3>HTML with MathJax  <a name="___sec48"></a></h3>

<p>
Scientific reports usually need mathematical formulas and hence
mathematical typesetting. In plain HTML, as used in the
<code>decay_exper1_html.py</code> file, we have to use just the keyboard
characters to write mathematics. However, there is an extension to
HTML, called <a href="http://www.mathjax.org/" target="_self">MathJax</a>, which allows
formulas and equations to be typeset with LaTeX syntax and nicely
rendered in web browsers, see Figure
<a href="#decay:exper:report:fig:mathjax">4</a>.  A relatively small subset of
LaTeX environments is supported, but the syntax for formulas is quite
rich. Inline formulas are look like <code>\( u'=-au \)</code> while equations are
surrounded by <code>$$</code> signs.  Inside such signs, one can use <code>\[ u'=-au
\]</code> for unnumbered equations, or <code>\begin{equation}</code> and
<code>\end{equation}</code> surrounding <code>u'=-au</code> for numbered equations, or
<code>\begin{align}</code> and <code>\end{align}</code> for multiple aligned equations.  You
need to be familiar with <a href="http://en.wikibooks.org/wiki/LaTeX/Mathematics" target="_self">mathematical typesetting in LaTeX</a>.

<p>
The file <a href="http://tinyurl.com/nm5587k/softeng1/experiments/decay_exper1_html.py" target="_self"><tt>decay_exper1_mathjax.py</tt></a> contains all the
details for turning the previous plain HTML report into <a href="http://hplgit.github.io/teamods/writing_reports/_static/report_mathjax.html" target="_self">web pages
with nicely typeset mathematics</a>.  The
<a href="http://hplgit.github.io/teamods/writing_reports/_static/report_mathjax.html.html" target="_self">corresponding HTML code</a> be studied
to see all details of the mathematical typesetting.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Report in HTML format with MathJax. <a name="decay:exper:report:fig:mathjax"></a> </p></center>
<p><img src="fig-softeng1/report_mathjax.png" align="bottom" width=600></p>
</center>

<h3>LaTeX  <a name="___sec49"></a></h3>

<p>
<!-- "http://en.wikibooks.org/wiki/LaTeX" -->

<p>
The <em>de facto</em> language for mathematical typesetting and scientific
report writing is <a href="http://en.wikipedia.org/wiki/LaTeX" target="_self">LaTeX</a>. A
number of very sophisticated packages have been added to the language
over a period of three decades, allowing very fine-tuned layout and
typesetting. For output in the <a href="http://hplgit.github.io/teamods/writing_reports/_static/report.pdf" target="_self">PDF format</a>, see Figure
<a href="#decay:exper:report:fig:latex">5</a> for an example, LaTeX is the
definite choice when it comes to quality. The LaTeX language used to
write the reports has typically a lot of commands involving
<a href="http://hplgit.github.io/teamods/writing_reports/_static/report.tex.html" target="_self">backslashes and braces</a>.  For output on
the web, using HTML (and not the PDF directly in the browser window),
LaTeX struggles with delivering high quality typesetting. Other tools,
especially Sphinx, give better results and can also produce
nice-looking PDFs.  The file <code>decay_exper1_latex.py</code> shows how to
generate the LaTeX source from a program.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Report in PDF format generated from LaTeX source. <a name="decay:exper:report:fig:latex"></a> </p></center>
<p><img src="fig-softeng1/report_latexpdf.png" align="bottom" width=600></p>
</center>

<h3>Sphinx  <a name="___sec50"></a></h3>

<p>
<!-- give pointers to source pages -->

<p>
<a href="http://sphinx.pocoo.org/" target="_self">Sphinx</a> is a typesetting language with
similarities to HTML and LaTeX, but with much less tagging. It has
recently become very popular for software documentation and
mathematical reports. Sphinx can utilize LaTeX for mathematical
formulas and equations (via MathJax or PNG images). Unfortunately, the
subset of LaTeX mathematics supported is less than in full MathJax (in
particular, numbering of multiple equations in an <code>align</code> type
environment is not supported).  The <a href="http://hplgit.github.io/teamods/writing_reports/_static/report_sphinx.rst.html" target="_self">Sphinx syntax</a> is an extension of
the reStructuredText language. An attractive feature of Sphinx is its
rich support for <a href="http://hplgit.github.io/teamods/writing_reports/_static/sphinx-cloud/index.html" target="_self">fancy layout of web pages</a>. In particular,
Sphinx can easily be combined with various layout <em>themes</em> that give a
certain look and feel to the web site and that offers table of
contents, navigation, and search facilities, see Figure
<a href="#decay:exper:report:fig:sphinx">6</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Report in HTML format generated from Sphinx source. <a name="decay:exper:report:fig:sphinx"></a> </p></center>
<p><img src="fig-softeng1/report_sphinx.png" align="bottom" width=600></p>
</center>

<h3>Markdown  <a name="___sec51"></a></h3>

<p>
A recently popular format for easy writing of web pages is
<a href="http://daringfireball.net/projects/markdown/" target="_self">Markdown</a>.
Text is written very much like one would do in email, using
spacing and special characters to naturally format the code
instead of heavily tagging the text as in LaTeX and HTML.
With the tool <a href="http://johnmacfarlane.net/pandoc/" target="_self">Pandoc</a> one
can go from Markdown to a variety of formats.
HTML is a common output format, but LaTeX, epub, XML,
OpenOffice, MediaWiki, and MS Word are some other possibilities.

<h3>Wiki formats  <a name="___sec52"></a></h3>

<p>
A range of wiki formats are popular for creating notes on the web,
especially documents which allow groups of people to edit and add
content. Apart from <a href="http://www.mediawiki.org/wiki/MediaWiki" target="_self">MediaWiki</a> (the wiki format used for
Wikipedia), wiki formats have no support for mathematical typesetting
and also limited tools for displaying computer code in nice ways.
Wiki formats are therefore less suitable for scientific reports compared
to the other formats mentioned here.

<h3>DocOnce  <a name="___sec53"></a></h3>

<p>
Since it is difficult to choose the right tool or format for writing
a scientific report, it is advantageous to write the content in a
format that easily translates to LaTeX, HTML, Sphinx, Markdown,
and various wikis. <a href="https://github.com/hplgit/doconce" target="_self">DocOnce</a> is such
a tool. It is similar to Pandoc, but offers some special convenient
features for writing about mathematics and programming.
The <a href="http://hplgit.github.io/teamods/writing_reports/_static/report.do.txt.html" target="_self">tagging is modest</a>,
somewhere between LaTeX and Markdown.
The program <code>decay_exper_do.py</code> demonstrates how to generate (and write)
DocOnce code for a report.

<h3>Worked example  <a name="___sec54"></a></h3>

<p>
The HTML, LaTeX (PDF), Sphinx, and DocOnce formats for the scientific
report whose content is outlined above, are exemplified
with source codes and results at the
web pages associated with this teaching material:
<a href="http://hplgit.github.io/teamods/writing_reports" target="_self"><tt>http://hplgit.github.io/teamods/writing_reports</tt></a>.

<p>
<!-- project with exploring instability (help with matplotlib contour plots, and maybe show such a plot) -->

<h2>Publishing a complete project <a name="decay:exper:github"></a></h2>

<p>
A report documenting scientific investigations should be accompanied by
all the software and data used for the investigations so that others
have a possibility to redo the work and assess the qualify of the results.
This possibility is important for <em>reproducible research</em> and
hence reaching reliable scientific conclusions.

<p>
One way of documenting a complete project is to make a directory tree
with all relevant files. Preferably, the tree is published at
some project hosting site like <a href="http://hplgit.github.com/teamods/bitgit/html/" target="_self">Bitbucket, GitHub, or Googlecode</a> so that others can download it
as a tarfile, zipfile, or clone the files directly using a version control
system like Mercurial or Git.
For the investigations outlined in the section <a href="#decay:exper:report">Making a report</a>,
we can create a directory tree with files
<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">setup.py
./src:
   decay_mod.py
./doc:
   ./src:
      decay_exper1_mathjax.py
      make_report.sh
      run.sh
   ./pub:
      report.html
</pre></div>
<p>
The <code>src</code> directory holds source code (modules) to be reused in other projects,
the <code>setup.py</code> builds and installs such software,
the <code>doc</code> directory contains the documentation, with <code>src</code> for the
source of the documentation and <code>pub</code> for ready-made, published documentation.
The <code>run.sh</code> file is a simple Bash script listing the <code>python</code> command
we used to run <code>decay_exper1_mathjax.py</code> to generate the experiments and
the <code>report.html</code> file.

<p>
<!-- Point to DocOnce version -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_softeng1-solarized002.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_softeng1-solarized004.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

