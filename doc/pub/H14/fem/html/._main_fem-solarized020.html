<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to finite element methods">
<meta name="keywords" content="approximation of vectors in the plane,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,residual,variational formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements">

<title>Introduction to finite element methods</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Approximation of vectors ',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              (' Approximation of planar vectors ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' The least squares method ', 3, None, '___sec2'),
              (' The projection method ', 3, None, '___sec3'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 3, None, '___sec5'),
              (' The Galerkin or projection method ', 3, None, '___sec6'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec9'),
              (' Example: linear approximation ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Implementation of the least squares method ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Symbolic integration ', 3, None, '___sec12'),
              (' Fallback on numerical integration ', 3, None, '___sec13'),
              (' Plotting the approximation ', 3, None, '___sec14'),
              (' Perfect approximation ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Ill-conditioning ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Fourier series ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Orthogonal basis functions ',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              (' Numerical computations ', 2, None, '___sec19'),
              (' The interpolation (or collocation) method ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' Example ', 3, None, '___sec21'),
              (' Lagrange polynomials ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Approximation of a polynomial ', 3, None, '___sec23'),
              (' Successful example ', 3, None, '___sec24'),
              (' Less successful example ', 3, None, '___sec25'),
              (' Remedy for strong oscillations ', 3, None, '___sec26'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example ', 3, None, '___sec29'),
              (' The basis functions ', 2, None, '___sec30'),
              (' Construction principles ', 3, None, '___sec31'),
              (' Properties of $\\basphi_i$ ', 3, None, '___sec32'),
              (' Example on piecewise quadratic finite element functions ',
               2,
               None,
               '___sec33'),
              (' Example on piecewise linear finite element functions ',
               2,
               None,
               '___sec34'),
              (' Example on piecewise cubic finite element basis functions ',
               2,
               None,
               '___sec35'),
              (' Calculating the linear system ',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Calculating a specific matrix entry ', 3, None, '___sec37'),
              (' Calculating a general row in the matrix ',
               3,
               None,
               '___sec38'),
              (' Assembly of elementwise computations ',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Mapping to a reference element ',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Example: Integration over a reference element ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Implementation ',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              (' Integration ',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              (' Linear system assembly and solution ',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              (' Example on computing symbolic approximations ',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              (' Comparison with finite elements and interpolation/collocation ',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              (' Example on computing numerical approximations ',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' Applications ',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Finite difference approximation of given functions ',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              (' Finite difference interpretation of a finite element approximation ',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              (' Making finite elements behave as finite differences ',
               2,
               None,
               '___sec54'),
              (' Computations in physical space ', 3, None, '___sec55'),
              (' Elementwise computations ', 3, None, '___sec56'),
              (' Terminology ', 3, None, '___sec57'),
              (' A generalized element concept ',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              (' Cells, vertices, and degrees of freedom ',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              (' Extended finite element concept ',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              (' Implementation ',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              (' Computing the error of the approximation ',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              (' Example: Cubic Hermite polynomials ',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              (' Numerical integration ', 1, None, '___sec64'),
              (' Newton-Cotes rules ',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              (' Gauss-Legendre rules with optimized points ',
               2,
               None,
               '___sec66'),
              (' Approximation of functions in 2D ',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              (' 2D basis functions as tensor products of 1D functions ',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              (' Example: Polynomial basis in 2D ', 2, None, '___sec69'),
              (' Implementation ',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              (' Extension to 3D ',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              (' Finite elements in 2D and 3D ', 1, None, '___sec72'),
              (' Basis functions over triangles in the physical domain ',
               2,
               None,
               '___sec73'),
              (' Element matrices and vectors ', 3, None, '___sec74'),
              (' Basis functions over triangles in the reference cell ',
               2,
               None,
               '___sec75'),
              (' Affine mapping of the reference cell ', 2, None, '___sec76'),
              (' Isoparametric mapping of the reference cell ',
               2,
               None,
               '___sec77'),
              (' Computing integrals ', 2, None, '___sec78'),
              (' Exercises ', 1, None, '___sec79'),
              (' Exercise 1: Linear algebra refresher I ',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              (' Exercise 2: Linear algebra refresher II ',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              (' Exercise 3: Approximate a three-dimensional vector in a plane ',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              (' Exercise 4: Approximate the exponential function by power functions ',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              (' Exercise 5: Approximate the sine function by power functions ',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              (' Exercise 6: Approximate a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              (' Remarks ', 3, None, '___sec86'),
              (' Exercise 7: Animate the approximation of a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine2',
               'fem:approx:exer:tanh:sine2'),
              (' Exercise 8: Fourier series as a least squares approximation ',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              (' Exercise 9: Approximate a steep function by Lagrange polynomials ',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              (' Exercise 10: Define nodes and elements ',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              (' Exercise 11: Define vertices, cells, and dof maps ',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              (' Exercise 12: Construct matrix sparsity patterns ',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              (' Exercise 13: Perform symbolic finite element computations ',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              (' Exercise 14: Approximate a steep function by P1 and P2 elements ',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              (' Exercise 15: Approximate a steep function by P3 and P4 elements ',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              (' Exercise 16: Investigate the approximation error in finite elements ',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              (' Exercise 17: Approximate a step function by finite elements ',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              (' Exercise 18: 2D approximation with orthogonal functions ',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              (' Exercise 19: Use the Trapezoidal rule and P1 elements ',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              (' Problem 20: Compare P1 elements and interpolation ',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              (' Exercise 21: Implement 3D computations with global basis functions ',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              (" Exercise 22: Use Simpson's rule and P2 elements ",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              (' Basic principles for approximating differential equations ',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              (' Differential equation models ',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              (' Simple model problems ',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              (' Forming the residual ',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              (' The least squares method ', 2, None, '___sec107'),
              (' The Galerkin method ', 2, None, '___sec108'),
              (' The Method of Weighted Residuals ', 2, None, '___sec109'),
              (' Test and Trial Functions ', 2, None, '___sec110'),
              (' The collocation method ', 2, None, '___sec111'),
              (' The subdomain collocation method ', 3, None, '___sec112'),
              (' Examples on using the principles ',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              (' The model problem ', 3, None, '___sec114'),
              (' Basis functions ', 3, None, '___sec115'),
              (' The residual ', 3, None, '___sec116'),
              (' The least squares method ', 3, None, '___sec117'),
              (' The Galerkin method ', 3, None, '___sec118'),
              (' The collocation method ', 3, None, '___sec119'),
              (' Comparison ', 3, None, '___sec120'),
              (' Integration by parts ',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              (' Weak form ', 3, None, '___sec122'),
              (' Boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Abstract notation for variational formulations ',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              (' Variational problems and optimization of functionals ',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              (' Examples on variational formulations ',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              (' Variable coefficient ', 2, None, '___sec127'),
              (' First-order derivative in the equation and boundary condition ',
               2,
               None,
               '___sec128'),
              (' Nonlinear coefficient ', 2, None, '___sec129'),
              (' Computing with Dirichlet and Neumann conditions ',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              (' When the numerical method is exact ', 2, None, '___sec131'),
              (' Computing with finite elements ',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              (' Finite element mesh and basis functions ',
               2,
               None,
               '___sec133'),
              (' Computation in the global physical domain ',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              (' Comparison with a finite difference discretization ',
               2,
               None,
               '___sec135'),
              (' Cellwise computations ',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              (' The integral for the element matrix ', 3, None, '___sec137'),
              (' The integral for the element vector ', 3, None, '___sec138'),
              (' Detailed calculations of the element matrix and vector ',
               3,
               None,
               '___sec139'),
              (' Contributions from the first and last cell ',
               3,
               None,
               '___sec140'),
              (' Assembly ', 3, None, '___sec141'),
              (' Boundary conditions: specified nonzero value ',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              (' General construction of a boundary function ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              (' Example on computing with finite element-based a boundary function ',
               2,
               None,
               '___sec144'),
              (' Computations in physical coordinates ',
               3,
               None,
               '___sec145'),
              (' Cellwise computations on the reference element ',
               3,
               None,
               '___sec146'),
              (' Modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (' Computations in the physical system ', 3, None, '___sec148'),
              (' Symmetric modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (' Modification of the element matrix and vector ',
               2,
               None,
               '___sec150'),
              (' Boundary conditions: specified derivative ',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              (' The variational formulation ', 2, None, '___sec152'),
              (' Boundary term vanishes because of the test functions ',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              (' Boundary term vanishes because of linear system modifications ',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              (' Direct computation of the global linear system ',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              (' Cellwise computations ', 2, None, '___sec156'),
              (' Implementation ',
               1,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              (' Global basis functions ', 2, None, '___sec158'),
              (' Example: constant right-hand side ', 2, None, '___sec159'),
              (' Finite elements ', 2, None, '___sec160'),
              (' Variational formulations in 2D and 3D ',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              (' Transformation to a reference cell in 2D and 3D ',
               2,
               None,
               '___sec162'),
              (' Numerical integration ', 2, None, '___sec163'),
              (' Convenient formulas for P1 elements in 2D ',
               2,
               None,
               '___sec164'),
              (' Summary ', 1, None, '___sec165'),
              (' Time-dependent problems ',
               1,
               'fem:deq:timedep',
               'fem:deq:timedep'),
              (' Discretization in time by a Forward Euler scheme ',
               2,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              (' Time discretization ', 3, None, '___sec168'),
              (' Space discretization ', 3, None, '___sec169'),
              (' Variational forms ', 2, None, '___sec170'),
              (' Simplified notation for the solution at recent time levels ',
               2,
               None,
               '___sec171'),
              (' Deriving the linear systems ', 2, None, '___sec172'),
              (' Computational algorithm ', 2, None, '___sec173'),
              (' Comparing P1 elements with the finite difference method ',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              (' Lumping the mass matrix ', 3, None, '___sec175'),
              (' Discretization in time by a Backward Euler scheme ',
               2,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              (' Time discretization ', 3, None, '___sec177'),
              (' Variational forms ', 3, None, '___sec178'),
              (' Linear systems ', 3, None, '___sec179'),
              (' Dirichlet boundary conditions ',
               2,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              (' Boundary function ', 3, None, '___sec181'),
              (' Finite element basis functions ', 3, None, '___sec182'),
              (' Modification of the linear system ', 3, None, '___sec183'),
              (' Example: Oscillating Dirichlet boundary condition ',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              (' Analysis of the discrete equations ',
               2,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              (' Forward Euler discretization ', 3, None, '___sec186'),
              (' Backward Euler discretization ', 3, None, '___sec187'),
              (' Comparing amplification factors ', 3, None, '___sec188'),
              (' Systems of differential equations ',
               1,
               'fem:sys',
               'fem:sys'),
              (' Variational forms ', 2, 'fem:sys:vform', 'fem:sys:vform'),
              (' A worked example ', 2, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              (' Identical function spaces for the unknowns ',
               2,
               None,
               '___sec192'),
              (' Variational form of each individual PDE ',
               3,
               None,
               '___sec193'),
              (' Compound scalar variational form ', 3, None, '___sec194'),
              (' Decoupled linear systems ', 3, None, '___sec195'),
              (' Coupled linear systems ', 3, None, '___sec196'),
              (' Different function spaces for the unknowns ',
               2,
               None,
               '___sec197'),
              (' Computations in 1D ', 2, None, '___sec198'),
              (' Exercises ', 1, None, '___sec199'),
              (' Exercise 23: Refactor functions into a more general class ',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              (' Exercise 24: Compute the deflection of a cable with sine functions ',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              (' Exercise 25: Check integration by parts ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 26: Compute the deflection of a cable with 2 P1 elements ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 27: Compute the deflection of a cable with 1 P2 element ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 28: Compute the deflection of a cable with a step load ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 29: Show equivalence between linear systems ',
               2,
               'fem:deq:exer:Aub:essbc:equiv',
               'fem:deq:exer:Aub:essbc:equiv'),
              (' Exercise 30: Compute with a non-uniform mesh ',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              (' Problem 31: Solve a 1D finite element problem by hand ',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              (' Exercise 32: Compare finite elements and differences for a radially symmetric Poisson equation ',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              (' Exercise 33: Compute with variable coefficients and P1 elements by hand ',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              (' Exercise 34: Solve a 2D Poisson equation using polynomials and sines ',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              (' Exercise 35: Analyze a Crank-Nicolson scheme for the diffusion equation ',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              (' Bibliography ', 1, None, '___sec213')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0020"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_fem-solarized019.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_fem-solarized021.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1>Time-dependent problems <a name="fem:deq:timedep"></a></h1>

<p>
The finite element method is normally used for discretization in
space. There are two alternative strategies for performing
a discretization in time:

<ul>
 <li> use finite differences for time derivatives to arrive at
   a recursive set of spatial problems that can be discretized by
   the finite element method, or</li>
 <li> discretize in space by finite elements first, and then solve
   the resulting system of ordinary differential equations (ODEs) by
   some standard method for ODEs.</li>
</ul>

We shall exemplify these strategies using a simple diffusion problem

$$
\begin{align}
\frac{\partial u}{\partial t} &= \dfc\nabla^2 u + f(\x, t),\quad
&\x\in\Omega, t\in (0,T],
\tag{102}\\ 
u(\x, 0) & = I(\x),\quad &\x\in\Omega,
\tag{103}\\ 
\frac{\partial u}{\partial n} &= 0,\quad &\x\in\partial\Omega,\ t\in (0,T]
\tag{104}
\tp
\end{align}
$$

Here, \( u(\x,t) \) is the unknown function, \( \dfc \) is a constant, and
\( f(\x,t) \) and \( I(x) \) are given functions. We have assigned the particular
boundary condition <a href="#mjx-eqn-104">(104)</a> to minimize
the details on handling boundary conditions in the finite element method.

<h2>Discretization in time by a Forward Euler scheme <a name="fem:deq:diffu:FE"></a></h2>

<p>
<!-- 2DO -->
<!-- N_s out: use N_t in time N in general space in all examples, -->
<!-- and change decay and vib to N_t -->

<h3>Time discretization  <a name="___sec168"></a></h3>

<p>
We can apply a finite difference method in time to <a href="#mjx-eqn-102">(102)</a>.
First we need a mesh in time, here taken as uniform with
mesh points \( t_n = n\Delta t \), \( n=0,1,\ldots,N_t \).
A Forward Euler scheme consists of sampling <a href="#mjx-eqn-102">(102)</a>
at \( t_n \) and approximating the time derivative by a forward
difference \( [D_t^+ u]^n\approx
(u^{n+1}-u^n)/\Delta t \). This approximation turns <a href="#mjx-eqn-102">(102)</a>
into a differential equation that is discrete in time, but still
continuous in space.
With a finite difference operator notation we can write the
time-discrete problem as

$$
\begin{equation}
[D_t^+ u = \dfc\nabla^2 u + f]^n,
\tag{105}
\end{equation}
$$

for \( n=1,2,\ldots,N_t-1 \). Writing this equation out in detail and
isolating the unknown \( u^{n+1} \) on the left-hand side, demonstrates that
the time-discrete problem is a recursive set of problems that are
continuous in space:

$$
\begin{equation}
u^{n+1} = u^n + \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)
\tag{106}
\tp
\end{equation}
$$

Given \( u^0=I \), we can use <a href="#mjx-eqn-106">(106)</a> to compute
\( u^1,u^2,\dots,u^{N_t} \).

<p>
For absolute clarity in the various stages of the discretizations, we
introduce \( \uex(\x,t) \) as the exact solution of the space-and time-continuous
partial differential equation <a href="#mjx-eqn-102">(102)</a> and
\( \uex^n(\x) \) as the time-discrete approximation, arising from the finite
difference method in time <a href="#mjx-eqn-105">(105)</a>.
More precisely, \( \uex \) fulfills

$$
\begin{equation}
\frac{\partial \uex}{\partial t} = \dfc\nabla^2 \uex + f(\x, t)
\tag{107},
\end{equation}
$$

while \( \uex^{n+1} \), with a superscript,
is the solution of the time-discrete equations

$$
\begin{equation}
\uex^{n+1} = \uex^n + \Delta t \left( \dfc\nabla^2 \uex^n + f(\x, t_n)\right)
\tag{108}
\tp
\end{equation}
$$

<h3>Space discretization  <a name="___sec169"></a></h3>

<p>
We now introduce a finite element approximation to \( \uex^n \) and \( \uex^{n+1} \)
in <a href="#mjx-eqn-108">(108)</a>, where the coefficients depend on the
time level:

$$
\begin{align}
\uex^n &\approx u^n = \sum_{j=0}^{N} c_j^{n}\baspsi_j(\x),
\tag{109}\\ 
\uex^{n+1} &\approx u^{n+1} = \sum_{j=0}^{N} c_j^{n+1}\baspsi_j(\x)
\tag{110}
\tp
\end{align}
$$

Note that, as before, \( N \) denotes the number of degrees of freedom
in the spatial domain. The number of time points is denoted by \( N_t \).
We define a space \( V \) spanned by the basis functions \( \sequencei{\baspsi} \).
<!-- Also note that we use \( u^n \) as the numerical solution we want -->
<!-- to compute in a program, while \( \uex \) and \( \uex^n \) are used when -->
<!-- we occasionally -->
<!-- need to refer to the exact solution and the time-discrete solution, -->
<!-- respectively. -->

<h2>Variational forms  <a name="___sec170"></a></h2>

<p>
A weighted residual method with weighting functions \( w_i \) can
now be formulated. We insert <a href="#mjx-eqn-109">(109)</a> and
<a href="#mjx-eqn-110">(110)</a> in
<a href="#mjx-eqn-108">(108)</a> to obtain the residual

$$ R = u^{n+1} - u^n - \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)
\tp $$

The weighted residual principle,

$$ \int_\Omega Rw\dx = 0,\quad \forall w\in W,$$

results in

$$
\int_\Omega
\left\lbrack
u^{n+1} - u^n - \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)
\right\rbrack w \dx =0, \quad\forall w \in W\tp
$$

From now on we use the Galerkin method so \( W=V \).
Isolating the unknown \( u^{n+1} \) on the left-hand side gives

$$
\int_{\Omega} u^{n+1}\baspsi_i\dx = \int_{\Omega}
\left\lbrack u^n - \Delta t \left( \dfc\nabla^2 u^n + f(\x, t_n)\right)
\right\rbrack v\dx,\quad \forall v\in V
\tp
$$


<p>
As usual in spatial finite element problems involving second-order
derivatives, we apply integration by parts on the term
\( \int (\nabla^2 u^n)v\dx \):

$$ \int_{\Omega}\dfc(\nabla^2 u^n)v \dx =
-\int_{\Omega}\dfc\nabla u^n\cdot\nabla v\dx +
\int_{\partial\Omega}\dfc\frac{\partial u^n}{\partial n}v \dx
\tp
$$

The last term vanishes because we have the Neumann condition
\( \partial u^n/\partial n=0 \) for all \( n \). Our discrete problem in
space and time then reads

$$
\begin{equation}
\int_{\Omega} u^{n+1}v\dx =
\int_{\Omega} u^n vdx -
\Delta t \int_{\Omega}\dfc\nabla u^n\cdot\nabla v\dx +
\Delta t\int_{\Omega}f^n v\dx,\quad \forall \v\in V\tp
\tag{111}
\end{equation}
$$

This is the variational formulation of our recursive set of spatial
problems.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Nonzero Dirichlet boundary conditions.</b>
<p>
As in stationary problems,
we can introduce a boundary function \( B(\x,t) \) to take care
of nonzero Dirichlet conditions:

$$
\begin{align}
\uex^n &\approx u^n = B(\x,t_n) + \sum_{j=0}^{N} c_j^{n}\baspsi_j(\x),
\tag{112}\\ 
\uex^{n+1} &\approx u^{n+1} = B(\x,t_{n+1}) +
\sum_{j=0}^{N} c_j^{n+1}\baspsi_j(\x)
\tag{113}
\tp
\end{align}
$$
</div>


<h2>Simplified notation for the solution at recent time levels  <a name="___sec171"></a></h2>

<p>
In a program it is only necessary to store \( u^{n+1} \) and \( u^n \) at the
same time. We therefore drop the \( n \) index in programs and work with
two functions: <code>u</code> for \( u^{n+1} \), the new unknown, and <code>u_1</code> for
\( u^n \), the solution at the previous time level. This is also
convenient in the mathematics to maximize the correspondence with the
code. From now on \( u_1 \) means the discrete unknown at the previous
time level (\( u^{n} \)) and \( u \) represents the
discrete unknown at the new time level (\( u^{n+1} \)).
Equation <a href="#mjx-eqn-111">(111)</a> with this new
naming convention is expressed as

$$
\begin{equation}
\int_{\Omega} u vdx =
\int_{\Omega} u_1 vdx -
\Delta t \int_{\Omega}\dfc\nabla u_1\cdot\nabla v\dx +
\Delta t\int_{\Omega}f^n v\dx
\tp
\tag{114}
\end{equation}
$$

This variational form can alternatively be expressed by the inner
product notation:

$$
\begin{equation}
(u,v) = (u_1,v) -
\Delta t (\dfc\nabla u_1,\nabla v) +
(f^n, v)
\tp
\tag{115}
\end{equation}
$$

<h2>Deriving the linear systems  <a name="___sec172"></a></h2>

<p>
To derive the equations for the new unknown coefficients \( c_j^{n+1} \),
now just called \( c_j \), we insert

$$ u = \sum_{j=0}^{N}c_j\baspsi_j(\x),\quad
u_1 = \sum_{j=0}^{N} c_{1,j}\baspsi_j(\x)$$

in <a href="#mjx-eqn-114">(114)</a> or <a href="#mjx-eqn-115">(115)</a>,
let the equation hold for all \( v=\baspsi \), $i=0,\ldots,$N,
and order the terms as matrix-vector products:

$$
\begin{equation}
\sum_{j=0}^{N} (\baspsi_i,\baspsi_j) c_j =
\sum_{j=0}^{N} (\baspsi_i,\baspsi_j) c_{1,j}
-\Delta t \sum_{j=0}^{N} (\nabla\baspsi_i,\dfc\nabla\baspsi_j) c_{1,j}
+ (f^n,\baspsi_i),\quad i=0,\ldots,N
\tp
\end{equation}
$$

This is a linear system \( \sum_j A_{i,j}c_j = b_i \) with

$$ A_{i,j} = (\baspsi_i,\baspsi_j)
$$

and

$$ b_i = \sum_{j=0}^{N} (\baspsi_i,\baspsi_j) c_{1,j}
-\Delta t \sum_{j=0}^{N} (\nabla\baspsi_i,\dfc\nabla\baspsi_j) c_{1,j}
+ (f^n,\baspsi_i)\tp  $$


<p>
It is instructive and convenient for implementations to write the linear
system on the form

$$
\begin{equation}
Mc = Mc_1 - \Delta t Kc_1 + f,
\end{equation}
$$

where

$$
\begin{align*}
M &= \{M_{i,j}\},\quad M_{i,j}=(\baspsi_i,\baspsi_j),\quad i,j\in\If,\\ 
K &= \{K_{i,j}\},\quad K_{i,j}=(\nabla\baspsi_i,\dfc\nabla\baspsi_j),
\quad i,j\in\If,\\ 
f &= \{(f(\x,t_n),\baspsi_i)\}_{i\in\If},\\ 
c &= \{c_i\}_{i\in\If},\\ 
c_1 &= \{c_{1,i}\}_{i\in\If}
\tp
\end{align*}
$$


<p>
We realize that \( M \) is the matrix arising from a term with the
zero-th derivative of \( u \), and called the mass matrix, while \( K \) is
the matrix arising from a Laplace term \( \nabla^2 u \). The \( K \) matrix
is often known as the <em>stiffness matrix</em>. (The terms mass and stiffness
stem from the early days of finite elements when applications to
vibrating structures dominated. The mass matrix arises from the
mass times acceleration term in Newton's second law, while the stiffness
matrix arises from the elastic forces in that law. The mass and stiffness
matrix appearing in a diffusion have slightly different mathematical
formulas.)

<p>
<b>Remark.</b>
The mathematical symbol \( f \) has two meanings, either the
function \( f(\x,t) \) in the PDE or the \( f \) vector in the linear system
to be solved at each time level. The symbol \( u \) also has different
meanings, basically the unknown in the PDE or the finite element
function representing the unknown at a time level. The actual
meaning should be evident from the context.

<h2>Computational algorithm  <a name="___sec173"></a></h2>

<p>
We observe that \( M \) and \( K \) can be precomputed so that we can avoid
computing the matrix entries at every time level. Instead, some
matrix-vector multiplications will produce the linear system to be solved.
The computational algorithm has the following steps:

<ol>
<li> Compute \( M \) and \( K \).</li>
<li> Initialize \( u^0 \) by interpolation or projection</li>
<li> For \( n=1,2,\ldots,N_t \):</li>

<ol>
  <li> compute \( b = Mc_1 - \Delta t Kc_1 + f \)</li>
  <li> solve \( Mc = b \)</li>
  <li> set \( c_1 = c \)</li>
</ol>

</ol>

In case of finite element basis functions, interpolation of the
initial condition at the nodes means \( c_{1,j} = I(\x_j) \). Otherwise
one has to solve the linear system \( \sum_j\baspsi_j(\xno{i})c_j =
I(\xno{i}) \), where \( \x_j \) denotes an interpolation point.  Projection
(or Galerkin's method) implies solving a linear system with \( M \) as
coefficient matrix : \( \sum_j M_{i,j}c_{1,j} = (I,\baspsi_i) \),
\( i\in\If \).

<h2>Comparing P1 elements with the finite difference method <a name="fem:deq:diffu:FE:fdvsP1fe"></a></h2>

<p>
We can compute the \( M \) and \( K \) matrices using P1 elements in 1D.
A uniform mesh on \( [0,L] \) is introduced for this purpose.
Since the boundary conditions are solely of Neumann type in this
sample problem, we have no restrictions on the basis functions
\( \baspsi_i \) and can simply choose \( \baspsi_i = \basphi_i \), \( i=0,\ldots,N=N_n \).

<p>
From the section <a href="._main_fem-solarized014.html#fem:deq:1D:comp:global">Computation in the global physical domain</a> or
<a href="._main_fem-solarized014.html#fem:deq:1D:comp:elmwise">Cellwise computations</a> we have that the \( K \) matrix is the same as we get
from the finite difference method: \( h[D_xD_x u]^n_i \), while
from the section <a href="._main_fem-solarized006.html#fem:approx:fe:fd:feproj">Finite difference interpretation of a finite element approximation</a> we know that \( M \) can be
interpreted as the finite difference approximation
\( [u + \frac{1}{6}h^2D_xD_x u]^n_i \) (times \( h \)). The equation system \( Mc=b \)
in
the algorithm is therefore equivalent to the finite difference scheme

$$
\begin{equation}
[D_t^+(u + \frac{1}{6}h^2D_xD_x u) = \dfc D_xD_x u + f]^n_i
\tag{116}
\tp
\end{equation}
$$

(More precisely, \( Mc=b \) divided by \( h \) gives the equation above.)

<h3>Lumping the mass matrix  <a name="___sec175"></a></h3>

<p>
By applying Trapezoidal integration one can turn \( M \) into a diagonal
matrix with \( (h/2,h,\ldots,h,h/2) \) on the diagonal. Then there is
no need to solve a linear system at each time level, and the finite
element scheme becomes identical to a standard finite difference method

$$
\begin{equation}
[D_t^+ u = \dfc D_xD_x u + f]^n_i
\tag{117}
\tp
\end{equation}
$$


<p>
The Trapezoidal integration is not as accurate as exact integration and
introduces therefore an error. Whether this error has a good or bad
influence on the overall numerical method is not immediately obvious,
and is analyzed in detail in the section <a href="#fem:deq:diffu:anal">Analysis of the discrete equations</a>.
The effect of the error is at least not more severe than what is
produced by the finite difference method.

<p>
Making \( M \) diagonal is usually referred to as <em>lumping the mass matrix</em>.
There is an alternative method to using an integration rule
based on the node points: one can sum the entries in each row, place
the sum on the diagonal, and set all other entries in the row equal
to zero. For P1 elements the methods of lumping the mass matrix give
the same result.

<h2>Discretization in time by a Backward Euler scheme <a name="fem:deq:diffu:BE"></a></h2>

<h3>Time discretization  <a name="___sec177"></a></h3>

<p>
The Backward Euler scheme in time applied to our diffusion problem
can be expressed as follows using the finite difference operator notation:

$$
[D_t^- u = \dfc\nabla^2 u + f(\x, t)]^n
\tp
$$

Written out, and collecting the unknown \( u^n \) on the left-hand side
and all the known terms on the right-hand side,
the time-discrete differential equation becomes

$$
\begin{equation}
\uex^{n} - \Delta t \left( \dfc\nabla^2 \uex^n + f(\x, t_{n})\right) =
\uex^{n-1}
\tag{118}
\tp
\end{equation}
$$

Equation <a href="#mjx-eqn-118">(118)</a> can compute
\( \uex^1,\uex^2,\dots,\uex^{N_t} \),
if we have a start \( \uex^0=I \) from the initial condition.
However, <a href="#mjx-eqn-118">(118)</a> is a partial differential
equation in space and needs a solution method based on discretization
in space. For this purpose we use an expansion as in
<a href="#mjx-eqn-109">(109)</a>-<a href="#mjx-eqn-110">(110)</a>.

<h3>Variational forms  <a name="___sec178"></a></h3>

<p>
Inserting <a href="#mjx-eqn-109">(109)</a>-<a href="#mjx-eqn-110">(110)</a>
in <a href="#mjx-eqn-118">(118)</a>, multiplying by \( \baspsi_i \) (or \( v\in V \)),
and integrating by parts, as we did in the Forward Euler case, results
in the variational form

$$
\begin{equation}
\int_{\Omega} \left( u^{n}v
+ \Delta t \dfc\nabla u^n\cdot\nabla v\right)\dx
= \int_{\Omega} u^{n-1}  v\dx -
\Delta t\int_{\Omega}f^n v\dx,\quad\forall v\in V
\tag{119}
\tp
\end{equation}
$$

Expressed with \( u \) as \( u^n \) and \( u_1 \) as \( u^{n-1} \), this becomes

$$
\begin{equation}
\int_{\Omega} \left( uv
+ \Delta t \dfc\nabla u\cdot\nabla v\right)\dx
= \int_{\Omega} u_1 v\dx +
\Delta t\int_{\Omega}f^n v\dx,
\tag{120}
\end{equation}
$$

or with the more compact inner product notation,

$$
\begin{equation}
(u,v) + \Delta t (\dfc\nabla u,\nabla v)
= (u_1,v) +
\Delta t (f^n,v)
\tag{121}
\tp
\end{equation}
$$

<h3>Linear systems  <a name="___sec179"></a></h3>

<p>
Inserting \( u=\sum_j c_j\baspsi_i \) and \( u_1=\sum_j c_{1,j}\baspsi_i \),
and choosing \( v \) to be the basis functions \( \baspsi_i\in V \),
\( i=0,\ldots,N \), together with doing some algebra, lead
to the following linear system to be
solved at each time level:

$$
\begin{equation}
(M + \Delta t K)c = Mc_1 + f,
\tag{122}
\end{equation}
$$

where \( M \), \( K \), and \( f \) are as in the Forward Euler case.
This time we really have to solve a linear system at each time level.
The computational algorithm goes as follows.

<ol>
<li> Compute \( M \), \( K \), and \( A=M + \Delta t K \)</li>
<li> Initialize \( u^0 \) by interpolation or projection</li>
<li> For \( n=1,2,\ldots,N_t \):</li>

<ol>
  <li> compute \( b = Mc_1 + f \)</li>
  <li> solve \( Ac = b \)</li>
  <li> set \( c_1 = c \)</li>
</ol>

</ol>

In case of finite element basis functions, interpolation of the
initial condition at the nodes means \( c_{1,j} = I(\x_j) \). Otherwise
one has to solve the linear system \( \sum_j\baspsi_j(\xno{i})c_j =
I(\xno{i}) \), where \( \x_j \) denotes an interpolation point.  Projection
(or Galerkin's method) implies solving a linear system with \( M \) as
coefficient matrix : \( \sum_j M_{i,j}c_{1,j} = (I,\baspsi_i) \),
\( i\in\If \).

<p>
We know what kind of finite difference operators the \( M \) and \( K \)
matrices correspond to (after dividing by \( h \)), so
<a href="#mjx-eqn-122">(122)</a> can be interpreted as
the following finite difference method:

$$
\begin{equation}
[D_t^-(u + \frac{1}{6}h^2D_xD_x u) = \dfc D_xD_x u + f]^n_i
\tag{123}
\tp
\end{equation}
$$


<p>
The mass matrix \( M \) can be lumped, as explained in the section <a href="#fem:deq:diffu:FE:fdvsP1fe">Comparing P1 elements with the finite difference method</a>, and then the linear system arising
from the finite element method with P1 elements corresponds
to a plain Backward Euler finite difference method for the diffusion
equation:

$$
\begin{equation}
[D_t^- u = \dfc D_xD_x u + f]^n_i
\tag{124}
\tp
\end{equation}
$$

<h2>Dirichlet boundary conditions <a name="fem:deq:diffu:Dirichlet"></a></h2>

<p>
Suppose now that the boundary condition <a href="#mjx-eqn-104">(104)</a> is
replaced by a mixed Neumann and Dirichlet condition,

$$
\begin{align}
u(\x,t) &= u_0(\x,t),\quad & \x\in\partial\Omega_D,\\ 
-\dfc\frac{\partial}{\partial n} u(\x,t) &= g(\x,t),\quad
& \x\in\partial{\Omega}_N\tp
\end{align}
$$


<p>
Using a Forward Euler discretization in time, the variational
form at a time level becomes

$$
\begin{equation}
\int_\Omega u^{n+1}v\dx =
\int_\Omega (u^n - \Delta t\dfc\nabla u^n\cdot\nabla v)\dx -
\Delta t\int_{\partial\Omega_N} gv\ds,\quad \forall v\in V\tp
\end{equation}
$$

<h3>Boundary function  <a name="___sec181"></a></h3>

<p>
The Dirichlet condition \( u=u_0 \) at \( \partial\Omega_D \) can be incorporated
through a boundary function \( B(\x)=u_0(\x) \) and demanding that \( v=0 \)
at \( \partial\Omega_D \). The expansion for \( u^n \) is written as

$$ u^n(\x) = u_0(\x,t_n) + \sum_{j\in\If}c_j^n\baspsi_j(\x)\tp$$

Inserting this expansion in the variational formulation and letting it
hold for all basis functions \( \baspsi_i \) leads to the linear system

$$
\begin{align*}
\sum_{j\in\If} \left(\int_\Omega \baspsi_i\baspsi_j\dx\right)
c^{n+1}_j &= \sum_{j\in\If}
\left(\int_\Omega\left( \baspsi_i\baspsi_j -
\Delta t\dfc\nabla \baspsi_i\cdot\nabla\baspsi_j\right)\dx\right) c_j^n - \\ 
&\quad  \int_\Omega\left( u_0(\x,t_{n+1}) - u_0(\x,t_n)
+ \Delta t\dfc\nabla u_0(\x,t_n)\cdot\nabla
\baspsi_i\right)\dx \\ 
& \quad + \Delta t\int_\Omega f\baspsi_i\dx -
\Delta t\int_{\partial\Omega_N} g\baspsi_i\ds,
\quad i\in\If\tp
\end{align*}
$$

In the following,
we adopt the convention that the unknowns \( c_j^{n+1} \) are written as
\( c_j \), while the known \( c_j^n \) from the previous time level
are denoted by \( c_{1,j} \).

<h3>Finite element basis functions  <a name="___sec182"></a></h3>

<p>
When using finite elements, each basis function \( \basphi_i \) is associated
with a node \( \xno{i} \). We have a collection of nodes
\( \{\xno{i}\}_{i\in\Ifb} \) on the boundary \( \partial\Omega_D \).
Suppose \( U_k^n \) is the known
Dirichlet value at \( \xno{k} \) at time \( t_n \) (\( U_k^n=u_0(\xno{k},t_n) \)).
The appropriate boundary function is then

$$ B(\x,t_n)=\sum_{j\in\Ifb} U_j^n\basphi_j\tp$$

The unknown coefficients \( c_j \) are associated with the rest of the nodes,
which have numbers \( \nu(i) \), \( i\in\If = \{0,\ldots,N\} \). The basis
functions for \( V \) are chosen as \( \baspsi_i = \basphi_{\nu(i)} \), \( i\in\If \),
and all of these vanish at the boundary nodes as they should.
The expansion for \( u^{n+1} \) and \( u^n \) become

$$
\begin{align*}
u^n &= \sum_{j\in\Ifb} U_j^n\basphi_j + \sum_{j\in\If}c_{1,j}\basphi_{\nu(j)},\\ 
u^{n+1} &= \sum_{j\in\Ifb} U_j^{n+1}\basphi_j +
\sum_{j\in\If}c_{j}\basphi_{\nu(j)}\tp
\end{align*}
$$

The equations for the unknown coefficients \( c_i \) become

$$
\begin{align*}
\sum_{j\in\If} \left(\int_\Omega \basphi_i\basphi_j\dx\right)
c_j &= \sum_{j\in\If}
\left(\int_\Omega\left( \basphi_i\basphi_j -
\Delta t\dfc\nabla \basphi_i\cdot\nabla\basphi_j\right)\dx\right) c_{1,j}
- \\ 
&\quad  \sum_{j\in\Ifb}\int_\Omega\left( \basphi_i\basphi_j(U_j^{n+1} - U_j^n)
+ \Delta t\dfc\nabla \basphi_i\cdot\nabla
\basphi_jU_j^n\right)\dx \\ 
&\quad + \Delta t\int_\Omega f\basphi_i\dx -
\Delta t\int_{\partial\Omega_N} g\basphi_i\ds,
\quad i\in\If\tp
\end{align*}
$$

<h3>Modification of the linear system  <a name="___sec183"></a></h3>

<p>
Instead of introducing a boundary function \( B \) we can work with
basis functions associated with all the nodes and incorporate the
Dirichlet conditions by modifying the linear system.
Let \( \If \) be the index set that counts all the nodes:
\( \{0,1,\ldots,N=N_n\} \). The
expansion for \( u^n \) is then \( \sum_{j\in\If}c^n_j\basphi_j \) and the
variational form becomes

$$
\begin{align*}
\sum_{j\in\If} \left(\int_\Omega \basphi_i\basphi_j\dx\right)
c_j &= \sum_{j\in\If}
\left(\int_\Omega\left( \basphi_i\basphi_j -
\Delta t\dfc\nabla \basphi_i\cdot\nabla\basphi_j\right)\dx\right) c_{1,j}
 \\ 
&\quad - \Delta t\int_\Omega f\basphi_i\dx -
\Delta t\int_{\partial\Omega_N} g\basphi_i\ds\tp
\end{align*}
$$

We introduce the matrices \( M \) and \( K \) with entries
\( M_{i,j}=\int_\Omega\basphi_i\basphi_j\dx \) and
\( K_{i,j}=\int_\Omega\dfc\nabla\basphi_i\cdot\nabla\basphi_j\dx \),
respectively.
In addition, we define the vectors \( c \), \( c_1 \), and \( f \) with
entries \( c_i \), \( c_{1,i} \), and
\( \int_\Omega f\basphi_i\dx - \int_{\partial\Omega_N}g\basphi_i\ds \).
The equation system can then be written as

$$
\begin{equation}
Mc = Mc_1 - \Delta t Kc_1 + \Delta t f\tp
\end{equation}
$$

When \( M \), \( K \), and \( b \) are assembled without paying attention to
Dirichlet boundary conditions, we need to replace equation \( k \)
by \( c_k=U_k \) for \( k \) corresponding to all boundary nodes (\( k\in\Ifb \)).
The modification of \( M \) consists in setting \( M_{k,j}=0 \), \( j\in\If \), and
the \( M_{k,k}=1 \). Alternatively, a modification that preserves
the symmetry of \( M \) can be applied. At each time level one forms
\( b = Mc_1 - \Delta t Kc_1 + \Delta t f \) and sets \( b_k=U^{n+1}_k \),
\( k\in\Ifb \), and solves the system \( Mc=b \).

<p>
In case of a Backward Euler method, the system becomes
<a href="#mjx-eqn-122">(122)</a>. We can write the system
as \( Ac=b \), with \( A=M + \Delta t K \) and \( b = Mc_1 + f \).
Both \( M \) and \( K \) needs to be modified because of Dirichlet
boundary conditions, but the diagonal entries in \( K \) should be
set to zero and those in \( M \) to unity. In this way, \( A_{k,k}=1 \).
The right-hand side must read \( b_k=U^n_k \) for \( k\in\Ifb \) (assuming
the unknown is sought at time level \( t_n \)).

<h2>Example: Oscillating Dirichlet boundary condition <a name="fem:deq:diffu:Dirichlet:ex"></a></h2>

<p>
We shall address the one-dimensional initial-boundary value problem

$$
\begin{align}
u_t &= (\dfc u_x)_x + f,\quad & \x\in\Omega =[0,L],\ t\in (0,T],
\tag{125} \\ 
u(x,0) &= 0,\quad & \x\in\Omega,
\tag{126}\\ 
u(0,t) &= a\sin\omega t,\quad & t\in (0,T],
\tag{127}\\ 
u_x(L,t) &= 0,\quad & t\in (0,T]\tp
\tag{128}
\end{align}
$$

A physical interpretation may be that \( u \) is the temperature
deviation from a constant mean temperature in a body \( \Omega \)
that is subject to an oscillating temperature (e.g., day and
night, or seasonal, variations) at \( x=0 \).

<p>
We use a Backward Euler scheme in time and P1 elements of
constant length \( h \) in space.
Incorporation of the Dirichlet condition at \( x=0 \) through
modifying the linear system at each time level means that we
carry out the computations as explained in the section <a href="#fem:deq:diffu:BE">Discretization in time by a Backward Euler scheme</a> and get a system <a href="#mjx-eqn-122">(122)</a>.
The \( M \) and \( K \) matrices computed without paying attention to
Dirichlet boundary conditions become

$$
\begin{align}
M &= \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)\\ 
K &= \frac{\dfc}{h}
\left(
\begin{array}{cccccccccc}
1 & -1 & 0 &\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 & \ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & -1  & 2  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 1
\end{array}
\right)
\end{align}
$$

The right-hand side of the variational form contains \( Mc_1 \) since
there is no source term (\( f \)) and no boundary term from the
integration by parts (\( u_x=0 \) at \( x=L \) and we compute as if \( u_x=0 \) at
\( x=0 \) too). We must incorporate the Dirichlet boundary
condition \( c_0=a\sin\omega t_n \) by ensuring that this is the
first equation in the linear system. To this end,
the first row in \( K \) and \( M \) are set to zero, but the diagonal
entry \( M_{0,0} \) is set to 1. The right-hand side is \( b=Mc_1 \),
and we set \( b_0 = a\sin\omega t_n \).
Note that in this
approach, \( N=N_n \), and \( c \) equals the unknown \( u \) at each node
in the mesh. We can write the complete linear system as

$$
\begin{align}
c_0 &= a\sin\omega t_n,\\ 
\frac{h}{6}(c_{i-1} + 4c_i + c_{i+1}) + \Delta t\frac{\dfc}{h}(-c_{i-1}
+2c_i + c_{i+1}) &= \frac{h}{6}(c_{1,i-1} + 4c_{1,i} + c_{1,i+1}),\\ 
&\qquad i=1,\ldots,N_n-1,\nonumber\\ 
\frac{h}{6}(c_{i-1} + 2c_i) + \Delta t\frac{\dfc}{h}(-c_{i-1}
+c_i) &= \frac{h}{6}(c_{1,i-1} + 2c_{1,i}),\quad i=N_n\tp
\end{align}
$$


<p>
The Dirichlet boundary condition can alternatively be implemented
through a boundary function \( B(x,t)=a\sin\omega t\basphi_0(x) \):

$$ u^n(x) = a\sin\omega t_n\basphi_0(x) +
\sum_{j\in\If} c_j\basphi_{\nu(j)}(x),\quad
\nu(j) = j+1\tp$$

Now, \( N=N_n-1 \) and the \( c \) vector contains values of \( u \) at nodes
\( 1,2,\ldots,N_n \). The right-hand side gets a contribution

$$
\begin{equation}
\int_0^L \left(
a(\sin\omega t_n - \sin\omega t_{n-1})\basphi_0\basphi_i
- \Delta t\dfc a\sin\omega t_n\nabla\basphi_0\cdot\nabla\basphi_i\right)\dx
\tp
\tag{129}
\end{equation}
$$

<h2>Analysis of the discrete equations <a name="fem:deq:diffu:anal"></a></h2>

<p>
The diffusion equation \( u_t = \dfc u_{xx} \) allows a (Fourier)
wave component \( u=\exp{(\beta t + ikx)} \) as solution if
\( \beta = -\dfc k^2 \), which follows from inserting the wave component
in the equation. The exact wave component can alternatively be written
as

$$
\begin{equation}
u = \Aex^n e^{ikx},\quad \Aex = e^{-\dfc k^2\Delta t}\tp
\tag{130}
\end{equation}
$$

Many numerical schemes for the diffusion equation
has a similar wave component as solution:

$$
\begin{equation}
u^n_q = A^n e^{ikx},
\tag{131}
\end{equation}
$$

where is an amplification factor to be calculated by inserting
<a href="#mjx-eqn-132">(132)</a> in the scheme.
We introduce \( x=qh \), or \( x=q\Delta x \) to align the notation with
that frequently used in finite difference methods.

<p>
A convenient start of the calculations is to establish some
results for various finite difference operators acting
on

$$
\begin{equation}
u^n_q = A^n e^{ikq\Delta x}\tp
\tag{132}
\end{equation}
$$


$$
\begin{align*}
[D_t^+ A^n e^{ikq\Delta x}]^n &= A^n e^{ikq\Delta x}\frac{A-1}{\Delta t},\\ 
[D_t^- A^n e^{ikq\Delta x}]^n &= A^n e^{ikq\Delta x}\frac{1-A^{-1}}{\Delta t},\\ 
[D_t A^n e^{ikq\Delta x}]^{n+\half} &= A^{n+\half} e^{ikq\Delta x}\frac{A^{\half}-A^{-\half}}{\Delta t} = A^ne^{ikq\Delta x}\frac{A-1}{\Delta t},\\ 
[D_xD_x A^ne^{ikq\Delta x}]_q &= -A^n \frac{4}{\Delta x^2}\sin^2\left(\frac{k\Delta x}{2}\right)\tp
\end{align*}
$$

<h3>Forward Euler discretization  <a name="___sec186"></a></h3>

<p>
We insert <a href="#mjx-eqn-132">(132)</a> in the
Forward Euler scheme with P1 elements in space and \( f=0 \) (this type of analysis
can only be carried out if \( f=0 \)),

$$
\begin{equation}
[D_t^+(u + \frac{1}{6}h^2D_xD_x u) = \dfc D_xD_x u]^n_q
\tag{133}
\tp
\end{equation}
$$

We have

$$ [D_t^+D_xD_x Ae^{ikx}]^n_q = [D_t^+A]^n [D_xD_x e^{ikx}]_q
= -A^ne^{ikp\Delta x}
\frac{A-1}{\Delta t}\frac{4}{\Delta x^2}\sin^2 (\frac{k\Delta x}{2})
\tp  $$

The term \( [D_t^+Ae^{ikx} + \frac{1}{6}\Delta x^2 D_t^+D_xD_x Ae^{ikx}]^n_q \)
then reduces to

$$ \frac{A-1}{\Delta t} - \frac{1}{6}\Delta x^2 \frac{A-1}{\Delta t}
\frac{4}{\Delta x^2}\sin^2 (\frac{k\Delta x}{2}), $$

or
$$ \frac{A-1}{\Delta t} \left(1 - \frac{2}{3}\sin^2 (k\Delta x/2)\right)
\tp  $$

Introducing \( p=k\Delta x/2 \) and \( C=\dfc\Delta t/\Delta x^2 \),
the complete scheme becomes

$$
(A-1) \left(1 - \frac{2}{3}\sin^2 p\right)
= -4C\sin^2 p,$$

from which we find \( A \) to be

$$ A = 1 - 4C\frac{\sin^2 p}{1 - \frac{2}{3}\sin^2 p}
\tp $$


<p>
How does this \( A \) change the stability criterion compared to the
Forward Euler finite difference scheme and centered differences in
space? The stability criterion is \( |A|\leq 1 \), which here implies
\( A\leq 1 \) and \( A\geq -1 \). The former is always fulfilled, while
the latter leads to

$$
4C\frac{\sin^2 p}{1 + \frac{2}{3}\sin^2 p} \leq 2\tp
$$

The factor \( \sin^2 p/(1 - \frac{2}{3}\sin^2 p) \)
can be plotted for \( p\in [0,\pi/2] \), and the maximum value goes to 3
as \( p\rightarrow \pi/2 \). The worst case for stability therefore occurs for
the shortest possible wave, \( p=\pi/2 \), and the stability criterion becomes

$$
\begin{equation}
C\leq \frac{1}{6}\quad\Rightarrow\quad \Delta t\leq \frac{\Delta x^2}{6\dfc},
\end{equation}
$$

which is a factor 1/3 worse than for the standard Forward Euler
finite difference method for the diffusion equation, which demands
\( C\leq 1/2 \).
Lumping the mass matrix will, however, recover the finite difference
method and therefore imply \( C\leq 1/2 \) for stability.

<h3>Backward Euler discretization  <a name="___sec187"></a></h3>

<p>
We can use the same approach and insert
<a href="#mjx-eqn-132">(132)</a> in the
Backward Euler scheme with P1 elements in space and \( f=0 \):

$$
\begin{equation}
[D_t^-(u + \frac{1}{6}h^2D_xD_x u) = \dfc D_xD_x u]^n_i
\tag{134}
\tp
\end{equation}
$$

Similar calculations as in the Forward Euler case lead to

$$
(1-A^{-1}) \left(1 - \frac{2}{3}\sin^2 p\right)
= -4C\sin^2 p,$$

and hence

$$
A = \left( 1 + 4C\frac{\sin^2 p}{1 - \frac{2}{3}\sin^2 p}\right)^{-1}
\tp
$$

<h3>Comparing amplification factors  <a name="___sec188"></a></h3>

<p>
It is of interest to compare \( A \) and \( \Aex \) as functions of \( p \)
for some \( C \) values. Figure
<a href="#fem:deq:diffu:fig:A:BE">48</a> display the amplification factors
for the Backward Euler scheme corresponding
a coarse mesh with \( C=2 \) and a mesh at the stability limit
of the Forward Euler scheme in the finite difference method,
\( C=1/2 \). Figures
<a href="#fem:deq:diffu:fig:A:FE2">49</a> and <a href="#fem:deq:diffu:fig:A:BE2">50</a> shows how
the accuracy increases with lower \( C \) values for both the
Forward Euler and Backward schemes, respectively.
The striking fact, however, is that the accuracy of the finite element
method is significantly less than the finite difference method for
the same value of \( C \). Lumping the mass matrix to recover the
numerical amplification factor \( A \) of the finite difference method
is therefore a good idea in this problem.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 48:  Comparison of coarse-mesh amplification factors for Backward Euler discretization of a 1D diffusion equation. <a name="fem:deq:diffu:fig:A:BE"></a> </p></center>
<p><img src="fig-fem/diffu_A_factors2_BE.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 49:  Comparison of fine-mesh amplification factors for Forward Euler discretization of a 1D diffusion equation. <a name="fem:deq:diffu:fig:A:FE2"></a> </p></center>
<p><img src="fig-fem/diffu_A_factors2_fine_FE.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 50:  Comparison of fine-mesh amplification factors for Backward Euler discretization of a 1D diffusion equation. <a name="fem:deq:diffu:fig:A:BE2"></a> </p></center>
<p><img src="fig-fem/diffu_A_factors2_fine_BE.png" align="bottom" width=600></p>
</center>

<p>
<!-- FIGURE: [fig-fem/diffu_A_factors2_FE, width=400 frac=0.8] Comparison of amplification factors for Forward Euler discretization of a 1D diffusion equation. <a name="fem:deq:diffu:fig:A:FE"></a> -->

<p>
<!-- FIGURE: [fig-fem/diffu_A_factors2_FE, width=400 frac=0.8] Comparison of amplification factors for Forward Euler discretization of a 1D diffusion equation. <a name="fem:deq:diffu:fig:A:FE"></a> -->

<p>
Remaining tasks:

<ul>
 <li> Taylor expansion of the error in the amplification factor \( \Aex - A \)</li>
 <li> Taylor expansion of the error \( e = (\Aex^n - A^n)e^{ikx} \)</li>
 <li> \( L^2 \) norm of \( e \)</li>
</ul>

<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_fem-solarized019.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_fem-solarized021.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

