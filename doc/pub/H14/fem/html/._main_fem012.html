<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to finite element methods">
<meta name="keywords" content="approximation of vectors in the plane,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,residual,variational formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements">

<title>Introduction to finite element methods</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Approximation of vectors ',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              (' Approximation of planar vectors ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' The least squares method ', 3, None, '___sec2'),
              (' The projection method ', 3, None, '___sec3'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 3, None, '___sec5'),
              (' The Galerkin or projection method ', 3, None, '___sec6'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec9'),
              (' Example: linear approximation ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Implementation of the least squares method ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Symbolic integration ', 3, None, '___sec12'),
              (' Fallback on numerical integration ', 3, None, '___sec13'),
              (' Plotting the approximation ', 3, None, '___sec14'),
              (' Perfect approximation ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Ill-conditioning ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Fourier series ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Orthogonal basis functions ',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              (' Numerical computations ', 2, None, '___sec19'),
              (' The interpolation (or collocation) method ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' Example ', 3, None, '___sec21'),
              (' Lagrange polynomials ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Approximation of a polynomial ', 3, None, '___sec23'),
              (' Successful example ', 3, None, '___sec24'),
              (' Less successful example ', 3, None, '___sec25'),
              (' Remedy for strong oscillations ', 3, None, '___sec26'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example ', 3, None, '___sec29'),
              (' The basis functions ', 2, None, '___sec30'),
              (' Construction principles ', 3, None, '___sec31'),
              (' Properties of $\\basphi_i$ ', 3, None, '___sec32'),
              (' Example on piecewise quadratic finite element functions ',
               2,
               None,
               '___sec33'),
              (' Example on piecewise linear finite element functions ',
               2,
               None,
               '___sec34'),
              (' Example on piecewise cubic finite element basis functions ',
               2,
               None,
               '___sec35'),
              (' Calculating the linear system ',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Calculating a specific matrix entry ', 3, None, '___sec37'),
              (' Calculating a general row in the matrix ',
               3,
               None,
               '___sec38'),
              (' Assembly of elementwise computations ',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Mapping to a reference element ',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Example: Integration over a reference element ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Implementation ',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              (' Integration ',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              (' Linear system assembly and solution ',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              (' Example on computing symbolic approximations ',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              (' Comparison with finite elements and interpolation/collocation ',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              (' Example on computing numerical approximations ',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' Applications ',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Finite difference approximation of given functions ',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              (' Finite difference interpretation of a finite element approximation ',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              (' Making finite elements behave as finite differences ',
               2,
               None,
               '___sec54'),
              (' Computations in physical space ', 3, None, '___sec55'),
              (' Elementwise computations ', 3, None, '___sec56'),
              (' Terminology ', 3, None, '___sec57'),
              (' A generalized element concept ',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              (' Cells, vertices, and degrees of freedom ',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              (' Extended finite element concept ',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              (' Implementation ',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              (' Computing the error of the approximation ',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              (' Example: Cubic Hermite polynomials ',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              (' Numerical integration ', 1, None, '___sec64'),
              (' Newton-Cotes rules ',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              (' Gauss-Legendre rules with optimized points ',
               2,
               None,
               '___sec66'),
              (' Approximation of functions in 2D ',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              (' 2D basis functions as tensor products of 1D functions ',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              (' Example: Polynomial basis in 2D ', 2, None, '___sec69'),
              (' Implementation ',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              (' Extension to 3D ',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              (' Finite elements in 2D and 3D ', 1, None, '___sec72'),
              (' Basis functions over triangles in the physical domain ',
               2,
               None,
               '___sec73'),
              (' Element matrices and vectors ', 3, None, '___sec74'),
              (' Basis functions over triangles in the reference cell ',
               2,
               None,
               '___sec75'),
              (' Affine mapping of the reference cell ', 2, None, '___sec76'),
              (' Isoparametric mapping of the reference cell ',
               2,
               None,
               '___sec77'),
              (' Computing integrals ', 2, None, '___sec78'),
              (' Exercises ', 1, None, '___sec79'),
              (' Exercise 1: Linear algebra refresher I ',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              (' Exercise 2: Linear algebra refresher II ',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              (' Exercise 3: Approximate a three-dimensional vector in a plane ',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              (' Exercise 4: Approximate the exponential function by power functions ',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              (' Exercise 5: Approximate the sine function by power functions ',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              (' Exercise 6: Approximate a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              (' Remarks ', 3, None, '___sec86'),
              (' Exercise 7: Animate the approximation of a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine2',
               'fem:approx:exer:tanh:sine2'),
              (' Exercise 8: Fourier series as a least squares approximation ',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              (' Exercise 9: Approximate a steep function by Lagrange polynomials ',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              (' Exercise 10: Define nodes and elements ',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              (' Exercise 11: Define vertices, cells, and dof maps ',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              (' Exercise 12: Construct matrix sparsity patterns ',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              (' Exercise 13: Perform symbolic finite element computations ',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              (' Exercise 14: Approximate a steep function by P1 and P2 elements ',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              (' Exercise 15: Approximate a steep function by P3 and P4 elements ',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              (' Exercise 16: Investigate the approximation error in finite elements ',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              (' Exercise 17: Approximate a step function by finite elements ',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              (' Exercise 18: 2D approximation with orthogonal functions ',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              (' Exercise 19: Use the Trapezoidal rule and P1 elements ',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              (' Problem 20: Compare P1 elements and interpolation ',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              (' Exercise 21: Implement 3D computations with global basis functions ',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              (" Exercise 22: Use Simpson's rule and P2 elements ",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              (' Basic principles for approximating differential equations ',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              (' Differential equation models ',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              (' Simple model problems ',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              (' Forming the residual ',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              (' The least squares method ', 2, None, '___sec107'),
              (' The Galerkin method ', 2, None, '___sec108'),
              (' The Method of Weighted Residuals ', 2, None, '___sec109'),
              (' Test and Trial Functions ', 2, None, '___sec110'),
              (' The collocation method ', 2, None, '___sec111'),
              (' The subdomain collocation method ', 3, None, '___sec112'),
              (' Examples on using the principles ',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              (' The model problem ', 3, None, '___sec114'),
              (' Basis functions ', 3, None, '___sec115'),
              (' The residual ', 3, None, '___sec116'),
              (' The least squares method ', 3, None, '___sec117'),
              (' The Galerkin method ', 3, None, '___sec118'),
              (' The collocation method ', 3, None, '___sec119'),
              (' Comparison ', 3, None, '___sec120'),
              (' Integration by parts ',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              (' Weak form ', 3, None, '___sec122'),
              (' Boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Abstract notation for variational formulations ',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              (' Variational problems and optimization of functionals ',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              (' Examples on variational formulations ',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              (' Variable coefficient ', 2, None, '___sec127'),
              (' First-order derivative in the equation and boundary condition ',
               2,
               None,
               '___sec128'),
              (' Nonlinear coefficient ', 2, None, '___sec129'),
              (' Computing with Dirichlet and Neumann conditions ',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              (' When the numerical method is exact ', 2, None, '___sec131'),
              (' Computing with finite elements ',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              (' Finite element mesh and basis functions ',
               2,
               None,
               '___sec133'),
              (' Computation in the global physical domain ',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              (' Comparison with a finite difference discretization ',
               2,
               None,
               '___sec135'),
              (' Cellwise computations ',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              (' The integral for the element matrix ', 3, None, '___sec137'),
              (' The integral for the element vector ', 3, None, '___sec138'),
              (' Detailed calculations of the element matrix and vector ',
               3,
               None,
               '___sec139'),
              (' Contributions from the first and last cell ',
               3,
               None,
               '___sec140'),
              (' Assembly ', 3, None, '___sec141'),
              (' Boundary conditions: specified nonzero value ',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              (' General construction of a boundary function ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              (' Example on computing with finite element-based a boundary function ',
               2,
               None,
               '___sec144'),
              (' Computations in physical coordinates ',
               3,
               None,
               '___sec145'),
              (' Cellwise computations on the reference element ',
               3,
               None,
               '___sec146'),
              (' Modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (' Computations in the physical system ', 3, None, '___sec148'),
              (' Symmetric modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (' Modification of the element matrix and vector ',
               2,
               None,
               '___sec150'),
              (' Boundary conditions: specified derivative ',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              (' The variational formulation ', 2, None, '___sec152'),
              (' Boundary term vanishes because of the test functions ',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              (' Boundary term vanishes because of linear system modifications ',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              (' Direct computation of the global linear system ',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              (' Cellwise computations ', 2, None, '___sec156'),
              (' Implementation ',
               1,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              (' Global basis functions ', 2, None, '___sec158'),
              (' Example: constant right-hand side ', 2, None, '___sec159'),
              (' Finite elements ', 2, None, '___sec160'),
              (' Variational formulations in 2D and 3D ',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              (' Transformation to a reference cell in 2D and 3D ',
               2,
               None,
               '___sec162'),
              (' Numerical integration ', 2, None, '___sec163'),
              (' Convenient formulas for P1 elements in 2D ',
               2,
               None,
               '___sec164'),
              (' Summary ', 1, None, '___sec165'),
              (' Time-dependent problems ',
               1,
               'fem:deq:timedep',
               'fem:deq:timedep'),
              (' Discretization in time by a Forward Euler scheme ',
               2,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              (' Time discretization ', 3, None, '___sec168'),
              (' Space discretization ', 3, None, '___sec169'),
              (' Variational forms ', 2, None, '___sec170'),
              (' Simplified notation for the solution at recent time levels ',
               2,
               None,
               '___sec171'),
              (' Deriving the linear systems ', 2, None, '___sec172'),
              (' Computational algorithm ', 2, None, '___sec173'),
              (' Comparing P1 elements with the finite difference method ',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              (' Lumping the mass matrix ', 3, None, '___sec175'),
              (' Discretization in time by a Backward Euler scheme ',
               2,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              (' Time discretization ', 3, None, '___sec177'),
              (' Variational forms ', 3, None, '___sec178'),
              (' Linear systems ', 3, None, '___sec179'),
              (' Dirichlet boundary conditions ',
               2,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              (' Boundary function ', 3, None, '___sec181'),
              (' Finite element basis functions ', 3, None, '___sec182'),
              (' Modification of the linear system ', 3, None, '___sec183'),
              (' Example: Oscillating Dirichlet boundary condition ',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              (' Analysis of the discrete equations ',
               2,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              (' Forward Euler discretization ', 3, None, '___sec186'),
              (' Backward Euler discretization ', 3, None, '___sec187'),
              (' Comparing amplification factors ', 3, None, '___sec188'),
              (' Systems of differential equations ',
               1,
               'fem:sys',
               'fem:sys'),
              (' Variational forms ', 2, 'fem:sys:vform', 'fem:sys:vform'),
              (' A worked example ', 2, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              (' Identical function spaces for the unknowns ',
               2,
               None,
               '___sec192'),
              (' Variational form of each individual PDE ',
               3,
               None,
               '___sec193'),
              (' Compound scalar variational form ', 3, None, '___sec194'),
              (' Decoupled linear systems ', 3, None, '___sec195'),
              (' Coupled linear systems ', 3, None, '___sec196'),
              (' Different function spaces for the unknowns ',
               2,
               None,
               '___sec197'),
              (' Computations in 1D ', 2, None, '___sec198'),
              (' Exercises ', 1, None, '___sec199'),
              (' Exercise 23: Refactor functions into a more general class ',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              (' Exercise 24: Compute the deflection of a cable with sine functions ',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              (' Exercise 25: Check integration by parts ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 26: Compute the deflection of a cable with 2 P1 elements ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 27: Compute the deflection of a cable with 1 P2 element ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 28: Compute the deflection of a cable with a step load ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 29: Show equivalence between linear systems ',
               2,
               'fem:deq:exer:Aub:essbc:equiv',
               'fem:deq:exer:Aub:essbc:equiv'),
              (' Exercise 30: Compute with a non-uniform mesh ',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              (' Problem 31: Solve a 1D finite element problem by hand ',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              (' Exercise 32: Compare finite elements and differences for a radially symmetric Poisson equation ',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              (' Exercise 33: Compute with variable coefficients and P1 elements by hand ',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              (' Exercise 34: Solve a 2D Poisson equation using polynomials and sines ',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              (' Exercise 35: Analyze a Crank-Nicolson scheme for the diffusion equation ',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              (' Bibliography ', 1, None, '___sec213')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="main_fem.html">Introduction to finite element methods</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0012"></a>
<!-- !split -->
<!-- 2DO -->
<!-- Must illustrate how to make weak form of continuous problem and -->
<!-- discretize. Do that in time-dependent problems too. -->

<p>
<!-- Maybe <,> \langle, \rangle as inner product -->

<p>
<!-- Must say something about error estimates! -->

<p>
<!-- no (au')', have (\alpha u')' - it solves all the problems with a and a(.,.) -->

<h1 id="fem:deq:1D:principles">Basic principles for approximating differential equations<a name="fem:deq:1D:principles"></a></h1>

<p>
The finite element method is a very flexible approach for solving partial
differential equations. Its two most attractive features are the ease
of handling domains of complex shape in two and three dimensions and
the ease of constructing higher-order discretization methods. The
finite element method is usually applied for discretization in space,
and therefore spatial problems will be our focus in the coming sections.
Extensions to time-dependent problems may, for instance, use finite difference
approximations in time.

<p>
Before studying how finite element methods are used to tackle differential
equation, we first look at how global basis functions and the
least squares, Galerkin, and collocation principles can be used to solve
differential equations.

<h2 id="fem:deq:1D:models">Differential equation models<a name="fem:deq:1D:models"></a></h2>

<p>
Let us consider an abstract differential equation for a function \( u(x) \) of
one variable, written as

$$
\begin{equation}
\mathcal{L}(u) = 0,\quad x\in\Omega\tp  \end{equation}
$$

Here are a few examples on possible choices of \( \mathcal{L}(u) \), of
increasing complexity:

$$
\begin{align}
\mathcal{L}(u) &= \frac{d^2u}{dx^2} - f(x),
\tag{47}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(x)\frac{du}{dx}\right) + f(x),
\tag{48}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(u)\frac{du}{dx}\right) - au + f(x),
\tag{49}\\ 
\mathcal{L}(u) &= \frac{d}{dx}\left(\dfc(u)\frac{du}{dx}\right) + f(u,x)
\tag{50}
\tp
\end{align}
$$

Both \( \dfc(x) \) and \( f(x) \) are considered as specified functions,
while \( a \) is a prescribed parameter.  Differential equations
corresponding to <a href="#mjx-eqn-47">(47)</a>-<a href="#mjx-eqn-48">(48)</a> arise in
diffusion phenomena, such as steady transport of heat in solids and
flow of viscous fluids between flat plates. The form
<a href="#mjx-eqn-49">(49)</a> arises when transient diffusion or wave
phenomenon are discretized in time by finite differences. The equation
<a href="#mjx-eqn-50">(50)</a> appear in chemical models when diffusion of a
substance is combined with chemical reactions. Also in biology,
<a href="#mjx-eqn-50">(50)</a> plays an important role, both for spreading of
species and in models involving generation and
propagation of electrical signals.

<p>
Let \( \Omega =[0,L] \) be the domain in one space dimension.
In addition to the differential equation, \( u \) must fulfill
boundary conditions at the boundaries of the domain, \( x=0 \) and \( x=L \).
When \( \mathcal{L} \) contains up to second-order derivatives, as in the
examples above, \( m=1 \), we need one boundary condition at each of
the (two) boundary points, here abstractly specified as

$$
\begin{equation}
\mathcal{B}_0(u)=0,\ x=0,\quad \mathcal{B}_1(u)=0,\ x=L
\end{equation}
$$


<p>
There are three common choices of boundary conditions:

$$
\begin{align}
\mathcal{B}_i(u) &= u - g,\quad &\hbox{Dirichlet condition}\\ 
\mathcal{B}_i(u) &= -\dfc \frac{du}{dx} - g,\quad &\hbox{Neumann condition}\\ 
\mathcal{B}_i(u) &= -\dfc \frac{du}{dx} - h(u-g),\quad &\hbox{Robin condition}
\end{align}
$$

Here, \( g \) and \( a \) are specified quantities.

<p>
From now on we shall use \( \uex(x) \) as symbol for the <em>exact</em> solution,
fulfilling

$$
\begin{equation}
\mathcal{L}(\uex)=0,\quad x\in\Omega,
\end{equation}
$$

while \( u(x) \) is our notation for an <em>approximate</em> solution of the differential
equation.

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Remark on notation.</b>
In the literature about the finite element method,
is common to use \( u \) as the exact solution and \( u_h \) as the
approximate solution, where \( h \) is a discretization parameter. However,
the vast part of the present text is about the approximate solutions,
and having a subscript \( h \) attached all the time
is cumbersome. Of equal importance is the close correspondence between
implementation and mathematics that we strive to achieve in this text:
when it is natural to use <code>u</code> and not <code>u_h</code> in
code, we let the mathematical notation be dictated by the code's
preferred notation. After all, it is the powerful computer implementations
of the finite element method that justifies studying the mathematical
formulation and aspects of the method.
</div>


<h2 id="fem:deq:1D:models:simple">Simple model problems<a name="fem:deq:1D:models:simple"></a></h2>

<p>
A common model problem used much in the forthcoming examples is

$$
\begin{equation}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=D
\tp
\tag{51}
\end{equation}
$$

A closely related problem with a different boundary condition at
\( x=0 \) reads

$$
\begin{equation}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u'(0)=C,\ u(L)=D\tp
\tag{52}
\end{equation}
$$

A third variant has a variable coefficient,

$$
\begin{equation}
-(\dfc(x)u'(x))' = f(x),\quad x\in\Omega=[0,L],\quad u'(0)=C,\ u(L)=D\tp
\tag{53}
\end{equation}
$$


<p>
We can easily solve these using <code>sympy</code>. For <a href="#mjx-eqn-51">(51)</a>
we can write the function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">model1</span>(f, L, D):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Solve -u&#39;&#39; = f(x), u(0)=0, u(L)=D.&quot;&quot;&quot;</span>
    u_x <span style="color: #666666">=</span> <span style="color: #666666">-</span> sp<span style="color: #666666">.</span>integrate(f, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_0
    u <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>integrate(u_x, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_1
    r <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>solve([u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)<span style="color: #666666">-0</span>, u<span style="color: #666666">.</span>subs(x,L)<span style="color: #666666">-</span>D], [c_0, c_1])
    u <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(c_0, r[c_0])<span style="color: #666666">.</span>subs(c_1, r[c_1])
    u <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>simplify(sp<span style="color: #666666">.</span>expand(u))
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
Calling <code>model1(2, L, D)</code> results in the solution

$$
\begin{equation}
u(x) = \frac{1}{L}x \left(D + L^{2} - L x\right)
\tag{54}
\end{equation}
$$

Model <a href="#mjx-eqn-52">(52)</a> can be solved by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">model2</span>(f, L, C, D):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Solve -u&#39;&#39; = f(x), u&#39;(0)=C, u(L)=D.&quot;&quot;&quot;</span>
    u_x <span style="color: #666666">=</span> <span style="color: #666666">-</span> sp<span style="color: #666666">.</span>integrate(f, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_0
    u <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>integrate(u_x, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_1
    r <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>solve([sp<span style="color: #666666">.</span>diff(u,x)<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)<span style="color: #666666">-</span>C, u<span style="color: #666666">.</span>subs(x,L)<span style="color: #666666">-</span>D], [c_0, c_1])
    u <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(c_0, r[c_0])<span style="color: #666666">.</span>subs(c_1, r[c_1])
    u <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>simplify(sp<span style="color: #666666">.</span>expand(u))
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
to yield

$$
\begin{equation}
u(x) = - x^{2} + C x - C L + D + L^{2},
\tag{55}
\end{equation}
$$

if \( f(x)=2 \). Model <a href="#mjx-eqn-53">(53)</a> requires a bit more involved
code,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">model3</span>(f, a, L, C, D):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Solve -(a*u&#39;)&#39; = f(x), u(0)=C, u(L)=D.&quot;&quot;&quot;</span>
    au_x <span style="color: #666666">=</span> <span style="color: #666666">-</span> sp<span style="color: #666666">.</span>integrate(f, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_0
    u <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>integrate(au_x<span style="color: #666666">/</span>a, (x, <span style="color: #666666">0</span>, x)) <span style="color: #666666">+</span> c_1
    r <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>solve([u<span style="color: #666666">.</span>subs(x, <span style="color: #666666">0</span>)<span style="color: #666666">-</span>C, u<span style="color: #666666">.</span>subs(x,L)<span style="color: #666666">-</span>D], [c_0, c_1])
    u <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(c_0, r[c_0])<span style="color: #666666">.</span>subs(c_1, r[c_1])
    u <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>simplify(sp<span style="color: #666666">.</span>expand(u))
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
With \( f(x)=0 \) and \( \dfc(x)=1+x^2 \) we get

$$ u(x) =
\frac{C \operatorname{atan}{\left (L \right )} - C \operatorname{atan}{\left (x \right )} + D \operatorname{atan}{\left (x \right )}}{\operatorname{atan}{\left (L \right )}}
$$

<h2 id="fem:deq:1D:residual:min">Forming the residual<a name="fem:deq:1D:residual:min"></a></h2>

<p>
The fundamental idea is to seek an approximate solution
\( u \) in some space \( V \),

$$
\begin{equation*}
V = \hbox{span}\{ \baspsi_0(x),\ldots,\baspsi_N(x)\},
\end{equation*}
$$

which means that \( u \) can always be expressed as a linear combination
of the basis functions \( \sequencei{\basphi} \), with \( \If \) as
the index set \( \{0,\ldots,N\} \):

$$
\begin{equation*} u(x) = \sum_{j\in\If} c_j\baspsi_j(x)\tp\end{equation*}
$$

The coefficients \( \sequencei{c} \) are unknowns to be computed.

<p>
(Later, in the section <a href="._main_fem015.html#fem:deq:1D:essBC">Boundary conditions: specified nonzero value</a>, we will see that if we specify boundary values of \( u \) different
from zero, we must look for an approximate solution
\( u(x) = B(x) + \sum_{j} c_j\baspsi_j(x) \),
where \( \sum_{j}c_j\baspsi_j\in V \) and \( B(x) \) is some function for
incorporating the right boundary values. Because of \( B(x) \), \( u \) will not
necessarily lie in \( V \). This modification does not imply any difficulties.)

<p>
We need principles for deriving \( N+1 \) equations to determine the
\( N+1 \) unknowns \( \sequencei{c} \).
When approximating a given function \( f \) by \( u=\sum_jc_j\basphi_j \),
a key idea is to minimize the square norm of the
approximation error \( e=u-f \) or (equivalently) demand that \( e \) is
orthogonal to \( V \). Working with \( e \) is not so useful here since
the approximation error in our case is \( e=\uex - u \) and \( \uex \) is
unknown. The only general indicator we have on the quality of the approximate
solution is to what degree \( u \) fulfills the differential equation.
Inserting \( u=\sum_j c_j \baspsi_j \) into \( \mathcal{L}(u) \) reveals that the
result is not zero, because \( u \) is only likely to equal \( \uex \).
The nonzero result,

$$
\begin{equation}
R = \mathcal{L}(u) = \mathcal{L}(\sum_j c_j \baspsi_j),
\end{equation}
$$

is called the <em>residual</em> and measures the
error in fulfilling the governing equation.

<p>
Various principles for determining \( \sequencei{c} \) try to minimize
\( R \) in some sense. Note that \( R \) varies with \( x \) and
the \( \sequencei{c} \) parameters. We may write this dependence
explicitly as

$$
\begin{equation}
R = R(x; c_0, \ldots, c_N)\tp  \end{equation}
$$

Below, we present three principles for making \( R \) small:
a least squares method, a projection or Galerkin method, and
a collocation or interpolation method.

<h2 id="___sec107">The least squares method <a name="___sec107"></a></h2>

<p>
The least-squares method aims to find \( \sequencei{c} \) such that
the square norm of the residual

$$
\begin{equation}
||R|| = (R, R) = \int_{\Omega} R^2 \dx
\end{equation}
$$

is minimized. By introducing
an inner product of two functions \( f \) and \( g \)
on \( \Omega \) as

$$
\begin{equation}
(f,g) = \int_{\Omega} f(x)g(x) \dx,
\end{equation}
$$

the least-squares method can be defined as

$$
\begin{equation}
\min_{c_0,\ldots,c_N} E = (R,R)\tp  \end{equation}
$$

Differentiating with respect to the free parameters \( \sequencei{c} \)
gives the \( N+1 \) equations

$$
\begin{equation}
\int_{\Omega} 2R\frac{\partial R}{\partial c_i} \dx = 0\quad
\Leftrightarrow\quad (R,\frac{\partial R}{\partial c_i})=0,\quad
i\in\If\tp
\tag{56}
\end{equation}
$$

<h2 id="___sec108">The Galerkin method <a name="___sec108"></a></h2>

<p>
The least-squares
principle is equivalent to demanding the error to be orthogonal to
the space \( V \) when approximating a function \( f \) by \( u\in V \).
With a differential equation
we do not know the true error so we must instead require the residual \( R \)
to be orthogonal to \( V \). This idea implies
seeking \( \sequencei{c} \) such that

$$
\begin{equation}
(R,v)=0,\quad \forall v\in V\tp
\tag{57}
\end{equation}
$$

This is the Galerkin method for differential equations.

<p>
<!-- As shown in <a href="._main_fem002.html#mjx-eqn-12">(12)</a> and <a href="._main_fem002.html#mjx-eqn-13">(13)</a>, -->
This statement is equivalent to \( R \) being orthogonal to the \( N+1 \)
basis functions only:

$$
\begin{equation}
(R,\baspsi_i)=0,\quad i\in\If,
\tag{58}
\end{equation}
$$

resulting in \( N+1 \) equations for determining \( \sequencei{c} \).

<h2 id="___sec109">The Method of Weighted Residuals <a name="___sec109"></a></h2>

<p>
A generalization of the Galerkin method is to demand that \( R \)
is orthogonal to some space \( W \), but not necessarily the same
space as \( V \) where we seek the unknown function.
This generalization is naturally called the <em>method of weighted residuals</em>:

$$
\begin{equation}
(R,v)=0,\quad \forall v\in W\tp
\tag{59}
\end{equation}
$$

If \( \{w_0,\ldots,w_N\} \) is a basis for \( W \), we can equivalently
express the method of weighted residuals as

$$
\begin{equation}
(R,w_i)=0,\quad i\in\If\tp
\tag{60}
\end{equation}
$$

The result is \( N+1 \) equations for \( \sequencei{c} \).

<p>
The least-squares method can also be viewed as a weighted residual
method with \( w_i = \partial R/\partial c_i \).

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Variational formulation of the continuous problem.</b>
Formulations like <a href="#mjx-eqn-59">(59)</a> (or
<a href="#mjx-eqn-60">(60)</a>) and <a href="#mjx-eqn-57">(57)</a>
(or <a href="#mjx-eqn-58">(58)</a>) are known as
<em>variational formulations</em>.
These equations are in this text primarily used for a numerical approximation
\( u\in V \), where \( V \) is a <em>finite-dimensional</em> space with dimension
\( N+1 \). However, we may also let \( V \) be an <em>infinite-dimensional</em> space
containing the exact solution \( \uex(x) \) such that also \( \uex \)
fulfills the same variational formulation. The variational formulation is in
that case a mathematical way of stating the problem and acts as an
alternative to the usual formulation of a differential equation with
initial and/or boundary conditions.
</div>


<h2 id="___sec110">Test and Trial Functions <a name="___sec110"></a></h2>

<p>
In the context of the Galerkin method and the method of weighted residuals it is
common to use the name <em>trial function</em> for the approximate \( u =
\sum_j c_j \baspsi_j \).
<!-- Sometimes the functions that spans the space where \( u \) lies are also called -->
<!-- trial functions. -->
The space containing the trial function is known as the <em>trial space</em>.
The function \( v \) entering the orthogonality requirement in
the Galerkin method and the method of weighted residuals is called
<em>test function</em>, and so are the \( \baspsi_i \) or \( w_i \) functions that are
used as weights in the inner products with the residual.  The space
where the test functions comes from is naturally called the
<em>test space</em>.

<p>
We see that in the method of weighted residuals the test and trial spaces
are different and so are the test and trial functions.
In the Galerkin method the test and trial spaces are the same (so far).
<!-- Later in the section <a href="._main_fem015.html#fem:deq:1D:essBC">Boundary conditions: specified nonzero value</a> we shall see that boundary -->
<!-- conditions may lead to a difference between the test and trial spaces -->
<!-- in the Galerkin method. -->

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark.</b>
It may be subject to debate whether
it is only the form of <a href="#mjx-eqn-59">(59)</a> or <a href="#mjx-eqn-57">(57)</a>
after integration by parts, as explained in the section <a href="#fem:deq:1D:varform">Integration by parts</a>,
that qualifies for the term variational formulation. The result after
integration by parts is what is obtained after taking the <em>first
variation</em> of an optimization problem, see the section <a href="#fem:deq:1D:optimization">Variational problems and optimization of functionals</a>. However, here we use variational formulation as a common term for
formulations which, in contrast to the differential equation \( R=0 \),
instead demand that an average of \( R \) is zero: \( (R,v)=0 \) for all \( v \) in some space.
</div>


<h2 id="___sec111">The collocation method <a name="___sec111"></a></h2>

<p>
The idea of the collocation method is to demand that \( R \) vanishes
at \( N+1 \) selected points \( \xno{0},\ldots,\xno{N} \) in \( \Omega \):

$$
\begin{equation}
R(\xno{i}; c_0,\ldots,c_N)=0,\quad i\in\If\tp
\tag{61}
\end{equation}
$$

The collocation method can also be viewed as a method of weighted residuals
with Dirac delta functions as weighting functions.
Let \( \delta (x-\xno{i}) \) be the Dirac delta function centered around
\( x=\xno{i} \) with the properties that \( \delta (x-\xno{i})=0 \) for \( x\neq \xno{i} \)
and

$$
\begin{equation}
\int_{\Omega} f(x)\delta (x-\xno{i}) \dx =
f(\xno{i}),\quad \xno{i}\in\Omega\tp
\tag{62}
\end{equation}
$$

Intuitively, we may think of \( \delta (x-\xno{i}) \) as a very peak-shaped
function around \( x=\xno{i} \) with integral 1, roughly visualized
in Figure <a href="#fem:deq:1D:fig:Dirac">46</a>.
Because of <a href="#mjx-eqn-62">(62)</a>, we can let \( w_i=\delta(x-\xno{i}) \)
be weighting functions in the method of weighted residuals,
and <a href="#mjx-eqn-60">(60)</a> becomes equivalent to
<a href="#mjx-eqn-61">(61)</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 46:  Approximation of delta functions by narrow Gaussian functions. <a name="fem:deq:1D:fig:Dirac"></a> </p></center>
<p><img src="fig-fem/delta_func_weight.png" align="bottom" width=400></p>
</center>

<h3 id="___sec112">The subdomain collocation method <a name="___sec112"></a></h3>

<p>
The idea of this approach is to demand the integral of \( R \) to vanish
over \( N+1 \) subdomains \( \Omega_i \) of \( \Omega \):

$$
\begin{equation}
\int_{\Omega_i} R\, \dx=0,\quad i\in\If\tp  \end{equation}
$$

This statement can also be expressed as a weighted residual method

$$
\begin{equation}
\int_{\Omega} Rw_i\, \dx=0,\quad i\in\If, \end{equation}
$$

where \( w_i=1 \) for \( x\in\Omega_i \) and \( w_i=0 \) otherwise.

<h2 id="fem:deq:1D:ex:sines">Examples on using the principles<a name="fem:deq:1D:ex:sines"></a></h2>

<p>
Let us now apply global basis functions to illustrate the principles
for minimizing \( R \).

<h3 id="___sec114">The model problem <a name="___sec114"></a></h3>

<p>
We consider the differential equation problem

$$
\begin{equation}
-u''(x) = f(x),\quad x\in\Omega=[0,L],\quad u(0)=0,\ u(L)=0
\tp
\tag{63}
\end{equation}
$$

<h3 id="___sec115">Basis functions <a name="___sec115"></a></h3>

<p>
Our choice of basis functions \( \baspsi_i \)
for \( V \) is

$$
\begin{equation}
\baspsi_i(x) = \sinL{i},\quad i\in\If\tp
\tag{64}
\end{equation}
$$


<p>
An important property of these functions is that \( \baspsi_i(0)=\baspsi_i(L)=0 \),
which means that the boundary conditions on \( u \) are fulfilled:

$$ u(0) = \sum_jc_j\baspsi_j(0) = 0,\quad u(L) = \sum_jc_j\baspsi_j(L) =0
\tp $$

Another nice property is that the chosen sine functions
are orthogonal on \( \Omega \):

$$
\begin{equation}
\int\limits_0^L \sinL{i}\sinL{j}\, \dx = \left\lbrace
\begin{array}{ll} \half L & i=j  \\ 0, & i\neq j
\end{array}\right.
\end{equation}
$$

provided \( i \) and \( j \) are integers.

<p>
<!-- Sympy can do this! -->
<!-- k, m, n = symbols('k m n', integer=True) -->
<!-- >>> integrate(sin(k*x)*sin(m*x), (x, 0, 2*pi)) -->
<!-- 0 -->
<!-- >>>integrate(sin(k*x)*sin(k*x), (x, 0, 2*pi)) -->
<!-- pi -->

<h3 id="___sec116">The residual <a name="___sec116"></a></h3>

<p>
We can readily calculate the following explicit expression for the
residual:

$$
\begin{align}
R(x;c_0, \ldots, c_N) &= u''(x) + f(x),\nonumber\\ 
&= \frac{d^2}{dx^2}\left(\sum_{j\in\If} c_j\baspsi_j(x)\right)
+ f(x),\nonumber\\ 
&= \sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\tp
\tag{65}
\end{align}
$$

<h3 id="___sec117">The least squares method <a name="___sec117"></a></h3>

<p>
The equations <a href="#mjx-eqn-56">(56)</a>
in the least squares method require an expression for
\( \partial R/\partial c_i \). We have

$$
\begin{equation}
\frac{\partial R}{\partial c_i} =
\frac{\partial}{\partial c_i}
\left(\sum_{j\in\If} c_j\baspsi_j''(x) + f(x)\right)
= \sum_{j\in\If} \frac{\partial c_j}{\partial c_i}\baspsi_j''(x)
= \baspsi_i''(x)\tp  \end{equation}
$$

The governing equations for \( \sequencei{c} \) are then

$$
\begin{equation}
(\sum_j c_j \baspsi_j'' + f,\baspsi_i'')=0,\quad i\in\If,
\end{equation}
$$

which can be rearranged as

$$
\begin{equation}
\sum_{j\in\If}(\baspsi_i'',\baspsi_j'')c_j = -(f,\baspsi_i''),\quad i\in\If\tp
\end{equation}
$$

This is nothing but a linear system

$$
\begin{equation*} \sum_{j\in\If}A_{i,j}c_j = b_i,\quad i\in\If,
\end{equation*}
$$

with

$$
\begin{align}
A_{i,j} &= (\baspsi_i'',\baspsi_j'')\nonumber\\ 
& = \pi^4(i+1)^2(j+1)^2L^{-4}\int_0^L \sinL{i}\sinL{j}\, \dx\nonumber\\ 
&= \left\lbrace
\begin{array}{ll} {1\over2}L^{-3}\pi^4(i+1)^4 & i=j  \\ 0, & i\neq j
\end{array}\right.
\\ 
b_i &= -(f,\baspsi_i'') = (i+1)^2\pi^2L^{-2}\int_0^Lf(x)\sinL{i}\, \dx
\end{align}
$$

Since the coefficient matrix is diagonal we can easily solve for

$$
\begin{equation}
c_i = \frac{2L}{\pi^2(i+1)^2}\int_0^Lf(x)\sinL{i}\, \dx\tp
\tag{66}
\end{equation}
$$

With the special choice of \( f(x)=2 \) can be calculated in <code>sympy</code> by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>

i, j <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;i j&#39;</span>, integer<span style="color: #666666">=</span><span style="color: #008000">True</span>)
x, L <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;x L&#39;</span>)
f <span style="color: #666666">=</span> <span style="color: #666666">2</span>
a <span style="color: #666666">=</span> <span style="color: #666666">2*</span>L<span style="color: #666666">/</span>(pi<span style="color: #666666">**2*</span>(i<span style="color: #666666">+1</span>)<span style="color: #666666">**2</span>)
c_i <span style="color: #666666">=</span> a<span style="color: #666666">*</span>integrate(f<span style="color: #666666">*</span>sin((i<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/</span>L), (x, <span style="color: #666666">0</span>, L))
c_i <span style="color: #666666">=</span> simplify(c_i)
<span style="color: #008000; font-weight: bold">print</span> c_i
</pre></div>
<p>
The answer becomes

$$
\begin{equation*}
c_i = 4 \frac{L^{2} \left(\left(-1\right)^{i} + 1\right)}{\pi^{3}
\left(i^{3} + 3 i^{2} + 3 i + 1\right)}
\end{equation*}
$$

Now, \( 1+(-1)^i=0 \) for \( i \) odd, so only the coefficients with even index
are nonzero. Introducing \( i=2k \) for \( k=0,\ldots,N/2 \) to count the
relevant indices (for \( N \) odd, \( k \) goes to \( (N-1)/2 \)), we get the solution

$$
\begin{equation}
u(x) = \sum_{k=0}^{N/2} \frac{8L^2}{\pi^3(2k+1)^3}\sinL{2k}\tp  \end{equation}
$$

The coefficients decay very fast: \( c_2 = c_0/27 \), \( c_4=c_0/125 \).
The solution will therefore be dominated by the first term,

$$
\begin{equation*} u(x) \approx \frac{8L^2}{\pi^3}\sin\left(\pi\frac{x}{L}\right)\tp  \end{equation*}
$$

<h3 id="___sec118">The Galerkin method <a name="___sec118"></a></h3>

<p>
The Galerkin principle <a href="#mjx-eqn-57">(57)</a>
applied to <a href="#mjx-eqn-63">(63)</a> consists of inserting
our special residual <a href="#mjx-eqn-65">(65)</a> in
<a href="#mjx-eqn-57">(57)</a>

$$
\begin{equation*}
(u''+f,v)=0,\quad \forall v\in V,
\end{equation*}
$$

or

$$
\begin{equation}
(u'',v) = -(f,v),\quad\forall v\in V\tp  \end{equation}
$$

This is the variational formulation, based on the Galerkin principle,
of our differential equation.
The \( \forall v\in V \) requirement is equivalent to
demanding the equation \( (u'',v) = -(f,v) \) to be fulfilled for all
basis functions \( v=\baspsi_i \), \( i\in\If \), see
<a href="#mjx-eqn-57">(57)</a> and <a href="#mjx-eqn-58">(58)</a>.
We therefore have

$$
\begin{equation}
(\sum_{j\in\If} c_j\baspsi_j'', \baspsi_i)=-(f,\baspsi_i),\quad i\in\If\tp  \end{equation}
$$

This equation can be rearranged to a form that explicitly shows
that we get a linear system for the unknowns \( \sequencei{c} \):

$$
\begin{equation}
\sum_{j\in\If} (\baspsi_i,\baspsi_j'')c_j = (f, \baspsi_i),\quad i\in\If\tp  \end{equation}
$$

For the particular choice of the basis functions <a href="#mjx-eqn-64">(64)</a>
we get in fact the same linear system
as in the least squares method
because \( \baspsi''= -(i+1)^2\pi^2L^{-2}\baspsi \).

<h3 id="___sec119">The collocation method <a name="___sec119"></a></h3>

<p>
For the collocation method <a href="#mjx-eqn-61">(61)</a> we need to
decide upon a set of \( N+1 \) collocation points in \( \Omega \). A simple
choice is to use uniformly spaced points: \( \xno{i}=i\Delta x \), where
\( \Delta x = L/N \) in our case (\( N\geq 1 \)). However, these points
lead to at least two rows in the matrix consisting of zeros
(since \( \baspsi_i(\xno{0})=0 \) and \( \baspsi_i(\xno{N})=0 \)), thereby making the matrix
singular and non-invertible. This forces us to choose some other
collocation points, e.g., random points or points uniformly distributed
in the interior of \( \Omega \).
Demanding the residual to vanish
at these points leads, in our model problem <a href="#mjx-eqn-63">(63)</a>, to
the equations

$$
\begin{equation}
-\sum_{j\in\If} c_j\baspsi_j''(\xno{i}) = f(\xno{i}),\quad i\in\If,
\end{equation}
$$

which is seen to be a linear system with entries

$$
\begin{equation*} A_{i,j}=-\baspsi_j''(\xno{i})=
(j+1)^2\pi^2L^{-2}\sin\left((j+1)\pi \frac{x_i}{L}\right),\end{equation*}
$$

in the coefficient matrix and entries
\( b_i=2 \) for the right-hand side (when \( f(x)=2 \)).

<p>
The special case of \( N=0 \)
can sometimes be of interest. A natural choice is then the midpoint
\( \xno{0}=L/2 \) of the domain, resulting in
\( A_{0,0} = -\baspsi_0''(\xno{0}) = \pi^2L^{-2} \), \( f(x_0)=2 \),
and hence \( c_0=2L^2/\pi^2 \).

<h3 id="___sec120">Comparison <a name="___sec120"></a></h3>

<p>
In the present model problem, with \( f(x)=2 \), the exact solution is
\( u(x)=x(L-x) \), while for \( N=0 \) the Galerkin and least squares method
result in \( u(x)=8L^2\pi^{-3}\sin (\pi x/L) \) and the
collocation method leads to \( u(x)=2L^2\pi^{-2}\sin (\pi x/L) \).
We can quickly use <code>sympy</code> to verify that the maximum error
occurs at the midpoint \( x=L/2 \) and find what the errors are:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sp</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># Computing with Dirichlet conditions: -u&#39;&#39;=2 and sines</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x, L <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x L&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> e_Galerkin <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(L<span style="color: #666666">-</span>x) <span style="color: #666666">-</span> <span style="color: #666666">8*</span>L<span style="color: #666666">**2*</span>sp<span style="color: #666666">.</span>pi<span style="color: #666666">**</span>(<span style="color: #666666">-3</span>)<span style="color: #666666">*</span>sp<span style="color: #666666">.</span>sin(sp<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/</span>L)
<span style="color: #666666">&gt;&gt;&gt;</span> e_colloc <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(L<span style="color: #666666">-</span>x) <span style="color: #666666">-</span> <span style="color: #666666">2*</span>L<span style="color: #666666">**2*</span>sp<span style="color: #666666">.</span>pi<span style="color: #666666">**</span>(<span style="color: #666666">-2</span>)<span style="color: #666666">*</span>sp<span style="color: #666666">.</span>sin(sp<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>x<span style="color: #666666">/</span>L)

<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># Verify max error for x=L/2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dedx_Galerkin <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>diff(e_Galerkin, x)
<span style="color: #666666">&gt;&gt;&gt;</span> dedx_Galerkin<span style="color: #666666">.</span>subs(x, L<span style="color: #666666">/2</span>)
<span style="color: #666666">0</span>
<span style="color: #666666">&gt;&gt;&gt;</span> dedx_colloc <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>diff(e_colloc, x)
<span style="color: #666666">&gt;&gt;&gt;</span> dedx_colloc<span style="color: #666666">.</span>subs(x, L<span style="color: #666666">/2</span>)
<span style="color: #666666">0</span>

<span style="color: #408080; font-style: italic"># Compute max error: x=L/2, evaluate numerical, and simplify</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sp<span style="color: #666666">.</span>simplify(e_Galerkin<span style="color: #666666">.</span>subs(x, L<span style="color: #666666">/2</span>)<span style="color: #666666">.</span>evalf(n<span style="color: #666666">=3</span>))
<span style="color: #666666">-0.00812*</span>L<span style="color: #666666">**2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sp<span style="color: #666666">.</span>simplify(e_colloc<span style="color: #666666">.</span>subs(x, L<span style="color: #666666">/2</span>)<span style="color: #666666">.</span>evalf(n<span style="color: #666666">=3</span>))
<span style="color: #666666">0.0473*</span>L<span style="color: #666666">**2</span>
</pre></div>
<p>
The error in the collocation method is about 6 times larger than
the error in the Galerkin or least squares method.

<h2 id="fem:deq:1D:varform">Integration by parts<a name="fem:deq:1D:varform"></a></h2>

<p>
A problem arises if we want to apply popular finite element functions
to solve our model problem <a href="#mjx-eqn-63">(63)</a>
by the standard least squares, Galerkin, or collocation methods: the piecewise
polynomials \( \baspsi_i(x) \) have discontinuous derivatives at the
cell boundaries which makes it problematic to compute
the second-order derivative.  This fact actually makes the least squares and
collocation methods less suitable for finite element approximation of
the unknown function. (By rewriting the equation \( -u''=f \) as a
system of two first-order equations, \( u'=v \) and \( -v'=f \), the
least squares method can be applied. Also, differentiating discontinuous
functions can actually be handled by distribution theory in
mathematics.)  The Galerkin method and the method of
weighted residuals can, however, be applied together with finite
element basis functions if we use <em>integration by parts</em>
as a means for transforming a second-order derivative to a first-order
one.

<p>
Consider the model problem <a href="#mjx-eqn-63">(63)</a> and its
Galerkin formulation

$$
\begin{equation*} -(u'',v) = (f,v)\quad\forall v\in V\tp  \end{equation*}
$$

Using integration by parts in the Galerkin method,
we can move a derivative of \( u \) onto \( v \):

$$
\begin{align}
\int_0^L u''(x)v(x) \dx &= - \int_0^Lu'(x)v'(x)\dx
+ [vu']_0^L\nonumber\\ 
&= - \int_0^Lu'(x)v'(x) \dx
+ u'(L)v(L) - u'(0)v(0)\tp
\tag{67}
\end{align}
$$

Usually, one integrates the problem at the stage where the \( u \) and \( v \)
functions enter the formulation.
Alternatively, but less common, we can integrate by parts in the expressions for
the matrix entries:

$$
\begin{align}
\int_0^L\baspsi_i(x)\baspsi_j''(x) \dx &=
- \int_0^L\baspsi_i'(x)\baspsi_j'(x) dx
+ [\baspsi_i\baspsi_j']_0^L\nonumber\\ 
&= - \int_0^L\baspsi_i'(x)\baspsi_j'(x) \dx
+ \baspsi_i(L)\baspsi_j'(L) - \baspsi_i(0)\baspsi_j'(0)\tp
\tag{68}
\end{align}
$$

Integration by parts serves to reduce the order of the derivatives and
to make the coefficient matrix symmetric since
\( (\baspsi_i',\baspsi_j') = (\baspsi_i',\baspsi_j') \).
The symmetry property depends
on the type of terms that enter the differential equation.
As will be seen later in the section <a href="._main_fem016.html#fem:deq:1D:BC:nat">Boundary conditions: specified derivative</a>,
integration by parts also provides a method for implementing
boundary conditions involving \( u' \).

<p>
With the choice <a href="#mjx-eqn-64">(64)</a> of basis functions we see
that the "boundary terms" \( \baspsi_i(L)\baspsi_j'(L) \) and \( \baspsi_i(0)\baspsi_j'(0) \)
vanish since \( \baspsi_i(0)=\baspsi_i(L)=0 \).
<!-- A boundary term associated with -->
<!-- a location at the boundary where we have Dirichlet conditions will always -->
<!-- vanish because \( \baspsi_i=0 \) at such locations. -->

<h3 id="___sec122">Weak form <a name="___sec122"></a></h3>

<p>
Since the variational formulation after integration by parts make
weaker demands on the differentiability of \( u \) and the basis
functions \( \baspsi_i \),
the resulting integral formulation is referred to as a <em>weak form</em> of
the differential equation problem. The original variational formulation
with second-order derivatives, or the differential equation problem
with second-order derivative, is then the <em>strong form</em>, with
stronger requirements on the differentiability of the functions.

<p>
For differential equations with second-order derivatives, expressed as
variational formulations and solved by finite element methods, we will
always perform integration by parts to arrive at expressions involving
only first-order derivatives.

<h2 id="fem:deq:1D:essBC:Bfunc">Boundary function<a name="fem:deq:1D:essBC:Bfunc"></a></h2>

<p>
So far we have assumed zero Dirichlet boundary conditions, typically
\( u(0)=u(L)=0 \), and we have demanded that \( \baspsi_i(0)=\baspsi_i(L)=0 \)
for \( i\in\If \). What about a boundary condition like \( u(L)=D\neq0 \)?
This condition immediately faces a problem:
\( u = \sum_j c_j\basphi_j(L) = 0 \) since all \( \basphi_i(L)=0 \).

<p>
A boundary condition of the form \( u(L)=D \) can be implemented by
demanding that all \( \baspsi_i(L)=0 \), but adding a
<em>boundary function</em> \( B(x) \) with the right boundary value, \( B(L)=D \), to
the expansion for \( u \):

$$
\begin{equation*} u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x)
\tp
\end{equation*}
$$

This \( u \) gets the right value at \( x=L \):

$$
\begin{equation*} u(L) = B(L) + \sum_{j\in\If} c_j\baspsi_j(L) = B(L) = D\tp  \end{equation*}
$$

The idea is that for any boundary where \( u \) is known we demand \( \baspsi_i \) to
vanish and construct a function \( B(x) \) to attain the boundary value of \( u \).
There are no restrictions how \( B(x) \) varies with \( x \) in the interior of the
domain, so this variation needs to be constructed in some way.

<p>
For example, with \( u(0)=0 \) and
\( u(L)=D \), we can choose \( B(x)=x D/L \), since this form ensures that
\( B(x) \) fulfills the boundary conditions: \( B(0)=0 \) and \( B(L)=D \).
The unknown function is then sought on the form

$$
\begin{equation}
u(x) = \frac{x}{L}D + \sum_{j\in\If} c_j\baspsi_j(x),
\tag{69}
\end{equation}
$$

with \( \baspsi_i(0)=\baspsi_i(L)=0 \).

<p>
The \( B(x) \) function can be chosen in many ways as long as its boundary
values are correct. For example, \( B(x)=D(x/L)^p \) for any power \( p \)
will work fine in the above example.

<p>
As another example, consider a domain \( \Omega = [a,b] \)
where the boundary conditions are \( u(a)=U_a \) and \( u(b)=U_b \).  A class
of possible \( B(x) \) functions is

$$
\begin{equation} B(x)=U_a + \frac{U_b-U_a}{(b-a)^p}(x-a)^p,\quad p>0
\tp
\tag{70}
\end{equation}
$$

Real applications will most likely use the simplest version, \( p=1 \),
but here such a \( p \) parameter was included to demonstrate the
ambiguity in the construction of \( B(x) \).

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Summary.</b>
The general procedure of incorporating Dirichlet boundary
conditions goes as follows.
Let \( \partial\Omega_E \) be the part(s) of the boundary
\( \partial\Omega \) of the domain \( \Omega \) where \( u \) is specified.
Set \( \baspsi_i=0 \) at the points in \( \partial\Omega_E \) and seek \( u \)
as

$$
\begin{equation}
u(x) = B(x) + \sum_{j\in\If} c_j\baspsi_j(x),
\tag{71}
\end{equation}
$$

where \( B(x) \) equals the boundary conditions on \( u \) at \( \partial\Omega_E \).
</div>


<p>
<b>Remark.</b>
With the \( B(x) \) term, \( u \) does not in general lie in \( V=\hbox{span}\,
\{\baspsi_0,\ldots,\baspsi_N\} \) anymore. Moreover, when a prescribed value
of \( u \) at the boundary, say \( u(a)=U_a \) is different from zero, it does
not make sense to say that \( u \) lies in a vector space, because
this space does not obey the requirements of addition and scalar multiplication.
For example,
\( 2u \) does not lie in the space since its boundary value is \( 2U_a \),
which is incorrect. It only makes sense to split \( u \) in two parts,
as done above, and have the unknown part \( \sum_j c_j \baspsi_j \) in a
proper function space.
<!-- Sometimes it is said that \( u \) is in the <em>affine space</em> \( B+V \). -->

<h2 id="fem:deq:1D:varform:abstract">Abstract notation for variational formulations<a name="fem:deq:1D:varform:abstract"></a></h2>

<p>
We have seen that variational formulations end up with a formula involving
\( u \) and \( v \), such as \( (u',v') \) and a formula involving \( v \) and known
functions, such as \( (f,v) \). A widely used notation is to introduce an abstract
variational statement written as \( a(u,v)=L(v) \),
where \( a(u,v) \) is a so-called <em>bilinear form</em> involving all the terms
that contain both the test and trial
function, while \( L(v) \) is a <em>linear form</em> containing all the terms without
the trial function. For example, the statement

$$ \int_{\Omega} u' v' \dx =
\int_{\Omega} fv\dx\quad\hbox{or}\quad (u',v') = (f,v)
\quad\forall v\in V$$

can be written in abstract form: <em>find \( u \) such that</em>

$$ a(u,v) = L(v)\quad \forall v\in V,$$

where we have the definitions

$$ a(u,v) = (u',v'),\quad L(v) = (f,v)\tp  $$


<p>
The term <em>linear</em> means that \( L(\alpha_1 v_1 + \alpha_2 v_2)
=\alpha_1 L(v_1) + \alpha_2 L(v_2) \) for two test functions \( v_1 \) and \( v_2 \), and
scalar parameters \( \alpha_1 \) and \( \alpha_2 \). Similarly, the term <em>bilinear</em>
means that \( a(u,v) \) is linear in both its arguments:
$$
\begin{align*}
a(\alpha_1 u_1 + \alpha_2 u_2, v) &= \alpha_1 a(u_1,v) + \alpha_2 a(u_2, v),
\\ 
a(u, \alpha_1 v_1 + \alpha_2 v_2) &= \alpha_1 a(u,v_1) + \alpha_2 a(u, v_2)
\tp
\end{align*}
$$

In nonlinear problems these linearity properties do not hold in general
and the abstract notation is then \( F(u;v)=0 \).

<p>
The matrix system associated with \( a(u,v)=L(v) \) can also be written in
an abstract form by inserting \( v=\baspsi_i \) and \( u=\sum_j c_j\baspsi_j \)
in \( a(u,v)=L(v) \). Using the linear properties, we get

$$ \sum_{j\in\If} a(\baspsi_j,\baspsi_i) c_j = L(\baspsi_i),\quad i\in\If,
$$

which is a linear system

$$ \sum_{j\in\If}A_{i,j}c_j = b_i,\quad i\in\If,$$

where

$$ A_{i,j} =a(\baspsi_j,\baspsi_i), \quad b_i = L(\baspsi_i)\tp$$

In many problems, \( a(u,v) \) is symmetric such that
\( a(\baspsi_j,\baspsi_i) = a(\baspsi_i,\baspsi_j) \). In those cases the
coefficient matrix becomes symmetric, \( A_{i,j}=A_{j,i} \), a property
that can simplify solution algorithms for linear systems
and make them more stable in addition to saving memory and computations.

<p>
The abstract notation \( a(u,v)=L(v) \) for linear differential equation problems
is much used in the literature and
in description of finite element software (in particular the
<a href="http://fenicsproject.org" target="_self">FEniCS</a> documentation). We shall
frequently summarize variational forms using this notation.

<h2 id="fem:deq:1D:optimization">Variational problems and optimization of functionals<a name="fem:deq:1D:optimization"></a></h2>

<p>
If \( a(u,v)=a(v,u) \), it can be shown that the variational statement

$$ a(u,v)=L(v)\quad\forall v\in V,$$

is equivalent to minimizing the functional

$$ F(v) = {\half}a(v,v) - L(v) $$

over all functions \( v\in V \). That is,
$$ F(u)\leq F(v)\quad \forall v\in V\tp $$

Inserting a \( v=\sum_j c_j\baspsi_j \) turns minimization of \( F(v) \) into
minimization of a quadratic function

$$ \bar F(c_0,\ldots,c_N) = \sum_{j\in\If}\sum_{i\in\If} a(\baspsi_i,\baspsi_j)c_ic_j - \sum_{j\in\If} L(\baspsi_j)c_j
$$

of \( N+1 \) parameters.

<p>
Minimization of \( \bar F \) implies

$$ \frac{\partial\bar F}{\partial c_i}=0,\quad i\in\If\tp$$

After some algebra one finds

$$ \sum{j\in\If} a(\baspsi_i,\baspsi_j)c_j = L(\baspsi_i),\quad i\in\If,$$

which is the same system as that arising from \( a(u,v)=L(v) \).

<p>
Many traditional applications of the finite element method, especially
in solid mechanics and structural analysis, start with formulating \( F(v) \)
from physical principles, such as minimization of energy, and then
proceeds with deriving \( a(u,v)=L(v) \), which is the equation usually desired
in implementations.

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._main_fem011.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._main_fem013.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

