<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to finite element methods">
<meta name="keywords" content="approximation of vectors in the plane,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,residual,variational formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements">

<title>Introduction to finite element methods</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Approximation of vectors ',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              (' Approximation of planar vectors ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' The least squares method ', 3, None, '___sec2'),
              (' The projection method ', 3, None, '___sec3'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 3, None, '___sec5'),
              (' The Galerkin or projection method ', 3, None, '___sec6'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec9'),
              (' Example: linear approximation ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Implementation of the least squares method ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Symbolic integration ', 3, None, '___sec12'),
              (' Fallback on numerical integration ', 3, None, '___sec13'),
              (' Plotting the approximation ', 3, None, '___sec14'),
              (' Perfect approximation ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Ill-conditioning ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Fourier series ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Orthogonal basis functions ',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              (' Numerical computations ', 2, None, '___sec19'),
              (' The interpolation (or collocation) method ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' Example ', 3, None, '___sec21'),
              (' Lagrange polynomials ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Approximation of a polynomial ', 3, None, '___sec23'),
              (' Successful example ', 3, None, '___sec24'),
              (' Less successful example ', 3, None, '___sec25'),
              (' Remedy for strong oscillations ', 3, None, '___sec26'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example ', 3, None, '___sec29'),
              (' The basis functions ', 2, None, '___sec30'),
              (' Construction principles ', 3, None, '___sec31'),
              (' Properties of $\\basphi_i$ ', 3, None, '___sec32'),
              (' Example on piecewise quadratic finite element functions ',
               2,
               None,
               '___sec33'),
              (' Example on piecewise linear finite element functions ',
               2,
               None,
               '___sec34'),
              (' Example on piecewise cubic finite element basis functions ',
               2,
               None,
               '___sec35'),
              (' Calculating the linear system ',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Calculating a specific matrix entry ', 3, None, '___sec37'),
              (' Calculating a general row in the matrix ',
               3,
               None,
               '___sec38'),
              (' Assembly of elementwise computations ',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Mapping to a reference element ',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Example: Integration over a reference element ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Implementation ',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              (' Integration ',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              (' Linear system assembly and solution ',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              (' Example on computing symbolic approximations ',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              (' Comparison with finite elements and interpolation/collocation ',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              (' Example on computing numerical approximations ',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' Applications ',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Finite difference approximation of given functions ',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              (' Finite difference interpretation of a finite element approximation ',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              (' Making finite elements behave as finite differences ',
               2,
               None,
               '___sec54'),
              (' Computations in physical space ', 3, None, '___sec55'),
              (' Elementwise computations ', 3, None, '___sec56'),
              (' Terminology ', 3, None, '___sec57'),
              (' A generalized element concept ',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              (' Cells, vertices, and degrees of freedom ',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              (' Extended finite element concept ',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              (' Implementation ',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              (' Computing the error of the approximation ',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              (' Example: Cubic Hermite polynomials ',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              (' Numerical integration ', 1, None, '___sec64'),
              (' Newton-Cotes rules ',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              (' Gauss-Legendre rules with optimized points ',
               2,
               None,
               '___sec66'),
              (' Approximation of functions in 2D ',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              (' 2D basis functions as tensor products of 1D functions ',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              (' Example: Polynomial basis in 2D ', 2, None, '___sec69'),
              (' Implementation ',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              (' Extension to 3D ',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              (' Finite elements in 2D and 3D ', 1, None, '___sec72'),
              (' Basis functions over triangles in the physical domain ',
               2,
               None,
               '___sec73'),
              (' Element matrices and vectors ', 3, None, '___sec74'),
              (' Basis functions over triangles in the reference cell ',
               2,
               None,
               '___sec75'),
              (' Affine mapping of the reference cell ', 2, None, '___sec76'),
              (' Isoparametric mapping of the reference cell ',
               2,
               None,
               '___sec77'),
              (' Computing integrals ', 2, None, '___sec78'),
              (' Exercises ', 1, None, '___sec79'),
              (' Exercise 1: Linear algebra refresher I ',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              (' Exercise 2: Linear algebra refresher II ',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              (' Exercise 3: Approximate a three-dimensional vector in a plane ',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              (' Exercise 4: Approximate the exponential function by power functions ',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              (' Exercise 5: Approximate the sine function by power functions ',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              (' Exercise 6: Approximate a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              (' Remarks ', 3, None, '___sec86'),
              (' Exercise 7: Animate the approximation of a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine2',
               'fem:approx:exer:tanh:sine2'),
              (' Exercise 8: Fourier series as a least squares approximation ',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              (' Exercise 9: Approximate a steep function by Lagrange polynomials ',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              (' Exercise 10: Define nodes and elements ',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              (' Exercise 11: Define vertices, cells, and dof maps ',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              (' Exercise 12: Construct matrix sparsity patterns ',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              (' Exercise 13: Perform symbolic finite element computations ',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              (' Exercise 14: Approximate a steep function by P1 and P2 elements ',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              (' Exercise 15: Approximate a steep function by P3 and P4 elements ',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              (' Exercise 16: Investigate the approximation error in finite elements ',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              (' Exercise 17: Approximate a step function by finite elements ',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              (' Exercise 18: 2D approximation with orthogonal functions ',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              (' Exercise 19: Use the Trapezoidal rule and P1 elements ',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              (' Problem 20: Compare P1 elements and interpolation ',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              (' Exercise 21: Implement 3D computations with global basis functions ',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              (" Exercise 22: Use Simpson's rule and P2 elements ",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              (' Basic principles for approximating differential equations ',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              (' Differential equation models ',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              (' Simple model problems ',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              (' Forming the residual ',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              (' The least squares method ', 2, None, '___sec107'),
              (' The Galerkin method ', 2, None, '___sec108'),
              (' The Method of Weighted Residuals ', 2, None, '___sec109'),
              (' Test and Trial Functions ', 2, None, '___sec110'),
              (' The collocation method ', 2, None, '___sec111'),
              (' The subdomain collocation method ', 3, None, '___sec112'),
              (' Examples on using the principles ',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              (' The model problem ', 3, None, '___sec114'),
              (' Basis functions ', 3, None, '___sec115'),
              (' The residual ', 3, None, '___sec116'),
              (' The least squares method ', 3, None, '___sec117'),
              (' The Galerkin method ', 3, None, '___sec118'),
              (' The collocation method ', 3, None, '___sec119'),
              (' Comparison ', 3, None, '___sec120'),
              (' Integration by parts ',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              (' Weak form ', 3, None, '___sec122'),
              (' Boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Abstract notation for variational formulations ',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              (' Variational problems and optimization of functionals ',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              (' Examples on variational formulations ',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              (' Variable coefficient ', 2, None, '___sec127'),
              (' First-order derivative in the equation and boundary condition ',
               2,
               None,
               '___sec128'),
              (' Nonlinear coefficient ', 2, None, '___sec129'),
              (' Computing with Dirichlet and Neumann conditions ',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              (' When the numerical method is exact ', 2, None, '___sec131'),
              (' Computing with finite elements ',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              (' Finite element mesh and basis functions ',
               2,
               None,
               '___sec133'),
              (' Computation in the global physical domain ',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              (' Comparison with a finite difference discretization ',
               2,
               None,
               '___sec135'),
              (' Cellwise computations ',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              (' The integral for the element matrix ', 3, None, '___sec137'),
              (' The integral for the element vector ', 3, None, '___sec138'),
              (' Detailed calculations of the element matrix and vector ',
               3,
               None,
               '___sec139'),
              (' Contributions from the first and last cell ',
               3,
               None,
               '___sec140'),
              (' Assembly ', 3, None, '___sec141'),
              (' Boundary conditions: specified nonzero value ',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              (' General construction of a boundary function ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              (' Example on computing with finite element-based a boundary function ',
               2,
               None,
               '___sec144'),
              (' Computations in physical coordinates ',
               3,
               None,
               '___sec145'),
              (' Cellwise computations on the reference element ',
               3,
               None,
               '___sec146'),
              (' Modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (' Computations in the physical system ', 3, None, '___sec148'),
              (' Symmetric modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (' Modification of the element matrix and vector ',
               2,
               None,
               '___sec150'),
              (' Boundary conditions: specified derivative ',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              (' The variational formulation ', 2, None, '___sec152'),
              (' Boundary term vanishes because of the test functions ',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              (' Boundary term vanishes because of linear system modifications ',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              (' Direct computation of the global linear system ',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              (' Cellwise computations ', 2, None, '___sec156'),
              (' Implementation ',
               1,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              (' Global basis functions ', 2, None, '___sec158'),
              (' Example: constant right-hand side ', 2, None, '___sec159'),
              (' Finite elements ', 2, None, '___sec160'),
              (' Variational formulations in 2D and 3D ',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              (' Transformation to a reference cell in 2D and 3D ',
               2,
               None,
               '___sec162'),
              (' Numerical integration ', 2, None, '___sec163'),
              (' Convenient formulas for P1 elements in 2D ',
               2,
               None,
               '___sec164'),
              (' Summary ', 1, None, '___sec165'),
              (' Time-dependent problems ',
               1,
               'fem:deq:timedep',
               'fem:deq:timedep'),
              (' Discretization in time by a Forward Euler scheme ',
               2,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              (' Time discretization ', 3, None, '___sec168'),
              (' Space discretization ', 3, None, '___sec169'),
              (' Variational forms ', 2, None, '___sec170'),
              (' Simplified notation for the solution at recent time levels ',
               2,
               None,
               '___sec171'),
              (' Deriving the linear systems ', 2, None, '___sec172'),
              (' Computational algorithm ', 2, None, '___sec173'),
              (' Comparing P1 elements with the finite difference method ',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              (' Lumping the mass matrix ', 3, None, '___sec175'),
              (' Discretization in time by a Backward Euler scheme ',
               2,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              (' Time discretization ', 3, None, '___sec177'),
              (' Variational forms ', 3, None, '___sec178'),
              (' Linear systems ', 3, None, '___sec179'),
              (' Dirichlet boundary conditions ',
               2,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              (' Boundary function ', 3, None, '___sec181'),
              (' Finite element basis functions ', 3, None, '___sec182'),
              (' Modification of the linear system ', 3, None, '___sec183'),
              (' Example: Oscillating Dirichlet boundary condition ',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              (' Analysis of the discrete equations ',
               2,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              (' Forward Euler discretization ', 3, None, '___sec186'),
              (' Backward Euler discretization ', 3, None, '___sec187'),
              (' Comparing amplification factors ', 3, None, '___sec188'),
              (' Systems of differential equations ',
               1,
               'fem:sys',
               'fem:sys'),
              (' Variational forms ', 2, 'fem:sys:vform', 'fem:sys:vform'),
              (' A worked example ', 2, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              (' Identical function spaces for the unknowns ',
               2,
               None,
               '___sec192'),
              (' Variational form of each individual PDE ',
               3,
               None,
               '___sec193'),
              (' Compound scalar variational form ', 3, None, '___sec194'),
              (' Decoupled linear systems ', 3, None, '___sec195'),
              (' Coupled linear systems ', 3, None, '___sec196'),
              (' Different function spaces for the unknowns ',
               2,
               None,
               '___sec197'),
              (' Computations in 1D ', 2, None, '___sec198'),
              (' Exercises ', 1, None, '___sec199'),
              (' Exercise 23: Refactor functions into a more general class ',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              (' Exercise 24: Compute the deflection of a cable with sine functions ',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              (' Exercise 25: Check integration by parts ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 26: Compute the deflection of a cable with 2 P1 elements ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 27: Compute the deflection of a cable with 1 P2 element ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 28: Compute the deflection of a cable with a step load ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 29: Show equivalence between linear systems ',
               2,
               'fem:deq:exer:Aub:essbc:equiv',
               'fem:deq:exer:Aub:essbc:equiv'),
              (' Exercise 30: Compute with a non-uniform mesh ',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              (' Problem 31: Solve a 1D finite element problem by hand ',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              (' Exercise 32: Compare finite elements and differences for a radially symmetric Poisson equation ',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              (' Exercise 33: Compute with variable coefficients and P1 elements by hand ',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              (' Exercise 34: Solve a 2D Poisson equation using polynomials and sines ',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              (' Exercise 35: Analyze a Crank-Nicolson scheme for the diffusion equation ',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              (' Bibliography ', 1, None, '___sec213')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0005"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_fem-solarized004.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_fem-solarized006.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1>Implementation <a name="fem:approx:fe:impl"></a></h1>

<p>
Based on the experience from the previous example, it makes
sense to write some code to automate the analytical integration process
for any choice of finite element basis functions. In addition,
we can automate the assembly process and linear system
solution. Appropriate
functions for this purpose document all details of all
steps in the finite element computations and can found in the module file
<a href="http://tinyurl.com/nm5587k/fem/fe_approx1D.py" target="_self"><tt>fe_approx1D.py</tt></a>.
The key steps in the computational machinery are now explained in
detail in terms of code and text.

<h2>Integration <a name="fem:approx:fe:impl:intg"></a></h2>

<p>
First we need a Python function for
defining \( \refphi_r(X) \) in terms of a Lagrange polynomial
of degree <code>d</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sp</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">phi_r</span>(r, X, d):
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(X, sp.Symbol):
        h = sp.Rational(<span style="color: #B452CD">1</span>, d)  <span style="color: #228B22"># node spacing</span>
        nodes = [<span style="color: #B452CD">2</span>*i*h - <span style="color: #B452CD">1</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #228B22"># assume X is numeric: use floats for nodes</span>
        nodes = np.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, d+<span style="color: #B452CD">1</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> Lagrange_polynomial(X, r, nodes)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p
</pre></div>
<p>
Observe how we construct the <code>phi_r</code> function to be
a symbolic expression for \( \refphi_r(X) \) if <code>X</code> is a
<code>Symbol</code> object from <code>sympy</code>. Otherwise, we assume that <code>X</code>
is a <code>float</code> object and compute the corresponding
floating-point value of \( \refphi_r(X) \). Recall that the
<code>Lagrange_polynomial</code> function, here simply copied
from the section <a href="._main_fem-solarized003.html#fem:approx:global:Fourier">Fourier series</a>,
works with both symbolic and
numeric variables.

<p>
The complete basis \( \refphi_0(X),\ldots,\refphi_d(X) \)
on the reference element, represented as a list of
symbolic expressions, is constructed by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">basis</span>(d=<span style="color: #B452CD">1</span>):
    X = sp.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    phi = [phi_r(r, X, d) <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> phi
</pre></div>
<p>
Now we are in a position to write the function for computing
the element matrix:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_matrix</span>(phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    A_e = sp.zeros((n, n))
    X = sp.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sp.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(r, n):
            A_e[r,s] = sp.integrate(phi[r]*phi[s]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
            A_e[s,r] = A_e[r,s]
    <span style="color: #8B008B; font-weight: bold">return</span> A_e
</pre></div>
<p>
In the symbolic case (<code>symbolic</code> is <code>True</code>),
we introduce the element length as a symbol
<code>h</code> in the computations. Otherwise, the real numerical value
of the element interval <code>Omega_e</code>
is used and the final matrix elements are numbers,
not symbols.
This functionality can be demonstrated:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; phi
[<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> - X/<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> + X/<span style="color: #B452CD">2</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">True</span>)
[h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">False</span>)
[<span style="color: #B452CD">0.0333333333333333</span>, <span style="color: #B452CD">0.0166666666666667</span>]
[<span style="color: #B452CD">0.0166666666666667</span>, <span style="color: #B452CD">0.0333333333333333</span>]
</pre></div>
<p>
The computation of the element vector is done by a similar
procedure:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    b_e = sp.zeros((n, <span style="color: #B452CD">1</span>))
    <span style="color: #228B22"># Make f a function of X</span>
    X = sp.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sp.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    x = (Omega_e[<span style="color: #B452CD">0</span>] + Omega_e[<span style="color: #B452CD">1</span>])/<span style="color: #B452CD">2</span> + h/<span style="color: #B452CD">2</span>*X  <span style="color: #228B22"># mapping</span>
    f = f.subs(<span style="color: #CD5555">&#39;x&#39;</span>, x)  <span style="color: #228B22"># substitute mapping formula for x</span>
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        b_e[r] = sp.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">return</span> b_e
</pre></div>
<p>
Here we need to replace the symbol <code>x</code> in the expression for <code>f</code>
by the mapping formula such that <code>f</code> can be integrated
in terms of \( X \), cf. the formula
\( \tilde b^{(e)}_{r} = \int_{-1}^1 f(x(X))\refphi_r(X)\frac{h}{2}dX \).

<p>
The integration in the element matrix function involves only products
of polynomials, which <code>sympy</code> can easily deal with, but for the
right-hand side <code>sympy</code> may face difficulties with certain types of
expressions <code>f</code>. The result of the integral is then an <code>Integral</code>
object and not a number or expression
as when symbolic integration is successful.
It may therefore be wise to introduce a fallback on numerical
integration. The symbolic integration can also take much time
before an unsuccessful conclusion so we may also introduce a parameter
<code>symbolic</code> and set it to <code>False</code> in order to avoid symbolic integration:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
        ...
        <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
            I = sp.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> symbolic <span style="color: #8B008B">or</span> <span style="color: #658b00">isinstance</span>(I, sp.Integral):
            h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]  <span style="color: #228B22"># Ensure h is numerical</span>
            detJ = h/<span style="color: #B452CD">2</span>
            integrand = sp.lambdify([X], f*phi[r]*detJ)
            I = sp.mpmath.quad(integrand, [-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>])
        b_e[r] = I
        ...
</pre></div>
<p>
Numerical integration requires that the symbolic
integrand is converted
to a plain Python function (<code>integrand</code>) and that
the element length <code>h</code> is a real number.

<h2>Linear system assembly and solution <a name="fem:approx:fe:impl:linsys"></a></h2>

<p>
The complete algorithm
for computing and assembling the elementwise contributions
takes the following form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assemble</span>(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>):
    N_n, N_e = <span style="color: #658b00">len</span>(nodes), <span style="color: #658b00">len</span>(elements)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        A = sp.zeros((N_n, N_n))
        b = sp.zeros((N_n, <span style="color: #B452CD">1</span>))    <span style="color: #228B22"># note: (N_n, 1) matrix</span>
    <span style="color: #8B008B; font-weight: bold">else</span>:
        A = np.zeros((N_n, N_n))
        b = np.zeros(N_n)
    <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_e):
        Omega_e = [nodes[elements[e][<span style="color: #B452CD">0</span>]], nodes[elements[e][-<span style="color: #B452CD">1</span>]]]

        A_e = element_matrix(phi, Omega_e, symbolic)
        b_e = element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] += A_e[r,s]
            b[elements[e][r]] += b_e[r]
    <span style="color: #8B008B; font-weight: bold">return</span> A, b
</pre></div>
<p>
The <code>nodes</code> and <code>elements</code> variables represent the finite
element mesh as explained earlier.

<p>
Given the coefficient matrix <code>A</code> and the right-hand side <code>b</code>,
we can compute the coefficients \( \sequencei{c} \) in the expansion
\( u(x)=\sum_jc_j\basphi_j \) as the solution vector <code>c</code> of the linear
system:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> symbolic:
    c = A.LUsolve(b)
<span style="color: #8B008B; font-weight: bold">else</span>:
    c = np.linalg.solve(A, b)
</pre></div>
<p>
When <code>A</code> and <code>b</code> are <code>sympy</code> arrays,
the solution procedure implied by <code>A.LUsolve</code> is symbolic.
Otherwise, <code>A</code> and <code>b</code> are <code>numpy</code> arrays and a standard
numerical solver is called.
The symbolic version is suited for small problems only
(small \( N \) values) since the calculation time becomes prohibitively large
otherwise. Normally, the symbolic <em>integration</em> will be more time
consuming in small problems than the symbolic <em>solution</em> of the linear system.

<h2>Example on computing symbolic approximations <a name="fem:approx:fe:impl:ex1:symbolic"></a></h2>

<p>
We can exemplify the use of <code>assemble</code> on the computational
case from the section <a href="._main_fem-solarized004.html#fem:approx:global:linearsystem">Calculating the linear system</a> with
two P1 elements (linear basis functions) on the domain \( \Omega=[0,1] \).
Let us first work with a symbolic element length:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; h, x = sp.symbols(<span style="color: #CD5555">&#39;h x&#39;</span>)
&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, h, <span style="color: #B452CD">2</span>*h]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; b
[     h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
[      h**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">5</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - <span style="color: #B452CD">17</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[                           h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">12</span>*(<span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - <span style="color: #B452CD">35</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">72</span>)/(<span style="color: #B452CD">7</span>*h)]
[  <span style="color: #B452CD">7</span>*(<span style="color: #B452CD">4</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">7</span> - <span style="color: #B452CD">23</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">21</span>)/(<span style="color: #B452CD">2</span>*h)]
</pre></div>

<h2>Comparison with finite elements and interpolation/collocation <a name="fem:approx:fe:impl:ex1:collocation"></a></h2>

<p>
We may, for comparison, compute the <code>c</code> vector corresponding to
an interpolation/collocation method with finite element basis functions.
Choosing the nodes as points, the principle is

$$ u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) = f(\xno{i}),\quad
i\in\If\tp$$

The coefficient matrix \( A_{i,j}=\basphi_j(\xno{i}) \) becomes
the identity matrix because basis function number \( j \) vanishes
at all nodes, except node \( j \): \( \basphi_j(\xno{i}=\delta_{ij} \).
Therefore, \( c_i = f(\xno{i} \).

<p>
The associated <code>sympy</code> calculations are

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; fn = sp.lambdify([x], f)
&gt;&gt;&gt; c = [fn(xc) <span style="color: #8B008B; font-weight: bold">for</span> xc <span style="color: #8B008B">in</span> nodes]
&gt;&gt;&gt; c
[<span style="color: #B452CD">0</span>, h*(<span style="color: #B452CD">1</span> - h), <span style="color: #B452CD">2</span>*h*(<span style="color: #B452CD">1</span> - <span style="color: #B452CD">2</span>*h)]
</pre></div>
<p>
These expressions are much simpler than those based on least squares
or projection in combination with finite element basis functions.

<h2>Example on computing numerical approximations <a name="fem:approx:fe:impl:ex1:numeric"></a></h2>

<p>
The numerical computations corresponding to the
symbolic ones in the section <a href="#fem:approx:fe:impl:ex1:symbolic">Example on computing symbolic approximations</a>,
and still done by <code>sympy</code> and the <code>assemble</code> function, go as follows:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; x = sp.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">False</span>)
&gt;&gt;&gt; A
[ <span style="color: #B452CD">0.166666666666667</span>, <span style="color: #B452CD">0.0833333333333333</span>,                  <span style="color: #B452CD">0</span>]
[<span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.333333333333333</span>, <span style="color: #B452CD">0.0833333333333333</span>]
[                 <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.166666666666667</span>]
&gt;&gt;&gt; b
[          <span style="color: #B452CD">0.03125</span>]
[<span style="color: #B452CD">0.104166666666667</span>]
[          <span style="color: #B452CD">0.03125</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[<span style="color: #B452CD">0.0416666666666666</span>]
[ <span style="color: #B452CD">0.291666666666667</span>]
[<span style="color: #B452CD">0.0416666666666666</span>]
</pre></div>
<p>
The <code>fe_approx1D</code> module contains functions for generating the
<code>nodes</code> and <code>elements</code> lists for equal-sized elements with
any number of nodes per element. The coordinates in <code>nodes</code>
can be expressed either through the element length symbol <code>h</code>
(<code>symbolic=True</code>) or by real numbers (<code>symbolic=False</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes, elements = mesh_uniform(N_e=<span style="color: #B452CD">10</span>, d=<span style="color: #B452CD">3</span>, Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>],
                               symbolic=<span style="color: #658b00">True</span>)
</pre></div>
<p>
There is also a function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">approximate</span>(f, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">4</span>, filename=<span style="color: #CD5555">&#39;tmp.pdf&#39;</span>):
</pre></div>
<p>
which computes a mesh with <code>N_e</code> elements, basis functions of
degree <code>d</code>, and approximates a given symbolic expression
<code>f</code> by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \).
When <code>symbolic</code> is <code>False</code>, \( u(x) = \sum_jc_j\basphi_j(x) \)
can be computed at a (large)
number of points and plotted together with \( f(x) \). The construction
of \( u \) points from the solution vector <code>c</code> is done
elementwise by evaluating \( \sum_rc_r\refphi_r(X) \) at a (large)
number of points in each element in the local coordinate system,
and the discrete \( (x,u) \) values on
each element are stored in separate arrays that are finally
concatenated to form a global array for \( x \) and for \( u \).
The details are found in the <code>u_glob</code> function in
<code>fe_approx1D.py</code>.

<h2>The structure of the coefficient matrix <a name="fem:approx:fe:A:structure"></a></h2>

<p>
Let us first see how the global matrix looks like if we assemble
symbolic element matrices, expressed in terms of <code>h</code>, from
several elements:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; d=<span style="color: #B452CD">1</span>; N_e=<span style="color: #B452CD">8</span>; Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]  <span style="color: #228B22"># 8 linear elements on [0,1]</span>
&gt;&gt;&gt; phi = basis(d)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; nodes, elements = mesh_symbolic(N_e, d, Omega)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
</pre></div>
<p>
The reader is encouraged to assemble the element matrices by hand and verify
this result, as this exercise will give a hands-on understanding of
what the assembly is about. In general we have a coefficient matrix that is
tridiagonal:

$$
\begin{equation}
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
\tag{38}
\end{equation}
$$


<p>
The structure of the right-hand side is more difficult to reveal since
it involves an assembly of elementwise integrals of
\( f(x(X))\refphi_r(X)h/2 \), which obviously depend on the
particular choice of \( f(x) \).
Numerical integration can give some insight into the nature of
the right-hand side. For this purpose it
is easier to look at the integration in \( x \) coordinates, which
gives the general formula <a href="._main_fem-solarized004.html#mjx-eqn-26">(26)</a>.
For equal-sized elements of length \( h \), we can apply the
Trapezoidal rule at the global node points to arrive at

$$
\begin{align}
b_i &= h\left( \half \basphi_i(\xno{0})f(\xno{0}) +
\half \basphi_i(\xno{N})f(\xno{N}) + \sum_{j=1}^{N-1}
\basphi_i(\xno{j})f(\xno{j})\right)\\ 
& =
\left\lbrace\begin{array}{ll}
\half hf(x_i),& i=0\hbox{ or }i=N,\\ 
h f(x_i), & 1 \leq i \leq N-1
\end{array}\right.
\end{align}
$$

The reason for this simple formula is simply that \( \basphi_i \) is either
0 or 1 at the nodes and 0 at all but one of them.

<p>
Going to P2 elements (<code>d=2</code>) leads
to the element matrix

$$
\begin{equation}
A^{(e)} = \frac{h}{30}
\left(\begin{array}{ccc}
4 & 2 & -1\\ 
2 & 16 & 2\\ 
-1 & 2 & 4
\end{array}\right)
\end{equation}
$$

and the following global assembled matrix from four elements:

$$
\begin{equation}
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 &
  0\\0 & 0 & 2 & 16 & 2 & 0 & 0
  & 0 & 0\\0 & 0 & - 1 & 2 & 8
  & 2 & - 1 & 0 & 0\\0 & 0 & 0 & 0 &
  2 & 16 & 2 & 0 & 0\\0 & 0 & 0
  & 0 & - 1 & 2 & 8 &
  2 & - 1\\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
\end{equation}
$$

In general, for \( i \) odd we have the nonzeroes

$$
\begin{equation*} A_{i,i-2} = -1,\quad A_{i-1,i}=2,\quad A_{i,i} = 8,\quad A_{i+1,i}=2,
\quad A_{i+2,i}=-1,\end{equation*}
$$

multiplied by \( h/30 \), and for \( i \) even we have the nonzeros

$$
\begin{equation*} A_{i-1,i}=2,\quad A_{i,i} = 16,\quad A_{i+1,i}=2,\end{equation*}
$$

multiplied by \( h/30 \). The rows with odd numbers correspond to
nodes at the element boundaries and get contributions from two
neighboring elements in the assembly process,
while the even numbered rows correspond to
internal nodes in the elements where the only one element contributes
to the values in the global matrix.

<h2>Applications <a name="fem:approx:fe:impl:ex2"></a></h2>

<p>
With the aid of the <code>approximate</code> function in the <code>fe_approx1D</code>
module we can easily investigate the quality of various finite element
approximations to some given functions. Figure <a href="#fem:approx:fe:x9:sin">29</a>
shows how linear and quadratic elements approximates the polynomial
\( f(x)=x(1-x)^8 \) on \( \Omega =[0,1] \), using equal-sized elements.
The results arise from the program

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sp</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> approximate
x = sp.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)

approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">4</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">2</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">8</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">4</span>)
</pre></div>
<p>
The quadratic functions are seen to be better than the linear ones for the same
value of \( N \), as we increase \( N \). This observation has some generality:
higher degree is not necessarily better on a coarse mesh, but it is as
we refined the mesh.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 29:  Comparison of the finite element approximations: 4 P1 elements with 5 nodes (upper left), 2 P2 elements with 5 nodes (upper right), 8 P1 elements with 9 nodes (lower left), and 4 P2 elements with 9 nodes (lower right).  <a name="fem:approx:fe:x9:sin"></a> </p></center>
<p><img src="fig-fem/fe_p1_p2_x9_248e.png" align="bottom" width=800,></p>
</center>

<h2>Sparse matrix storage and solution <a name="fem:approx:fe:impl:sparse"></a></h2>

<p>
Some of the examples in the preceding section took several minutes to
compute, even on small meshes consisting of up to eight elements.
The main explanation for slow computations is unsuccessful
symbolic integration: <code>sympy</code> may use a lot of energy on
integrals like \( \int f(x(X))\refphi_r(X)h/2 dx \) before
giving up, and the program then resorts to numerical integration.
Codes that can deal with a large number of basis functions and
accept flexible choices of \( f(x) \) should compute all integrals
numerically and replace the matrix objects from <code>sympy</code> by
the far more efficient array objects from <code>numpy</code>.

<p>
Another reason for slow code is related to the fact that most of the
matrix entries \( A_{i,j} \) are zero, because \( (\basphi_i,\basphi_j)=0 \)
unless \( i \) and \( j \) are nodes in the same element.  A matrix whose
majority of entries are zeros, is known as a <em>sparse</em> matrix.  The
sparsity should be utilized in software as it dramatically decreases
the storage demands and the CPU-time needed to compute the solution of
the linear system. This optimization is not critical in 1D problems
where modern computers can afford computing with all the zeros in the
complete square matrix, but in 2D and especially in 3D, sparse
matrices are fundamental for feasible finite element computations.

<p>
In 1D problems, using a
numbering of nodes and elements from left to right over the domain,
the assembled coefficient matrix has only a few diagonals different
from zero. More precisely, \( 2d+1 \) diagonals are different from
zero. With a different numbering of global nodes, say a random
ordering, the diagonal structure is lost, but the number of
nonzero elements is unaltered. Figures <a href="#fem:approx:fe:sparsity:P1">30</a>
and <a href="#fem:approx:fe:sparsity:P3">31</a> exemplify sparsity patterns.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 30:  Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P1 elements. <a name="fem:approx:fe:sparsity:P1"></a> </p></center>
<p><img src="fig-fem/sparsity_pattern_1D_30.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 31:  Matrix sparsity pattern for left-to-right numbering (left) and random numbering (right) of nodes in P3 elements. <a name="fem:approx:fe:sparsity:P3"></a> </p></center>
<p><img src="fig-fem/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p>
</center>

<p>
<!-- 2DO: -->
<!-- figure of diagonals vs random, exact examples on sparsity in 2D/3D? -->

<p>
The <code>scipy.sparse</code> library supports creation of sparse matrices
and linear system solution.

<ul>
 <li> <code>scipy.sparse.diags</code> for matrix defined via diagonals</li>
 <li> <code>scipy.sparse.lil_matrix</code> for creation via setting matrix entries</li>
 <li> <code>scipy.sparse.dok_matrix</code> for creation via setting matrix entries
<!-- 2DO -->
<!-- Examples to come.... -->
<!-- Exercise: introduce a random numbering of global nodes; need arbitrary, sparse matrix. --></li>
</ul>

<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_fem-solarized004.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_fem-solarized006.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

