.. !split

.. ========= Principles and machinery for approximating functions =========

Many successful numerical methods for differential equations,
including the finite element method,
aim at approximating the unknown function by a sum

.. _Eq:fem:u:

.. math::
   :label: fem:u
        
         u(x) = \sum_{i=0}^N c_i{\psi}_i(x),
        
        

where :math:`{\psi}_i(x)` are prescribed functions and :math:`c_0,\ldots,c_N`
are unknown coefficients to be determined.
Solution methods for differential equations
utilizing :eq:`fem:u` must
have a *principle* for constructing :math:`N+1` equations to
determine :math:`c_0,\ldots,c_N`. Then there is a *machinery* regarding
the actual constructions of the equations for :math:`c_0,\ldots,c_N`, in a
particular problem. Finally, there is a *solve* phase for computing
the solution :math:`c_0,\ldots,c_N` of the :math:`N+1` equations.

Especially in the finite element method, the machinery for constructing
the discrete equations to be implemented on a computer is quite
comprehensive, with many mathematical and implementational
details entering the scene at the
same time. From an ease-of-learning perspective it can therefore be
wise to follow an idea of Larson and Bengzon [Ref1]_
and introduce the computational machinery for a trivial equation:
:math:`u=f`. Solving this equation with :math:`f` given and :math:`u` on the form
:eq:`fem:u` means that we seek an approximation
:math:`u` to :math:`f`.
This approximation problem has the advantage of introducing most of the
finite element toolbox, but with postponing demanding topics related to
differential equations (e.g., integration by parts, boundary conditions,
and coordinate mappings).
This is the reason why we shall first become familiar
with finite element *approximation* before addressing
finite element methods for differential equations.

First, we refresh some linear algebra concepts about approximating
vectors in vector spaces. Second, we extend these concepts to
approximating functions in function spaces, using the same
principles and the same notation.
We present examples on approximating functions by  global basis functions with
support throughout the entire domain.
Third, we introduce the finite element type of local basis functions
and explain the computational algorithms for working with such functions.
Three types of approximation principles are covered: 1) the least squares
method, 2) the :math:`L_2` projection or Galerkin method,
and 3) interpolation or collocation.

