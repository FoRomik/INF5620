
# Information about all exercises in the file main_vib.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_vib.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['vib_undamped_verify_mms.pdf', 'vib_undamped_verify_mms.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:verify:linquad',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Derive the equation for the\nfirst time step ($u^1$).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'For verification purposes,\nwe use the method of manufactured solutions (MMS) with the\nchoice of $\\uex(x,t)= ct+d$.\nFind restrictions on $c$ and $d$ from\nthe initial conditions. Compute the corresponding source term $f$ by term.\nShow that $[D_tD_t t]^n=0$ and use the fact\nthat the $D_tD_t$ operator is linear,\n$[D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0$, to show that\n$\\uex$ is also a perfect solution of the discrete equations.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Use `sympy` to do the symbolic calculations above. Here is a\nsketch of the program `vib_undamped_verify_mms.py`:\n\n!bc pycod\nimport sympy as sp\nV, t, I, w, dt = sp.symbols(\'V t I w dt\')  # global symbols\nf = None  # global variable for the source term in the ODE\n\ndef ode_source_term(u):\n    """Return the terms in the ODE that the source term\n    must balance, here u\'\' + w**2*u.\n    u is symbolic Python function of t."""\n    return sp.diff(u(t), t, t) + w**2*u(t)\n\ndef residual_discrete_eq(u):\n    """Return the residual of the discrete eq. with u inserted."""\n    R = ...\n    return sp.simplify(R)\n\ndef residual_discrete_eq_step1(u):\n    """Return the residual of the discrete eq. at the first\n    step with u inserted."""\n    R = ...\n    return sp.simplify(R)\n\ndef DtDt(u, dt):\n    """Return 2nd-order finite difference for u_tt.\n    u is a symbolic Python function of t.\n    """\n    return ...\n\ndef main(u):\n    """\n    Given some chosen solution u (as a function of t, implemented\n    as a Python function), use the method of manufactured solutions\n    to compute the source term f, and check if u also solves\n    the discrete equations.\n    """\n    print \'=== Testing exact solution: %s ===\' % u\n    print "Initial conditions u(0)=%s, u\'(0)=%s:" % \\ \n          (u(t).subs(t, 0), sp.diff(u(t), t).subs(t, 0))\n\n    # Method of manufactured solution requires fitting f\n    global f  # source term in the ODE\n    f = sp.simplify(ode_lhs(u))\n\n    # Residual in discrete equations (should be 0)\n    print \'residual step1:\', residual_discrete_eq_step1(u)\n    print \'residual:\', residual_discrete_eq(u)\n\ndef linear():\n    main(lambda t: V*t + I)\n\nif __name__ == \'__main__\':\n    linear()\n\n!ec\nFill in the various functions such that the calls in the `main`\nfunction works.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The purpose now is to choose a quadratic function\n$\\uex = bt^2 + ct + d$ as exact solution. Extend the `sympy`\ncode above with a function `quadratic` for fitting `f` and checking\nif the discrete equations are fulfilled. (The function is very similar\nto `linear`.)\n\n#Check with hand calculations that the `sympy` implementation\n#is correct.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Will a polynomial of degree three fulfill the discrete equations?'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement a `solver` function for computing the numerical\nsolution of this problem.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a nose test for checking that the quadratic solution\nis computed to correctly (too machine precision, but the\nround-off errors accumulate and increase with $T$) by the `solver`\nfunction.'}],
  'text': 'Consider the ODE problem\n\n!bt\n\\[ u^{\\prime\\prime} + \\omega^2u=f(t), \\quad u(0)=I,\\ u^{\\prime}(0)=V,\\ t\\in(0,T]\\tp\\]\n\n!et\nDiscretize this equation according to\n$[D_tD_t u + \\omega^2 u = f]^n$.',
  'title': 'Use linear/quadratic functions for verification',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_phase_error_growth.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:phase:err:growth',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider an exact solution $I\\cos (\\omega t)$ and an\napproximation $I\\cos(\\tilde\\omega t)$.\nDefine the phase error as time lag between the peak $I$\nin the exact solution and the corresponding peak in the approximation\nafter $m$ periods of oscillations. Show that this phase error\nis linear in $m$.',
  'title': 'Show linear growth of the phase with time',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_adjust_w.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:w:adjust',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'According to (ref{vib:ode1:tildeomega:series}), the numerical\nfrequency deviates from the exact frequency by a (dominating) amount\n$\\omega^3\\Delta t^2/24 >0$. Replace the `w` parameter in the algorithm\nin the `solver` function in `vib_undamped.py` by `w*(1 -\n(1./24)*w**2*dt**2` and test how this adjustment in the numerical\nalgorithm improves the accuracy (use $\\Delta t =0.1$ and simulate\nfor 80 periods, with and without adjustment of $\\omega$).',
  'title': 'Improve the accuracy by adjusting the frequency',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_undamped_adaptive.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:adaptive',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Adaptive methods for solving ODEs aim at adjusting $\\Delta t$ such\nthat the error is within a user-prescribed tolerance. Implement the\nequation $u^{\\prime\\prime}+u=0$ in the "Odespy": "https://github.com/hplgit/odespy"\nsoftware. Use the example ref[from Section\nref{decay:fd2:adaptiveRK}][in cite{Langtangen:deq:decay}]["on adaptive\nschemes": "http://tinyurl.com/opdfafk/pub/sphinx-decay/._main_decay007.html#example-adaptive-runge-kutta-methods"\nin cite{Langtangen:deq:decay}].  Run the scheme with a very low\ntolerance (say $10^{-14}$) and for a long time, check the number of\ntime points in the solver\'s mesh (`len(solver.t_all)`), and compare\nthe phase error with that produced by the simple finite difference\nmethod from Section ref{vib:ode1:fdm} with the same number of (equally\nspaced) mesh points. The question is whether it pays off to use an\nadaptive solver or if equally many points with a simple method gives\nabout the same accuracy.',
  'title': 'See if adaptive methods improve the phase error',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_first_step.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:step4b:alt',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'As an alternative to the derivation of (ref{vib:ode1:step4b}) for\ncomputing $u^1$, one can use a Taylor polynomial with three terms\nfor $u^1$:\n\n!bt\n\\[ u(t_1) \\approx u(0) + u^{\\prime}(0)\\Delta t + {\\half}u^{\\prime\\prime}(0)\\Delta t^2\\]\n\n!et\nWith $u^{\\prime\\prime}=-\\omega^2 u$ and $u^{\\prime}(0)=0$, show that this method also leads to\n(ref{vib:ode1:step4b}). Generalize the condition on $u^{\\prime}(0)$ to\nbe $u^{\\prime}(0)=V$ and compute $u^1$ in this case with both methods.',
  'title': 'Use a Taylor polynomial to compute $u^1$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_largest_wdt.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:wdt:limit',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': '# Short: Find the largest relevant value of $\\omega\\Delta t$\n\n\nSketch the function on a given mesh which has the highest possible\nfrequency. That is, this oscillatory "cos-like" function has its\nmaxima and minima at every two grid points.  Find an expression for\nthe frequency of this function, and use the result to find the largest\nrelevant value of $\\omega\\Delta t$ when $\\omega$ is the frequency\nof an oscillating function and $\\Delta t$ is the mesh spacing.',
  'title': 'Find the minimal resolution of an oscillatory function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_plot_fd_exp_error.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:fd:exp:plot',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': '# Short: Visualize the accuracy of finite differences\n\n\nWe introduce the error fraction\n!bt\n\\[ E = \\frac{[D_tD_t u]^n}{u^{\\prime\\prime}(t_n)} \\]\n\n!et\nto measure the error in the finite difference approximation $D_tD_tu$ to\n$u^{\\prime\\prime}$.\nCompute $E$\nfor the specific choice of a cosine/sine function of the\nform $u=\\exp{(i\\omega t)}$ and show that\n!bt\n\\[ E = \\left(\\frac{2}{\\omega\\Delta t}\\right)^2\n\\sin^2(\\frac{\\omega\\Delta t}{2})\n\\tp\n\\]\n\n!et\nPlot $E$ as a function of $p=\\omega\\Delta t$. The relevant\nvalues of $p$ are $[0,\\pi]$ (see Exercise ref{vib:exer:wdt:limit}\nfor why $p>\\pi$ does not make sense).\nThe deviation of the curve from unity visualizes the error in the\napproximation. Also expand $E$ as a Taylor polynomial in $p$ up to\nfourth degree (use, e.g., `sympy`).',
  'title': 'Visualize the accuracy of finite differences for a cosine function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['test_error_conv.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:energy:convrate',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the ODE problem $u^{\\prime\\prime} + \\omega^2u=0$, $u(0)=I$, $u^{\\prime}(0)=V$,\nfor $t\\in (0,T]$. The total energy of the solution\n$E(t)=\\half(u^{\\prime})^2 + \\half\\omega^2 u^2$ should stay\nconstant.\nThe error in energy can be computed as explained in\nSection ref{vib:model1:energy}.\n\nMake a nose test in a file `test_error_conv.py`, where code from\n`vib_undamped.py` is imported, but the `convergence_rates` and\n`test_convergence_rates` functions are copied and modified to also\nincorporate computations of the error in energy and the convergence\nrate of this error. The expected rate is 2.',
  'title': 'Verify convergence rates of the error in energy',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_verify_mms.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:verify:gen:linear',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'This exercise is a generalization of Problem\nref{vib:exer:undamped:verify:linquad} to the extended model problem\n(ref{vib:ode2}) where the damping term is either linear or quadratic.\nSolve the various subproblems and see how the results and problem\nsettings change with the generalized ODE in case of linear or\nquadratic damping. By modifying the code from Problem\nref{vib:exer:undamped:verify:linquad}, `sympy` will do most\nof the work required to analyze the generalized problem.',
  'title': 'Use linear/quadratic functions for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['test_vib_undamped_exact_discrete_sol.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:discrete:omega',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Write a nose test function in a separate file\nthat employs the exact discrete solution\n(ref{vib:ode1:un:exact}) to verify the implementation of the\n`solver` function in the file `vib_undamped.py`.',
  'title': 'Use an exact discrete solution for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_conv_rate.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:conv:rate',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to perform convergence tests of the\nproblem (ref{vib:ode2}) when $s(u)=\\omega^2u$ and $F(t)=A\\sin\\phi t$.\nFind the complete analytical solution to the problem in this case\n(most textbooks on mechanics or ordinary differential equations list\nthe various elements you need to write down the exact solution).\nModify the `convergence_rate` function from the `vib_undamped.py`\nprogram to perform experiments with the extended model.  Verify that\nthe error is of order $\\Delta t^2$.',
  'title': 'Use analytical solution for convergence rate tests',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_amplitude_errors.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:odespy',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Use the program `vib_undamped_odespy.py` from Section ref{vib:undamped:1stODE}\nand the amplitude estimation from the `amplitudes` function\nin the `vib_undamped.py` file (see Section ref{vib:ode1:empirical})\nto investigate how well famous methods for 1st-order ODEs\ncan preserve the amplitude of $u$ in undamped oscillations.\nTest, for example, the 3rd- and 4th-order Runge-Kutta methods\n(`RK3`, `RK4`), the Crank-Nicolson method (`CrankNicolson`),\nthe 2nd- and 3rd-order Adams-Bashforth methods (`AdamsBashforth2`,\n`AdamsBashforth3`), and a 2nd-order Backwards scheme (`Backward2Step`).\nThe relevant governing equations are listed in\nSection ref{vib:model2x2:ueq}.',
  'title': 'Investigate the amplitude errors of many solvers',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_memsave.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:memsave',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The program "`vib.py`": "http://tinyurl.com/nm5587k/vib/vib.py"\nstore the complete solution $u^0,u^1,\\ldots,u^{N_t}$ in memory, which is\nconvenient for later plotting.\nMake a memory minimizing version of this program where only the last three\n$u^{n+1}$, $u^n$, and $u^{n-1}$ values are stored in memory.\nWrite each computed $(t_{n+1}, u^{n+1})$ pair to file.\nVisualize the data in the file (a cool solution is to\nread one line at a time and\nplot the $u$ value using the line-by-line plotter in the\n`visualize_front_ascii` function - this technique makes it trivial\nto visualize very long time simulations).',
  'title': 'Minimize memory usage of a vibration solver',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_class.py'],
  'heading': '=====',
  'hints': ['Use the ideas and examples\nref[from Section ref{decay:prog:se:class} and ref{decay:prog:se:class2}][in cite{Langtangen:deq:decay}][for an "ODE model": "http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#implementing-simple-problem-and-solver-classes"].\nMore specifically, make a superclass `Problem` for holding the scalar\nphysical parameters of a problem and let subclasses implement the\n$s(u)$ and $F(t)$ functions as methods.\nTry to call up as much existing functionality in `vib.py` as possible.'],
  'keywords': None,
  'label': 'vib:exer:gen:class',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Reimplement the `vib.py`\nprogram\nusing a class `Problem` to hold all the physical parameters of the problem,\na class `Solver` to hold the numerical parameters and compute the\nsolution, and a class `Visualizer` to display the solution.',
  'title': 'Implement the solver via classes',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_DtDt_fw_bw.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:DtDt:asDtpDtm',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Show that the difference $[D_t D_tu]^n$ is equal to $[D_t^+D_t^-u]^n$\nand $D_t^-D_t^+u]^n$. That is, instead of applying a centered difference\ntwice one can alternatively apply a mixture forward and backward\ndifferences.',
  'title': 'Interpret $[D_tD_t u]^n$ as a forward-backward difference',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_gen_bwdamping.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:quad:damping:fwbw',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the generalized model with quadratic damping, expressed\nas a system of two first-order equations as in Section ref{vib:ode2:staggered}:\n\n!bt\n\\begin{align*}\nu^{\\prime} &= v,\\\\ \nv\' &= \\frac{1}{m}\\left( F(t) - \\beta |v|v - s(u)\\right)\\tp\n\\end{align*}\n\n!et\nHowever, contrary to what is done in Section ref{vib:ode2:staggered},\nwe want to apply the idea of the forward-backward discretization\nin Section ref{vib:model2x2:EulerCromer}. Express the idea in operator\nnotation and write out the scheme. Unfortunately, the backward\ndifference for the $v$ equation creates a nonlinearity $|v^{n+1}|v^{n}$.\nTo linearize this nonlinearity, use the known value $v^n$ inside\nthe absolute value factor, i.e., $|v^{n+1}|v^{n}\\approx |v^n|v^{n+1}$.\nShow that the resulting scheme is equivalent to the one in\nSection ref{vib:ode2:staggered} for some time level $n\\geq 1$.\n\nWhat we learn from this exercise is that the first-order differences\nand the linearization trick play together in "the right way" such that\nthe scheme is as good as when we (in Section ref{vib:ode2:staggered})\ncarefully apply centered differences and a geometric mean on a\nstaggered mesh to achieve second-order accuracy.  There is a\ndifference in the handling of the initial conditions, though, as\nexplained at the end of Section ref{vib:model2x2:EulerCromer}.',
  'title': 'Use the forward-backward scheme with quadratic damping',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vib_gen_bwdamping.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:quad:damping:bw',
  'no': 17,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'As an alternative to discretizing the damping terms $\\beta u^{\\prime}$ and\n$\\beta |u^{\\prime}|u^{\\prime}$ by centered differences, we may apply\nbackward differences:\n\n!bt\n\\begin{align*}\n[u^{\\prime}]^n &\\approx [D_t^-u]^n,\\\\ \n& [|u^{\\prime}|u^{\\prime}]^n &\\approx [|D_t^-u|D_t^-u]^n\n= |[D_t^-u]^n|[D_t^-u]^n\\tp\n\\end{align*}\n\n!et\nThe advantage of the backward difference is that the damping term is\nevaluated using known values $u^n$ and $u^{n-1}$ only.\nExtend the "`vib.py`": "http://tinyurl.com/nm5587k/vib/vib.py" code with a scheme based\non using backward differences in the damping terms. Add statements\nto compare the original approach with centered difference and the\nnew idea launched in this exercise. Perform numerical experiments\nto investigate how much accuracy that is lost by using the backward\ndifferences.',
  'title': 'Use a backward difference for the damping term',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['bouncing_ball.py'],
  'heading': '=====',
  'hints': ['A naive implementation may get stuck in repeated impacts for large time\nstep sizes. To avoid this situation, one can introduce a state\nvariable that holds the mode of the motion: free fall, impact, or rest.\nTwo consecutive impacts imply that the motion has stopped.'],
  'keywords': None,
  'label': 'vib:exer:bouncing:ball',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'A bouncing ball is a body in free vertically fall until it impacts the\nground. During the impact, some kinetic energy is lost, and a new\nmotion upwards with reduced velocity starts.  At some point the\nvelocity close to the ground is so small that the ball is considered\nto be finally at rest.\n\nThe motion of the ball falling in air is governed by Newton\'s second\nlaw $F=ma$, where $a$ is the acceleration of the body, $m$ is the mass,\nand $F$ is the sum of all forces. Here, we neglect the air resistance\nso that gravity $-mg$ is the only force. The height of the ball is\ndenoted by $h$ and $v$ is the velocity. The relations between $h$, $v$, and\n$a$,\n\n!bt\n\\[ h\'(t)= v(t),\\quad v\'(t) = a(t),\\]\n\n!et\ncombined with Newton\'s second law gives the ODE model\n\n!bt\n\\begin{equation}\nh^{\\prime\\prime}(t) = -g,\nlabel{vib:exer:bouncing:ball:h2eq}\n\\end{equation}\n\n!et\nor expressed alternatively as a system of first-order equations:\n\n!bt\n\\begin{equation}\nv\'(t) = -g,\nlabel{vib:exer:bouncing:ball:veq} \n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \nh\'(t) = v(t)\\tp\nlabel{vib:exer:bouncing:ball:heq}\n\\end{equation}\n\n!et\nThese equations govern the motion as long as the ball is away from\nthe ground by a small distance $\\epsilon_h > 0$. When $h<\\epsilon_h$,\nwe have two cases.\n\n o The ball impacts the ground, recognized by a sufficiently large negative\n   velocity ($v<-\\epsilon_v$). The velocity then changes sign and is\n   reduced by a factor $C_R$, known as the "coefficient of restitution":\n   "http://en.wikipedia.org/wiki/Coefficient_of_restitution".\n   For plotting purposes, one may set $h=0$.\n o The motion stops, recognized by a sufficiently small velocity\n   ($|v|<\\epsilon_v$) close to the ground.\n\nChoose one of the models, (ref{vib:exer:bouncing:ball:h2eq}) or\n(ref{vib:exer:bouncing:ball:veq})-(ref{vib:exer:bouncing:ball:heq}),\nand simulate a bouncing ball. Plot $h(t)$. Think about how to\nplot $v(t)$.',
  'title': 'Simulate a bouncing ball',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['elastic_pendulum.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:elastic:pendulum',
  'no': 19,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': ['The associated classical pendulum, for large $k$, has an equation\n$\\ddot\\theta + g/L_0\\theta =0$. With $g=L_0$, the period is $2\\pi$:\n$\\theta(t) = \\theta_0\\cos(t)$. One can compare in a plot the angle\nof the elastic solution ($\\theta = \\tan^{-1}x/(L_0-y)$)\nwith the solution of the classical pendulum problem.',
                       'The equation of motion is subject to round-off errors for large $k$,\nbecause $s$ is then small such that $ks$ is a product of a large and\na small number. Moreover, in this stiff case,\n$m^{-1}ksn_y$ is close to $g$ such that we\nalso subtract two almost equal numbers in the force term in the\nequation. For the given parameters, $k=150$ is a large value and\ngives a solution close to the motion of a perfect classical pendulum.\nMuch larger values gives unstable solutions.'],
             'solution': '',
             'text': 'Write a code that can simulate such an elastic pendulum. Plot\n$y$ against $x$ in a plot with the same length scale on the\naxis such that we get a correct picture of the motion.\nAlso plot the angle the pendulum: $\\theta = \\tan^{-1}x/(L_0-y)$.\n\nA possible set of parameters is $L_0=9.81$ m, $m=1$ kg, $theta_0=30$\ndegrees.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Air resistance is a force $\\frac{1}{2}\\varrho C_D A||bm{v}||\\boldsymbol{v}$,\nwhere $C_D$ is a drag coefficient (0.2 for a sphere), $\\varrho$\nis the density of air (1.2 $\\hbox{kg }\\,{\\hbox{m}}^{-3}$), $A$ is the\ncross section area ($A=\\pi R^2$ for a sphere, where $R$ is the radius),\nand $\\boldsymbol{v}$ is the velocity: $\\boldsymbol{v} = \\dot{\\boldsymbol{r}}$.\nInclude air resistance in the model and show plots comparing the\nmotion with and without air resistance.'}],
  'text': "Consider an elastic pendulum fixed to the point $\\boldsymbol{r}_0=(0,L_0)$.\nThe length of the pendulum wire when not stretched is $L_0$.\nThe wire is massless and always straight. At the end point\n$\\boldsymbol{r}$, we have a mass $m$.\nStretching the elastic wire a distance $s$\ngives rise to a spring force $ks$ in the opposite direction of the\nstretching. Let $\\boldsymbol{n}$ be a unit normal vector along the wire:\n\n!bt\n\\[ \\boldsymbol{n} = \\frac{\\boldsymbol{r}-\\boldsymbol{r}_0}{||\\boldsymbol{r}-\\boldsymbol{r}_0||}\\tp\\]\n\n!et\nThe stretch $s$ in the wire is the current length $||\\boldsymbol{r}-\\boldsymbol{r}_0||$\nat some time $t$ minus the original length $L_0$:\n\n!bt\n\\[ s = ||\\boldsymbol{r}-\\boldsymbol{r}_0|| - L_0\\tp\\]\n\n!et\nThe force in the wire is then $\\boldsymbol{F}_w=-ks\\boldsymbol{n}$.\nNewton's second law of motion applied to the mass results in\n\n!bt\n\\begin{equation}\nm\\ddot{\\boldsymbol{r}} = -ks\\boldsymbol{n} - mg\\boldsymbol{j},\nlabel{vib:exer:elastic:pendulum:eq1}\n\\end{equation}\n\n!et\nwhere $\\boldsymbol{j}$ is a unit vector in the upward vertical direction.\nLet $\\boldsymbol{r}=(x,y)$ and $\\boldsymbol{n}=(n_x,n_y)$. The two components of\n(ref{vib:exer:elastic:pendulum:eq1}) then becomes\n\n!bt\n\\begin{equation}\n\\ddot x = -m^{-1}ksn_x,\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \nlabel{vib:exer:elastic:pendulum:eq2a} \n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\ddot y = - m^{-1}ksn_y - g\nlabel{vib:exer:elastic:pendulum:eq2b}\\tp\n\\end{equation}\n\n!et\nThe mass point $(x,y)$ will undergo a two-dimensional motion, but\nif the wire is stiff (large $k$), the elastic pendulum will approach\nthe classical one where the mass point moves along a circle.\nHowever, the elastic pendulum is modeled by a direct application of\nNewton's second law, because the force in the wire is known (as a\nfunction of the motion), while the classical pendulum involves\nconstrained motion, which requires elimination of an unknown via\nthe constraint (by invoking polar coordinates).\n\nIn equilibrium, the mass hangs in the position $(0,y_0)$ determined by\n\n!bt\n\\[ 0 = - m^{-1}ksn_y - g = m^{-1}k(y_0-L_0) - g\\quad\\Rightarrow\\quad\ny_0 = L_0 + mg/k = L\\tp\\]\n\n!et\nWe then displace the mass an angle $\\theta_0$ to the right. The initial\nposition $(x(0),y(0))$ then becomes\n\n!bt\n\\[ x(0)=L\\sin\\theta_0,\\quad y(0)=L_0 - L\\cos\\theta_0\\tp\\]\n\n!et\nThe velocity is zero, $x'(0)=y'(0)=0$.",
  'title': 'Simulate an elastic pendulum',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': ["Use an ``ansatz'' $u^n=I\\exp{(i\\tilde\\omega\\Delta t\\,n)}$ and\n$v^=qu^n$, where $\\tilde\\omega$ and $q$ are unknown parameters. The formula\n\n139 <<<!!MATH_BLOCK\nbecomes handy."],
  'keywords': None,
  'label': 'vib:exer:EulerCromer:analysis',
  'no': 20,
  'solution': 'We follow the ideas in Section ref{vib:ode1:analysis}. Inserting\n$u^n=I\\exp{(i\\tilde\\omega\\Delta t\\,n)}$ and\n$v^=qu^n$ in\n(ref{vib:model2x2:EulerCromer:ueq1b})-(ref{vib:model2x2:EulerCromer:veq1b})\nand dividing by $I\\exp{(i\\tilde\\omega\\Delta t\\,n)}$ gives\n\n!bt\n\\begin{equation}\nq\\exp{(i\\tilde\\omega\\Delta t)} = q - \\omega^2 \\Delta t,\nlabel{vib:exer:EulerCromer:analysis:equ} \n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\exp{(i\\tilde\\omega\\Delta t)} = 1 + \\Delta t\\, q\\exp{(i\\tilde\\omega\\Delta t)}\nlabel{vib:exer:EulerCromer:analysis:eqv}\\tp\n\\end{equation}\n\n!et\nSolving (ref{vib:exer:EulerCromer:analysis:eqv}) with respect to $q$ gives\n\n!bt\n\\[ q = \\frac{1}{\\Delta t}\\left( 1 - \\exp{(i\\tilde\\omega\\Delta t)} \\right)\\tp\\]\n\n!et\nInserting this expression for $q$ in (ref{vib:exer:EulerCromer:analysis:equ})\nresults in\n\n!bt\n\\[ \\exp{(i\\tilde\\omega\\Delta t)} + \\exp{(-i\\tilde\\omega\\Delta t)} -2\n= - \\omega^2\\Delta t^2\\tp\\]\n\n!et\nUsing the relation\n$\\exp{(i\\tilde\\omega(\\Delta t))} + \\exp{(i\\tilde\\omega(-\\Delta t))} - 2\n= -4\\sin^2(\\frac{\\tilde\\omega\\Delta t}{2})$ gives\n\n!bt\n\\[ -4\\sin^2(\\frac{\\tilde\\omega\\Delta t}{2}) = - \\omega^2\\Delta t^2,\\]\n\n!et\nor after dividing by 4,\n\n!bt\n\\[\n\\sin^2(\\frac{\\tilde\\omega\\Delta t}{2}) = \\left(\\frac{1}{2}\\omega\\Delta t\\right)^2,\\]\n\n!et\nwhich is the same equation for $\\tilde\\omega$ as found in\nSection ref{vib:ode1:analysis}, such that $\\tilde\\omega$ is the\nsame. The accuracy, stability, and formula for the exact discrete solution\nare then all the same as derived in Section ref{vib:ode1:analysis}.\n#This proves that the solution of the Euler-Cromer scheme\n#coincides',
  'solution_file': None,
  'subex': [],
  'text': 'The Euler-Cromer scheme for the model problem\n$u^{\\prime\\prime} + \\omega^2 u =0$, $u(0)=I$, $u^{\\prime}(0)=0$, is given in\n(ref{vib:model2x2:EulerCromer:ueq1b})-(ref{vib:model2x2:EulerCromer:veq1b}).\nFind the exact discrete solutions of this scheme and show that the solution\nfor $u^n$ coincides with that found in Section ref{vib:ode1:analysis}.',
  'title': 'Analysis of the Euler-Cromer scheme',
  'type': 'Exercise',
  'type_visible': True}]