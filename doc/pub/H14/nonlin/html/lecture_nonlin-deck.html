<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Solving nonlinear ODE and PDE problems">
<meta name="keywords" content="linearization explicit time integration,Picard iteration,successive substitutions,linearization Picard iteration,fixed-point iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),group finite element method,product approximation technique,continuation method">

<title>Study guide: Solving nonlinear ODE and PDE problems</title>







<!-- deck.js: https://github.com/imakewebthings/deck.js -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=1024, user-scalable=no">

<!-- Required stylesheet -->
<link rel="stylesheet" href="deck.js/core/deck.core.css">

<!-- Extension CSS files go here. Remove or add as needed.
deck.goto: Adds a shortcut key to jump to any slide number.
Hit g, type in the slide number, and hit enter.

deck.hash: Enables internal linking within slides, deep
linking to individual slides, and updates the address bar and
a permalink anchor with each slide change.

deck.menu: Adds a menu view, letting you see all slides in a grid.
Hit m to toggle to menu view, continue navigating your deck,
and hit m to return to normal view. Touch devices can double-tap
the deck to switch between views.

deck.navigation: Adds clickable left and right buttons for the
less keyboard inclined.

deck.status: Adds a page number indicator. (current/total).

deck.scale: Scales each slide to fit within the deck container
using CSS Transforms for those browsers that support them.

deck.pointer: Turn mouse into laser pointer (toggle with p).
(Requires https://github.com/mikeharris100/deck.pointer.js)
-->

<link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
<link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
<link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">
<link rel="stylesheet" href="deck.js/extensions/pointer/deck.pointer.css">
<link rel="stylesheet" href="deck.js/extensions/notes/deck.notes.css">
<!--
<link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
<link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
<link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
-->

<!-- Style theme. More available in themes/style/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">

<!--
<link rel="stylesheet" href="deck.js/themes/style/neon.css">
<link rel="stylesheet" href="deck.js/themes/style/swiss.css">
<link rel="stylesheet" href="deck.js/themes/style/web-2.0.css">

git clone git://github.com/duijf/mnml.git
<link rel="stylesheet" href="deck.js/themes/style/mnml.css">

git://github.com/groovecoder/deckjs-theme-mozilla.git
<link rel="stylesheet" href="deck.js/themes/style/sandstone.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.aurora.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.dark.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.firefox.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.light.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.mdn.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.nightly.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.cbc.css">

git://github.com/barraq/deck.ext.js.git
<link rel="stylesheet" href="deck.js/themes/style/beamer.css">
-->

<!--
Transition theme. More available in /themes/transition/ or create your own. -->
<!--
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/fade.css">
<link rel="stylesheet" href="deck.js/themes/transition/vertical-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
-->

<!-- Required Modernizr file -->
<script src="deck.js/modernizr.custom.js"></script>

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */

hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
     padding:8px 35px 8px 14px; margin-bottom:18px;
     text-shadow:0 1px 0 rgba(255,255,255,0.5);
     border:5px solid #bababa;
       -webkit-border-radius:14px; -moz-border-radius:14px;
     border-radius:14px
     background-position: 10px 10px;
     background-repeat: no-repeat;
     background-size: 38px;
     padding-left: 30px; /* 55px; if icon */
 }
 .slide .alert-block {padding-top:14px; padding-bottom:14px}
 .slide .alert-block > p, .alert-block > ul {margin-bottom:0}
 /*.slide .alert li {margin-top: 1em}*/
 .deck .alert-block p+p {margin-top:5px}
 /*.slide .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_notice.png); }
 .slide .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_summary.png); }
 .slide .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_warning.png); }
 .slide .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body class="deck-container">

<header>
<!-- Here goes a potential header -->
</header>

<!-- do not use the article tag - it gives strange sizings -->





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    



<section class="slide">
<!-- ------------------- main content ---------------------- -->



<h2 style="text-align: center;">Study guide: Solving nonlinear ODE and PDE problems</h2>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b style="font-weight: bold">Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b style="font-weight: bold">Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b style="font-weight: bold">Department of Informatics, University of Oslo</b></center>
<p>
<center><b style="font-weight: bold">Dec 14, 2014</b></center> <!-- date -->
<p>

</section>


<section class="slide">

<h2>What makes a differential equations nonlinear?  <a name="___sec0"></a></h2>

<ul>
 <p><li> In linear differential equations, the unknown \( u \) or its derivatives
   appear in linear terms \( au(t) \), \( au'(t) \), \( a\nabla^2u \),
   where \( a \) is independent of \( u \).</li>
 <p><li> All other types of terms containing \( u \) are <em>nonlinear</em> and contain
   <font color="red">products of \( u \) or its derivatives</font>.</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Examples on linear and nonlinear differential equations  <a name="___sec1"></a></h2>

<p>
Linear ODE:

<p>&nbsp;<br>
$$ u^{\prime} (t) = a(t)u(t) + b(t)$$
<p>&nbsp;<br>


<p>
Nonlinear ODE:

<p>&nbsp;<br>
$$ u^{\prime}(t) = u(t)(1 - u(t)) = u(t) - {\color{red}u(t)^2}$$
<p>&nbsp;<br>


<p>
This (pendulum) ODE is also nonlinear:

<p>&nbsp;<br>
$$ u^{\prime\prime} + \gamma\sin u = 0$$
<p>&nbsp;<br>

because

<p>&nbsp;<br>
$$ \sin u = u - \frac{1}{6}u^3 + \Oof{u^5},$$
<p>&nbsp;<br>

contains products of \( u \)

<p>

</section>


<section class="slide">

<h1 style="text-align: center;">Introduction of basic concepts <a name="nonlin:timediscrete:logistic"></a></h1>

<ul>
 <p><li> Logistic ODE as simple model for a nonlinear problem</li>
 <p><li> Introduction of basic techniques:</li>

<ul>
   <p><li> Explicit time integration (no nonlinearities)</li>
   <p><li> Implicit time integration (nonlinearities)</li>
   <p><li> Linearization and Picard iteration</li>
   <p><li> Linearization via Newton's method</li>
   <p><li> Linearization via a trick like geometric mean</li>
</ul>
<p>

 <p><li> Numerical illustration of the performance</li>
</ul>
<p>


</section>


<section class="slide">

<h2>The scaled logistic ODE  <a name="___sec3"></a></h2>

<p>&nbsp;<br>
$$ u^{\prime}(t) = u(t)(1 - u(t)) = u - {\color{red}u^2}$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Linearization by explicit time discretization <a name="nonlin:timediscrete:logistic:FE"></a></h2>

<p>
Forward Euler method:

<p>&nbsp;<br>
$$ \frac{u^{n+1} - u^n}{\Delta t} = u^n(1 - u^n)$$
<p>&nbsp;<br>


<p>
gives a <em>linear</em> algebraic
equation for the unknown value \( u^{n+1} \)!

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>
Explicit time integration methods will (normally) linearize
a nonlinear problem.
</div>


<p>
Another example: 2nd-order Runge-Kutta method

<p>&nbsp;<br>
$$
\begin{align*}
u^* &= u^n + \Delta t u^n(1 - u^n),\\ 
u^{n+1} &= u^n + \Delta t \half \left(
u^n(1 - u^n) + u^*(1 - u^*))
\right)\tp
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>An implicit method: Backward Euler discretization <a name="nonlin:timediscrete:logistic:roots"></a></h2>

<p>
A backward time difference

<p>&nbsp;<br>
$$ \frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^n) $$
<p>&nbsp;<br>


<p>
gives a <em>nonlinear</em> algebraic equation for the unknown \( u^n \).
The equation is of quadratic type (which can easily be solved exactly):

<p>&nbsp;<br>
$$ \Delta t (u^n)^2 + (1-\Delta t)u^n - u^{n-1} = 0 $$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Detour: new notation  <a name="___sec6"></a></h2>

<p>
To make formulas less overloaded and the mathematics as close as
possible to computer code, a new notation is introduced:

<ul>
 <p><li> \( u^{(1)} \) means \( u^{n-1} \)</li>
 <p><li> In general: \( u^{(\ell)} \) means \( u^{n-\ell} \)</li>
 <p><li> \( u \) is the unknown (\( u^n \))</li>
</ul>
<p>

Nonlinear equation to solve in new notation:

<p>&nbsp;<br>
$$
F(u) = \Delta t u^2 + (1-\Delta t)u - u^{(1)} = 0
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Exact solution of quadratic nonlinear equations  <a name="___sec7"></a></h2>

<p>
Solution of \( F(u)=0 \):

<p>&nbsp;<br>
$$
u = \frac{1}{2\Delta t}
\left(-1+\Delta t \pm \sqrt{(1-\Delta t)^2 - 4\Delta t u^{(1)}}\right)
$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b style="font-weight: bold">Observation:</b>
<p>
Nonlinear algebraic equations may have multiple solutions!
</div>


<p>

</section>


<section class="slide">

<h2>How do we pick the right solution in this case?  <a name="___sec8"></a></h2>

<p>
Let's investigate the nature of the two roots:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sp</span>
&gt;&gt;&gt; dt, u_1, u = sp.symbols(<span style="color: #CD5555">&#39;dt u_1 u&#39;</span>)
&gt;&gt;&gt; r1, r2 = sp.solve(dt*u**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">1</span>-dt)*u - u_1, u)  <span style="color: #228B22"># find roots</span>
&gt;&gt;&gt; r1
(dt - sqrt(dt**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">4</span>*dt*u_1 - <span style="color: #B452CD">2</span>*dt + <span style="color: #B452CD">1</span>) - <span style="color: #B452CD">1</span>)/(<span style="color: #B452CD">2</span>*dt)
&gt;&gt;&gt; r2
(dt + sqrt(dt**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">4</span>*dt*u_1 - <span style="color: #B452CD">2</span>*dt + <span style="color: #B452CD">1</span>) - <span style="color: #B452CD">1</span>)/(<span style="color: #B452CD">2</span>*dt)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> r1.series(dt, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>)
-<span style="color: #B452CD">1</span>/dt + <span style="color: #B452CD">1</span> - u_1 + dt*(u_1**<span style="color: #B452CD">2</span> - u_1) + O(dt**<span style="color: #B452CD">2</span>)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> r2.series(dt, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">2</span>)
u_1 + dt*(-u_1**<span style="color: #B452CD">2</span> + u_1) + O(dt**<span style="color: #B452CD">2</span>)
</pre></div>
<p>
The <code>r1</code> root behaves as \( 1/\Delta t\rightarrow\infty \)
as \( \Delta t\rightarrow 0 \)! Therefore, only the <code>r2</code> root is of
relevance.

<p>

</section>


<section class="slide">

<h2>Linearization  <a name="___sec9"></a></h2>

<ul>
 <p><li> In general, we cannot solve nonlinear algebraic equations
   with formulas</li>
 <p><li> We must <em>linearize</em> the equation, or create a recursive set
   of <em>linearized</em> equations whose solutions hopefully converge
   to the solution of the nonlinear equation</li>
 <p><li> Manual linearization may be an art</li>
 <p><li> Automatic linearization is possible (cf. Newton's method)</li>
</ul>
<p>

Examples will illustrate the points!

<p>

</section>


<section class="slide">

<h2>Picard iteration <a name="nonlin:timediscrete:logistic:Picard"></a></h2>

<p>
Nonliner equation from Backward Euler scheme for logistic ODE:

<p>&nbsp;<br>
$$ F(u) = au^2 + bu + c = 0$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>
Let \( u^{-} \) be an available approximation of the unknown \( u \).
</div>


<p>
Linearization of \( u^2 \): \( u^{-}u \)

<p>&nbsp;<br>
$$ F(u)\approx\hat F(u) = au^{-}u + bu + c = 0$$
<p>&nbsp;<br>


<p>
But

<ul>
 <p><li> Problem: the solution \( u \) of \( \hat F(u)=0 \) is not the exact solution
   of \( F(u)=0 \)</li>
 <p><li> Solution: set \( u^{-}=u \) and repeat the procedure</li>
</ul>
<p>


</section>


<section class="slide">

<h2>The algorithm of Picard iteration  <a name="___sec11"></a></h2>

<p>
At a time level, set \( u^{-}=u^{(1)} \) (solution at previous time level)
and iterate:

<p>&nbsp;<br>
$$ u = -\frac{c}{au^{-} + b},\quad u^{-}\ \leftarrow\ u$$
<p>&nbsp;<br>


<p>
This technique is known as

<ul>
 <p><li> fixed-point iteration</li>
 <p><li> successive substitutions</li>
 <p><li> nonlinear Richardson iteration</li>
 <p><li> <font color="red">Picard iteration</font></li>
</ul>
<p>


</section>


<section class="slide">

<h2>The algorithm of Picard iteration with classical math notation  <a name="___sec12"></a></h2>

<ul>
 <p><li> \( u^k \): computed approximation in iteration \( k \)</li>
 <p><li> \( u^{k+1} \) is the next approximation (unknown)</li>
</ul>
<p>

<p>&nbsp;<br>
$$ au^k u^{k+1} + bu^{k+1} + c = 0\quad\Rightarrow\quad u^{k+1}
= -\frac{c}{au^k + b},\quad k=0,1,\ldots$$
<p>&nbsp;<br>


<p>
Or with a time level \( n \) too:

<p>&nbsp;<br>
$$ au^{n,k} u^{n,k+1} + bu^{n,k+1} - u^{n-1} = 0\quad\Rightarrow\quad u^{n,k+1}
= \frac{u^{n-1}}{au^{n,k} + b},\quad k=0,1,\ldots$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Stopping criteria  <a name="___sec13"></a></h2>

<p>
Using change in solution:

<p>&nbsp;<br>
$$ |u - u^{-}| \leq\epsilon_u$$
<p>&nbsp;<br>


<p>
or change in residual:

<p>&nbsp;<br>
$$ |F(u)|= |au^2+bu + c| < \epsilon_r$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>A single Picard iteration  <a name="___sec14"></a></h2>

<p>
Common simple and cheap technique: perform 1 single Picard iteration

<p>&nbsp;<br>
$$
\frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - {\color{red}u^{n-1}})
$$
<p>&nbsp;<br>


<p>
Inconsistent time discretization (\( u(1-u) \) must be evaluated for
\( n \), \( n-1 \), or \( n-\frac{1}{2} \)) - can produce quite inaccurate results, but
is very popular.

<p>

</section>


<section class="slide">

<h2>Implicit Crank-Nicolson discretization  <a name="___sec15"></a></h2>

<p>
Crank-Nicolson discretization:

<p>&nbsp;<br>
$$ [D_t u = u(1-u)]^{n+\half}$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\frac{u^{n+1}-u^n}{\Delta t} = u^{n+\half} -
(u^{n+\half})^2
$$
<p>&nbsp;<br>


<p>
Approximate \( u^{n+\half} \) as usual by an arithmetic
mean,

<p>&nbsp;<br>
$$ u^{n+\half}\approx \half(u^n + u^{n+1})$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$ (u^{n+\half})^2\approx \frac{1}{4}(u^n + u^{n+1})^2\quad\hbox{(nonlinear term)}$$
<p>&nbsp;<br>


<p>
which is nonlinear in the unknown \( u^{n+1} \).

<p>

</section>


<section class="slide">

<h2>Linearization by a geometric mean <a name="nonlin:timediscrete:logistic:geometric:mean"></a></h2>

<p>
Using a <em>geometric mean</em> for \( (u^{n+\half})^2 \) linearizes
the nonlinear term \( (u^{n+\half})^2 \) (error \( \Oof{\Delta t^2} \) as
in the discretization of \( u^{\prime} \)):

<p>&nbsp;<br>
$$ (u^{n+\half})^2\approx u^nu^{n+1}$$
<p>&nbsp;<br>


<p>
Arithmetic mean on the linear \( u^{n+\frac{1}{2}} \) term and a geometric
mean for \( (u^{n+\half})^2 \) gives a linear equation
for \( u^{n+1} \):

<p>&nbsp;<br>
$$ \frac{{\color{red}u^{n+1}}-u^n}{\Delta t} =
\half(u^n + {\color{red}u^{n+1}}) + u^n{\color{red}u^{n+1}}$$
<p>&nbsp;<br>


<p>
Note: Here we turned a nonlinear algebraic equation into a linear
one. No need for iteration! (Consistent \( \Oof{\Delta t^2} \) approx.)

<p>

</section>


<section class="slide">

<h2>Newton's method <a name="nonlin:timediscrete:logistic:Newton"></a></h2>

<p>
Write the nonlinear algebraic equation as

<p>&nbsp;<br>
$$ F(u) = 0 $$
<p>&nbsp;<br>


<p>
Newton's method: linearize \( F(u) \) by two terms from the Taylor series,

<p>&nbsp;<br>
$$
\begin{align*}
F(u) &= F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) + {\half}F^{\prime\prime}(u^{-})(u-u^{-})^2
+\cdots\\ 
& \approx F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) \equiv \hat F(u)
\end{align*}
$$
<p>&nbsp;<br>


<p>
The linear equation \( \hat F(u)=0 \) has the solution

<p>&nbsp;<br>
$$ u = u^{-} - \frac{F(u^{-})}{F^{\prime}(u^{-})}$$
<p>&nbsp;<br>


<p>
Note that \( \hat F \) in Picard and Newton are different!

<p>

</section>


<section class="slide">

<h2>Newton's method with an iteration index  <a name="___sec18"></a></h2>

<p>&nbsp;<br>
$$ u^{k+1} = u^k - \frac{F(u^k)}{F^{\prime}(u^k)},\quad k=0,1,\ldots$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>
Newton's method exhibits <em>quadratic convergence</em> if
\( u^k \) is sufficiently close to the solution. Otherwise, the method
may diverge.
</div>


<p>

</section>


<section class="slide">

<h2>Using Newton's method on the logistic ODE  <a name="___sec19"></a></h2>

<p>&nbsp;<br>
$$ F(u) = au^2 + bu + c$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$ F^{\prime}(u) = 2au + b$$
<p>&nbsp;<br>


<p>
The iteration method becomes

<p>&nbsp;<br>
$$
u = u^{-} + \frac{a(u^{-})^2 + bu^{-} + c}{2au^{-} + b},\quad
u^{-}\ \leftarrow u
$$
<p>&nbsp;<br>


<p>
Start of iteration: \( u^{-}=u^{(1)} \)

<p>

</section>


<section class="slide">

<h2>Using Newton's method on the logistic ODE with typical math notation  <a name="___sec20"></a></h2>

<p>
Set iteration start as \( u^{n,0}= u^{n-1} \) and iterate
with explicit indices for time (\( n \)) and
Newton iteration (\( k \)):

<p>&nbsp;<br>
$$
u^{n,k+1} = u^{n,k} +
\frac{\Delta t (u^{n,k})^2 + (1-\Delta t)u^{n,k} - u^{n-1}}
{2\Delta t u^{n,k} + 1 - \Delta t}
$$
<p>&nbsp;<br>


<p>
Compare notation with

<p>&nbsp;<br>
$$
u = u^{-} +
\frac{\Delta t (u^{-})^2 + (1-\Delta t)u^{-} - u^{(1)}}
{2\Delta t u^{-} + 1 - \Delta t}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Relaxation may improve the convergence <a name="nonlin:timediscrete:logistic:relaxation"></a></h2>

<ul>
 <p><li> Problem: Picard and Newton iteration may change the solution too much</li>
 <p><li> Remedy: relaxation (less change in the solution)</li>
 <p><li> Let \( u^* \) be the suggested new value from Picard or Newton iteration</li>
</ul>
<p>

Relaxation with <em>relaxation parameter</em> \( \omega \) (weight old and new value):

<p>&nbsp;<br>
$$ u = \omega u^* + (1-\omega) u^{-},\quad \omega \leq 1$$
<p>&nbsp;<br>


<p>
Simple formula when used in Newton's method:

<p>&nbsp;<br>
$$
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Implementation; part 1 <a name="nonlin:timediscrete:logistic:impl"></a></h2>

<p>
Program <a href="http://tinyurl.com/nm5587k/nonlin/logistic.py" target="_self"><tt>logistic.py</tt></a>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">BE_logistic</span>(u0, dt, Nt, choice=<span style="color: #CD5555">&#39;Picard&#39;</span>,
                eps_r=<span style="color: #B452CD">1E-3</span>, omega=<span style="color: #B452CD">1</span>, max_iter=<span style="color: #B452CD">1000</span>):
    <span style="color: #8B008B; font-weight: bold">if</span> choice == <span style="color: #CD5555">&#39;Picard1&#39;</span>:
        choice = <span style="color: #CD5555">&#39;Picard&#39;</span>;  max_iter = <span style="color: #B452CD">1</span>

    u = np.zeros(Nt+<span style="color: #B452CD">1</span>)
    iterations = []
    u[<span style="color: #B452CD">0</span>] = u0
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt+<span style="color: #B452CD">1</span>):
        a = dt
        b = <span style="color: #B452CD">1</span> - dt
        c = -u[n-<span style="color: #B452CD">1</span>]

        <span style="color: #8B008B; font-weight: bold">if</span> choice == <span style="color: #CD5555">&#39;Picard&#39;</span>:

            <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">F</span>(u):
                <span style="color: #8B008B; font-weight: bold">return</span> a*u**<span style="color: #B452CD">2</span> + b*u + c

            u_ = u[n-<span style="color: #B452CD">1</span>]
            k = <span style="color: #B452CD">0</span>
            <span style="color: #8B008B; font-weight: bold">while</span> <span style="color: #658b00">abs</span>(F(u_)) &gt; eps_r <span style="color: #8B008B">and</span> k &lt; max_iter:
                u_ = omega*(-c/(a*u_ + b)) + (<span style="color: #B452CD">1</span>-omega)*u_
                k += <span style="color: #B452CD">1</span>
            u[n] = u_
            iterations.append(k)
</pre></div>
<p>

</section>


<section class="slide">

<h2>Implementation; part 2  <a name="___sec23"></a></h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">BE_logistic</span>(u0, dt, Nt, choice=<span style="color: #CD5555">&#39;Picard&#39;</span>,
                eps_r=<span style="color: #B452CD">1E-3</span>, omega=<span style="color: #B452CD">1</span>, max_iter=<span style="color: #B452CD">1000</span>):
    ...
        <span style="color: #8B008B; font-weight: bold">elif</span> choice == <span style="color: #CD5555">&#39;Newton&#39;</span>:

            <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">F</span>(u):
                <span style="color: #8B008B; font-weight: bold">return</span> a*u**<span style="color: #B452CD">2</span> + b*u + c

            <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">dF</span>(u):
                <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*a*u + b

            u_ = u[n-<span style="color: #B452CD">1</span>]
            k = <span style="color: #B452CD">0</span>
            <span style="color: #8B008B; font-weight: bold">while</span> <span style="color: #658b00">abs</span>(F(u_)) &gt; eps_r <span style="color: #8B008B">and</span> k &lt; max_iter:
                u_ = u_ - F(u_)/dF(u_)
                k += <span style="color: #B452CD">1</span>
            u[n] = u_
            iterations.append(k)
    <span style="color: #8B008B; font-weight: bold">return</span> u, iterations
</pre></div>
<p>

</section>


<section class="slide">

<h2>Implementation; part 3  <a name="___sec24"></a></h2>

<p>
The Crank-Nicolson method with a geometric mean:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">CN_logistic</span>(u0, dt, Nt):
    u = np.zeros(Nt+<span style="color: #B452CD">1</span>)
    u[<span style="color: #B452CD">0</span>] = u0
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
        u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*dt)/(<span style="color: #B452CD">1</span> + dt*u[n] - <span style="color: #B452CD">0.5</span>*dt)*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
<p>

</section>


<section class="slide">

<h2>Experiments: accuracy of iteration methods  <a name="___sec25"></a></h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  The impact of solution strategies and for four different time step lengths on the solution. <a name="nonlin:timediscrete:logistic:impl:fig:u"></a> </p></center>
<p><img src="fig-nonlin/logistic_u.png" align="bottom" width=800></p>
</center>

<p>

</section>


<section class="slide">

<h2>Experiments: number of iterations  <a name="___sec26"></a></h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Comparison of the number of iterations at various time levels for Picard and Newton iteration. <a name="nonlin:timediscrete:logistic:impl:fig:iter"></a> </p></center>
<p><img src="fig-nonlin/logistic_iter.png" align="bottom" width=800></p>
</center>

<p>

</section>


<section class="slide">

<h2>The effect of relaxation can potentially be great!  <a name="___sec27"></a></h2>

<ul>
 <p><li> \( \Delta t=0.9 \): Picard required 32 iterations on average</li>
 <p><li> \( \omega =0.8 \): 7 iterations</li>
 <p><li> \( \omega =0.5 \): 2 iterations (!) - optimal choice</li>
</ul>
<p>

Other \( \omega=1 \) experiments:

<p>
<table border="1">
<thead>
<tr><td align="center">\( \Delta t \)</td> <td align="center">\( \epsilon_r \)</td> <th align="center">Picard</th> <th align="center">Newton</th> </tr>
</thead>
<tbody>
<tr><td align="left">   \( 0.2 \)         </td> <td align="left">   \( 10^{-7} \)       </td> <td align="right">   5         </td> <td align="right">   2         </td> </tr>
<tr><td align="left">   \( 0.2 \)         </td> <td align="left">   \( 10^{-3} \)       </td> <td align="right">   2         </td> <td align="right">   1         </td> </tr>
<tr><td align="left">   \( 0.4 \)         </td> <td align="left">   \( 10^{-7} \)       </td> <td align="right">   12        </td> <td align="right">   3         </td> </tr>
<tr><td align="left">   \( 0.4 \)         </td> <td align="left">   \( 10^{-3} \)       </td> <td align="right">   4         </td> <td align="right">   2         </td> </tr>
<tr><td align="left">   \( 0.8 \)         </td> <td align="left">   \( 10^{-7} \)       </td> <td align="right">   58        </td> <td align="right">   3         </td> </tr>
<tr><td align="left">   \( 0.8 \)         </td> <td align="left">   \( 10^{-3} \)       </td> <td align="right">   4         </td> <td align="right">   2         </td> </tr>
</tbody>
</table>
<p>

</section>


<section class="slide">

<h2>Generalization to a general nonlinear ODE <a name="nonlin:ode:generic"></a></h2>

<p>&nbsp;<br>
$$
u^{\prime} = f(u, t)
$$
<p>&nbsp;<br>


<p>
Note: \( f \) is in general nonlinear in \( u \) so the ODE is nonlinear

<p>

</section>


<section class="slide">

<h2>Explicit time discretization  <a name="___sec29"></a></h2>

<p>
Forward Euler and all explicit methods sample \( f \) with known
values and all nonlinearities are gone:

<p>&nbsp;<br>
$$ \frac{{\color{red}u^{n+1}}-u^n}{\Delta t} = f(u^n, t_n) $$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Backward Euler discretization  <a name="___sec30"></a></h2>

<p>
Backward Euler \( [D_t^- u = f]^n \) leads to nonlinear algebraic equations:

<p>&nbsp;<br>
$$ F(u^n) = u^{n} - \Delta t\, f(u^n, t_n) - u^{n-1}=0$$
<p>&nbsp;<br>


<p>
Alternative notation:

<p>&nbsp;<br>
$$ F(u) = u - \Delta t\, f(u, t_n) - u^{(1)} = 0$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Picard iteration for Backward Euler scheme  <a name="___sec31"></a></h2>

<p>
A simple Picard iteration, not knowing anything about the nonlinear
structure of \( f \), must approximate \( f(u,t_n) \) by \( f(u^{-},t_n) \):

<p>&nbsp;<br>
$$ \hat F(u) = u - \Delta t\, f(u^{-},t_n) - u^{(1)}$$
<p>&nbsp;<br>


<p>
The iteration starts with \( u^{-}=u^{(1)} \) and proceeds with repeating

<p>&nbsp;<br>
$$ u^* = \Delta t\, f(u^{-},t_n) + u^{(1)},\quad
   u = \omega u^* + (1-\omega)u^{-},
\quad u^{-}\ \leftarrow\ u$$
<p>&nbsp;<br>

until a stopping criterion is fulfilled.

<p>

</section>


<section class="slide">

<h2>Manual linearization for a given \( f(u,t) \)  <a name="___sec32"></a></h2>

<ul>
 <p><li> \( f(u^{-},t) \): <em>explicit</em> treatment of \( f \)<br />
   (as in time-discretization)</li>
 <p><li> \( f(u,t) \): <em>fully implicit</em> treatment of \( f \)</li>
 <p><li> If \( f \) has some structure, say \( f(u,t)=u^3 \), we may
   think of a <em>partially implicit</em> treatment: \( (u^{-})^2u \)</li>
 <p><li> More implicit treatment of \( f \) often gives faster
   convergence<br />
   (as it gives more stable time discretizations)</li>
</ul>
<p>

Trick for partially implicit treatment of a general \( f(u,t) \):

<p>&nbsp;<br>
$$ f(u^{-},t)\frac{u}{u^{-1}} $$
<p>&nbsp;<br>


<p>
(Idea: \( u\approx u^{-} \))

<p>

</section>


<section class="slide">

<h2>Computational experiments with partially implicit treatment of \( f \)  <a name="___sec33"></a></h2>

<ul>
 <p><li> \( f(u,t)=-u^3 \):</li>

<ul>
   <p><li> \( (u^{-})^3 \) linearization: 22, 9, 6 iterations</li>
   <p><li> \( (u^{-})^2u \) linearization: 8, 5, 4 iterations</li>
</ul>
<p>

 <p><li> \( f(u,t)=e^{-u} \): a trick \( f(u^{-},t)u/u^{-} \) has no effect</li>
 <p><li> \( f(u,t)=\sin(2(u+1)) \): a trick \( f(u^{-},t)u/u^{-} \) has effect<br />
   (7, 9, 11 iterations vs 17, 21, 20)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Newton's method for Backward Euler scheme  <a name="___sec34"></a></h2>

<p>
Newton's method requires the computation of the derivative

<p>&nbsp;<br>
$$ F^{\prime}(u) = 1 - \Delta t\frac{\partial f}{\partial u}(u,t_n)$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Algorithm for Newton's method for \( u^{\prime}=f(u,t) \).</b>
<p>
Start with \( u^{-}=u^{(1)} \), then iterate

<p>&nbsp;<br>
$$
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}
= u^{-} - \omega \frac{u^{(1)} + \Delta t\, f(u^{-},t_{n})}{1 - \Delta t
\frac{\partial}{\partial u}f(u^{-},t_n)}
$$
<p>&nbsp;<br>
</div>


<p>

</section>


<section class="slide">

<h2>Crank-Nicolson discretization  <a name="___sec35"></a></h2>

<p>
The standard Crank-Nicolson scheme with arithmetic mean approximation of
\( f \) reads

<p>&nbsp;<br>
$$ \frac{u^{n+1} - u^n}{\Delta t} = \half(f(u^{n+1}, t_{n+1})
+ f(u^n, t_n))$$
<p>&nbsp;<br>


<p>
Nonlinear algebraic equation:

<p>&nbsp;<br>
$$
F(u) = u - u^{(1)} - \Delta t{\half}f(u,t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n}) = 0
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Picard and Newton iteration in the Crank-Nicolson case  <a name="___sec36"></a></h2>

<p>
Picard iteration (for a general \( f \)):

<p>&nbsp;<br>
$$ \hat F(u) = u - u^{(1)} - \Delta t{\half}f(u^{-},t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n})$$
<p>&nbsp;<br>


<p>
Newton's method:

<p>&nbsp;<br>
$$
F(u) = u - u^{(1)} - \Delta t{\half}f(u,t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n})
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$ F^{\prime}(u)= 1 - \half\Delta t\frac{\partial f}{\partial u}(u,t_{n+1})$$
<p>&nbsp;<br>


<p>
<!-- see ODE_Picard_tricks.py for testing -->

<p>

</section>


<section class="slide">

<h2>Systems of ODEs  <a name="___sec37"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
\frac{d}{dt}u_0(t) &= f_0(u_0(t),u_1(t),\ldots,u_N(t),t)\\ 
\frac{d}{dt}u_1(t) &= f_1(u_0(t),u_1(t),\ldots,u_N(t),t),\\ 
&\vdots\\ 
\frac{d}{dt}u_N(t) &= f_N(u_0(t),u_1(t),\ldots,u_N(t),t)
\end{align*}
$$
<p>&nbsp;<br>


<p>
Introduce vector notation:

<ul>
 <p><li> \( u=(u_0(t),u_1(t),\ldots,u_N(t)) \)</li>
 <p><li> \( (f_0(u,t),f_1(u,t),\ldots,f_N(u,t)) \)</li>
</ul>
<p>

Vector form:

<p>&nbsp;<br>
$$ u^{\prime} = f(u,t),\quad u(0)=U_0 $$
<p>&nbsp;<br>


<p>
Schemes: apply scalar scheme to each component

<p>

</section>


<section class="slide">

<h2>A Backward Euler scheme for the vector ODE \( u^{\prime}=f(u,t) \)  <a name="___sec38"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
\frac{u_0^n- u_0^{n-1}}{\Delta t} &= f_0(u^n,t_n)\\ 
\frac{u_1^n- u_1^{n-1}}{\Delta t} &= f_1(u^n,t_n)\\ 
&\vdots\\ 
\frac{u_N^n- u_N^{n-1}}{\Delta t} &= f_N(u^n,t_n)
\end{align*}
$$
<p>&nbsp;<br>


<p>
This can be written more compactly in vector form as

<p>&nbsp;<br>
$$ \frac{u^n- u^{n-1}}{\Delta t} = f(u^n,t_n)$$
<p>&nbsp;<br>


<p>
This is a system of <em>nonlinear algebraic equations</em>,

<p>&nbsp;<br>
$$ u^n - \Delta t\,f(u^n,t_n) - u^{n-1}=0,$$
<p>&nbsp;<br>

or written out

<p>&nbsp;<br>
$$
\begin{align*}
u_0^n - \Delta t\, f_0(u^n,t_n) - u_0^{n-1} &= 0,\\ 
&\vdots\\ 
u_N^n - \Delta t\, f_N(u^n,t_n) - u_N^{n-1} &= 0\tp
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Example: Crank-Nicolson scheme for the oscillating pendulum model  <a name="___sec39"></a></h2>

<p>
The scaled equations for an oscillating pendulum:

<p>&nbsp;<br>
$$
\begin{align}
\dot\omega &= -\sin\theta -\beta \omega |\omega|,\\ 
\dot\theta &= omega,
\end{align}
$$
<p>&nbsp;<br>


<p>
Set \( u_0=\omega \), \( u_1=\theta \)

<p>&nbsp;<br>
$$
\begin{align*}
u_0^{\prime} = f_0(u,t) &= -\sin u_1 - \beta u_0|u_0|,\\ 
u_1^{\prime} = f_1(u,t) &= u_1\tp
\end{align*}
$$
<p>&nbsp;<br>


<p>
Crank-Nicolson discretization:

<p>&nbsp;<br>
$$
\begin{align}
\frac{u_0^{n+1}-u_0^{n}}{\Delta t} &= -\sin u_1^{n+\frac{1}{2}}
- \beta u_0^{n+\frac{1}{2}}|u_0^{n+\frac{1}{2}}|
\approx -\sin\left(\frac{1}{2}(u_1^{n+1} + u_1n)\right)
- \beta\frac{1}{4} (u_0^{n+1} + u_0^n)|u_0^{n+1}+u_0^n|,\\ 
\frac{u_1^{n+1}-u_1^n}{\Delta t} &= v_0^{n+\frac{1}{2}}\approx
\frac{1}{2} (u_0^{n+1}+u_0^n)\tp
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The nonlinear \( 2\times 2 \) system  <a name="___sec40"></a></h2>

<p>
Introduce \( u_0 \) and \( u_1 \) for \( u_0^{n+1} \) and
\( u_1^{n+1} \), write \( u_0^{(1)} \) and
\( u_1^{(1)} \) for \( u_0^n \) and \( u_1^n \), and rearrange:

<p>&nbsp;<br>
$$
\begin{align*}
F_0(u_0,u_1) &=
{\color{red}u_0}
- u_0^{(1)} + \Delta t\,\sin\left(\frac{1}{2}({\color{red}u_1}
+ u_1^{(1)})\right)
+ \frac{1}{4}\Delta t\beta ({\color{red}u_0} + u_0^{(1)})
|{\color{red}u_0} + u_0^{(1)}| =0
\\ 
F_1(u_0,u_1) &=
{\color{red}u_1} - u_1^{(1)} -\frac{1}{2}\Delta t({\color{red}u_0}
+ u_0^{(1)}) =0
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h1 style="text-align: center;">Systems of nonlinear algebraic equations <a name="nonlin:systems:alg"></a></h1>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
<p>&nbsp;<br>
$$
\begin{align*}
x\cos y + y^3 & = 0\\ 
y^2e^x + xy &= 2
\end{align*}
$$
<p>&nbsp;<br>
</div>
<!-- end box -->


<p>
Systems of nonlinear algebraic equations arise from solving
<em>systems of ODEs</em> or solving <em>PDEs</em>

<p>

</section>


<section class="slide">

<h2>Notation for general systems of algebraic equations  <a name="___sec42"></a></h2>

<p>&nbsp;<br>
$$ F(u) = 0$$
<p>&nbsp;<br>


<p>
where

<p>&nbsp;<br>
$$ u=(u_0,\ldots,u_N),\quad F=(F_0,\ldots,F_N)$$
<p>&nbsp;<br>


<p>
Special linear system-type structure <br />
(arises frequently in PDE problems):

<p>&nbsp;<br>
$$ A(u)u = b(u)$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Picard iteration <a name="nonlin:systems:alg:Picard"></a></h2>

<p>
Picard iteration for \( F(u)=0 \) is meaningless unless there is
some structure so we can linearize. For \( A(u)u=b(u) \) we can
linearize

<p>&nbsp;<br>
$$ A(u^{-})u = b(u^{-})$$
<p>&nbsp;<br>


<p>
Note: we solve a system of nonlinear algebraic equations as
a sequence of linear systems.

<p>

</section>


<section class="slide">

<h2>Algorithm for relaxed Picard iteration  <a name="___sec44"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>
Given \( A(u)u=b(u) \) and an initial guess \( u^{-} \), iterate until convergence:

<ol>
<p><li> solve \( A(u^{-})u^* = b(u^{-}) \) with respect to \( u^* \)</li>
<p><li> \( u = \omega u^* + (1-\omega) u^{-} \)</li>
<p><li> \( u^{-}\ \leftarrow\ u \)</li>
</ol>
</div>


<p>
&quot;Until convergence&quot;: \( ||u - u^{-}|| \leq \epsilon_u \) or
\( ||A(u)u-b|| \leq\epsilon_r \)

<p>

</section>


<section class="slide">

<h2>Newton's method for \( F(u)=0 \) <a name="nonlin:systems:alg:Newton"></a></h2>

<p>
Linearization of \( F(u)=0 \) equation via multi-dimensional Taylor series:

<p>&nbsp;<br>
$$ F(u) = F(u^{-}) + J(u^{-}) \cdot (u - u^{-}) + \mathcal{O}(||u - u^{-}||^2) $$
<p>&nbsp;<br>


<p>
where \( J \) is the <em>Jacobian</em> of \( F \), sometimes denoted \( \nabla_uF \), defined by

<p>&nbsp;<br>
$$ J_{i,j} = \frac{\partial F_i}{\partial u_j}$$
<p>&nbsp;<br>


<p>
Approximate the original nonlinear system \( F(u)=0 \) by

<p>&nbsp;<br>
$$ \hat F(u) = F(u^{-}) + J(u^{-}) \cdot \delta u =0,\quad
\delta u = u - u^{-}$$
<p>&nbsp;<br>


<p>
which is linear vector equation in \( u \)

<p>

</section>


<section class="slide">

<h2>Algorithm for Newton's method  <a name="___sec46"></a></h2>

<p>&nbsp;<br>
$$ \underline{F(u^{-})}_{\mbox{vector}} +
\underline{J(u^{-})}_{\mbox{matrix}} \cdot
\underline{\delta u}_{\mbox{vector}} =0$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>
Solution by a two-step procedure:

<ol>
<p><li> solve linear system \( J(u^{-})\delta u = -F(u^{-}) \) wrt \( \delta u \)</li>
<p><li> update \( u = u^{-} + \delta u \)</li>
</ol>
<p>

Relaxed update:

<p>&nbsp;<br>
$$ u = \omega(u^{-} +\delta u)
+ (1-\omega)u^{-} = u^{-}  + \omega\delta u
$$
<p>&nbsp;<br>
</div>


<p>

</section>


<section class="slide">

<h2>Newton's method for \( A(u)u=b(u) \) <a name="nonlin:systems:alg:Newton:Aub"></a></h2>

<p>
For

<p>&nbsp;<br>
$$ F_i = \sum_k A_{i,k}(u)u_k - b_i(u)$$
<p>&nbsp;<br>


<p>
one gets

<p>&nbsp;<br>
$$
J_{i,j} = \frac{\partial F_i}{\partial u_j}
= \sum_k \frac{\partial A_{i,k}}{\partial u_j}u_k
+ A_{i,j} -
\frac{\partial b_i}{\partial u_j}
$$
<p>&nbsp;<br>


<p>
Matrix form:

<p>&nbsp;<br>
$$ (A + A^{\prime}u + b^{\prime})\delta u = -Au + b$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$ (A(u^{-}) + A^{\prime}(u^{-})u^{-} + b^{\prime}(u^{-}))\delta u
= -A(u^{-})u^{-} + b(u^{-})$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Comparison of Newton and Picard iteration  <a name="___sec48"></a></h2>

<p>
Newton:

<p>&nbsp;<br>
$$ (A(u^{-}) + A^{\prime}(u^{-})u^{-} + b^{\prime}(u^{-}))\delta u
= -A(u^{-})u^{-} + b(u^{-})$$
<p>&nbsp;<br>


<p>
Rewrite:

<p>&nbsp;<br>
$$ \underbrace{A(u^{-})(u^{-}+\delta u) - b(u^{-})}_{\hbox{Picard system}}
+\, \gamma (A^{\prime}(u^{-})u^{-} + b^{\prime}(u^{-}))\delta u
= 0$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>
All the &quot;Picard terms&quot; are contained in the Newton formulation.
</div>


<p>

</section>


<section class="slide">

<h2>Combined Picard-Newton algorithm  <a name="___sec49"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Idea:</b>
<p>
Write a common Picard-Newton algorithm so we can trivially
switch between the two methods (e.g., start with Picard, get
faster convergence with Newton when \( u \) is closer to the solution)
</div>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Algorithm:</b>
<p>
Given \( A(u) \), \( b(u) \), and an initial guess \( u^{-} \), iterate until convergence:

<ol>
<p><li> solve \( (A + \gamma(A^{\prime}(u^{-})u^{-} +
   b^{\prime}(u^{-})))\delta u = -A(u^{-})u^{-} + b(u^{-}) \)
   with respect to \( \delta u \)</li>
<p><li> \( u = u^{-} + \omega\delta u \)</li>
<p><li> \( u^{-}\ \leftarrow\ u \)</li>
</ol>
<p>

Note:

<ul>
  <p><li> \( \gamma =1 \): Newton's method</li>
  <p><li> \( \gamma =0 \): Picard iteration</li>
</ul>
</div>


<p>

</section>


<section class="slide">

<h2>Stopping criteria <a name="nonlin:systems:alg:terminate"></a></h2>

<p>
Let \( ||\cdot|| \) be the standard Eucledian vector norm. Several termination
criteria are much in use:

<ul>
 <p><li> Absolute change in solution: \( ||u - u^{-}||\leq \epsilon_u \)</li>
 <p><li> Relative change in solution: \( ||u - u^{-}||\leq \epsilon_u ||u_0|| \),
   where \( u_0 \) denotes the start value of \( u^{-} \) in the iteration</li>
 <p><li> Absolute residual: \( ||F(u)|| \leq \epsilon_r \)</li>
 <p><li> Relative residual: \( ||F(u)|| \leq \epsilon_r ||F(u_0)|| \)</li>
 <p><li> Max no of iterations: stop when \( k > k_{\max} \)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Combination of absolute and relative stopping criteria  <a name="___sec51"></a></h2>

<p>
Problem with relative criterion: a small
\( ||F(u_0)|| \) (because \( u_0\approx u \), perhaps because of small \( \Delta t \))
must be significantly reduced. Better with absolute criterion.

<ul>
 <p><li> Can make combined absolute-relative criterion</li>
 <p><li> \( \epsilon_{rr} \): tolerance for relative part</li>
 <p><li> \( \epsilon_{ra} \): tolerance for absolute part</li>
</ul>
<p>

<p>&nbsp;<br>
$$
||F(u)|| \leq \epsilon_{rr} ||F(u_0)|| + \epsilon_{ra}
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
||F(u)|| \leq \epsilon_{rr} ||F(u_0)|| + \epsilon_{ra}
\quad\hbox{or}\quad
||\delta u|| \leq \epsilon_{ur} ||u_0|| + \epsilon_{ua}
\quad\hbox{or}\quad
k>k_{\max}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Example: A nonlinear ODE model from epidemiology <a name="nonlin:systems:alg:SI"></a></h2>

<p>
Spreading of a disease (e.g., a flu) can be modeled by
a \( 2\times 2 \) ODE system

<p>&nbsp;<br>
$$
\begin{align*}
S^{\prime} &= -\beta SI\\ 
I^{\prime} &= \beta SI - \nu I
\end{align*}
$$
<p>&nbsp;<br>


<p>
Here:

<ul>
 <p><li> \( S(t) \) is the number of people who can get ill (susceptibles)</li>
 <p><li> \( I(t) \) is the number of people who are ill (infected)</li>
 <p><li> Must know \( \beta >0 \) (danger of getting ill) and <br />
   \( \nu >0 \) (\( 1/\nu \): expected recovery time)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Implicit time discretization  <a name="___sec53"></a></h2>

<p>
A Crank-Nicolson scheme:

<p>&nbsp;<br>
$$
\begin{align*}
\frac{S^{n+1}-S^n}{\Delta t} &= -\beta [SI]^{n+\half}
\approx -\frac{\beta}{2}(S^nI^n + S^{n+1}I^{n+1})\\ 
\frac{I^{n+1}-I^n}{\Delta t} &= \beta [SI]^{n+\half} -
\nu I^{n+\half}
\approx \frac{\beta}{2}(S^nI^n + S^{n+1}I^{n+1}) -
\frac{\nu}{2}(I^n + I^{n+1})
\end{align*}
$$
<p>&nbsp;<br>


<p>
New notation: \( S \) for \( S^{n+1} \), \( S^{(1)} \) for \( S^n \), \( I \) for \( I^{n+1} \),
\( I^{(1)} \) for \( I^n \)

<p>&nbsp;<br>
$$
\begin{align*}
F_S(S,I) &= S - S^{(1)} +
\half\Delta t\beta(S^{(1)}I^{(1)} + SI) = 0\\ 
F_I(S,I) &= I - I^{(1)} -
\half\Delta t\beta(S^{(1)}I^{(1)} + SI) -
\half\Delta t\nu(I^{(1)} + I) =0
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>A Picard iteration  <a name="___sec54"></a></h2>

<ul>
 <p><li> We have approximations \( S^{-} \) and \( I^{-} \) to \( S \) and \( I \).</li>
 <p><li> Linearize \( SI \) in \( S \) ODE as \( I^{-}S \) (linear equation in \( S \)!)</li>
 <p><li> Linearize \( SI \) in \( I \) ODE as \( S^{-}I \) (linear equation in \( I \)!)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{align*}
S &= \frac{S^{(1)} - \half\Delta t\beta S^{(1)}I^{(1)}}
{1 + \half\Delta t\beta I^{-}}
\\ 
I &= \frac{I^{(1)} + \half\Delta t\beta S^{(1)}I^{(1)}}
{1 - \half\Delta t\beta S^{-} + \nu}
\end{align*}
$$
<p>&nbsp;<br>

Before a new iteration: \( S^{-}\ \leftarrow\ S \) and
\( I^{-}\ \leftarrow\ I \)

<p>

</section>


<section class="slide">

<h2>Newton's method  <a name="___sec55"></a></h2>

<p>&nbsp;<br>
$$ F(u)=0,\quad F=(F_S,F_I),\  u=(S,I) $$
<p>&nbsp;<br>


<p>
Jacobian:

<p>&nbsp;<br>
$$
\renewcommand*{\arraystretch}{2}
J = \left(\begin{array}{cc}
\frac{\partial}{\partial S} F_S & \frac{\partial}{\partial I}F_S\\ 
\frac{\partial}{\partial S} F_I & \frac{\partial}{\partial I}F_I
\end{array}\right)
= \left(\begin{array}{cc}
1 + \half\Delta t\beta I & \half\Delta t\beta\\ 
- \half\Delta t\beta S & 1 - \half\Delta t\beta I -
\half\Delta t\nu
\end{array}\right)
$$
<p>&nbsp;<br>


<p>
Newton system: \( J(u^{-})\delta u = -F(u^{-}) \)

<p>&nbsp;<br>
$$
\begin{align*}
\renewcommand*{\arraystretch}{1.5}
&
\left(\begin{array}{cc}
1 + \half\Delta t\beta I^{-} & \half\Delta t\beta S^{-}\\ 
- \half\Delta t\beta S^{-} & 1 - \half\Delta t\beta I^{-} -
\half\Delta t\nu
\end{array}\right)
\left(\begin{array}{c}
\delta S\\ 
\delta I
\end{array}\right)
=\\ 
& \qquad\qquad
\left(\begin{array}{c}
S^{-} - S^{(1)} + \half\Delta t\beta(S^{(1)}I^{(1)} + S^{-}I^{-})\\ 
I^{-} - I^{(1)} - \half\Delta t\beta(S^{(1)}I^{(1)} + S^{-}I^{-}) -
\half\Delta t\nu(I^{(1)} + I^{-})
\end{array}\right)
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Actually no need to bother with nonlinear algebraic equations for this particular model...  <a name="___sec56"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Remark:</b>
<p>
For this particular system of ODEs, explicit time integration methods work very
well. Even a Forward Euler scheme is fine, but
the 4-th order Runge-Kutta method is an excellent
balance between high accuracy, high efficiency, and simplicity.
</div>


<p>

</section>


<section class="slide">

<h1 style="text-align: center;">Linearization at the differential equation level <a name="nonlin:pdelevel"></a></h1>

<p>
Goal: linearize a PDE like

<p>&nbsp;<br>
$$
\frac{\partial u}{\partial t} = \nabla\cdot ({\color{red}\dfc(u)\nabla u})
+ {\color{red}f(u)}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>PDE problem  <a name="___sec58"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
\frac{\partial u}{\partial t} &= \nabla\cdot (\dfc(u)\nabla u) + f(u),\quad
&\x\in\Omega,\ t\in (0,T]
\\ 
-\dfc(u)\frac{\partial u}{\partial n} &= g,\quad &\x\in\partial\Omega_N,\ 
t\in (0,T]
\\ 
u &= u_0,\quad &\x\in\partial\Omega_D,\ t\in (0,T]
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Explicit time integration <a name="nonlin:pdelevel:explicit"></a></h2>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Explicit time integration methods remove the nonlinearity
</div>
<!-- end box -->


<p>
Forward Euler method:

<p>&nbsp;<br>
$$ [D_t^+ u = \nabla\cdot (\dfc(u)\nabla u) + f(u)]^n$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$ \frac{u^{n+1} - u^n}{\Delta t} = \nabla\cdot (\dfc(u^n)\nabla u^n)
+ f(u^n)$$
<p>&nbsp;<br>


<p>
This is a <em>linear equation</em> in the unknown \( u^{n+1}(\x) \), with solution

<p>&nbsp;<br>
$$ u^{n+1} = u^n + \Delta t\nabla\cdot (\dfc(u^n)\nabla u^n) +
\Delta t f(u^n) $$
<p>&nbsp;<br>


<p>
Disadvantage: \( \Delta t \leq (\max\alpha)^{-1}(\Delta x^2 + \Delta y^2 + \Delta z^2) \)

<p>

</section>


<section class="slide">

<h2>Backward Euler scheme <a name="nonlin:pdelevel:Picard"></a></h2>

<p>
Backward Euler scheme:

<p>&nbsp;<br>
$$ [D_t^- u = \nabla\cdot (\dfc(u)\nabla u) + f(u)]^n$$
<p>&nbsp;<br>


<p>
Written out:

<p>&nbsp;<br>
$$
\frac{u^{n} - u^{n-1}}{\Delta t} = \nabla\cdot (\dfc(u^n)\nabla u^n)
+ f(u^n)
$$
<p>&nbsp;<br>


<p>
This is a nonlinear, stationary PDE for the unknown function \( u^n(\x) \)

<p>

</section>


<section class="slide">

<h2>Picard iteration for Backward Euler scheme  <a name="___sec61"></a></h2>

<p>
We have

<p>&nbsp;<br>
$$
\frac{u^{n} - u^{n-1}}{\Delta t} = \nabla\cdot (\dfc(u^n)\nabla u^n)
+ f(u^n)
$$
<p>&nbsp;<br>


<p>
Picard iteration:

<p>&nbsp;<br>
$$
\frac{u^{n,k+1} - u^{n-1}}{\Delta t} = \nabla\cdot (\dfc(u^{n,k})
\nabla u^{n,k+1})
+ f(u^{n,k})
$$
<p>&nbsp;<br>


<p>
Start iteration with \( u^{n,0}=u^{n-1} \)

<p>

</section>


<section class="slide">

<h2>Picard iteration with alternative notation  <a name="___sec62"></a></h2>

<p>&nbsp;<br>
$$
\frac{u^{n,k+1} - u^{n-1}}{\Delta t} = \nabla\cdot (\dfc(u^{n,k})
\nabla u^{n,k+1})
+ f(u^{n,k})
$$
<p>&nbsp;<br>


<p>
Rewrite with a simplified, implementation-friendly notation:

<ul>
 <p><li> \( u \) means the unknown \( u^{n,k+1} \) to solve for</li>
 <p><li> \( u^{-} \) means the most recent approximation to \( u \)</li>
 <p><li> \( u^{(1)} \) means \( u^{n-1} \) (\( u^{(\ell)} \) means \( u^{n-\ell} \))</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\frac{u - u^{(1)}}{\Delta t} = \nabla\cdot (\dfc(u^{-})
\nabla u)
+ f(u^{-})
$$
<p>&nbsp;<br>


<p>
Start iteration with \( u^{-}=u^{(1)} \);
update with \( u^{-} \) to \( u \).

<p>

</section>


<section class="slide">

<h2>Backward Euler scheme and Newton's method <a name="nonlin:pdelevel:Newton"></a></h2>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Normally, Newton's method is defined for systems of <em>algebraic equations</em>,
but the idea of the method can be applied at the PDE level too!
</div>
<!-- end box -->


<p>
Let \( u^{n,k} \) be an approximation to the unknown \( u^n \).
We seek a better approximation

<p>&nbsp;<br>
$$
u^{n} = u^{n,k} + \delta u
$$
<p>&nbsp;<br>


<ul>
 <p><li> Insert \( u^{n} = u^{n,k} + \delta u \) in the PDE</li>
 <p><li> Taylor expand the nonlinearities
   and keep only terms that are linear in \( \delta u \)</li>
</ul>
<p>

Result: linear PDE for the <em>approximate</em> correction \( \delta u \)

<p>

</section>


<section class="slide">

<h2>Calculation details of Newton's method at the PDE level  <a name="___sec64"></a></h2>

<p>
Insert \( u^{n,k} +\delta u \) for \( u^n \) in PDE:

<p>&nbsp;<br>
$$
\frac{u^{n,k} +\delta u - u^{n-1}}{\Delta t} =
\nabla\cdot (\dfc(u^{n,k} + \delta u)\nabla (u^{n,k}+\delta u))
+ f(u^{n,k}+\delta u)
$$
<p>&nbsp;<br>


<p>
Taylor expand \( \dfc(u^{n,k} + \delta u) \) and
\( f(u^{n,k}+\delta u) \):

<p>&nbsp;<br>
$$
\begin{align*}
\dfc(u^{n,k} + \delta u) & = \dfc(u^{n,k}) + \frac{d\dfc}{du}(u^{n,k})
\delta u + \Oof{\delta u^2}\approx \dfc(u^{n,k}) + \dfc^{\prime}(u^{n,k})\delta u\\ 
f(u^{n,k}+\delta u) &=  f(u^{n,k}) + \frac{df}{du}(u^{n,k})\delta u
+ \Oof{\delta u^2}\approx f(u^{n,k}) + f^{\prime}(u^{n,k})\delta u
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Calculation details of Newton's method at the PDE level  <a name="___sec65"></a></h2>

<p>
Inserting linear approximations of \( \dfc \) and \( f \):

<p>&nbsp;<br>
$$
\begin{align*}
\frac{u^{n,k} +\delta u - u^{n-1}}{\Delta t} &=
\nabla\cdot (\dfc(u^{n,k})\nabla u^{n,k}) + f(u^{n,k}) + \\ 
&\quad \nabla\cdot (\dfc(u^{n,k})\nabla \delta u)
+ \nabla\cdot (\dfc^{\prime}(u^{n,k})\delta u\nabla u^{n,k}) + \\ 
&\quad \nabla\cdot (\dfc^{\prime}(u^{n,k})\underbrace{\delta u\nabla \delta u}_{\mbox{dropped}})
+ f^{\prime}(u^{n,k})\delta u
\end{align*}
$$
<p>&nbsp;<br>


<p>
Note: \( \dfc^{\prime}(u^{n,k})\delta u\nabla \delta u \) is \( \Oof{\delta u^2} \)
and therefore omitted.

<p>

</section>


<section class="slide">

<h2>Result of Newton's method at the PDE level  <a name="___sec66"></a></h2>

<p>&nbsp;<br>
$$ \delta F(\delta u; u^{n,k}) = -F(u^{n,k})$$
<p>&nbsp;<br>


<p>
with

<p>&nbsp;<br>
$$
\begin{align*}
F(u^{n,k}) &= \frac{u^{n,k} - u^{n-1}}{\Delta t} -
\nabla\cdot (\dfc(u^{n,k})\nabla u^{n,k}) + f(u^{n,k})
\\ 
\delta F(\delta u; u^{n,k}) &=
- \frac{1}{\Delta t}\delta u +
\nabla\cdot (\dfc(u^{n,k})\nabla \delta u) + \\ 
&\qquad \nabla\cdot (\dfc^{\prime}(u^{n,k})\delta u\nabla u^{n,k})
+ f^{\prime}(u^{n,k})\delta u
\end{align*}
$$
<p>&nbsp;<br>


<p>
Note:

<ul>
 <p><li> \( \delta F \) is linear in \( \delta u \)</li>
 <p><li> \( F \) contains only known terms</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Similarity with Picard iteration  <a name="___sec67"></a></h2>

<p>
Rewrite the PDE for \( \delta u \) using
\( u^{n,k} + \delta u =u^{n,k+1} \):

<p>&nbsp;<br>
$$
\begin{align*}
& \frac{u^{n,k+1} - u^{n-1}}{\Delta t} =
\nabla\cdot (\dfc(u^{n,k})\nabla u^{n,k+1}) + f(u^{n,k})\\ 
&\qquad  + \nabla\cdot (\dfc^{\prime}(u^{n,k})\delta u\nabla u^{n,k})
+ f^{\prime}(u^{n,k})\delta u
\end{align*}
$$
<p>&nbsp;<br>


<p>
Note:

<ul>
 <p><li> The first line is the same PDE as arise in the Picard iteration</li>
 <p><li> The remaining terms arise from the differentiations in Newton's method</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Using new notation for implementation  <a name="___sec68"></a></h2>

<ul>
 <p><li> \( u \) for \( u^n \)</li>
 <p><li> \( u^{-} \) for \( u^{n,k} \)</li>
 <p><li> \( u^{(1)} \) for \( u^{n-1} \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$ \delta F(\delta u; u^{-}) =- F(u^{-})\quad\hbox{(PDE)}$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{align*}
F(u^{-}) &= \frac{u^{-} - u^{(1)}}{\Delta t} -
\nabla\cdot (\dfc(u^{-})\nabla u^{-}) + f(u^{-})
\\ 
\delta F(\delta u; u^{-}) &=
- \frac{1}{\Delta t}\delta u +
\nabla\cdot (\dfc(u^{-})\nabla \delta u) \ + \nonumber\\ 
&\quad \nabla\cdot (\dfc^{\prime}(u^{-})\delta u\nabla u^{-})
+ f^{\prime}(u^{-})\delta u
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Combined Picard and Newton formulation  <a name="___sec69"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
& \frac{u - u^{(1)}}{\Delta t} =
\nabla\cdot (\dfc(u^{-})\nabla u) + f(u^{-}) + \\ 
&\qquad  \gamma(\nabla\cdot (\dfc^{\prime}(u^{-})(u - u^{-})\nabla u^{-})
+ f^{\prime}(u^{-})(u - u^{-}))
\end{align*}
$$
<p>&nbsp;<br>


<p>
Observe:

<ul>
 <p><li> \( \gamma=0 \): Picard iteration</li>
 <p><li> \( \gamma=1 \): Newton's method</li>
</ul>
<p>

Why is this formulation convenient?
Easy to switch (start with Picard, use Newton close to solution)

<p>

</section>


<section class="slide">

<h2>Crank-Nicolson discretization <a name="nonlin:pdelevel:Picard:CN"></a></h2>

<p>
Crank-Nicolson discretization applies a centered difference
at \( t_{n+\frac{1}{2}} \):

<p>&nbsp;<br>
$$ [D_t u = \nabla\cdot (\dfc(u)\nabla u) + f(u)]^{n+\frac{1}{2}}\tp$$
<p>&nbsp;<br>


<p>
Many choices of formulating an arithmetic means:

<p>&nbsp;<br>
$$
\begin{align*}
[f(u)]^{n+\frac{1}{2}} &\approx f(\frac{1}{2}(u^n + u^{n+1}))
= [f(\overline{u}^t)]^{n+\frac{1}{2}}\\ 
[f(u)]^{n+\frac{1}{2}} &\approx \frac{1}{2}(f(u^n) + f(u^{n+1}))
=[\overline{f(u)}^t]^{n+\frac{1}{2}}\\ 
[\dfc(u)\nabla u]^{n+\frac{1}{2}} &\approx
\dfc(\frac{1}{2}(u^n + u^{n+1}))\nabla (\frac{1}{2}(u^n + u^{n+1}))
= \dfc(\overline{u}^t)\nabla \overline{u}^t]^{n+\frac{1}{2}}\\ 
[\dfc(u)\nabla u]^{n+\frac{1}{2}} &\approx
\frac{1}{2}(\dfc(u^n) + \dfc(u^{n+1}))\nabla (\frac{1}{2}(u^n + u^{n+1}))
= [\overline{\dfc(u)}^t\nabla\overline{u}^t]^{n+\frac{1}{2}}\\ 
[\dfc(u)\nabla u]^{n+\frac{1}{2}} &\approx
\frac{1}{2}(\dfc(u^n)\nabla u^n + \dfc(u^{n+1})\nabla u^{n+1})
= [\overline{\dfc(u)\nabla u}^t]^{n+\frac{1}{2}}
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Arithmetic means: which variant is best?  <a name="___sec71"></a></h2>

<p>
Is there any differences in accuracy between

<ol>
<p><li> two factors of arithmetic means</li>
<p><li> the arithmetic mean of a product</li>
</ol>
<p>

More precisely,

<p>&nbsp;<br>
$$
\begin{align*}
[PQ]^{n+\frac{1}{2}} = P^{n+\frac{1}{2}}Q^{n+\frac{1}{2}}
&\approx
\frac{1}{2}(P^n + P^{n+1})\frac{1}{2}(Q^n + Q^{n+1})\\ 
[PQ]^{n+\frac{1}{2}} & \approx \frac{1}{2}(P^nQ^n + P^{n+1}Q^{n+1})
\end{align*}
$$
<p>&nbsp;<br>


<p>
It can be shown (by Taylor series around \( t_{n+\frac{1}{2}} \)) that
both approximations are \( \Oof{\Delta t^2} \)

<p>

</section>


<section class="slide">

<h2>Solution of nonlinear equations in the Crank-Nicolson scheme  <a name="___sec72"></a></h2>

<p>
No big difference from the Backward Euler case, just more terms:

<ul>
 <p><li> Identify the \( F(u)=0 \) for the unknown \( u^{n+1} \)</li>
 <p><li> Apply Picard iteration or Newton's method to the PDE</li>
 <p><li> Identify the sequence of linearized PDEs and iterate</li>
</ul>
<p>


</section>


<section class="slide">

<h1 style="text-align: center;">Discretization of 1D stationary nonlinear differential equations <a name="nonlin:alglevel:1D"></a></h1>

<p>
Differential equation:

<p>&nbsp;<br>
$$
-(\dfc(u)u^{\prime})^{\prime} + au = f(u),\quad x\in (0,L)
$$
<p>&nbsp;<br>


<p>
Boundary conditions:

<p>&nbsp;<br>
$$
\dfc(u(0))u^{\prime}(0) = C,\quad u(L)=D
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Relevance of this stationary 1D problem  <a name="___sec74"></a></h2>

<p>
1. As stationary limit of a diffusion PDE

<p>&nbsp;<br>
$$ u_t = (\alpha(u)u_x)_x + au + f(u) $$
<p>&nbsp;<br>


<p>
(\( u_t\rightarrow 0 \))

<p>
2. The time-discrete problem at each time level arising from a Backward Euler scheme for a diffusion PDE

<p>&nbsp;<br>
$$ u_t = (\alpha(u)u_x)_x + f(u) $$
<p>&nbsp;<br>


<p>
(\( au \) comes from \( u_t \), \( a\sim 1/\Delta t \), \( f(u) := f(u) - u^{n-1}/\Delta t \))

<p>

</section>


<section class="slide">

<h2>Finite difference discretizations <a name="nonlin:alglevel:1D:fd"></a></h2>

<p>
The nonlinear term \( (\dfc(u)u^{\prime})^{\prime} \) behaves just
as a variable coefficient term \( (\dfc(x)u^{\prime})^{\prime} \) wrt
discretization:

<p>&nbsp;<br>
$$ [-D_x\dfc D_x u +au = f]_i$$
<p>&nbsp;<br>


<p>
Written out at internal points:

<p>&nbsp;<br>
$$
\begin{align*}
-\frac{1}{\Delta x^2}
\left(\dfc_{i+\half}(u_{i+1}-u_i) -
\dfc_{i-\half}(u_{i}-u_{i-1})\right)
+ au_i &= f(u_i)
\end{align*}
$$
<p>&nbsp;<br>


<p>
\( \dfc_{i+\half} \): two choices

<p>&nbsp;<br>
$$
\begin{align*}
\dfc_{i+\half} &\approx
\dfc(\half(u_i + u_{i+1})) =
[\dfc(\overline{u}^x)]^{i+\half}
\\ 
\dfc_{i+\half} &\approx
\half(\dfc(u_i) + \dfc(u_{i+1})) = [\overline{\dfc(u)}^x]^{i+\half}
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Finite difference scheme  <a name="___sec76"></a></h2>

<p>&nbsp;<br>
$$ \dfc_{i+\half} \approx
\half(\dfc(u_i) + \dfc(u_{i+1})) = [\overline{\dfc(u)}^x]^{i+\half} $$
<p>&nbsp;<br>


<p>
results in

<p>&nbsp;<br>
$$ [-D_x\overline{\dfc}^x D_x u +au = f]_i\tp$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{align*}
&-\frac{1}{2\Delta x^2}
\left((\dfc(u_i)+\dfc(u_{i+1}))(u_{i+1}-u_i) -
(\dfc(u_{i-1})+\dfc(u_{i}))(u_{i}-u_{i-1})\right)\\ 
&\qquad\qquad + au_i = f(u_i)
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Boundary conditions  <a name="___sec77"></a></h2>

<ul>
 <p><li> At \( i=N_x \): \( u_i=0 \).</li>
 <p><li> At \( i=0 \): \( \dfc(u)u^{\prime}=C \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$ [\dfc(u)D_{2x}u = C]_0$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\dfc(u_0)\frac{u_{1} - u_{-1}}{2\Delta x} = C
$$
<p>&nbsp;<br>


<p>
The fictitious value \( u_{-1} \) can, as usual, be eliminated with the aid
of the scheme at \( i=0 \)

<p>

</section>


<section class="slide">

<h2>The structure of the equation system  <a name="___sec78"></a></h2>

<p>
Structure of nonlinear algebraic equations:

<p>&nbsp;<br>
$$ A(u)u = b(u)$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{align*}
A_{i,i} &= \frac{1}{2\Delta x^2}(-\dfc(u_{i-1}) + 2\dfc(u_{i})
-\dfc(u_{i+1})) + a\\ 
A_{i,i-1} &= -\frac{1}{2\Delta x^2}(\dfc(u_{i-1}) + \dfc(u_{i}))\\ 
A_{i,i+1} &= -\frac{1}{2\Delta x^2}(\dfc(u_{i}) + \dfc(u_{i+1}))\\ 
b_i &= f(u_i)
\end{align*}
$$
<p>&nbsp;<br>


<p>
Note:

<ul>
 <p><li> \( A(u) \) is tridiagonal: \( A_{i,j}=0 \) for \( j > 1+1 \) and \( j < i-1 \).</li>
 <p><li> The \( i=0 \) and \( i=N_x \) equation must incorporate boundary conditions</li>
</ul>
<p>


</section>


<section class="slide">

<h2>The equation for the Neumann boundary condition  <a name="___sec79"></a></h2>

<p>
\( i=0 \): insert

<p>&nbsp;<br>
$$
u_{-1} = u_1 -\frac{2\Delta x}{\dfc(u_0)}
$$
<p>&nbsp;<br>

in \( A_{0,0} \). The expression for \( A_{i,i+1} \)
applies for \( i=0 \), and \( A_{i,i-1} \) for \( i=0 \) does not enter the system.

<p>

</section>


<section class="slide">

<h2>The equation for the Dirichlet boundary condition  <a name="___sec80"></a></h2>

<p>
1. For \( i=N_x \) we can use the Dirichlet condition as a separate
equation

<p>&nbsp;<br>
$$ u_i = D,\quad i=N_x$$
<p>&nbsp;<br>


<p>
2. Alternative: for \( i=N_x \) we can substitute \( u_{N_x} \) in \( A_{i,i} \) by \( D \) and have \( N_x-1 \) equations.

<p>

</section>


<section class="slide">

<h2>Picard iteration  <a name="___sec81"></a></h2>

<p>
Use the most recently computed vaue \( u^{-} \) of \( u \) in \( A(u) \) and
\( b(u) \):

<p>&nbsp;<br>
$$ A(u^{-})u = b(u^{-})$$
<p>&nbsp;<br>


<p>
Tridiagonal system: use tridiagonal Gaussian elimination

<p>

</section>


<section class="slide">

<h2>Details: without Dirichlet condition equation  <a name="___sec82"></a></h2>

<p>
\( N_x=2 \) and Dirichlet condition not as a separate equation:

<p>&nbsp;<br>
$$
\left(\begin{array}{cc}
A_{0,0}& A_{0,1}\\ 
A_{1,0} & A_{1,1}
\end{array}\right)
\left(\begin{array}{c}
u_0\\ 
u_1
\end{array}\right)
=
\left(\begin{array}{c}
b_0\\ 
b_1
\end{array}\right)
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{align*}
A_{0,0} &= \frac{1}{2\Delta x^2}(-\dfc(u_{1}^{-}) + 2\dfc(u_{0}^{-})
-\dfc(u_{1}^{-})) + a\\ 
A_{0,1} &=
-\frac{1}{2\Delta x^2}(\dfc(u_{0}^{-}) + \dfc(u_{1}^{-}))\\ 
A_{1,0} &=
-\frac{1}{2\Delta x^2}(\dfc(u_{0}^{-}) + \dfc(u_{1}^{-}))\\ 
A_{1,1} &=
\frac{1}{2\Delta x^2}(-\dfc(u_{0}^{-}) + 2\dfc(u_{1}^{-})
-\dfc(u_{2})) + a\\ 
b_0 &=
f(u_0^{-})\\ 
b_1 &=
f(u_1^{-})
\end{align*}
$$
<p>&nbsp;<br>


<p>
Note: subst. \( u_{-1} \) by Neumann condition formula, subst.
\( u_2 \) by \( D \)

<p>

</section>


<section class="slide">

<h2>Details: with Dirichlet condition equation  <a name="___sec83"></a></h2>

<p>
\( N_x=2 \) and including \( u_2=D \) as a separate equation:

<p>&nbsp;<br>
$$
\left(\begin{array}{ccc}
A_{0,0}& A_{0,1} & A_{0,2}\\ 
A_{1,0} & A_{1,1} & A_{1,2}\\ 
A_{2,0} & A_{2,1} & A_{2,2}
\end{array}\right)
\left(\begin{array}{c}
u_0\\ 
u_1\\ 
u_2
\end{array}\right)
=
\left(\begin{array}{c}
b_0\\ 
b_1\\ 
b_2
\end{array}\right)
$$
<p>&nbsp;<br>

with \( A_{i,j} \) and \( b_i \) as before for \( i,j=1,2 \), keeping
\( u_2 \) as unknown in \( A_{1,1} \), and

<p>&nbsp;<br>
$$
\begin{align*}
A_{0,2}&=A_{2,0}=A_{2,1}=0\\ 
A_{1,2}&=
-\frac{1}{2\Delta x^2}(\dfc(u_{1}) + \dfc(u_{2}))\\ 
A_{2,2}=&1,\ b_2=D
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Newton's method; Jacobian (1)  <a name="___sec84"></a></h2>

<p>
Nonlinear eq.no \( i \) has the structure

<p>&nbsp;<br>
$$
\begin{align*}
F_i &= A_{i,i-1}(u_{i-1},u_i)u_{i-1} +
A_{i,i}(u_{i-1},u_i,u_{i+1})u_i +\\ 
&\qquad A_{i,i+1}(u_i, u_{i+1})u_{i+1} - b_i(u_i)
\end{align*}
$$
<p>&nbsp;<br>


<p>
Need Jacobian, i.e., need to differentiate \( F(u)=A(u)u - b(u) \) wrt \( u \).
Example:

<p>&nbsp;<br>
$$
\begin{align*}
&\frac{\partial}{\partial u_i}(A_{i,i}(u_{i-1},u_i,u_{i+1})u_i) =
\frac{\partial A_{i,i}}{\partial u_i}u_i + A_{i,i}
\frac{\partial u_i}{\partial u_i}\\ 
&\quad =
\frac{\partial}{\partial u_i}(
\frac{1}{2\Delta x^2}(-\dfc(u_{i-1}) + 2\dfc(u_{i})
-\dfc(u_{i+1})) + a)u_i +\\ 
&\qquad\frac{1}{2\Delta x^2}(-\dfc(u_{i-1}) + 2\dfc(u_{i})
-\dfc(u_{i+1})) + a\\ 
&\quad =\frac{1}{2\Delta x^2}(2\dfc^\prime (u_i)u_i
-\dfc(u_{i-1}) + 2\dfc(u_{i})
-\dfc(u_{i+1})) + a
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Newton's method; Jacobian (2)  <a name="___sec85"></a></h2>

<p>
The complete Jacobian becomes (make sure you get this!)

<p>&nbsp;<br>
$$
\begin{align*}
J_{i,i} &= \frac{\partial F_i}{\partial u_i}
= \frac{\partial A_{i,i-1}}{\partial u_i}u_{i-1}
+ \frac{\partial A_{i,i}}{\partial u_i}u_i
+ A_{i,i}
+ \frac{\partial A_{i,i+1}}{\partial u_i}u_{i+1}
- \frac{\partial b_i}{\partial u_{i}}\\ 
&=
\frac{1}{2\Delta x^2}(
-\dfc^{\prime}(u_i)u_{i-1}
+2\dfc^{\prime}(u_i)u_{i}
-\dfc(u_{i-1}) + 2\dfc(u_i) - \dfc(u_{i+1})) +\\ 
&\quad a
-\frac{1}{2\Delta x^2}\dfc^{\prime}(u_{i})u_{i+1}
- b^{\prime}(u_i)\\ 
J_{i,i-1} &= \frac{\partial F_i}{\partial u_{i-1}}
= \frac{\partial A_{i,i-1}}{\partial u_{i-1}}u_{i-1}
+ A_{i-1,i}
+ \frac{\partial A_{i,i}}{\partial u_{i-1}}u_i
- \frac{\partial b_i}{\partial u_{i-1}}\\ 
&=
\frac{1}{2\Delta x^2}(
-\dfc^{\prime}(u_{i-1})u_{i-1} - (\dfc(u_{i-1}) + \dfc(u_i))
+ \dfc^{\prime}(u_{i-1})u_i)\\ 
J_{i,i+1} &= \frac{\partial A_{i,i+1}}{\partial u_{i-1}}u_{i+1}
+ A_{i+1,i} +
\frac{\partial A_{i,i}}{\partial u_{i+1}}u_i
- \frac{\partial b_i}{\partial u_{i+1}}\\ 
&=\frac{1}{2\Delta x^2}(
-\dfc^{\prime}(u_{i+1})u_{i+1} - (\dfc(u_{i}) + \dfc(u_{i+1}))
+ \dfc^{\prime}(u_{i+1})u_i)
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Newton's method; nonlinear equations at the end points  <a name="___sec86"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
F_i &= -\frac{1}{2\Delta x^2}
((\dfc(u_i)+\dfc(u_{i+1}))(u_{i+1}-u_i) -
(\dfc(u_{i-1})+\dfc(u_{i}))\times \\ 
&\qquad (u_{i}-u_{i-1})) + au_i - f(u_i) = 0
\end{align*}
$$
<p>&nbsp;<br>


<p>
At \( i=0 \), replace \( u_{-1} \) by formula from Neumann condition.

<ol>
<p><li> Exclude Dirichlet condition as separate equation:
   replace \( u_i \), \( i=N_x \), by \( D \) in \( F_{i} \), \( i=N_x-1 \)</li>
<p><li> Include Dirichlet condition as separate equation:</li>
</ol>
<p>

<p>&nbsp;<br>
$$ F_{N_x}(u_0,\ldots,u_{N_x}) = u_{N_x} - D = 0\tp$$
<p>&nbsp;<br>


<p>
Note: The size of the Jacobian depends on 1 or 2.

<p>

</section>


<section class="slide">

<h2>Galerkin-type discretizations <a name="nonlin:alglevel:1D:fe"></a></h2>

<ul>
 <p><li> \( V \): function space with basis functions \( \baspsi_i(x) \), \( i\in\If \)</li>
 <p><li> Dirichlet conditionat \( x=L \): \( \baspsi_i(L)=0 \), \( i\in\If \) (\( v(L)=0\ \forall v\in V \))</li>
 <p><li> \( u = D + \sum_{j\in\If}c_j\baspsi_j \)</li>
</ul>
<p>

Galerkin's method for \( -(\dfc(u)u')' + au = f(u) \):

<p>&nbsp;<br>
$$
\int_0^L \dfc(u)u^{\prime}v^{\prime}\dx + \int_0^L auv\dx =
\int_0^L f(u)v\dx + [\dfc(u)u^{\prime}v]_0^L,\quad \forall v\in V
$$
<p>&nbsp;<br>


<p>
Insert Neumann condition:

<p>&nbsp;<br>
$$ [\dfc(u)u^{\prime}v]_0^L = \dfc(u(L))u^{\prime}(L)v(L) - \dfc(u(0))u^{\prime}(0)v(0)
= -Cv(0)
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The nonlinear algebraic equations  <a name="___sec88"></a></h2>

<p>
Find \( u\in V \) such that

<p>&nbsp;<br>
$$
\int_0^L \dfc(u)u^{\prime}v^{\prime}\dx + \int_0^L auv\dx =
\int_0^L f(u)v\dx - Cv(0),\quad \forall v\in V
$$
<p>&nbsp;<br>


<p>
\( \forall v\in V\ \Rightarrow\ \forall i\in\If \), \( v=\baspsi_i \).
Inserting \( u=D+\sum_jc_j\baspsi_j \)
and sorting terms:

<p>&nbsp;<br>
$$
\sum_{j}\left(
\int\limits_0^L \dfc(D+\sum_{k}c_k\baspsi_k)
\baspsi_j^{\prime}\baspsi_i^{\prime}\dx\right)c_j =
\int\limits_0^L f(D+\sum_{k}c_k\baspsi_k)\baspsi_i\dx -
C\baspsi_i(0)
$$
<p>&nbsp;<br>


<p>
This is a <em>nonlinear algebraic system</em>

<p>

</section>


<section class="slide">

<h2>Fundamental integration problem: how to deal with \( \int f(\sum_kc_k\baspsi_k)\baspsi_idx \) for unknown \( c_k \)?  <a name="___sec89"></a></h2>

<ul>
 <p><li> We do not know \( c_k \) in \( \int_0^L f(\sum_kc_k\baspsi_k)\baspsi_i dx \) and
   \( \int_0^L \dfc(\sum_{k}c_k\baspsi_k)\baspsi_i^{\prime}\baspsi_j^{\prime}\dx \)</li>
 <p><li> Solution: numerical integration with approximations to \( c_k \),
   as in \( \int_0^L f(u^{-})\baspsi_idx \)</li>
</ul>
<p>


<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Next: want to do <em>symbolic integration</em> of such terms to see the
structure of nonlinear finite element equations (to compare with
finite differences)
</div>
<!-- end box -->


<p>

</section>


<section class="slide">

<h2>We choose \( \baspsi_i \) as finite element basis functions  <a name="___sec90"></a></h2>

<p>&nbsp;<br>
$$ \baspsi_i = \basphi_{\nu(i)},\quad i\in\If$$
<p>&nbsp;<br>


<p>
Degree of freedom number \( \nu(i) \) in the mesh corresponds to
unknown number \( i \) (\( c_i \)).

<p>
Model problem: \( \nu(i)=i \), \( \If=\{0,\ldots,N_n-2\} \) (last node excluded)

<p>&nbsp;<br>
$$ u = D + \sum_{j\in\If} c_j\basphi_{\nu(j)}$$
<p>&nbsp;<br>


<p>
or with \( \basphi_i \) in the boundary function:

<p>&nbsp;<br>
$$ u = D\basphi_{N_n-1} + \sum_{j\in\If} c_j\basphi_{j}$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The group finite element method <a name="nonlin:alglevel:1D:fe:group"></a></h2>

<p>
Since \( u \) is represented by \( \sum_j\basphi_j u(\xno{j}) \), we may use the
same approximation for \( f(u) \):

<p>&nbsp;<br>
$$
f(u)\approx \sum_{j} f(\xno{j})\basphi_j
$$
<p>&nbsp;<br>


<p>
\( f(\xno{j}) \): value of \( f \) at node \( j \). With
\( u_j \) as \( u(\xno{j}) \), we can write

<p>&nbsp;<br>
$$
f(u)\approx \sum_{j} f(u_{j})\basphi_j
$$
<p>&nbsp;<br>


<p>
This approximation is known as the <em>group finite element method</em>
or the <em>product approximation</em> technique. The index \( j \) runs over
all node numbers in the mesh.

<p>

</section>


<section class="slide">

<h2>What is the point with the group finite element method?  <a name="___sec92"></a></h2>

<ol>
<p><li> Complicated nonlinear expressions can be simplified to increase
   the efficiency of numerical computations.</li>
<p><li> One can derive <em>symbolic forms</em> of the difference equations arising
   from the finite element method in nonlinear problems.
   The symbolic form is useful for comparing finite element and finite
   difference equations of nonlinear differential equation problems.</li>
</ol>
<p>


</section>


<section class="slide">

<h2>Simplified problem for symbolic calculations  <a name="___sec93"></a></h2>

<p>
Simple nonlinear problem: \( -u^{\prime\prime}=u^2 \),
\( u'(0)=1 \), \( u'(L)=0 \).

<p>&nbsp;<br>
$$ \int_0^L u^{\prime}v^{\prime}\dx = \int_0^L u^2v\dx
- v(0),\quad\forall v\in V$$
<p>&nbsp;<br>


<p>
Now,

<ul>
  <p><li> Focus on \( \int u^2v\dx \)</li>
  <p><li> Set \( c_j = u(\xno{j}) = u_j \) <br />
    (to mimic finite difference interpretation of \( u_j \))</li>
  <p><li> That is, \( u = \sum_ju_j\basphi_j \)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Integrating very simple nonlinear functions results in complicated expressions in the finite element method  <a name="___sec94"></a></h2>

<p>
Consider \( \int u^2v\dx \) with \( u = \sum_ku_k\basphi_k \) and \( v=\basphi_i \):

<p>&nbsp;<br>
$$ \int_0^L (\sum_ku_k\basphi_k)^2\basphi_i\dx$$
<p>&nbsp;<br>


<p>
Tedious exact evaluation on uniform P1 elements:

<p>&nbsp;<br>
$$ \frac{h}{12}(u_{i-1}^2 + 2u_i(u_{i-1} + u_{i+1}) + 6u_i^2
+ u_{i+1}^2)$$
<p>&nbsp;<br>


<p>
Finite difference counterpart: \( u_i^2 \) (!)

<p>

</section>


<section class="slide">

<h2>Application of the group finite element method  <a name="___sec95"></a></h2>

<p>&nbsp;<br>
$$ \int_0^L f(u)\basphi_i\dx \approx
\int_0^L (\sum_j \basphi_jf(u_j))\basphi_i\dx
= \sum_j (\underbrace{\int_0^L \basphi_i\basphi_j\dx}_{\mbox{mass matrix }M_{i,j}}) f(u_j)$$
<p>&nbsp;<br>


<p>
Corresponding part of difference equation for P1 elements:

<p>&nbsp;<br>
$$ \frac{h}{6}(f(u_{i-1}) + 4f(u_i) + f(u_{i+1}))$$
<p>&nbsp;<br>


<p>
Rewrite as &quot;finite difference form plus something&quot;:

<p>&nbsp;<br>
$$ \frac{h}{6}(f(u_{i-1}) + 4f(u_i) + f(u_{i+1}))
= h[{\color{red}f(u)} - \frac{h^2}{6}D_xD_x f(u)]_i$$
<p>&nbsp;<br>


<p>
This is like the finite difference discretization of
\( -u'' = f(u) - \frac{h^2}{6}f''(u) \)

<p>

</section>


<section class="slide">

<h2>Lumping the mass matrix gives finite difference form  <a name="___sec96"></a></h2>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Lumped mass matrix (integrate at the nodes): \( M \) becomes diagonal and
the finite element and difference method's treatment of \( f(u) \)
becomes identical!
</div>
<!-- end box -->


<p>

</section>


<section class="slide">

<h2>Alternative: evaluation of finite element terms at nodes gives great simplifications  <a name="___sec97"></a></h2>

<p>
Idea: integrate \( \int f(u)v\dx \) numerically with a rule that samples \( f(u)v \)
at the nodes only. This involves great simplifications, since

<p>&nbsp;<br>
$$ \sum_k u_k\basphi_k(\xno{\ell}) = u_\ell$$
<p>&nbsp;<br>


<p>
and

<p>&nbsp;<br>
$$ f\basphi_i(\xno{\ell}) =
f(\sum_k u_k\underbrace{\basphi_k(\xno{\ell})}_{\delta_{k\ell}})
\underbrace{\basphi_i(\xno{\ell})}_{\delta_{i\ell}}
= f(u_\ell)\delta_{i\ell}\quad \neq 0\mbox{ only for } f(u_i)$$
<p>&nbsp;<br>


<p>
(\( \delta_{ij}=0 \) if \( i\neq j \) and \( \delta_{ij}=1 \) if \( i=j \))

<p>

</section>


<section class="slide">

<h2>Numerical integration of nonlinear terms <a name="nonlin:alglevel:1D:fe:f"></a></h2>

<p>
Trapezoidal rule with the nodes only gives the finite difference form of \( [f(u)]_i \):

<p>&nbsp;<br>
$$
\int_0^L f(\sum_k u_k\basphi_k)(x)\basphi_i(x)\dx
\approx h\sum_{\ell=0}^{N_n-1} f(u_\ell)\delta_{i\ell} - \mathcal{C}
= h{\color{red}f(u_i)}
$$
<p>&nbsp;<br>


<p>
(\( \mathcal{C} \): boundary adjustment of rule, \( i=0,N_n-1 \))

<p>

</section>


<section class="slide">

<h2>Finite elements for a variable coefficient Laplace term <a name="nonlin:alglevel:1D:fe:Laplace"></a></h2>

<p>
Consider the term \( (\dfc u^{\prime})^{\prime} \), with
the group finite element method: \( \dfc(u)\approx \sum_k\alpha(u_k)\basphi_k \),
and the variational counterpart

<p>&nbsp;<br>
$$
\int_0^L \dfc(\sum_k c_k\basphi_k)\basphi_i^{\prime}\basphi_j^{\prime}\dx
\approx
\sum_k (\int_0^L \basphi_k\basphi_i^{\prime}\basphi_j^{\prime}\dx)
\dfc(u_k) = \ldots
$$
<p>&nbsp;<br>


<p>
Further calculations (see text) lead to

<p>&nbsp;<br>
$$
-\frac{1}{h}(\half(\dfc(u_i) + \dfc(u_{i+1}))(u_{i+1}-u_i)
-  \half(\dfc(u_{i-1}) + \dfc(u_{i}))(u_{i}-u_{i-1}))
$$
<p>&nbsp;<br>


<p>
= standard finite difference discretization
of \( -(\dfc(u)u^{\prime})^{\prime} \) with an arithmetic mean of \( \dfc(u) \)

<p>

</section>


<section class="slide">

<h2>Numerical integration at the nodes  <a name="___sec100"></a></h2>

<p>
Instead of the group finite element method and exact integration, use
Trapezoidal rule in the nodes for \( \int_0^L \dfc(\sum_k u_k\basphi_k)\basphi_i^{\prime}\basphi_j^{\prime}\dx \).

<p>
Work at the cell level (most convenient with discontinuous
\( \basphi_i' \)):

<p>&nbsp;<br>
$$
\begin{align*}
& \int_{-1}^1 \alpha(\sum_t\tilde u_t\refphi_t)\refphi_r'\refphi_s'\frac{h}{2}dX
= \int_{-1}^1 \dfc(\sum_{t=0}^1
\tilde u_t\refphi_t)\frac{2}{h}\frac{d\refphi_r}{dX}
\frac{2}{h}\frac{d\refphi_s}{dX}\frac{h}{2}dX\\ 
&\quad = \frac{1}{2h}(-1)^r(-1)^s \int_{-1}^1 \dfc(\sum_{t=0}^1 u_t\refphi_t(X))dX
\\ 
& \qquad \approx \frac{1}{2h}(-1)^r(-1)^s\dfc (
\sum_{t=0}^1\refphi_t(-1)\tilde u_t) + \dfc(\sum_{t=0}^1\refphi_t(1)\tilde u_t)\\ 
&\quad = \frac{1}{2h}(-1)^r(-1)^s(\dfc(\tilde u_0) + \dfc(\tilde u^{(1)}))
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Summary of finite element vs finite difference nonlinear algebraic equations  <a name="___sec101"></a></h2>

<p>&nbsp;<br>
$$ -(\dfc(u)u^{\prime})^{\prime} +au = f(u)$$
<p>&nbsp;<br>


<p>
Uniform P1 finite elements:

<ul>
 <p><li> Group finite element or Trapezoidal integration at nodes: <br />
   \( -(\dfc(u)u^{\prime})^{\prime} \) becomes \( -h[D_x\overline{\dfc(u)}^xD_x u]_i \)</li>
 <p><li> \( f(u) \) becomes \( hf(u_i) \) with Trapezoidal integration <br />
   or the &quot;mass matrix&quot; representation \( h[f(u) - \frac{h}{6}D_xD_x f(u)]_i \)
   if group finite elements</li>
 <p><li> \( au \) leads to the &quot;mass matrix&quot; form \( ah[u - \frac{h}{6}D_xD_x u]_i \)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Real computations utilize accurate numerical integration  <a name="___sec102"></a></h2>

<ul>
 <p><li> Previous group finite element or Trapezoidal integration examples had
   one aim: derive symbolic expressions for finite element equations</li>
 <p><li> Real world computations apply numerical integration</li>
 <p><li> How to define Picard iteration and Newton's method from a
   variational form with numerical integration in real world computations?</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Picard iteration defined from the variational form <a name="nonlin:alglevel:1D:fe:Picard"></a></h2>

<p>&nbsp;<br>
$$
-(\dfc(u)u^{\prime})^{\prime} + au = f(u),\quad x\in (0,L),
\quad \dfc(u(0))u^{\prime}(0) = C,\ u(L)=D
$$
<p>&nbsp;<br>


<p>
Variational form (\( v=\baspsi_i \)):

<p>&nbsp;<br>
$$
F_i =
\int_0^L \dfc(u)u^{\prime}\baspsi_i^{\prime}\dx + \int_0^L au\baspsi_i\dx -
\int_0^L f(u)\baspsi_i\dx + C\baspsi_i(0) = 0
$$
<p>&nbsp;<br>


<p>
Picard iteration: use &quot;old value&quot; \( u^{-} \) in \( \dfc(u) \) and \( f(u) \)
and integrate numerically:

<p>&nbsp;<br>
$$
F_i = \int_0^L (\dfc(u^{-})u^{\prime}\baspsi_i^{\prime} + au\baspsi_i)\dx -
\int_0^L f(u^{-})\baspsi_i\dx + C\baspsi_i(0)
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The linear system in Picard iteration  <a name="___sec104"></a></h2>

<p>&nbsp;<br>
$$
F_i = \int_0^L (\dfc(u^{-})u^{\prime}\baspsi_i^{\prime} + au\baspsi_i)\dx -
\int_0^L f(u^{-})\baspsi_i\dx + C\baspsi_i(0)
$$
<p>&nbsp;<br>


<p>
This is a linear problem \( a(u,v)=L(v) \) with bilinear and linear forms

<p>&nbsp;<br>
$$ a(u,v) = \int_0^L (\dfc(u^{-})u^{\prime}v^{\prime} + auv)\dx,\quad
L(v) = \int_0^L f(u^{-})v\dx - Cv(0)$$
<p>&nbsp;<br>


<p>
The linear system now is computed the standard way.

<p>

</section>


<section class="slide">

<h2>The equations in Newton's method <a name="nonlin:alglevel:1D:fe:Newton"></a></h2>

<p>&nbsp;<br>
$$
F_i =
\int_0^L (\dfc(u)u^{\prime}\baspsi_i^{\prime} + au\baspsi_i -
f(u)\baspsi_i)\dx + C\baspsi_i(0)=0,\quad i\in\If
$$
<p>&nbsp;<br>


<p>
Easy to evaluate right-hand side \( -F_i(u^{-}) \) by numerical integration:

<p>&nbsp;<br>
$$
F_i =
\int_0^L (\dfc(u^{-})u^{\prime}\baspsi_i^{\prime} + au\baspsi_i -
f(u^{-})\baspsi_i)\dx + C\baspsi_i(0)=0
$$
<p>&nbsp;<br>


<p>
(just known functions)

<p>

</section>


<section class="slide">

<h2>Useful formulas for computing the Jacobian  <a name="___sec106"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
\frac{\partial u}{\partial c_j} &= \frac{\partial}{\partial c_j}
\sum_kc_k\baspsi_k = \baspsi_j\\ 
\frac{\partial u^{\prime}}{\partial c_j} &= \frac{\partial}{\partial c_j}
\sum_kc_k\baspsi_k^{\prime} = \baspsi_j^{\prime}
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Computing the Jacobian  <a name="___sec107"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
J_{i,j} = \frac{\partial F_i}{\partial c_j}
& = \int_0^L \frac{\partial}{\partial c_j}
(\dfc(u)u^{\prime}\baspsi_i^{\prime} + au\baspsi_i -
f(u)\baspsi_i)\dx\\ 
&=
\int_0^L
((\dfc^{\prime}(u)\frac{\partial u}{\partial c_j}u^{\prime} +
\dfc(u)\frac{\partial u^{\prime}}{\partial c_j})\baspsi_i^{\prime}
+ a\frac{\partial u}{\partial c_j}\baspsi_i -
f^{\prime}(u)\frac{\partial u}{\partial c_j}\baspsi_i)\dx\\ 
&=
\int_0^L
((\dfc^{\prime}(u)\baspsi_ju^{\prime} +
\dfc(u)\baspsi_j^{\prime}\baspsi_i^{\prime}
+ a\baspsi_j\baspsi_i -
f^{\prime}(u)\baspsi_j\baspsi_i)\dx\\ 
&=
\int_0^L
(\dfc^{\prime}(u)u^{\prime}\baspsi_i^{\prime}\baspsi_j +
\dfc(u)\baspsi_i^{\prime}\baspsi_j^{\prime}
+ (a - f(u))\baspsi_i\baspsi_j)\dx
\end{align*}
$$
<p>&nbsp;<br>


<p>
Use \( \dfc^{\prime}(u^{-}) \), \( \dfc(u^{-}) \), \( f^\prime (u^{-}) \), \( f(u^{-}) \)
and integrate expressions numerically (only known functions)

<p>

</section>


<section class="slide">

<h2>Computations in a reference cell \( [-1,1] \)  <a name="___sec108"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
\tilde F_r^{(e)} &=
\int_{-1}^1\left(
\dfc(\tilde u^{-})\tilde u^{-\prime}\refphi_r^{\prime} +
(a-f(\tilde u^{-}))\refphi_r\right)\det J\dX -
C\refphi_r(0)
\\ 
\tilde J_{r,s}^{(e)} &=
\int_{-1}^1
(\dfc^{\prime}(\tilde u^{-})\tilde u^{-\prime}\refphi_r^{\prime}\refphi_s +
\dfc(\tilde u^{-})\refphi_r^{\prime}\refphi_s^{\prime}
+ (a - f(\tilde u^{-}))\refphi_r\refphi_s)\det J\dX
\end{align*}
$$
<p>&nbsp;<br>


<p>
\( r,s\in\Ifd \) (local degrees of freedom)

<p>

</section>


<section class="slide">

<h2>How to handle Dirichlet conditions in Newton's method  <a name="___sec109"></a></h2>

<ul>
 <p><li> Newton's method solves \( J(u^{-})\delta u = -F(u^{-}) \)</li>
 <p><li> \( \delta u \) is a <em>correction</em> to \( u^{-} \)</li>
 <p><li> If \( u(\xno{i}) \) has Dirchlet condition \( D \),
   set \( u^{-}_i=D \) in prior to the first iteration</li>
 <p><li> Set \( \delta u_i=0 \) (no change for Dirichlet conditions)</li>
</ul>
<p>


</section>


<section class="slide">

<h1 style="text-align: center;">Multi-dimensional PDE problems  <a name="___sec110"></a></h1>

<p>&nbsp;<br>
$$
u_t = \nabla\cdot(\dfc(u)\nabla u) + f(u)
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Backward Euler and variational form <a name="nonlin:alglevel:dD:fe"></a></h2>

<p>&nbsp;<br>
$$
u_t = \nabla\cdot(\dfc(u)\nabla u) + f(u)
$$
<p>&nbsp;<br>


<p>
Backward Euler time discretization:

<p>&nbsp;<br>
$$ u^n - \Delta t\nabla\cdot(\dfc(u^n)\nabla u^n) + f(u^n) = u^{n-1}$$
<p>&nbsp;<br>


<p>
Alternative notation (\( u \) for \( u^n \), \( u^{(1)} \) for \( u^{n-1} \)):

<p>&nbsp;<br>
$$ u - \Delta t\nabla\cdot(\dfc(u)\nabla u) - \Delta t f(u) = u^{(1)}$$
<p>&nbsp;<br>


<p>
Boundary conditions: \( \partial u/\partial n=0 \) for simplicity.
Variational form:

<p>&nbsp;<br>
$$
\int_\Omega (uv + \Delta t\,\dfc(u)\nabla u\cdot\nabla v
- \Delta t f(u)v - u^{(1)} v)\dx = 0
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Nonlinear algebraic equations arising from the variational form  <a name="___sec112"></a></h2>

<p>&nbsp;<br>
$$
\int_\Omega (uv + \Delta t\,\dfc(u)\nabla u\cdot\nabla v
- \Delta t f(u)v - u^{(1)} v)\dx = 0
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
F_i =
\int_\Omega (u\baspsi_i + \Delta t\,\dfc(u)\nabla u\cdot\nabla \baspsi_i
- \Delta t f(u)\baspsi_i - u^{(1)}\baspsi_i)\dx = 0
$$
<p>&nbsp;<br>


<p>
Picard iteration:

<p>&nbsp;<br>
$$
F_i \approx \hat F_i =
\int_\Omega (u\baspsi_i + \Delta t\,\dfc(u^{-})\nabla u\cdot\nabla \baspsi_i
- \Delta t f(u^{-})\baspsi_i - u^{(1)}\baspsi_i)\dx = 0
$$
<p>&nbsp;<br>


<p>
This is a variable coefficient problem like \( au - \nabla\cdot\dfc(\x)\nabla u
= f(\x,t) \) and results in a linear system

<p>

</section>


<section class="slide">

<h2>A note on our notation and the different meanings of \( u \) (1)  <a name="___sec113"></a></h2>

<p>
PDE problem: \( u(\x,t) \) is the exact solution of

<p>&nbsp;<br>
$$
u_t = \nabla\cdot(\dfc(u)\nabla u) + f(u)
$$
<p>&nbsp;<br>


<p>
Time discretization: \( u(\x) \) is the exact solution of the time-discrete
spatial equation

<p>&nbsp;<br>
$$ u - \Delta t\nabla\cdot(\dfc(u^n)\nabla u) - \Delta t f(u) = u^{(1)}$$
<p>&nbsp;<br>


<p>
The same \( u(\x) \) is the exact solution of the
(continuous) variational form:

<p>&nbsp;<br>
$$
\int_\Omega (uv + \Delta t\,\dfc(u)\nabla u\cdot\nabla v
- \Delta t f(u)v - u^{(1)} v)\dx,\quad\forall v\in V
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>A note on our notation and the different meanings of \( u \) (2)  <a name="___sec114"></a></h2>

<p>
Or we may approximate \( u \): \( u(\x) = \sum_jc_j\baspsi_j(\x) \) and
let this spatially discrete \( u \) enter the variational form,

<p>&nbsp;<br>
$$
\int_\Omega (uv + \Delta t\,\dfc(u)\nabla u\cdot\nabla v
- \Delta t f(u)v - u^{(1)} v)\dx,\quad\forall v\in V
$$
<p>&nbsp;<br>


<p>
Picard iteration: \( u(\x) \) solves the <em>approximate</em>
variational form

<p>&nbsp;<br>
$$
\int_\Omega (uv + \Delta t\,\dfc(u^{-})\nabla u\cdot\nabla v
- \Delta t f(u^{-})v - u^{(1)} v)\dx
$$
<p>&nbsp;<br>


<p>
Could introduce

<ul>
 <p><li> \( \uex(\x,t) \) for the exact solution of the PDE problem</li>
 <p><li> \( \uex(\x)^n \) for the exact solution after time discretization</li>
 <p><li> \( u^n(\x) \) for the spatially discrete solution \( \sum_jc_j\baspsi_j \)</li>
 <p><li> \( u^{n,k} \) for approximation in Picard/Newton iteration no \( k \)
   to \( u^n(\x) \)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Newton's method (1)  <a name="___sec115"></a></h2>

<p>
Need to evaluate \( F_i(u^{-}) \):

<p>&nbsp;<br>
$$
F_i \approx \hat F_i =
\int_\Omega (u^{-}\baspsi_i + \Delta t\,\dfc(u^{-})
\nabla u^{-}\cdot\nabla \baspsi_i
- \Delta t f(u^{-})\baspsi_i - u^{(1)}\baspsi_i)\dx
$$
<p>&nbsp;<br>


<p>
To compute the Jacobian we need

<p>&nbsp;<br>
$$
\begin{align*}
\frac{\partial u}{\partial c_j} &= \sum_k\frac{\partial}{\partial c_j}
c_k\baspsi_k = \baspsi_j\\ 
\frac{\partial \nabla u}{\partial c_j} &= \sum_k\frac{\partial}{\partial c_j}
c_k\nabla \baspsi_k = \nabla \baspsi_j
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Newton's method (2)  <a name="___sec116"></a></h2>

<p>
The Jacobian becomes

<p>&nbsp;<br>
$$
\begin{align*}
J_{i,j} = \frac{\partial F_i}{\partial c_j} =
\int_\Omega & (\baspsi_j\baspsi_i + \Delta t\,\dfc^{\prime}(u)\baspsi_j
\nabla u\cdot\nabla \baspsi_i +
\Delta t\,\dfc(u)\nabla\baspsi_j\cdot\nabla\baspsi_i - \\ 
&\ \Delta t f^{\prime}(u)\baspsi_j\baspsi_i)\dx
\end{align*}
$$
<p>&nbsp;<br>


<p>
Evaluation of \( J_{i,j} \) as the coefficient matrix in the
Newton system \( J\delta u = -F \) means \( J(u^{-}) \):

<p>&nbsp;<br>
$$
\begin{align*}
J_{i,j} =
\int_\Omega & (\baspsi_j\baspsi_i + \Delta t\,\dfc^{\prime}(u^{-})\baspsi_j
\nabla u^{-}\cdot\nabla \baspsi_i +
\Delta t\,\dfc(u^{-})\nabla\baspsi_j\cdot\nabla\baspsi_i - \\ 
&\ \Delta t f^{\prime}(u^{-})\baspsi_j\baspsi_i)\dx
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Non-homogeneous Neumann conditions  <a name="___sec117"></a></h2>

<p>
A natural physical flux condition:

<p>&nbsp;<br>
$$
-\dfc(u)\frac{\partial u}{\partial n} = g,\quad\x\in\partial\Omega_N
$$
<p>&nbsp;<br>


<p>
Integration by parts gives the boundary term

<p>&nbsp;<br>
$$
\int_{\partial\Omega_N}\dfc(u)\frac{\partial u}{\partial u}v\ds
$$
<p>&nbsp;<br>


<p>
Inserting the nonlinear Neumann condition:

<p>&nbsp;<br>
$$ -\int_{\partial\Omega_N}gv\ds$$
<p>&nbsp;<br>


<p>
(no nonlinearity)

<p>

</section>


<section class="slide">

<h2>Robin condition  <a name="___sec118"></a></h2>

<p>
Heat conduction problems often apply a kind of Newton's cooling law,
also known as a Robin condition, at the boundary:

<p>&nbsp;<br>
$$
-\dfc(u)\frac{\partial u}{\partial u} = h(u)(u-T_s(t)),\quad\x\in\partial\Omega_R
$$
<p>&nbsp;<br>


<p>
Here:

<ul>
 <p><li> \( h(u) \): heat transfer coefficient between the body (\( \Omega \))
   and its surroundings</li>
 <p><li> \( T_s \): temperature of the surroundings</li>
</ul>
<p>

Inserting the condition in the boundary integral
\( \int_{\partial\Omega_N}\dfc(u)\frac{\partial u}{\partial u}v\ds \):

<p>&nbsp;<br>
$$ \int_{\partial\Omega_R}h(u)(u-T_s(T))v\ds$$
<p>&nbsp;<br>


<p>
Use \( h(u^{-})(u-T_s) \) for Picard, differentiate for Newton

<p>

</section>


<section class="slide">

<h2>Finite difference discretization in a 2D problem <a name="nonlin:alglevel:dD:fd"></a></h2>

<p>&nbsp;<br>
$$ u_t = \nabla\cdot(\dfc(u)\nabla u) + f(u)$$
<p>&nbsp;<br>


<p>
Backward Euler in time, centered differences in space:

<p>&nbsp;<br>
$$ [D_t^- u = D_x\overline{\dfc(u)}^xD_x u
+ D_y\overline{\dfc(u)}^yD_y u + f(u)]_{i,j}^n
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{align*}
u^n_{i,j} &- \frac{\Delta t}{h^2}(
 \half(\dfc(u_{i,j}^n)   + \dfc(u_{i+1,j}^n))(u_{i+1,j}^n-u_{i,j}^n)\\ 
&\quad -
\half(\dfc(u_{i-1,j}^n) + \dfc(u_{i,j}^n))(u_{i,j}^n-u_{i-1,j}^n) \\ 
&\quad +
 \half(\dfc(u_{i,j}^n)   + \dfc(u_{i,j+1}^n))(u_{i,j+1}^n-u_{i,j}^n)\\ 
&\quad -
 \half(\dfc(u_{i,j-1}^n) + \dfc(u_{i,j}^n))(u_{i,j}^n-u_{i-1,j-1}^n))
- \Delta tf(u_{i,j}^n) = u^{n-1}_{i,j}
\end{align*}
$$
<p>&nbsp;<br>


<p>
Nonlinear algebraic system on the form \( A(u)u=b(u) \)

<p>

</section>


<section class="slide">

<h2>Picard iteration  <a name="___sec120"></a></h2>

<ul>
 <p><li> Use the most recently computed values \( u^{-} \) of \( u^n \)
   in \( \dfc \) and \( f \)</li>
 <p><li> Or: \( A(u^{-})u=b(u^{-}) \)</li>
 <p><li> Like solving \( u_t = \nabla\cdot (\dfc(\x)\nabla u) + f(\x,t) \)</li>
</ul>
<p>

Picard iteration in operator notation:

<p>&nbsp;<br>
$$ [D_t^- u = D_x\overline{\dfc(u^{-})}^xD_x u
+ D_y\overline{\dfc(u^{-})}^yD_y u + f(u^{-})]_{i,j}^n
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Newton's method: the nonlinear algebraic equations  <a name="___sec121"></a></h2>

<p>
Define the nonlinear equations (use \( u \) for \( u^n \), \( u^{(1)} \) for \( u^{n-1} \)):

<p>&nbsp;<br>
$$
\begin{align*}
F_{i,j} &= u_{i,j} - \frac{\Delta t}{h^2}(\\ 
&\qquad \half(\dfc(u_{i,j})   + \dfc(u_{i+1,j}))(u_{i+1,j}-u_{i,j}) -\\ 
&\qquad \half(\dfc(u_{i-1,j}) + \dfc(u_{i,j}))(u_{i,j}-u_{i-1,j}) + \\ 
&\qquad \half(\dfc(u_{i,j})   + \dfc(u_{i,j+1}))(u_{i,j+1}-u_{i,j}) -\\ 
&\qquad \half(\dfc(u_{i,j-1}) + \dfc(u_{i,j}))(u_{i,j}-u_{i-1,j-1})) -
\Delta t\, f(u_{i,j}) - u^{(1)}_{i,j} = 0
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Newton's method: the Jacobian and its sparsity  <a name="___sec122"></a></h2>

<p>&nbsp;<br>
$$ J_{i,j,r,s} = \frac{\partial F_{i,j}}{\partial u_{r,s}} $$
<p>&nbsp;<br>


<p>
Newton system:

<p>&nbsp;<br>
$$ \sum_{r\in\Ix}\sum_{s\in\Iy}J_{i,j,r,s}\delta u_{r,s} = -F_{i,j},
\quad i\in\Ix,\ j\in\Iy\tp$$
<p>&nbsp;<br>


<p>
But \( F_{i,j} \) contains only \( u_{i\pm 1,j} \),
\( u_{i,j\pm 1} \), and \( u_{i,j} \). We get nonzero contributions
only for
\( J_{i,j,i-1,j} \), \( J_{i,j,i+1,j} \), \( J_{i,j,i,j-1} \), \( J_{i,j,i,j+1} \),
and \( J_{i,j,i,j} \). The Newton system collapses to

<p>&nbsp;<br>
$$
\begin{align*}
 J_{i,j,r,s}\delta u_{r,s} =
J_{i,j,i,j}\delta u_{i,j} & +
J_{i,j,i-1,j}\delta u_{i-1,j} +\\ 
& J_{i,j,i+1,j}\delta u_{i+1,j} +
J_{i,j,i,j-1}\delta u_{i,j-1}
+ J_{i,j,i,j+1}\delta u_{i,j+1}
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Newton's method: details of the Jacobian  <a name="___sec123"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
J_{i,j,i-1,j} &= \frac{\partial F_{i,j}}{\partial u_{i-1,j}}\\ 
&= \frac{\Delta t}{h^2}(\dfc^{\prime}(u_{i-1,j})(u_{i,j}-u_{i-1,j})
+ \dfc(u_{i-1,j})(-1)),\\ 
J_{i,j,i+1,j} &= \frac{\partial F_{i,j}}{\partial u_{i+1,j}}\\ 
&= \frac{\Delta t}{h^2}(-\dfc^{\prime}(u_{i+1,j})(u_{i+1,j}-u_{i,j})
- \dfc(u_{i-1,j})),\\ 
J_{i,j,i,j-1} &= \frac{\partial F_{i,j}}{\partial u_{i,j-1}}\\ 
&= \frac{\Delta t}{h^2}(\dfc^{\prime}(u_{i,j-1})(u_{i,j}-u_{i,j-1})
+ \dfc(u_{i,j-1})(-1)),\\ 
J_{i,j,i,j+1} &= \frac{\partial F_{i,j}}{\partial u_{i,j+1}}\\ 
&= \frac{\Delta t}{h^2}(-\dfc^{\prime}(u_{i,j+1})(u_{i,j+1}-u_{i,j})
- \dfc(u_{i,j-1}))\tp
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Good exercise at this point: \( J_{i,j,i,j} \)  <a name="___sec124"></a></h2>

<p>
Compute \( J_{i,j,i,j} \):

<p>&nbsp;<br>
$$
\begin{align*}
F_{i,j} &= u_{i,j} - \frac{\Delta t}{h^2}(\\ 
&\qquad \half(\dfc(u_{i,j})   + \dfc(u_{i+1,j}))(u_{i+1,j}-u_{i,j}) -\\ 
&\qquad \half(\dfc(u_{i-1,j}) + \dfc(u_{i,j}))(u_{i,j}-u_{i-1,j}) + \\ 
&\qquad \half(\dfc(u_{i,j})   + \dfc(u_{i,j+1}))(u_{i,j+1}-u_{i,j}) -\\ 
&\qquad \half(\dfc(u_{i,j-1}) + \dfc(u_{i,j}))(u_{i,j}-u_{i-1,j-1})) -
\Delta t\, f(u_{i,j}) - u^{(1)}_{i,j} = 0\\ 
J_{i,j,i,j} &= \frac{\partial F_{i,j}}{\partial u_{i,j}}
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h1 style="text-align: center;">Continuation methods  <a name="___sec125"></a></h1>

<ul>
 <p><li> Picard iteration or Newton's method may diverge</li>
 <p><li> Relaxation with \( \omega < 1 \) may help</li>
 <p><li> If not, resort to <em>continuation methods</em></li>
</ul>
<p>


</section>


<section class="slide">

<h2>Continuation method: solve difficult problem as a sequence of simpler problems  <a name="___sec126"></a></h2>

<ul>
 <p><li> Introduce a <em>continuation parameter</em> \( \Lambda \)</li>
 <p><li> \( \Lambda =0 \): simple version of the PDE problem</li>
 <p><li> \( \Lambda =1 \): desired PDE problem</li>
 <p><li> Increase \( \Lambda \) in steps: \( \Lambda_0=0 ,\Lambda_1 < \cdots < \Lambda_n=1 \)</li>
 <p><li> Use the solution from \( \Lambda_{i-1} \) as
   initial guess for the iterations for \( \Lambda_i \)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Example on a continuation method  <a name="___sec127"></a></h2>

<p>&nbsp;<br>
$$ -\nabla\cdot\left( ||\nabla u||^q\nabla u\right) = f, $$
<p>&nbsp;<br>


<p>
Pseudo-plastic fluids may be \( q=-0.8 \), which is a difficult problem for
Picard/Newton iteration.

<p>&nbsp;<br>
$$ \Lambda\in [0,1]:\quad q=-\Lambda 0.8 $$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
-\nabla\cdot\left( ||\nabla u||^{-\Lambda 0.8}\nabla u\right) = f$$
<p>&nbsp;<br>


<p>
Start with \( \Lambda = 0 \), increase in steps to \( \Lambda =1 \), use
previous solution as initial guess for Newton or Picard


</section>




<footer>
<!-- Here goes a footer -->
</footer>

<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>
-->

<!-- deck.goto snippet
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>
-->

<!-- deck.hash snippet
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>
-->

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/notes/deck.notes.js"></script>

<!-- From https://github.com/mikeharris100/deck.pointer.js -->
<script src="deck.js/extensions/pointer/deck.pointer.js"></script>

<!-- From https://github.com/stvnwrgs/presenterview
<script type="text/javascript" src="deck.js/extensions/presenterview/deck.presenterview.js"></script> -->

<!-- From https://github.com/nemec/deck.annotate.js
<script type="text/javascript" src="deck.js/extensions/deck.annotate.js/deck.annotate.js"></script>
-->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>


</body>
</html>
