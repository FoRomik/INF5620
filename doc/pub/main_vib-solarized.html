<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for vibration problems">
<meta name="keywords" content="vibration ODE,oscillations,mechanical vibrations,period (of oscillations),frequency (of oscillations),Hz (unit),mesh finite differences,mesh function,centered difference,finite differences centered,making movies,stability criterion,mechanical energy,energy principle,forward-backward Euler-Cromer scheme,staggered mesh,staggered Euler-Cromer scheme,nonlinear restoring force,nonlinear spring,forced vibrations,geometric mean">



<style type="text/css">
    /* solarized style */
    body {
      margin:5;
      padding:0;
      border:0;	/* Remove the border around the viewport in old versions of IE */
      width:100%;
      background: #fdf6e3;
      min-width:600px;	/* Minimum width of layout - remove if not required */
      font-family: Verdana, Helvetica, Arial, sans-serif;
      font-size: 1.0em;
      line-height: 1.3em;
      color: #657b83;
    }
    a { color: #657b83; text-decoration:none; }
    a:hover { color: #b58900; background: #eee8d5; text-decoration:none; }
    h1, h2, h3 { margin:.8em 0 .2em 0; padding:0; line-height: 125%; }
    h2 { font-variant: small-caps; }
    pre {
      background: #fdf6e3;
      -webkit-box-shadow: inset 0 0 2px #000000;
      -moz-box-shadow: inset 0 0 2px #000000;
      box-shadow: inset 0 0 2px #000000;
      color: #586e75;
      margin-left: 0px;
      font-family: 'Droid Sans Mono', monospace;
      padding: 2px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      -moz-background-clip: padding;
      -webkit-background-clip: padding-box;
      background-clip: padding-box;
    }
    tt { font-family: "Courier New", Courier; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p { text-indent: 0px; }
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #FFBF00;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #fbeed5;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_yellow_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference discretization ',
               1,
               'vib:model1',
               'vib:model1'),
              (' A basic model for vibrations ', 2, None, '___sec1'),
              (' A centered finite difference scheme ',
               2,
               'vib:ode1:fdm',
               'vib:ode1:fdm'),
              (' Step 1: Discretizing the domain ', 3, None, '___sec3'),
              (' Step 2: Fulfilling the equation at discrete time points ',
               3,
               None,
               '___sec4'),
              (' Step 3: Replacing derivatives by finite differences ',
               3,
               None,
               '___sec5'),
              (' Step 4: Formulating a recursive algorithm ',
               3,
               None,
               '___sec6'),
              (' Computing the first step ', 3, None, '___sec7'),
              (' The computational algorithm ', 3, None, '___sec8'),
              (' Operator notation ', 3, None, '___sec9'),
              (" Computing $u'$ ", 3, None, '___sec10'),
              (' Implementation ', 1, 'vib:impl1', 'vib:impl1'),
              (' Making a solver function ', 2, None, '___sec12'),
              (' Verification ', 2, 'vib:ode1:verify', 'vib:ode1:verify'),
              (' Manual calculation ', 3, None, '___sec14'),
              (' Testing very simple solutions ', 3, None, '___sec15'),
              (' Checking convergence rates ', 3, None, '___sec16'),
              (' Long time simulations ',
               1,
               'vib:ode1:longseries',
               'vib:ode1:longseries'),
              (' Using a moving plot window ', 2, None, '___sec18'),
              (' Making a movie file ', 2, None, '___sec19'),
              (' Using a line-by-line ascii plotter ', 2, None, '___sec20'),
              (' Empirical analysis of the solution ',
               2,
               'vib:ode1:empirical',
               'vib:ode1:empirical'),
              (' Analysis of the numerical scheme ',
               1,
               'vib:ode1:analysis',
               'vib:ode1:analysis'),
              (' Deriving an exact numerical solution ', 2, None, '___sec23'),
              (' Exact discrete solution ', 2, None, '___sec24'),
              (' Stability ', 2, None, '___sec25'),
              (' Alternative schemes based on 1st-order equations ',
               1,
               'vib:model2x2',
               'vib:model2x2'),
              (' Standard methods for 1st-order ODE systems ',
               2,
               'vib:undamped:1stODE',
               'vib:undamped:1stODE'),
              (' The Forward Euler scheme ', 3, None, '___sec28'),
              (' The Backward Euler scheme ', 3, None, '___sec29'),
              (' The Crank-Nicolson scheme ', 3, None, '___sec30'),
              (' Comparison of schemes ', 3, None, '___sec31'),
              (' Enegy considerations ',
               2,
               'vib:model1:energy',
               'vib:model1:energy'),
              (' Derivation of the energy expression ', 3, None, '___sec33'),
              (' Example ', 3, None, '___sec34'),
              (' Discrete total energy ', 3, None, '___sec35'),
              (' An error measure based on total energy ',
               3,
               None,
               '___sec36'),
              (' The Euler-Cromer method ',
               2,
               'vib:model2x2:EulerCromer',
               'vib:model2x2:EulerCromer'),
              (' Forward-backward discretization ', 3, None, '___sec38'),
              (' Equivalence with the scheme for the second-order ODE ',
               3,
               None,
               '___sec39'),
              (' The Euler-Cromer scheme on a staggered mesh ',
               2,
               'vib:model2x2:staggered',
               'vib:model2x2:staggered'),
              (' Implementation of the scheme on a staggered mesh ',
               2,
               None,
               '___sec41'),
              (' Implementation with integer indices ', 3, None, '___sec42'),
              (' Implementation with half-integer indices ',
               3,
               None,
               '___sec43'),
              (' Generalization: damping, nonlinear spring, and external excitation ',
               1,
               'vib:model2',
               'vib:model2'),
              (' A centered scheme for linear damping ',
               2,
               'vib:ode2:fdm:flin',
               'vib:ode2:fdm:flin'),
              (' A centered scheme for quadratic damping ',
               2,
               'vib:ode2:fdm:fquad',
               'vib:ode2:fdm:fquad'),
              (' Implementation ', 2, 'vib:ode2:solver', 'vib:ode2:solver'),
              (' Verification ', 2, 'vib:ode2:verify', 'vib:ode2:verify'),
              (' Constant solution ', 3, None, '___sec49'),
              (' Linear solution ', 3, None, '___sec50'),
              (' Quadratic solution ', 3, None, '___sec51'),
              (' Visualization ', 2, 'vib:ode2:viz', 'vib:ode2:viz'),
              (' User interface ', 2, 'vib:ode2:ui', 'vib:ode2:ui'),
              (' A staggered Euler-Cromer scheme for the generalized model ',
               2,
               'vib:ode2:staggered',
               'vib:ode2:staggered'),
              (' Exercises and Problems ', 1, None, '___sec55'),
              (' Problem 1: Use linear/quadratic functions for verification ',
               2,
               'vib:exer:undamped:verify:linquad',
               'vib:exer:undamped:verify:linquad'),
              (' Exercise 1: Show linear growth of the phase with time ',
               2,
               'vib:exer:phase:err:growth',
               'vib:exer:phase:err:growth'),
              (' Exercise 2: Improve the accuracy by adjusting the frequency ',
               2,
               'vib:exer:w:adjust',
               'vib:exer:w:adjust'),
              (' Exercise 3: See if adaptive methods improve the phase error ',
               2,
               'vib:exer:undamped:adaptive',
               'vib:exer:undamped:adaptive'),
              (' Exercise 4: Use a Taylor polynomial to compute $u^1$ ',
               2,
               'vib:exer:step4b:alt',
               'vib:exer:step4b:alt'),
              (' Exercise 5: Find the minimal resolution of an oscillatory function ',
               2,
               'vib:exer:wdt:limit',
               'vib:exer:wdt:limit'),
              (' Exercise 6: Visualize the accuracy of finite differences for a cosine function ',
               2,
               'vib:exer:fd:exp:plot',
               'vib:exer:fd:exp:plot'),
              (' Exercise 7: verify convergence rates of the error in energy ',
               2,
               'vib:exer:energy:convrate',
               'vib:exer:energy:convrate'),
              (' Exercise 8: Use linear/quadratic functions for verification ',
               2,
               'vib:exer:verify:gen:linear',
               'vib:exer:verify:gen:linear'),
              (' Exercise 9: Use an exact discrete solution for verification ',
               2,
               'vib:exer:discrete:omega',
               'vib:exer:discrete:omega'),
              (' Exercise 10: Use analytical solution for convergence rate tests ',
               2,
               'vib:exer:conv:rate',
               'vib:exer:conv:rate'),
              (' Exercise 11: Investigate the amplitude errors of many solvers ',
               2,
               'vib:exer:undamped:odespy',
               'vib:exer:undamped:odespy'),
              (' Exercise 12: Minimize memory usage of a vibration solver ',
               2,
               'vib:exer:memsave',
               'vib:exer:memsave'),
              (' Exercise 13: Implement the solver via classes ',
               2,
               'vib:exer:gen:class',
               'vib:exer:gen:class'),
              (' Exercise 14: Show equivalence between schemes ',
               2,
               'vib:exer:schemes:equiv',
               'vib:exer:schemes:equiv'),
              (' References ', 1, None, '___sec71')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{u_{\small\mbox{e}}}
\newcommand{\Aex}{A_{\small\mbox{e}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{{\cal O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{{\cal I}_x}
\newcommand{\Iy}{{\cal I}_y}
\newcommand{\Iz}{{\cal I}_z}
\newcommand{\It}{{\cal I}_t}
\newcommand{\setb}[1]{{#1}^0}    % set begin
\newcommand{\sete}[1]{{#1}^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{{#1}^-}
\newcommand{\setr}[1]{{#1}^+}
\newcommand{\seti}[1]{{#1}^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0000"></a>
<!-- begin top navigation --><!-- end top navigation -->

<p>
<!-- ------------------- main content ---------------------- -->


<title>Finite difference methods for vibration problems</title>

<center><h1>Finite difference methods for vibration problems</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Sep 9, 2013</h4></center> <!-- date -->
<p>
Note: <b>PRELIMINARY VERSION</b> (expect typos)

<h2>Table of contents</h2>

<p>
<a href="#vib:model1"> Finite difference discretization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> A basic model for vibrations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode1:fdm"> A centered finite difference scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec3"> Step 1: Discretizing the domain </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec4"> Step 2: Fulfilling the equation at discrete time points </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec5"> Step 3: Replacing derivatives by finite differences </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec6"> Step 4: Formulating a recursive algorithm </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec7"> Computing the first step </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec8"> The computational algorithm </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec9"> Operator notation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec10"> Computing \( u' \) </a><br>
<a href="#vib:impl1"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> Making a solver function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode1:verify"> Verification </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec14"> Manual calculation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec15"> Testing very simple solutions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec16"> Checking convergence rates </a><br>
<a href="#vib:ode1:longseries"> Long time simulations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Using a moving plot window </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Making a movie file </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> Using a line-by-line ascii plotter </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode1:empirical"> Empirical analysis of the solution </a><br>
<a href="#vib:ode1:analysis"> Analysis of the numerical scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec23"> Deriving an exact numerical solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Exact discrete solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Stability </a><br>
<a href="#vib:model2x2"> Alternative schemes based on 1st-order equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:undamped:1stODE"> Standard methods for 1st-order ODE systems </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec28"> The Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec29"> The Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec30"> The Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec31"> Comparison of schemes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model1:energy"> Enegy considerations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec33"> Derivation of the energy expression </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec34"> Example </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec35"> Discrete total energy </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec36"> An error measure based on total energy </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model2x2:EulerCromer"> The Euler-Cromer method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec38"> Forward-backward discretization </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec39"> Equivalence with the scheme for the second-order ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model2x2:staggered"> The Euler-Cromer scheme on a staggered mesh </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Implementation of the scheme on a staggered mesh </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec42"> Implementation with integer indices </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec43"> Implementation with half-integer indices </a><br>
<a href="#vib:model2"> Generalization: damping, nonlinear spring, and external excitation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:fdm:flin"> A centered scheme for linear damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:fdm:fquad"> A centered scheme for quadratic damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:solver"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:verify"> Verification </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec49"> Constant solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec50"> Linear solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec51"> Quadratic solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:viz"> Visualization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:ui"> User interface </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:staggered"> A staggered Euler-Cromer scheme for the generalized model </a><br>
<a href="#___sec55"> Exercises and Problems </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:undamped:verify:linquad"> Problem 1: Use linear/quadratic functions for verification </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:phase:err:growth"> Exercise 1: Show linear growth of the phase with time </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:w:adjust"> Exercise 2: Improve the accuracy by adjusting the frequency </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:undamped:adaptive"> Exercise 3: See if adaptive methods improve the phase error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:step4b:alt"> Exercise 4: Use a Taylor polynomial to compute \( u^1 \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:wdt:limit"> Exercise 5: Find the minimal resolution of an oscillatory function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:fd:exp:plot"> Exercise 6: Visualize the accuracy of finite differences for a cosine function </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:energy:convrate"> Exercise 7: verify convergence rates of the error in energy </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:verify:gen:linear"> Exercise 8: Use linear/quadratic functions for verification </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:discrete:omega"> Exercise 9: Use an exact discrete solution for verification </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:conv:rate"> Exercise 10: Use analytical solution for convergence rate tests </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:undamped:odespy"> Exercise 11: Investigate the amplitude errors of many solvers </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:memsave"> Exercise 12: Minimize memory usage of a vibration solver </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:gen:class"> Exercise 13: Implement the solver via classes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:exer:schemes:equiv"> Exercise 14: Show equivalence between schemes </a><br>
<a href="#___sec71"> References </a><br>

<p>
<!-- Externaldocuments: ../decay/main_decay -->

<p>
Vibration problems lead to differential equations with solutions that
oscillates in time, typically in a damped or undamped sinusoidal
fashion.  Such solutions put certain demands on the numerical methods
compared to other phenomena whose solutions are monotone.
Both the frequency and amplitude of the oscillations need to be
accurately handled by the numerical schemes. Most of the reasoning and
specific building blocks introduced in the fortcoming text can be
reused to construct sound methods for partial differential equations
of wave nature in multiple spatial dimensions.

<p>
<!-- 2DO: -->
<!-- Long time integration by adaptive RK: will that improve the -->
<!-- phase error? Do experiments where we measure the wavelength -->
<!-- and plot it as function of time. Can we vectorize the -->
<!-- max/min pt computation? -->

<h2>Finite difference discretization <a name="vib:model1"></a></h2>

<p>
Much of the numerical challenges with computing oscillatory
solutions in ODEs and PDEs can be captured by the very simple
ODE \( u'' + u =0 \) and this is therefore the starting point for
method development, implementation, and analysis.

<h3>A basic model for vibrations  <a name="___sec1"></a></h3>

<p>
A system that vibrates without damping and external forcing
can be described by ODE problem

<p>
$$
\begin{equation}
u'' + \omega^2u = 0,\quad u(0)=I,\ u'(0)=0,\ t\in (0,T]
\thinspace .
\label{vib:ode1}
\end{equation}
$$

Here, \( \omega \) and \( I \) are given constants.
The exact solution of \eqref{vib:ode1} is

<p>
$$
\begin{equation}
u(t) = I\cos (\omega t)
\thinspace .
\label{vib:ode1:uex}
\end{equation}
$$

That is, \( u \) oscillates with constant amplitude \( I \) and
angular frequency \( \omega \).
The corresponding period of oscillations (i.e., the time between two
neighboring peaks in the cosine function) is \( P=2\pi/\omega \).
The number of periods per second
is \( f=\omega/(2\pi) \) and measured in the unit Hz.
Both \( f \) and \( \omega \) are referred to as frequency, but \( \omega \)
may be more precisely named angular frequency, measured in rad/s.

<p>
In vibrating mechanical systems modeled by \eqref{vib:ode1}, \( u(t) \)
very often represents a position or a displacement of a particular
point in the system. The derivative \( u'(t) \) then has the
interpretation of the point's velocity, and \( u''(t) \) is the associated
acceleration.  The model \eqref{vib:ode1} is not only
applicable to vibrating mechanical systems, but also to oscillations
in electrical circuits.

<h3>A centered finite difference scheme <a name="vib:ode1:fdm"></a></h3>

<p>
To formulate a finite difference method for the model
problem  \eqref{vib:ode1} we follow the <a href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#the-forward-euler-scheme">four steps</a> in <a href="#Langtangen:deq:decay">[1]</a>.

<h4>Step 1: Discretizing the domain  <a name="___sec3"></a></h4>

<p>
The domain is discretized by
introducing a uniformly partitioned time mesh in the present problem.
The points in the mesh are hence \( t_n=n\Delta t \), \( n=0,1,\ldots,N_t \),
where \( \Delta t = T/N_t \) is the constant length of the time steps.
We introduce a mesh function \( u^n \) for \( n=0,1,\ldots,N_t \), which
approximates the exact solution at the mesh points. The mesh
function will be computed from algebraic equations derived from
the differential equation problem.

<h4>Step 2: Fulfilling the equation at discrete time points  <a name="___sec4"></a></h4>

<p>
The ODE is to be satisfied at each mesh point:

<p>
$$
\begin{equation}
u''(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
\thinspace .
\label{vib:ode1:step2}
\end{equation}
$$

<h4>Step 3: Replacing derivatives by finite differences  <a name="___sec5"></a></h4>

<p>
The derivative \( u''(t_n) \) is to be replaced by a finite
difference approximation. A common second-order accurate approximation
to the second-order derivative is

<p>
$$
\begin{equation}
u''(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
\label{vib:ode1:step3}
\end{equation}
$$

Inserting \eqref{vib:ode1:step3} in \eqref{vib:ode1:step2}
yields

<p>
$$
\begin{equation}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
\thinspace .
\label{vib:ode1:step3b}
\end{equation}
$$


<p>
We also need to replace the derivative in the initial condition by
a finite difference. Here we choose a centered difference:

<p>
$$
\begin{equation}
\frac{u^1-u^{-1}}{2\Delta t} = 0
\label{vib:ode1:step3c}
\thinspace .
\end{equation}
$$

<h4>Step 4: Formulating a recursive algorithm  <a name="___sec6"></a></h4>

<p>
To formulate the computational algorithm, we assume that we
have already computed \( u^{n-1} \) and \( u^n \) such that \( u^{n+1} \) is the
unknown value, which we can readily solve for:

<p>
$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
\thinspace .
\label{vib:ode1:step4}
\end{equation}
$$

The computational algorithm is simply to apply \eqref{vib:ode1:step4}
successively for \( n=1,2,\ldots,N_t-1 \). This numerical scheme sometimes
goes under the name
Stormer's
method or <a href="http://en.wikipedia.org/wiki/Velocity_Verlet">Verlet integration</a>.

<h4>Computing the first step  <a name="___sec7"></a></h4>

<p>
We observe that \eqref{vib:ode1:step4} cannot be used for \( n=0 \) since
the computation of \( u^1 \) then involves the undefined value \( u^{-1} \)
at \( t=-\Delta t \). The discretization of the initial condition
then come to rescue: \eqref{vib:ode1:step3c} implies \( u^{-1} = u^1 \)
and this relation can be combined with \eqref{vib:ode1:step4}
for \( n=1 \) to yield a value for \( u^1 \):

<p>
$$
\begin{equation*} u^1 = 2u^0 - u^{1} - \Delta t^2 \omega^2 u^0,\end{equation*}
$$

which reduces to

<p>
$$
\begin{equation}
u^1 = u^0 - \half \Delta t^2 \omega^2 u^0
\thinspace .
\label{vib:ode1:step4b}
\end{equation}
$$

<a href="#vib:exer:step4b:alt">Exercise 4: Use a Taylor polynomial to compute $u^1$</a> asks you to perform an alternative derivation
and also to generalize the initial condition to \( u'(0)=V\neq 0 \).

<h4>The computational algorithm  <a name="___sec8"></a></h4>

<p>
The steps for solving \eqref{vib:ode1} becomes

<p>

<ol>
 <li> \( u^0=I \)</li>
 <li> compute \( u^1 \) from \eqref{vib:ode1:step4b}</li>
 <li> for \( n=1,2,\ldots,N_t-1 \):</li>

<ol>
   <li> compute \( u^{n+1} \) from \eqref{vib:ode1:step4}</li>
</ol>

</ol>

The algorithm is more precisely expressed directly in Python:

<p>

<!-- code=text (from !bc cod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">t = linspace(0, T, Nt+1)  # mesh points in time
dt = t[1] - t[0]          # constant time step
u = zeros(Nt+1)           # solution

u[0] = I
u[1] = u[0] - 0.5*dt**2*w**2*u[0]
for n in range(1, Nt):
    u[n+1] = 2*u[n] - u[n-1] - dt**2*w**2*u[n]
</pre></div>
<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Remark.</b>
In the code, we use <code>w</code> as the symbol for \( \omega \).
The reason is that this author prefers <code>w</code> for readability
and comparison with the mathematical \( \omega \) instead of
the full word <code>omega</code> as variable name.
</div>
<h4>Operator notation  <a name="___sec9"></a></h4>

<p>
We may write the scheme using the compact difference notation
(see 
<a href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#compact-operator-notation-for-finite-differences">examples</a> in <a href="#Langtangen:deq:decay">[1]</a>). The difference \eqref{vib:ode1:step3} has the operator
notation \( [D_tD_t u]^n \) such that we can write:

<p>
$$
\begin{equation}
[D_tD_t u  + \omega^2 u = 0]^n
\thinspace .
\label{vib:ode1:step4:op}
\end{equation}
$$

Note that \( [D_tD_t u]^n \) means applying a central difference with step \( \Delta t/2 \) twice:

<p>
$$ [D_t(D_t u)]^n = \frac{[D_t u]^{n+1/2} - [D_t u]^{n-1/2}}{\Delta t}$$

which is written out as
$$
\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
$$


<p>
The discretization of initial conditions can in the operator notation
be expressed as
$$
\begin{equation}
[u = I]^0,\quad [D_{2t} u = 0]^0,
\end{equation}
$$

where the operator \( [D_{2t} u]^n \) is defined as
$$
\begin{equation}
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
\thinspace .
\end{equation}
$$

<h4>Computing \( u' \)  <a name="___sec10"></a></h4>

<p>
In mechanical vibration applications one is often interested in
computing the velocity \( u'(t) \) after \( u(t) \) has been computed.
This can be done by a central difference,

<p>
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
\thinspace .
\end{equation}
$$

<h2>Implementation <a name="vib:impl1"></a></h2>

<h3>Making a solver function  <a name="___sec12"></a></h3>

<p>
The algorithm from the previous section is readily translated to
a complete Python function for computing (returning)
\( u^0,u^1,\ldots,u^{N_t} \) and \( t_0,t_1,\ldots,t_{N_t} \), given the
input \( I \), \( \omega \), \( \Delta t \), and \( T \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, w, dt, T):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span style="color: #CD5555">    by a central finite difference method with time step dt.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    u = zeros(Nt+<span style="color: #B452CD">1</span>)
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)

    u[<span style="color: #B452CD">0</span>] = I
    u[<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>] - <span style="color: #B452CD">0.5</span>*dt**<span style="color: #B452CD">2</span>*w**<span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        u[n+<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">2</span>*u[n] - u[n-<span style="color: #B452CD">1</span>] - dt**<span style="color: #B452CD">2</span>*w**<span style="color: #B452CD">2</span>*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
<p>
A function for plotting the numerical and the exact solution is also
convenient to have:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t, I, w):
    <span style="color: #8B008B; font-weight: bold">return</span> I*cos(w*t)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">visualize</span>(u, t, I, w):
    plot(t, u, <span style="color: #CD5555">&#39;r--o&#39;</span>)
    t_fine = linspace(<span style="color: #B452CD">0</span>, t[-<span style="color: #B452CD">1</span>], <span style="color: #B452CD">1001</span>)  <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = exact_solution(t_fine, I, w)
    hold(<span style="color: #CD5555">&#39;on&#39;</span>)
    plot(t_fine, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
    legend([<span style="color: #CD5555">&#39;numerical&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>], loc=<span style="color: #CD5555">&#39;upper left&#39;</span>)
    xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
    title(<span style="color: #CD5555">&#39;dt=%g&#39;</span> % dt)
    umin = <span style="color: #B452CD">1.2</span>*u.min();  umax = -umin
    axis([t[<span style="color: #B452CD">0</span>], t[-<span style="color: #B452CD">1</span>], umin, umax])
    savefig(<span style="color: #CD5555">&#39;vib1.png&#39;</span>)
    savefig(<span style="color: #CD5555">&#39;vib1.pdf&#39;</span>)
    savefig(<span style="color: #CD5555">&#39;vib1.eps&#39;</span>)
</pre></div>
<p>
A corresponding main program calling these functions for a simulation
of a given number of periods (<code>num_periods</code>) may take the form

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">I = <span style="color: #B452CD">1</span>
w = <span style="color: #B452CD">2</span>*pi
dt = <span style="color: #B452CD">0.05</span>
num_periods = <span style="color: #B452CD">5</span>
P = <span style="color: #B452CD">2</span>*pi/w    <span style="color: #228B22">#  one period</span>
T = P*num_periods
u, t = solver(I, w, dt, T)
visualize(u, t, I, w, dt)
</pre></div>
<p>
Adjusting some of the input parameters on the command line can be
handy. Here is a code segment using the <code>ArgumentParser</code> tool in
the <code>argparse</code> module to define option value (<code>--option value</code>)
pairs on the command line:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
parser = argparse.ArgumentParser()
parser.add_argument(<span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>)
parser.add_argument(<span style="color: #CD5555">&#39;--w&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">2</span>*pi)
parser.add_argument(<span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">0.05</span>)
parser.add_argument(<span style="color: #CD5555">&#39;--num_periods&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">int</span>, default=<span style="color: #B452CD">5</span>)
a = parser.parse_args()
I, w, dt, num_periods = a.I, a.w, a.dt, a.num_periods
</pre></div>
<p>
A typical execution goes like

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --num_periods 20 --dt 0.1
</pre></div>

<h3>Verification <a name="vib:ode1:verify"></a></h3>

<h4>Manual calculation  <a name="___sec14"></a></h4>

<p>
The simplest type of verification, which is also instructive for understanding
the algorithm, is to compute \( u^1 \), \( u^2 \), and \( u^3 \)
with the aid of a calculator
and make a function for comparing these results with those from the <code>solver</code>
function. We refer to the <code>test_three_steps</code> function in
the file <a href="http://tinyurl.com/jvzzcfn/vib/vib_undamped.py"><tt>vib_undamped.py</tt></a>
for details.

<h4>Testing very simple solutions  <a name="___sec15"></a></h4>

<p>
Constructing test problems where the exact solution is constant or linear
helps initial debugging and verification as one expects any reasonable
numerical method to reproduce such solutions to machine
precision.
Second-order accurate methods will often also reproduce a quadratic
solution.
Here \( [D_tD_tt^2]^n=2 \), which is the exact result. A solution
\( u=t^2 \) leads to \( u''+\omega^2 u=2 + (\omega t)^2\neq 0 \).
We must therefore add a source in the equation:
\( u'' + \omega^2 u = f \) to allow a solution \( u=t^2 \) for \( f=(\omega t)^2 \).
By simple insertion we can show that the mesh function \( u^n = t_n^2 \) is
also a solution of the discrete equations.
<a href="#vib:exer:undamped:verify:linquad">Problem 1: Use linear/quadratic functions for verification</a>
asks you to carry out all
details with showing that linear and quadratic solutions are solutions
of the discrete equations. Such results are very useful
for debugging and verification.

<h4>Checking convergence rates  <a name="___sec16"></a></h4>

<p>
Empirical computation of convergence rates, as explained
for a simple <a href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#computing-convergence-rates">ODE model</a>, yields a good method for
verification. The function below

<p>

<ul>
 <li> performs \( m \) simulations with halved time steps: \( 2^{-i}\Delta t \), \( i=0,\ldots,m-1 \),</li>
 <li> computes the \( L^2 \) norm of the error,
   \( E=\sqrt{2^{-i}\Delta t\sum_{n=0}^{N_t-1}(u^n-\uex(t_n))^2} \) in each case,</li>
 <li> estimates the convergence rates \( r_i \) based on two consecutive
   experiments \( (\Delta t_{i-1}, E_{i-1}) \) and \( (\Delta t_{i}, E_{i}) \),
   assuming \( E_i=C\Delta t_i^{r_i} \) and \( E_{i-1}=C\Delta t_{i-1}^{r_i} \).
   From these equations it follows that
   \( r_{i-1} = \ln (E_{i-1}/E_i)/\ln (\Delta t_{i-1}/\Delta t_i) \), for
   \( i=1,\ldots,m-1 \).</li>
</ul>

All the implementational details appear below.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">convergence_rates</span>(m, num_periods=<span style="color: #B452CD">8</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Return m-1 empirical estimates of the convergence rate</span>
<span style="color: #CD5555">    based on m simulations, where the time step is halved</span>
<span style="color: #CD5555">    for each simulation.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    w = <span style="color: #B452CD">0.35</span>; I = <span style="color: #B452CD">0.3</span>
    dt = <span style="color: #B452CD">2</span>*pi/w/<span style="color: #B452CD">30</span>  <span style="color: #228B22"># 30 time step per period 2*pi/w</span>
    T = <span style="color: #B452CD">2</span>*pi/w*num_periods
    dt_values = []
    E_values = []
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(m):
        u, t = solver(I, w, dt, T)
        u_e = exact_solution(t, I, w)
        E = sqrt(dt*<span style="color: #658b00">sum</span>((u_e-u)**<span style="color: #B452CD">2</span>))
        dt_values.append(dt)
        E_values.append(E)
        dt = dt/<span style="color: #B452CD">2</span>

    r = [log(E_values[i-<span style="color: #B452CD">1</span>]/E_values[i])/
         log(dt_values[i-<span style="color: #B452CD">1</span>]/dt_values[i])
         <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, m, <span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> r
</pre></div>
<p>
The returned <code>r</code> list has its values equal to 2.00, which is in
excellent agreement with what is
expected from the second-order finite difference approximation \( [D_tD_tu]^n \)
and other theoretical measures of the error in the numerical method.
The final <code>r[-1]</code> value is a good candidate for a unit test:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_convergence_rates</span>():
    r = convergence_rates(m=<span style="color: #B452CD">5</span>, num_periods=<span style="color: #B452CD">8</span>)
    <span style="color: #228B22"># Accept rate to 1 decimal place</span>
    nt.assert_almost_equal(r[-<span style="color: #B452CD">1</span>], <span style="color: #B452CD">2.0</span>, places=<span style="color: #B452CD">1</span>)
</pre></div>
<p>
The complete code appears in the file <code>vib_undamped.py</code>.

<h2>Long time simulations <a name="vib:ode1:longseries"></a></h2>

<p>
Figure <a href="#vib:ode1:2dt">1</a> shows a comparison of the exact and numerical
solution for \( \Delta t=0.1, 0.05 \) and \( w=2\pi \).
From the plot we make the following observations:

<p>

<ul>
 <li> The numerical solution seems to have correct amplitude.</li>
 <li> There is a phase error which is reduced by reducing the time step.</li>
 <li> The total phase error grows with time.</li>
</ul>

By phase error we mean that the peaks of the numerical solution have incorrect
positions compared with the peaks of the exact cosine solution. This
effect can be understood as if also the numerical solution is on
the form \( I\cos\tilde\omega t \), but where \( \tilde\omega \) is not exactly
equal to \( \omega \). Later, we shall mathematically
quantify this numerical frequency \( \tilde\omega \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Effect of halving the time step. <a name="vib:ode1:2dt"></a> </p></center>
<p><img src="fig-vib/vib_phase_err1.png" align="bottom" width=600,></p>
</center>

<h3>Using a moving plot window  <a name="___sec18"></a></h3>

<p>
In vibration problems it is often of interest to investigate the system's
behavior over long time intervals. Errors in the phase may then show
up as crucial. Let us investigate long
time series by introducing a moving plot window that can move along with
the \( p \) most recently computed periods of the solution. The
<a href="http://code.google.com/p/scitools">SciTools</a> package contains
a convenient tool for this: <code>MovingPlotWindow</code>. Typing
<code>pydoc scitools.MovingPlotWindow</code> shows a demo and description of usage.
The function below illustrates the usage and is invoked in the
<code>vib_undamped.py</code> code if the number of periods in the simulation exceeds
10:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">visualize_front</span>(u, t, I, w, savefig=<span style="color: #658b00">False</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Visualize u and the exact solution vs t, using a</span>
<span style="color: #CD5555">    moving plot window and continuous drawing of the</span>
<span style="color: #CD5555">    curves as they evolve in time.</span>
<span style="color: #CD5555">    Makes it easy to plot very long time series.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">st</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scitools.MovingPlotWindow</span> <span style="color: #8B008B; font-weight: bold">import</span> MovingPlotWindow

    P = <span style="color: #B452CD">2</span>*pi/w  <span style="color: #228B22"># one period</span>
    umin = <span style="color: #B452CD">1.2</span>*u.min();  umax = -umin
    plot_manager = MovingPlotWindow(
        window_width=<span style="color: #B452CD">8</span>*P,
        dt=t[<span style="color: #B452CD">1</span>]-t[<span style="color: #B452CD">0</span>],
        yaxis=[umin, umax],
        mode=<span style="color: #CD5555">&#39;continuous drawing&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,<span style="color: #658b00">len</span>(u)):
        <span style="color: #8B008B; font-weight: bold">if</span> plot_manager.plot(n):
            s = plot_manager.first_index_in_plot
            st.plot(t[s:n+<span style="color: #B452CD">1</span>], u[s:n+<span style="color: #B452CD">1</span>], <span style="color: #CD5555">&#39;r-1&#39;</span>,
                    t[s:n+<span style="color: #B452CD">1</span>], I*cos(w*t)[s:n+<span style="color: #B452CD">1</span>], <span style="color: #CD5555">&#39;b-1&#39;</span>,
                    title=<span style="color: #CD5555">&#39;t=%6.3f&#39;</span> % t[n],
                    axis=plot_manager.axis(),
                    show=<span style="color: #8B008B">not</span> savefig) <span style="color: #228B22"># drop window if savefig</span>
            <span style="color: #8B008B; font-weight: bold">if</span> savefig:
                filename = <span style="color: #CD5555">&#39;tmp_vib%04d.png&#39;</span> % n
                st.savefig(filename)
                <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;making plot file&#39;</span>, filename, <span style="color: #CD5555">&#39;at t=%g&#39;</span> % t[n]
        plot_manager.update(n)
</pre></div>
<p>
Running
<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
<p>
makes the simulation last for 40 periods of the cosine function.
With the moving plot window we can follow the numerical and exact
solution as time progresses, and we see from this demo that
the phase error is small in the beginning, but then becomes more
prominent with time. Running <code>vib_undamped.py</code> with \( \Delta t=0.1 \)
clearly shows that the phase errors become significant even earlier
in the time series and destroys the solution.

<h3>Making a movie file  <a name="___sec19"></a></h3>

<p>
The <code>visualize_front</code> function stores all the plots in
files whose names are numbered:
<code>tmp_vib0000.png</code>, <code>tmp_vib0001.png</code>, <code>tmp_vib0002.png</code>,
and so on. From these files we may make a movie. The Flash
format is popular,

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; avconv -r 12 -i tmp_vib%04d.png -vcodec flv movie.flv
</pre></div>
<p>
The <code>avconv</code> program can be replaced by the <code>ffmpeg</code> program in
the above command if desired.
Other formats can be generated by changing the video codec
and equipping the movie file with the right extension:

<p>
<table border="1">
<tr><td align="center"><b>                  Format                  </b></td> <td align="center"><b>            Codec and filename            </b></td> </tr>
<tr><td align="left">   Flash                                       </td> <td align="left">   <code>-vcodec flv movie.flv</code>          </td> </tr>
<tr><td align="left">   MP4                                         </td> <td align="left">   <code>-vcodec libx64 movie.mp4</code>       </td> </tr>
<tr><td align="left">   Webm                                        </td> <td align="left">   <code>-vcodec libvpx movie.webm</code>      </td> </tr>
<tr><td align="left">   Ogg                                         </td> <td align="left">   <code>-vcodec libtheora movie.ogg</code>    </td> </tr>
</table>
<p>
The movie file can be played by some video player like <code>vlc</code>, <code>mplayer</code>,
<code>gxine</code>, or <code>totem</code>, e.g.,

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; vlc movie.webm
</pre></div>
<p>
A web page can also be used to play the movie. Today's standard is
to use the HTML5 <code>video</code> tag:

<p>

<!-- code=html (from !bc htmlcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">&lt;video</span> <span style="color: #658b00">autoplay</span> <span style="color: #658b00">loop</span> <span style="color: #658b00">controls</span>
       <span style="color: #658b00">width=</span><span style="color: #CD5555">&#39;640&#39;</span> <span style="color: #658b00">height=</span><span style="color: #CD5555">&#39;365&#39;</span> <span style="color: #658b00">preload=</span><span style="color: #CD5555">&#39;none&#39;</span><span style="color: #8B008B; font-weight: bold">&gt;</span>
<span style="color: #8B008B; font-weight: bold">&lt;source</span> <span style="color: #658b00">src=</span><span style="color: #CD5555">&#39;movie.webm&#39;</span>  <span style="color: #658b00">type=</span><span style="color: #CD5555">&#39;video/webm; codecs=&quot;vp8, vorbis&quot;&#39;</span><span style="color: #8B008B; font-weight: bold">&gt;</span>
<span style="color: #8B008B; font-weight: bold">&lt;/video&gt;</span>
</pre></div>
<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Caution: number the plot files correctly.</b>
To ensure that the individual plot frames are shown in correct order,
it is important to number the files with zero-padded numbers
(0000, 0001, 0002, etc.). The printf format <code>%04d</code> specifies an
integer in a field of width 4, padded with zeros from the left.
A simple Unix wildcard file specification like <code>tmp_vib*.png</code>
will then list the frames in the right order. If the numbers in the
filenames were not zero-padded, the frame <code>tmp_vib11.png</code> would appear
before <code>tmp_vib2.png</code> in the movie.
</div>
<h3>Using a line-by-line ascii plotter  <a name="___sec20"></a></h3>

<p>
Plotting functions vertically, line by line, in the terminal window
using ascii characters only is a simple, fast, and convenient
visualization technique for long time series (the time arrow points
downward). The tool
<code>scitools.avplotter.Plotter</code> makes it easy to create such plots:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">visualize_front_ascii</span>(u, t, I, w, fps=<span style="color: #B452CD">10</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Plot u and the exact solution vs t line by line in a</span>
<span style="color: #CD5555">    terminal window (only using ascii characters).</span>
<span style="color: #CD5555">    Makes it easy to plot very long time series.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scitools.avplotter</span> <span style="color: #8B008B; font-weight: bold">import</span> Plotter
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>
    P = <span style="color: #B452CD">2</span>*pi/w
    umin = <span style="color: #B452CD">1.2</span>*u.min();  umax = -umin

    p = Plotter(ymin=umin, ymax=umax, width=<span style="color: #B452CD">60</span>, symbols=<span style="color: #CD5555">&#39;+o&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(u)):
        <span style="color: #8B008B; font-weight: bold">print</span> p.plot(t[n], u[n], I*cos(w*t[n])), \ 
              <span style="color: #CD5555">&#39;%.1f&#39;</span> % (t[n]/P)
        time.sleep(<span style="color: #B452CD">1</span>/<span style="color: #658b00">float</span>(fps))
</pre></div>
<p>
The call <code>p.plot</code> returns a line of text, with the \( t \) axis marked and
a symbol <code>+</code> for the first function (<code>u</code>) and <code>o</code> for the second
function (the exact solution). Here we append this text
a time counter reflecting how many periods the current time point
corresponds to. A typical output (\( \omega =2\pi \), \( \Delta t=0.05 \))
looks like this:

<p>

<!-- code=text (from !bc dat) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">                              |                       o+      14.0
                              |                      + o      14.0
                              |                  +    o       14.1
                              |             +     o           14.1
                              |     +        o                14.2
                             +|       o                       14.2
                     +        |                               14.2
              +       o       |                               14.3
         +     o              |                               14.4
      +   o                   |                               14.4
     +o                       |                               14.5
     o +                      |                               14.5
      o    +                  |                               14.6
          o      +            |                               14.6
               o        +     |                               14.7
                      o       | +                             14.7
                              |        +                      14.8
                              |       o       +               14.8
                              |              o     +          14.9
                              |                   o   +       14.9
                              |                       o+      15.0
</pre></div>

<h3>Empirical analysis of the solution <a name="vib:ode1:empirical"></a></h3>

<p>
For oscillating functions like those in Figure <a href="#vib:ode1:2dt">1</a> we may
compute the amplitude and frequency (or period) empirically.
That is, we run through the discrete solution points \( (t_n, u_n) \) and
find all maxima and minima points. The distance between two consecutive
maxima (or minima) points can be used as estimate of the local period,
while half the difference between the \( u \) value at a maximum and a nearby
minimum gives an estimate of the local amplitude.

<p>
The local maxima are the points where
$$
\begin{equation}
u^{n-1} < u^n > u^{n+1},\quad n=1,\ldots,N_t-1,
\end{equation}
$$

and the local minima are recognized by
$$
\begin{equation}
u^{n-1} > u^n < u^{n+1},\quad n=1,\ldots,N_t-1
\thinspace .
\end{equation}
$$

In computer code this becomes

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">minmax</span>(t, u):
    minima = []; maxima = []
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, <span style="color: #658b00">len</span>(u)-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">if</span> u[n-<span style="color: #B452CD">1</span>] &gt; u[n] &lt; u[n+<span style="color: #B452CD">1</span>]:
            minima.append((t[n], u[n]))
        <span style="color: #8B008B; font-weight: bold">if</span> u[n-<span style="color: #B452CD">1</span>] &lt; u[n] &gt; u[n+<span style="color: #B452CD">1</span>]:
            maxima.append((t[n], u[n]))
    <span style="color: #8B008B; font-weight: bold">return</span> minima, maxima
</pre></div>
<p>
Note that the returned objects are list of tuples.

<p>
Let \( (t_i, e_i) \), \( i=0,\ldots,M-1 \), be the sequence of all
the \( M \) maxima points, where \( t_i \)
is the time value and \( e_i \) the corresponding \( u \) value.
The local period can be defined as \( p_i=t_{i+1}-t_i \).
With Python syntax this reads

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">periods</span>(maxima):
    p = [extrema[n][<span style="color: #B452CD">0</span>] - maxima[n-<span style="color: #B452CD">1</span>][<span style="color: #B452CD">0</span>]
         <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, <span style="color: #658b00">len</span>(maxima))]
    <span style="color: #8B008B; font-weight: bold">return</span> np.array(p)
</pre></div>
<p>
The list <code>p</code> created by a list comprehension is converted to an array
since we probably want to compute with it, e.g., find the corresponding
frequencies <code>2*pi/p</code>.

<p>
Having the minima and the maxima, the local amplitude can be
calculated as the difference between two neighboring minimum and
maximum points:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">amplitudes</span>(minima, maxima):
    a = [(<span style="color: #658b00">abs</span>(maxima[n][<span style="color: #B452CD">1</span>] - minima[n][<span style="color: #B452CD">1</span>]))/<span style="color: #B452CD">2.0</span>
         <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">min</span>(<span style="color: #658b00">len</span>(minima),<span style="color: #658b00">len</span>(maxima)))]
    <span style="color: #8B008B; font-weight: bold">return</span> np.array(a)
</pre></div>
<p>
The code segments are found in the file <a href="http://tinyurl.com/jvzzcfn/vib/vib_empirical_analysis.py"><tt>vib_empirical_analysis.py</tt></a>.

<p>
Visualization of the periods <code>p</code> or the amplitudes <code>a</code>
it is most conveniently done with just a counter
on the horizontal axis, since <code>a[i]</code> and <code>p[i]</code> correspond to
the \( i \)-th amplitude estimate and the \( i \)-th period estimate, respectively.
There is no unique time point associated with either of these estimate
since values at two different time points were used in the
computations.

<p>
In the analysis of very long time series, it is advantageous to
compute and plot <code>p</code> and <code>a</code> instead of \( u \) to get an impression of
the development of the oscillations.

<p>
<!-- Use it for very long time integration of CN! And of RK4! -->

<h2>Analysis of the numerical scheme <a name="vib:ode1:analysis"></a></h2>

<h3>Deriving an exact numerical solution  <a name="___sec23"></a></h3>

<p>
After having seen the phase error grow with time in the previous
section, we shall now quantify this error through mathematical analysis.  The
key tool in the analysis will be to establish an exact solution of the
discrete equations.  The difference equation \eqref{vib:ode1:step4}
has constant coefficients and is homogeneous. The solution is then of
the form \( u^n=A^n \), where \( A \) is some number to be determined
(recall that \( n \) in \( u^n \) is a superscript labeling the time level,
while \( n \) in \( A^n \) is an exponent).
With oscillating functions as solutions, the algebra will be
considerably simplified if we write

<p>
$$ A=Ie^{i\tilde\omega \Delta t},$$

and solve for the numerical frequency \( \tilde\omega \) rather than
\( A \). Note that \( i=\sqrt{-1} \) is the imaginary unit. (Using a
complex exponential function gives simpler arithmetics than working
with a sine or cosine function.)
We have

<p>
$$
A^n = Ie^{i\tilde\omega \Delta t\, n}=Ie^{i\tilde\omega t} =
I\cos (\tilde\omega t) + iI\sin(\tilde \omega t)
\thinspace .
$$

The physically relevant numerical solution can
be taken as the real part of this complex expression.

<p>
The calculations goes as
$$
\begin{align*}
[D_tD_t u]^n &= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\ 
&= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\ 
&= I\frac{\exp{(i\tilde\omega(t+\Delta t))} - 2\exp{(i\tilde\omega t)} + \exp{(i\tilde\omega(t-\Delta t))}}{\Delta t^2}\\ 
&= I\exp{(i\tilde\omega t)}\frac{1}{\Delta t^2}\left(\exp{(i\tilde\omega(\Delta t))} + \exp{(i\tilde\omega(-\Delta t))} - 2\right)\\ 
&= I\exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\ 
&= I\exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\ 
&= -I\exp{(i\tilde\omega t)}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
\end{align*}
$$

The last line follows from the relation
\( \cos x - 1 = -2\sin^2(x/2) \) (try <code>cos(x)-1</code> in
<a href="http://www.wolframalpha.com">wolframalpha.com</a> to see the formula).

<p>
The scheme \eqref{vib:ode1:step4}
with \( u^n=Ie^{i\omega\tilde\Delta t\, n} \) inserted now gives

<p>
$$
\begin{equation}
-Ie^{i\tilde\omega t}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
+ \omega^2 Ie^{i\tilde\omega t} = 0,
\end{equation}
$$

which after dividing by \( Ie^{i\tilde\omega t} \) results in
$$
\begin{equation}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
\thinspace .
\end{equation}
$$

The first step in solving for the unknown \( \tilde\omega \) is
$$ \sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
\thinspace .
$$

Then, taking the square root, applying the inverse sine function, and
multiplying by \( 2/\Delta t \), results in
$$
\begin{equation}
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\thinspace .
\label{vib:ode1:tildeomega}
\end{equation}
$$


<p>
The first observation of \eqref{vib:ode1:tildeomega} tells that
there is a phase error since the numerical frequency \( \tilde\omega \)
never equals the exact frequency \( \omega \). But how good is
the approximation \eqref{vib:ode1:tildeomega}? That is, what
is the error \( \omega - \tilde\omega \) or \( \tilde\omega/\omega \)?
Taylor series expansion
for small \( \Delta t \) may give an expression that is easier to understand
than the complicated function in \eqref{vib:ode1:tildeomega}:

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; dt, w = symbols(&#39;dt w&#39;)
&gt;&gt;&gt; w_tilde = asin(w*dt/2).series(dt, 0, 4)*2/dt
&gt;&gt;&gt; print w_tilde
(dt*w + dt**3*w**3/24 + O(dt**4))/dt
</pre></div>
<p>
This means that
$$
\begin{equation}
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right) + {\cal O}(\Delta t^3)
\thinspace .
\label{vib:ode1:tildeomega:series}
\end{equation}
$$

The error in the numerical frequency is of second-order in
\( \Delta t \), and the error vanishes as \( \Delta t\rightarrow 0 \).
We see that \( \tilde\omega > \omega \) since the term \( \omega^3\Delta t^2/24 >0 \)
and this is by far the biggest term in the series expansion for small
\( \omega\Delta t \). A numerical frequency that is too large gives an oscillating
curve that oscillates too fast and therefore "lags behind" the exact
oscillations, a feature that can be seen in the plots.

<p>
Figure <a href="#vib:ode1:tildeomega:plot">2</a> plots the discrete frequency
\eqref{vib:ode1:tildeomega}
and its approximation \eqref{vib:ode1:tildeomega:series} for \( \omega =1 \) (based
on the program <a href="http://tinyurl.com/jvzzcfn/vib/vib_plot_freq.py"><tt>vib_plot_freq.py</tt></a>).
Although \( \tilde\omega \) is a function of \( \Delta t \) in
\eqref{vib:ode1:tildeomega:series},
it is misleading to think of \( \Delta t \) as the important
discretization parameter. It is the product \( \omega\Delta t \) that is
the key discretization parameter. This quantity reflects the
<em>number of time steps per period</em> of the oscillations.
To see this, we set \( P=N_P\Delta t \), where \( P \) is the length of
a period, and \( N_P \) is the number of time steps during a period.
Since \( P \) and \( \omega \) are related by \( P=2\pi/\omega \),
we get that \( \omega\Delta t = 2\pi/N_P \), which shows that
\( \omega\Delta t \) is directly related to \( N_P \).

<p>
The plot shows
that at least \( N_P\sim 25-30 \) points per period are necessary for reasonable
accuracy, but this depends on the length of the simulation (\( T \)) as
the total phase error due to the frequency error grows linearly with time
(see <a href="#vib:exer:phase:err:growth">Exercise 1: Show linear growth of the phase with time</a>).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Exact discrete frequency and its second-order series expansion. <a name="vib:ode1:tildeomega:plot"></a> </p></center>
<p><img src="fig-vib/discrete_freq.png" align="bottom" width=400></p>
</center>

<h3>Exact discrete solution  <a name="___sec24"></a></h3>

<p>
Perhaps more important than the \( \tilde\omega = \omega + {\cal O}(\Delta t^2) \)
result found above is the fact that we have an exact discrete solution of
the problem:

<p>
$$
\begin{equation}
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\thinspace .
\label{vib:ode1:un:exact}
\end{equation}
$$

We can then compute the error mesh function

<p>
$$
\begin{equation}
e^n = \uex(t_n) - u^n =
I\cos\left(\omega n\Delta t\right)
- I\cos\left(\tilde\omega n\Delta t\right) \ts
\label{vib:ode1:en}
\end{equation}
$$

In particular, we can use this expression to show <em>convergence</em> of the
numerical scheme, i.e., \( e^n\rightarrow 0 \) as \( \Delta t\rightarrow 0 \).
We have that

<p>
$$
\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,
$$

by L'Hopital's rule or simply asking
<code>(2/x)*asin(w*x/2) as x->0</code> in <a href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0">WolframAlpha</a>.
Therefore, \( \tilde\omega\rightarrow\omega \), and the two terms in
\( e^n \) cancel each other in the limit \( \Delta t\rightarrow 0 \).

<p>
The error mesh function is ideal for verification purposes
(and you are encouraged to make a test based on \eqref{vib:ode1:un:exact}
in <a href="#vib:exer:discrete:omega">Exercise 9: Use an exact discrete solution for verification</a>).

<h3>Stability  <a name="___sec25"></a></h3>

<p>
Looking at \eqref{vib:ode1:un:exact}, it appears that the numerical
solution has constant and correct amplitude, but an error in the
frequency (phase error). However, there is another error that
is more serious, namely an unstable growing amplitude that can
occur of \( \Delta t \) is too large.

<p>
We realize that
a constant amplitude demands
\( \tilde\omega \) to be a real number. A complex \( \tilde\omega \) is
indeed possible if the argument \( x \) of \( \sin^{-1}(x) \) has magnitude
larger than unity: \( |x|>1 \) (type <code>asin(x)</code> in <a href="http://www.wolframalpha.com">wolframalpha.com</a> to see basic properties of \( \sin^{-1} (x) \)).
A complex \( \tilde\omega \) can be written \( \tilde\omega = \tilde\omega_r +
i\tilde\omega_i \). Since \( \sin^{-1}(x) \) has a <em>negative</em> imaginary part for
\( x>1 \), \( \tilde\omega_i < 0 \), it means that
\( \exp{(i\omega\tilde t)}=\exp{(-\tilde\omega_i t)}\exp{(i\tilde\omega_r t)} \)
will lead to exponential growth in time because
\( \exp{(-\tilde\omega_i t)} \) with \( \tilde\omega_i <0 \) has a positive
exponent.

<p>
We do not tolerate growth in the amplitude and we therefore
have a <em>stability criterion</em> arising from requiring the argument
\( \omega\Delta t/2 \) in the inverse sine function to be less than
one:
$$
\begin{equation}
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
\Delta t \leq \frac{2}{\omega}
\thinspace .
\end{equation}
$$

With \( \omega =2\pi \), \( \Delta t > \pi^{-1} = 0.3183098861837907 \) will give
growing solutions. Figure <a href="#vib:ode1:dt:unstable">3</a>
displays what happens when \( \Delta t =0.3184 \),
which is slightly above the critical value: \( \Delta t =\pi^{-1} + 9.01\cdot
10^{-5} \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Growing, unstable solution because of a time step slightly beyond the stability limit. <a name="vib:ode1:dt:unstable"></a> </p></center>
<p><img src="fig-vib/vib_unstable.png" align="bottom" width=400></p>
</center>

<p>
<div class="alert alert-block alert-summary alert-text-normal"><b>Summary.</b>
From the analysis we can draw three important conclusions:

<p>

<ol>
<li> The key parameter in the formulas is \( p=\omega\Delta t \).
   The period of oscillations is \( P=2\pi/\omega \), and the
   number of time steps per period is \( N_P=P/\Delta t \).
   Therefore, \( p=\omega\Delta t = 2\pi N_P \), showing that the
   critical parameter is the number of time steps per period.
   The smallest possible \( N_P \) is 2, showing that \( p\in (0,\pi] \).</li>
<li> Provided \( p\leq 2 \), the amplitude of the numerical solution is
   constant.</li>
<li> The numerical solution exhibits a relative phase error
   \( \tilde\omega/\omega \approx 1 + \frac{1}{24}p^2 \).
   This error leads to wrongly displaced peaks of the numerical
   solution, and the error in peak location grows linearly with time
   (see <a href="#vib:exer:phase:err:growth">Exercise 1: Show linear growth of the phase with time</a>).</li>
</ol>
</div>
<h2>Alternative schemes based on 1st-order equations <a name="vib:model2x2"></a></h2>

<p>
A standard technique for solving second-order ODEs is
to rewrite them as a system of first-order ODEs and then apply the
vast collection of methods for first-order ODE systems.
Given the second-order ODE problem
$$ u'' + \omega^2 u = 0,\quad u(0)=I,\ u'(0)=0,$$

we introduce the auxiliary variable \( v=u' \) and express the ODE problem
in terms of first-order derivatives of \( u \) and \( v \):

<p>
$$
\begin{align}
u' &= v,
\label{vib:model2x2:ueq}\\ 
v' &= -\omega^2 u
\label{vib:model2x2:veq}
\thinspace .
\end{align}
$$

The initial conditions become \( u(0)=I \) and \( v(0)=0 \).

<h3>Standard methods for 1st-order ODE systems <a name="vib:undamped:1stODE"></a></h3>

<h4>The Forward Euler scheme  <a name="___sec28"></a></h4>

<p>
A Forward Euler approximation to our \( 2\times 2 \) system of ODEs
\eqref{vib:model2x2:ueq}-\eqref{vib:model2x2:veq}
becomes

<p>
$$
\begin{align}
\lbrack D_t^+ u = v\rbrack^n,
\lbrack D_t^+ v = -\omega^2 u\rbrack^n,
\end{align}
$$

or written out,

<p>
$$
\begin{align}
u^{n+1} &= u^n + \Delta t v^n,
\label{vib:undamped:FE1}\\ 
v^{n+1} &= v^n -\Delta t \omega^2 u^n
\label{vib:undamped:FE2}
\thinspace .
\end{align}
$$


<p>
Let us briefly compare this Forward Euler method with the
centered difference scheme for the second-order differential
equation. We have from \eqref{vib:undamped:FE1} and
\eqref{vib:undamped:FE2} applied at levels \( n \) and \( n-1 \) that

<p>
$$ u^{n+1} = u^n + \Delta t v^n = u^n + \Delta t (v^{n-1} -\Delta t \omega^2 u^{n-1}\ts$$

Since from \eqref{vib:undamped:FE1}
$$ v^{n-1} = \frac{1}{\Delta t}(u^{n}-u^{n-1}),$$

it follows that

<p>
$$ u^{n+1} = 2u^n - u^{n-1} -\Delta t^2\omega^2 u^{n-1},$$

which is very close to the centered difference scheme, but
the last term is evaluated at \( t_{n-1} \) instead of \( t_n \).
This difference is actually crucial for the accuracy of
the Forward Euler method applied to vibration problems.

<h4>The Backward Euler scheme  <a name="___sec29"></a></h4>

<p>
A Backward Euler approximation the ODE system is equally easy to
write up in the operator notation:

<p>
$$
\begin{align}
\lbrack D_t^- u &= v\rbrack^{n+1},\\ 
\lbrack D_t^- v &= -\omega u\rbrack^{n+1} \thinspace .
\end{align}
$$

This becomes a coupled system for \( u^{n+1} \) and \( v^{n+1} \):

<p>
$$
\begin{align}
u^{n+1} - \Delta t v^{n+1} &= u^{n},\\ 
v^{n+1} + \Delta t \omega^2 u^{n+1} &= v^{n}
\thinspace .
\end{align}
$$

<h4>The Crank-Nicolson scheme  <a name="___sec30"></a></h4>

<p>
The Crank-Nicolson scheme takes this form in the operator notation:

<p>
$$
\begin{align}
\lbrack D_t u &= \overline{v}^t\rbrack^{n+\frac{1}{2}},\\ 
\lbrack D_t v &= -\omega \overline{u}^t\rbrack^{n+\frac{1}{2}}
\thinspace .
\end{align}
$$

Writing the equations out shows that is also a coupled system:

<p>
$$
\begin{align}
u^{n+1} - \frac{1}{2}\Delta t v^{n+1} &= u^{n} + \frac{1}{2}\Delta t v^{n},\\ 
v^{n+1} + \frac{1}{2}\Delta t \omega^2 u^{n+1} &= v^{n}
- \frac{1}{2}\Delta t \omega^2 u^{n}
\thinspace .
\end{align}
$$

<h4>Comparison of schemes  <a name="___sec31"></a></h4>

<p>
We can easily compare methods like the ones above (and many more!)
with the aid of the
<a href="https://github.com/hplgit/odespy">Odespy</a> package. Below is
a sketch of the code.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">odespy</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(u, t, w=<span style="color: #B452CD">1</span>):
    u, v = u  <span style="color: #228B22"># u is array of length 2 holding our [u, v]</span>
    <span style="color: #8B008B; font-weight: bold">return</span> [v, -w**<span style="color: #B452CD">2</span>*u]

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">run_solvers_and_plot</span>(solvers, timesteps_per_period=<span style="color: #B452CD">20</span>,
                         num_periods=<span style="color: #B452CD">1</span>, I=<span style="color: #B452CD">1</span>, w=<span style="color: #B452CD">2</span>*np.pi):
    P = <span style="color: #B452CD">2</span>*np.pi/w  <span style="color: #228B22"># duration of one period</span>
    dt = P/timesteps_per_period
    Nt = num_periods*timesteps_per_period
    T = Nt*dt
    t_mesh = np.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)

    legends = []
    <span style="color: #8B008B; font-weight: bold">for</span> solver <span style="color: #8B008B">in</span> solvers:
        solver.set(f_kwargs={<span style="color: #CD5555">&#39;w&#39;</span>: w})
        solver.set_initial_condition([I, <span style="color: #B452CD">0</span>])
        u, t = solver.solve(t_mesh)
</pre></div>
<p>
There is quite some more code dealing with plots also, and we refer
to the source file <a href="http://tinyurl.com/jvzzcfn/vib/vib_undamped_odespy.py"><tt>vib_undamped_odespy.py</tt></a>
for details. Observe that keyword arguments in <code>f(u,t,w=1)</code> can
be supplied through a solver parameter <code>f_kwargs</code> (dictionary).

<p>
Specification of the Forward Euler, Backward Euler, and
Crank-Nicolson schemes is done like this:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">solvers = [
    odespy.ForwardEuler(f),
    <span style="color: #228B22"># Implicit methods must use Newton solver to converge</span>
    odespy.BackwardEuler(f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>),
    odespy.CrankNicolson(f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>),
    ]
</pre></div>
<p>
The <code>vib_undamped_odespy.py</code>
program makes two plots of the computed solutions with the various
methods in the <code>solvers</code> list: one plot with \( u(t) \) versus \( t \), and
one <em>phase plane plot</em> where \( v \) is plotted against \( u \).
That is, the phase plane plot is the curve \( (u(t),v(t)) \) parameterized
by \( t \). Analytically, \( u=I\cos(\omega t) \) and \( v=u'=-\omega I\sin(\omega t) \).
The exact curve \( (u(t),v(t)) \) is therefore an ellipse, which often
looks like a circle in a plot if the axes are automatically scaled. The
important feature, however, is that exact curve \( (u(t),v(t)) \) is
closed and repeats itself for every period. Not all numerical schemes
are capable to do that, meaning that the amplitude instead shrinks or
grows with time.

<p>
The Forward Euler scheme in Figure
<a href="#vib:ode1:1st:odespy:theta:phaseplane">4</a> has a pronounced spiral
curve, pointing to the fact that the amplitude steadily grows, which
is also evident in Figure <a href="#vib:ode1:1st:odespy:theta">5</a>.
The Backward Euler scheme has a similar feature, except that the
spriral goes inward and the amplitude is significantly damped.  The
changing amplitude and the sprial form decreases with decreasing time
step.  The Crank-Nicolson scheme looks much more
accurate.  In fact, these plots tell that the Forward and Backward
Euler schemes are not suitable for solving our ODEs with oscillating
solutions.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Comparison of classical schemes in the phase plane. <a name="vib:ode1:1st:odespy:theta:phaseplane"></a> </p></center>
<p><img src="fig-vib/vib_theta_1_pp.png" align="bottom" width=600,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Comparison of classical schemes. <a name="vib:ode1:1st:odespy:theta"></a> </p></center>
<p><img src="fig-vib/vib_theta_1_u.png" align="bottom" width=600,></p>
</center>

<p>
We may run two popular standard methods for first-order ODEs, the 2nd-
and 4th-order Runge-Kutta methods, to see how they perform. Figures
<a href="#vib:ode1:1st:odespy:RK:phaseplane">6</a> and
<a href="#vib:ode1:1st:odespy:RK">7</a> show the solutions with larger \( \Delta
t \) values than what was used in the previous two plots.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Comparison of Runge-Kutta schemes in the phase plane. <a name="vib:ode1:1st:odespy:RK:phaseplane"></a> </p></center>
<p><img src="fig-vib/vib_RK_1_pp.png" align="bottom" width=600,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Comparison of Runge-Kutta schemes. <a name="vib:ode1:1st:odespy:RK"></a> </p></center>
<p><img src="fig-vib/vib_RK_1_u.png" align="bottom" width=600,></p>
</center>

<p>
The visual impression is that the
4th-order Runge-Kutta method is very accurate, under all circumstances
in these tests, and the 2nd-order scheme suffer from amplitude errors
unless the time step is very small.

<p>
The corresponding results for the Crank-Nicolson scheme
are shown in Figures <a href="#vib:ode1:1st:odespy:CN:long:phaseplane">8</a> and
<a href="#vib:ode1:1st:odespy:CN:long">9</a>. It is clear that the Crank-Nicolson
scheme outperforms
the 2nd-order Runge-Kutta method. Both schemes have the same order
of accuracy \( \Oof{\Delta t^2} \), but their differences in the accuracy
that matters in
a real physical application is very clearly pronounced in this example.
<a href="#vib:exer:undamped:odespy">Exercise 11: Investigate the amplitude errors of many solvers</a> invites you to investigate
how

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Long-time behavior of the Crank-Nicolson scheme in the phase plane. <a name="vib:ode1:1st:odespy:CN:long:phaseplane"></a> </p></center>
<p><img src="fig-vib/vib_CN_10_pp.png" align="bottom" width=600,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Long-time behavior of the Crank-Nicolson scheme. <a name="vib:ode1:1st:odespy:CN:long"></a> </p></center>
<p><img src="fig-vib/vib_CN_10_u.png" align="bottom" width=600,></p>
</center>

<h3>Enegy considerations <a name="vib:model1:energy"></a></h3>

<p>
The observations of various methods in the previous section can be
better interpreted if we compute an quantity reflecting
the total <em>energy of the system</em>. It turns out that this quantity,

<p>
$$ E(t) = \frac{1}{2}(u')^2 + \frac{1}{2}\omega^2u^2,$$

is <em>constant</em> for all \( t \). Checking that \( E(t) \) really remains constant
brings evidence that the numerical computations are sound.
Such energy measures, when they exist, are much used to check numerical
simulations.

<h4>Derivation of the energy expression  <a name="___sec33"></a></h4>

<p>
We starting multiplying

<p>
$$ u'' + \omega^2 u = 0,$$

by \( u' \) and integrating from \( 0 \) to \( T \):

<p>
$$ \int_0^T u''u' dt + \int_0^T\omega^2 u u' dt = 0\ts$$

Observing that

<p>
$$ u''u' = \frac{d}{dt}\frac{1}{2}(u')^2,\quad uu' = \frac{d}{dt} \frac{1}{2}u^2,$$

we get

<p>
$$
\int_0^T (\frac{d}{dt}\frac{1}{2}(u')^2 + \frac{d}{dt} \frac{1}{2}\omega^2u^2)dt = E(T) - E(0),
$$

where we have introduced the energy measure \( E(t) \)

<p>
$$
\begin{equation}
E(t) = \frac{1}{2}(u')^2 + \frac{1}{2}\omega^2u^2\ts
\label{vib:model1:energy:balance1}
\end{equation}
$$

The important result from this derivation is that the total energy
is constant:

<p>
$$ E(t) = \hbox{const}\ts$$


<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Remark on the energy expression.</b>
The quantity \( E(t) \) derived above is physically not the energy of a
vibrating mechanical system, but the energy per unit mass. To see this,
we start with Newton's second law \( F=ma \) (\( F \) is the sum of forces, \( m \)
is the mass of the system, and \( a \) is the acceleration).
The displacement \( u \) is related to \( a \) through
\( a=u'' \). With a spring force as the only force we have \( F=-ku \), where
\( k \) is a spring constant measuring the stiffness of the spring.
Newton's second law then implies the differential equation

<p>
$$ -ku = mu''\quad\Rightarrow mu'' + ku = 0\ts$$

This equation of motion can be turned into an energy balance equation
by finding the work done by each term during a time interval \( [0,T] \).
To this end, we multiply the equation by \( du=u'dt \) and integrate:

<p>
$$ \int_0^T muu'dt + \int_0^T kuu'dt = 0\ts$$

The result is

<p>
$$ E(t) = E_k(t) + E_p(t) = 0,$$

where

<p>
$$
\begin{equation}
E_k(t) = \frac{1}{}2mv^2,\quad v=u',
\label{vib:model1:energy:kinetic}
\end{equation}
$$

is the <em>kinetic energy</em> of the system,

<p>
$$
\begin{equation}
E_p(t) = \frac{1}{2}ku^2
\label{vib:model1:energy:potential}
\end{equation}
$$

is the <em>potential energy</em>, and the sum \( E(t) \) is the total energy.
The derivation demonstrates the famous energy principle that any
change in the kinetic energy is due to a change in potential energy
and vice versa.

<p>
The equation \( mu''+ku=0 \) can be divided by \( m \) and written as
\( u'' + \omega^2u=0 \) for \( \omega=\sqrt{k/m} \). The energy expression
\( E(t)=\frac{1}{2}(u')^2 + \frac{1}{2}\omega^2u^2 \) derived earlier is then
simply the
true physical total
energy \( \frac{1}{2}m(u')^2 + \frac{1}{2}k^2u^2 \) divided by \( m \), i.e.,
total energy per unit mass.
</div>
<h4>Example  <a name="___sec34"></a></h4>

<p>
Analytically, we have \( u(t)=I\cos\omega t \), if \( u(0)=I \) and \( u'(0)=0 \),
so we can easily check that the evolution of the energy \( E(t) \) is
constant:

<p>
$$ E(t) = \frac{1}{2}I^2 (-\omega\sin\omega t)^2
+ \frac{1}{2}\omega^2 I^2 \cos^2\omega t
= \frac{1}{2}\omega^2 (\sin^2\omega t + \cos^2\omega t) = \frac{1}{2}\omega^2
\ts
$$

<h4>Discrete total energy  <a name="___sec35"></a></h4>

<p>
The total energy \( E(t) \) can be computed as soon as
\( u^n \) is available. Using \( (u')^n\approx [D_{2t} u^n] \) we have

<p>
$$ E^n = \frac{1}{2}([D_{2t} u]^n)^2 + \frac{1}{2}\omega^2 (u^n)^2\ts$$

The errors involved in \( E^n \) get a contribution \( \Oof{\Delta t^2} \)
from the difference approximation of \( u' \) and a contribution from
the numerical error in \( u^n \). With a second-order scheme for computing
\( u^n \), the overall error in \( E^n \) is expected to be \( \Oof{\Delta t^2} \).

<h4>An error measure based on total energy  <a name="___sec36"></a></h4>

The error in total energy, as a mesh function, can be computed by

<p>
$$
\begin{equation}
e_E^n = \frac{1}{2}\left(\frac{u^{n+1}-u^{n-1}}{2\Delta t}\right)^2
+ \frac{1}{2}\omega^2 (u^n)^2 - E(0),
\quad n=1,\ldots,N_t-1,
\end{equation}
$$

where

<p>
$$ E(0) = \frac{1}{2}V^2 + \frac{1}{2}\omega^2I^2,$$

if \( u(0)=I \) and \( u'(0)=V \).
A useful norm can be the maximum absolute value of \( e_E^n \):

<p>
$$ ||e_E^n||_{\ell^\infty} = \max_{1\leq n <N_t} |e_E^n|\ts$$

The corresponding Python implementation takes the form

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># import numpy as np and compute u, t</span>
dt = t[<span style="color: #B452CD">1</span>]-t[<span style="color: #B452CD">0</span>]
E = <span style="color: #B452CD">0.5</span>*((u[<span style="color: #B452CD">2</span>:] - u[:-<span style="color: #B452CD">2</span>])/(<span style="color: #B452CD">2</span>*dt))**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">0.5</span>*w**<span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]**<span style="color: #B452CD">2</span>
E0 = <span style="color: #B452CD">0.5</span>*V**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">0.5</span>**w**<span style="color: #B452CD">2</span>*I**<span style="color: #B452CD">2</span>
e_E = E - E0
e_E_norm = np.abs(e_E).max()
</pre></div>
<p>
The convergence rates of the quantity <code>e_E_norm</code> can be used for verification.
The value of <code>e_E_norm</code> is also useful for comparing schemes
through their ability to preserve energy. Below is a table demonstrating
the error in total energy for various schemes. We clearly see that
the Crank-Nicolson and 4th-order Runge-Kutta schemes are superior to
the 2nd-order Runge-Kutta method and even more superior to the Forward
and Backward Euler schemes.

<p>
<table border="1">
<tr><td align="center"><b>                 Method                 </b></td> <td align="center"><b>                \( T \)                 </b></td> <td align="center"><b>             \( \Delta t \)             </b></td> <td align="center"><b> \( \max \left\vert e_E^n\right\vert \) </b></td> </tr>
<tr><td align="center">   Forward Euler                             </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.05 \)                                </td> <td align="center">   \( 1.113\cdot 10^{2} \)                   </td> </tr>
<tr><td align="center">   Forward Euler                             </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.025 \)                               </td> <td align="center">   \( 3.312\cdot 10^{1} \)                   </td> </tr>
<tr><td align="center">   Backward Euler                            </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.05 \)                                </td> <td align="center">   \( 1.683\cdot 10^{1} \)                   </td> </tr>
<tr><td align="center">   Backward Euler                            </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.025 \)                               </td> <td align="center">   \( 1.231\cdot 10^{1} \)                   </td> </tr>
<tr><td align="center">   Runge-Kutta 2nd-order                     </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.1 \)                                 </td> <td align="center">   \( 8.401 \)                               </td> </tr>
<tr><td align="center">   Runge-Kutta 2nd-order                     </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.05 \)                                </td> <td align="center">   \( 9.637\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="center">   Crank-Nicolson                            </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.05 \)                                </td> <td align="center">   \( 9.389\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="center">   Crank-Nicolson                            </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.025 \)                               </td> <td align="center">   \( 2.411\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="center">   Runge-Kutta 4th-order                     </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.1 \)                                 </td> <td align="center">   \( 2.387 \)                               </td> </tr>
<tr><td align="center">   Runge-Kutta 4th-order                     </td> <td align="center">   \( 1 \)                                   </td> <td align="center">   \( 0.05 \)                                </td> <td align="center">   \( 6.476\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="center">   Crank-Nicolson                            </td> <td align="center">   \( 10 \)                                  </td> <td align="center">   \( 0.1 \)                                 </td> <td align="center">   \( 3.389 \)                               </td> </tr>
<tr><td align="center">   Crank-Nicolson                            </td> <td align="center">   \( 10 \)                                  </td> <td align="center">   \( 0.05 \)                                </td> <td align="center">   \( 9.389\cdot 10^{-1} \)                  </td> </tr>
<tr><td align="center">   Runge-Kutta 4th-order                     </td> <td align="center">   \( 10 \)                                  </td> <td align="center">   \( 0.1 \)                                 </td> <td align="center">   \( 3.686 \)                               </td> </tr>
<tr><td align="center">   Runge-Kutta 4th-order                     </td> <td align="center">   \( 10 \)                                  </td> <td align="center">   \( 0.05 \)                                </td> <td align="center">   \( 6.928\cdot 10^{-1} \)                  </td> </tr>
</table>
<p>
<!-- Should build a verification test on the energy error. -->

<p>
<!-- Link phase plane plot to energy -->
<!-- A phase plane plot shows the curve \( (u(t), u'(t)) \). -->

<h3>The Euler-Cromer method <a name="vib:model2x2:EulerCromer"></a></h3>

<p>
While the 4th-order Runge-Kutta method and the a centered Crank-Nicolson scheme
work well for the first-order formulation of the vibration model, both
were inferior to the straightforward centered difference
scheme for the second-order
equation \( u''+\omega^2u=0 \). However, there is a similarly successful
scheme available for the first-order system \( u'=v \), \( v'=-\omega^2u \),
to be presented next.

<h4>Forward-backward discretization  <a name="___sec38"></a></h4>

<p>
The idea is to apply a Forward Euler discretization to the first
equation and a Backward Euler discretization to the second. In operator
notation this is stated as

<p>
$$
\begin{align}
\lbrack D_t^+u &= v\rbrack^n,\\ 
\lbrack D_t^-v &= -\omega u\rbrack^{n+1}
\thinspace .
\end{align}
$$

We can write out the formulas and collect the unknowns on the left-hand side:
$$
\begin{align}
u^{n+1} &= u^n + \Delta t v^n,
\label{vib:model2x2:EulerCromer:ueq1}\\ 
v^{n+1} &= v^n -\Delta t \omega^2u^{n+1}
\label{vib:model2x2:EulerCromer:veq1}
\thinspace .
\end{align}
$$

We realize that \( u^{n+1} \) can be computed from
\eqref{vib:model2x2:EulerCromer:ueq1} and then \( v^{n+1} \) from
\eqref{vib:model2x2:EulerCromer:veq1} using the recently computed value
\( u^{n+1} \) on the right-hand side.

<p>
<!-- Despite using a backward difference, there is no need to solve a coupled -->
<!-- system for \( u^{n+1} \) and \( v^{n+1} \) because the structure of the ODEs -->
<!-- allows \eqref{vib:model2x2:EulerCromer:ueq1} -->

<p>
The scheme
\eqref{vib:model2x2:EulerCromer:ueq1}-\eqref{vib:model2x2:EulerCromer:veq1}
goes under several names: Forward-backward scheme, <a href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">Semi-implicit Euler method</a>, symplectic
Euler, semi-explicit Euler,
Newton-Stormer-Verlet,
and Euler-Cromer.
We shall stick to the latter name.
Since both time discretizations are based on first-order difference
approximation, one may think that the scheme is only of first-order,
but this is not true: the use of a forward and then a backward
difference make errors cancel so that the overall error in the scheme
is \( \Oof{\Delta t^2} \). This is explaned below.

<h4>Equivalence with the scheme for the second-order ODE  <a name="___sec39"></a></h4>

<p>
We may eliminate the \( v^n \) variable from
\eqref{vib:model2x2:EulerCromer:ueq1}-\eqref{vib:model2x2:EulerCromer:veq1}.
From \eqref{vib:model2x2:EulerCromer:veq1} we have
\( v^n = v^{n-1} - \Delta t \omega^2u^{n} \), which can be inserted
in \eqref{vib:model2x2:EulerCromer:ueq1} to yield
$$
\begin{equation}
u^{n+1} = u^n + \Delta t v^{n-1} - \Delta t^2 \omega^2u^{n} .
\label{vib:model2x2:EulerCromer:elim1}
\end{equation}
$$

The \( v^{n-1} \) quantity can be expressed by \( u^n \) and \( u^{n-1} \)
using \eqref{vib:model2x2:EulerCromer:ueq1}:
$$ v^{n-1} = \frac{u^n - u^{n-1}}{\Delta t},
$$

and when this is inserted in \eqref{vib:model2x2:EulerCromer:elim1} we get
$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},
\end{equation}
$$

which is nothing but the centered scheme \eqref{vib:ode1:step4}!
The previous analysis of this scheme then also applies to the Euler-Cromer
method. That is, the amplitude is constant, given that the stability
criterion is fulfilled, but there is always a phase error
\eqref{vib:ode1:tildeomega:series}.

<p>
The initial condition \( u'=0 \) means \( u'=v=0 \). Then \( v^0=0 \), and
\eqref{vib:model2x2:EulerCromer:ueq1} implies \( u^1=u^0 \), while
\eqref{vib:model2x2:EulerCromer:veq1} says \( v^1=-\omega^2 u^0 \).
This approximation, \( u^1=u^0 \),
corresponds to a first-order Forward Euler discretization
of the initial condition \( u'(0)=0 \): \( [D_t^+ u = 0]^0 \).
Therefore, the Euler-Cromer scheme will start out differently
and not exactly reproduce the solution of \eqref{vib:ode1:step4}.

<h3>The Euler-Cromer scheme on a staggered mesh <a name="vib:model2x2:staggered"></a></h3>

<p>
The Forward and Backward Euler schemes used in the Euler-Cromer
method are both non-symmetric, but their combination yields a
symmetric method since the resulting scheme is equivalent with
a centered (symmetric) difference scheme for \( u''+\omega^2u=0 \).
The symmetric nature of the Euler-Cromer scheme is much more evident if we
introduce a <em>staggered mesh</em> in time where \( u \) is sought at
integer time points \( t_n \) and \( v \) is sought at \( t_{n+1/2} \)
<em>between</em> two \( u \) points.
The unknowns are then \( u^1, v^{3/2}, u^2, v^{5/2} \), and so on.
We typically use the notation
\( u^n \) and \( v^{n+1/2} \) for the two unknown mesh functions.

<p>
On a staggered mesh it is natural to
use centered difference approximations, expressed
in operator notation as
$$
\begin{align}
\lbrack D_t u &= v\rbrack^{n+\frac{1}{2}},\\ 
\lbrack D_t v &= -\omega u\rbrack^{n+1}
\thinspace .
\end{align}
$$

Writing out the formulas gives

<p>
$$
\begin{align}
u^{n+1} &= u^{n} + \Delta t v^{n+\frac{1}{2}},
\label{vib:model2x2:EulerCromer:ueq1s}\\ 
v^{n+\frac{3}{2}} &= v^{n+\frac{1}{2}} -\Delta t \omega^2u^{n+1}
\label{vib:model2x2:EulerCromer:veq1s}
\thinspace .
\end{align}
$$

Of esthetic reasons one often writes these equations at the
previous time level to replace the \( \frac{3}{2} \) by \( \frac{1}{2} \) in the
left-most term in the last equation,

<p>
$$
\begin{align}
u^{n} &= u^{n-1} + \Delta t v^{n-\frac{1}{2}},
\label{vib:model2x2:EulerCromer:ueq1s2}\\ 
v^{n+\frac{1}{2}} &= v^{n-\frac{1}{2}} -\Delta t \omega^2u^{n}
\label{vib:model2x2:EulerCromer:veq1s2}
\thinspace .
\end{align}
$$

Such a rewrite is only mathematical cosmetics. The important thing
is that this centered scheme has exactly the same computational
structure as the forward-backward scheme. We shall use the names
<em>forward-backward Euler-Cromer</em> and <em>staggered Euler-Cromer</em>
to distinguish the two schemes.

<p>
We can eliminate the \( v \)
values and get back the centered scheme based on the second-order
differential equation, so all these three schemes are equivalent.
However, they differ somewhat in the treatment of the initial
conditions.

<p>
Suppose we have \( u(0)=I \) and \( u'(0)=v(0)=0 \) as mathematical
initial conditions. This means \( u^0=I \) and

<p>
$$ v(0)\approx \frac{1}{2}(v^{-\frac{1}{2}} + v^{\frac{1}{2}}) = 0,
\quad\Rightarrow\quad v^{-\frac{1}{2}} =- v^{\frac{1}{2}}\ts$$

Using the discretized equation \eqref{vib:model2x2:EulerCromer:veq1s2} for
\( n=0 \) yields

<p>
$$ v^{\frac{1}{2}} = v^{-\frac{1}{2}} -\Delta t\omega^2 I,$$

and eliminating \( v^{-\frac{1}{2}} =- v^{\frac{1}{2}} \)
results in \( v^{\frac{1}{2}} = -\frac{1}{2}\Delta t\omega^2I \) and

<p>
$$ u^1 = u^0 - \frac{1}{2}\Delta t^2\omega^2 I,$$

which is exactly the same equation for \( u^1 \) as we had in the
centered scheme based on the second-order differential equation
(and hence corresponds to a centered difference approximation of
the initial condition for \( u'(0) \)).
The conclusion is that a staggered mesh is fully equivalent with
that scheme, while the forward-backward version gives a slight
deviation in the computation of \( u^1 \).

<p>
We can redo the derivation of the initial conditions when \( u'(0)=V \):

<p>
$$ v(0)\approx \frac{1}{2}(v^{-\frac{1}{2}} + v^{\frac{1}{2}}) = V,
\quad\Rightarrow\quad v^{-\frac{1}{2}} = 2V - v^{\frac{1}{2}}\ts$$

Using this \( v^{-\frac{1}{2}} \) in

<p>
$$ v^{\frac{1}{2}} = v^{-\frac{1}{2}} -\Delta t\omega^2 I,$$

then gives \( v^{\frac{1}{2}} = V - \frac{1}{2}\Delta t\omega^2 I \).
The general initial conditions are therefore

<p>
$$
\begin{align}
u^0 &= I,
\label{vib:ode2:staggered:u0}\\ 
v^{\frac{1}{2}} &= V - \frac{1}{2}\Delta t\omega^2I
\label{vib:ode2:staggered:v0}\ts
\end{align}
$$

<h3>Implementation of the scheme on a staggered mesh  <a name="___sec41"></a></h3>

<p>
The algorithm goes like this:

<p>

<ol>
<li> Set the initial values \eqref{vib:ode2:staggered:u0} and
   \eqref{vib:ode2:staggered:v0}.</li>
<li> For \( n=1,2,\ldots \):</li>

<ol>
  <li> Compute \( u^{n} \) from \eqref{vib:model2x2:EulerCromer:ueq1s2}.</li>
  <li> Compute \( v^{n+1/2} \) from \eqref{vib:model2x2:EulerCromer:veq1s2}.</li>
</ol>

</ol>

<h4>Implementation with integer indices  <a name="___sec42"></a></h4>

<p>
Translating the schemes \eqref{vib:model2x2:EulerCromer:ueq1s2}
and \eqref{vib:model2x2:EulerCromer:veq1s2} to computer code
faces the problem of how to store and access \( v^{n+\frac{1}{2}} \),
since arrays only allow integer indices with base 0.
We must then introduce a convention: \( v^{1+\frac{1}{2}} \) is stored
in <code>v[n]</code> while \( v^{1-\frac{1}{2}} \) is stored in <code>v[n-1]</code>.
We can then write the algorithm in Python as

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, w, dt, T):
    dt = <span style="color: #658b00">float</span>(dt)
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    u = zeros(Nt+<span style="color: #B452CD">1</span>)
    v = zeros(Nt+<span style="color: #B452CD">1</span>)
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># mesh for u</span>
    t_v = t + dt/<span style="color: #B452CD">2</span>                <span style="color: #228B22"># mesh for v</span>

    u[<span style="color: #B452CD">0</span>] = I
    v[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span> - <span style="color: #B452CD">0.5</span>*dt*w**<span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt+<span style="color: #B452CD">1</span>):
        u[n] = u[n-<span style="color: #B452CD">1</span>] + dt*v[n-<span style="color: #B452CD">1</span>]
        v[n] = v[n-<span style="color: #B452CD">1</span>] - dt*w**<span style="color: #B452CD">2</span>*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t, v, t_v
</pre></div>
<p>
Note that the return \( u \) and \( v \) together with the mesh points such
that the complete mesh function for \( u \) is described by <code>u</code> and <code>t</code>,
while <code>v</code> and <code>t_v</code> represents the mesh function for \( v \).

<h4>Implementation with half-integer indices  <a name="___sec43"></a></h4>

<p>
Some prefer to see a closer relationship between the code and
the mathematics for the quantities with half-integer indices.
For example, we would like to replace the updating equation for
<code>v[n]</code> by

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">v[n+half] = v[n-half] - dt*w**<span style="color: #B452CD">2</span>*u[n]
</pre></div>
<p>
This is easy to do if we could be sure that <code>n+half</code> means <code>n</code> and
<code>n-half</code> means <code>n-1</code>. A possible solution is to define <code>half</code> as a
special object such that an integer plus <code>half</code> results in the integer,
while an integer minus <code>half</code> equals the integer minus 1.
A simple Python class may realize the <code>half</code> object:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">HalfInt</span>:
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__radd__</span>(<span style="color: #658b00">self</span>, other):
        <span style="color: #8B008B; font-weight: bold">return</span> other

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__rsub__</span>(<span style="color: #658b00">self</span>, other):
        <span style="color: #8B008B; font-weight: bold">return</span> other - <span style="color: #B452CD">1</span>

half = HalfInt()
</pre></div>
<p>
The <code>__radd__</code> function is invoked for all expressions <code>n+half</code>
("right add" with <code>self</code> as <code>half</code> and <code>other</code> as <code>n</code>). Similarly,
the <code>__rsub__</code> function is invoked for <code>n-half</code> and results in <code>n-1</code>.

<p>
Using the <code>half</code> object, we can implement the algorithms in an even
more readable way:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, w, dt, T):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;=v, v&#39; = - w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span style="color: #CD5555">    by a central finite difference method with time step dt.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    u = zeros(Nt+<span style="color: #B452CD">1</span>)
    v = zeros(Nt+<span style="color: #B452CD">1</span>)
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># mesh for u</span>
    t_v = t + dt/<span style="color: #B452CD">2</span>                <span style="color: #228B22"># mesh for v</span>

    u[<span style="color: #B452CD">0</span>] = I
    v[<span style="color: #B452CD">0</span>+half] = <span style="color: #B452CD">0</span> - <span style="color: #B452CD">0.5</span>*dt*w**<span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">print</span> n, n+half, n-half
        u[n] = u[n-<span style="color: #B452CD">1</span>] + dt*v[n-half]
        v[n+half] = v[n-half] - dt*w**<span style="color: #B452CD">2</span>*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t, v, t_v
</pre></div>
<p>
Verification of this code is easy as we can just compare the computed <code>u</code>
with the <code>u</code> arising from the <code>solver</code> function in <code>vib_undamped.py</code>.
The values should coincide to machine precision.
The file <a href="http://tinyurl.com/jvzzcfn/vib/vib_undamped_staggered.py"><tt>vib_undamped_staggered.py</tt></a>
contains a nose test for checking this property.

<p>
<!-- is anything gained? is v of higher order than D_2t u from the -->
<!-- other approach, i.e., if we need v, is this alg better? Probably not -->
<!-- since v is related u through a difference -->

<p>
<!-- make exercises: -->
<!-- investigate how important the u^1 wrong formula really is on -->
<!-- convergence rate -->

<p>
<!-- new file: genealizations, systems, -->
<!-- new file: apps -->

<p>
<!-- exercise: damping analysis, see geophysics book first... -->

<h2>Generalization: damping, nonlinear spring, and external excitation <a name="vib:model2"></a></h2>

<p>
We shall now generalize the simple model problem from
the section <a href="#vib:model1">Finite difference discretization</a> to include a possibly nonlinear damping term \( f(u') \),
a possibly nonlinear spring (or restoring) force \( s(u) \), and
some external excitation \( F(t) \):

<p>
$$
\begin{equation}
mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T]
\thinspace .
\label{vib:ode2}
\end{equation}
$$

We have also included a possibly nonzero initial value of \( u'(0) \).
The parameters \( m \), \( f(u') \), \( s(u) \), \( F(t) \), \( I \), \( V \), and \( T \) are
input data.

<p>
There are two main types of damping (friction) forces: linear \( f(u')=bu \), or
quadratic \( f(u')=bu'|u'| \). Spring systems often feature linear
damping, while air resistance usually gives rise to quadratic damping.
Spring forces are often linear: \( s(u)=cu \), but nonlinear versions
are also common, the most famous is the gravity force on a pendulum
that acts as a spring with \( s(u)\sim \sin(u) \).

<h3>A centered scheme for linear damping <a name="vib:ode2:fdm:flin"></a></h3>

<p>
Sampling \eqref{vib:ode2} at a mesh point \( t_n \), replacing
\( u''(t_n) \) by \( [D_tD_tu]^n \), and \( u'(t_n) \) by \( [D_{2t}u]^n \) results
in the discretization

<p>
$$
\begin{equation}
[mD_tD_t u + f(D_{2t}u) + s(u) = F]^n,
\end{equation}
$$

which written out means

<p>
$$
\begin{equation}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n,
\label{vib:ode2:step3b}
\end{equation}
$$

where \( F^n \) as usual means \( F(t) \) evaluated at \( t=t_n \).
Solving \eqref{vib:ode2:step3b} with respect to the unknown
\( u^{n+1} \) gives a problem: the \( u^{n+1} \) inside the \( f \) function
makes the equation <em>nonlinear</em> unless \( f(u') \) is a linear function,
\( f(u')=bu' \). For now we shall assume that \( f \) is linear in \( u' \).
Then

<p>
$$
\begin{equation}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + s(u^n) = F^n,
\label{vib:ode2:step3b2}
\end{equation}
$$

which gives an explicit formula for \( u \) at each
new time level:

<p>
$$
\begin{equation}
u^{n+1} = \left(2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
\Delta t^2(F^n - s(u^n))
\right)(m + \frac{b}{2}\Delta t)^{-1}
\label{vib:ode2:step4}
\thinspace .
\end{equation}
$$


<p>
For the first time step we need to discretize \( u'(0)=V \)
as \( [D_{2t}u = V]^0 \) and combine
with \eqref{vib:ode2:step4} for \( n=0 \). The discretized initial condition
leads to

<p>
$$
\begin{equation}
u^{-1} = u^{1} - 2\Delta t V,
\label{vib:ode2:ic:du}
\end{equation}
$$

which inserted in \eqref{vib:ode2:step4} for \( n=0 \) gives an equation
that can be solved for
\( u^1 \):

<p>
$$
\begin{equation}
u^1 = u^0 + \Delta t\, V
+ \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
\thinspace .
\label{vib:ode2:step4b}
\end{equation}
$$

<h3>A centered scheme for quadratic damping <a name="vib:ode2:fdm:fquad"></a></h3>

<p>
When \( f(u')=bu'|u'| \), we get a quadratic equation for \( u^{n+1} \)
in \eqref{vib:ode2:step3b}. This equation can straightforwardly
be solved, but we can also avoid the nonlinearity by
performing an approximation that is within
other numerical errors that we have already committed by replacing
derivatives with finite differences.

<p>
The idea is to reconsider \eqref{vib:ode2} and only replace
\( u'' \) by \( D_tD_tu \), giving

<p>
$$
\begin{equation}
[mD_tD_t u + bu'|u'| + s(u) = F]^n,
\label{vib:ode2:quad:idea1}
\end{equation}
$$

Here, \( u'|u'| \) is to be computed at time \( t_n \). We can introduce
a <em>geometric mean</em>, defined by

<p>
$$ (w^2)^n \approx w^{n-1/2}w^{n+1/2},$$

for some quantity \( w \) depending on time. The error in the geometric mean
approximation is \( \Oof{\Delta t^2} \), the same as in the
approximation \( u''\approx D_tD_tu \). With \( w=u' \) it follows
that

<p>
$$ [u'|u'|]^n \approx u'(t_n+\frac{1}{2})|u'(t_n-\frac{1}{2})|\ts$$

The next step is to approximate
\( u' \) at \( t_{n\pm 1/2} \), but here a centered difference can be used:

<p>
$$
\begin{equation}
u'(t_{n+1/2})\approx [D_t u]^{n+1/2},\quad u'(t_{n-1/2})\approx [D_t u]^{n-1/2}
\thinspace .
\label{vib:ode2:quad:idea2}
\end{equation}
$$

We then get

<p>
$$
\begin{equation}
[u'|u'|]^n
\approx [D_tu]^{n+1/2}[|D_tu|]^{n-1/2} = \frac{u^{n+1}-u^n}{\Delta t}
\frac{|u^n-u^{n-1}|}{\Delta t}
\thinspace .
\end{equation}
$$

The counterpart to \eqref{vib:ode2:step3b} is then

<p>
$$
\begin{equation}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ b\frac{u^{n+1}-u^n}{\Delta t}\frac{|u^n-u^{n-1}|}{\Delta t}
+ s(u^n) = F^n,
\label{vib:ode2:step3b:quad}
\end{equation}
$$

which is linear in \( u^{n+1} \). Therefore, we can easily solve
with respect to \( u^{n+1} \) and achieve
the explicit updating formula

<p>
$$
\begin{align}
u^{n+1} &=  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \nonumber\\ 
& \qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - s(u^n))
\right)
\thinspace .
\label{vib:ode2:step4:quad}
\end{align}
$$


<p>
<!-- Make exercise to solve complicated u^1 equation with Bisection/Newton -->

<p>
For \( n=0 \) we run into some trouble: inserting \eqref{vib:ode2:ic:du}
in \eqref{vib:ode2:step4:quad} results in a complicated nonlinear
equation for \( u^1 \). By thinking differently about the problem we can
get away with the nonlinearity (again). We have for \( n=0 \) that
\( b[u'|u'|]^0 = bV|V| \). Using this value in \eqref{vib:ode2:quad:idea1}
gives

<p>
$$
\begin{equation}
[mD_tD_t u + bV|V| + s(u) = F]^0
\thinspace .
\end{equation}
$$

Writing this equation out and using \eqref{vib:ode2:ic:du} gives

<p>
$$
\begin{equation}
u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - s(u^0) + F^0\right)
\thinspace .
\label{vib:ode2:step4b:quad}
\end{equation}
$$

<h3>Implementation <a name="vib:ode2:solver"></a></h3>

<p>
The algorithm is very similar to the undamped case. The difference is
basically a question of different formulas for \( u^1 \) and
\( u^{n+1} \). This is actually quite remarkable. The equation
\eqref{vib:ode2} is normally impossible to solve by pen and paper, but
possible for some special choices of \( F \), \( s \), and \( f \). On the
contrary, the nonlinear generalized model \eqref{vib:ode2} versus the
simple undamped model does not make much sense when we solve the
problem numerically!

<p>
The computational algorithm is a slight variation of the one
in the section <a href="#vib:ode1:fdm">A centered finite difference scheme</a>:

<p>

<ol>
 <li> \( u^0=I \)</li>
 <li> compute \( u^1 \) from \eqref{vib:ode2:step4b} if linear
    damping or \eqref{vib:ode2:step4b:quad} if quadratic damping</li>
 <li> for \( n=1,2,\ldots,N_t-1 \):</li>

<ol>
   <li> compute \( u^{n+1} \) from \eqref{vib:ode2:step4} if linear
      damping or \eqref{vib:ode2:step4:quad} if quadratic damping</li>
</ol>

</ol>

Modifying the <code>solver</code> function for the undamped case is fairly
easy, the big difference being many more terms and if tests on
the type of damping:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, V, m, b, s, F, dt, T, damping=<span style="color: #CD5555">&#39;linear&#39;</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve m*u&#39;&#39; + f(u&#39;) + s(u) = F(t) for t in (0,T],</span>
<span style="color: #CD5555">    u(0)=I and u&#39;(0)=V,</span>
<span style="color: #CD5555">    by a central finite difference method with time step dt.</span>
<span style="color: #CD5555">    If damping is &#39;linear&#39;, f(u&#39;)=b*u, while if damping is</span>
<span style="color: #CD5555">    &#39;quadratic&#39;, f(u&#39;)=b*u&#39;*abs(u&#39;).</span>
<span style="color: #CD5555">    F(t) and s(u) are Python functions.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt); b = <span style="color: #658b00">float</span>(b); m = <span style="color: #658b00">float</span>(m) <span style="color: #228B22"># avoid integer div.</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    u = zeros(Nt+<span style="color: #B452CD">1</span>)
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)

    u[<span style="color: #B452CD">0</span>] = I
    <span style="color: #8B008B; font-weight: bold">if</span> damping == <span style="color: #CD5555">&#39;linear&#39;</span>:
        u[<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>] + dt*V + dt**<span style="color: #B452CD">2</span>/(<span style="color: #B452CD">2</span>*m)*(-b*V - s(u[<span style="color: #B452CD">0</span>]) + F(t[<span style="color: #B452CD">0</span>]))
    <span style="color: #8B008B; font-weight: bold">elif</span> damping == <span style="color: #CD5555">&#39;quadratic&#39;</span>:
        u[<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>] + dt*V + \ 
               dt**<span style="color: #B452CD">2</span>/(<span style="color: #B452CD">2</span>*m)*(-b*V*<span style="color: #658b00">abs</span>(V) - s(u[<span style="color: #B452CD">0</span>]) + F(t[<span style="color: #B452CD">0</span>]))

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        <span style="color: #8B008B; font-weight: bold">if</span> damping == <span style="color: #CD5555">&#39;linear&#39;</span>:
            u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">2</span>*m*u[n] + (b*dt/<span style="color: #B452CD">2</span> - m)*u[n-<span style="color: #B452CD">1</span>] +
                      dt**<span style="color: #B452CD">2</span>*(F(t[n]) - s(u[n])))/(m + b*dt/<span style="color: #B452CD">2</span>)
        <span style="color: #8B008B; font-weight: bold">elif</span> damping == <span style="color: #CD5555">&#39;quadratic&#39;</span>:
            u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">2</span>*m*u[n] - m*u[n-<span style="color: #B452CD">1</span>] + b*u[n]*<span style="color: #658b00">abs</span>(u[n] - u[n-<span style="color: #B452CD">1</span>])
                      + dt**<span style="color: #B452CD">2</span>*(F(t[n]) - s(u[n])))/\ 
                      (m + b*<span style="color: #658b00">abs</span>(u[n] - u[n-<span style="color: #B452CD">1</span>]))
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>

<h3>Verification <a name="vib:ode2:verify"></a></h3>

<h4>Constant solution  <a name="___sec49"></a></h4>

<p>
For debugging and initial verification, a constant solution is often
very useful. We choose \( \uex(t)=I \), which implies \( V=0 \).
Inserted in the ODE, we get
\( F(t)=s(I) \) for any choice of \( f \). Since the discrete derivative
of a constant vanishes (in particular, \( [D_{2t}I]^n=0 \),
\( [D_tI]^n=0 \), and \( [D_tD_t I]^n=0 \)), the constant solution also fulfills
the discrete equations. The constant should therefore be reproduced
to machine precision.

<h4>Linear solution  <a name="___sec50"></a></h4>

<p>
Now we choose a linear solution: \( \uex = ct + d \). The initial condition
\( u(0)=I \) implies \( d=I \), and \( u'(0)=V \) forces \( c \) to be \( V \).
Inserting \( \uex=Vt+I \) in the ODE with linear damping results in

<p>
$$ 0 + bV + s(Vt+I) = F(t),$$

while quadratic damping requires the source term

<p>
$$ 0 + b|V|V + s(Vt+I) = F(t)\ts$$

Since the finite difference approximations used to compute \( u' \) all
are exact for a linear function, it turns out that the linear \( \uex \)
is also a solution of the discrete equations.
<a href="#vib:exer:verify:gen:linear">Exercise 8: Use linear/quadratic functions for verification</a> asks you to carry out
all the details.

<h4>Quadratic solution  <a name="___sec51"></a></h4>

<p>
Choosing \( \uex = bt^2 + Vt + I \), with \( b \) arbitrary,
fulfills the initial conditions and
fits the ODE if \( F \) is adjusted properly. The solution also solves
the discrete equations with linear damping. However, this quadratic
polynomial in \( t \) does not fulfill the discrete equations in case
of quadratic damping, because the geometric mean used in the approximation
of this term introduces an error.
Doing <a href="#vib:exer:verify:gen:linear">Exercise 8: Use linear/quadratic functions for verification</a> will reveal
the details. One can fit \( F^n \) in the discrete equations such that
the quadratic polynomial is reproduced by the numerical method (to
machine precision).

<p>
<!-- More: classes, cases with pendulum approx u vs sin(u), -->
<!-- making UI via parampool -->

<h3>Visualization <a name="vib:ode2:viz"></a></h3>

<p>
The functions for visualizations differ significantly from
those in the undamped case in the <code>vib_undamped.py</code> program because
we in the present general case do not have an exact solution to
include in the plots. Moreover, we have no good estimate of
the periods of the oscillations as there will be one period
determined by the system parameters, essentially the
approximate frequency \( \sqrt{s'(0)/m} \) for linear \( s \) and small damping,
and one period dictated by \( F(t) \) in case the excitation is periodic.
This is, however,
nothing that the program can depend on or make use of.
Therefore, the user has to specify \( T \) and the window width
in case of a plot that moves with the graph and shows
the most recent parts of it in long time simulations.

<p>
The <a href="http://tinyurl.com/jvzzcfn/vib/vib.py"><tt>vib.py</tt></a> code
contains several functions for analyzing the time series signal
and for visualizing the solutions.

<h3>User interface <a name="vib:ode2:ui"></a></h3>

<p>
The <code>main</code> function has substantial changes from
the <code>vib_undamped.py</code> code since we need to
specify the new data \( c \), \( s(u) \), and \( F(t) \).  In addition, we must
set \( T \) and the plot window width (instead of the number of periods we
want to simulate as in <code>vib_undamped.py</code>). To figure out whether we
can use one plot for the whole time series or if we should follow the
most recent part of \( u \), we can use the <code>plot_empricial_freq_and_amplitude</code>
function's estimate of the number of local maxima. This number is now
returned from the function and used in <code>main</code> to decide on the
visualization technique.

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main</span>():
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
    parser = argparse.ArgumentParser()
    parser.add_argument(<span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--V&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">0.0</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--m&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--c&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">0.0</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--s&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">str</span>, default=<span style="color: #CD5555">&#39;u&#39;</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--F&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">str</span>, default=<span style="color: #CD5555">&#39;0&#39;</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">0.05</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--T&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">140</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--damping&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">str</span>, default=<span style="color: #CD5555">&#39;linear&#39;</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--window_width&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">30</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--savefig&#39;</span>, action=<span style="color: #CD5555">&#39;store_true&#39;</span>)
    a = parser.parse_args()
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">import</span> StringFunction
    s = StringFunction(a.s, independent_variable=<span style="color: #CD5555">&#39;u&#39;</span>)
    F = StringFunction(a.F, independent_variable=<span style="color: #CD5555">&#39;t&#39;</span>)
    I, V, m, c, dt, T, window_width, savefig, damping = \ 
       a.I, a.V, a.m, a.c, a.dt, a.T, a.window_width, a.savefig, \ 
       a.damping

    u, t = solver(I, V, m, c, s, F, dt, T)
    num_periods = empirical_freq_and_amplitude(u, t)
    <span style="color: #8B008B; font-weight: bold">if</span> num_periods &lt;= <span style="color: #B452CD">15</span>:
        figure()
        visualize(u, t)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        visualize_front(u, t, window_width, savefig)
    show()
</pre></div>
<p>
The program <code>vib.py</code> contains
the above code snippets and can solve the model problem
\eqref{vib:ode2}. As a demo of <code>vib.py</code>, we consider the case
\( I=1 \), \( V=0 \), \( m=1 \), \( c=0.03 \), \( s(u)=\sin(u) \), \( F(t)=3\cos(4t) \),
\( \Delta t = 0.05 \), and \( T=140 \). The relevant command to run is

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python vib.py --s <span style="color: #CD5555">&#39;sin(u)&#39;</span> --F <span style="color: #CD5555">&#39;3*cos(4*t)&#39;</span> --c 0.03
</pre></div>
<p>
This results in a <a href="http://tinyurl.com/k3sdbuv/pub/mov-vib/vib_generalized_dt0.05/index.html">moving window following the function</a> on the screen.
Figure <a href="#vib:ode2:fig:demo">10</a> shows a part of the time series.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Damped oscillator excited by a sinusoidal function. <a name="vib:ode2:fig:demo"></a> </p></center>
<p><img src="fig-vib/vib_gen_demo.png" align="bottom" width=600,></p>
</center>

<h3>A staggered Euler-Cromer scheme for the generalized model <a name="vib:ode2:staggered"></a></h3>

<p>
The model

<p>
$$
\begin{equation}
mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T],
\end{equation}
$$

can be rewritten as a first-order ODE system

<p>
$$
\begin{align}
u' &= v,
\label{vib:ode2:staggered:ueq} \\ 
v' &= m^{-1}\left(F(t) - f(v) - s(u)\right)\ts
\label{vib:ode2:staggered:veq}
\end{align}
$$

It is natural to introduce a staggered mesh (see the section <a href="#vib:model2x2:staggered">The Euler-Cromer scheme on a staggered mesh</a>) and seek \( u \) at mesh points \( t_n \) (the numerical value is
denoted by \( u^n \)) and \( v \) between mesh points at \( t_{n+1/2} \) (the numerical
value is denoted by \( v^{n+1/2} \)).
A centered difference approximation to \eqref{vib:ode2:staggered:ueq}-\eqref{vib:ode2:staggered:veq} can then be written in operator notation as

<p>
$$
\begin{align}
\lbrack D_t u &= v\rbrack^{n-1/2},
\label{vib:ode2:staggered:dueq} \\ 
\lbrack D_tv &= m^{-1}\left(F(t) - f(v) - s(u)\right)\rbrack^n\ts
\label{vib:ode2:staggered:dveq}
\end{align}
$$

Written out,

<p>
$$
\begin{align}
\frac{u^n - u^{n-1}}{\Delta t} &= v^{n-\frac{1}{2}},
\label{vib:ode2:staggered:dueq2} \\ 
\frac{v^{n+\frac{1}{2}} - v^{n-\frac{1}{2}}}{\Delta t}
&= m^{-1}\left(F^n - f(v^n) - s(u^n)\right)\ts
\label{vib:ode2:staggered:dveq2}
\end{align}
$$

With linear damping, \( f(v)=bv \), we can use an arithmetic mean
for \( f(v^n) \): \( f(v^n)\approx = \frac{1}{2}(f(v^{n-1/2}) +
f(v^{n+1/2})) \). The system
\eqref{vib:ode2:staggered:dueq2}-\eqref{vib:ode2:staggered:dveq2}
can then be solved with respect to the unknowns \( u^n \) and \( v^{n+1/2} \):

<p>
$$
\begin{align}
u^n & = u^{n-1} + {\Delta t}v^{n-\frac{1}{2}},
\label{vib:ode2:staggered:u:scheme:lin} \\ 
v^{n+\frac{1}{2}} &= \left(1 + \frac{b}{2m}\Delta t\right)^{-1}\left(
v^{n-\frac{1}{2}} + {\Delta t}
m^{-1}\left(F^n - \frac{1}{2}f(v^{n-\frac{1}{2}}) - s(u^n)\right)\right)\ts
\label{vib:ode2:staggered:v:scheme:lin}
\end{align}
$$


<p>
In case of quadratic damping, \( f(v)=b|v|v \), we can use a geometric mean:
\( f(v^n)\approx b|v^{n-1/2}|v^{n+1/2} \). Inserting this approximation
in \eqref{vib:ode2:staggered:dueq2}-\eqref{vib:ode2:staggered:dveq2} and
solving for the unknowns \( u^n \) and \( v^{n+1/2} \) results in

<p>
$$
\begin{align}
u^n & = u^{n-1} + {\Delta t}v^{n-\frac{1}{2}},
\label{vib:ode2:staggered:u:scheme:quad} \\ 
v^{n+\frac{1}{2}} &= (1 + \frac{b}{m}|v^{n-1/2}|\Delta t)^{-1}\left(
v^{n-\frac{1}{2}} + {\Delta t}
m^{-1}\left(F^n - s(u^n)\right)\right)\ts
\label{vib:ode2:staggered:v:scheme:quad}
\end{align}
$$


<p>
The initial conditions are derived at the end of
the section <a href="#vib:model2x2:staggered">The Euler-Cromer scheme on a staggered mesh</a>:

<p>
$$
\begin{align}
u^0 &= I,
\label{vib:ode2:staggered:u02}\\ 
v^{\frac{1}{2}} &= V - \frac{1}{2}\Delta t\omega^2I
\label{vib:ode2:staggered:v02}\ts
\end{align}
$$

<h2>Exercises and Problems  <a name="___sec55"></a></h2>

<p>
<!-- --- begin exercise --- -->

<h3>Problem 1: Use linear/quadratic functions for verification <a name="vib:exer:undamped:verify:linquad"></a></h3>

<p>
Consider the ODE problem

<p>
$$ u'' + \omega^2u=f(t), \quad u(0)=I,\ u'(0)=V,\ t\in(0,T]\ts$$

Discretize this equation according to
\( [D_tD_t u + \omega^2 u = f]^n \).

<p>
<b>a)</b>
Derive the equation for the
first time step (\( u^1 \)).

<p>
<b>b)</b>
For verification purposes,
we use the method of manufactured solutions (MMS) with the
choice of \( \uex(x,t)= ct+d \).
Find restrictions on \( c \) and \( d \) from
the initial conditions. Compute the corresponding source term \( f \) by term.
Show that \( [D_tD_t t]^n=0 \) and use the fact
that the \( D_tD_t \) operator is linear,
\( [D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0 \), to show that
\( \uex \) is also a perfect solution of the discrete equations.

<p>
<b>c)</b>
Use <code>sympy</code> to do the symbolic calculations above. Here is a
sketch of the program <code>vib_undamped_verify_mms.py</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
V, t, I, w, dt = sm.symbols(<span style="color: #CD5555">&#39;V t I w dt&#39;</span>)  <span style="color: #228B22"># global symbols</span>
f = <span style="color: #658b00">None</span>  <span style="color: #228B22"># global variable for the source term in the ODE</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ode_lhs</span>(u):
    <span style="color: #CD5555">&quot;&quot;&quot;Return left-hand side of ODE: u&#39;&#39; + w**2*u.</span>
<span style="color: #CD5555">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">return</span> ...

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_e</span>(t):
    <span style="color: #CD5555">&quot;&quot;&quot;Return chosen linear exact solution.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">return</span> V*t + I

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">DtDt</span>(u, dt):
    <span style="color: #CD5555">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span style="color: #CD5555">    u is a symbolic Python function of t.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">return</span> ...

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">residual_discrete_eq</span>(u):
    <span style="color: #CD5555">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    R = ...
    <span style="color: #8B008B; font-weight: bold">return</span> sm.simplify(R)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">residual_discrete_eq_step1</span>(u):
    <span style="color: #CD5555">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span style="color: #CD5555">    step with u inserted.&quot;&quot;&quot;</span>
    R = ...
    <span style="color: #8B008B; font-weight: bold">return</span> sm.simplify(R)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main</span>(u):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Given some chosen solution u (as a function of t, implemented</span>
<span style="color: #CD5555">    as a Python function), use the method of manufactured solutions</span>
<span style="color: #CD5555">    to compute the source term f, and check if u also solves</span>
<span style="color: #CD5555">    the discrete equations.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;=== Testing exact solution: %s ===&#39;</span> % u
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&quot;Initial conditions u(0)=%s, u&#39;(0)=%s:&quot;</span> % \ 
          (u(t).subs(t, <span style="color: #B452CD">0</span>), sm.diff(u(t), t).subs(t, <span style="color: #B452CD">0</span>))

    <span style="color: #228B22"># Method of manufactured solution requires fitting f</span>
    <span style="color: #8B008B; font-weight: bold">global</span> f  <span style="color: #228B22"># source term in the ODE</span>
    f = sm.simplify(ode_lhs(u))

    <span style="color: #228B22"># Residual in discrete equations (should be 0)</span>
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;residual step1:&#39;</span>, residual_discrete_eq_step1(u)
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;residual:&#39;</span>, residual_discrete_eq(u)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">linear</span>():
    main(<span style="color: #8B008B; font-weight: bold">lambda</span> t: V*t + I)

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    linear()
</pre></div>
<p>
Fill in the various functions such that the calls in the <code>main</code>
function works.

<p>
<b>d)</b>
The purpose now is to choose a quadratic function
\( \uex = bt^2 + ct + d \) as exact solution. Extend the <code>sympy</code>
code above with a function <code>quadratic</code> for fitting <code>f</code> and checking
if the discrete equations are fulfilled. (The function is very similar
to <code>linear</code>.)

<p>
<!-- Check with hand calculations that the <code>sympy</code> implementation -->
<!-- is correct. -->

<p>
<b>e)</b>
Will a polynomial of degree three fulfill the discrete equations?

<p>
<b>f)</b>
Implement a <code>solver</code> function for computing the numerical
solution of this problem.

<p>
<b>g)</b>
Write a nose test for checking that the quadratic solution
is computed to correctly (too machine precision, but the
round-off errors accumulate and increase with \( T \)) by the <code>solver</code>
function.

<p>
Filenames: <code>vib_undamped_verify_mms.pdf</code>, <code>vib_undamped_verify_mms.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 1: Show linear growth of the phase with time <a name="vib:exer:phase:err:growth"></a></h3>

<p>
Consider an exact solution \( I\cos (\omega t) \) and an
approximation \( I\cos(\tilde\omega t) \).
Define the phase error as time lag between the peak \( I \)
in the exact solution and the corresponding peak in the approximation
after \( m \) periods of oscillations. Show that this phase error
is linear in \( m \).
Filename: <code>vib_phase_error_growth.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 2: Improve the accuracy by adjusting the frequency <a name="vib:exer:w:adjust"></a></h3>

<p>
According to \eqref{vib:ode1:tildeomega:series}, the numerical
frequency deviates from the exact frequency by a (dominating) amount
\( \omega^3\Delta t^2/24 >0 \). Replace the <code>w</code> parameter in the algorithm
in the <code>solver</code> function in <code>vib_undamped.py</code> by <code>w*(1 -
(1./24)*w**2*dt**2</code> and test how this adjustment in the numerical
algorithm improves the accuracy (use \( \Delta t =0.1 \) and simulate
for 80 periods, with and without adjustment of \( \omega \)).

<p>
<!-- How does this go if -->
Filename: <code>vib_adjust_w.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 3: See if adaptive methods improve the phase error <a name="vib:exer:undamped:adaptive"></a></h3>

<p>
Adaptive methods for solving ODEs aim at adjusting \( \Delta t \) such
that the error is within a user-prescribed tolerance. Implement the
equation \( u''+u=0 \) in the <a href="https://github.com/hplgit/odespy">Odespy</a>
software. Use the example <a href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/._part0007_main_decay.html#example-adaptive-runge-kutta-methods">on adaptive
schemes</a>
in <a href="#Langtangen:deq:decay">[1]</a>.  Run the scheme with a very low
tolerance (say \( 10^{-14} \)) and for a long time, check the number of
time points in the solver's mesh (<code>len(solver.t_all)</code>), and compare
the phase error with that produced by the simple finite difference
method from the section <a href="#vib:ode1:fdm">A centered finite difference scheme</a> with the same number of (equally
spaced) mesh points. The question is whether it pays off to use an
adaptive solver or if equally many points with a simple method gives
about the same accuracy.
Filename: <code>vib_undamped_adaptive.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 4: Use a Taylor polynomial to compute \( u^1 \) <a name="vib:exer:step4b:alt"></a></h3>

<p>
As an alternative to the derivation of \eqref{vib:ode1:step4b} for
computing \( u^1 \), one can use a Taylor polynomial with three terms
for \( u^1 \):

<p>
$$ u(t_1) \approx u(0) + u'(0)\Delta t + \frac{1}{2}u''(0)\Delta t^2$$

With \( u''=-\omega^2 u \) and \( u'(0)=0 \), show that this method also leads to
\eqref{vib:ode1:step4b}. Generalize the condition on \( u'(0) \) to
be \( u'(0)=V \) and compute \( u^1 \) in this case with both methods.
Filename: <code>vib_first_step.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 5: Find the minimal resolution of an oscillatory function <a name="vib:exer:wdt:limit"></a></h3>

<p>
<!-- Short: Find the largest relevant value of \( \omega\Delta t \) -->

<p>
Sketch the function on a given mesh which has the highest possible
frequency. That is, this oscillatory "cos-like" function has its
maxima and minima at every two grid points.  Find an expression for
the frequency of this function, and use the result to find the largest
relevant value of \( \omega\Delta t \) when \( \omega \) is the frequency
of an oscillating function and \( \Delta t \) is the mesh spacing.
Filename: <code>vib_largest_wdt.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 6: Visualize the accuracy of finite differences for a cosine function <a name="vib:exer:fd:exp:plot"></a></h3>

<p>
<!-- Short: Visualize the accuracy of finite differences -->

<p>
We introduce the error fraction
$$ E = \frac{[D_tD_t u]^n}{u''(t_n)} $$

to measure the error in the finite difference approximation \( D_tD_tu \) to
\( u'' \).
Compute \( E \)
for the specific choice of a cosine/sine function of the
form \( u=\exp{(i\omega t)} \) and show that
$$ E = \left(\frac{2}{\omega\Delta t}\right)^2
\sin^2(\frac{\tilde\omega\Delta t}{2})
\thinspace .
$$

Plot \( E \) as a function of \( p=\omega\Delta t \). The relevant
values of \( p \) are \( [0,\pi] \) (see <a href="#vib:exer:wdt:limit">Exercise 5: Find the minimal resolution of an oscillatory function</a>
for why \( p>\pi \) does not make sense).
The deviation of the curve from unity visualizes the error in the
approximation. Also expand \( E \) as a Taylor polynomial in \( p \) up to
fourth degree (use, e.g., <code>sympy</code>).
Filename: <code>vib_plot_fd_exp_error.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 7: verify convergence rates of the error in energy <a name="vib:exer:energy:convrate"></a></h3>

<p>
We consider the ODE problem \( u'' + \omega^2u=0 \), \( u(0)=I \), \( u'(0)=V \),
for \( t\in (0,T] \). The total energy of the solution
\( E(t)=\frac{1}{2}(u')^2 + \frac{1}{2}\omega^2 u^2 \) should stay
constant.
The error in energy can be computed as explained in
the section <a href="#vib:model1:energy">Enegy considerations</a>.

<p>
Make a nose test in a file <code>test_error_conv.py</code>, where code
from <code>vib_undamped.py</code> is important, but <code>convergence_rates</code>
and <code>test_convergence_rates</code> are modified to also incorporate
computations of the error in energy and the convergence
rate of this error. The expected rate is 2.
Filename: <code>test_error_conv.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 8: Use linear/quadratic functions for verification <a name="vib:exer:verify:gen:linear"></a></h3>

<p>
This exercise is a generalization of <a href="#vib:exer:undamped:verify:linquad">Problem 1: Use linear/quadratic functions for verification</a> to the extended model problem
\eqref{vib:ode2} where the damping term is either linear or quadratic.
Solve the various subproblems and see how the results and problem
settings change with the generalized ODE in case of linear or
quadratic damping. By modifying the code from <a href="#vib:exer:undamped:verify:linquad">Problem 1: Use linear/quadratic functions for verification</a>, <code>sympy</code> will do most
of the work required to analyze the generalized problem.
Filename: <code>vib_verify_mms.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 9: Use an exact discrete solution for verification <a name="vib:exer:discrete:omega"></a></h3>

<p>
Write a nose test function in a separate file
that employs the exact discrete solution
\eqref{vib:ode1:un:exact} to verify the implementation of the
<code>solver</code> function in the file <code>vib_undamped.py</code>.
Just import <code>solver</code> and make functions for the exact discrete
solution and the nose test.
Filename: <code>vib_verify_discrete_omega.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 10: Use analytical solution for convergence rate tests <a name="vib:exer:conv:rate"></a></h3>

<p>
The purpose of this exercise is to perform convergence tests of
the problem \eqref{vib:ode2} when \( s(u)=\omega^2u \) and \( F(t)=A\sin\phi t \).
Find the complete analytical solution to the problem in this case
(most textbooks on mechanics list the various elements you need to
write down the exact solution).
Modify the <code>convergence_rate</code> function from the <code>vib_undamped.py</code>
program to perform experiments with the extended model.
Verify that the error is of order \( \Delta t^2 \).
Filename: <code>vib_conv_rate.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 11: Investigate the amplitude errors of many solvers <a name="vib:exer:undamped:odespy"></a></h3>

<p>
Use the program <code>vib_undamped_odespy.py</code> from the section <a href="#vib:undamped:1stODE">Standard methods for 1st-order ODE systems</a>
and the amplitude estimation from the <code>amplitudes</code> function
in the <code>vib_undamped.py</code> file (see the section <a href="#vib:ode1:empirical">Empirical analysis of the solution</a>)
to investigate how well famous methods for 1st-order ODEs
can preserve the amplitude of \( u \) in undamped oscillations.
Test, for example, the 3rd- and 4th-order Runge-Kutta methods
(<code>RK3</code>, <code>RK4</code>), the Crank-Nicolson method (<code>CrankNicolson</code>),
the 2nd- and 3rd-order Adams-Bashforth methods (<code>AdamsBashforth2</code>,
<code>AdamsBashforth3</code>), and a 2nd-order Backwards scheme (<code>Backward2Step</code>).
The relevant governing equations are listed in
the section ref{vib:model2x2:ueq}.
Filename: <code>vib_amplitude_errors.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 12: Minimize memory usage of a vibration solver <a name="vib:exer:memsave"></a></h3>

<p>
The program <a href="http://tinyurl.com/jvzzcfn/vib/vib.py"><tt>vib.py</tt></a>
store the complete solution \( u^0,u^1,\ldots,u^{N_t} \) in memory, which is
convenient for later plotting.
Make a memory minimizing version of this program where only the last three
\( u^{n+1} \), \( u^n \), and \( u^{n-1} \) values are stored in memory.
Write each computed \( (t_{n+1}, u^{n+1}) \) pair to file.
Visualize the data in the file (a cool solution is to
read one line at a time and
plot the \( u \) value using the line-by-line plotter in the
<code>visualize_front_ascii</code> function - this technique makes it trivial
to visualize very long time simulations).
Filename: <code>vib_memsave.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 13: Implement the solver via classes <a name="vib:exer:gen:class"></a></h3>

<p>
Reimplement the <code>vib.py</code>
program
using a class <code>Problem</code> to hold all the physical parameters of the problem,
a class <code>Solver</code> to hold the numerical parameters and compute the
solution, and a class <code>Visualizer</code> to display the solution.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Use the ideas and examples
for an <a href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#implementing-simple-problem-and-solver-classes">ODE model</a>.
More specifically, make a superclass <code>Problem</code> for holding the scalar
physical parameters of a problem and let subclasses implement the
\( s(u) \) and \( F(t) \) functions as methods.
Try to call up as much existing functionality in <code>vib.py</code> as possible.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>vib_class.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 14: Show equivalence between schemes <a name="vib:exer:schemes:equiv"></a></h3>

<p>
Show that the schemes from the sections <a href="#vib:ode1:fdm">A centered finite difference scheme</a>,
<a href="#vib:model2x2:EulerCromer">The Euler-Cromer method</a>, and
<a href="#vib:model2x2:staggered">The Euler-Cromer scheme on a staggered mesh</a> are all equivalent.
<!-- mech systems: horizontal, vertical/hanging -->
<!-- box with mu*M*g*v/|v| friction force, treat nonlinearity with geometric mean -->
<!-- pendulum -->
<!-- bumpy road -->
<!-- moored ship -->
<!-- electrical circuits, see ode2.p.tex -->
<!-- 0D blood flow? -->
<!-- waves: 1D blood flow -->
<!-- general particle laws and velocity verlet, make exercises -->
<!-- see <a href="http://en.wikipedia.org/wiki/Velocity_Verlet"><tt>http://en.wikipedia.org/wiki/Velocity_Verlet</tt></a> -->

<p>
<!-- in vb_odespy examples: add 20 RK4 1000 to show RK4 in the long run -->

<p>
<!-- mu'' + bu' + ku = F(t) -->
<!-- set up analytical solution for reference -->
<!-- compare for F = sin qt, demonstrate resonance by having -->
<!-- F = sin q t and q = piecewise constant in time with four -->
<!-- levels: 0.1, 0.75 1, 1.25, 2 of the resonance frequency, -->
<!-- make each platou act for a while to see the effect -->

<p>
<!-- mu'' + bu' + s(u) = F(t) as exercise, pendulum -->
<!-- mu'' + f(x) + s() = F(t) via odespy RK4 -->

<p>
<!-- odespy: ForwardBackward on a 2n system? Need special formula for first -->
<!-- step to ensure dt^2 accuracy there. -->

<p>
<!-- apps: planet around a star, box horizontal and vertical, bumpy, -->
<!-- jumping washing machine, pendulum, moored ship, look to Irgens -->
Filename: <code>vib_scheme_equivalence.pdf</code>.

<p>
<!-- --- end exercise --- -->

<h2>References  <a name="___sec71"></a></h2>

<p>

<ol>
 <li> <a name="Langtangen:deq:decay"></a> <b>H. P. Langtangen</b>. 
    Introduction to Computing With Finite Difference Methods,
    <em>Simula Research Laboratory and University of Oslo</em>,
    2013,
    <a href="http://hplgit.github.com/INF5620/doc/pub/decay-sphinx/main_decay.html"><tt>http://hplgit.github.com/INF5620/doc/pub/decay-sphinx/main_decay.html</tt></a>.</li>
</ol>


<p>
<!-- begin bottom navigation --><!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

