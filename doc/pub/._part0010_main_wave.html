<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for wave motion">
<meta name="keywords" content="waves on a string,wave equation 1D,wave equation 1D, finite difference method,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,unit testing,software testing nose,vectorization,scalar code,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,stencil Neumann boundary,index set notation,geometric mean,arithmetic mean,harmonic average,averaging geometric,averaging arithmetic,averaging harmonic,wave equation 1D, analytical properties,Fourier series,Fourier transform,discrete Fourier transform,wave equation 1D, exact numerical solution,Courant number,stability criterion,wave equation 1D, stability,wave equation 2D, implementation,Cython,declaration of variables in Cython,C extension module,wrapper code,Fortran subroutine,row-major ordering,column-major ordering,Fortran array storage,C/Python array storage,radiation condition,open boundary condition">



<style type="text/css">
    /* blueish style */

    /* Color definitions:  http://www.december.com/html/spec/color0.html
       CSS examples:       http://www.w3schools.com/css/css_examples.asp */

    body {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #000000;
    }
    h1 { font-size: 1.8em; color: #1e36ce; }
    h2 { font-size: 1.5em; color: #1e36ce; }
    h3 { color: #1e36ce; }
    a { color: #1e36ce; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #bababa;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #f8f8f8;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods for waves on a string ',
               1,
               'wave:string',
               'wave:string'),
              (' Discretizing the domain ',
               2,
               'wave:string:mesh',
               'wave:string:mesh'),
              (' Uniform meshes ', 3, None, '___sec2'),
              (' The discrete solution ',
               2,
               'wave:string:numerical:sol',
               'wave:string:numerical:sol'),
              (' Fulfilling the equation at the mesh points ',
               2,
               'wave:string:samplingPDE',
               'wave:string:samplingPDE'),
              (' Replacing derivatives by finite differences ',
               2,
               'wave:string:fd',
               'wave:string:fd'),
              (' Algebraic version of the PDE ', 3, None, '___sec6'),
              (' Algebraic version of the initial conditions ',
               3,
               None,
               '___sec7'),
              (' Formulating a recursive algorithm ',
               2,
               'wave:string:alg',
               'wave:string:alg'),
              (' Sketch of an implementation ',
               2,
               'wave:string:impl',
               'wave:string:impl'),
              (' Verification ', 1, None, '___sec10'),
              (' A slightly generalized model problem ',
               2,
               'wave:pde2:fd',
               'wave:pde2:fd'),
              (' Using an analytical solution of physical significance ',
               2,
               None,
               '___sec12'),
              (' Manufactured solution ', 2, None, '___sec13'),
              (' Constructing an exact solution of the discrete equations ',
               2,
               None,
               '___sec14'),
              (' Implementation ', 1, 'wave:pde1:impl', 'wave:pde1:impl'),
              (' Making a solver function ', 2, None, '___sec16'),
              (' Verification: exact quadratic solution ',
               2,
               None,
               '___sec17'),
              (' Visualization: animating $u(x,t)$ ', 2, None, '___sec18'),
              (' Visualization via SciTools ', 3, None, '___sec19'),
              (' Making movie files ', 3, None, '___sec20'),
              (' Skipping frames for animation speed ', 3, None, '___sec21'),
              (' Visualization via Matplotlib ', 3, None, '___sec22'),
              (' Running a case ',
               2,
               'wave:pde1:guitar:data',
               'wave:pde1:guitar:data'),
              (' The benefits of scaling ', 2, None, '___sec24'),
              (' Vectorization ', 1, None, '___sec25'),
              (' Operations on slices of arrays ', 2, None, '___sec26'),
              (' Finite difference schemes expressed as slices ',
               2,
               None,
               '___sec27'),
              (' Verification ', 2, None, '___sec28'),
              (' Efficiency measurements ', 2, None, '___sec29'),
              (' Exercises ', 1, None, '___sec30'),
              (' Exercise 1: Simulate a standing wave ',
               2,
               'wave:exer:standingwave',
               'wave:exer:standingwave'),
              (' Exercise 2: Add storage of solution in a user action function ',
               2,
               'wave:exer:store:list',
               'wave:exer:store:list'),
              (' Exercise 3: Use a class for the user action function ',
               2,
               'wave:exer:store:list:class',
               'wave:exer:store:list:class'),
              (' Exercise 4: Compare several Courant numbers in one movie ',
               2,
               'wave:exer:multiple:C',
               'wave:exer:multiple:C'),
              (' Project 5: Calculus with 1D mesh functions ',
               2,
               'wave:exer:mesh1D:calculus',
               'wave:exer:mesh1D:calculus'),
              (' Generalization: reflecting boundaries ',
               1,
               None,
               '___sec36'),
              (' Neumann boundary condition ',
               2,
               'wave:pde2:Neumann',
               'wave:pde2:Neumann'),
              (' Discretization of derivatives at the boundary ',
               2,
               'wave:pde2:Neumann:discr',
               'wave:pde2:Neumann:discr'),
              (' Implementation of Neumann conditions ',
               2,
               'wave:pde2:Neumann:impl',
               'wave:pde2:Neumann:impl'),
              (' Index set notation ', 2, 'wave:indexset', 'wave:indexset'),
              (' Alternative implementation via ghost cells ',
               2,
               'wave:pde1:Neumann:ghost',
               'wave:pde1:Neumann:ghost'),
              (' Idea ', 3, None, '___sec42'),
              (' Implementation ', 3, None, '___sec43'),
              (' Generalization: variable wave velocity ',
               1,
               'wave:pde2:var:c',
               'wave:pde2:var:c'),
              (' The model PDE with a variable coefficient ',
               2,
               None,
               '___sec45'),
              (' Discretizing the variable coefficient ',
               2,
               'wave:pde2:var:c:ideas',
               'wave:pde2:var:c:ideas'),
              (' Computing the coefficient between mesh points ',
               2,
               'wave:pde2:var:c:means',
               'wave:pde2:var:c:means'),
              (' How a variable coefficient affects the stability ',
               2,
               'wave:pde2:var:c:stability',
               'wave:pde2:var:c:stability'),
              (' Neumann condition and a variable coefficient ',
               2,
               'wave:pde2:var:c:Neumann',
               'wave:pde2:var:c:Neumann'),
              (' Implementation of variable coefficients ',
               2,
               'wave:pde2:var:c:impl',
               'wave:pde2:var:c:impl'),
              (' A more general model PDE with variable coefficients ',
               2,
               None,
               '___sec51'),
              (' Generalization: damping ', 2, None, '___sec52'),
              (' Building a general 1D wave equation solver ',
               1,
               'wave:pde2:software',
               'wave:pde2:software'),
              (' User action function as a class ', 2, None, '___sec54'),
              (' Collection of initial conditions ', 2, None, '___sec55'),
              (' Exercises ', 1, None, '___sec56'),
              (' Problem 6: Explore the effect of boundary conditions ',
               2,
               'wave:exer:1D:bceffects',
               'wave:exer:1D:bceffects'),
              (' Problem 7: Explore symmetry boundary conditions ',
               2,
               'wave:exer:symmetry:bc',
               'wave:exer:symmetry:bc'),
              (' Exercise 8: Send pulse waves through a layered medium ',
               2,
               'wave:app:exer:pulse1D',
               'wave:app:exer:pulse1D'),
              (' Exercise 9: Compare discretizations of a Neumann condition ',
               2,
               None,
               '___sec60'),
              (' Analysis of the continuous and discrete solutions ',
               1,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Properties of the solution of the wave equation ',
               2,
               'wave:pde1:properties',
               'wave:pde1:properties'),
              (' More precise definition of Fourier representations ',
               2,
               'wave:pde1:Fourier',
               'wave:pde1:Fourier'),
              (' Analysis of the finite difference scheme ',
               2,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Extending the analysis to 2D and 3D ',
               2,
               'wave:pde1:analysis:2D3D',
               'wave:pde1:analysis:2D3D'),
              (' Finite difference methods for 2D and 3D wave equations ',
               1,
               'wave:2D3D',
               'wave:2D3D'),
              (' Multi-dimensional wave equations ',
               2,
               'wave:2D3D:models',
               'wave:2D3D:models'),
              (' Mesh ', 2, 'wave:2D3D:mesh', 'wave:2D3D:mesh'),
              (' Discretization ', 2, 'wave:2D3D:models', 'wave:2D3D:models'),
              (' Discretizing the PDEs ', 3, None, '___sec70'),
              (' Handling boundary conditions where is $u$ known ',
               3,
               None,
               '___sec71'),
              (' Discretizing the $\\partial u/\\partial n = 0$ ',
               3,
               None,
               '___sec72'),
              (' Implementation ', 1, 'wave:2D3D:impl', 'wave:2D3D:impl'),
              (' Scalar computations ', 2, None, '___sec74'),
              (' Domain and mesh ', 3, None, '___sec75'),
              (' Stability limit ', 3, None, '___sec76'),
              (' Solution arrays ', 3, None, '___sec77'),
              (' Computing the solution ', 3, None, '___sec78'),
              (' Vectorized computations ', 2, None, '___sec79'),
              (' Verification ', 2, None, '___sec80'),
              (' Testing a quadratic solution ', 3, None, '___sec81'),
              (' Migrating loops to Cython ', 2, None, '___sec82'),
              (' Declaring variables and annotating the code ',
               3,
               None,
               '___sec83'),
              (' Visual inspection of the C translation ',
               3,
               None,
               '___sec84'),
              (' Building the extension module ', 3, None, '___sec85'),
              (' Calling the Cython function ', 3, None, '___sec86'),
              (' Efficiency ', 3, None, '___sec87'),
              (' Migrating loops to Fortran ', 2, None, '___sec88'),
              (' The Fortran subroutine ', 3, None, '___sec89'),
              (' Building the Fortran module with f2py ',
               3,
               None,
               '___sec90'),
              (' Examining doc strings ', 3, None, '___sec91'),
              (' How to avoid array copying ', 3, None, '___sec92'),
              (' Efficiency ', 3, None, '___sec93'),
              (' Migrating loops to C via Cython ', 2, None, '___sec94'),
              (' Translating index pairs to single indices ',
               3,
               None,
               '___sec95'),
              (' The complete C code ', 3, None, '___sec96'),
              (' The Cython interface file ', 3, None, '___sec97'),
              (' Building the extension module ', 3, None, '___sec98'),
              (' Efficiency ', 3, None, '___sec99'),
              (' Migrating loops to C via f2py ', 2, None, '___sec100'),
              (' Migrating loops to C via Instant ', 2, None, '___sec101'),
              (' Migrating loops to C++ via f2py ', 2, None, '___sec102'),
              (' Using classes to implement a simulator ',
               2,
               None,
               '___sec103'),
              (' Callbacks to Python from Fortran or C ',
               2,
               None,
               '___sec104'),
              (' Exercises ', 1, None, '___sec105'),
              (' Project 10: Calculus with 2D/3D mesh functions ',
               2,
               'wave:exer:mesh3D:calculus',
               'wave:exer:mesh3D:calculus'),
              (' Applications of wave equations ', 1, 'wave:app', 'wave:app'),
              (' Waves on a string ',
               2,
               'wave:app:string',
               'wave:app:string'),
              (' Damping ', 3, None, '___sec109'),
              (' External forcing ', 3, None, '___sec110'),
              (' Modeling the tension via springs ', 3, None, '___sec111'),
              (' Waves on a membrane ',
               2,
               'wave:app:membrane',
               'wave:app:membrane'),
              (' Elastic waves in a rod ',
               2,
               'wave:app:elastic:rod',
               'wave:app:elastic:rod'),
              (' The acoustic model for seismic waves ',
               2,
               'wave:app:acoustic:seismic',
               'wave:app:acoustic:seismic'),
              (' Anisotropy ', 3, None, '___sec115'),
              (' Sound waves in liquids and gases ',
               2,
               'wave:app:sound',
               'wave:app:sound'),
              (' Spherical waves ',
               2,
               'wave:app:spherical',
               'wave:app:spherical'),
              (' The linear shallow water equations ',
               2,
               'wave:app:sw:2D',
               'wave:app:sw:2D'),
              (' Wind drag on the surface ', 3, None, '___sec119'),
              (' Bottom drag ', 3, None, '___sec120'),
              (" Effect of the Earth's rotation ", 3, None, '___sec121'),
              (' Waves in blood vessels ',
               2,
               'wave:app:blood',
               'wave:app:blood'),
              (' Reduction to standard wave equation ', 3, None, '___sec123'),
              (' Electromagnetic waves ',
               2,
               'wave:app:light',
               'wave:app:light'),
              (' Exercises ', 1, 'wave:app:exer', 'wave:app:exer'),
              (' Exercise 11: Simulate waves on a non-homogeneous string ',
               2,
               'wave:app:exer:string:discont',
               'wave:app:exer:string:discont'),
              (' Exercise 12: Simulate damped waves on a string ',
               2,
               'wave:app:exer:string:damping',
               'wave:app:exer:string:damping'),
              (' Exercise 13: Simulate elastic waves in a rod ',
               2,
               'wave:app:exer:rod',
               'wave:app:exer:rod'),
              (' Exercise 14: Explain why numerical noise occurs ',
               2,
               'wave:app:exer:pulse1D:analysis',
               'wave:app:exer:pulse1D:analysis'),
              (' Exercise 15: Investigate harmonic averaging in a 1D model ',
               2,
               'wave:app:exer:pulse1D:harmonic',
               'wave:app:exer:pulse1D:harmonic'),
              (' Exercise 16: Test the efficiency of compiled loops in 3D ',
               2,
               'wave:exer:3D:f77:cy:efficiency',
               'wave:exer:3D:f77:cy:efficiency'),
              (' Exercise 17: Earthquake-generated tsunami in a 1D model ',
               2,
               'wave:app:exer:tsunami1D',
               'wave:app:exer:tsunami1D'),
              (' Exercise 18: Implement an open boundary condition ',
               2,
               'wave:app:exer:tsunami1D:radiation',
               'wave:app:exer:tsunami1D:radiation'),
              (' Exercise 19: Earthquake-generated tsunami over a subsea hill ',
               2,
               'wave:app:exer:tsunami1D:hill',
               'wave:app:exer:tsunami1D:hill'),
              (' Exercise 20: Implement Neumann conditions in 2D ',
               2,
               'wave:app:exer:wave2D:Neumann',
               'wave:app:exer:wave2D:Neumann'),
              (' Exercise 21: Implement a convergence test for a 2D code ',
               2,
               None,
               '___sec136'),
              (' Exercise 22: Earthquake-generated tsunami over a 3D hill ',
               2,
               'wave:app:exer:tsunami2D:hill',
               'wave:app:exer:tsunami2D:hill'),
              (' Exercise 23: Implement loops in compiled languages ',
               2,
               'wave:app:exer:tsunami2D:hill:compiled',
               'wave:app:exer:tsunami2D:hill:compiled'),
              (' Exercise 24: Write a complete program in Fortran or C ',
               2,
               'wave:app:exer:tsunami2D:hill:compiled2',
               'wave:app:exer:tsunami2D:hill:compiled2'),
              (' Exercise 25: Investigate Matplotlib for visualization ',
               2,
               'wave:app:exer:tsunami:hill:viz:matplotlib',
               'wave:app:exer:tsunami:hill:viz:matplotlib'),
              (' Exercise 26: Investigate visualization packages ',
               2,
               'wave:app:exer:tsunami:hill:viz:packages',
               'wave:app:exer:tsunami:hill:viz:packages'),
              (' Exercise 27: Investigate harmonic vs arithmetic mean ',
               2,
               'wave:app:exer:tsunami:hill:harmonic',
               'wave:app:exer:tsunami:hill:harmonic'),
              (' Exercise 28: Simulate seismic waves in 2D ',
               2,
               'wave:app:exer:seismic2D',
               'wave:app:exer:seismic2D'),
              (' Project 29: Modeling 3D acoustic waves in a room ',
               2,
               'wave:app:exer:acoustics',
               'wave:app:exer:acoustics'),
              (' Project 30: Solve a 1D transport equation ',
               2,
               'wave:app:exer:advec1D',
               'wave:app:exer:advec1D')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0010"></a>
<!-- begin top navigation -->
<a href="._part0009_main_wave.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>
<!-- end top navigation -->

<p>
<!-- !split -->

<h2>Exercises <a name="wave:app:exer"></a></h2>

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 11: Simulate waves on a non-homogeneous string <a name="wave:app:exer:string:discont"></a></h3>

<p>
Simulate waves on a string that consists of two materials with
different density. The tension in the string is constant, but the
density has a jump at the boundary between the materials.
Experiment
with different sizes of the jump to derive a couple of demonstrations
that visualizes the effect on the waves of having a two-material
string.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
the section <a href="._part0007_main_wave.html#wave:app:string">Waves on a string</a>
explains how the density enters the mathematical model. Modify the
<code>wave1D_u0_sv.py</code> code to incorporate the tension and a function
specifying the density.

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>wave1D_u0_sv_discont.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 12: Simulate damped waves on a string <a name="wave:app:exer:string:damping"></a></h3>

<p>
Formulate a mathematical model for damped waves on a string.
Use data from the section <a href="._part0002_main_wave.html#wave:pde1:guitar:data">Running a case</a>, and
tune the damping parameter so that the string is very close to
the rest state after 15 s. Make a movie of the wave motion.
Filename: <code>wave1D_u0_sv_damping.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 13: Simulate elastic waves in a rod <a name="wave:app:exer:rod"></a></h3>

<p>
A hammer hits the end of an elastic rod. The exercise is to simulate
the resulting wave motion using the model <a href="._part0007_main_wave.html#mjx-eqn-71">(71)</a>
from the section <a href="._part0007_main_wave.html#wave:app:elastic:rod">Elastic waves in a rod</a>. Let the rod have length
\( L \) and let the boundary \( x=L \) be stress free so that \( \sigma_{xx}=0 \),
implying that \( \partial u/\partial x=0 \). The left end \( x=0 \) is
subject to a strong stress pulse (the hammer), modeled as

<p>
$$ \sigma_{xx}(t) = \left\lbrace\begin{array}{ll}
S,& 0 < t \leq t_s,\\ 
0, & t > t_s
\end{array}\right.
$$

The corresponding condition on \( u \) becomes \( u_x= S/E \)
for \( t\leq t_s \) and zero afterwards (recall that
\( \sigma_{xx} = Eu_x \)). This is a non-homogeneous
Neumann condition, and you will need to approximate this condition
and combine it with the scheme (the ideas and manipulations follow
closely the handling of a non-zero initial condition
\( u_t=V \) in wave PDEs or the corresponding
second-order ODEs for vibrations).
Filename: <code>wave_rod.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 14: Explain why numerical noise occurs <a name="wave:app:exer:pulse1D:analysis"></a></h3>

<p>
The experiments performed in <a href="._part0003_main_wave.html#wave:app:exer:pulse1D">Exercise 8: Send pulse waves through a layered medium</a> shows
considerable numerical noise in the form of non-physical waves,
especially for \( s_f=4 \) and the plug pulse or the half a "cosinehat"
pulse. The noise is much less visible for a Gaussian pulse. Run the
case with the plug and half a "cosinehat" pulses for \( s_f=1 \), \( C=0.9,
0.25 \), and \( N_x=40,80,160 \). Use the numerical dispersion relation to
explain the observations.
Filename: <code>pulse1D_analysis.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 15: Investigate harmonic averaging in a 1D model <a name="wave:app:exer:pulse1D:harmonic"></a></h3>

<p>
Will harmonic averaging of the wave velocity give better numerical
results for the case \( s_f=4 \) in <a href="._part0003_main_wave.html#wave:app:exer:pulse1D">Exercise 8: Send pulse waves through a layered medium</a>?
Filenames: <code>pulse1D_harmonic.pdf</code>, <code>pulse1D_harmonic.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 16: Test the efficiency of compiled loops in 3D <a name="wave:exer:3D:f77:cy:efficiency"></a></h3>

<p>
Extend the <code>wave2D_u0.py</code> code and the Cython, Fortran, and C versions to 3D.
Set up an efficiency experiment to determine the relative efficiency of
pure scalar Python code, vectorized code, Cython-compiled loops,
Fortran-compiled loops, and C-compiled loops.
Normalize the CPU time for each mesh by the fastest version.
Filename: <code>wave3D_u0.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 17: Earthquake-generated tsunami in a 1D model <a name="wave:app:exer:tsunami1D"></a></h3>

<p>
A subsea earthquake leads to an immediate lift of the surface, see
Figure <a href="#wave:app:fig:1D:tsunami:flat">10</a>. The initial surface shape \( I(x) \) is symmetric
around \( x=0 \) and will split into two tsunamis, one traveling to the right
and one to the left, as depicted in Figure <a href="#wave:app:fig:1D:tsunami:2waves">11</a>.
Since the water surface will remain symmetric with respect to \( x=0 \), given that
the outgoing wave to the left does not come back due to reflection,
we insert a boundary \( x=0 \) and impose a symmetry condition there: \( \partial\eta\ 
\partial x =0 \), where \( \eta(x,t) \) is the elevation of the water surface.
We are not interested in what happens with the right-going wave after
it hits the right boundary, so whether we impose
\( \eta =0 \) or \( \partial\eta /\partial x=0 \) at that boundary is not of importance.

<p>
The shape of the initial surface can be taken as a
Gaussian function,

<p>
$$
\begin{equation}
I(x;I_0,I_a,I_m,I_s) =
I_0 + I_a\exp{\left(-\left(\frac{x-I_m}{I_s}\right)^2\right)},
\end{equation}
$$

with \( I_m=0 \) reflecting the location of the peak of \( I(x) \) and
\( I_s \) being a measure of the width of the function \( I(x) \)
(\( I_s \) is \( \sqrt{2} \) times the standard deviation of the familiar
normal distribution curve).

<p>
Set up the relevant one-dimensional, linear, wave equation for \( \eta \),
assuming long waves of small amplitude in comparison with the depth,
as described in the section <a href="._part0008_main_wave.html#wave:app:sw:2D">The linear shallow water equations</a>. Import the <code>viz</code> method
from the <code>wave1D.py</code> program and make a call to it to solve the
present tsunami problem.  The constant speed of the right-going wave is
\( c=\sqrt{gH} \) and use this quantity to determine a suitable time \( T \)
for when the wave hits the right boundary and the simulation is to be
stopped. An alternative is to check in <code>plot_u</code> if \( u[-2] \) is
significantly different from 0 and then return <code>True</code> to stop
the simulation.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Sketch of initial water surface due to a subsea earthquake. <a name="wave:app:fig:1D:tsunami:flat"></a> </p></center>
<p><img src="fig-wave/earthquake_tsunami_flat.png" align="bottom" width=800,></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  An initial surface elevation is split into two waves. <a name="wave:app:fig:1D:tsunami:2waves"></a> </p></center>
<p><img src="fig-wave/earthquake_tsunami_2waves.png" align="bottom" width=800,></p>
</center>

<p>
Filename: <code>tsunami1D_flat.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 18: Implement an open boundary condition <a name="wave:app:exer:tsunami1D:radiation"></a></h3>

<p>
To enable the right-going wave in <a href="#wave:app:exer:tsunami1D">Exercise 17: Earthquake-generated tsunami in a 1D model</a>
to leave the computational domain and travel undisturbed through
the boundary, one can in a one-dimensional problem impose the
following condition, called a <em>radiation condition</em> or
<em>open boundary condition</em>:

<p>
$$
\begin{equation}
\frac{\partial\eta}{\partial t} + c\frac{\partial\eta}{\partial x} = 0,
\tag{95}
\end{equation}
$$

at the right boundary \( x=x_R \). The parameter \( c \) is the wave velocity,
which for the model in <a href="#wave:app:exer:tsunami1D">Exercise 17: Earthquake-generated tsunami in a 1D model</a>
is \( c=\sqrt{gH(x_R)} \).

<p>
Show that <a href="#mjx-eqn-95">(95)</a> accepts
a solution \( \eta = g_R(x-ct) \), but not \( \eta = g_L(x+ct) \). This means
that <a href="#mjx-eqn-95">(95)</a> will allow any
right-going wave \( g_R(x-ct) \) pass through the boundary.

<p>
The condition <a href="#mjx-eqn-95">(95)</a> can be
discretized by centered differences at the spatial end point \( i=N_x \),
corresponding to \( x=x_R \):

<p>
$$
\begin{equation}
[D_{2t}\eta + cD_{2x}\eta =0]^n_{N_x}
\tag{96}
\thinspace .
\end{equation}
$$

Eliminate the fictitious value \( \eta_{N_x+1}^n \) by using
the discrete equation at the same point \( (n,N_x) \).
The equation for the first step, \( \eta_i^1 \), is in principal affected,
but we can then use the condition \( \eta^1_{N_x}=0 \) since the wave
has not yet reached the right boundary.

<p>
Modify the <code>solver</code> function in the <code>wave1D.py</code> program to
incorporate the condition <a href="#mjx-eqn-96">(96)</a>.
Demonstrate that the tsunami travels through the domain and out of
the right boundary without leaving any reflections behind.
Make a nose test for checking that after a certain time \( T \), the surface is
flat.

<p>
<b>Remark 1.</b>
The condition <a href="#mjx-eqn-95">(95)</a>
works perfectly in 1D when \( c \) is known. In 2D and 3D, however, the
condition reads \( \eta_t + c_x\eta_x + c_y\eta_y=0 \), where \( c_x \) and
\( c_y \) are the wave speeds in the \( x \) and \( y \) directions, and estimating
these components (i.e., the direction of the wave) is often
challenging. Other methods are normally used in 2D and 3D to
let waves move out of a computational domain.

<p>
<b>Remark 2.</b>
A radiation or open boundary condition at the left
boundary takes the same form as <a href="#mjx-eqn-95">(95)</a>,
except that there is a minus sign in front of the \( c\eta_x \)
term. One can easily show that with this sign, the condition accepts
left-going waves of the form \( \eta = g_L(x+ct) \).
Filename: <code>wave1D_Ropen.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 19: Earthquake-generated tsunami over a subsea hill <a name="wave:app:exer:tsunami1D:hill"></a></h3>

<p>
We consider the same problem as in <a href="#wave:app:exer:tsunami1D">Exercise 17: Earthquake-generated tsunami in a 1D model</a>, but now there is a hill at the sea
bottom, see Figure <a href="#wave:app:fig:1D:tsunami:hill">12</a>. The wave speed
\( c=\sqrt{gH(x)} = \sqrt{g(H_0-B(x))} \) will then be reduced in the
shallow water above the hill.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 12:  Sketch of an earthquake-generated tsunami passing over a subsea hill. <a name="wave:app:fig:1D:tsunami:hill"></a> </p></center>
<p><img src="fig-wave/earthquake_tsunami_hill.png" align="bottom" width=800,></p>
</center>

<p>
One possible form of the
hill is a Gaussian function,

<p>
$$
\begin{equation}
B(x;B_0,B_a,B_m,B_s) =
B_0 + B_a\exp{\left(-\left(\frac{x-B_m}{B_s}\right)^2\right)},
\tag{97}
\end{equation}
$$

but many other shapes are also possible, e.g., a "cosine hat" where

<p>
$$
\begin{equation}
B(x; B_0, B_a, B_m, B_s) = B_0 + B_a\cos{\left( \pi\frac{x-B_m}{2B_s}\right)},
\tag{98}
\end{equation}
$$

when \( x\in [B_m - B_s, B_m + B_s] \) while \( B=B_0 \) outside this
interval.

<p>
Also an abrupt construction may be tried:
$$
\begin{equation}
B(x; B_0, B_a, B_m, B_s) = B_0 + B_a,
\tag{99}
\end{equation}
$$

for \( x\in [B_m - B_s, B_m + B_s] \) while \( B=B_0 \) outside this
interval.

<p>
Visualize both the bottom topography and the
water surface elevation (this requires modifying <code>plot_u</code>).
Allow for a flexible choice of bottom shape,
<a href="#mjx-eqn-97">(97)</a>,
<a href="#mjx-eqn-98">(98)</a>,
<a href="#mjx-eqn-99">(99)</a>, or \( B(x)=B_0 \) (flat)
and see if the waves become
qualitatively different. Also investigate the amount of numerical
noise that is triggered by rapid changes in the bottom function
and a small water gap at the top of the hill, and how this noise
varies with the mesh resolution \( \Delta x \).
Use either the open boundary condition from
<a href="#wave:app:exer:tsunami1D:radiation">Exercise 18: Implement an open boundary condition</a>, or set \( \eta =0 \) at
the right boundary and stop the simulation when the wave hits this
boundary.
Filename: <code>tsunami1D_hill.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 20: Implement Neumann conditions in 2D <a name="wave:app:exer:wave2D:Neumann"></a></h3>

<p>
Modify the <a href="/wave2D_u0/wave2D_u0.py"><tt>wave2D_u0.py</tt></a>
program, which solves the 2D wave equation \( u_{tt}=c^2(u_{xx}+u_{yy}) \)
with constant wave velocity \( c \) and \( u=0 \) on the boundary, to have
Neumann boundary conditions: \( \partial u/\partial n=0 \).
Include both scalar code (for debugging and reference) and
vectorized code (for speed).

<p>
To test the code, use \( u=1.2 \) as solution (\( I(x,y)=1.2 \), \( V=f=0 \), and
\( c \) arbitrary), which should be exactly reproduced with any mesh
as long as the stability criterion is satisfied.
Another test is to use the plug-shaped pulse
in the <code>pulse</code> function from the section <a href="._part0003_main_wave.html#wave:pde2:software">Building a general 1D wave equation solver</a>
and the <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py"><tt>wave1D_dn_vc.py</tt></a>
program. This pulse
is exactly propagated in 1D if \( c\Delta t/\Delta x=1 \). Check
that also the 2D program can propagate this pulse exactly
in \( x \) direction (\( c\Delta t/\Delta x=1 \), \( \Delta y \) arbitrary)
and \( y \) direction (\( c\Delta t/\Delta y=1 \), \( \Delta x \) arbitrary).
Filename: <code>wave2D_n.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 21: Implement a convergence test for a 2D code  <a name="___sec136"></a></h3>

<p>
Use the following manufactured solution to verify a 2D code
for \( u_{tt}=c^2(u_{xx}+u_{yy}) \) in the spatial domain
\( [0,L_x]\times [0,L_y] \), with \( \partial u/\partial n \) on the boundary
(cf. <a href="#wave:app:exer:wave2D:Neumann">Exercise 20: Implement Neumann conditions in 2D</a>):

<p>
$$
\begin{equation}
\uex(x,y,t)=\cos(m_xx\pi/L_x)\cos(m_yy\pi/L_y)\cos (\omega t),
\tag{100}
\end{equation}
$$

Here, \( m_x \) and \( m_y \) are freely chosen integers such that
the wave lengths in the \( x \) and \( y \) directions become \( 2L_x/m_x \) and
\( 2L_y/m_y \), respectively. The parameter \( \omega \) is calculated
by inserting <a href="#mjx-eqn-100">(100)</a> in the wave equation.
The solution
<a href="#mjx-eqn-100">(100)</a> is a <em>standing wave</em>
with \( \partial u/\partial n=0 \).
This \( \uex \) is not an exact solution of the discrete equations so the
test must be based on empirical analysis of the convergence.
The error \( E \) is assumed to behave like

<p>
$$
E = C_t\Delta t^2 + C_x\Delta x^2 + C_y\Delta y^2,
$$

for some constants \( C_t \), \( C_x \), and \( C_y \).
Choose \( \Delta t=F_th \), \( \Delta x =F_xh \), and \( \Delta y=F_yh \), where
\( h \) is a common discretization parameter to be varied (\( h\rightarrow 0 \))
and \( F_t \), \( F_x \), and \( F_y \) are freely chosen constant factors
compatible with the stability criterion in 2D. The error can then
be expressed as

<p>
$$
E = Ch^2,
$$

where \( C=C_xF_t^2 + C_yF_x^2 + C_tF_t^2 \).
Perform experiments with decreasing \( h \), compute \( E \), and verify that
\( E/h^2 \) is approximately constant.
Filename: <code>wave2D_n2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 22: Earthquake-generated tsunami over a 3D hill <a name="wave:app:exer:tsunami2D:hill"></a></h3>

<p>
This exercise extends <a href="#wave:app:exer:tsunami1D:hill">Exercise 19: Earthquake-generated tsunami over a subsea hill</a>
to a three-dimensional wave phenomenon, governed by the 2D PDE
<a href="._part0008_main_wave.html#mjx-eqn-89">(89)</a>. We assume that the earthquake
arise from a fault along the line \( x=0 \) in the \( xy \)-plane so that
the initial lift of the surface can be taken as \( I(x) \) in
<a href="#wave:app:exer:tsunami1D:hill">Exercise 19: Earthquake-generated tsunami over a subsea hill</a>. That is, a plan wave is
propagating to the right, but will experience bending because of
the bottom.

<p>
The bottom shape is now a function of \( x \) and \( y \).
An "elliptic" Gauss function in two dimensions, with its peak
at \( (B_{mx}, B_{my}) \), generalizes
<a href="#mjx-eqn-97">(97)</a>:

<p>
$$
\begin{equation}
B(x;B_0,B_a,B_{mx}, B_{my} ,B_s, b) =
B_0 + B_a\exp{\left(-\left(\frac{x-B_{mx}}{B_s}\right)^2
-\left(\frac{y-B_{my}}{bB_s}\right)^2\right)},
\tag{101}
\end{equation}
$$

where \( b \) is a scaling parameter: \( b=1 \) gives a circular Gaussian
function with circular contour lines, while \( b\neq 1 \) gives an elliptic
shape with elliptic contour lines.

<p>
The "cosine hat" <a href="#mjx-eqn-98">(98)</a> can also be
generalized to

<p>
$$
\begin{equation}
B(x; B_0, B_a, B_{mx}, B_{my}, B_s) =
B_0 + B_a\cos{\left( \pi\frac{x-B_{mx}}{2B_s}\right)}
\cos{\left( \pi\frac{y-B_{my}}{2B_s}\right)},
\tag{102}
\end{equation}
$$

when \( 0 \leq \sqrt{x^2+y^2} \leq B_s \) and \( B=B_0 \) outside this circle.

<p>
A box-shaped obstacle means that
$$
\begin{equation}
B(x; B_0, B_a, B_m, B_s, b) = B_0 + B_a
\tag{103}
\end{equation}
$$

for \( x \) and \( y \) inside a rectangle
$$ B_{mx}-B_s \leq  x \leq B_{mx} + B_s,\quad
B_{my}-bB_s \leq  y \leq B_{my} + bB_s,
$$

and \( B=B_0 \) outside this rectangle.
The \( b \) parameter controls the rectangular shape of the cross section of
the box.

<p>
Note that the initial condition and the listed bottom shapes are
symmetric around the line \( y=B_{my} \). We therefore expect the
surface elevation also to be symmetric with respect to this line.
This means that we can halve the computational domain by working
with  \( [0,L_x]\times [0, B_{my}] \). Along the upper boundary, \( y=B_{my} \),
we must impose the symmetry condition \( \partial \eta/\partial n=0 \).
Such a symmetry condition (\( -\eta_x=0 \))
is also needed at the \( x=0 \) boundary because
the initial condition has a symmetry here. At the lower boundary
\( y=0 \) we also set a Neumann condition (which becomes \( -\eta_y=0 \)).
At the right boundary \( x=L_x \)
one can either implement a radiation (or open boundary) condition
as in <a href="#wave:app:exer:tsunami1D:radiation">Exercise 18: Implement an open boundary condition</a> or just set
\( \eta = 0 \) or use a reflecting condition \( \partial\eta/\partial n
=\eta_x =0 \).

<p>
Visualize the surface elevation.  Investigate how different hill shapes,
different sizes of the water gap above the hill, and different
resolutions \( \Delta x \) and \( \Delta t \) influence
the numerical quality of the solution.
Filename: <code>tsunami2D_hill.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 23: Implement loops in compiled languages <a name="wave:app:exer:tsunami2D:hill:compiled"></a></h3>

<p>
Extend the program from <a href="#wave:app:exer:tsunami2D:hill">Exercise 22: Earthquake-generated tsunami over a 3D hill</a> such
that the loops over mesh points, inside the time loop, are
implemented in compiled languages.
Consider implementations in
Cython, Fortran via <code>f2py</code>, C via Cython, C via <code>f2py</code>, C/C++ via Instant,
and C/C++ via <code>scipy.weave</code>.
Perform efficiency experiments to investigate the relative performance
of the various implementations. It is often advantageous to normalize
CPU times by the fastest method on a given mesh.
Filename: <code>tsunami3D_hill_compiled.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 24: Write a complete program in Fortran or C <a name="wave:app:exer:tsunami2D:hill:compiled2"></a></h3>

<p>
As an extension of <a href="#wave:app:exer:tsunami2D:hill:compiled2">Exercise 24: Write a complete program in Fortran or C</a>,
write the whole <code>tsunami3D_hill.py</code> code in Fortran, C, or C++ to check
if there is more to be won with respect to efficiency in large-scale
problems. This exercise will also illustrate the difference in
program development with Fortran/C/C++ and Python.
Filename: <code>tsunami3D_hill.f</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 25: Investigate Matplotlib for visualization <a name="wave:app:exer:tsunami:hill:viz:matplotlib"></a></h3>

<p>
Play with native Matplotlib code for visualizing 2D
solutions of the wave equation with variable wave velocity.
See if there
are effective ways to visualize both the solution and the wave
velocity.
Filename: <code>tsunami2D_hill_mpl.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 26: Investigate visualization packages <a name="wave:app:exer:tsunami:hill:viz:packages"></a></h3>

<p>
Explore one or more of the programs below
for visualizing solutions of 2D or 3D wave equations with variable
wave velocity. Try to visualize
both the solution and the wave velocity in the same plot.

<p>

<ul>
  <li> <a href="http://code.enthought.com/projects/mayavi/">Mayavi</a></li>
  <li> <a href="http://www.paraview.org/">Paraview</a></li>
  <li> <a href="http://www.opendx.org/">OpenDX</a></li>
</ul>

Filename: <code>tsunami2D_hill_mayavi.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 27: Investigate harmonic vs arithmetic mean <a name="wave:app:exer:tsunami:hill:harmonic"></a></h3>

<p>
In <a href="#wave:app:exer:tsunami1D:hill">Exercise 19: Earthquake-generated tsunami over a subsea hill</a>, investigate if
there is significant difference between the harmonic mean
<a href="._part0003_main_wave.html#mjx-eqn-30">(30)</a> and the standard
arithmetic mean <a href="._part0003_main_wave.html#mjx-eqn-29">(29)</a>.
Use extreme cases for the investigations where the subsea hill is
close to the flat surface. Pay particular attention to the
box-shaped obstruction <a href="#mjx-eqn-99">(99)</a> since
it has discontinuities.

<p>
Repeat the investigations for the case of a box-shaped obstruction
in the 2D model from <a href="#wave:app:exer:tsunami2D:hill">Exercise 22: Earthquake-generated tsunami over a 3D hill</a>.

<p>
<b>Remark.</b>
With a small gap between the obstruction and the free surface,
and with abrupt changes in the bottom shape, the model PDE does not
necessarily describe the wave motion in an accurate or qualitatively correct
way.
Filename: <code>tsunami2D_hill_harmonic.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 28: Simulate seismic waves in 2D <a name="wave:app:exer:seismic2D"></a></h3>

<p>
The goal of this exercise is to simulate seismic waves using the
PDE model <a href="._part0007_main_wave.html#mjx-eqn-78">(78)</a> in a
2D \( xz \) domain with geological layers.
Introduce \( m \) horizontal layers of thickness \( h_i \), \( i=0,\ldots,m-1 \).
Inside layer number \( i \) we have a vertical wave velocity \( c_{z,i} \)
and a horizontal wave velocity \( c_{h,i} \). Make a program
for simulating such 2D waves. Test it on a case with 3 layers where

<p>
$$ c_{z,0}=c_{z,1}=c_{z,2},\quad c_{h,0}=c_{h,2},\quad c_{h,1} \ll c_{h,0}
\thinspace .
$$

Let \( s \) be a localized point source at the middle of the Earth's surface
(the upper boundary)
and investigate how the resulting wave travels through the medium.
The source can be a localized Gaussian peak that oscillates in
time for some time interval.
Place the boundaries far enough from the expanding wave so that the
boundary conditions do not disturb the wave. Then the type of
boundary condition does not matter, except that we physically need
to have \( p=p_0 \), where \( p_0 \) is the atmospheric pressure,
at the upper boundary.
Filename: <code>seismic2D.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Project 29: Modeling 3D acoustic waves in a room <a name="wave:app:exer:acoustics"></a></h3>

<p>
The equation for sound waves in air is derived in the section <a href="._part0007_main_wave.html#wave:app:sound">Sound waves in liquids and gases</a>
and reads

<p>
$$ p_{tt} = c^2\nabla^2 p,$$

where \( p(x,y,z,t) \) is the pressure and \( c \)
is the speed of sound, taken as 340 m/s.
<!-- air at a room temperature 20 C, \( p_0 \) is reference pressure in the -->
<!-- air, typically 1 atm (approximately \( 10^5 \) Pa), and \( \varrho_0 \) is -->
<!-- the density of air, taken as \( 1.225\mbox{ kg/m}^3 \). -->
However, sound is absorbed in the air due to relaxation of molecules
in the gas. A model for simple relaxation, valid for gases consisting
only of one type of molecules, is a term \( c^2\tau_s\nabla^2 p_t \) in
the PDE, where \( \tau_s \) is the relaxation time. If we generate sound
from, e.g., a loudspeaker in the room, this sound source must also
be added to the governing equation.

<p>
The PDE with the mentioned type of damping and source then becomes

<p>
$$
\begin{equation}
p_tt = c^2\nabla^p + c^2\tau_s\nabla^2 p_t + f,
\end{equation}
$$

where \( f(x,y,z,t) \) is the source term.

<p>
The walls can absorb some sound. A possible model is to have a "wall layer"
(thicker than the physical wall)
outside the room where \( c \) is changed such that some of the wave energy
is reflected and some is absorbed in the wall. The absorption of
energy can be taken care of by adding a damping term \( bp_t \) in
the equation:

<p>
$$
\begin{equation}
p_tt + bp_t = c^2\nabla^p + c^2\tau_s\nabla^2 p_t + f\ts
\end{equation}
$$

Typically, \( b=0 \) in the room and \( b>0 \) in the wall. A discontinuity in \( b \)
or \( c \) will give rise to reflections. It can be wise to use a constant
\( c \) in the wall to control reflections because of the discontinuity between
\( c \) in the air and in the wall, while \( b \) is gradually increased
as we go into the wall to avoid reflections because of rapid changes in \( b \).
At the outer boundary of the wall the condition \( p=0 \) or \( \partial p/\partial n=0 \) can be imposed. The waves should anyway be approximately dampened
to \( p=0 \) this far out in the wall layer.

<p>
There are two strategies for discretizing the \( \nabla^2 p_t \) term: using
a center difference between times \( n+1 \) and \( n-1 \) (if the equation is
sampled at level \( n \)), or use a one-sided difference based on levels \( n \)
and \( n-1 \). The latter has the advantage of not leading to any equation system,
while the former is second-order accurate as the scheme for the
simple wave equation \( p_tt = c^2\nabla^2 p \). To avoid an equation system,
go for the one-sided difference such that the overall scheme becomes
explicit and only of first order in time.

<p>
Develop a 3D solver for the specified PDE and introduce a wall layer.
Test the solver with the method of manufactured solutions. Make some
demonstrations where the wall reflects and absorbs the waves (reflection
because of discontinuity in \( b \) and absorption because of growing \( b \)).
Experiment with the impact of the \( \tau_s \) parameter.
Filename: <code>acoustics.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Project 30: Solve a 1D transport equation <a name="wave:app:exer:advec1D"></a></h3>

<p>
We shall study the wave equation

<p>
$$
\begin{equation}
u_t + cu_x = 0,\quad x\in (0,L],\ t\in (0, T],
\tag{104}
\end{equation}
$$

with initial condition

<p>
$$
\begin{equation}
u(x,0) = I(x),\quad x\in [0,L],
\end{equation}
$$

and <em>one</em> periodic boundary condition

<p>
$$
\begin{equation}
u(0,t) = u(L,t)
\thinspace .
\end{equation}
$$

This boundary condition means that what goes out of the domain at \( x=L \)
comes in at \( x=0 \). Roughly speaking,
we need only one boundary condition because of
the spatial derivative is of first order only.

<p>
<b>Physical interpretation.</b>
The parameter \( c \) can be constant or variable, \( c=c(x) \). The
equation <a href="#mjx-eqn-104">(104)</a> arises in <em>transport</em>
problems where a quantity \( u \), which could be temperature or
concentration of some contaminant, is transported with the velocity
\( c \) of a fluid. In addition to the transport imposed by "travelling with
the fluid", \( u \) may also be transported by diffusion (such as
heat conduction or Fickian diffusion), but we have in
the model \( u_t + cu_x \) assumed that diffusion effects are negligible,
which they often are.

<p>
A widely used numerical scheme for <a href="#mjx-eqn-104">(104)</a>
applies a forward difference in time and a backward difference in
space when \( c>0 \):

<p>
$$
\begin{equation}
[D_t^+ u + cD_x^-u = 0]_i^n
\tag{105}
\thinspace .
\end{equation}
$$

For \( c<0 \) we use a forward difference in space: \( [cD_x^+u]_i^n \).

<p>
We shall hereafter assume that \( =c(x)>0 \).

<p>
To compute <a href="#mjx-eqn-110">(110)</a> we need to integrate
\( 1/c \) to obtain \( C \) and then compute the inverse of \( C \).

<p>
The inverse function computation can be easily done if we first think
discretely. Say we have some function \( y=g(x) \) and seeks its inverse.
Plotting \( (x_i,y_i) \), where \( y_i=g(x_i) \) for some mesh points \( x_i \),
displays \( g \) as a function of \( x \).
The inverse function is simply \( x \) as a function of \( g \), i.e., the
curve with points \( (y_i,x_i) \). We can therefore quickly compute points
at the curve of the inverse function. One way of extending these
points to a continuous function is to assume a linear variation
(known as linear interpolation)
between the points (which actually means to draw straight lines between
the points, exactly as done by a plotting program).

<p>
The function <code>wrap2callable</code> in <code>scitools.std</code> can take a set of points
and return a continuous function that corresponds to linear
variation between the points. The computation of the inverse of a
function \( g \) on \( [0,L] \) can then be done by

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">inverse</span>(g, domain, resolution<span style="color: #666666">=101</span>):
    x <span style="color: #666666">=</span> linspace(domain[<span style="color: #666666">0</span>], domain[L], resolution)
    y <span style="color: #666666">=</span> g(x)
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> wrap2callable
    g_inverse <span style="color: #666666">=</span> wrap2callable((y, x))
    <span style="color: #008000; font-weight: bold">return</span> g_inverse
</pre></div>
<p>
To compute \( C(x) \) we need to integrate \( 1/c \), which can be done by
a Trapezoidal rule. Suppose we have computed \( C(x_i) \) and need
to compute \( C(x_{i+1}) \). Using the Trapezoidal rule with \( m \) subintervals
over the integration domain \( [x_i,x_{i+1}] \) gives

<p>
$$
\begin{equation}
C(x_{i+1}) = C(x_i) + \int_{x_i}^{x_{i+1}} \frac{dx}{c}
\approx h\left(
\frac{1}{2}\frac{1}{c(x_i)} + \frac{1}{2}\frac{1}{c(x_{i+1})}
+ \sum_{j=1}^{m-1} \frac{1}{c(x_i + jh)}\right),
\tag{106}
\end{equation}
$$

where \( h=(x_{i+1}-x_i)/m \) is the length of the subintervals used
for the integral over \( [x_i,x_{i+1}] \).
We observe that <a href="#mjx-eqn-106">(106)</a> is a
<em>difference equation</em> which we can solve by repeatedly
applying <a href="#mjx-eqn-106">(106)</a> for
\( i=0,1,\ldots,N_x-1 \) if a mesh \( x_0,x_,\ldots,x_{N_x} \) is prescribed.
Note that \( C(0)=0 \).

<p>
<!-- Idea: one thing at a time: no f2py intro for du/dn, just u=0 to make it -->
<!-- simple -->

<p>
<!-- 1D open boundary cond, try u=0 and du/dn=0 combination too -->
<!-- 1D correction terms -->

<p>
<!-- migrate to compiled: idea is to keep it very simple (u=0 cond), or maybe -->
<!-- do it in 1D? No, better in 2D, but have f(x,y) as an array (no callback) -->
<!-- 2D -->
<!-- 2D code simple, u=0, constant coeff -->
<!-- 2D visualization with mayavi2, matplotlib, gnuplot (scitools), + mpeg/avi -->
<!-- 2D code vectorized -->
<!-- 2D code cython -->
<!-- 2D code f2py -->
<!-- 2D code instant -->

<p>
<!-- Exer: f2py w/callback to Python for f and inlet U_0 -->

<p>
<!-- 3D -->
<!-- 3D code vectorized -->
<!-- 3D code cython -->
<!-- main point: visualization with paraview or similar -->

<p>
<!-- apps: -->
<!-- shallow water, 1D and 2D -->
<!-- string -->
<!-- pipe -->
<!-- 3D acoustic -->
<!-- elastic in the ground, div u -->
<!-- blood 1D -->

<p>
<b>a)</b>
Show that under the assumption of \( a=\hbox{const} \),

<p>
$$
\begin{equation}
u(x,t) = I(x - ct)
\tag{107}
\end{equation}
$$

fulfills the PDE as well as the initial and boundary condition
(provided \( I(0)=I(L) \)).

<p>
<b>b)</b>
Set up a computational algorithm and implement it in a function.
Assume \( a \) is constant and positive.

<p>
<b>c)</b>
Test implementation by using the remarkable property that
the numerical solution is exact at the mesh points if
\( \Delta t = c^{-1}\Delta x \).

<p>
<b>d)</b>
Make a movie comparing the numerical and exact solution for the
following two choices of initial conditions:

<p>
$$
\begin{equation}
 I(x) = \left\lbrack\sin\left(\pi\frac{x}{L}\right)\right\rbrack^{2n}
\tag{108}
\end{equation}
$$

where \( n \) is an integer, typically \( n=5 \),
and

<p>
$$
\begin{equation}
I(x) = \exp{\left( -\frac{(x-L/2)^2}{2\sigma2}\right)} \thinspace .
\end{equation}
\tag{109}
$$

Choose \( \Delta t = c^{-1}\Delta x, 0.9c^{-1}\Delta x, 0.5c^{-1}\Delta x \).

<p>
<b>e)</b>
The performance of the suggested numerical scheme can be investigated
by analyzing the numerical dispersion relation.
Analytically, we have that the <em>Fourier component</em>

<p>
$$ u(x,t) = e^{i(kx-\omega t)},$$

is a solution of the PDE if \( \omega = kc \). This is the <em>analytical
dispersion relation</em>. A complete solution of the PDE can be built by
adding up such Fourier components with different amplitudes, where the
initial condition \( I \) determines the amplitudes. The solution \( u \) is
then represented by a Fourier series.

<p>
A similar discrete Fourier component at \( (x_p,t_n) \) is

<p>
$$ u_p^q = e^{i(kp\Delta x -\tilde\omega n\Delta t)},$$

where in general \( \tilde\omega \) is a function of \( k \), \( \Delta t \), and
\( \Delta x \), and differs from the exact \( \omega =kc \).

<p>
Insert the discrete Fourier component in the numerical scheme and
derive an expression for \( \tilde\omega \), i.e.,
the discrete dispersion relation. Show in particular that if
the \( \Delta t/(c\Delta x)=1 \), the discrete solution coincides with the
exact solution at the mesh points, regardless of the mesh resolution (!).
Show that if the stability condition

<p>
$$ \frac{\Delta t}{c\Delta x}\leq 1,$$

the discrete Fourier component cannot grow (i.e., \( \tilde\omega \) is real).

<p>
<b>f)</b>
Write a test for your implementation where you try to use information
from the numerical dispersion relation.

<p>
<b>g)</b>
Set up a computational algorithm for the variable
coefficient case and implement it in a function.
Make a test that the function works for constant \( a \).

<p>
<b>h)</b>
It can be shown that
for an observer moving with velocity \( c(x) \), \( u \) is constant.
This can be used to derive an exact solution when \( a \) varies
with \( x \). Show first that

<p>
$$
\begin{equation}
u(x,t) = f(C(x) - t),
\tag{110}
\end{equation}
$$

where

<p>
$$ C'(x) = \frac{1}{c(x)},$$

is a solution of <a href="#mjx-eqn-104">(104)</a> for any
differentiable function \( f \).

<p>
<!-- --- begin solution of exercise --- -->
<b>Solution.</b>
Let \( \xi = C(x) - t \).
We have that
$$ u_t = f'(\xi)(-1),$$

while
$$ u_x = f'(\xi)C'(x) = f'(\xi)\frac{1}{c(x)},$$

implying that \( au_x = f'(\xi) \). Then we have \( u_t + cu_x= -f'(\xi) +
f'(\xi) = 0 \).

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>i)</b>
Use the initial condition to show that an exact solution is

<p>
$$ u(x,t) = I(C^{-1}(C(x)-t)),$$

with \( C^{-1} \) being the inverse function of \( C = \int c^{1}dx \).
Since \( C(x) \) is an integral \( \int_0^x (1/c)dx \),
\( C(x) \) is monotonically increasing and there exists hence an
inverse function \( C^{-1} \) with values in \( [0,L] \).

<p>
<!-- --- begin solution of exercise --- -->
<b>Solution.</b>
In general we have \( u(x,t) = f(C(x)-t) \) and the solution is
of this form with \( f(\xi)=I(C^{-1}(\xi)) \).
Moreover, at \( t=0 \) we have
\( I(C^{-1}(C(x)))=I(x) \), which is the required initial condition.

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>j)</b>
Implement a function for computing \( C(x_i) \) and one for computing
\( C^{-1}(x) \) for any \( x \). Use these two functions for computing
the exact solution \( I(C^{-1}(C(x)-t)) \).
End up with a function <code>u_exact_variable_c(x, n, c, I)</code> that returns
the value of \( I(C^{-1}(C(x)-t_n)) \).

<p>
<b>k)</b>
Make movies showing a comparison of the numerical and exact solutions
for the two initial conditions
<a href="#mjx-eqn-108">(108)</a> and <a href="#mjx-eqn-109">(109)</a>.
Choose \( \Delta t = \Delta x /\max_{0,L} c(x) \)
and the velocity of the medium as

<p>

<ol>
<li> \( c(x) = 1 + \epsilon\sin(k\pi x/L) \), \( \epsilon <1 \),</li>
<li> \( c(x) = 1 + I(x) \), where \( I \) is given by
   <a href="#mjx-eqn-108">(108)</a> or <a href="#mjx-eqn-109">(109)</a>.</li>
</ol>

The PDE \( u_t + cu_x=0 \) expresses that the initial condition \( I(x) \)
is transported with velocity \( c(x) \).

<p>
Filename: <code>advec1D.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- begin bottom navigation -->
<a href="._part0009_main_wave.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

