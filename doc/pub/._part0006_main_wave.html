<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for wave motion">
<meta name="keywords" content="waves on a string,wave equation 1D,wave equation 1D, finite difference method,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,unit testing,software testing nose,vectorization,scalar code,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,stencil Neumann boundary,index set notation,geometric mean,arithmetic mean,harmonic average,averaging geometric,averaging arithmetic,averaging harmonic,wave equation 1D, analytical properties,Fourier series,Fourier transform,discrete Fourier transform,wave equation 1D, exact numerical solution,Courant number,stability criterion,wave equation 1D, stability,wave equation 2D, implementation,index set notation,Cython,declaration of variables in Cython,C extension module,wrapper code,Fortran subroutine,row-major ordering,column-major ordering,Fortran array storage,C/Python array storage,radiation condition,open boundary condition">



<style type="text/css">
    /* blueish style */

    /* Color definitions:  http://www.december.com/html/spec/color0.html
       CSS examples:       http://www.w3schools.com/css/css_examples.asp */

    body {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #000000;
    }
    h1 { font-size: 1.8em; color: #1e36ce; }
    h2 { font-size: 1.5em; color: #1e36ce; }
    h3 { color: #1e36ce; }
    a { color: #1e36ce; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #bababa;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #f8f8f8;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods for waves on a string ',
               1,
               'wave:string',
               'wave:string'),
              (' Discretizing the domain ',
               2,
               'wave:string:mesh',
               'wave:string:mesh'),
              (' Uniform meshes ', 3, None, '___sec2'),
              (' The discrete solution ',
               2,
               'wave:string:numerical:sol',
               'wave:string:numerical:sol'),
              (' Fulfilling the equation at the mesh points ',
               2,
               'wave:string:samplingPDE',
               'wave:string:samplingPDE'),
              (' Replacing derivatives by finite differences ',
               2,
               'wave:string:fd',
               'wave:string:fd'),
              (' Algebraic version of the PDE ', 3, None, '___sec6'),
              (' Algebraic version of the initial conditions ',
               3,
               None,
               '___sec7'),
              (' Formulating a recursive algorithm ',
               2,
               'wave:string:alg',
               'wave:string:alg'),
              (' Sketch of an implementation ',
               2,
               'wave:string:impl',
               'wave:string:impl'),
              (' Verification ', 1, None, '___sec10'),
              (' A slightly generalized model problem ',
               2,
               'wave:pde2:fd',
               'wave:pde2:fd'),
              (' Using an analytical solution of physical significance ',
               2,
               'wave:pde2:fd:standing:waves',
               'wave:pde2:fd:standing:waves'),
              (' Manufactured solution ',
               2,
               'wave:pde2:fd:MMS',
               'wave:pde2:fd:MMS'),
              (' Constructing an exact solution of the discrete equations ',
               2,
               'wave:pde2:fd:verify:quadratic',
               'wave:pde2:fd:verify:quadratic'),
              (' Implementation ', 1, 'wave:pde1:impl', 'wave:pde1:impl'),
              (' Making a solver function ',
               2,
               'wave:pde1:impl:solver',
               'wave:pde1:impl:solver'),
              (' Verification: exact quadratic solution ',
               2,
               'wave:pde1:impl:verify:quadratic',
               'wave:pde1:impl:verify:quadratic'),
              (' Visualization: animating the solution ',
               2,
               'wave:pde1:impl:animate',
               'wave:pde1:impl:animate'),
              (' Visualization via SciTools ', 3, None, '___sec19'),
              (' Making movie files ', 3, None, '___sec20'),
              (' Skipping frames for animation speed ', 3, None, '___sec21'),
              (' Visualization via Matplotlib ', 3, None, '___sec22'),
              (' Running a case ',
               2,
               'wave:pde1:guitar:data',
               'wave:pde1:guitar:data'),
              (' The benefits of scaling ', 2, None, '___sec24'),
              (' Vectorization ',
               1,
               'wave:pde1:impl:vec',
               'wave:pde1:impl:vec'),
              (' Operations on slices of arrays ',
               2,
               'wave:pde1:impl:vec:slices:basics',
               'wave:pde1:impl:vec:slices:basics'),
              (' Finite difference schemes expressed as slices ',
               2,
               'wave:pde1:impl:vec:slices:fdm',
               'wave:pde1:impl:vec:slices:fdm'),
              (' Verification ',
               2,
               'wave:pde1:impl:vec:verify:quadratic',
               'wave:pde1:impl:vec:verify:quadratic'),
              (' Efficiency measurements ', 2, None, '___sec29'),
              (' Exercises ', 1, None, '___sec30'),
              (' Exercise 1: Simulate a standing wave ',
               2,
               'wave:exer:standingwave',
               'wave:exer:standingwave'),
              (' Exercise 2: Add storage of solution in a user action function ',
               2,
               'wave:exer:store:list',
               'wave:exer:store:list'),
              (' Exercise 3: Use a class for the user action function ',
               2,
               'wave:exer:store:list:class',
               'wave:exer:store:list:class'),
              (' Exercise 4: Compare several Courant numbers in one movie ',
               2,
               'wave:exer:multiple:C',
               'wave:exer:multiple:C'),
              (' Project 5: Calculus with 1D mesh functions ',
               2,
               'wave:exer:mesh1D:calculus',
               'wave:exer:mesh1D:calculus'),
              (' Generalization: reflecting boundaries ',
               1,
               'wave:pde2:Neumann',
               'wave:pde2:Neumann'),
              (' Neumann boundary condition ',
               2,
               'wave:pde2:Neumann:bc',
               'wave:pde2:Neumann:bc'),
              (' Discretization of derivatives at the boundary ',
               2,
               'wave:pde2:Neumann:discr',
               'wave:pde2:Neumann:discr'),
              (' Implementation of Neumann conditions ',
               2,
               'wave:pde2:Neumann:impl',
               'wave:pde2:Neumann:impl'),
              (' Index set notation ', 2, 'wave:indexset', 'wave:indexset'),
              (' Alternative implementation via ghost cells ',
               2,
               'wave:pde1:Neumann:ghost',
               'wave:pde1:Neumann:ghost'),
              (' Idea ', 3, None, '___sec42'),
              (' Implementation ', 3, None, '___sec43'),
              (' Generalization: variable wave velocity ',
               1,
               'wave:pde2:var:c',
               'wave:pde2:var:c'),
              (' The model PDE with a variable coefficient ',
               2,
               None,
               '___sec45'),
              (' Discretizing the variable coefficient ',
               2,
               'wave:pde2:var:c:ideas',
               'wave:pde2:var:c:ideas'),
              (' Computing the coefficient between mesh points ',
               2,
               'wave:pde2:var:c:means',
               'wave:pde2:var:c:means'),
              (' How a variable coefficient affects the stability ',
               2,
               'wave:pde2:var:c:stability',
               'wave:pde2:var:c:stability'),
              (' Neumann condition and a variable coefficient ',
               2,
               'wave:pde2:var:c:Neumann',
               'wave:pde2:var:c:Neumann'),
              (' Implementation of variable coefficients ',
               2,
               'wave:pde2:var:c:impl',
               'wave:pde2:var:c:impl'),
              (' A more general model PDE with variable coefficients ',
               2,
               None,
               '___sec51'),
              (' Generalization: damping ', 2, None, '___sec52'),
              (' Building a general 1D wave equation solver ',
               1,
               'wave:pde2:software',
               'wave:pde2:software'),
              (' User action function as a class ', 2, None, '___sec54'),
              (' Pulse propagation in two media ', 2, None, '___sec55'),
              (' Exercises ', 1, None, '___sec56'),
              (' Exercise 6: Find the analytical solution to a damped wave equation ',
               2,
               'wave:exer:standingwave:damped:uex',
               'wave:exer:standingwave:damped:uex'),
              (' Problem 7: Explore symmetry boundary conditions ',
               2,
               'wave:exer:symmetry:bc',
               'wave:exer:symmetry:bc'),
              (' Exercise 8: Send pulse waves through a layered medium ',
               2,
               'wave:app:exer:pulse1D',
               'wave:app:exer:pulse1D'),
              (' Exercise 9: Compare discretizations of a Neumann condition ',
               2,
               None,
               '___sec60'),
              (' Analysis of the difference equations ',
               1,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Properties of the solution of the wave equation ',
               2,
               'wave:pde1:properties',
               'wave:pde1:properties'),
              (' More precise definition of Fourier representations ',
               2,
               'wave:pde1:Fourier',
               'wave:pde1:Fourier'),
              (' Analysis of the finite difference scheme ',
               2,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Preliminary results ', 3, None, '___sec65'),
              (' Numerical wave propagation ', 3, None, '___sec66'),
              (' Numerical dispersion relation ', 3, None, '___sec67'),
              (' Extending the analysis to 2D and 3D ',
               2,
               'wave:pde1:analysis:2D3D',
               'wave:pde1:analysis:2D3D'),
              (' Finite difference methods for 2D and 3D wave equations ',
               1,
               'wave:2D3D',
               'wave:2D3D'),
              (' Multi-dimensional wave equations ',
               2,
               'wave:2D3D:models',
               'wave:2D3D:models'),
              (' Mesh ', 2, 'wave:2D3D:mesh', 'wave:2D3D:mesh'),
              (' Discretization ', 2, 'wave:2D3D:models', 'wave:2D3D:models'),
              (' Discretizing the PDEs ', 3, None, '___sec73'),
              (' Handling boundary conditions where is $u$ known ',
               3,
               None,
               '___sec74'),
              (' Discretizing the Neumann condition ', 3, None, '___sec75'),
              (' Implementation ', 1, 'wave:2D3D:impl', 'wave:2D3D:impl'),
              (' Scalar computations ',
               2,
               'wave2D3D:impl:scalar',
               'wave2D3D:impl:scalar'),
              (' Domain and mesh ', 3, None, '___sec78'),
              (' Solution arrays ', 3, None, '___sec79'),
              (' Index sets ', 3, None, '___sec80'),
              (' Computing the solution ', 3, None, '___sec81'),
              (' Vectorized computations ',
               2,
               'wave2D3D:impl:vectorized',
               'wave2D3D:impl:vectorized'),
              (' Verification ',
               2,
               'wave2D3D:impl:verify',
               'wave2D3D:impl:verify'),
              (' Testing a quadratic solution ', 3, None, '___sec84'),
              (' Migrating loops to Cython ',
               1,
               'wave2D3D:impl:Cython',
               'wave2D3D:impl:Cython'),
              (' Declaring variables and annotating the code ',
               2,
               None,
               '___sec86'),
              (' Visual inspection of the C translation ',
               2,
               None,
               '___sec87'),
              (' Building the extension module ', 3, None, '___sec88'),
              (' Calling the Cython function ', 2, None, '___sec89'),
              (' Efficiency ', 3, None, '___sec90'),
              (' Migrating loops to Fortran ', 1, None, '___sec91'),
              (' The Fortran subroutine ', 2, None, '___sec92'),
              (' Building the Fortran module with f2py ',
               3,
               None,
               '___sec93'),
              (' How to avoid array copying ', 2, None, '___sec94'),
              (' Efficiency ', 3, None, '___sec95'),
              (' Migrating loops to C via Cython ', 1, None, '___sec96'),
              (' Translating index pairs to single indices ',
               2,
               None,
               '___sec97'),
              (' The complete C code ', 2, None, '___sec98'),
              (' The Cython interface file ', 2, None, '___sec99'),
              (' Building the extension module ', 2, None, '___sec100'),
              (' Efficiency ', 3, None, '___sec101'),
              (' Migrating loops to C via f2py ', 1, None, '___sec102'),
              (' Migrating loops to C++ via f2py ', 2, None, '___sec103'),
              (' Using classes to implement a simulator ',
               1,
               None,
               '___sec104'),
              (' Exercises ', 1, None, '___sec105'),
              (' Exercise 10: Check that a solution fulfills the discrete model ',
               2,
               'wave:exer:quadratic:2D',
               'wave:exer:quadratic:2D'),
              (' Project 11: Calculus with 2D/3D mesh functions ',
               2,
               'wave:exer:mesh3D:calculus',
               'wave:exer:mesh3D:calculus'),
              (' Exercise 12: Implement Neumann conditions in 2D ',
               2,
               'wave:app:exer:wave2D:Neumann',
               'wave:app:exer:wave2D:Neumann'),
              (' Exercise 13: Test the efficiency of compiled loops in 3D ',
               2,
               'wave:exer:3D:f77:cy:efficiency',
               'wave:exer:3D:f77:cy:efficiency'),
              (' Applications of wave equations ', 1, 'wave:app', 'wave:app'),
              (' Waves on a string ',
               2,
               'wave:app:string',
               'wave:app:string'),
              (' Damping ', 3, None, '___sec112'),
              (' External forcing ', 3, None, '___sec113'),
              (' Modeling the tension via springs ', 3, None, '___sec114'),
              (' Waves on a membrane ',
               2,
               'wave:app:membrane',
               'wave:app:membrane'),
              (' Elastic waves in a rod ',
               2,
               'wave:app:elastic:rod',
               'wave:app:elastic:rod'),
              (' The acoustic model for seismic waves ',
               2,
               'wave:app:acoustic:seismic',
               'wave:app:acoustic:seismic'),
              (' Anisotropy ', 3, None, '___sec118'),
              (' Sound waves in liquids and gases ',
               2,
               'wave:app:sound',
               'wave:app:sound'),
              (' Spherical waves ',
               2,
               'wave:app:spherical',
               'wave:app:spherical'),
              (' The linear shallow water equations ',
               2,
               'wave:app:sw:2D',
               'wave:app:sw:2D'),
              (' Wind drag on the surface ', 3, None, '___sec122'),
              (' Bottom drag ', 3, None, '___sec123'),
              (" Effect of the Earth's rotation ", 3, None, '___sec124'),
              (' Waves in blood vessels ',
               2,
               'wave:app:blood',
               'wave:app:blood'),
              (' Electromagnetic waves ',
               2,
               'wave:app:light',
               'wave:app:light'),
              (' Exercises ', 1, 'wave:app:exer', 'wave:app:exer'),
              (' Exercise 14: Simulate waves on a non-homogeneous string ',
               2,
               'wave:app:exer:string:discont',
               'wave:app:exer:string:discont'),
              (' Exercise 15: Simulate damped waves on a string ',
               2,
               'wave:app:exer:string:damping',
               'wave:app:exer:string:damping'),
              (' Exercise 16: Simulate elastic waves in a rod ',
               2,
               'wave:app:exer:rod',
               'wave:app:exer:rod'),
              (' Exercise 17: Simulate spherical waves ',
               2,
               'wave:app:exer:spherical',
               'wave:app:exer:spherical'),
              (' Exercise 18: Explain why numerical noise occurs ',
               2,
               'wave:app:exer:pulse1D:analysis',
               'wave:app:exer:pulse1D:analysis'),
              (' Exercise 19: Investigate harmonic averaging in a 1D model ',
               2,
               'wave:app:exer:pulse1D:harmonic',
               'wave:app:exer:pulse1D:harmonic'),
              (' Problem 20: Implement open boundary conditions ',
               2,
               'wave:app:exer:radiationBC',
               'wave:app:exer:radiationBC'),
              (' Problem 21: Earthquake-generated tsunami over a subsea hill ',
               2,
               'wave:app:exer:tsunami1D:hill',
               'wave:app:exer:tsunami1D:hill'),
              (' Problem 22: Earthquake-generated tsunami over a 3D hill ',
               2,
               'wave:app:exer:tsunami2D:hill',
               'wave:app:exer:tsunami2D:hill'),
              (' Problem 23: Investigate Matplotlib for visualization ',
               2,
               'wave:app:exer:tsunami:hill:viz:matplotlib',
               'wave:app:exer:tsunami:hill:viz:matplotlib'),
              (' Problem 24: Investigate visualization packages ',
               2,
               'wave:app:exer:tsunami:hill:viz:packages',
               'wave:app:exer:tsunami:hill:viz:packages'),
              (' Problem 25: Implement loops in compiled languages ',
               2,
               'wave:app:exer:tsunami2D:hill:compiled',
               'wave:app:exer:tsunami2D:hill:compiled'),
              (' Exercise 26: Simulate seismic waves in 2D ',
               2,
               'wave:app:exer:seismic2D',
               'wave:app:exer:seismic2D'),
              (' Project 27: Model 3D acoustic waves in a room ',
               2,
               'wave:app:exer:acoustics',
               'wave:app:exer:acoustics'),
              (' Project 28: Solve a 1D transport equation ',
               2,
               'wave:app:exer:advec1D',
               'wave:app:exer:advec1D')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0006"></a>
<!-- begin top navigation -->
<a href="._part0005_main_wave.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0007_main_wave.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end top navigation -->

<p>
<!-- !split -->

<h2>Implementation <a name="wave:2D3D:impl"></a></h2>

<p>
We shall now describe in detail various Python implementations
for solving a standard 2D, linear wave equation with constant
wave velocity and \( u=0 \) on the
boundary. The wave equation is to be solved
in the space-time domain \( \Omega\times (0,T] \),
where \( \Omega = [0,L_x]\times [0,L_y] \) is a rectangular spatial
domain. More precisely,
the complete initial-boundary value problem is defined by

<p>
$$
\begin{align}
u_t &= c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad (x,y)\in \Omega,\ t\in (0,T],\\ 
u(x,y,0) &= I(x,y),\quad (x,y)\in\Omega,\\ 
u_t(x,y,0) &= V(x,y),\quad (x,y)\in\Omega,\\ 
u &= 0,\quad (x,y)\in\partial\Omega,\ t\in (0,T],
\end{align}
$$

where \( \partial\Omega \) is the boundary of \( \Omega \), in this case
the four sides of the rectangle \( [0,L_x]\times [0,L_y] \):
\( x=0 \), \( x=L_x \), \( y=0 \), and \( y=L_y \).

<p>
The PDE is discretized as
$$ [D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j},
$$

which leads to an explicit updating formula to be implemented in a
program:

<p>
$$
\begin{align}
u^{n+1} = -u^{n-1}_{i,j} + 2u^n_{i,j} + \nonumber\\ 
&\quad C_x^2(
u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}) + C_y^2
(u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}) + \Delta t^2 f_{i,j}^n,
\tag{66}
\end{align}
$$

for all interior mesh points \( i\in\seti{\Ix} \) and
\( j\in\seti{\Iy} \), and for \( n\in\setr{\It} \).
The constants \( C_x \) and \( C_y \) are defined as
$$ C_x = c\frac{\Delta t}{\Delta x},\quad C_x = c\frac{\Delta t}{\Delta y}
\thinspace .
$$


<p>
At the boundary we simply set \( u^{n+1}_{i,j}=0 \) for
\( i=0 \), \( j=0,\ldots,N_y \); \( i=N_x \), \( j=0,\ldots,N_y \);
\( j=0 \), \( i=0,\ldots,N_x \); and \( j=N_y \), \( i=0,\ldots,N_x \).
For the first step, \( n=0 \), <a href="#mjx-eqn-66">(66)</a>
is combined with the discretization of the initial condition \( u_t=V \),
\( [D_{2t} u = V]^0_{i,j} \) to obtain a special formula for
\( u^1_{i,j} \) at the interior mesh points:

<p>
$$
\begin{align}
u^{1} = u^0_{i,j} + \Delta t V_{i,j} + \nonumber\\ 
&\quad \frac{1}{2}C_x^2(
u^{0}_{i+1,j} - 2u^{0}_{i,j} + u^{0}_{i-1,j}) + \frac{1}{2}C_y^2
(u^{0}_{i,j+1} - 2u^{0}_{i,j} + u^{0}_{i,j-1}) + \frac{1}{2}\Delta t^2f_{i,j}^n,
\tag{66}
\end{align}
$$

<h3>Scalar computations <a name="wave2D3D:impl:scalar"></a></h3>

<p>
The <code>solver</code> function for a 2D case with constant wave velocity and
\( u=0 \) as boundary condition follows the setup from the similar
function for the 1D case in <code>wave1D_u0_s.py</code>, but there are
a few necessary extensions. The code is in the program
<a href="/wave2D_u0/wave2D_u0.py"><tt>wave2D_u0.py</tt></a>.

<h4>Domain and mesh  <a name="___sec78"></a></h4>

<p>
The spatial domain is now \( [0,L_x]\times [0,L_y] \), specified
by the arguments <code>Lx</code> and <code>Ly</code>. Similarly, the number of mesh
points in the \( x \) and \( y \) directions,
\( N_x \) and \( N_y \), become the arguments <code>Nx</code> and <code>Ny</code>.
In multi-dimensional problems it makes less sense to specify a
Courant number as the wave velocity is a vector and the mesh spacings
may differ in the various spatial directions.
We therefore give \( \Delta t \) explicitly. The signature of
the <code>solver</code> function is then

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, V, f, c, Lx, Ly, Nx, Ny, dt, T,
           user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;scalar&#39;</span>):
</pre></div>
<p>
Key parameters used in the calculations are created as
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, Lx, Nx<span style="color: #666666">+1</span>)                  <span style="color: #408080; font-style: italic"># mesh points in x dir</span>
y <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, Ly, Ny<span style="color: #666666">+1</span>)                  <span style="color: #408080; font-style: italic"># mesh points in y dir</span>
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
dy <span style="color: #666666">=</span> y[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> y[<span style="color: #666666">0</span>]
Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, N<span style="color: #666666">*</span>dt, N<span style="color: #666666">+1</span>)                 <span style="color: #408080; font-style: italic"># mesh points in time</span>
Cx2 <span style="color: #666666">=</span> (c<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dx)<span style="color: #666666">**2</span>;  Cy2 <span style="color: #666666">=</span> (c<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dy)<span style="color: #666666">**2</span>    <span style="color: #408080; font-style: italic"># help variables</span>
dt2 <span style="color: #666666">=</span> dt<span style="color: #666666">**2</span>
</pre></div>

<h4>Solution arrays  <a name="___sec79"></a></h4>

<p>
We store \( u^{n+1}_{i,j} \), \( u^{n}_{i,j} \), and
\( u^{n-1}_{i,j} \) in three two-dimensional arrays,

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u   <span style="color: #666666">=</span> zeros((Nx<span style="color: #666666">+1</span>,Ny<span style="color: #666666">+1</span>))   <span style="color: #408080; font-style: italic"># solution array</span>
u_1 <span style="color: #666666">=</span> zeros((Nx<span style="color: #666666">+1</span>,Ny<span style="color: #666666">+1</span>))   <span style="color: #408080; font-style: italic"># solution at t-dt</span>
u_2 <span style="color: #666666">=</span> zeros((Nx<span style="color: #666666">+1</span>,Ny<span style="color: #666666">+1</span>))   <span style="color: #408080; font-style: italic"># solution at t-2*dt</span>
</pre></div>
<p>
where \( u^{n+1}_{i,j} \) corresponds to <code>u[i,j]</code>,
\( u^{n}_{i,j} \) to <code>u_1[i,j]</code>, and
\( u^{n-1}_{i,j} \) to <code>u_2[i,j]</code>

<h4>Index sets  <a name="___sec80"></a></h4>

<p>
It is also convenient to introduce the index sets (cf. The section <a href="._part0003_main_wave.html#wave:indexset">Index set notation</a>)

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Ix <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, u<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>])
Iy <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, u<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>])
It <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, t<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>])
</pre></div>

<h4>Computing the solution  <a name="___sec81"></a></h4>

<p>
Inserting the initial
condition <code>I</code> in <code>u_1</code> and making a callback to the user in terms of
the <code>user_action</code> function is a straightforward generalization of
the 1D code from the section <a href="._part0001_main_wave.html#wave:string:impl">Sketch of an implementation</a>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy:
        u_1[i,j] <span style="color: #666666">=</span> I(x[i], y[j])

<span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
    user_action(u_1, x, xv, y, yv, t, <span style="color: #666666">0</span>)
</pre></div>
<p>
The <code>user_action</code> function has additional arguments compared to the
1D case. The arguments <code>xv</code> and <code>yv</code> fact will be commented
upon in the section <a href="#wave2D3D:impl:vectorized">Vectorized computations</a>.

<p>
The key finite difference formula <a href="._part0005_main_wave.html#mjx-eqn-63">(63)</a>
for updating the solution at
a time level is implemented in a separate function as

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">advance_scalar</span>(u, u_1, u_2, f, x, y, t,
                   n, Cx2, Cy2, dt2, D1<span style="color: #666666">=2</span>, D2<span style="color: #666666">=1</span>):
    Ix <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, u<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]);  Iy <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, u<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>])
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
            u_xx <span style="color: #666666">=</span> u_1[i<span style="color: #666666">-1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>,j]
            u_yy <span style="color: #666666">=</span> u_1[i,j<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i,j<span style="color: #666666">+1</span>]
            u[i,j] <span style="color: #666666">=</span> D1<span style="color: #666666">*</span>u_1[i,j] <span style="color: #666666">-</span> D2<span style="color: #666666">*</span>u_2[i,j] <span style="color: #666666">+</span> \ 
                     Cx2<span style="color: #666666">*</span>u_xx <span style="color: #666666">+</span> Cy2<span style="color: #666666">*</span>u_yy <span style="color: #666666">+</span> dt2<span style="color: #666666">*</span>f(x[i], y[j], t[n])
    <span style="color: #408080; font-style: italic"># Boundary condition u=0</span>
    j <span style="color: #666666">=</span> Iy[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix: u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    j <span style="color: #666666">=</span> Iy[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix: u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    i <span style="color: #666666">=</span> Ix[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy: u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    i <span style="color: #666666">=</span> Ix[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy: u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
The constants <code>D1</code> and <code>D2</code> in front of <code>u_1</code> and <code>u_2</code> have been
introduced to allow this <code>advance_scalar</code> function to also be used for the
first step \( u^1_{i,j} \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> advance_scalar(u, u_1, u_2, f, x, y, t,
                   n, <span style="color: #666666">0.5*</span>Cx2, <span style="color: #666666">0.5*</span>Cy2, <span style="color: #666666">0.5*</span>dt2, D1<span style="color: #666666">=1</span>, D2<span style="color: #666666">=0</span>)
</pre></div>
<p>
The special formula for the first step \( u^1_{i,j} \),
given by <a href="._part0005_main_wave.html#mjx-eqn-64">(64)</a>, is implemented
in a very similar manner.

<p>
Below, we will make many alternative implementations of the
<code>advance_scalar</code> function to speed up the code since most of
the CPU time in simulations is spent in this function.

<h3>Vectorized computations <a name="wave2D3D:impl:vectorized"></a></h3>

<p>
The scalar code above turns out to be extremely slow for large 2D
meshes, and probably useless in 3D beyond debugging of small test cases.
Vectorization is therefore a must for multi-dimensional
finite difference computations in Python. For example,
with a mesh consisting of \( 30\times 30 \) cells, vectorization
brings down the CPU time by a factor of 70 (!).

<p>
In the vectorized case we must be able to evaluate user-given functions
like \( I(x,y) \) and \( f(x,y,t) \), provided as Python functions <code>I(x,y)</code>
and <code>f(x,y,t)</code>, for the entire mesh in one array operation.
Having the one-dimensional coordinate arrays <code>x</code> and <code>y</code> is not
sufficient: these must be extended to vectorized versions,

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> newaxis
xv <span style="color: #666666">=</span> x[:,newaxis]
yv <span style="color: #666666">=</span> y[newaxis,:]
<span style="color: #408080; font-style: italic"># or</span>
xv <span style="color: #666666">=</span> x<span style="color: #666666">.</span>reshape((x<span style="color: #666666">.</span>size, <span style="color: #666666">1</span>))
yv <span style="color: #666666">=</span> y<span style="color: #666666">.</span>reshape((<span style="color: #666666">1</span>, y<span style="color: #666666">.</span>size))
</pre></div>
<p>
This is a standard required technique when evaluating functions over
a 2D mesh, say <code>sin(xv)*cos(xv)</code>, which then gives a result with shape
<code>(Nx+1,Ny+1)</code>.

<p>
With the <code>xv</code> and <code>yv</code> arrays for vectorized computing,
setting the initial condition is just a matter of

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u_1[:,:] <span style="color: #666666">=</span> I(xv, yv)
</pre></div>
<p>
One could also have written <code>u_1 = I(xv, yv)</code> and let <code>u_1</code> point
to a new object, but vectorized operations often makes use of
direct insertion in the original array through <code>u_1[:,:]</code> because
sometimes not all of the array is to be filled by such a function
evaluation. This is the case with the computational scheme for \( u^{n+1}_{i,j} \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">advance_vectorized</span>(u, u_1, u_2, f_a, Cx2, Cy2, dt2, D1<span style="color: #666666">=2</span>, D2<span style="color: #666666">=1</span>):
    u_xx <span style="color: #666666">=</span> u_1[:<span style="color: #666666">-2</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_1[<span style="color: #666666">2</span>:,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
    u_yy <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,:<span style="color: #666666">-2</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>:]
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> D1<span style="color: #666666">*</span>u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> D2<span style="color: #666666">*</span>u_2[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> \ 
                   Cx2<span style="color: #666666">*</span>u_xx <span style="color: #666666">+</span> Cy2<span style="color: #666666">*</span>u_yy <span style="color: #666666">+</span> dt2<span style="color: #666666">*</span>f_a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
    <span style="color: #408080; font-style: italic"># Boundary condition u=0</span>
    j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u[:,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    j <span style="color: #666666">=</span> u<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]<span style="color: #666666">-1</span>
    u[:,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    i <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u[i,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    i <span style="color: #666666">=</span> u<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]<span style="color: #666666">-1</span>
    u[i,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
Array slices in 2D are more complicated to understand than those in
1D, but the logic from 1D applies to each dimension separately.
For example, when doing \( u^{n}_{i,j} - u^{n}_{i-1,j} \) for \( i\in\setr{\Ix} \),
we just keep <code>j</code> constant and make a slice in the first index:
<code>u_1[1:,j] - u_1[:-1,j]</code>, exactly as in 1D. The <code>1:</code> slice
specifies all the indices \( i=1,2,\ldots,N_x \) (up to the last
valid index),
while <code>:-1</code> specifies the relevant indices for the second term:
\( 0,1,\ldots,N_x-1 \) (up to, but not including the last index).

<p>
In the above code segment, the situation is slightly more complicated,
because each displaced slice in one direction is
accompanied by a <code>1:-1</code> slice in the other direction. The reason is
that we only work with the internal points for the index that is
kept constant in a difference.

<p>
The <code>f</code> function is in the above vectorized update of <code>u</code> first computed
as an array over all mesh points:
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f_a = f(xv, yv, t[n])
</pre></div>
<p>
We could, alternatively, used the call <code>f(xv, yv, t[n])[1:-1,1:-1]</code>
in the last term of the update statement, but other implementations
in compiled languages benefit from having <code>f</code> available in an array
rather than calling our Python function <code>f(x,y,t)</code> for
every point.

<p>
The boundary conditions along the four sides makes use of
a slice consisting of all indices along a boundary:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[: ,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
u[:,Ny] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
u[<span style="color: #666666">0</span> ,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
u[Nx,:] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
</pre></div>
<p>
The shown snippets appear in a function <code>advance_vectorized</code>.

<p>
The callback function now has the arguments
<code>u, x, xv, y, yv, t, n</code>. The inclusion of <code>xv</code> and <code>yv</code> makes it
easy to, e.g., compute an exact 2D solution in the callback function
and compute errors, through an expression like
<code>u - exact_solution(xv, yv, t[n])</code>.

<h3>Verification <a name="wave2D3D:impl:verify"></a></h3>

<h4>Testing a quadratic solution  <a name="___sec84"></a></h4>

<p>
The 1D solution from the section <a href="._part0001_main_wave.html#wave:pde2:fd:verify:quadratic">Constructing an exact solution of the discrete equations</a> can be
generalized to multi-dimensions and provides a test case where the
exact solution also fulfills the discrete equations such that we know
(to machine precision) what numbers the solver function should
produce. In 2D we use the following generalization of
<a href="._part0001_main_wave.html#mjx-eqn-21">(21)</a>:

<p>
$$
\begin{equation}
\uex(x,y,t) = x(L_x-x)y(L_y-y)(1+\frac{1}{2}t)
\thinspace .
\tag{67}
\end{equation}
$$

This solution fulfills the PDE problem if \( I(x,y)=\uex(x,y,0) \),
\( V=\frac{1}{2}\uex(x,y,0) \), and \( f=2c^2(1+\frac{1}{2}t)(y(L_y-y) +
x(L_x-x)) \). To show that \( \uex \) also solves the discrete equations,
we start with the general results \( [D_t D_t t]^n=0 \)
and \( [D_t D_t t^2]=2 \), and use these to compute

<p>
$$ [D_xD_x \uex]^n_{i,j} = [y(L_y-y)(1+\frac{1}{2}t) D_xD_x x(L_x-x)]^n_{i,j}
= y_j(L_y-y_j)(1+\frac{1}{2}t_n)2\ts
$$

A similar calculation must be carried out for the \( [D_yD_y
\uex]^n_{i,j} \) and \( [D_tD_t \uex]^n_{i,j} \) terms.  One must also show
that the quadratic solution fits the special formula for
\( u^1_{i,j} \). The details are left as <a href="#wave:exer:quadratic:2D">Exercise 10: Check that a solution fulfills the discrete model</a>.
The <code>test_quadratic</code> function in the
<a href="http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0.py"><tt>wave2D_u0.py</tt></a>
program implements this verification as a nose test.

<h2>Migrating loops to Cython <a name="wave2D3D:impl:Cython"></a></h2>

<p>
Although vectorization can bring down the CPU time dramatically
compared with scalar code, there is still some factor 5-10 to win
in these types of applications
by implementing the finite difference scheme in compiled code,
typically in Fortran, C, or C++. This can quite easily be done by
adding a little extra code to our program. Cython is an extension of
Python that offers the easiest way to nail our Python loops in the
scalar code down to machine code and the efficiency of C.

<p>
Cython can be viewed as an extended Python language where variables are
declared with types and where functions are marked to be implemented in C.
Migrating Python code to Cython is done by copying the desired code
segments to functions (or classes) and placing them in one or more separate
files with extension <code>.pyx</code>.

<h3>Declaring variables and annotating the code  <a name="___sec86"></a></h3>

<p>
Our starting point is the plain <code>advance_scalar</code> function for a scalar
implementation of the updating algorithm for new values
\( u^{n+1}_{i,j} \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">advance_scalar</span>(u, u_1, u_2, f, x, y, t,
                   n, Cx2, Cy2, dt2, D1<span style="color: #666666">=2</span>, D2<span style="color: #666666">=1</span>):
    Ix <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, u<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]);  Iy <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, u<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>])
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
            u_xx <span style="color: #666666">=</span> u_1[i<span style="color: #666666">-1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>,j]
            u_yy <span style="color: #666666">=</span> u_1[i,j<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i,j<span style="color: #666666">+1</span>]
            u[i,j] <span style="color: #666666">=</span> D1<span style="color: #666666">*</span>u_1[i,j] <span style="color: #666666">-</span> D2<span style="color: #666666">*</span>u_2[i,j] <span style="color: #666666">+</span> \ 
                     Cx2<span style="color: #666666">*</span>u_xx <span style="color: #666666">+</span> Cy2<span style="color: #666666">*</span>u_yy <span style="color: #666666">+</span> dt2<span style="color: #666666">*</span>f(x[i], y[j], t[n])
    <span style="color: #408080; font-style: italic"># Boundary condition u=0</span>
    j <span style="color: #666666">=</span> Iy[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix: u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    j <span style="color: #666666">=</span> Iy[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix: u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    i <span style="color: #666666">=</span> Ix[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy: u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    i <span style="color: #666666">=</span> Ix[<span style="color: #666666">-1</span>]
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy: u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
We simply take
a copy of this function and put it in a file <code>wave2D_u0_loop_cy.pyx</code>.
The relevant Cython implementation arises from declaring variables with
types and adding some important annotations to speed up array
computing in Cython. Let us first list the complete code in the
<code>.pyx</code> file:

<p>

<!-- code=cython (from !bc cypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">cimport</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">cimport</span> <span style="color: #0000FF; font-weight: bold">cython</span>
<span style="color: #008000; font-weight: bold">ctypedef</span> np<span style="color: #666666">.</span>float64_t DT    <span style="color: #408080; font-style: italic"># data type</span>

<span style="color: #AA22FF">@cython</span><span style="color: #666666">.</span>boundscheck(<span style="color: #008000">False</span>)  <span style="color: #408080; font-style: italic"># turn off array bounds check</span>
<span style="color: #AA22FF">@cython</span><span style="color: #666666">.</span>wraparound(<span style="color: #008000">False</span>)   <span style="color: #408080; font-style: italic"># turn off negative indices (u[-1,-1])</span>
<span style="color: #008000; font-weight: bold">cpdef</span> <span style="color: #0000FF">advance</span>(
    np<span style="color: #666666">.</span>ndarray[DT, ndim<span style="color: #666666">=2</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>] u,
    np<span style="color: #666666">.</span>ndarray[DT, ndim<span style="color: #666666">=2</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>] u_1,
    np<span style="color: #666666">.</span>ndarray[DT, ndim<span style="color: #666666">=2</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>] u_2,
    np<span style="color: #666666">.</span>ndarray[DT, ndim<span style="color: #666666">=2</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>] f,
    double Cx2, double Cy2, double dt2):

    <span style="color: #008000; font-weight: bold">cdef</span> <span style="color: #B00040">int</span> <span style="color: #0000FF">Nx</span>, <span style="color: #0000FF">Ny</span>, <span style="color: #0000FF">i</span>, <span style="color: #0000FF">j</span>
    Nx <span style="color: #666666">=</span> u<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]<span style="color: #666666">-1</span>
    Ny <span style="color: #666666">=</span> u<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]<span style="color: #666666">-1</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(<span style="color: #666666">1</span>, Nx):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">xrange</span>(<span style="color: #666666">1</span>, Ny):
            u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">-</span> u_2[i,j] <span style="color: #666666">+</span> \
            Cx2<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>,j]) <span style="color: #666666">+</span> \
            Cy2<span style="color: #666666">*</span>(u_1[i,j<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i,j<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \
            dt2<span style="color: #666666">*</span>f[i,j]
    <span style="color: #408080; font-style: italic"># Boundary condition u=0</span>
    j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>): u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    j <span style="color: #666666">=</span> Ny
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>): u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    i <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Ny<span style="color: #666666">+1</span>): u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    i <span style="color: #666666">=</span> Nx
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Ny<span style="color: #666666">+1</span>): u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
This example may act as a recipe on how to transform array-intensive
code with loops into Cython.

<p>

<ol>
<li> Variables are declared with types: for example,
   <code>double v</code> in the argument list instead of just <code>v</code>, and <code>cdef double v</code>
   for a variable <code>v</code> in the body of the function.
   A Python <code>float</code> object is declared as <code>double</code> for
   translation to C by Cython, while an <code>int</code> object is
   declared by <code>int</code>.</li>
<li> Arrays need a comprehensive type declaration involving</li>

<ul>
   <li> the type <code>np.ndarray</code>,</li>
   <li> the data type of the elements, here 64-bit floats,
     abbreviated as <code>DT</code> through <code>ctypedef np.float64_t DT</code>
     (instead of <code>DT</code> we could use the full name of the
     data type: <code>np.float64_t</code>, which is a Cython-defined type),</li>
   <li> the dimensions of the array, here <code>ndim=2</code> and <code>ndim=1</code>,</li>
   <li> specification of contiguous memory for the array (<code>mode='c'</code>).</li>
</ul>

<li> Functions declared with <code>cpdef</code> are translated to C but also
   accessible from Python.</li>
<li> In addition to the standard <code>numpy</code> import we also need a special
   Cython import of <code>numpy</code>: <code>cimport numpy as np</code>, to appear <em>after</em>
   the standard import.</li>
<li> By default, array indices are checked to be within their legal
   limits. To speed up the code one should turn off this feature
   for a specific function by placing <code>@cython.boundscheck(False)</code>
   above the function header.</li>
<li> Also by default, array indices can be negative (counting from the
   end), but this feature has a performance penalty and is therefore
   here turned off by writing <code>@cython.wraparound(False)</code> right above
   the function header.</li>
</ol>

<h3>Visual inspection of the C translation  <a name="___sec87"></a></h3>

<p>
Cython can visually explain how successfully it can translate a code from
Python to C. The command

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; cython -a wave2D_u0_loop_cy.pyx
</pre></div>
<p>
produces an HTML file <code>wave2D_u0_loop_cy.html</code>, which can be loaded into
a web browser to illustrate which lines of the code that have been
translated to C. Figure <a href="#wave:2D3D:impl:fig:cython:ma1">8</a> shows
the illustrated code. Yellow lines indicate the lines that Cython did not manage
to translate to efficient C code and that remain in Python.
For the present code we see that Cython is able to translate all the
loops with array computing to C, which is our primary goal.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Visual illustration of Cython's ability to translate Python to C. <a name="wave:2D3D:impl:fig:cython:ma1"></a> </p></center>
<p><img src="fig-wave/wave2D_u0_loop_cy1.png" align="bottom" width=500,></p>
</center>

<p>
You can also inspect the generated C code directly, as it appears
in the file <code>wave2D_u0_loop_cy.c</code>. Nevertheless,
understanding this C code requires some
familiarity with writing Python extension modules in C by hand.
Deep down in the file we can see in detail how the compute-intensive
statements are translated some complex C code that is quite different from
what we a human would write (at least if a direct correspondence to
the mathematics was in mind).

<h4>Building the extension module  <a name="___sec88"></a></h4>

<p>
Cython code must be translated to C, compiled, and linked to form what
is known in the Python world as a <em>C extension module</em>.
This is usually done by making a <code>setup.py</code> script, which
is the standard way of building and installing Python software.
For an extension module arising from Cython code, the following
<code>setup.py</code> script is all we need to build and install the module:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">distutils.core</span> <span style="color: #008000; font-weight: bold">import</span> setup
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">distutils.extension</span> <span style="color: #008000; font-weight: bold">import</span> Extension
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">Cython.Distutils</span> <span style="color: #008000; font-weight: bold">import</span> build_ext

cymodule <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;wave2D_u0_loop_cy&#39;</span>
setup(
  name<span style="color: #666666">=</span>cymodule
  ext_modules<span style="color: #666666">=</span>[Extension(cymodule, [cymodule <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.pyx&#39;</span>],)],
  cmdclass<span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;build_ext&#39;</span>: build_ext},
)
</pre></div>
<p>
We run the script by
run

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python setup.py build_ext --inplace
</pre></div>
<p>
The <code>--inplace</code> option makes the extension module available in the
current directory as the file <code>wave2D_u0_loop_cy.so</code>. This
file acts as a normal Python module that can be imported and inspected:

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; import wave2D_u0_loop_cy
&gt;&gt;&gt; dir(wave2D_u0_loop_cy)
[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;,
 &#39;__package__&#39;, &#39;__test__&#39;, &#39;advance&#39;, &#39;np&#39;]
</pre></div>
<p>
The important output from the <code>dir</code> function is our Cython function
<code>advance</code> (the module also features the imported <code>numpy</code> module under
the name <code>np</code> as well as many standard Python objects with double
underscores in their names).

<p>
The <code>setup.py</code> file makes use of the <code>distutils</code> package in Python
and Cython's extension of this package.
These tools know how Python was built on the computer and will
use compatible compiler(s) and options when building other code
in Cython, C, or C++. Quite some experience with building large
program systems is needed to do the build process manually, so using
a <code>setup.py</code> script is strongly recommended.

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Simplified build of a Cython module.</b>
When there is no need to link the C code with special libraries,
Cython offers a shortcut for generating and importing the extension
module:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">pyximport</span>; pyximport<span style="color: #666666">.</span>install()
</pre></div>
<p>
This makes the <code>setup.py</code> script redundant. However, in the <code>wave2D_u0.py</code>
code we do not use <code>pyximport</code> and require an explicit build process
of this and many other modules.
</div>
<h3>Calling the Cython function  <a name="___sec89"></a></h3>

<p>
The <code>wave2D_u0_loop_cy</code>
module contains our <code>advance</code> function, which we now may call from
the Python program for the wave equation:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">wave2D_u0_loop_cy</span>
advance <span style="color: #666666">=</span> wave2D_u0_loop_cy<span style="color: #666666">.</span>advance
<span style="color: #666666">...</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt):        <span style="color: #408080; font-style: italic"># time loop</span>
    f_a <span style="color: #666666">=</span> f(xv, yv, t[n])     <span style="color: #408080; font-style: italic"># precompute, size as u</span>
    u <span style="color: #666666">=</span> advance(u, u_1, u_2, f_a, x, y, t, Cx2, Cy2, dt2)
</pre></div>

<h4>Efficiency  <a name="___sec90"></a></h4>

<p>
For a mesh consisting of \( 120\times 120 \) cells, the scalar Python code
require 1370 CPU time units, the vectorized version requires 5.5,
while the Cython version requires only 1! For a smaller mesh with
\( 60\times 60 \) cells Cython is about 1000 times faster than the scalar
Python code, and the vectorized version is about 6 times slower than
the Cython version.

<p>
<!-- In 3D these numbers are even more favorable. -->

<h2>Migrating loops to Fortran  <a name="___sec91"></a></h2>

<p>
Instead of relying on Cython's (excellent) ability to translate Python to C,
we can invoke a compiled language directly and write the loops ourselves.
Let us start with Fortran 77, because this is a language with more
convenient array handling than C (or plain C++). Or more precisely,
we can with ease program with the same multi-dimensional indices
in the Fortran code as in the <code>numpy</code>
arrays in the Python code, while in C these arrays are
one-dimensional and requires us to reduce multi-dimensional indices
to a single index.

<p>
<!-- Fortran compilers -->
<!-- build on 60 years of intensive research on how to optimize loops with -->
<!-- array computations. -->

<h3>The Fortran subroutine  <a name="___sec92"></a></h3>

<p>
We write a Fortran subroutine <code>advance</code> in a file
<a href="http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0_loop_f77.f"><tt>wave2D_u0_loop_f77.f</tt></a>
for implementing the updating formula
<a href="#mjx-eqn-66">(66)</a> and setting the solution to zero
at the boundaries:

<p>

<!-- code=fortran (from !bc fpro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">      <span style="color: #008000; font-weight: bold">subroutine </span><span style="color: #19177C">advance</span>(<span style="color: #19177C">u</span>, <span style="color: #19177C">u_1</span>, <span style="color: #19177C">u_2</span>, <span style="color: #19177C">f</span>, <span style="color: #19177C">Cx2</span>, <span style="color: #19177C">Cy2</span>, <span style="color: #19177C">dt2</span>, <span style="color: #19177C">Nx</span>, <span style="color: #19177C">Ny</span>)
      <span style="color: #B00040">integer </span><span style="color: #19177C">Nx</span>, <span style="color: #19177C">Ny</span>
      <span style="color: #B00040">real</span><span style="color: #666666">*8</span> <span style="color: #19177C">u</span>(<span style="color: #666666">0</span>:<span style="color: #19177C">Nx</span>,<span style="color: #666666">0</span>:<span style="color: #19177C">Ny</span>), <span style="color: #19177C">u_1</span>(<span style="color: #666666">0</span>:<span style="color: #19177C">Nx</span>,<span style="color: #666666">0</span>:<span style="color: #19177C">Ny</span>), <span style="color: #19177C">u_2</span>(<span style="color: #666666">0</span>:<span style="color: #19177C">Nx</span>,<span style="color: #666666">0</span>:<span style="color: #19177C">Ny</span>)
      <span style="color: #B00040">real</span><span style="color: #666666">*8</span> <span style="color: #19177C">f</span>(<span style="color: #666666">0</span>:<span style="color: #19177C">Nx</span>, <span style="color: #666666">0</span>:<span style="color: #19177C">Ny</span>), <span style="color: #19177C">Cx2</span>, <span style="color: #19177C">Cy2</span>, <span style="color: #19177C">dt2</span>
      <span style="color: #B00040">integer </span><span style="color: #19177C">i</span>, <span style="color: #19177C">j</span>
<span style="color: #19177C">Cf2py</span> <span style="color: #008000; font-weight: bold">intent</span>(<span style="color: #19177C">in</span>, <span style="color: #19177C">out</span>) <span style="color: #19177C">u</span>

<span style="color: #19177C">C</span>     <span style="color: #19177C">Scheme</span> <span style="color: #19177C">at</span> <span style="color: #19177C">interior</span> <span style="color: #19177C">points</span>
      <span style="color: #008000; font-weight: bold">do </span><span style="color: #19177C">j</span> <span style="color: #666666">=</span> <span style="color: #666666">1</span>, <span style="color: #19177C">Ny</span><span style="color: #666666">-1</span>
         <span style="color: #008000; font-weight: bold">do </span><span style="color: #19177C">i</span> <span style="color: #666666">=</span> <span style="color: #666666">1</span>, <span style="color: #19177C">Nx</span><span style="color: #666666">-1</span>
            <span style="color: #19177C">u</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">=</span> <span style="color: #666666">2*</span><span style="color: #19177C">u_1</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">-</span> <span style="color: #19177C">u_2</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">+</span>
     &amp;      <span style="color: #19177C">Cx2</span><span style="color: #666666">*</span>(<span style="color: #19177C">u_1</span>(<span style="color: #19177C">i</span><span style="color: #666666">-1</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">-</span> <span style="color: #666666">2*</span><span style="color: #19177C">u_1</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">+</span> <span style="color: #19177C">u_1</span>(<span style="color: #19177C">i</span><span style="color: #666666">+1</span>,<span style="color: #19177C">j</span>)) <span style="color: #666666">+</span>
     &amp;      <span style="color: #19177C">Cy2</span><span style="color: #666666">*</span>(<span style="color: #19177C">u_1</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span><span style="color: #666666">-1</span>) <span style="color: #666666">-</span> <span style="color: #666666">2*</span><span style="color: #19177C">u_1</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">+</span> <span style="color: #19177C">u_1</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span><span style="color: #666666">+1</span>)) <span style="color: #666666">+</span>
     &amp;      <span style="color: #19177C">dt2</span><span style="color: #666666">*</span><span style="color: #19177C">f</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>)
         <span style="color: #008000; font-weight: bold">end do</span>
<span style="color: #008000; font-weight: bold">      end do</span>

<span style="color: #19177C">C</span>     <span style="color: #19177C">Boundary</span> <span style="color: #19177C">conditions</span>
      <span style="color: #19177C">j</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>
      <span style="color: #008000; font-weight: bold">do </span><span style="color: #19177C">i</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #19177C">Nx</span>
         <span style="color: #19177C">u</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">=</span> <span style="color: #666666">0</span>
      <span style="color: #008000; font-weight: bold">end do</span>
<span style="color: #008000; font-weight: bold">      </span><span style="color: #19177C">j</span> <span style="color: #666666">=</span> <span style="color: #19177C">Ny</span>
      <span style="color: #008000; font-weight: bold">do </span><span style="color: #19177C">i</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #19177C">Nx</span>
         <span style="color: #19177C">u</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">=</span> <span style="color: #666666">0</span>
      <span style="color: #008000; font-weight: bold">end do</span>
<span style="color: #008000; font-weight: bold">      </span><span style="color: #19177C">i</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>
      <span style="color: #008000; font-weight: bold">do </span><span style="color: #19177C">j</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #19177C">Ny</span>
         <span style="color: #19177C">u</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">=</span> <span style="color: #666666">0</span>
      <span style="color: #008000; font-weight: bold">end do</span>
<span style="color: #008000; font-weight: bold">      </span><span style="color: #19177C">i</span> <span style="color: #666666">=</span> <span style="color: #19177C">Nx</span>
      <span style="color: #008000; font-weight: bold">do </span><span style="color: #19177C">j</span> <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #19177C">Ny</span>
         <span style="color: #19177C">u</span>(<span style="color: #19177C">i</span>,<span style="color: #19177C">j</span>) <span style="color: #666666">=</span> <span style="color: #666666">0</span>
      <span style="color: #008000; font-weight: bold">end do</span>
<span style="color: #008000; font-weight: bold">      return</span>
<span style="color: #008000; font-weight: bold">      end</span>
</pre></div>
<p>
This code is plain Fortran 77, except for the special <code>Cf2py</code> comment
line, which here specifies that <code>u</code> is both an input argument <em>and</em>
an object to be returned from the <code>advance</code> routine. Or more
precisely, Fortran is not able return an array from a function,
but we need a <em>wrapper code</em> in C for the Fortran subroutine to enable
calling it from Python, and in this wrapper code one can return <code>u</code>
to the calling Python code.

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Remark.</b>
It is not strictly necessary to return <code>u</code> to the calling Python
code since the <code>advance</code> function will modify the elements of <code>u</code>,
but the convention in Python is to get all output from a function
as returned values. That is, the right way of calling the above
Fortran subroutine from Python is

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> advance(u, u_1, u_2, f, Cx2, Cy2, dt2)
</pre></div>
<p>
The less encouraged style, which works and resembles the way the
Fortran subroutine is called from Fortran, reads

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">advance(u, u_1, u_2, f, Cx2, Cy2, dt2)
</pre></div>
<p>
</div>
<h4>Building the Fortran module with f2py  <a name="___sec93"></a></h4>

<p>
The nice feature of writing loops in Fortran is that the tool <code>f2py</code>
can with very little work produce a C extension module such that
we can call the Fortran version of <code>advance</code> from Python.
The necessary commands to run are

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; f2py -m wave2D_u0_loop_f77 -h wave2D_u0_loop_f77.pyf <span style="color: #BB6622; font-weight: bold">\ </span>
          --overwrite-signature wave2D_u0_loop_f77.f
Terminal&gt; f2py -c wave2D_u0_loop_f77.pyf --build-dir build_f77 <span style="color: #BB6622; font-weight: bold">\ </span>
          -DF2PY_REPORT_ON_ARRAY_COPY<span style="color: #666666">=</span>1 wave2D_u0_loop_f77.f
</pre></div>
<p>
The first command asks <code>f2py</code> to interpret the Fortran code and make
a Fortran 90
specification of the extension module in the file
<code>wave2D_u0_loop_f77.pyf</code>. The second command makes
<code>f2py</code> generate all necessary
wrapper code, compile our Fortran file and the wrapper code,
and finally build the module.
The build process takes place in the specified subdirectory <code>build_f77</code>
so that files can be inspected if something goes wrong.
The option <code>-DF2PY_REPORT_ON_ARRAY_COPY=1</code> makes <code>f2py</code> write a message
for every array that is copied in the communication between Fortran and Python,
which is very useful for avoiding unnecessary array copying (see below).
The name of the module file
is <code>wave2D_u0_loop_f77.so</code>, and this file can be imported and inspected
as any other
Python module:

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; import wave2D_u0_loop_f77
&gt;&gt;&gt; dir(wave2D_u0_loop_f77)
[&#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,
 &#39;__version__&#39;, &#39;advance&#39;]
&gt;&gt;&gt; print wave2D_u0_loop_f77.__doc__
This module &#39;wave2D_u0_loop_f77&#39; is auto-generated with f2py....
Functions:
  u = advance(u,u_1,u_2,f,x,y,t,cx2,cy2,dt2,
      nx=(shape(u,0)-1),ny=(shape(u,1)-1),n=(len(t)-1))
</pre></div>
<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Examine the doc strings!</b>
Printing the doc strings of the module and its functions is
extremely important after having created a module with <code>f2py</code>,
because <code>f2py</code> makes Python interfaces to the Fortran functions
that are different from how the functions are declared in
the Fortran code (!). The rationale for this behavior is that
<code>f2py</code> creates <em>Pythonic</em> interfaces such that Fortran routines
can be called in the same way as one calls Python functions.
Output data from Python functions is always returned
to the calling code, but this is technically impossible in Fortran.
Also, arrays in Python are passed to Python functions without
their dimensions because that information is packed with the array
data in the array objects, but this is not possible in Fortran.
Therefore, <code>f2py</code> removes array dimensions from the argument list,
and <code>f2py</code> makes it possible to
return objects back to Python.
</div>
<p>
Let us follow the advice of examining the doc strings
and take a close look at
the documentation <code>f2py</code> has generated for our Fortran <code>advance</code>
subroutine:

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; print wave2D_u0_loop_f77.advance.__doc__
This module &#39;wave2D_u0_loop_f77&#39; is auto-generated with f2py
Functions:
  u = advance(u,u_1,u_2,f,cx2,cy2,dt2,
              nx=(shape(u,0)-1),ny=(shape(u,1)-1))
.
advance - Function signature:
  u = advance(u,u_1,u_2,f,cx2,cy2,dt2,[nx,ny])
Required arguments:
  u : input rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)
  u_1 : input rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)
  u_2 : input rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)
  f : input rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)
  cx2 : input float
  cy2 : input float
  dt2 : input float
Optional arguments:
  nx := (shape(u,0)-1) input int
  ny := (shape(u,1)-1) input int
Return objects:
  u : rank-2 array(&#39;d&#39;) with bounds (nx + 1,ny + 1)
</pre></div>
<p>
Here we see that the <code>nx</code> and <code>ny</code> parameters declared in
Fortran are optional arguments that can be omitted when calling
<code>advance</code> from Python.

<p>
We strongly recommend to print out the
documentation of <em>every</em> Fortran function to be called from Python
and make sure the call syntax is exactly as listed in the
documentation.

<h3>How to avoid array copying  <a name="___sec94"></a></h3>

<p>
Multi-dimensional arrays are stored as a stream of numbers in memory.
For a two-dimensional array consisting of rows and columns there are
two ways of creating such a stream: <em>row-major ordering</em>, which means
that rows are stored consecutively in memory, or <em>column-major
ordering</em>, which means that the columns are stored one after each other.
All programming languages inherited from C, including Python, apply
the row-major ordering, but Fortran uses column-major storage.
Thinking of a two-dimensional array in Python or C
as a matrix, it means that Fortran
works with the transposed matrix.

<p>
Fortunately, <code>f2py</code> creates extra code so that accessing <code>u(i,j)</code> in
the Fortran subroutine corresponds to the element <code>u[i,j]</code> in the
underlying <code>numpy</code> array (without the extra code, <code>u(i,j)</code> in Fortran
would access <code>u[j,i]</code> in the <code>numpy</code> array).  Technically, <code>f2py</code>
takes a copy of our <code>numpy</code> array and reorders the data before
sending the array to Fortran. Such copying can be costly. For 2D wave
simulations on a \( 60\times 60 \) grid the overhead of copying is a
factor of 5, which means that almost the whole performance gain of
Fortran over vectorized <code>numpy</code> code is lost!

<p>
To avoid having <code>f2py</code> to copy
arrays with C storage to the corresponding Fortran storage, we declare
the arrays with Fortran storage:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">order <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Fortran&#39;</span> <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;f77&#39;</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&#39;C&#39;</span>
u   <span style="color: #666666">=</span> zeros((Nx<span style="color: #666666">+1</span>,Ny<span style="color: #666666">+1</span>), order<span style="color: #666666">=</span>order)   <span style="color: #408080; font-style: italic"># solution array</span>
u_1 <span style="color: #666666">=</span> zeros((Nx<span style="color: #666666">+1</span>,Ny<span style="color: #666666">+1</span>), order<span style="color: #666666">=</span>order)   <span style="color: #408080; font-style: italic"># solution at t-dt</span>
u_2 <span style="color: #666666">=</span> zeros((Nx<span style="color: #666666">+1</span>,Ny<span style="color: #666666">+1</span>), order<span style="color: #666666">=</span>order)   <span style="color: #408080; font-style: italic"># solution at t-2*dt</span>
</pre></div>
<p>
In the compile and build step of using <code>f2py</code>, it is recommended to add
an extra option for making <code>f2py</code> report on array copying:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; f2py -c wave2D_u0_loop_f77.pyf --build-dir build_f77 <span style="color: #BB6622; font-weight: bold">\ </span>
          -DF2PY_REPORT_ON_ARRAY_COPY<span style="color: #666666">=</span>1 wave2D_u0_loop_f77.f
</pre></div>
<p>
It can sometimes be a challenge to track down which array that causes
a copying. There are two principal reasons for copying array data:
either the array does not have Fortran storage or the element types do
not match those declared in the Fortran code. The latter cause is
usually effectively eliminated by using <code>real*8</code> data in the Fortran
code and <code>float64</code> (the default <code>float</code> type in <code>numpy</code>) in the arrays
on the Python side. The former reason is more common, and to check
whether an array before a Fortran call has the right storage one can
print the result of <code>isfortran(a)</code>, which is <code>True</code> if the array <code>a</code>
has Fortran storage.

<p>
Let us look at an example where we face problems with array storage.
A typical problem in the <code>wave2D_u0.py</code> code is
to set

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f_a <span style="color: #666666">=</span> f(xv, yv, t[n])
</pre></div>
<p>
before the call to the Fortran <code>advance</code> routine. This computation creates
a new array with C storage. An undesired copy of <code>f_a</code> will be produced
when sending <code>f_a</code> to a Fortran routine.
There are two remedies, either direct insertion
of data in an array with Fortran storage,
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f_a <span style="color: #666666">=</span> zeros((Nx<span style="color: #666666">+1</span>, Ny<span style="color: #666666">+1</span>), order<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Fortran&#39;</span>)
<span style="color: #666666">...</span>
f_a[:,:] <span style="color: #666666">=</span> f(xv, yv, t[n])
</pre></div>
<p>
or remaking the <code>f(xv, yv, t[n])</code> array,
<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f_a <span style="color: #666666">=</span> asarray(f(xv, yv, t[n]), order<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Fortran&#39;</span>)
</pre></div>
<p>
The former remedy is most efficient if the <code>asarray</code> operation is to
be performed a large number of times.

<h4>Efficiency  <a name="___sec95"></a></h4>

<p>
The efficiency of this Fortran code is very similar to the Cython code.
There is usually nothing more to gain, from a computational efficiency
point of view, by implementing the <em>complete</em> Python program in Fortran
or C. That will just be a lot more code for all administering work
that is needed in scientific software, especially if we extend our
sample program <code>wave2D_u0.py</code> to handle a real scientific problem.
Then only a small portion will consist of loops with intensive
array calculations. These can be migrated to Cython or Fortran as
explained, while the rest of the programming can be more conveniently
done in Python.

<h2>Migrating loops to C via Cython  <a name="___sec96"></a></h2>

<p>
The computationally intensive loops can alternatively be implemented
in C code. Just as Fortran calls for care regarding the storage of
two-dimensional arrays, working with two-dimensional arrays in C
is a bit tricky. The reason is that
<code>numpy</code> arrays are viewed as one-dimensional arrays when
transferred to C, while C programmers will think of <code>u</code>, <code>u_1</code>, and
<code>u_2</code> as two dimensional arrays and index them like <code>u[i][j]</code>.
The C code must declare <code>u</code> as <code>double* u</code> and translate an index
pair <code>[i][j]</code> to a corresponding single index when <code>u</code> is
viewed as one-dimensional. This translation requires knowledge of
how the numbers in <code>u</code> are stored in memory.

<h3>Translating index pairs to single indices  <a name="___sec97"></a></h3>

<p>
Two-dimensional <code>numpy</code> arrays with the default C storage are stored
row by row. In general, multi-dimensional arrays with C storage are
stored such that the last index has the fastest variation, then the
next last index, and so on, ending up with the slowest variation
in the first index. For a two-dimensional <code>u</code> declared as
<code>zeros((Nx+1,Ny+1))</code> in Python, the individual elements are stored
in the following order:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>], u[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], u[<span style="color: #666666">0</span>,<span style="color: #666666">2</span>], <span style="color: #666666">...</span>, u[<span style="color: #666666">0</span>,Ny], u[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>], u[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>], <span style="color: #666666">...</span>,
u[<span style="color: #666666">1</span>,Ny], u[<span style="color: #666666">2</span>,<span style="color: #666666">0</span>], <span style="color: #666666">...</span>, u[Nx,<span style="color: #666666">0</span>], u[Nx,<span style="color: #666666">1</span>], <span style="color: #666666">...</span>, u[Nx, Ny]
</pre></div>
<p>
Viewing <code>u</code> as one-dimensional, the index pair \( (i,j) \) translates
to \( i(N_y+1)+j \). So, where a C programmer would naturally write
an index <code>u[i][j]</code>, the indexing must read <code>u[i*(Ny+1) + j]</code>.
This is tedious to write, so it can be handy to define a C macro,

<p>

<!-- code=c (from !bc ccod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BC7A00">#define idx(i,j) (i)*(Ny+1) + j</span>
</pre></div>
<p>
so that we can write <code>u[idx(i,j)]</code>, which reads much better and is
easier to debug.

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Be careful with macro definitions.</b>
Macros just perform simple text substitutions:
<code>idx(hello,world)</code> is expanded to <code>(hello)*(Ny+1) + world</code>.
The parenthesis in <code>(i)</code> are essential - using the natural mathematical
formula <code>i*(Ny+1) + j</code> in the macro definition,
<code>idx(i-1,j)</code> would expand to <code>i-1*(Ny+1) + j</code>, which is the wrong
formula. Macros are handy, but requires careful use.
In C++, inline functions are safer and replace the need for macros.
</div>
<h3>The complete C code  <a name="___sec98"></a></h3>

<p>
The C version of our function <code>advance</code> can be coded as follows.

<p>

<!-- code=c (from !bc cpro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BC7A00">#define idx(i,j) (i)*(Ny+1) + j</span>

<span style="color: #B00040">void</span> <span style="color: #0000FF">advance</span>(<span style="color: #B00040">double</span><span style="color: #666666">*</span> u, <span style="color: #B00040">double</span><span style="color: #666666">*</span> u_1, <span style="color: #B00040">double</span><span style="color: #666666">*</span> u_2, <span style="color: #B00040">double</span><span style="color: #666666">*</span> f,
	     <span style="color: #B00040">double</span> Cx2, <span style="color: #B00040">double</span> Cy2, <span style="color: #B00040">double</span> dt2,
	     <span style="color: #B00040">int</span> Nx, <span style="color: #B00040">int</span> Ny)
{
  <span style="color: #B00040">int</span> i, j;
  <span style="color: #408080; font-style: italic">/* Scheme at interior points */</span>
  <span style="color: #008000; font-weight: bold">for</span> (i<span style="color: #666666">=1</span>; i<span style="color: #666666">&lt;=</span>Nx<span style="color: #666666">-1</span>; i<span style="color: #666666">++</span>) {
    <span style="color: #008000; font-weight: bold">for</span> (j<span style="color: #666666">=1</span>; j<span style="color: #666666">&lt;=</span>Ny<span style="color: #666666">-1</span>; j<span style="color: #666666">++</span>) {
        u[idx(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">2*</span>u_1[idx(i,j)] <span style="color: #666666">-</span> u_2[idx(i,j)] <span style="color: #666666">+</span>
        Cx2<span style="color: #666666">*</span>(u_1[idx(i<span style="color: #666666">-1</span>,j)] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[idx(i,j)] <span style="color: #666666">+</span> u_1[idx(i<span style="color: #666666">+1</span>,j)]) <span style="color: #666666">+</span>
        Cy2<span style="color: #666666">*</span>(u_1[idx(i,j<span style="color: #666666">-1</span>)] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[idx(i,j)] <span style="color: #666666">+</span> u_1[idx(i,j<span style="color: #666666">+1</span>)]) <span style="color: #666666">+</span>
        dt2<span style="color: #666666">*</span>f[idx(i,j)];
	}
    }
  }
  <span style="color: #408080; font-style: italic">/* Boundary conditions */</span>
  j <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  <span style="color: #008000; font-weight: bold">for</span> (i<span style="color: #666666">=0</span>; i<span style="color: #666666">&lt;=</span>Nx; i<span style="color: #666666">++</span>) u[idx(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  j <span style="color: #666666">=</span> Ny; <span style="color: #008000; font-weight: bold">for</span> (i<span style="color: #666666">=0</span>; i<span style="color: #666666">&lt;=</span>Nx; i<span style="color: #666666">++</span>) u[idx(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  <span style="color: #008000; font-weight: bold">for</span> (j<span style="color: #666666">=0</span>; j<span style="color: #666666">&lt;=</span>Ny; j<span style="color: #666666">++</span>) u[idx(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  i <span style="color: #666666">=</span> Nx; <span style="color: #008000; font-weight: bold">for</span> (j<span style="color: #666666">=0</span>; j<span style="color: #666666">&lt;=</span>Ny; j<span style="color: #666666">++</span>) u[idx(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
}
</pre></div>

<h3>The Cython interface file  <a name="___sec99"></a></h3>

<p>
All the code above appears in a file <a href="http://tinyurl.com/jvzzcfn/wave//wave2D_u0/wave2D_u0_loop_c.c"><tt>wave2D_u0_loop_c.c</tt></a>.
We need to compile this file together with C wrapper code such that
<code>advance</code> can be called from Python. Cython can be used to generate
appropriate wrapper code.
The relevant Cython code for interfacing C is
placed in a file with extension <code>.pyx</code>. Here this file, called
<a href="http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0_loop_c_cy.pyx"><tt>wave2D_u0_loop_c_cy.pyx</tt></a>, looks like

<p>

<!-- code=cython (from !bc cypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">cimport</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">cimport</span> <span style="color: #0000FF; font-weight: bold">cython</span>

<span style="color: #008000; font-weight: bold">cdef</span> <span style="color: #008000; font-weight: bold">extern</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #BA2121">&quot;wave2D_u0_loop_c.h&quot;</span>:
    void advance(double<span style="color: #666666">*</span> u, double<span style="color: #666666">*</span> u_1, double<span style="color: #666666">*</span> u_2, double<span style="color: #666666">*</span> f,
                 double Cx2, double Cy2, double dt2,
                 <span style="color: #008000">int</span> Nx, <span style="color: #008000">int</span> Ny)

<span style="color: #AA22FF">@cython</span><span style="color: #666666">.</span>boundscheck(<span style="color: #008000">False</span>)
<span style="color: #AA22FF">@cython</span><span style="color: #666666">.</span>wraparound(<span style="color: #008000">False</span>)
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">advance_cwrap</span>(
    np<span style="color: #666666">.</span>ndarray[double, ndim<span style="color: #666666">=2</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>] u,
    np<span style="color: #666666">.</span>ndarray[double, ndim<span style="color: #666666">=2</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>] u_1,
    np<span style="color: #666666">.</span>ndarray[double, ndim<span style="color: #666666">=2</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>] u_2,
    np<span style="color: #666666">.</span>ndarray[double, ndim<span style="color: #666666">=2</span>, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;c&#39;</span>] f,
    double Cx2, double Cy2, double dt2):
    advance(<span style="color: #666666">&amp;</span>u[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>], <span style="color: #666666">&amp;</span>u_1[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>], <span style="color: #666666">&amp;</span>u_2[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>], <span style="color: #666666">&amp;</span>f[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>],
            Cx2, Cy2, dt2,
            u<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]<span style="color: #666666">-1</span>, u<span style="color: #666666">.</span>shape[<span style="color: #666666">1</span>]<span style="color: #666666">-1</span>)
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
We first declare the C functions to be interfaced.
These must also appear in a C header file, <a href="http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0_loop_c.h"><tt>wave2D_u0_loop_c.h</tt></a>,

<p>

<!-- code=c++ (from !bc cpppro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">extern</span> <span style="color: #B00040">void</span> <span style="color: #0000FF">advance</span>(<span style="color: #B00040">double</span><span style="color: #666666">*</span> u, <span style="color: #B00040">double</span><span style="color: #666666">*</span> u_1, <span style="color: #B00040">double</span><span style="color: #666666">*</span> u_2, <span style="color: #B00040">double</span><span style="color: #666666">*</span> f,
		    <span style="color: #B00040">double</span> Cx2, <span style="color: #B00040">double</span> Cy2, <span style="color: #B00040">double</span> dt2,
		    <span style="color: #B00040">int</span> Nx, <span style="color: #B00040">int</span> Ny);
</pre></div>
<p>
The next step is to write a Cython function with Python objects as arguments.
The name <code>advance</code> is already used for the C function so the function
to be called from Python is named <code>advance_cwrap</code>. The contents of
this function is simply a call to the <code>advance</code> version in C. To this end,
the right information from the Python objects must be passed on as
arguments to <code>advance</code>. Arrays are sent with their C pointers to the
first element, obtained in Cython as <code>&u[0,0]</code> (the <code>&</code> takes the
address of a C variable). The <code>Nx</code> and <code>Ny</code> arguments in <code>advance</code> are
easily obtained from the shape of the <code>numpy</code> array <code>u</code>.
Finally, <code>u</code> must be returned such that we can set <code>u = advance(...)</code>
in Python.

<h3>Building the extension module  <a name="___sec100"></a></h3>

<p>
It remains to build the extension module. An appropriate
<code>setup.py</code> file is

<p>

<!-- code=python (from !bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">distutils.core</span> <span style="color: #008000; font-weight: bold">import</span> setup
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">distutils.extension</span> <span style="color: #008000; font-weight: bold">import</span> Extension
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">Cython.Distutils</span> <span style="color: #008000; font-weight: bold">import</span> build_ext

sources <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;wave2D_u0_loop_c.c&#39;</span>, <span style="color: #BA2121">&#39;wave2D_u0_loop_c_cy.pyx&#39;</span>]
module <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;wave2D_u0_loop_c_cy&#39;</span>
setup(
  name<span style="color: #666666">=</span>module,
  ext_modules<span style="color: #666666">=</span>[Extension(module, sources,
                         libraries<span style="color: #666666">=</span>[], <span style="color: #408080; font-style: italic"># C libs to link with</span>
                         )],
  cmdclass<span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;build_ext&#39;</span>: build_ext},
)
</pre></div>
<p>
All we need to specify is the <code>.c</code> file(s) and the <code>.pyx</code> interface
file. Cython is automatically run to generate the necessary wrapper
code. Files are then compiled and linked to an extension module
residing in the file <code>wave2D_u0_loop_c_cy.so</code>. Here is a
session with running <code>setup.py</code>
and examining the resulting module in Python

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python setup.py build_ext --inplace
Terminal&gt; python
&gt;&gt;&gt; import wave2D_u0_loop_c_cy as m
&gt;&gt;&gt; dir<span style="color: #666666">(</span>m<span style="color: #666666">)</span>
<span style="color: #666666">[</span><span style="color: #BA2121">&#39;__builtins__&#39;</span>, <span style="color: #BA2121">&#39;__doc__&#39;</span>, <span style="color: #BA2121">&#39;__file__&#39;</span>, <span style="color: #BA2121">&#39;__name__&#39;</span>, <span style="color: #BA2121">&#39;__package__&#39;</span>,
 <span style="color: #BA2121">&#39;__test__&#39;</span>, <span style="color: #BA2121">&#39;advance_cwrap&#39;</span>, <span style="color: #BA2121">&#39;np&#39;</span><span style="color: #666666">]</span>
</pre></div>
<p>
The call to the C version of <code>advance</code> can go like this in Python:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">wave2D_u0_loop_c_cy</span>
advance <span style="color: #666666">=</span> wave2D_u0_loop_c_cy<span style="color: #666666">.</span>advance_cwrap
<span style="color: #666666">...</span>
f_a[:,:] <span style="color: #666666">=</span> f(xv, yv, t[n])
u <span style="color: #666666">=</span> advance(u, u_1, u_2, f_a, Cx2, Cy2, dt2)
</pre></div>

<h4>Efficiency  <a name="___sec101"></a></h4>

<p>
In this example, the C and Fortran code runs at the same speed, and there
are no significant differences in the efficiency of the wrapper code.
The overhead implied by the wrapper code is negligible as long as
we do not work with very small meshes and consequently little numerical
work in the <code>advance</code> function.

<h2>Migrating loops to C via f2py  <a name="___sec102"></a></h2>

<p>
An alternative to using Cython for interfacing C code is to apply
<code>f2py</code>. The C code is the same, just the details of specifying how
it is to be called from Python differ. The <code>f2py</code> tool requires
the call specification to be a Fortran 90 module defined in a <code>.pyf</code>
file. This file was automatically generated when we interfaced a
Fortran subroutine. With a C function we need to write this module
ourselves, or we can use a trick and let <code>f2py</code> generate it for us.
The trick consists in writing the signature of the C function with
Fortran syntax and place it in a Fortran file, here
<code>wave2D_u0_loop_c_f2py_signature.f</code>:

<p>

<!-- code=fortran (from !bc fpro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">      <span style="color: #008000; font-weight: bold">subroutine </span><span style="color: #19177C">advance</span>(<span style="color: #19177C">u</span>, <span style="color: #19177C">u_1</span>, <span style="color: #19177C">u_2</span>, <span style="color: #19177C">f</span>, <span style="color: #19177C">Cx2</span>, <span style="color: #19177C">Cy2</span>, <span style="color: #19177C">dt2</span>, <span style="color: #19177C">Nx</span>, <span style="color: #19177C">Ny</span>)
<span style="color: #19177C">Cf2py</span> <span style="color: #008000; font-weight: bold">intent</span>(<span style="color: #19177C">c</span>) <span style="color: #19177C">advance</span>
      <span style="color: #B00040">integer </span><span style="color: #19177C">Nx</span>, <span style="color: #19177C">Ny</span>, <span style="color: #19177C">N</span>
      <span style="color: #B00040">real</span><span style="color: #666666">*8</span> <span style="color: #19177C">u</span>(<span style="color: #666666">0</span>:<span style="color: #19177C">Nx</span>,<span style="color: #666666">0</span>:<span style="color: #19177C">Ny</span>), <span style="color: #19177C">u_1</span>(<span style="color: #666666">0</span>:<span style="color: #19177C">Nx</span>,<span style="color: #666666">0</span>:<span style="color: #19177C">Ny</span>), <span style="color: #19177C">u_2</span>(<span style="color: #666666">0</span>:<span style="color: #19177C">Nx</span>,<span style="color: #666666">0</span>:<span style="color: #19177C">Ny</span>)
      <span style="color: #B00040">real</span><span style="color: #666666">*8</span> <span style="color: #19177C">f</span>(<span style="color: #666666">0</span>:<span style="color: #19177C">Nx</span>, <span style="color: #666666">0</span>:<span style="color: #19177C">Ny</span>), <span style="color: #19177C">Cx2</span>, <span style="color: #19177C">Cy2</span>, <span style="color: #19177C">dt2</span>
<span style="color: #19177C">Cf2py</span> <span style="color: #008000; font-weight: bold">intent</span>(<span style="color: #19177C">in</span>, <span style="color: #19177C">out</span>) <span style="color: #19177C">u</span>
<span style="color: #19177C">Cf2py</span> <span style="color: #008000; font-weight: bold">intent</span>(<span style="color: #19177C">c</span>) <span style="color: #19177C">u</span>, <span style="color: #19177C">u_1</span>, <span style="color: #19177C">u_2</span>, <span style="color: #19177C">f</span>, <span style="color: #19177C">Cx2</span>, <span style="color: #19177C">Cy2</span>, <span style="color: #19177C">dt2</span>, <span style="color: #19177C">Nx</span>, <span style="color: #19177C">Ny</span>
      <span style="color: #008000; font-weight: bold">return</span>
<span style="color: #008000; font-weight: bold">      end</span>
</pre></div>
<p>
Note that we need a special <code>f2py</code> instruction, through a <code>Cf2py</code>
comment line, for telling that all the function arguments are
C variables. We also need to specify that the function is actually
in C: <code>intent(c) advance</code>.

<p>
Since <code>f2py</code> is just concerned with the function signature and not the
complete contents of the function body, it can easily generate the
Fortran 90 module specification based solely on the signature above:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; f2py -m wave2D_u0_loop_c_f2py <span style="color: #BB6622; font-weight: bold">\ </span>
          -h wave2D_u0_loop_c_f2py.pyf --overwrite-signature <span style="color: #BB6622; font-weight: bold">\ </span>
          wave2D_u0_loop_c_f2py_signature.f
</pre></div>
<p>
The compile and build step is as for the Fortran code, except that we
list C files instead of Fortran files:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; f2py -c wave2D_u0_loop_c_f2py.pyf <span style="color: #BB6622; font-weight: bold">\ </span>
          --build-dir tmp_build_c <span style="color: #BB6622; font-weight: bold">\ </span>
          -DF2PY_REPORT_ON_ARRAY_COPY<span style="color: #666666">=</span>1 wave2D_u0_loop_c.c
</pre></div>
<p>
As when interfacing Fortran code with <code>f2py</code>, we need to print out
the doc string to see the exact call syntax from the Python side.
This doc string is identical for the C and Fortran versions of
<code>advance</code>.

<p>
<!-- No worries with transposed storage, copy of arrays can only take -->
<!-- place if the type don't match -->

<p>
<!-- ===== Migrating loops to C via Instant ===== -->

<h3>Migrating loops to C++ via f2py  <a name="___sec103"></a></h3>

<p>
C++ is a much more versatile language than C or Fortran and has over
the last two decades become very popular for numerical computing.
Many will therefore prefer to migrate compute-intensive Python code
to C++. This is, in principle, easy: just write the desired C++ code
and use some tool for interfacing it from Python. A tool like
<a href="http://swig.org/">SWIG</a> can interpret the C++ code and generate
interfaces for a wide range of
languages, including Python, Perl, Ruby, and Java.
However, SWIG is a comprehensive tool with a correspondingly
steep learning curve. Alternative tools, such as
<a href="http://www.boost.org/doc/libs/1_51_0/libs/python/doc/index.html">Boost Python</a>, <a href="http://riverbankcomputing.co.uk/software/sip/intro">SIP</a>,
and <a href="http://qt-project.org/wiki/Category:LanguageBindings::PySide::Shiboken">Shiboken</a>
are similarly comprehensive. Simpler tools include
<a href="http://code.google.com/p/pybindgen/">PyBindGen</a>,

<p>
<!-- More tools for interfacing C++ from Python -->

<p>
A technically much easier way of interfacing C++ code is to drop the
possibility to use C++ classes directly from Python, but instead
make a C interface to the C++ code. The C interface can be handled
by <code>f2py</code> as shown in the example with pure C code. Such a solution
means that classes in Python and C++ cannot be mixed and that only
primitive data types like numbers, strings, and arrays can be
transferred between Python and C++. Actually, this is often a very
good solution because it forces the C++ code to work on array data,
which usually gives faster code than if fancy data structures with
classes are used. The arrays coming from Python, and looking like
plain C/C++ arrays, can be efficiently wrapped in more user-friendly
C++ array classes in the C++ code, if desired.

<p>
<b>Remaining.</b>
Use some array class. Key issue: <code>extern "C"</code> declaration of C++
function in the C file with the interface we want to wrap.

<h2>Using classes to implement a simulator  <a name="___sec104"></a></h2>

<p>

<ul>
 <li> Introduce classes <code>Mesh</code>, <code>Function</code>, <code>Problem</code>, <code>Solver</code>, <code>Visualizer</code>,
   <code>File</code>
<!-- communicate with compiled code by ensuring that classes work with arrays -->
<!-- ===== Callbacks to Python from Fortran or C ===== -->
<!-- 5631 projects: -->
<!-- Drop f_a, call py from f77 -->
<!-- Call py with cpdef f from Cython, but hardcode function name -->
<!-- As above, but transfer function to Cython -->
<!-- Instant -->
<!-- test_quadratic for all -->
<!-- Think of extensions: Neumann with modified stencil or ghost cells, -->
<!-- variable coefficients, damping, ... --></li>
</ul>

<h2>Exercises  <a name="___sec105"></a></h2>

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 10: Check that a solution fulfills the discrete model <a name="wave:exer:quadratic:2D"></a></h3>

<p>
Carry out all mathematical details to show that
<a href="#mjx-eqn-67">(67)</a> is indeed a solution of the
discrete model for a 2D wave equation with \( u=0 \) on the boundary.
One must check the boundary conditions, the initial conditions,
the general discrete equation at a time level and the special
version of this equation for the first time level.
Filename: <code>check_quadratic_solution.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Project 11: Calculus with 2D/3D mesh functions <a name="wave:exer:mesh3D:calculus"></a></h3>

<p>
The goal of this project is to redo
<a href="._part0002_main_wave.html#wave:exer:mesh1D:calculus">Project 5: Calculus with 1D mesh functions</a> with 2D and 3D
mesh functions (\( f_{i,j} \) and \( _{fi,j,k} \)).

<p>
<b>Differentiation.</b>
The differentiation results in a discrete gradient
function, which in the 2D case can be represented by a three-dimensional
array <code>df[d,i,j]</code> where <code>d</code> represents the direction of
the derivative and <code>i</code> and <code>j</code> are mesh point counters in 2D
(the 3D counterpart is <code>df[d,i,j,k]</code>).

<p>
<b>Integration.</b>
The integral of a 2D mesh function \( f_{i,j} \) is defined as

<p>
$$ F_{i,j} = \int_{y_0}^{y_j} \int_{x_0}^{x_i} f(x,y)dxdy,$$

where \( f(x,y) \) is a function that takes on the values of the
discrete mesh function \( f_{i,j} \) at the mesh points, but can also
be evaluated in between the mesh points. The particular variation
between mesh points can be taken as bilinear, but this is not
important as we will use a product Trapezoidal rule to approximate
the integral over a cell in the mesh and then we only need to
evaluate \( f(x,y) \) at the mesh points.

<p>
Suppose \( F_{i,j} \) is computed. The calculation of \( F_{i+1,j} \)
is then

<p>
$$
\begin{align*}
F_{i+1,j} &= F_{i,j} + \int_{x_i}^{x_{i+1}}\int_{y_0}^{y_j} f(x,y)dydx\\ 
&\approx \Delta x \int_{y_0}^{y_j} f(x_{i+\frac{1}{2}},y)dy\\ 
& \approx \Delta x \frac{1}{2}\left(
\int_{y_0}^{y_j} f(x_{i},y)dy
+ \int_{y_0}^{y_j} f(x_{i+1},y)dy\right)
\end{align*}
$$

The integrals in the \( y \) direction can be approximated by a Trapezoidal
rule. A similar idea can be used to compute \( F_{i,j+1} \). Thereafter,
\( F_{i+1,j+1} \) can be computed by adding the integral over the final
corner cell to \( F_{i+1,j} + F_{i,j+1} - F_{i,j} \). Carry out the
details of these computations and extend the ideas to 3D.
Filename: <code>mesh_calculus_3D.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 12: Implement Neumann conditions in 2D <a name="wave:app:exer:wave2D:Neumann"></a></h3>

<p>
Modify the <a href="/wave2D_u0/wave2D_u0.py"><tt>wave2D_u0.py</tt></a>
program, which solves the 2D wave equation \( u_{tt}=c^2(u_{xx}+u_{yy}) \)
with constant wave velocity \( c \) and \( u=0 \) on the boundary, to have
Neumann boundary conditions: \( \partial u/\partial n=0 \).
Include both scalar code (for debugging and reference) and
vectorized code (for speed).

<p>
To test the code, use \( u=1.2 \) as solution (\( I(x,y)=1.2 \), \( V=f=0 \), and
\( c \) arbitrary), which should be exactly reproduced with any mesh
as long as the stability criterion is satisfied.
Another test is to use the plug-shaped pulse
in the <code>pulse</code> function from the section <a href="._part0003_main_wave.html#wave:pde2:software">Building a general 1D wave equation solver</a>
and the <a href="http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py"><tt>wave1D_dn_vc.py</tt></a>
program. This pulse
is exactly propagated in 1D if \( c\Delta t/\Delta x=1 \). Check
that also the 2D program can propagate this pulse exactly
in \( x \) direction (\( c\Delta t/\Delta x=1 \), \( \Delta y \) arbitrary)
and \( y \) direction (\( c\Delta t/\Delta y=1 \), \( \Delta x \) arbitrary).
Filename: <code>wave2D_dn.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h3>Exercise 13: Test the efficiency of compiled loops in 3D <a name="wave:exer:3D:f77:cy:efficiency"></a></h3>

<p>
Extend the <code>wave2D_u0.py</code> code and the Cython, Fortran, and C versions to 3D.
Set up an efficiency experiment to determine the relative efficiency of
pure scalar Python code, vectorized code, Cython-compiled loops,
Fortran-compiled loops, and C-compiled loops.
Normalize the CPU time for each mesh by the fastest version.
Filename: <code>wave3D_u0.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<a href="._part0005_main_wave.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0007_main_wave.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

