<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study Guide: Finite difference methods for vibration problems">
<meta name="keywords" content="period (of oscillations),frequency (of oscillations),Hz (unit),stability criterion,staggered mesh,staggered Euler-Cromer scheme">



<style type="text/css">
    /* bloodish style */

    body {
      font-family: Helvetica, Verdana, Arial, Sans-serif;
      color: #404040;
      background: #ffffff;
    }
    h1 { font-size: 1.8em;  color: #8A0808; }
    h2 { font-size: 1.5em;  color: #8A0808; }
    h3, h4 { color: #8A0808; }
    a { color: #8A0808; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' A simple vibration problem ', 1, None, '___sec0'),
              (' A centered finite difference scheme; step 1 and 2 ',
               2,
               'vib:model1:fdm',
               'vib:model1:fdm'),
              (' A centered finite difference scheme; step 3 ',
               2,
               None,
               '___sec2'),
              (' A centered finite difference scheme; step 4 ',
               2,
               None,
               '___sec3'),
              (' Computing the first step ', 2, None, '___sec4'),
              (' The computational algorithm ', 2, None, '___sec5'),
              (' Operator notation; ODE ', 2, None, '___sec6'),
              (' Operator notation; initial condition ', 2, None, '___sec7'),
              (" Computing $u'$ ", 2, None, '___sec8'),
              (' Implementation ', 1, None, '___sec9'),
              (' Core algorithm ', 2, None, '___sec10'),
              (' Plotting ', 2, None, '___sec11'),
              (' Main program ', 2, None, '___sec12'),
              (' User interface: command line ', 2, None, '___sec13'),
              (' Running the program ', 2, None, '___sec14'),
              (' Verification ', 1, None, '___sec15'),
              (' First steps for testing and debugging ',
               2,
               None,
               '___sec16'),
              (' Checking convergence rates ', 2, None, '___sec17'),
              (' Implementational details ', 2, None, '___sec18'),
              (' Nose test ', 2, None, '___sec19'),
              (' Long time simulations ',
               1,
               'vib:model1:longseries',
               'vib:model1:longseries'),
              (' Effect of the time step on long simulations ',
               2,
               None,
               '___sec21'),
              (' Using a moving plot window ', 2, None, '___sec22'),
              (' Analysis of the numerical scheme ',
               1,
               'vib:model1:analysis',
               'vib:model1:analysis'),
              (' Deriving an exact numerical solution; ideas ',
               2,
               None,
               '___sec24'),
              (' Deriving an exact numerical solution; calculations (1) ',
               2,
               None,
               '___sec25'),
              (' Deriving an exact numerical; calculations (2) ',
               2,
               None,
               '___sec26'),
              (' Polynomial approximation of the phase error ',
               2,
               None,
               '___sec27'),
              (' Plot of the phase error ', 2, None, '___sec28'),
              (' Exact discrete solution ', 2, None, '___sec29'),
              (' Convergence of the numerical scheme ', 2, None, '___sec30'),
              (' Stability ', 2, None, '___sec31'),
              (' The stability criterion ', 2, None, '___sec32'),
              (' Summary of the analysis ', 2, None, '___sec33'),
              (' Alternative schemes based on 1st-order equations ',
               1,
               'vib:model2x2',
               'vib:model2x2'),
              (' Rewriting 2nd-order ODE as system of two 1st-order ODEs ',
               2,
               None,
               '___sec35'),
              (' The Forward Euler scheme ', 2, None, '___sec36'),
              (' The Backward Euler scheme ', 2, None, '___sec37'),
              (' The Crank-Nicolson scheme ', 2, None, '___sec38'),
              (' Comparison of schemes via Odespy ', 2, None, '___sec39'),
              (' Forward and Backward Euler and Crank-Nicolson ',
               2,
               None,
               '___sec40'),
              (' Phase plane plot of the numerical solutions ',
               2,
               None,
               '___sec41'),
              (' Plain solution curves ', 2, None, '___sec42'),
              (' Observations from the figures ', 2, None, '___sec43'),
              (' Runge-Kutta methods of order 2 and 4; short time series ',
               2,
               None,
               '___sec44'),
              (' Runge-Kutta methods of order 2 and 4; longer time series ',
               2,
               None,
               '___sec45'),
              (' Crank-Nicolson; longer time series ', 2, None, '___sec46'),
              (' Observations of RK and CN methods ', 2, None, '___sec47'),
              (' The Euler-Cromer method; idea ',
               2,
               'vib:model2x2:EulerCromer',
               'vib:model2x2:EulerCromer'),
              (' The Euler-Cromer method; complete formulas ',
               2,
               None,
               '___sec49'),
              (' Equivalence with the scheme for the second-order ODE ',
               2,
               None,
               '___sec50'),
              (' Comparison of the treatment of initial conditions ',
               2,
               None,
               '___sec51'),
              (' A method utilizing a staggered mesh ',
               2,
               'vib:model2x2:staggered',
               'vib:model2x2:staggered'),
              (' Centered differences on a staggered mesh ',
               2,
               None,
               '___sec53'),
              (' Comparison with the scheme for the 2nd-order ODE ',
               2,
               None,
               '___sec54'),
              (' Generalization: damping, nonlinear spring, and external excitation ',
               1,
               'vib:model2',
               'vib:model2'),
              (' A centered scheme for linear damping ',
               2,
               'vib:ode2:fdm:flin',
               'vib:ode2:fdm:flin'),
              (' Initial conditions ', 2, None, '___sec57'),
              (' Linearization via a geometric mean approximation ',
               2,
               'vib:ode2:fdm:fquad',
               'vib:ode2:fdm:fquad'),
              (' A centered scheme for quadratic damping ',
               2,
               None,
               '___sec59'),
              (' Initial condition for quadratic damping ',
               2,
               None,
               '___sec60'),
              (' Algorithm ', 2, None, '___sec61'),
              (' Implementation ', 2, None, '___sec62'),
              (' Verification ', 2, 'vib:ode2:verify', 'vib:ode2:verify'),
              (' Demo program ', 2, None, '___sec64'),
              (' Euler-Cromer formulation ', 2, None, '___sec65'),
              (' Staggered grid ', 2, None, '___sec66'),
              (' Linear damping ', 2, None, '___sec67'),
              (' Quadratic damping ', 2, None, '___sec68'),
              (' Initial conditions ', 2, None, '___sec69')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{u_{\small\mbox{e}}}
\newcommand{\Aex}{A_{\small\mbox{e}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{{\cal O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{{\cal I}_x}
\newcommand{\Iy}{{\cal I}_y}
\newcommand{\Iz}{{\cal I}_z}
\newcommand{\It}{{\cal I}_t}
\newcommand{\setb}[1]{{#1}^0}    % set begin
\newcommand{\sete}[1]{{#1}^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{{#1}^-}
\newcommand{\setr}[1]{{#1}^+}
\newcommand{\seti}[1]{{#1}^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- ------------------- main content ---------------------- -->


<title>Study Guide: Finite difference methods for vibration problems</title>

<center><h1>Study Guide: Finite difference methods for vibration problems</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Sep 9, 2013</h4></center> <!-- date -->
<p>
<!-- !split -->

<h2>Table of contents</h2>

<p>
<a href="#___sec0"> A simple vibration problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model1:fdm"> A centered finite difference scheme; step 1 and 2 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> A centered finite difference scheme; step 3 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> A centered finite difference scheme; step 4 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Computing the first step </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> The computational algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec6"> Operator notation; ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> Operator notation; initial condition </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> Computing \( u' \) </a><br>
<a href="#___sec9"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> Core algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> Plotting </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> Main program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> User interface: command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Running the program </a><br>
<a href="#___sec15"> Verification </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> First steps for testing and debugging </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Checking convergence rates </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Implementational details </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Nose test </a><br>
<a href="#vib:model1:longseries"> Long time simulations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec21"> Effect of the time step on long simulations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> Using a moving plot window </a><br>
<a href="#vib:model1:analysis"> Analysis of the numerical scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Deriving an exact numerical solution; ideas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Deriving an exact numerical solution; calculations (1) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> Deriving an exact numerical; calculations (2) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Polynomial approximation of the phase error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec28"> Plot of the phase error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> Exact discrete solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> Convergence of the numerical scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec31"> Stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec32"> The stability criterion </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> Summary of the analysis </a><br>
<a href="#vib:model2x2"> Alternative schemes based on 1st-order equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec35"> Rewriting 2nd-order ODE as system of two 1st-order ODEs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec36"> The Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec37"> The Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec38"> The Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec39"> Comparison of schemes via Odespy </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec40"> Forward and Backward Euler and Crank-Nicolson </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Phase plane plot of the numerical solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> Plain solution curves </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec43"> Observations from the figures </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec44"> Runge-Kutta methods of order 2 and 4; short time series </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec45"> Runge-Kutta methods of order 2 and 4; longer time series </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> Crank-Nicolson; longer time series </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> Observations of RK and CN methods </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model2x2:EulerCromer"> The Euler-Cromer method; idea </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> The Euler-Cromer method; complete formulas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Equivalence with the scheme for the second-order ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec51"> Comparison of the treatment of initial conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model2x2:staggered"> A method utilizing a staggered mesh </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Centered differences on a staggered mesh </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec54"> Comparison with the scheme for the 2nd-order ODE </a><br>
<a href="#vib:model2"> Generalization: damping, nonlinear spring, and external excitation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:fdm:flin"> A centered scheme for linear damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec57"> Initial conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:fdm:fquad"> Linearization via a geometric mean approximation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec59"> A centered scheme for quadratic damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec60"> Initial condition for quadratic damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec61"> Algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec62"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:verify"> Verification </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec64"> Demo program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec65"> Euler-Cromer formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec66"> Staggered grid </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec67"> Linear damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec68"> Quadratic damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec69"> Initial conditions </a><br>

<p>
<!-- !split -->

<h2>A simple vibration problem  <a name="___sec0"></a></h2>

<p>
$$
\begin{equation}
u''t + \omega^2u = 0,\quad u(0)=I,\ u'(0)=0,\ t\in (0,T]
\thinspace .
\label{vib:model1}
\end{equation}
$$


<p>
Exact solution:

<p>
$$
\begin{equation}
u(t) = I\cos (\omega t)
\thinspace .
\label{vib:model1:uex}
\end{equation}
$$

\( u(t) \) oscillates with constant amplitude \( I \) and
(angular) frequency \( \omega \).
Period: \( P=2\pi/\omega \).

<p>
<!-- !split -->

<h3>A centered finite difference scheme; step 1 and 2 <a name="vib:model1:fdm"></a></h3>

<p>

<ul>
 <p><li> Strategy: follow the <a href="http://tinyurl.com/k3sdbuv/pub/decay-sphinx/main_decay.html#the-forward-euler-scheme">four steps</a> of the finite difference method.</li>
 <p><li> Step 1: Introduce a time mesh, here uniform on \( [0,T] \): \( t_n=n\Delta t \)</li>
 <p><li> Step 2: Let the ODE be satisfied at each mesh point:</li>
</ul>

$$
\begin{equation}
u''(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
\thinspace .
\label{vib:model1:step2}
\end{equation}
$$


<p>
<!-- !split -->

<h3>A centered finite difference scheme; step 3  <a name="___sec2"></a></h3>

<p>
Step 3: Approximate derivative(s) by finite
difference approximation(s).
Very common (standard!) formula for \( u'' \):

<p>
$$
\begin{equation}
u''(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
\label{vib:model1:step3}
\end{equation}
$$


<p>
Use this discrete initial condition together with the ODE at \( t=0 \) to
eliminate \( u^{-1} \) (insert \eqref{vib:model1:step3} in \eqref{vib:model1:step2}):

<p>
$$
\begin{equation}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
\thinspace .
\label{vib:model1:step4a}
\end{equation}
$$


<p>
<!-- !split -->

<h3>A centered finite difference scheme; step 4  <a name="___sec3"></a></h3>

<p>
Step 4: Formulate the computational algorithm.
Assume \( u^{n-1} \) and \( u^n \) are known, solve for unknown \( u^{n+1} \):

<p>
$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
\thinspace .
\label{vib:model1:step4}
\end{equation}
$$


<p>
Nick names for this scheme:
Stormer's
method or <a href="http://en.wikipedia.org/wiki/Velocity_Verlet">Verlet integration</a>.

<p>
<!-- !split -->

<h3>Computing the first step  <a name="___sec4"></a></h3>

<p>

<ul>
  <p><li> The formula breaks down for \( u^1 \) because \( u^{-1} \) is unknown and
    outside the mesh!</li>
  <p><li> And: we have not used the initial condition \( u'(0)=0 \).</li>
</ul>

Discretize \( u'(0)=0 \) by a centered difference
$$
\begin{equation}
\frac{u^1-u^{-1}}{2\Delta t} = 0\quad\Rightarrow\quad u^{-1} = u^1
\thinspace .
\end{equation}
$$


<p>
Inserted in \eqref{vib:model1:step4} for \( n=0 \) gives

<p>
$$
\begin{equation}
u^1 = u^0 - \half \Delta t^2 \omega^2 u^0
\thinspace .
\label{vib:model1:step4b}
\end{equation}
$$


<p>
<!-- !split -->

<h3>The computational algorithm  <a name="___sec5"></a></h3>

<p>

<ol>
 <p><li> \( u^0=I \)</li>
 <p><li> compute \( u^1 \) from \eqref{vib:model1:step4b}</li>
 <p><li> for \( n=1,2,\ldots,N_t-1 \):</li>

<ol>
   <p><li> compute \( u^{n+1} \) from \eqref{vib:model1:step4}</li>
</ol>

</ol>

More precisly expressed in Python:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)  <span style="color: #408080; font-style: italic"># mesh points in time</span>
dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]          <span style="color: #408080; font-style: italic"># constant time step.</span>
u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># solution</span>

u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
u[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> u[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**2*</span>u[<span style="color: #666666">0</span>]
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt):
    u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> <span style="color: #666666">2*</span>u[n] <span style="color: #666666">-</span> u[n<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**2*</span>u[n]
</pre></div>
<p>
Note: <code>w</code> is consistently used for \( \omega \) in my code.

<p>
<!-- !split -->

<h3>Operator notation; ODE  <a name="___sec6"></a></h3>

<p>
With \( [D_tD_t u]^n \) as the finite difference approximation to
\( u''(t_n) \) we can write

<p>
$$
\begin{equation}
[D_tD_t u  + \omega^2 u = 0]^n
\thinspace .
\label{vib:model1:step4:op}
\end{equation}
$$


<p>
\( [D_tD_t u]^n \) means applying a central difference with step \( \Delta t/2 \) twice:

<p>
$$ [D_t(D_t u)]^n = \frac{[D_t u]^{n+1/2} - [D_t u]^{n-1/2}}{\Delta t}$$

which is written out as
$$
\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
$$


<p>
<!-- !split -->

<h3>Operator notation; initial condition  <a name="___sec7"></a></h3>

<p>
$$
\begin{equation}
[u = I]^0,\quad [D_{2t} u = 0]^0,
\end{equation}
$$

where \( [D_{2t} u]^n \) is defined as
$$
\begin{equation}
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
\thinspace .
\end{equation}
$$


<p>
<!-- !split -->

<h3>Computing \( u' \)  <a name="___sec8"></a></h3>

<p>
\( u \) is often displacement/position, \( u' \) is velocity and can be computed by

<p>
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
\thinspace .
\end{equation}
$$


<p>
<!-- !split -->

<h2>Implementation  <a name="___sec9"></a></h2>

<p>
<!-- !split -->

<h3>Core algorithm  <a name="___sec10"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, w, dt, T):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span style="color: #BA2121; font-style: italic">    by a central finite difference method with time step dt.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
    u[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> u[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**2*</span>u[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> <span style="color: #666666">2*</span>u[n] <span style="color: #666666">-</span> u[n<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> dt<span style="color: #666666">**2*</span>w<span style="color: #666666">**2*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>
<p>
<!-- !split -->

<h3>Plotting  <a name="___sec11"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">exact_solution</span>(t, I, w):
    <span style="color: #008000; font-weight: bold">return</span> I<span style="color: #666666">*</span>cos(w<span style="color: #666666">*</span>t)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">visualize</span>(u, t, I, w):
    plot(t, u, <span style="color: #BA2121">&#39;r--o&#39;</span>)
    t_fine <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, t[<span style="color: #666666">-1</span>], <span style="color: #666666">1001</span>)  <span style="color: #408080; font-style: italic"># very fine mesh for u_e</span>
    u_e <span style="color: #666666">=</span> exact_solution(t_fine, I, w)
    hold(<span style="color: #BA2121">&#39;on&#39;</span>)
    plot(t_fine, u_e, <span style="color: #BA2121">&#39;b-&#39;</span>)
    legend([<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
    xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
    ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]
    title(<span style="color: #BA2121">&#39;dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> dt)
    umin <span style="color: #666666">=</span> <span style="color: #666666">1.2*</span>u<span style="color: #666666">.</span>min();  umax <span style="color: #666666">=</span> <span style="color: #666666">-</span>umin
    axis([t[<span style="color: #666666">0</span>], t[<span style="color: #666666">-1</span>], umin, umax])
    savefig(<span style="color: #BA2121">&#39;vib1.png&#39;</span>)
    savefig(<span style="color: #BA2121">&#39;vib1.pdf&#39;</span>)
    savefig(<span style="color: #BA2121">&#39;vib1.eps&#39;</span>)
</pre></div>
<p>
<!-- !split -->

<h3>Main program  <a name="___sec12"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">I <span style="color: #666666">=</span> <span style="color: #666666">1</span>
w <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi
dt <span style="color: #666666">=</span> <span style="color: #666666">0.05</span>
num_periods <span style="color: #666666">=</span> <span style="color: #666666">5</span>
P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>w    <span style="color: #408080; font-style: italic">#  one period</span>
T <span style="color: #666666">=</span> P<span style="color: #666666">*</span>num_periods
u, t <span style="color: #666666">=</span> solver(I, w, dt, T)
visualize(u, t, I, w, dt)
</pre></div>
<p>
<!-- !split -->

<h3>User interface: command line  <a name="___sec13"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">argparse</span>
parser <span style="color: #666666">=</span> argparse<span style="color: #666666">.</span>ArgumentParser()
parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--I&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>, default<span style="color: #666666">=1.0</span>)
parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--w&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>, default<span style="color: #666666">=2*</span>pi)
parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--dt&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">float</span>, default<span style="color: #666666">=0.05</span>)
parser<span style="color: #666666">.</span>add_argument(<span style="color: #BA2121">&#39;--num_periods&#39;</span>, <span style="color: #008000">type</span><span style="color: #666666">=</span><span style="color: #008000">int</span>, default<span style="color: #666666">=5</span>)
a <span style="color: #666666">=</span> parser<span style="color: #666666">.</span>parse_args()
I, w, dt, num_periods <span style="color: #666666">=</span> a<span style="color: #666666">.</span>I, a<span style="color: #666666">.</span>w, a<span style="color: #666666">.</span>dt, a<span style="color: #666666">.</span>num_periods
</pre></div>
<p>
<!-- !split -->

<h3>Running the program  <a name="___sec14"></a></h3>

<p>
<a href="http://tinyurl.com/jvzzcfn/vib/vib_undamped.py"><tt>vib_undamped.py</tt></a>:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
<p>
Generates frames <code>tmp_vib%04d.png</code> in files. Can make movie:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; avconv -r 12 -i tmp_vib%04d.png -vcodec flv movie.flv
</pre></div>
<p>
Can use <code>ffmpeg</code> instead of <code>avconv</code>.

<p>
<table border="1">
<tr><td align="center"><b>                  Format                  </b></td> <td align="center"><b>            Codec and filename            </b></td> </tr>
<tr><td align="left">   Flash                                       </td> <td align="left">   <code>-vcodec flv movie.flv</code>          </td> </tr>
<tr><td align="left">   MP4                                         </td> <td align="left">   <code>-vcodec libx64 movie.mp4</code>       </td> </tr>
<tr><td align="left">   Webm                                        </td> <td align="left">   <code>-vcodec libvpx movie.webm</code>      </td> </tr>
<tr><td align="left">   Ogg                                         </td> <td align="left">   <code>-vcodec libtheora movie.ogg</code>    </td> </tr>
</table>
<p>
<!-- !split -->

<h2>Verification  <a name="___sec15"></a></h2>

<p>
<!-- !split -->

<h3>First steps for testing and debugging  <a name="___sec16"></a></h3>

<p>

<ul>
 <p><li> <b>Testing very simple solutions</b>:
   \( u=\hbox{const} \) or \( u=ct + d \) do not apply here (without a force
   term in the equation: \( u'' + \omega^2u = f \)).</li>
 <p><li> <b>Hand calculations</b>: calculate \( u^1 \) and \( u^2 \) and compare with program.</li>
</ul>

<!-- !split -->

<h3>Checking convergence rates  <a name="___sec17"></a></h3>

<p>
The next function estimates convergence rates, i.e., it

<p>

<ul>
 <p><li> performs \( m \) simulations with halved time steps: \( 2^{-k}\Delta t \), \( k=0,\ldots,m-1 \),</li>
 <p><li> computes the \( L_2 \) norm of the error,
   \( E = \sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-\uex(t_n))^2} \) in each case,</li>
 <p><li> estimates the rates \( r_i \) from two consecutive
   experiments \( (\Delta t_{i-1}, E_{i-1}) \) and \( (\Delta t_{i}, E_{i}) \),
   assuming \( E_i=C\Delta t_i^{r_i} \) and \( E_{i-1}=C\Delta t_{i-1}^{r_i} \):</li>
</ul>

<!-- !split -->

<h3>Implementational details  <a name="___sec18"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_rates</span>(m, num_periods<span style="color: #666666">=8</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Return m-1 empirical estimates of the convergence rate</span>
<span style="color: #BA2121; font-style: italic">    based on m simulations, where the time step is halved</span>
<span style="color: #BA2121; font-style: italic">    for each simulation.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    w <span style="color: #666666">=</span> <span style="color: #666666">0.35</span>; I <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
    dt <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>w<span style="color: #666666">/30</span>  <span style="color: #408080; font-style: italic"># 30 time step per period 2*pi/w</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>w<span style="color: #666666">*</span>num_periods
    dt_values <span style="color: #666666">=</span> []
    E_values <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(m):
        u, t <span style="color: #666666">=</span> solver(I, w, dt, T)
        u_e <span style="color: #666666">=</span> exact_solution(t, I, w)
        E <span style="color: #666666">=</span> sqrt(dt<span style="color: #666666">*</span><span style="color: #008000">sum</span>((u_e<span style="color: #666666">-</span>u)<span style="color: #666666">**2</span>))
        dt_values<span style="color: #666666">.</span>append(dt)
        E_values<span style="color: #666666">.</span>append(E)
        dt <span style="color: #666666">=</span> dt<span style="color: #666666">/2</span>

    r <span style="color: #666666">=</span> [log(E_values[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>E_values[i])<span style="color: #666666">/</span>
         log(dt_values[i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>dt_values[i])
         <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, m, <span style="color: #666666">1</span>)]
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
Result: <code>r</code> contains values equal to 2.00 - as expected!

<p>
<!-- !split -->

<h3>Nose test  <a name="___sec19"></a></h3>

<p>
Use final <code>r[-1]</code> in a unit test:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_convergence_rates</span>():
    r <span style="color: #666666">=</span> convergence_rates(m<span style="color: #666666">=5</span>, num_periods<span style="color: #666666">=8</span>)
    <span style="color: #408080; font-style: italic"># Accept rate to 1 decimal place</span>
    nt<span style="color: #666666">.</span>assert_almost_equal(r[<span style="color: #666666">-1</span>], <span style="color: #666666">2.0</span>, places<span style="color: #666666">=1</span>)
</pre></div>
<p>
Complete code in <a href="http://tinyurl.com/jvzzcfn/vib/vib_undamped.py"><tt>vib_undamped.py</tt></a>.

<p>
<!-- !split -->

<h2>Long time simulations <a name="vib:model1:longseries"></a></h2>

<p>
<!-- !split -->

<h3>Effect of the time step on long simulations  <a name="___sec21"></a></h3>

<p>
<center><p><img src="fig-vib/vib_phase_err1.png" align="bottom" width=800,></p></center>

<p>

<ul>
 <p><li> The numerical solution seems to have right amplitude.</li>
 <p><li> There is a phase error (reduced by reducing the time step).</li>
 <p><li> The total phase error seems to grow with time.</li>
</ul>

<!-- !split -->

<h3>Using a moving plot window  <a name="___sec22"></a></h3>

<p>

<ul>
 <p><li> In long time simulations we need a plot window that follows
   the solution.</li>
 <p><li> Method 1: <code>scitools.MovingPlotWindow</code>.</li>
 <p><li> Method 2: <code>scitools.avplotter</code> (ASCII vertical plotter).</li>
</ul>

Example:
<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
<p>
<a href="http://tinyurl.com/k3sdbuv/pub/mov-vib/vib_undamped_dt0.05/index.html">Movie of the moving plot window</a>.

<p>
<!-- !split -->

<h2>Analysis of the numerical scheme <a name="vib:model1:analysis"></a></h2>

<p>
<!-- !split -->

<h3>Deriving an exact numerical solution; ideas  <a name="___sec24"></a></h3>

<p>

<ul>
  <p><li> Linear, homogeneous, difference equation for \( u^n \).</li>
  <p><li> Has solutions \( u^n \sim A^n \), where \( A \) is unknown (number).</li>
  <p><li> Here: \( \uex(t) =I\cos(\omega t) \sim I\exp{(i\omega t)} = I(e^{i\omega\Delta t})^n \)</li>
  <p><li> Trick for simplifying the algebra: \( u^n = A^n \), with \( A=\exp{(i\tilde\omega\Delta t)} \), then find \( \tilde\omega \)</li>
  <p><li> \( \tilde\omega \): unknown <em>numerical frequency</em> (easier to calculate than \( A \))</li>
  <p><li> \( \omega - \tilde\omega \) is the <em>phase error</em></li>
  <p><li> Use the real part as the physical relevant part of a complex expression</li>
</ul>

<!-- !split -->

<h3>Deriving an exact numerical solution; calculations (1)  <a name="___sec25"></a></h3>

<p>
$$
u^n = A^n = \exp{(\tilde\omega \Delta t\, n)}=\exp{(\tilde\omega t)} =
\cos (\tilde\omega t) + i\sin(\tilde \omega t)
\thinspace .
$$


<p>
$$
\begin{align*}
[D_tD_t u]^n &= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\ 
&= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\ 
&= I\frac{\exp{(i\tilde\omega(t+\Delta t))} - 2\exp{(i\tilde\omega t)} + \exp{(i\tilde\omega(t-\Delta t))}}{\Delta t^2}\\ 
&= I\exp{(i\tilde\omega t)}\frac{1}{\Delta t^2}\left(\exp{(i\tilde\omega(\Delta t))} + \exp{(i\tilde\omega(-\Delta t))} - 2\right)\\ 
&= I\exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\ 
&= I\exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\ 
&= -I\exp{(i\tilde\omega t)}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
\end{align*}
$$


<p>
<!-- !split -->

<h3>Deriving an exact numerical; calculations (2)  <a name="___sec26"></a></h3>

<p>
The scheme \eqref{vib:model1:step4}
with \( u^n=I\exp{(i\omega\tilde\Delta t\, n)} \) inserted gives

<p>
$$
\begin{equation}
-I\exp{(i\tilde\omega t)}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
+ \omega^2 I\exp{(i\tilde\omega t)} = 0,
\end{equation}
$$

which after dividing by \( Io\exp{(i\tilde\omega t)} \) results in
$$
\begin{equation}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
\thinspace .
\end{equation}
$$

Solve for \( \tilde\omega \):
$$
\begin{equation}
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\thinspace .
\label{vib:model1:tildeomega}
\end{equation}
$$


<p>

<ul>
 <p><li> Phase error because \( \tilde\omega \neq \omega \).</li>
 <p><li> But how good is the approximation \( \tilde\omega \) to \( \omega \)?</li>
</ul>

<!-- !split -->

<h3>Polynomial approximation of the phase error  <a name="___sec27"></a></h3>

<p>
Taylor series expansion
for small \( \Delta t \) gives a formula that is easier to understand:

<p>

<!-- code=text (from !bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; dt, w = symbols(&#39;dt w&#39;)
&gt;&gt;&gt; w_tilde = asin(w*dt/2).series(dt, 0, 4)*2/dt
&gt;&gt;&gt; print w_tilde
(dt*w + dt**3*w**3/24 + O(dt**4))/dt  # observe final /dt
</pre></div>
<p>
$$
\begin{equation}
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right) + {\cal O}(\Delta t^3)
\thinspace .
\label{vib:model1:tildeomega:series}
\end{equation}
$$

The numerical frequency is too large (to fast oscillations).

<p>
<!-- !split -->

<h3>Plot of the phase error  <a name="___sec28"></a></h3>

<p>
<center><p><img src="fig-vib/discrete_freq.png" align="bottom" width=600></p></center>

<p>
Recommendation: 25-30 points per period.

<p>
<!-- !split -->

<h3>Exact discrete solution  <a name="___sec29"></a></h3>

<p>
$$
\begin{equation}
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
\thinspace .
\label{vib:model1:un:exact}
\end{equation}
$$


<p>
The error mesh function,

<p>
$$ e^n = \uex(t_n) - u^n =
I\cos\left(\omega n\Delta t\right)
- I\cos\left(\tilde\omega n\Delta t\right)
$$

is ideal for verification and analysis.

<p>
<!-- !split -->

<h3>Convergence of the numerical scheme  <a name="___sec30"></a></h3>

<p>
Can easily show <em>convergence</em>:

<p>
$$ e^n\rightarrow 0 \hbox{ as }\Delta t\rightarrow 0,$$

because

<p>
$$
\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,
$$

by L'Hopital's rule or simply asking
<code>(2/x)*asin(w*x/2) as x->0</code> in <a href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0">WolframAlpha</a>.

<p>
<!-- !split -->

<h3>Stability  <a name="___sec31"></a></h3>

<p>
Observations:

<p>

<ul>
 <p><li> Numerical solution has constant amplitude (desired!), but phase error.</li>
 <p><li> Constant amplitude requires \( \sin^{-1}(\omega\Delta t/2) \) to be
   real-valued \( \Rightarrow \) $|\omega\Delta t/2| \leq 1$.</li>
 <p><li> \( \sin^{-1}(x) \) is complex if \( |x|>1 \), and then \( \tilde\omega \) becomes
   complex.</li>
</ul>

What is the consequence of complex \( \tilde\omega \)?

<p>

<ul>
 <p><li> Set \( \tilde\omega = \tilde\omega_r + i\tilde\omega_i \).</li>
 <p><li> Since \( \sin^{-1}(x) \) has a <a href="http://www.wolframalpha.com/input/?i=arcsin%28x%29%2C+x+in+%280%2C3%29">negative* imaginary part</a> for
   \( x>1 \), \( \exp{(i\omega\tilde t)}=\exp{(-\tilde\omega_i t)}\exp{(i\tilde\omega_r t)} \)
   leads to exponential growth \( e^{-\tilde\omega_it} \)
   when \( -\tilde\omega_i t > 0 \).</li>
 <p><li> This is <em>instability</em> because the qualitative behavior is wrong.</li>
</ul>

<!-- !split -->

<h3>The stability criterion  <a name="___sec32"></a></h3>

<p>
Cannot tolerate growth and must therefore demand a <em>stability criterion</em>
$$
\begin{equation}
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
\Delta t \leq \frac{2}{\omega}
\thinspace .
\end{equation}
$$


<p>
Try \( \Delta t = \frac{2}{\omega} + 9.01\cdot 10^{-5} \) (slightly too big!):

<p>
<center><p><img src="fig-vib/vib_unstable.png" align="bottom" width=400></p></center>

<p>
<!-- !split -->

<h3>Summary of the analysis  <a name="___sec33"></a></h3>

<p>
We can draw three important conclusions:

<p>

<ol>
<p><li> The key parameter in the formulas is \( p=\omega\Delta t \).</li>

<ol>
  <p><li> Period of oscillations: \( P=2\pi/\omega \)</li>
  <p><li> Number of time steps per period: \( N_P=P/\Delta t \)</li>
  <p><li> \( \Rightarrow\ p=\omega\Delta t = 2\pi/ N_P \sim 1/N_P \)</li>
  <p><li> The smallest possible \( N_P \) is 2 \( \Rightarrow \) $p\in (0,\pi]$</li>
</ol>

<p><li> For \( p\leq 2 \) the amplitude of \( u^n \) is constant (stable solution)</li>
<p><li> \( u^n \) has a relative phase error
   \( \tilde\omega/\omega \approx 1 + \frac{1}{24}p^2 \), making numerical
   peaks occur too early</li>
</ol>

<!-- !split -->

<h2>Alternative schemes based on 1st-order equations <a name="vib:model2x2"></a></h2>

<p>
<!-- !split -->

<h3>Rewriting 2nd-order ODE as system of two 1st-order ODEs  <a name="___sec35"></a></h3>

<p>
The vast collection of ODE solvers (e.g., in <a href="https://github.com/hplgit/odespy">Odespy</a>) cannot be applied to
$$ u'' + \omega^2 u = 0$$

unless we write this higher-order ODE as a system of 1st-order ODEs.

<p>
Introduce an auxiliary variable \( v=u' \):

<p>
$$
\begin{align}
u' &= v,
\label{vib:model2x2:ueq}\\ 
v' &= -\omega^2 u
\label{vib:model2x2:veq}
\thinspace .
\end{align}
$$


<p>
Initial conditions: \( u(0)=I \) and \( v(0)=0 \).

<p>
<!-- !split -->

<h3>The Forward Euler scheme  <a name="___sec36"></a></h3>

<p>
We apply the Forward Euler scheme to each component equation:

<p>
$$ [D_t^+ u = v]^n,$$


<p>
$$ [D_t^+ v = -\omega^2 u]^n,$$

or written out,

<p>
$$
\begin{align}
u^{n+1} &= u^n + \Delta t v^n,\\ 
v^{n+1} &= v^n -\Delta t \omega^2 u^n
\thinspace .
\end{align}
$$


<p>
<!-- !split -->

<h3>The Backward Euler scheme  <a name="___sec37"></a></h3>

<p>
We apply the Backward Euler scheme to each component equation:

<p>
$$ [D_t^- u = v]^{n+1},$$


<p>
$$ [D_t^- v = -\omega u]^{n+1} \thinspace . $$

Written out:
$$
\begin{align}
u^{n+1} - \Delta t v^{n+1} = u^{n},\\ 
v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}
\thinspace .
\end{align}
$$

This is a <em>coupled</em> \( 2\times 2 \) system for the new values at \( t=t_{n+1} \)!

<p>
<!-- !split -->

<h3>The Crank-Nicolson scheme  <a name="___sec38"></a></h3>

<p>
$$
[D_t u = \overline{v}^t]^{n+\frac{1}{2}},$$


<p>
$$
[D_t v = -\omega \overline{u}^t]^{n+\frac{1}{2}}$$

The result is also a coupled system:

<p>
$$
\begin{align}
u^{n+1} - \frac{1}{2}\Delta t v^{n+1} &= u^{n} + \frac{1}{2}\Delta t v^{n},\\ 
v^{n+1} + \frac{1}{2}\Delta t \omega^2 u^{n+1} &= v^{n}
- \frac{1}{2}\Delta t \omega^2 u^{n}
\thinspace .
\end{align}
$$


<p>
<!-- !split -->

<h3>Comparison of schemes via Odespy  <a name="___sec39"></a></h3>

<p>
Can use
<a href="https://github.com/hplgit/odespy">Odespy</a> to compare many methods
for first-order schemes:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">odespy</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(u, t, w<span style="color: #666666">=1</span>):
    u, v <span style="color: #666666">=</span> u  <span style="color: #408080; font-style: italic"># u is array of length 2 holding our [u, v]</span>
    <span style="color: #008000; font-weight: bold">return</span> [v, <span style="color: #666666">-</span>w<span style="color: #666666">**2*</span>u]

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">run_solvers_and_plot</span>(solvers, timesteps_per_period<span style="color: #666666">=20</span>,
                         num_periods<span style="color: #666666">=1</span>, I<span style="color: #666666">=1</span>, w<span style="color: #666666">=2*</span>np<span style="color: #666666">.</span>pi):
    P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">/</span>w  <span style="color: #408080; font-style: italic"># one period</span>
    dt <span style="color: #666666">=</span> P<span style="color: #666666">/</span>timesteps_per_period
    Nt <span style="color: #666666">=</span> num_periods<span style="color: #666666">*</span>timesteps_per_period
    T <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt
    t_mesh <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)

    legends <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> solver <span style="color: #AA22FF; font-weight: bold">in</span> solvers:
        solver<span style="color: #666666">.</span>set(f_kwargs<span style="color: #666666">=</span>{<span style="color: #BA2121">&#39;w&#39;</span>: w})
        solver<span style="color: #666666">.</span>set_initial_condition([I, <span style="color: #666666">0</span>])
        u, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(t_mesh)
</pre></div>
<p>
<!-- !split -->

<h3>Forward and Backward Euler and Crank-Nicolson  <a name="___sec40"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">solvers <span style="color: #666666">=</span> [
    odespy<span style="color: #666666">.</span>ForwardEuler(f),
    <span style="color: #408080; font-style: italic"># Implicit methods must use Newton solver to converge</span>
    odespy<span style="color: #666666">.</span>BackwardEuler(f, nonlinear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Newton&#39;</span>),
    odespy<span style="color: #666666">.</span>CrankNicolson(f, nonlinear_solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Newton&#39;</span>),
    ]
</pre></div>
<p>
Two plot types:

<p>

<ul>
  <p><li> \( u(t) \) vs \( t \)</li>
  <p><li> Parameterized curve \( (u(t), v(t)) \) in <em>phase space</em></li>
  <p><li> Exact curve is an ellipse: \( (I\cos\omega t, -\omega I\sin\omega t) \),
    closed and periodic</li>
</ul>

<!-- !split -->

<h3>Phase plane plot of the numerical solutions  <a name="___sec41"></a></h3>

<p>
<center><p><img src="fig-vib/vib_theta_1_pp.png" align="bottom" width=800,></p></center>

<p>
Note: CrankNicolson in Odespy leads to the name MidpointImplicit in plots.

<p>
<!-- !split -->

<h3>Plain solution curves  <a name="___sec42"></a></h3>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Comparison of classical schemes. <a name="vib:model1:1st:odespy:theta"></a> </p></center>
<p><img src="fig-vib/vib_theta_1_u.png" align="bottom" width=800,></p>
</center>

<p>
<!-- !split -->

<h3>Observations from the figures  <a name="___sec43"></a></h3>

<p>

<ul>
  <p><li> Forward Euler has growing amplitude and outward \( (u,v) \) spiral - pumps
    energy into the system.</li>
  <p><li> Backward Euler is opposite: decreasing amplitude, inward sprial,
    extracts energy.</li>
  <p><li> <b>Forward and Backward Euler are useless for vibrations.</b></li>
  <p><li> Crank-Nicolson (MidpointImplicit) looks much better.</li>
</ul>

<!-- !split -->

<h3>Runge-Kutta methods of order 2 and 4; short time series  <a name="___sec44"></a></h3>

<p>
<center><p><img src="fig-vib/vib_RK_1_pp.png" align="bottom" width=800,></p></center>

<p>
<center><p><img src="fig-vib/vib_RK_1_u.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h3>Runge-Kutta methods of order 2 and 4; longer time series  <a name="___sec45"></a></h3>

<p>
<center><p><img src="fig-vib/vib_RK_10_pp.png" align="bottom" width=800,></p></center>

<p>
<center><p><img src="fig-vib/vib_RK_10_u.png" align="bottom" width=800,></p></center>

<p>
<!-- !split -->

<h3>Crank-Nicolson; longer time series  <a name="___sec46"></a></h3>

<p>
<center><p><img src="fig-vib/vib_CN_10_pp.png" align="bottom" width=800,></p></center>

<p>
<center><p><img src="fig-vib/vib_CN_10_u.png" align="bottom" width=800,></p></center>

<p>
(MidpointImplicit means CrankNicolson in Odespy)

<p>
<!-- !split -->

<h3>Observations of RK and CN methods  <a name="___sec47"></a></h3>

<p>

<ul>
  <p><li> 4th-order Runge-Kutta is very accurate, also for large \( \Delta t \).</li>
  <p><li> 2th-order Runge-Kutta is almost as bad as Forward and Backward
    Euler.</li>
  <p><li> Crank-Nicolson is accurate, but the amplitude is not as accurate
    as the difference scheme for \( u''+\omega^2u=0 \).</li>
</ul>

<!-- !split -->

<h3>The Euler-Cromer method; idea <a name="vib:model2x2:EulerCromer"></a></h3>

<p>
Forward-backward discretization of the 2x2 system:

<p>

<ul>
  <p><li> Update \( u \) with Forward Euler</li>
  <p><li> Update \( v \) with Backward Euler, using latest \( u \)</li>
</ul>

$$ [D_t^+u = v]^n,$$


<p>
$$ [D_t^-v = -\omega u]^{n+1}
\thinspace .
$$


<p>
<!-- !split -->

<h3>The Euler-Cromer method; complete formulas  <a name="___sec49"></a></h3>

<p>
Written out:

<p>
$$
\begin{align}
u^0 &= I,\\ 
v^0 &= 0,\\ 
u^{n+1} &= u^n + \Delta t v^n,
\label{vib:model2x2:EulerCromer:ueq1}\\ 
v^{n+1} &= v^n -\Delta t \omega^2u^{n+1}
\label{vib:model2x2:EulerCromer:veq1}
\thinspace .
\end{align}
$$


<p>
Names: Forward-backward scheme, <a href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">Semi-implicit Euler method</a>, symplectic
Euler, semi-explicit Euler, Newton-Stormer-Verlet, and Euler-Cromer.

<p>

<ul>
 <p><li> Forward Euler and Backward Euler have error \( \Oof{\Delta t} \)</li>
 <p><li> What about the overall scheme? Expect \( \Oof{\Delta t} \)...</li>
</ul>

<!-- !split -->

<h3>Equivalence with the scheme for the second-order ODE  <a name="___sec50"></a></h3>

<p>
Goal: eliminate \( v^n \). We have
$$ v^n = v^{n-1} - \Delta t \omega^2u^{n},
$$

which can be inserted in \eqref{vib:model2x2:EulerCromer:ueq1} to yield
$$
\begin{equation}
u^{n+1} = u^n + \Delta t v^{n-1} - \Delta t^2 \omega^2u^{n} .
\label{vib:model2x2:EulerCromer:elim1}
\end{equation}
$$

Using \eqref{vib:model2x2:EulerCromer:ueq1},
$$ v^{n-1} = \frac{u^n - u^{n-1}}{\Delta t},
$$

and when this is inserted in \eqref{vib:model2x2:EulerCromer:elim1} we get
$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Comparison of the treatment of initial conditions  <a name="___sec51"></a></h3>

<p>

<ul>
 <p><li> The Euler-Cromer scheme is nothing but the centered scheme
   for \( u''+\omega^2u=0 \) \eqref{vib:model1:step4}!</li>
 <p><li> The previous analysis of this scheme then also applies to the Euler-Cromer
   method!</li>
 <p><li> What about the initial conditions?</li>
</ul>

$$ u'=v=0\quad\Rightarrow\quad v^0=0,$$

and
\eqref{vib:model2x2:EulerCromer:ueq1} implies \( u^1=u^0 \), while
\eqref{vib:model2x2:EulerCromer:veq1} says \( v^1=-\omega^2 u^0 \).

<p>
This \( u^1=u^0 \) approximation
corresponds to a first-order Forward Euler discretization
of \( u'(0)=0 \): \( [D_t^+ u = 0]^0 \).

<p>
<!-- !split -->

<h3>A method utilizing a staggered mesh <a name="vib:model2x2:staggered"></a></h3>

<p>

<ul>
 <p><li> The Euler-Cromer scheme uses two unsymmetric differences
   in a symmetric way...</li>
 <p><li> We can derive the method from a more pedagogical point of view
   where we use a <em>staggered mesh</em> and only centered differences</li>
</ul>

Staggered mesh:

<p>

<ul>
 <p><li> \( u \) is unknown at mesh points \( t_0,t_1,\ldots,t_n,\ldots \)</li>
 <p><li> \( v \) is unknown at mesh points \( t_{1/2}, t_{3/2},\ldots, t_{n+1/2},\ldots \)
   (between the \( u \) points)</li>
</ul>

<!-- !split -->

<h3>Centered differences on a staggered mesh  <a name="___sec53"></a></h3>

<p>
$$
\begin{align}
\lbrack D_t u &= v\rbrack^{n+\frac{1}{2}},\\ 
\lbrack D_t v &= -\omega u\rbrack^{n+1}
\thinspace .
\end{align}
$$

Written out:

<p>
$$
\begin{align}
u^{n+1} &= u^{n} + \Delta t v^{n+\frac{1}{2}},
\label{vib:model2x2:EulerCromer:ueq1s}\\ 
v^{n+\frac{3}{2}} &= v^{n+\frac{1}{2}} -\Delta t \omega^2u^{n+1}
\label{vib:model2x2:EulerCromer:veq1s}
\thinspace .
\end{align}
$$

or shift one time level back (purely of esthetic reasons):

<p>
$$
\begin{align}
u^{n} &= u^{n-1} + \Delta t v^{n-\frac{1}{2}},
\label{vib:model2x2:EulerCromer:ueq1s2}\\ 
v^{n+\frac{1}{2}} &= v^{n-\frac{1}{2}} -\Delta t \omega^2u^{n}
\label{vib:model2x2:EulerCromer:veq1s2}
\thinspace .
\end{align}
$$


<p>
<!-- !split -->

<h3>Comparison with the scheme for the 2nd-order ODE  <a name="___sec54"></a></h3>

<p>

<ul>
 <p><li> Can eliminate \( v^{n\pm 1/2} \) and get the centered scheme
   for \( u''+\omega^2 u = 0 \)</li>
 <p><li> What about the initial conditions? Their equivalent too!</li>
</ul>

\( u(0)=0 \) and \( u'(0)=v(0)=0 \) give \( u^0=I \) and

<p>
$$ v(0)\approx \frac{1}{2}(v^{-\frac{1}{2}} + v^{\frac{1}{2}}) = 0,
\quad\Rightarrow\quad v^{-\frac{1}{2}} =- v^{\frac{1}{2}}\ts$$

Combined with the scheme on the staggered mesh we get

<p>
$$ u^1 = u^0 - \frac{1}{2}\Delta t^2\omega^2 I,$$


<p>
<!-- !split -->

<h2>Generalization: damping, nonlinear spring, and external excitation <a name="vib:model2"></a></h2>

<p>
$$
\begin{equation}
mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T]
\thinspace .
\label{vib:ode2}
\end{equation}
$$

Input data: \( m \), \( f(u') \), \( s(u) \), \( F(t) \), \( I \), \( V \), and \( T \).

<p>
Typical choices of \( f \) and \( s \):

<p>

<ul>
 <p><li> linear damping \( f(u')=bu \), or</li>
 <p><li> quadratic damping \( f(u')=bu'|u'| \)</li>
 <p><li> linear spring \( s(u)=cu \)</li>
 <p><li> nonlinear spring \( s(u)\sim \sin(u) \) (pendulum)</li>
</ul>

<!-- !split -->

<h3>A centered scheme for linear damping <a name="vib:ode2:fdm:flin"></a></h3>

<p>
$$
\begin{equation}
[mD_tD_t u + f(D_{2t}u) + s(u) = F]^n
\end{equation}
$$

Written out

<p>
$$
\begin{equation}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n
\label{vib:ode2:step3b}
\end{equation}
$$

Assume \( f(u') \) is linear in \( u'=v \):

<p>
$$
\begin{equation}
u^{n+1} = \left(2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
\Delta t^2(F^n - s(u^n))
\right)(m + \frac{b}{2}\Delta t)^{-1}
\label{vib:ode2:step4}
\thinspace .
\end{equation}
$$


<p>
<!-- !split -->

<h3>Initial conditions  <a name="___sec57"></a></h3>

<p>
\( u(0)=I \), \( u'(0)=V \):

<p>
$$
\begin{align}
\lbrack u &=I\rbrack^0\quad\Rightarrow\quad u^0=I,\\ 
\lbrack D_{2t}u &=V\rbrack^0\quad\Rightarrow\quad u^{-1} = u^{1} - 2\Delta t V
\end{align}
$$

End result:

<p>
$$
\begin{equation}
u^1 = u^0 + \Delta t\, V
+ \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
\thinspace .
\label{vib:ode2:step4b}
\end{equation}
$$

Same formula for \( u^1 \) as when using a centered scheme for \( u''+\omega u=0 \).

<p>
<!-- !split -->

<h3>Linearization via a geometric mean approximation <a name="vib:ode2:fdm:fquad"></a></h3>

<p>

<ul>
 <p><li> \( f(u')=bu'|u'| \) leads to a quadratic equation for \( u^{n+1} \)</li>
 <p><li> Instead of solving the quadratic equation, we use a geometric mean
   approximation</li>
</ul>

In general, the geometric mean approximation reads
$$ (w^2)^n \approx w^{n-1/2}w^{n+1/2}\ts$$

For \( |u'|u' \) at \( t_n \):

<p>
$$ [u'|u'|]^n \approx u'(t_n+\frac{1}{2})|u'(t_n-\frac{1}{2})|\ts$$

For \( u' \) at \( t_{n\pm 1/2} \) we use centered difference:

<p>
$$
\begin{equation}
u'(t_{n+1/2})\approx [D_t u]^{n+1/2},\quad u'(t_{n-1/2})\approx [D_t u]^{n-1/2}
\thinspace .
\label{vib:ode2:quad:idea2}
\end{equation}
$$


<p>
<!-- !split -->

<h3>A centered scheme for quadratic damping  <a name="___sec59"></a></h3>

<p>
After some algebra:

<p>
$$
\begin{align}
u^{n+1} &=  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \nonumber\\ 
& \qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - s(u^n))
\right)
\thinspace .
\label{vib:ode2:step4:quad}
\end{align}
$$


<p>
<!-- !split -->

<h3>Initial condition for quadratic damping  <a name="___sec60"></a></h3>

<p>
Simply use that \( u'=V \) in the scheme when \( t=0 \) (\( n=0 \)):

<p>
$$
\begin{equation}
[mD_tD_t u + bV|V| + s(u) = F]^0
\end{equation}
$$


<p>
which gives

<p>
$$
\begin{equation}
u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - s(u^0) + F^0\right)
\thinspace .
\label{vib:ode2:step4b:quad}
\end{equation}
$$


<p>
<!-- !split -->

<h3>Algorithm  <a name="___sec61"></a></h3>

<p>

<ol>
 <p><li> \( u^0=I \)</li>
 <p><li> compute \( u^1 \) from \eqref{vib:ode2:step4b} if linear
    damping or \eqref{vib:ode2:step4b:quad} if quadratic damping</li>
 <p><li> for \( n=1,2,\ldots,N_t-1 \):</li>

<ol>
   <p><li> compute \( u^{n+1} \) from \eqref{vib:ode2:step4} if linear
      damping or \eqref{vib:ode2:step4:quad} if quadratic damping</li>
</ol>

</ol>

<!-- !split -->

<h3>Implementation  <a name="___sec62"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, V, m, b, s, F, dt, T, damping<span style="color: #666666">=</span><span style="color: #BA2121">&#39;linear&#39;</span>):
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt); b <span style="color: #666666">=</span> <span style="color: #008000">float</span>(b); m <span style="color: #666666">=</span> <span style="color: #008000">float</span>(m) <span style="color: #408080; font-style: italic"># avoid integer div.</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> I
    <span style="color: #008000; font-weight: bold">if</span> damping <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;linear&#39;</span>:
        u[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> u[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>V <span style="color: #666666">+</span> dt<span style="color: #666666">**2/</span>(<span style="color: #666666">2*</span>m)<span style="color: #666666">*</span>(<span style="color: #666666">-</span>b<span style="color: #666666">*</span>V <span style="color: #666666">-</span> s(u[<span style="color: #666666">0</span>]) <span style="color: #666666">+</span> F(t[<span style="color: #666666">0</span>]))
    <span style="color: #008000; font-weight: bold">elif</span> damping <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;quadratic&#39;</span>:
        u[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> u[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>V <span style="color: #666666">+</span> \ 
               dt<span style="color: #666666">**2/</span>(<span style="color: #666666">2*</span>m)<span style="color: #666666">*</span>(<span style="color: #666666">-</span>b<span style="color: #666666">*</span>V<span style="color: #666666">*</span><span style="color: #008000">abs</span>(V) <span style="color: #666666">-</span> s(u[<span style="color: #666666">0</span>]) <span style="color: #666666">+</span> F(t[<span style="color: #666666">0</span>]))

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt):
        <span style="color: #008000; font-weight: bold">if</span> damping <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;linear&#39;</span>:
            u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">2*</span>m<span style="color: #666666">*</span>u[n] <span style="color: #666666">+</span> (b<span style="color: #666666">*</span>dt<span style="color: #666666">/2</span> <span style="color: #666666">-</span> m)<span style="color: #666666">*</span>u[n<span style="color: #666666">-1</span>] <span style="color: #666666">+</span>
                      dt<span style="color: #666666">**2*</span>(F(t[n]) <span style="color: #666666">-</span> s(u[n])))<span style="color: #666666">/</span>(m <span style="color: #666666">+</span> b<span style="color: #666666">*</span>dt<span style="color: #666666">/2</span>)
        <span style="color: #008000; font-weight: bold">elif</span> damping <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;quadratic&#39;</span>:
            u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">2*</span>m<span style="color: #666666">*</span>u[n] <span style="color: #666666">-</span> m<span style="color: #666666">*</span>u[n<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> b<span style="color: #666666">*</span>u[n]<span style="color: #666666">*</span><span style="color: #008000">abs</span>(u[n] <span style="color: #666666">-</span> u[n<span style="color: #666666">-1</span>])
                      <span style="color: #666666">+</span> dt<span style="color: #666666">**2*</span>(F(t[n]) <span style="color: #666666">-</span> s(u[n])))<span style="color: #666666">/</span>\ 
                      (m <span style="color: #666666">+</span> b<span style="color: #666666">*</span><span style="color: #008000">abs</span>(u[n] <span style="color: #666666">-</span> u[n<span style="color: #666666">-1</span>]))
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>
<p>
<!-- !split -->

<h3>Verification <a name="vib:ode2:verify"></a></h3>

<p>

<ul>
 <p><li> Constant solution \( \uex = I \) (\( V=0 \)) fulfills the ODE problem
   and the discrete equations. Ideal for debugging!</li>
 <p><li> Linear solution \( \uex = Vt+I \) fulfills the ODE problem and
   the discrete equations.</li>
 <p><li> Quadratic solution \( \uex = bt^2 + Vt + I \) fulfills the ODE
   problem and the discrete equations with linear damping, but not
   for quadratic damping.
   A special discrete source term can allow \( \uex \) to also fulfill
   the discrete equations with quadratic damping.</li>
</ul>

<!-- !split -->

<h3>Demo program  <a name="___sec64"></a></h3>

<p>
<a href="http://tinyurl.com/jvzzcfn/vib/vib.py"><tt>vib.py</tt></a> supports input via the command line:

<p>

<!-- code=bash (from !bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python vib.py --s <span style="color: #BA2121">&#39;sin(u)&#39;</span> --F <span style="color: #BA2121">&#39;3*cos(4*t)&#39;</span> --c 0.03
</pre></div>
<p>
This results in a <a href="http://tinyurl.com/k3sdbuv/pub/mov-vib/vib_generalized_dt0.05/index.html">moving window following the function</a> on the screen.

<p>
<center><p><img src="fig-vib/vib_gen_demo.png" align="bottom" width=600,></p></center>

<p>
<!-- !split -->

<h3>Euler-Cromer formulation  <a name="___sec65"></a></h3>

<p>
We rewrite

<p>
$$
\begin{equation}
mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T],
\end{equation}
$$

as a first-order ODE system

<p>
$$
\begin{align}
u' &= v,
\label{vib:ode2:staggered:ueq} \\ 
v' &= m^{-1}\left(F(t) - f(v) - s(u)\right)\ts
\label{vib:ode2:staggered:veq}
\end{align}
$$


<p>
<!-- !split -->

<h3>Staggered grid  <a name="___sec66"></a></h3>

<p>

<ul>
 <p><li> \( u \) is unknown at \( t_n \): \( u^n \)</li>
 <p><li> \( v \) is unknown at \( t_{n+1/2} \): \( v^{n+\frac{1}{2}} \)</li>
 <p><li> All derivatives are approximated by centered differences</li>
</ul>

$$
\begin{align}
\lbrack D_t u &= v\rbrack^{n-1/2},
\label{vib:ode2:staggered:dueq} \\ 
\lbrack D_tv &= m^{-1}\left(F(t) - f(v) - s(u)\right)\rbrack^n\ts
\label{vib:ode2:staggered:dveq}
\end{align}
$$


<p>
Written out,

<p>
$$
\begin{align}
\frac{u^n - u^{n-1}}{\Delta t} &= v^{n-\frac{1}{2}},
\label{vib:ode2:staggered:dueq2} \\ 
\frac{v^{n+\frac{1}{2}} - v^{n-\frac{1}{2}}}{\Delta t}
&= m^{-1}\left(F^n - f(v^n) - s(u^n)\right)\ts
\label{vib:ode2:staggered:dveq2}
\end{align}
$$


<p>
Problem: \( f(v^n) \)

<p>
<!-- !split -->

<h3>Linear damping  <a name="___sec67"></a></h3>

<p>
With \( f(v)=bv \), we can use an arithmetic mean for \( bv^n \) a la
Crank-Nicolson schemes.

<p>
$$
\begin{align*}
u^n & = u^{n-1} + {\Delta t}v^{n-\frac{1}{2}},\\ 
v^{n+\frac{1}{2}} &= \left(1 + \frac{b}{2m}\Delta t\right)^{-1}\left(
v^{n-\frac{1}{2}} + {\Delta t}
m^{-1}\left(F^n - \frac{1}{2}f(v^{n-\frac{1}{2}}) - s(u^n)\right)\right)\ts
\end{align*}
$$


<p>
<!-- !split -->

<h3>Quadratic damping  <a name="___sec68"></a></h3>

<p>
With \( f(v)=b|v|v \), we can use a geometric mean

<p>
$$
b|v^n|v^n\approx b|v^{n-\frac{1}{2}}|v^{n+\frac{1}{2}},
$$

resulting in

<p>
$$
\begin{align*}
u^n & = u^{n-1} + {\Delta t}v^{n-\frac{1}{2}},\\ 
v^{n+\frac{1}{2}} &= (1 + \frac{b}{m}|v^{n-1/2}|\Delta t)^{-1}\left(
v^{n-\frac{1}{2}} + {\Delta t}
m^{-1}\left(F^n - s(u^n)\right)\right)\ts
\end{align*}
$$


<p>
<!-- !split -->

<h3>Initial conditions  <a name="___sec69"></a></h3>

<p>
$$
\begin{align}
u^0 &= I,
\label{vib:ode2:staggered:u0}\\ 
v^{\frac{1}{2}} &= V - \frac{1}{2}\Delta t\omega^2I
\label{vib:ode2:staggered:v0}\ts
\end{align}
$$


<p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

