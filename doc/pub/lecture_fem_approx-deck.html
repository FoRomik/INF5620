<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study Guide: Approximation of functions with finite elements">
<meta name="keywords" content="approximation of general vectors,Galerkin method,projection,approximation of functions,approximation by sines,collocation method (approximation),approximation collocation,Lagrange (interpolating) polynomial,sparse matrices">







<!-- deck.js: https://github.com/imakewebthings/deck.js -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=1024, user-scalable=no">

<!-- Required stylesheet -->
<link rel="stylesheet" href="deck.js/core/deck.core.css">

<!-- Extension CSS files go here. Remove or add as needed.
deck.goto: Adds a shortcut key to jump to any slide number.
Hit g, type in the slide number, and hit enter.

deck.hash: Enables internal linking within slides, deep
linking to individual slides, and updates the address bar and
a permalink anchor with each slide change.

deck.menu: Adds a menu view, letting you see all slides in a grid.
Hit m to toggle to menu view, continue navigating your deck,
and hit m to return to normal view. Touch devices can double-tap
the deck to switch between views.

deck.navigation: Adds clickable left and right buttons for the
less keyboard inclined.

deck.status: Adds a page number indicator. (current/total).

deck.scale: Scales each slide to fit within the deck container
using CSS Transforms for those browsers that support them.

deck.pointer: Turn mouse into laser pointer (toggle with p).
(Requires https://github.com/mikeharris100/deck.pointer.js)
-->

<link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
<link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
<link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">
<link rel="stylesheet" href="deck.js/extensions/pointer/deck.pointer.css">
<link rel="stylesheet" href="deck.js/extensions/notes/deck.notes.css">
<!--
<link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
<link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
<link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
-->

<!-- Style theme. More available in themes/style/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">

<!--
<link rel="stylesheet" href="deck.js/themes/style/neon.css">
<link rel="stylesheet" href="deck.js/themes/style/swiss.css">
<link rel="stylesheet" href="deck.js/themes/style/web-2.0.css">

git clone git://github.com/duijf/mnml.git
<link rel="stylesheet" href="deck.js/themes/style/mnml.css">

git://github.com/groovecoder/deckjs-theme-mozilla.git
<link rel="stylesheet" href="deck.js/themes/style/sandstone.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.aurora.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.dark.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.firefox.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.light.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.mdn.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.nightly.css">

git://github.com/barraq/deck.ext.js.git
<link rel="stylesheet" href="deck.js/themes/style/beamer.css">
-->

<!-- Transition theme. More available in /themes/transition/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
<!--
<link rel="stylesheet" href="deck.js/themes/transition/fade.css">
<link rel="stylesheet" href="deck.js/themes/transition/vertical-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
-->

<!-- Required Modernizr file -->
<script src="deck.js/modernizr.custom.js"></script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .slide .alert-text-small   { font-size: 80%;  }
    .slide .alert-text-large   { font-size: 130%; }
    .slide .alert-text-normal  { font-size: 90%;  }
    .slide .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
               -webkit-border-radius:14px; -moz-border-radius:14px;
             border-radius:14px
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .slide .alert-block {padding-top:14px; padding-bottom:14px}
     .slide .alert-block > p, .alert-block > ul {margin-bottom:0}
     /*.slide .alert li {margin-top: 1em}*/
     .deck .alert-block p+p {margin-top:5px}
     /*.slide .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_notice.png); }
     .slide .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_summary.png); }
     .slide .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_warning.png); }
     .slide .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body class="deck-container">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
%\newcommand{\If}{\mathcal{I}}     % for FEM
\newcommand{\If}{I}     % for FEM
%\newcommand{\Ifd}{\mathcal{I}_d}  % for FEM
\newcommand{\Ifd}{I_d}  % for FEM
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    



<section class="slide">
<!-- ------------------- main content ---------------------- -->


<title>Study Guide: Approximation of functions with finite elements</title>

<center><h1>Study Guide: Approximation of functions with finite elements</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b style="font-weight: bold">Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b style="font-weight: bold">Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b style="font-weight: bold">Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Oct 16, 2013</h4></center> <!-- date -->
<p>

</section>


<section class="slide">

<h2>Why finite elements?  <a name="___sec0"></a></h2>

<p>

<ul>
 <p><li> Can with ease solve PDEs in domains with <em>complex geometry</em></li>
 <p><li> Can with ease provide higher-order approximations</li>
 <p><li> Has (in simpler stationary problems) a rigorus mathematical
   analysis framework (not much considered here)
<!-- The theoretical framework is not powerful enough to uncover the -->
<!-- serious limitations of the method in time-dependent problems -->
<!-- and the necessary adjustments) --></li>
</ul>
<p>


</section>


<section class="slide">

<h3>Domain for flow around a dolphin  <a name="___sec1"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_mesh.png" align="bottom" width=400,></p></center>

<p>

</section>


<section class="slide">

<h3>The flow  <a name="___sec2"></a></h3>

<p>
<center><p><img src="fig-fem/dolfin_flow.gif" align="bottom" width=400,></p></center>

<p>

</section>


<section class="slide">

<h3>Basic ingredients of the finite element method  <a name="___sec3"></a></h3>

<p>

<ul>
 <p><li> Transform the PDE problem to a <em>variational form</em></li>
 <p><li> Define function approximation over <em>finite elements</em></li>
 <p><li> Use a machinery to derive <em>linear systems</em></li>
 <p><li> Solve linear systems</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Our learning strategy  <a name="___sec4"></a></h3>

<p>

<ul>
 <p><li> Start with approximation of functions, not PDEs</li>
 <p><li> Introduce finite element <em>approximations</em></li>
 <p><li> See later how this is applied to PDEs</li>
</ul>
<p>

Reason: the finite element method has many concepts and a jungle of details.
This strategy minimizes the mixing of ideas, concepts, and technical details.

<p>

</section>


<section class="slide">

<h3>Approximation set-up  <a name="___sec5"></a></h3>

<p>
General idea of finding an approximation \( u(x) \) to some given \( f(x) \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
 u(x) = \sum_{i=0}^N c_i\baspsi_i(x)
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>


<p>
where

<p>

<ul>
 <p><li> \( \baspsi_i(x) \) are prescribed functions</li>
 <p><li> \( c_i \), \( i=0,\ldots,N \) are unknown coefficients to be determined</li>
</ul>
<p>


</section>


<section class="slide">

<h3>How to determine the coefficients?  <a name="___sec6"></a></h3>

<p>
We shall address three approaches:

<p>

<ul>
 <p><li> The least squares method</li>
 <p><li> The projection (or Galerkin) method</li>
 <p><li> The interpolation (or collocation) method</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal"><b style="font-weight: bold">Underlying motivation for our notation.</b>
Our mathematical framework for doing this is phrased in a way such
that it becomes easy to understand and use the <a href="http://fenicsproject.org">FEniCS</a> software package for finite element computing.
</div>
<p>

</section>


<section class="slide">

<h3>Approximation of planar vectors; problem <a name="fem:approx:vec:plane"></a></h3>

<p>
Given a vector \( \f = (3,5) \), find an approximation
to \( \f \) directed along a given line.

<p>
<center><p><img src="fig-fem/vecapprox_plane.png" align="bottom" width=300></p></center>

<p>

</section>


<section class="slide">

<h3>Approximation of planar vectors; vector space terminology  <a name="___sec8"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
V = \mbox{span}\,\{ \psib_0\}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( \psib_0 \) is a basis vector in the space \( V \)</li>
 <p><li> Seek \( \u = c_0\psib_0\in V \)</li>
 <p><li> Determine \( c_0 \) such that \( \u \) is the "best" approximation to \( \f \)</li>
 <p><li> Visually, "best" is obvious</li>
</ul>
<p>

Define

<p>

<ul>
 <p><li> the error \( \e = \f - \u \)</li>
 <p><li> the (Eucledian) scalar product of two vectors: \( (\u,\v) \)</li>
 <p><li> the norm of \( \e \): \( ||\e|| = \sqrt{(\e, \e)} \)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>The least squares method; principle  <a name="___sec9"></a></h3>

<p>

<ul>
 <p><li> Idea: find \( c_0 \) such that \( ||\e|| \) is minimized</li>
 <p><li> Actually, we always minimize \( E=||\e||^2 \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_0} = 0
\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The least squares method; calculations  <a name="___sec10"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
E(c_0) = (\e,\e) = (\f,\f) - 2c_0(\f,\psib_0) + c_0^2(\psib_0,\psib_0)
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\psib_0) + 2c_0 (\psib_0,\psib_0) = 0
\tag{2}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = \frac{(\f,\psib_0)}{(\psib_0,\psib_0)}
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = \frac{3a + 5b}{a^2 + b^2}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Observation for later: the vanishing derivative <a href="#mjx-eqn-2">(2)</a>
can be alternatively written as

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\e, \psib_0) = 0
\tag{4}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The projection (or Galerkin) method  <a name="___sec11"></a></h3>

<p>

<ul>
 <p><li> Backgrund: minimizing \( ||\e||^2 \) implies that \( \e \) is
   orthogonal to <em>any</em> vector \( \v \) in the space \( V \)
   (visually clear, but can easily be computed too)</li>
 <p><li> Alternative idea: demand \( (\e, \v) = 0,\quad\forall\v\in V \)</li>
 <p><li> Equivalent statement: \( (\e, \psib_0)=0 \) (see notes for why)</li>
 <p><li> Insert \( \e = \f - c_0\psib_0 \) and solve for \( c_0 \)</li>
 <p><li> Same equation for \( c_0 \) and hence same solution as in the least squares
   method</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Approximation of general vectors <a name="fem:approx:vec:Np1dim"></a></h3>

<p>
Given a vector \( \f \), find an approximation \( \u\in V \):

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\psib_0,\ldots,\psib_N\}
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> We have a set of linearly independent basis vectors
   \( \psib_0,\ldots,\psib_N \)</li>
 <p><li> Any \( \u\in V \) can then be written as \( \u = \sum_{j=0}^Nc_j\psib_j \)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>The least squares method  <a name="___sec13"></a></h3>

<p>
Idea: find \( c_0,\ldots,c_N \) such that \( E= ||\e||^2 \) is minimized, \( \e=\f-\u \).

<p>
<p>&nbsp;<br>
$$
\begin{align*}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\psib_j,\f -\sum_jc_j\psib_j)
\nonumber\\ 
&= (\f,\f) - 2\sum_{j=0}^Nc_j(\f,\psib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)
\end{align*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\end{equation*}
$$
<p>&nbsp;<br>


<p>
After some work we end up with a <em>linear system</em>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j=0}^N A_{i,j}c_j &= b_i,\quad i=0,\ldots,N\\ 
A_{i,j} &= (\psib_i,\psib_j)\\ 
b_i &= (\psib_i, \f)
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The projection (or Galerkin) method  <a name="___sec14"></a></h3>

<p>
Can be shown that minimizing \( ||\e|| \) implies that
\( \e \) is orthogonal to all \( \v\in V \):

<p>
<p>&nbsp;<br>
$$
(\e,\v)=0,\quad \forall\v\in V
$$
<p>&nbsp;<br>

which implies that \( \e \) most be orthogonal to each basis vector:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(\e,\psib_i)=0,\quad i=0,\ldots,N
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>


<p>
This orthogonality condition is the principle of the projection
(or Galerkin) method. Leads to
the same linear system as in the least squares method.

<p>

</section>


<section class="slide">

<h2>Approximation of functions <a name="fem:approx:global"></a></h2>

<p>
Let \( V \) be a <em>function space</em> spanned by a set of <em>basis functions</em>
\( \baspsi_0,\ldots,\baspsi_N \),

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{\baspsi_0,\ldots,\baspsi_N\}
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Find \( u\in V \) as a linear
combination of the basis functions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u = \sum_{j\in\If} c_j\baspsi_j,\quad\If = \{0,1,\ldots,N\}
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The least squares method <a name="fem:approx:LS"></a></h3>

<p>

<ul>
 <p><li> Extend the ideas from the vector case: minimize the (square) norm
   of the error.</li>
 <p><li> What norm? \( (f,g) = \int_\Omega f(x)g(x)\, dx \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
E = (e,e) = (f-u,f-u) = (f(x)-\sum_{j\in\If} c_j\baspsi_j(x), f(x)-\sum_{j\in\If} c_j\baspsi_j(x))
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
E(c_0,\ldots,c_N) = (f,f) -2\sum_{j\in\If} c_j(f,\baspsi_i)
+ \sum_{p\in\If}\sum_{q\in\If} c_pc_q(\baspsi_p,\baspsi_q)
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=\in\If
\end{equation*}
$$
<p>&nbsp;<br>


<p>
After computations <em>identical to the vector case</em>, we get a linear system

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j\in\If}^N A_{i,j}c_j &= b_i,\quad i\in\If
\tag{8}\\ 
A_{i,j} &= (\baspsi_i,\baspsi_j)
\tag{9}\\ 
b_i &= (f,\baspsi_i)
\tag{10}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The projection (or Galerkin) method  <a name="___sec17"></a></h3>

<p>
As before, minimizing \( (e,e) \) is equivalent to the projection (or Galerkin)
method

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(e,v)=0,\quad\forall v\in V
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>

which means, as before,

<p>
<p>&nbsp;<br>
$$
\begin{equation}
(e,\baspsi_i)=0,\quad i\in\If
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>


<p>
With the same algebra as in the multi-dimensional vector case,
we get the same linear system as arose from the least squares method.

<p>

</section>


<section class="slide">

<h3>Example: linear approximation; problem <a name="fem:approx:global:linear"></a></h3>

<p>
<div class="alert alert-block alert-block alert-text-normal"><b style="font-weight: bold">Problem.</b>
Approximate a parabola \( f(x) = 10(x-1)^2 - 1 \) by a straight line.
</div>
<p>
<p>&nbsp;<br>
$$
\begin{equation*} V = \hbox{span}\,\{1, x\}  \end{equation*}
$$
<p>&nbsp;<br>

That is, \( \baspsi_0(x)=1 \), \( \baspsi_1(x)=x \), and \( N=1 \).
We seek

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
u=c_0\baspsi_0(x) + c_1\baspsi_1(x) = c_0 + c_1x
\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Example: linear approximation; solution  <a name="___sec19"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
A_{0,0} &= (\baspsi_0,\baspsi_0) = \int_1^21\cdot 1\, dx = 1\\ 
A_{0,1} &= (\baspsi_0,\baspsi_1) = \int_1^2 1\cdot x\, dx = 3/2\\ 
A_{1,0} &= A_{0,1} = 3/2,\\ 
A_{1,1} &= (\baspsi_1,\baspsi_1) = \int_1^2 x\cdot x\,dx = 7/3
\end{align}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{align}
b_1 &= (f,\baspsi_0) = \int_1^2 (10(x-1)^2 - 1)\cdot 1 \, dx = 7/3\\ 
b_2 &= (f,\baspsi_1) = \int_1^2 (10(x-1)^2 - 1)\cdot x\, dx = 13/3
\end{align}
$$
<p>&nbsp;<br>

Solution of 2x2 linear system:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_0 = -38/3,\quad c_1 = 10,\quad u(x) = 10x - \frac{38}{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Example: linear approximation; plot  <a name="___sec20"></a></h3>

<p>
<center><p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h3>Implementation of the least squares method; ideas <a name="fem:approx:global:LS:code"></a></h3>

<p>
Consider symbolic computation of the linear system,
where

<p>

<ul>
 <p><li> \( f(x) \) is given as a <code>sympy</code> expression <code>f</code> (involving
   the symbol <code>x</code>),</li>
 <p><li> <code>phi</code> is a list of \( \sequencei{\baspsi} \),</li>
 <p><li> <code>Omega</code> is a 2-tuple/list holding the domain \( \Omega \)</li>
</ul>
<p>

Carry out the integrations, solve the linear system, and
return \( u(x)=\sum_jc_j\baspsi_j(x) \)

<p>

</section>


<section class="slide">

<h3>Implementation of the least squares method; code  <a name="___sec22"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">least_squares</span>(f, phi, Omega):
    N = <span style="color: #658b00">len</span>(phi) - <span style="color: #B452CD">1</span>
    A = sm.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sm.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(i, N+<span style="color: #B452CD">1</span>):
            A[i,j] = sm.integrate(phi[i]*phi[j],
                                  (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
            A[j,i] = A[i,j]
        b[i,<span style="color: #B452CD">0</span>] = sm.integrate(phi[i]*f, (x, Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>]))
    c = A.LUsolve(b)
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(phi)):
        u += c[i,<span style="color: #B452CD">0</span>]*phi[i]
    <span style="color: #8B008B; font-weight: bold">return</span> u
</code></pre></div>
<p>
Observe: symmetric coefficient matrix so we can halve the integrations.

<p>

</section>


<section class="slide">

<h3>Implementation of the least squares method; plotting  <a name="___sec23"></a></h3>

<p>
Compare \( f \) and \( u \) visually:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">comparison_plot</span>(f, u, Omega, filename=<span style="color: #CD5555">&#39;tmp.pdf&#39;</span>):
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #228B22"># Turn f and u to ordinary Python functions</span>
    f = sm.lambdify([x], f, modules=<span style="color: #CD5555">&quot;numpy&quot;</span>)
    u = sm.lambdify([x], u, modules=<span style="color: #CD5555">&quot;numpy&quot;</span>)
    resolution = <span style="color: #B452CD">401</span>  <span style="color: #228B22"># no of points in plot</span>
    xcoor  = linspace(Omega[<span style="color: #B452CD">0</span>], Omega[<span style="color: #B452CD">1</span>], resolution)
    exact  = f(xcoor)
    approx = u(xcoor)
    plot(xcoor, approx)
    hold(<span style="color: #CD5555">&#39;on&#39;</span>)
    plot(xcoor, exact)
    legend([<span style="color: #CD5555">&#39;approximation&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>])
    savefig(filename)
</code></pre></div>
<p>
All code in module <a href="http://tinyurl.com/jvzzcfn/fem/approx1D.py"><tt>approx1D.py</tt></a>

<p>

</section>


<section class="slide">

<h3>Implementation of the least squares method; application  <a name="___sec24"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>-<span style="color: #B452CD">1</span>
&gt;&gt;&gt; u = least_squares(f=f, phi=[<span style="color: #B452CD">1</span>, x], Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
&gt;&gt;&gt; comparison_plot(f, u, Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
</code></pre></div>
<p>
<center><p><img src="fig-fem/parabola_ls_linear.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h3>Perfect approximation; parabola approximating parabola <a name="fem:approx:global:exact"></a></h3>

<p>

<ul>
 <p><li> What if we add \( \baspsi_2=x^2 \) to the space \( V \)?</li>
 <p><li> That is, approximating a parabola by any parabola?</li>
 <p><li> (Hopefully we get the exact parabola!)</li>
</ul>
<p>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span>-<span style="color: #B452CD">1</span>
&gt;&gt;&gt; u = least_squares(f=f, phi=[<span style="color: #B452CD">1</span>, x, x**<span style="color: #B452CD">2</span>], Omega=[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>])
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> u
<span style="color: #B452CD">10</span>*x**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">20</span>*x + <span style="color: #B452CD">9</span>
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sm.expand(f)
<span style="color: #B452CD">10</span>*x**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">20</span>*x + <span style="color: #B452CD">9</span>
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Perfect approximation; the general result  <a name="___sec26"></a></h3>

<p>

<ul>
 <p><li> What if we use \( \phi_i(x)=x^i \) for \( i=0,\ldots,N=40 \)?</li>
 <p><li> The output from <code>least_squares</code> is \( c_i=0 \) for \( i>2 \)</li>
</ul>
<p>

<div class="alert alert-block alert-block alert-text-normal"><b style="font-weight: bold">General result.</b>
If \( f\in V \), least squares and projection/Galerkin give \( u=f \).
</div>
<p>

</section>


<section class="slide">

<h3>Perfect approximation; proof of the general result  <a name="___sec27"></a></h3>

<p>
If \( f\in V \), \( f=\sum_{j\in\If}d_j\baspsi_j \), for
some  \( \sequencei{d} \). Then

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
b_i = (f,\baspsi_i) = \sum_{j\in\If}d_j(\baspsi_j, \baspsi_i)
= \sum_{j\in\If} d_jA_{i,j}
\end{equation*}
$$
<p>&nbsp;<br>

The linear system \( \sum_j A_{i,j}c_j = b_i \), \( i\in\If \), is then

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
\sum_{j\in\If}c_jA_{i,j} = \sum_{j\in\If}d_jA_{i,j},\quad i\in\If
\end{equation*}
$$
<p>&nbsp;<br>

which implies that \( c_i=d_i \) for \( i\in\If \) and \( u \) is identical to \( f \).

<p>

</section>


<section class="slide">

<h3>Finite-precision/numerical computations <a name="fem:approx:global:illconditioning"></a></h3>

<p>
The previous computations were symbolic. What if we solve the
linear system numerically with standard arrays?

<p>
<table border="1">
<tr><td align="center"><b style="font-weight: bold">        exact         </b></td> <td align="center"><b style="font-weight: bold">  <code>sympy</code>  </b></td> <td align="center"><b style="font-weight: bold"> <code>numpy32</code> </b></td> <td align="center"><b style="font-weight: bold"> <code>numpy64</code> </b></td> </tr>
<tr><td align="right">   9                       </td> <td align="right">   9.62                    </td> <td align="right">   5.57                    </td> <td align="right">   8.98                    </td> </tr>
<tr><td align="right">   -20                     </td> <td align="right">   -23.39                  </td> <td align="right">   -7.65                   </td> <td align="right">   -19.93                  </td> </tr>
<tr><td align="right">   10                      </td> <td align="right">   17.74                   </td> <td align="right">   -4.50                   </td> <td align="right">   9.96                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -9.19                   </td> <td align="right">   4.13                    </td> <td align="right">   -0.26                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   5.25                    </td> <td align="right">   2.99                    </td> <td align="right">   0.72                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.18                    </td> <td align="right">   -1.21                   </td> <td align="right">   -0.93                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -2.48                   </td> <td align="right">   -0.41                   </td> <td align="right">   0.73                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   1.81                    </td> <td align="right">   -0.013                  </td> <td align="right">   -0.36                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.66                   </td> <td align="right">   0.08                    </td> <td align="right">   0.11                    </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   0.12                    </td> <td align="right">   0.04                    </td> <td align="right">   -0.02                   </td> </tr>
<tr><td align="right">   0                       </td> <td align="right">   -0.001                  </td> <td align="right">   -0.02                   </td> <td align="right">   0.002                   </td> </tr>
</table>
<p>

<ul>
  <p><li> Column 2: <code>sympy.mpmath.fp.matrix</code> and <code>sympy.mpmath.fp.lu_solve</code></li>
  <p><li> Column 3: <code>numpy</code> arrays with <code>numpy.float32</code> entries</li>
  <p><li> Column 4: <code>numpy</code> arrays with <code>numpy.float64</code> entries</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Ill-conditioning (1)  <a name="___sec29"></a></h3>

<p>
Observations:

<p>

<ul>
 <p><li> Significant round-off errors in the numerical computations (!)</li>
 <p><li> But if we plot the approximations they look good (!)</li>
</ul>
<p>

Problem: The basis functions \( x^i \) become almost linearly dependent for
large \( N \).

<p>
<center><p><img src="fig-fem/ill_conditioning.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h3>Ill-conditioning (2)  <a name="___sec30"></a></h3>

<p>

<ul>
  <p><li> Almost linearly dependent basis functions give almost singular matrices</li>
  <p><li> Such matrices are said to be <em>ill conditioned</em>, and Gaussian elimination
    is severely affected by round-off errors</li>
  <p><li> The basis \( 1, x, x^2, x^3, x^4, \ldots \) is a bad basis</li>
  <p><li> Polynomials are fine as basis, but the more orthogonal they are,
    \( (\baspsi_i,\baspsi_j)\approx 0 \), the better</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Fourier series approximation; problem and code <a name="fem:approx:global:Fourier"></a></h3>

<p>
Consider

<p>
<p>&nbsp;<br>
$$
\begin{equation*}
V = \hbox{span}\,\{ \sin \pi x, \sin 2\pi x,\ldots,\sin (N+1)\pi x\}
\end{equation*}
$$
<p>&nbsp;<br>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">N = <span style="color: #B452CD">3</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> sin, pi
phi = [sin(pi*(i+<span style="color: #B452CD">1</span>)*x) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]
f = <span style="color: #B452CD">10</span>*(x-<span style="color: #B452CD">1</span>)**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">1</span>
Omega = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>]
u = least_squares(f, phi, Omega)
comparison_plot(f, u, Omega)
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Fourier series approximation; plot  <a name="___sec32"></a></h3>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-fem/parabola_ls_sines4_12.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Fourier series approximation; improvements  <a name="___sec33"></a></h3>

<p>

<ul>
 <p><li> Considerably improvement by \( N=11 \)</li>
 <p><li> But always discrepancy of \( f(0)-u(0)=9 \) at \( x=0 \), because all the
   \( \baspsi_i(0)=0 \) and hence \( u(0)=0 \)</li>
 <p><li> Possible remedy: add a term that leads to correct boundary values</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
u(x) = f(0)(1-x) + xf(1) + \sum_{j\in\If} c_j\baspsi_j(x)
\end{equation}
$$
<p>&nbsp;<br>

The extra term ensures \( u(0)=f(0) \) and \( u(1)=f(1) \) and
is a strikingly good help to get a good
approximation!

<p>

</section>


<section class="slide">

<h3>Fourier series approximation; final results  <a name="___sec34"></a></h3>

<p>
\( N=3 \) vs \( N=11 \):

<p>
<center><p><img src="fig-fem/parabola_ls_sines4_12_wfterm.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Orthogonal basis functions  <a name="___sec35"></a></h3>

<p>
This choice of sine functions as basis functions is popular because

<p>

<ul>
 <p><li> the basis functions are orthogonal: \( (\baspsi_i,\baspsi_j)=0 \)</li>
 <p><li> implying that \( A_{i,j} \) is a diagonal matrix</li>
 <p><li> implying that we can solve for \( c_i = 2\int_0^1 f(x)\sin ((i+1)\pi x) dx \)</li>
</ul>
<p>

In general for an orthogonal basis, \( A_{i,j} \) is diagonal and we can
easily solve for \( c_i \):

<p>
<p>&nbsp;<br>
$$
c_i = \frac{b_i}{A_{i,i}} = \frac{(f,\baspsi_i)}{(\baspsi_i,\baspsi_i)}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>The collocation or interpolation method; ideas and math <a name="fem:approx:global:interp"></a></h3>

<p>
Here is another idea for approximating \( f(x) \) by \( u(x)=\sum_jc_j\baspsi_j \):

<p>

<ul>
 <p><li> Force \( u(\xno{i}) = f(\xno{i}) \) at some selected <em>collocation</em> points
   \( \sequencei{x} \)</li>
 <p><li> Then \( u \) interpolates \( f \)</li>
 <p><li> The method is known as <em>interpolation</em> or <em>collocation</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j(\xno{i}) = f(\xno{i})
\quad i\in\If,N
\end{equation}
$$
<p>&nbsp;<br>


<p>
This is a linear system with no need for integration:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\sum_{j\in\If} A_{i,j}c_j &= b_i,\quad i\in\If\\ 
A_{i,j} &= \baspsi_j(\xno{i})\\ 
b_i &= f(\xno{i})
\end{align}
$$
<p>&nbsp;<br>


<p>
No symmetric matrix: \( \baspsi_j(\xno{i})\neq \baspsi_i(\xno{j}) \) in general

<p>

</section>


<section class="slide">

<h3>The collocation or interpolation method; implementation  <a name="___sec37"></a></h3>

<p>
<code>points</code> holds the interpolation/collocation points

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">interpolation</span>(f, phi, points):
    N = <span style="color: #658b00">len</span>(phi) - <span style="color: #B452CD">1</span>
    A = sm.zeros((N+<span style="color: #B452CD">1</span>, N+<span style="color: #B452CD">1</span>))
    b = sm.zeros((N+<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
    <span style="color: #228B22"># Turn phi and f into Python functions</span>
    phi = [sm.lambdify([x], phi[i]) <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>)]
    f = sm.lambdify([x], f)
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N+<span style="color: #B452CD">1</span>):
            A[i,j] = phi[j](points[i])
        b[i,<span style="color: #B452CD">0</span>] = f(points[i])
    c = A.LUsolve(b)
    u = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(phi)):
        u += c[i,<span style="color: #B452CD">0</span>]*phi[i](x)
    <span style="color: #8B008B; font-weight: bold">return</span> u
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>The collocation or interpolation method; approximating a parabola by linear functions  <a name="___sec38"></a></h3>

<p>

<ul>
 <p><li> Potential difficulty: how to choose \( \xno{i} \)?</li>
 <p><li> The results are sensitive to the points!</li>
</ul>
<p>

\( (4/3,5/3) \) vs \( (1,2) \):

<p>
<center><p><img src="fig-fem/parabola_inter.png" align="bottom" width=700,></p></center>

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; motivation and ideas <a name="fem:approx:global:Lagrange"></a></h3>

<p>
Motivation:

<p>

<ul>
 <p><li> The interpolation/collocation method avoids integration</li>
 <p><li> With a diagonal matrix \( A_{i,j} = \baspsi_j(\xno{i}) \) we
   can solve the linear system by hand</li>
</ul>
<p>

The <em>Lagrange interpolating polynomials</em> \( \baspsi_j \) have the property that

<p>
<p>&nbsp;<br>
$$ \basphi_i(\xno{j}) =\delta_{ij},\quad \delta_{ij} =
\left\lbrace\begin{array}{ll}
1, & i=j,\\ 
0, & i\neq j,
\end{array}\right.
$$
<p>&nbsp;<br>


<p>
Hence, \( c_i = f(x_i) \) and

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(x) = \sum_{j\in\If} f(\xno{i})\baspsi_i(x)
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Lagrange polynomials and interpolation/collocation look convenient</li>
 <p><li> Lagrange polynomials are very much used in the finite element method</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Lagrange polynomials; formula and code  <a name="___sec40"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\baspsi_i(x) =
\prod_{j=0,j\neq i}^N
\frac{x-\xno{j}}{\xno{i}-\xno{j}}
= \frac{x-x_0}{\xno{i}-x_0}\cdots\frac{x-\xno{i-1}}{\xno{i}-\xno{i-1}}\frac{x-\xno{i+1}}{\xno{i}-\xno{i+1}}
\cdots\frac{x-x_N}{\xno{i}-x_N}
\tag{13}
\end{equation}
$$
<p>&nbsp;<br>


<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; successful example  <a name="___sec41"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_ls_interp_sin_4.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; a less successful example  <a name="___sec42"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_interp_abs_8_15.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; oscillatory behavior  <a name="___sec43"></a></h3>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-fem/Lagrange_basis_12.png" align="bottom" width=500></p></center>

<p>
Problem: strong oscillations near the boundaries for larger \( N \) values.

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; remedy for strong oscillations  <a name="___sec44"></a></h3>

<p>
The oscillations can be reduced by a more clever choice of
interpolation points, called the <em>Chebyshev nodes</em>:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\xno{i} = \half (a+b) + \half(b-a)\cos\left( \frac{2i+1}{2(N+1)}pi\right),\quad i=0\ldots,N
\end{equation}
$$
<p>&nbsp;<br>

on an interval \( [a,b] \).

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; recalculation with Chebyshev nodes  <a name="___sec45"></a></h3>

<p>
<center><p><img src="fig-fem/Lagrange_interp_abs_Cheb_8_15.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h3>Lagrange polynomials; less oscillations with Chebyshev nodes  <a name="___sec46"></a></h3>

<p>
12 points, degree 11, plot of two of the Lagrange polynomials - note that
they are zero at all points except one.

<p>
<center><p><img src="fig-fem/Lagrange_basis_Cheb_12.png" align="bottom" width=500></p></center>

<p>

</section>


<section class="slide">

<h2>Finite element basis functions <a name="fem:approx:fe"></a></h2>

<p>

</section>


<section class="slide">

<h3>So far: basis functions have been global  <a name="___sec48"></a></h3>

<p>
\( \baspsi_i(x) \neq 0 \) for most \( x\in\Omega \)

<p>
<center><p><img src="fig-fem/u_example_sin.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h3>In the finite element method we use basis functions with local support  <a name="___sec49"></a></h3>

<p>

<ul>
 <p><li> <em>Local support</em>: \( \baspsi_i(x) \neq 0 \) for \( x \) in a
   small subdomain of \( \Omega \)</li>
 <p><li> Typically hat-shaped</li>
 <p><li> \( u(x) \) based on these \( \baspsi_i \) is a piecewise polynomial
   defined over many (small) subdomains</li>
</ul>
<p>


</section>


<section class="slide">

<h3>The linear combination of hat functions is a piecewise linear function  <a name="___sec50"></a></h3>

<p>
<center><p><img src="fig-fem/u_example_fe2.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h3>Elements and nodes <a name="fem:approx:fe:def:elements:nodes"></a></h3>

<p>
Split \( \Omega \) into non-overlapping subdomains called <em>elements</em>:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(N_e)}
\end{equation}
$$
<p>&nbsp;<br>


<p>
On each element, introduce points called <em>nodes</em>: \( \xno{0},\ldots,\xno{N_n} \)

<p>

<ul>
 <p><li> The finite element basis functions are named \( \basphi_i(x) \)</li>
 <p><li> \( \basphi_i=1 \) at node \( i \) and 0 at all other nodes</li>
 <p><li> \( \basphi_i \) is a Lagrange polynomial on each element</li>
 <p><li> For nodes at the boundary between two elements, \( \basphi_i \) is made
   up of a Lagrange polynomial over each element</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Example on elements with two nodes (P1 elements)  <a name="___sec52"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D.png" align="bottom" width=500></p></center>

<p>
Data structure: <code>nodes</code> holds coordinates or nodes, <code>elements</code> holds the
node numbers in each element

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1.2</span>, <span style="color: #B452CD">2.4</span>, <span style="color: #B452CD">3.6</span>, <span style="color: #B452CD">4.8</span>, <span style="color: #B452CD">5</span>]
elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>], [<span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>]]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Illustration of two basis functions on the mesh  <a name="___sec53"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>

</section>


<section class="slide">

<h3>Example on elements with three nodes (P2 elements)  <a name="___sec54"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_P2.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.125</span>, <span style="color: #B452CD">0.25</span>, <span style="color: #B452CD">0.375</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.625</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.875</span>, <span style="color: #B452CD">1.0</span>]
elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>, <span style="color: #B452CD">6</span>], [<span style="color: #B452CD">6</span>, <span style="color: #B452CD">7</span>, <span style="color: #B452CD">8</span>]]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Some corresponding basis functions (P2 elements)  <a name="___sec55"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h3>Examples on elements with four nodes per element (P3 elements)  <a name="___sec56"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_d4_stretched.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">d = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># d+1 nodes per element</span>
num_elements = <span style="color: #B452CD">4</span>
num_nodes = num_elements*d + <span style="color: #B452CD">1</span>
nodes = [i*<span style="color: #B452CD">0.5</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(num_nodes)]
elements = [[i*d+j <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(num_elements)]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Some corresponding basis functions (P3 elements)  <a name="___sec57"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h3>The numbering does not need to be regular from left to right  <a name="___sec58"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_random_numbering.png" align="bottom" width=500></p></center>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">nodes = [<span style="color: #B452CD">1.5</span>, <span style="color: #B452CD">5.5</span>, <span style="color: #B452CD">4.2</span>, <span style="color: #B452CD">0.3</span>, <span style="color: #B452CD">2.2</span>, <span style="color: #B452CD">3.1</span>]
elements = [[<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">4</span>, <span style="color: #B452CD">5</span>], [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>], [<span style="color: #B452CD">3</span>, <span style="color: #B452CD">0</span>], [<span style="color: #B452CD">5</span>, <span style="color: #B452CD">2</span>]]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Interpretation of the coefficients \( c_i \)  <a name="___sec59"></a></h3>

<p>
Important property: \( c_i \)
is the value of \( u \) at node \( i \), \( \xno{i} \):

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i}) = \sum_{j\in\If} c_j\basphi_j(\xno{i}) =
c_i\basphi_i(\xno{i}) = c_i
\tag{14}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Properties of the basis functions  <a name="___sec60"></a></h3>

<p>
\( \basphi_i(x) \) is mostly zero throughout the domain:

<p>

<ul>
 <p><li> \( \basphi_i(x) \neq 0 \) only on those elements that contain global node \( i \),</li>
 <p><li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) if and only if \( i \) and \( j \) are global node
   numbers in the same element.</li>
</ul>
<p>

Since \( A_{i,j} \) is the integral of
\( \basphi_i\basphi_j \) it means that
<em>most of the elements in the coefficient matrix will be zero</em>
(important for implementation!).

<p>

</section>


<section class="slide">

<h3>How to construct quadratic \( \basphi_i \) (P2 elements)  <a name="___sec61"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p2_4e.png" align="bottom" width=600></p></center>

<p>

<ol>
<p><li> Associate Lagrange polynomials with the nodes in an element</li>
<p><li> When the polynomial is 1 on the element boundary, combine it
   with the polynomial in the neighboring element</li>
</ol>
<p>


</section>


<section class="slide">

<h3>Example on linear \( \basphi_i \) (P1 elements)  <a name="___sec62"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p1_4e.png" align="bottom" width=600></p></center>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
(x - \xno{i-1})/h,
& \xno{i-1} \leq x < \xno{i},\\ 
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{15}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Example on cubic \( \basphi_i \) (P3 elements)  <a name="___sec63"></a></h3>

<p>
<center><p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600,></p></center>

<p>

</section>


<section class="slide">

<h2>Calculating the linear system for \( c_i \) <a name="fem:approx:global:linearsystem"></a></h2>

<p>

</section>


<section class="slide">

<h3>Computing a specific matrix entry (1)  <a name="___sec65"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>
\( A_{2,3}=\int_\Omega\basphi_2\basphi_3 dx \): \( \basphi_2\basphi_3\neq 0 \)
only over element 2. There,

<p>
<p>&nbsp;<br>
$$ \basphi_3(x) = (x-x_2)/h,\quad \basphi_2(x) = 1- (x-x_2)/h$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
A_{2,3} = \int_\Omega \basphi_2\basphi_{3}\dx =
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right) \frac{x - x_{2}}{h}
 \dx = \frac{h}{6}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Computing a specific matrix entry (2)  <a name="___sec66"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$ A_{2,2} =
\int_{\xno{1}}^{\xno{2}}
\left(\frac{x - \xno{1}}{h}\right)^2\dx +
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right)^2\dx
= \frac{h}{3}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Calculating a general row in the matrix; figure  <a name="___sec67"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_im1.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$ A_{i,i-1} = \int_\Omega \basphi_i\basphi_{i-1}\dx = \hbox{?}$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Calculating a general row in the matrix; details  <a name="___sec68"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align*}
A_{i,i-1} &= \int_\Omega \basphi_i\basphi_{i-1}\dx\\ 
&=
\underbrace{\int_{\xno{i-2}}^{\xno{i-1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_i=0} +
\int_{\xno{i}}^{\xno{i}} \basphi_i\basphi_{i-1}\dx +
\underbrace{\int_{\xno{i}}^{\xno{i+1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_{i-1}=0}\\ 
&= \int_{\xno{i-1}}^{\xno{i}}
\underbrace{\frac{x - x_{i}}{h}}_{\basphi_i(x)}
\underbrace{\left(1 - \frac{x - \xno{i-1}}{h}\right)}_{\basphi_{i-1}(x)} \dx =
\frac{h}{6}
\end{align*}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( A_{i,i+1}=A_{i,i-1} \) due to symmetry</li>
 <p><li> \( A_{i,i}=h/3 \) (same calculation as for \( A_{2,2} \))</li>
 <p><li> \( A_{0,0}=A_{N,N}=h/3 \) (only one element)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Calculation of the right-hand side  <a name="___sec69"></a></h3>

<p>
<center><p><img src="fig-fem/fe_mesh1D_phi_i_f.png" align="bottom" width=500></p></center>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i(x)f(x)\dx
= \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)\dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)
\dx
\tag{16}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Need a specific \( f(x) \) to do more...

<p>

</section>


<section class="slide">

<h3>Specific example: two elements; linear system and solution  <a name="___sec70"></a></h3>

<p>

<ul>
 <p><li> \( f(x)=x(1-x) \) on \( \Omega=[0,1] \)</li>
 <p><li> Two equal-sized elements \( [0,0.5] \) and \( [0.5,1] \)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\ 
1 & 4 & 1\\ 
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\ 
12 - 14h\\ 
10 -17h
\end{array}\right)
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation*} c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2
\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Specific example: two elements; plot  <a name="___sec71"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation*} u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)\end{equation*}
$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-fem/fe_p1_x2_2e.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h3>Specific example: what about four elements?  <a name="___sec72"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p1_x2_2e_4e.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h2>Assembly of elementwise computations <a name="fem:approx:fe:elementwise"></a></h2>

<p>

</section>


<section class="slide">

<h3>Split the integrals into elementwise integrals  <a name="___sec74"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A_{i,j} = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} A^{(e)}_{i,j},\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_jdx
\tag{17}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
 <p><li> \( A^{(e)}_{i,j}\neq 0 \) if and only if \( i \) and \( j \) are nodes in element
   \( e \) (otherwise no overlap between the basis functions)</li>
 <p><li> all the nonzero elements in \( A^{(e)}_{i,j} \) are collected in an
   <em>element matrix</em></li>
</ul>
<p>


</section>


<section class="slide">

<h3>The element matrix  <a name="___sec75"></a></h3>

<p>
<p>&nbsp;<br>
$$
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad r,s\in\Ifd=\{0,\ldots,d\}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)}dx,\quad r,s\in\Ifd
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> \( r,s \) run over <em>local node numbers</em> within an element, while \( i,j \) run
   over <em>global node numbers</em>.</li>
 <p><li> \( i=q(e,r) \): mapping of local node number \( r \) in element
   \( e \) to the global node number \( i \). Math equivalent to <code>i=elements[e][r]</code>.</li>
 <p><li> Add contribution from an element into the global coefficient matrix
   (<em>assembly</em>)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s\in\Ifd
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Illustration of the matrix assembly: regularly numbered P1 elements  <a name="___sec76"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_regular_2x2/fe_assembly_regular_2x2.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>

</section>


<section class="slide">

<h3>Illustration of the matrix assembly: regularly numbered P3 elements  <a name="___sec77"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_regular_4x4/fe_assembly_regular_4x4.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>

</section>


<section class="slide">

<h3>Illustration of the matrix assembly: irregularly numbered P1 elements  <a name="___sec78"></a></h3>

<p>
<center><p><img src="mov-fem/fe_assembly_irregular/fe_assembly_irregular.png" align="bottom" width=400></p></center>

<p>
<a href="mov-fem/fe_assembly.html">Animation</a>

<p>

</section>


<section class="slide">

<h3>Assembly of the right-hand side  <a name="___sec79"></a></h3>

<p>
Split in elementwise contributions:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_i = \int_\Omega\basphi_i\basphi_jdx = \sum_{e} b^{(e)}_{i},\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)dx
\end{equation}
$$
<p>&nbsp;<br>


<p>
Important:

<p>

<ul>
  <p><li> \( b_i^{(e)}\neq 0 \) if and only if global node \( i \) is a node in element \( e \)
    (otherwise \( \basphi_i=0 \))</li>
  <p><li> The \( d+1 \) nonzero \( b_i^{(e)} \) can be collected in an <em>element vector</em></li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation*}
\tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\},\quad r\in\Ifd
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Assembly:

<p>
<p>&nbsp;<br>
$$
\begin{equation}
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r,s\in\Ifd
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Mapping to a reference element <a name="fem:approx:fe:mapping"></a></h2>

<p>
Instead of computing

<p>
<p>&nbsp;<br>
$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx\end{equation*}
$$
<p>&nbsp;<br>

over some element
\( \Omega^{(e)} = [x_L, x_R] \),
we now map \( [x_L, x_R] \) to
a standardized reference element domain \( [-1,1] \) with local coordinate \( X \).

<p>

</section>


<section class="slide">

<h3>Affine mapping  <a name="___sec81"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
x = \half (x_L + x_R) + \half (x_R - x_L)X
\tag{18}
\end{equation}
$$
<p>&nbsp;<br>

or rewritten as
<p>&nbsp;<br>
$$
\begin{equation}
x = x_m + \frac{1}{2}hX, \qquad x_m=(x_L+x_R)/2
\tag{19}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Integral transformation  <a name="___sec82"></a></h3>

<p>
Integrating on
the reference element is a matter of just changing the integration
variable from \( x \) to \( X \). Introduce local basis function

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
\end{equation}
$$
<p>&nbsp;<br>

The integral transformation reads

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)dx
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\frac{dx}{dX}dX  \end{equation}
$$
<p>&nbsp;<br>


<p>
Introduce the notation
\( \det J = dx/dX = h/2 \) (2D/3D must use \( \det J \))

<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde A^{(e)}_{r,s}
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
\tag{20}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<p>&nbsp;<br>
$$
\begin{equation}
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
\tag{21}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Advantages of the reference element  <a name="___sec83"></a></h3>

<p>

<ul>
  <p><li> Always the same domain for integration: \( [-1,1] \)</li>
  <p><li> We only need formulas for \( \refphi_r(X) \) on the reference elements
    (no need for piecewise polynomial definition)</li>
  <p><li> All geometric information (length and location) is "factored out"
    in the mapping and \( \det J \)</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Standardized basis functions for P1 elements  <a name="___sec84"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\tag{22}\\ 
\refphi_1(X) &= \half (1 + X)
\tag{23}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Standardized basis functions for P2 elements  <a name="___sec85"></a></h3>

<p>
P2 elements:

<p>
<p>&nbsp;<br>
$$
\begin{align}
\refphi_0(X) &= \half (X-1)X\\ 
\refphi_1(X) &= 1 - X^2\\ 
\refphi_2(X) &= \half (X+1)X
\end{align}
$$
<p>&nbsp;<br>


<p>
Easy to generalize to arbitrary order!

<p>

</section>


<section class="slide">

<h3>Integration over a reference element; element matrix <a name="fem:approx:fe:intg:ref"></a></h3>

<p>
P1 elements and \( f(x)=x(1-x) \).

<p>
<p>&nbsp;<br>
$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1-X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3},
\tag{24}\\ 
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6},\\ 
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0},
\tag{25}\\ 
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \frac{1}{2}(1+X)\frac{1}{2}(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\tag{26}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Integration over a reference element; element vector  <a name="___sec87"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1-X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\tag{27}\\ 
\tilde b^{(e)}_{1}
&= \int_{-1}^1 f(x(X))\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\frac{1}{2}(1+X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\frac{1}{2} h x_{m}^{2} + \frac{1}{2} h x_{m}
\end{align}
$$
<p>&nbsp;<br>


<p>
\( x_m \): element midpoint.

<p>

</section>


<section class="slide">

<h3>Tedious calculations! Let's use symbolic software  <a name="___sec88"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
&gt;&gt;&gt; x, x_m, h, X = sm.symbols(<span style="color: #CD5555">&#39;x x_m h X&#39;</span>)
&gt;&gt;&gt; sm.integrate(h/<span style="color: #B452CD">8</span>*(<span style="color: #B452CD">1</span>-X)**<span style="color: #B452CD">2</span>, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
h/<span style="color: #B452CD">3</span>
&gt;&gt;&gt; sm.integrate(h/<span style="color: #B452CD">8</span>*(<span style="color: #B452CD">1</span>+X)*(<span style="color: #B452CD">1</span>-X), (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
h/<span style="color: #B452CD">6</span>
&gt;&gt;&gt; x = x_m + h/<span style="color: #B452CD">2</span>*X
&gt;&gt;&gt; b_0 = sm.integrate(h/<span style="color: #B452CD">4</span>*x*(<span style="color: #B452CD">1</span>-x)*(<span style="color: #B452CD">1</span>-X), (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> b_0
-h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">24</span> + h**<span style="color: #B452CD">2</span>*x_m/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - h*x_m**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">2</span> + h*x_m/<span style="color: #B452CD">2</span>
</code></pre></div>
<p>
Can printe out in LaTeX too (convenient for copying into reports):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> sm.latex(b_0, mode=<span style="color: #CD5555">&#39;plain&#39;</span>)
- \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">24</span>} h^{<span style="color: #B452CD">3</span>} + \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">6</span>} h^{<span style="color: #B452CD">2</span>} x_{m}
- \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">12</span>} h^{<span style="color: #B452CD">2</span>} - \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">2</span>} h x_{m}^{<span style="color: #B452CD">2</span>}
+ \frac{<span style="color: #B452CD">1</span>}{<span style="color: #B452CD">2</span>} h x_{m}
</code></pre></div>
<p>

</section>


<section class="slide">

<h2>Implementation  <a name="___sec89"></a></h2>

<p>

<ul>
 <p><li> Coming functions appear in <a href="http://tinyurl.com/jvzzcfn/fem/fe_approx1D.py"><tt>fe_approx1D.py</tt></a></li>
 <p><li> Functions can operate in symbolic or numeric mode</li>
 <p><li> The code documents all steps in finite element calculations!</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Compute finite element basis functions  <a name="___sec90"></a></h3>

<p>
Let \( \refphi_r(X) \) be a Lagrange polynomial of degree <code>d</code>:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">phi_r</span>(r, X, d):
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(X, sm.Symbol):
        h = sm.Rational(<span style="color: #B452CD">1</span>, d)  <span style="color: #228B22"># node spacing</span>
        nodes = [<span style="color: #B452CD">2</span>*i*h - <span style="color: #B452CD">1</span> <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #228B22"># assume X is numeric: use floats for nodes</span>
        nodes = np.linspace(-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, d+<span style="color: #B452CD">1</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> Lagrange_polynomial(X, r, nodes)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Lagrange_polynomial</span>(x, i, points):
    p = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> k <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(points)):
        <span style="color: #8B008B; font-weight: bold">if</span> k != i:
            p *= (x - points[k])/(points[i] - points[k])
    <span style="color: #8B008B; font-weight: bold">return</span> p

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">basis</span>(d=<span style="color: #B452CD">1</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Return the complete basis.&quot;&quot;&quot;</span>
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    phi = [phi_r(r, X, d) <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(d+<span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> phi
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Compute the element matrix  <a name="___sec91"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_matrix</span>(phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    A_e = sm.zeros((n, n))
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sm.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(r, n):
            A_e[r,s] = sm.integrate(phi[r]*phi[s]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
            A_e[s,r] = A_e[r,s]
    <span style="color: #8B008B; font-weight: bold">return</span> A_e
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Example on symbolic and numeric element matrix  <a name="___sec92"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; phi
[<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> - X/<span style="color: #B452CD">2</span>, <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span> + X/<span style="color: #B452CD">2</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">True</span>)
[h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; element_matrix(phi, Omega_e=[<span style="color: #B452CD">0.1</span>, <span style="color: #B452CD">0.2</span>], symbolic=<span style="color: #658b00">False</span>)
[<span style="color: #B452CD">0.0333333333333333</span>, <span style="color: #B452CD">0.0166666666666667</span>]
[<span style="color: #B452CD">0.0166666666666667</span>, <span style="color: #B452CD">0.0333333333333333</span>]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Compute the element vector  <a name="___sec93"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
    n = <span style="color: #658b00">len</span>(phi)
    b_e = sm.zeros((n, <span style="color: #B452CD">1</span>))
    <span style="color: #228B22"># Make f a function of X</span>
    X = sm.Symbol(<span style="color: #CD5555">&#39;X&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">if</span> symbolic:
        h = sm.Symbol(<span style="color: #CD5555">&#39;h&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]
    x = (Omega_e[<span style="color: #B452CD">0</span>] + Omega_e[<span style="color: #B452CD">1</span>])/<span style="color: #B452CD">2</span> + h/<span style="color: #B452CD">2</span>*X  <span style="color: #228B22"># mapping</span>
    f = f.subs(<span style="color: #CD5555">&#39;x&#39;</span>, x)  <span style="color: #228B22"># substitute mapping formula for x</span>
    detJ = h/<span style="color: #B452CD">2</span>  <span style="color: #228B22"># dx/dX</span>
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(n):
        b_e[r] = sm.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">return</span> b_e
</code></pre></div>
<p>
Note <code>f.subs('x', x)</code>: replace <code>x</code> by \( x(X) \) such that <code>f</code> contains <code>X</code>

<p>

</section>


<section class="slide">

<h3>Fallback on numerical integration if symbolic integration fails  <a name="___sec94"></a></h3>

<p>

<ul>
  <p><li> Element matrix: only polynomials and <code>sympy</code> always succeeds</li>
  <p><li> Element vector: \( \int f\refphi \dx \) can fail
    (<code>sympy</code> then returns an <code>Integral</code> object instead of a number)</li>
</ul>
<p>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">element_vector</span>(f, phi, Omega_e, symbolic=<span style="color: #658b00">True</span>):
        ...
        I = sm.integrate(f*phi[r]*detJ, (X, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>))  <span style="color: #228B22"># try...</span>
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, sm.Integral):
            h = Omega_e[<span style="color: #B452CD">1</span>] - Omega_e[<span style="color: #B452CD">0</span>]  <span style="color: #228B22"># Ensure h is numerical</span>
            detJ = h/<span style="color: #B452CD">2</span>
            integrand = sm.lambdify([X], f*phi[r]*detJ)
            I = sm.mpmath.quad(integrand, [-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>])
        b_e[r] = I
        ...
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Linear system assembly and solution  <a name="___sec95"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assemble</span>(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>):
    N_n, N_e = <span style="color: #658b00">len</span>(nodes), <span style="color: #658b00">len</span>(elements)
    zeros = sm.zeros <span style="color: #8B008B; font-weight: bold">if</span> symbolic <span style="color: #8B008B; font-weight: bold">else</span> np.zeros
    A = zeros((N_n, N_n))
    b = zeros((N_n, <span style="color: #B452CD">1</span>))
    <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_e):
        Omega_e = [nodes[elements[e][<span style="color: #B452CD">0</span>]], nodes[elements[e][-<span style="color: #B452CD">1</span>]]]

        A_e = element_matrix(phi, Omega_e, symbolic)
        b_e = element_vector(f, phi, Omega_e, symbolic)

        <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
            <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(elements[e])):
                A[elements[e][r],elements[e][s]] += A_e[r,s]
            b[elements[e][r]] += b_e[r]
    <span style="color: #8B008B; font-weight: bold">return</span> A, b
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Linear system solution  <a name="___sec96"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">if</span> symbolic:
    c = A.LUsolve(b)           <span style="color: #228B22"># sympy arrays, symbolic Gaussian elim.</span>
<span style="color: #8B008B; font-weight: bold">else</span>:
    c = np.linalg.solve(A, b)  <span style="color: #228B22"># numpy arrays, numerical solve</span>
</code></pre></div>
<p>
Note: the symbolic computation of <code>A</code> and <code>b</code> and the symbolic
solution can be very tedious.

<p>

</section>


<section class="slide">

<h3>Example on computing approximations  <a name="___sec97"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; h, x = sm.symbols(<span style="color: #CD5555">&#39;h x&#39;</span>)
&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, h, <span style="color: #B452CD">2</span>*h]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
&gt;&gt;&gt; b
[     h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
[      h**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">5</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> - <span style="color: #B452CD">17</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">12</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[                           h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span>]
[<span style="color: #B452CD">12</span>*(<span style="color: #B452CD">7</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">12</span> - <span style="color: #B452CD">35</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">72</span>)/(<span style="color: #B452CD">7</span>*h)]
[  <span style="color: #B452CD">7</span>*(<span style="color: #B452CD">4</span>*h**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">7</span> - <span style="color: #B452CD">23</span>*h**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">21</span>)/(<span style="color: #B452CD">2</span>*h)]
</code></pre></div>
<p>
Numerical computations:

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; nodes = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]
&gt;&gt;&gt; elements = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>]]
&gt;&gt;&gt; phi = basis(d=<span style="color: #B452CD">1</span>)
&gt;&gt;&gt; x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">False</span>)
&gt;&gt;&gt; A
[ <span style="color: #B452CD">0.166666666666667</span>, <span style="color: #B452CD">0.0833333333333333</span>,                  <span style="color: #B452CD">0</span>]
[<span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.333333333333333</span>, <span style="color: #B452CD">0.0833333333333333</span>]
[                 <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.0833333333333333</span>,  <span style="color: #B452CD">0.166666666666667</span>]
&gt;&gt;&gt; b
[          <span style="color: #B452CD">0.03125</span>]
[<span style="color: #B452CD">0.104166666666667</span>]
[          <span style="color: #B452CD">0.03125</span>]
&gt;&gt;&gt; c = A.LUsolve(b)
&gt;&gt;&gt; c
[<span style="color: #B452CD">0.0416666666666666</span>]
[ <span style="color: #B452CD">0.291666666666667</span>]
[<span style="color: #B452CD">0.0416666666666666</span>]
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>The structure of the coefficient matrix <a name="fem:approx:fe:A:structure"></a></h3>

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; d=<span style="color: #B452CD">1</span>; N_e=<span style="color: #B452CD">8</span>; Omega=[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]  <span style="color: #228B22"># 8 linear elements on [0,1]</span>
&gt;&gt;&gt; phi = basis(d)
&gt;&gt;&gt; f = x*(<span style="color: #B452CD">1</span>-x)
&gt;&gt;&gt; nodes, elements = mesh_symbolic(N_e, d, Omega)
&gt;&gt;&gt; A, b = assemble(nodes, elements, phi, f, symbolic=<span style="color: #658b00">True</span>)
&gt;&gt;&gt; A
[h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,     <span style="color: #B452CD">0</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>,   h/<span style="color: #B452CD">6</span>,   <span style="color: #B452CD">0</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>*h/<span style="color: #B452CD">3</span>, h/<span style="color: #B452CD">6</span>]
[  <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,     <span style="color: #B452CD">0</span>,   h/<span style="color: #B452CD">6</span>, h/<span style="color: #B452CD">3</span>]
</code></pre></div>
<p>
Note: do this by hand to understand what is going on!

<p>

</section>


<section class="slide">

<h3>General result: the coefficient matrix is sparse  <a name="___sec99"></a></h3>

<p>

<ul>
 <p><li> Sparse = most of the entries are zeros</li>
 <p><li> Below: P1 elements</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{h}{6}
\left(
\begin{array}{cccccccccc}
2 & 1 & 0
&\cdots & \cdots & \cdots & \cdots & \cdots & 0 \\ 
1 & 4 & 1 & \ddots &   & &  & &  \vdots \\ 
0 & 1 & 4 & 1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & 1 & 4 & 1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & 1  & 4  & 1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & 1 & 2
\end{array}
\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Exemplifying the sparsity for P2 elements  <a name="___sec100"></a></h3>

<p>
<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{h}{30}
\left(
\begin{array}{ccccccccc}
4 & 2 & - 1 & 0
  & 0 & 0 & 0 & 0 & 0\\ 
  2 & 16 & 2
  & 0 & 0 & 0 & 0 & 0 & 0\\- 1 & 2 &
  8 & 2 & - 1 & 0 & 0 & 0 &
  0\\0 & 0 & 2 & 16 & 2 & 0 & 0
  & 0 & 0\\0 & 0 & - 1 & 2 & 8
  & 2 & - 1 & 0 & 0\\0 & 0 & 0 & 0 &
  2 & 16 & 2 & 0 & 0\\0 & 0 & 0
  & 0 & - 1 & 2 & 8 &
  2 & - 1\\0 & 0 & 0 & 0 & 0 & 0 &
  2 & 16 & 2\\0 & 0 & 0 & 0 & 0
  & 0 & - 1 & 2 & 4
\end{array}
\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h3>Matrix sparsity pattern for regular/random numbering of P1 elements  <a name="___sec101"></a></h3>

<p>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>
<p>

<center><p><img src="fig-fem/sparsity_pattern_1D_30.png" align="bottom" width=800></p></center>

<p>

</section>


<section class="slide">

<h3>Matrix sparsity pattern for regular/random numbering of P3 elements  <a name="___sec102"></a></h3>

<p>

<ul>
 <p><li> Left: number nodes and elements from left to right</li>
 <p><li> Right: number nodes and elements arbitrarily</li>
</ul>
<p>

<center><p><img src="fig-fem/sparsity_pattern_1DP3_30.png" align="bottom" width=800></p></center>

<p>

</section>


<section class="slide">

<h3>Sparse matrix storage and solution <a name="fem:approx:fe:impl:sparse"></a></h3>

<p>
The minimum storage requirements for the coefficient matrix \( A_{i,j} \):

<p>

<ul>
 <p><li> P1 elements: only 3 nonzero entires per row</li>
 <p><li> P2 elements: only 5 nonzero entires per row</li>
 <p><li> P2 elements: only 7 nonzero entires per row</li>
 <p><li> It is important to utilize sparse storage and sparse solvers</li>
 <p><li> In Python: <code>scipy.sparse</code> package</li>
</ul>
<p>


</section>


<section class="slide">

<h3>Approximate \( f\sim x^9 \) by various elements; code  <a name="___sec104"></a></h3>

<p>
Compute a mesh with <code>N_e</code> elements, basis functions of
degree <code>d</code>, and approximate a given symbolic expression
<code>f</code> by a finite element expansion \( u(x) = \sum_jc_j\basphi_j(x) \):

<p>

<!-- code=python (from !bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sm</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">fe_approx1D</span> <span style="color: #8B008B; font-weight: bold">import</span> approximate
x = sm.Symbol(<span style="color: #CD5555">&#39;x&#39;</span>)

approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">4</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">2</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">1</span>, N_e=<span style="color: #B452CD">8</span>)
approximate(f=x*(<span style="color: #B452CD">1</span>-x)**<span style="color: #B452CD">8</span>, symbolic=<span style="color: #658b00">False</span>, d=<span style="color: #B452CD">2</span>, N_e=<span style="color: #B452CD">4</span>)
</code></pre></div>
<p>

</section>


<section class="slide">

<h3>Approximate \( f\sim x^9 \) by various elements; plot  <a name="___sec105"></a></h3>

<p>
<center><p><img src="fig-fem/fe_p1_p2_x9_248e.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h2>Comparison of finite element and finite difference approximation <a name="fem:approx:fe:fd"></a></h2>

<p>

<ul>
 <p><li> Finite difference approximation of a function \( f(x) \): simply
   choose \( u_i = f(x_i) \) (interpolation)</li>
 <p><li> Galerkin/projection and least squares method:
   must derive and solve a linear system</li>
 <p><li> What is really the difference?</li>
</ul>
<p>

<h3>Interpolation/collocation with finite elements  <a name="___sec107"></a></h3>

<p>
Let \( \xno{i} \), \( i\in\If \), be the nodes in the mesh.
Collocation means

<p>
<p>&nbsp;<br>
$$
\begin{equation}
u(\xno{i})=f(\xno{i}),\quad i\in\If,
\end{equation}
$$
<p>&nbsp;<br>

which translates to

<p>
<p>&nbsp;<br>
$$ \sum_{j\in\If} c_j \basphi_j(\xno{i}) = f(\xno{i}),$$
<p>&nbsp;<br>

but \( \basphi_j(\xno{i})=0 \) if \( i\neq j \) so the sum collapses to one
term \( c_i\basphi_i(\xno{i}) = c_i \), and we have the result

<p>
<p>&nbsp;<br>
$$
\begin{equation}
c_i = f(\xno{i})
\end{equation}
$$
<p>&nbsp;<br>


<p>

<ul>
 <p><li> Same result as the standard finite difference approach</li>
 <p><li> \( u \) <em>interpolates</em> \( f \) at the node points</li>
 <p><li> \( u \) has a variation between the node points dictated by the \( \basphi_i \)
   functions</li>
</ul>
<p>



</section>



<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>
-->

<!-- deck.goto snippet
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>
-->

<!-- deck.hash snippet
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>
-->

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery-1.7.2.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/notes/deck.notes.js"></script>

<!-- From https://github.com/mikeharris100/deck.pointer.js -->
<script src="deck.js/extensions/pointer/deck.pointer.js"></script>

<!-- From https://github.com/stvnwrgs/presenterview -->
<script type="text/javascript" src="deck.js/extensions/presenterview/deck.presenterview.js"></script>

<!-- From https://github.com/nemec/deck.annotate.js
<script type="text/javascript" src="deck.js/extensions/deck.annotate.js/deck.annotate.js"></script>
-->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>


</body>
</html>
