

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Truncation Error Analysis</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Truncation Error Analysis" href="index.html" />
    <link rel="prev" title="Truncation Error Analysis" href="index.html" />
 
  
   <style type=text/css>
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="Truncation Error Analysis"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Truncation Error Analysis</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="truncation-error-analysis">
<h1>Truncation Error Analysis<a class="headerlink" href="#truncation-error-analysis" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Hans Petter Langtangen</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">Nov 29, 2013</td>
</tr>
</tbody>
</table>
<p><strong>WARNING</strong>: Preliminary version (expect typos!)</p>
<div class="admonition-purpose admonition">
<p class="first admonition-title">Purpose</p>
<p>Truncation error analysis provides a widely applicable framework for
analyzing the accuracy of finite difference schemes. This type of
analysis can also be used for finite element and finite volume methods
if the discrete equations are written in finite difference form.  The
result of the analysis is an asymptotic estimate of the error in the
scheme on the form <span class="math">\(Ch^r\)</span>, where <span class="math">\(h\)</span> is a discretization parameter
(<span class="math">\(\Delta t\)</span>, <span class="math">\(\Delta x\)</span>, etc.), <span class="math">\(r\)</span> is a number, known as the convergence
rate, and <span class="math">\(C\)</span> is a constant, typically dependent on the
derivatives of the exact solution.</p>
<p>Knowing <span class="math">\(r\)</span> gives understanding of the accuracy of the scheme. But
maybe even more important, a powerful verification method for computer
codes is to check that the empirically observed convergence rates in
experiments coincide with the theoretical value of <span class="math">\(r\)</span> found from
truncation error analysis.</p>
<p class="last">The analysis
can be carried out by hand, by symbolic software, and also
numerically. All three methods will be illustrated.
From examining the symbolic expressions of the truncation error
we can add correction terms to the differential equations in order
to increase the numerical accuracy.</p>
</div>
<p>In general, the term truncation error refers to the discrepancy that
arises from performing a finite number of steps to approximate a
process with infinitely many steps. The term is used in a number
of contexts, including truncation of infinite series, finite
precision arithmetic, finite differences, and differential equations.
We shall be concerned with computing truncation errors arising in
finite difference formulas and in finite difference discretizations
of differential equations.</p>
</div>
<div class="section" id="overview-of-truncation-error-analysis">
<span id="index-0"></span><h1>Overview of truncation error analysis<a class="headerlink" href="#overview-of-truncation-error-analysis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="abstract-problem-setting">
<h2>Abstract problem setting<a class="headerlink" href="#abstract-problem-setting" title="Permalink to this headline">¶</a></h2>
<p>Consider an abstract differential equation</p>
<div class="math">
\[\mathcal{L}(u)=0,\]</div>
<p>where <span class="math">\(\mathcal{L}(u)\)</span> is some formula involving the unknown <span class="math">\(u\)</span> and
its derivatives. One example is <span class="math">\(\mathcal{L}(u)=u'(t)+a(t)u(t)-b(t)\)</span>, where
<span class="math">\(a\)</span> and <span class="math">\(b\)</span> are contants or functions of time.
We can discretize the differential equation and obtain a corresponding
discrete model, here written as</p>
<div class="math">
\[\mathcal{L}_{\Delta}(u) =0{\thinspace .}\]</div>
<p>The solution <span class="math">\(u\)</span> of this equation is the <em>numerical solution</em>.
To distinguish the
numerical solution from the exact solution of the differential
equation problem,
we denote the latter by <span class="math">\({u_{\small\mbox{e}}}\)</span> and write the
differential equation and its discrete counterpart as</p>
<div class="math">
\[\begin{split}\mathcal{L}({u_{\small\mbox{e}}})&amp;=0,\\
\mathcal{L}_\Delta (u)&amp;=0{\thinspace .}\end{split}\]</div>
<p>Initial and/or boundary conditions can usually be left out of the truncation
error analysis and are omitted in the following.</p>
<p>The numerical solution <span class="math">\(u\)</span> is in a finite difference method computed
at a collection of mesh points. The discrete equations represented
by the abstract equation <span class="math">\(\mathcal{L}_\Delta (u)=0\)</span> are usually
algebraic equations involving <span class="math">\(u\)</span> at some
neighboring mesh points.</p>
</div>
<div class="section" id="error-measures">
<h2>Error measures<a class="headerlink" href="#error-measures" title="Permalink to this headline">¶</a></h2>
<p>A key issue is how accurate the numerical solution is.
The ultimate way of addressing this issue would be to compute
the error <span class="math">\({u_{\small\mbox{e}}} - u\)</span> at the mesh points. This is usually extremely demanding.
In very simplified problem settings we may, however, manage to
derive formulas for the numerical solution <span class="math">\(u\)</span>, and
therefore closed form expressions
for the error <span class="math">\({u_{\small\mbox{e}}} - u\)</span>. Such special cases can provide
considerable insight regarding accuracy and stability, but
the results are established for special problems.</p>
<p>The error <span class="math">\({u_{\small\mbox{e}}} -u\)</span> can be computed empirically in special cases where
we know <span class="math">\({u_{\small\mbox{e}}}\)</span>. Such cases can be constructed by the method of
manufactured solutions, where we choose some exact solution <span class="math">\({u_{\small\mbox{e}}} = v\)</span>
and fit a source term <span class="math">\(f\)</span> in the governing differential equation
<span class="math">\(\mathcal{L}({u_{\small\mbox{e}}})=f\)</span> such that <span class="math">\({u_{\small\mbox{e}}}=v\)</span> is a solution (i.e.,
<span class="math">\(f=\mathcal{L}(v)\)</span>).  Assuming an error model of the form <span class="math">\(Ch^r\)</span>,
where <span class="math">\(h\)</span> is the discretization parameter, such as <span class="math">\(\Delta t\)</span> or
<span class="math">\(\Delta x\)</span>, one can estimate the convergence rate <span class="math">\(r\)</span>. This is a
widely applicable procedure, but the valididity of the results is,
strictly speaking, tied to the chosen test problems.</p>
<p>Another error measure is to ask to what extent the exact solution
<span class="math">\({u_{\small\mbox{e}}}\)</span> fits the discrete equations. Clearly, <span class="math">\({u_{\small\mbox{e}}}\)</span> is in general
not a solution of <span class="math">\(\mathcal{L}_\Delta(u)=0\)</span>, but we can define
the residual</p>
<div class="math">
\[R = \mathcal{L}_\Delta({u_{\small\mbox{e}}}),\]</div>
<p>and investigate how close <span class="math">\(R\)</span> is to zero. A small <span class="math">\(R\)</span> means
intuitively that the discrete equations are close to the
differential equation, and then we are tempted to think that
<span class="math">\(u^n\)</span> must also be close to <span class="math">\({u_{\small\mbox{e}}}(t_n)\)</span>.</p>
<p>The residual <span class="math">\(R\)</span> is known as the truncation error of the finite
difference scheme <span class="math">\(\mathcal{L}_\Delta(u)=0\)</span>.  It appears that the
truncation error is relatively straightforward to compute by hand or
symbolic software <em>without specializing the differential equation
and the discrete model to a special case</em>. The resulting <span class="math">\(R\)</span> is found
as a power series in the discretization parameters. The leading-order
terms in the series provide an asymptotic measure of the accuracy of
the numerical solution method (as the discretization parameters
tend to zero). An advantage of truncation error analysis compared
empricial estimation of convergence rates or detailed analysis
of a special problem with a mathematical expression for the numerical
solution, is that the truncation error analysis reveals the
accuracy of the various building blocks in the numerical method and
how each building block impacts the overall accuracy. The analysis
can therefore be used to detect building blocks with lower accuracy
than the others.</p>
<p>Knowing the truncation error or other error measures is important for
verification of programs by empirically establishing convergence
rates. The forthcoming text will provide many examples on how to
compute truncation errors for finite difference discretizations of
ODEs and PDEs.</p>
</div>
</div>
<div class="section" id="truncation-errors-in-finite-difference-formulas">
<span id="trunc-finite-differences"></span><h1>Truncation errors in finite difference formulas<a class="headerlink" href="#truncation-errors-in-finite-difference-formulas" title="Permalink to this headline">¶</a></h1>
<p>The accuracy of a finite difference formula is a fundamental issue
when discretizing differential equations. We shall first go through a
particular example in detail and thereafter list the truncation error
in the most common finite difference approximation formulas.</p>
<div class="section" id="example-the-backward-difference-for">
<span id="trunc-fd-backward"></span><h2>Example: The backward difference for <span class="math">\(u'(t)\)</span><a class="headerlink" href="#example-the-backward-difference-for" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">Consider a backward
finite difference approximation of the first-order derivative <span class="math">\(u'\)</span>:</p>
<div class="math" id="equation-trunc:fd:bw1">
<span class="eqno">(1)</span>\[     \lbrack D_t^- u\rbrack^n  = \frac{u^{n} - u^{n-1}}{\Delta t} \approx u'(t_n)\]\[     {\thinspace .}\]</div>
<p>Here, <span class="math">\(u^n\)</span> means the value of some function <span class="math">\(u(t)\)</span> at a point <span class="math">\(t_n\)</span>, and
<span class="math">\([D_t^-u]^n\)</span> is the <em>discrete derivative</em> of <span class="math">\(u(t)\)</span> at
<span class="math">\(t=t_n\)</span>. The discrete derivative computed by a finite difference
is not exactly equal to the derivative <span class="math">\(u'(t_n)\)</span>. The error in
the approximation is</p>
<div class="math" id="equation-trunc:fd:bw3">
<span class="eqno">(2)</span>\[     R^n = [D^-_tu]^n - u'(t_n){\thinspace .}\]</div>
<p>The common way of calculating <span class="math">\(R^n\)</span> is to</p>
<ol class="arabic simple">
<li>expand <span class="math">\(u(t)\)</span> in a Taylor series around the point where the
derivative is evaluated, here <span class="math">\(t_n\)</span>,</li>
<li>insert this Taylor series in <a href="#equation-trunc:fd:bw3">(2)</a>,
and</li>
<li>collect terms that cancel and simplify the expression.</li>
</ol>
<p>The result is an expression for <span class="math">\(R^n\)</span> in terms of a power series in
<span class="math">\(\Delta t\)</span>. The error <span class="math">\(R^n\)</span> is commonly referred to as the <em>truncation
error</em> of the finite difference formula.</p>
<p>The Taylor series formula often found in calculus books takes the form</p>
<div class="math">
\[f(x+h) = \sum_{i=0}^\infty \frac{1}{i!}\frac{d^if}{dx^i}(x)h^i{\thinspace .}\]</div>
<p>In our application,
we expand the Taylor series around the point where the finite difference
formula approximates the derivative. The Taylor series of <span class="math">\(u^n\)</span> at <span class="math">\(t_n\)</span>
is simply <span class="math">\(u(t_n)\)</span>, while the Taylor sereis of <span class="math">\(u^{n-1}\)</span> at <span class="math">\(t_n\)</span> must
employ the general formula,</p>
<div class="math">
\[\begin{split}u(t_{n-1}) = u(t-\Delta t) &amp;= \sum_{i=0}^\infty \frac{1}{i!}\frac{d^iu}{dt^i}(t_n)(-\Delta t)^i\\
&amp; = u(t_n) - u'(t_n)\Delta t + {\frac{1}{2}}u''(t_n)\Delta t^2
+ {\mathcal{O}(\Delta t^3)},\end{split}\]</div>
<p>where <span class="math">\({\mathcal{O}(\Delta t^3)}\)</span> means a power-series in <span class="math">\(\Delta t\)</span> where
the lowest power is <span class="math">\(\Delta t^3\)</span>. We assume that <span class="math">\(\Delta t\)</span> is small such that
<span class="math">\(\Delta t^p \gg \Delta t^q\)</span> if <span class="math">\(p\)</span> is smaller than <span class="math">\(q\)</span>.
The details of higher-order terms
in <span class="math">\(\Delta t\)</span> are therefore not of much interest.
Inserting the Taylor series above in the left-hand side of1
<a href="#equation-trunc:fd:bw3">(2)</a> gives rise to some algebra:</p>
<div class="math">
\[\begin{split}[D_t^-u]^n - u'(t_n) &amp;= \frac{u(t_n) - u(t_{n-1})}{\Delta t} - u'(t_n)\\
&amp;= \frac{u(t_n) - (u(t_n) - u'(t_n)\Delta t + {\frac{1}{2}}u''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^3)} )}{\Delta t} - u'(t_n)\\
&amp;= -{\frac{1}{2}}u''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)} ),\end{split}\]</div>
<p>which is, according to
<a href="#equation-trunc:fd:bw3">(2)</a>, the truncation error:</p>
<div class="math">
\[R^n = - {\frac{1}{2}}u''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)} )
{\thinspace .}\]</div>
<p>The dominating term for small <span class="math">\(\Delta t\)</span> is <span class="math">\(-{\frac{1}{2}}u''(t_n)\Delta t\)</span>,
which is proportional to <span class="math">\(\Delta t\)</span>, and we say that the truncation error
is of <em>first order</em> in <span class="math">\(\Delta t\)</span>.</p>
</div>
<div class="section" id="example-the-forward-difference-for">
<span id="trunc-fd-forward"></span><h2>Example: The forward difference for <span class="math">\(u'(t)\)</span><a class="headerlink" href="#example-the-forward-difference-for" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-3"></span><p id="index-4">We can analyze the approximation error in the forward difference</p>
<div class="math">
\[u'(t_n) \approx [D_t^+ u]^n = \frac{u^{n+1}-u^n}{\Delta t},\]</div>
<p>by writing</p>
<div class="math">
\[R^n = [D_t^+ u]^n - u'(t_n),\]</div>
<p>and expanding <span class="math">\(u^{n+1}\)</span> in a Taylor series around <span class="math">\(t_n\)</span>,</p>
<div class="math">
\[u(t_{n+1}) = u(t_n) + u'(t_n)\Delta t +
{\frac{1}{2}}u''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^3)}
{\thinspace .}\]</div>
<p>The result becomes</p>
<div class="math">
\[R = {\frac{1}{2}}u''(t_n)\Delta t +
{\mathcal{O}(\Delta t^2)},\]</div>
<p>showing that also the forward difference is of first order.</p>
</div>
<div class="section" id="example-the-central-difference-for">
<span id="trunc-fd-central"></span><h2>Example: The central difference for <span class="math">\(u'(t)\)</span><a class="headerlink" href="#example-the-central-difference-for" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-5"></span><p id="index-6">For the central difference approximation,</p>
<div class="math">
\[u'(t_n)\approx [ D_tu]^n, \quad [D_tu]^n =
\frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t},\]</div>
<p>we write</p>
<div class="math">
\[R^n = [ D_tu]^n - u'(t_n),\]</div>
<p>and expand <span class="math">\(u(t_{n+\frac{1}{2}})\)</span> and
<span class="math">\(u(t_{n-1/2})\)</span> in Taylor series around the point <span class="math">\(t_n\)</span> where
the derivative is evaluated. We have</p>
<div class="math">
\[\begin{split}u(t_{n+\frac{1}{2}}) = &amp;u(t_n) + u'(t_n)\frac{1}{2}\Delta t +
{\frac{1}{2}}u''(t_n)(\frac{1}{2}\Delta t)^2 + \\
&amp; \frac{1}{6}u'''(t_n) (\frac{1}{2}\Delta t)^3
+ \frac{1}{24}u''''(t_n) (\frac{1}{2}\Delta t)^4 + \\
&amp; \frac{1}{120}u''''(t_n) (\frac{1}{2}\Delta t)^5 + {\mathcal{O}(\Delta t^6)},\\
u(t_{n-1/2}) = &amp;u(t_n) - u'(t_n)\frac{1}{2}\Delta t +
{\frac{1}{2}}u''(t_n)(\frac{1}{2}\Delta t)^2 - \\
&amp; \frac{1}{6}u'''(t_n) (\frac{1}{2}\Delta t)^3
+ \frac{1}{24}u''''(t_n) (\frac{1}{2}\Delta t)^4 - \\
&amp; \frac{1}{120}u'''''(t_n) (\frac{1}{2}\Delta t)^5 + {\mathcal{O}(\Delta t^6)}
{\thinspace .}\end{split}\]</div>
<p>Now,</p>
<div class="math">
\[u(t_{n+\frac{1}{2}}) - u(t_{n-1/2}) = u'(t_n)\Delta t + \frac{1}{24}u'''(t_n) \Delta t^3 + \frac{1}{960}u'''''(t_n) \Delta t^5 + {\mathcal{O}(\Delta t^7)}
{\thinspace .}\]</div>
<p>By collecting terms in <span class="math">\([D_t u]^n - u(t_n)\)</span> we find the truncation error
to be</p>
<div class="math">
\[R^n = \frac{1}{24}u'''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^4)},\]</div>
<p>with only even powers of <span class="math">\(\Delta t\)</span>. Since <span class="math">\(R\sim \Delta t^2\)</span> we say
the centered difference is of <em>second order</em> in <span class="math">\(\Delta t\)</span>.</p>
</div>
<div class="section" id="overview-of-leading-order-error-terms-in-finite-difference-formulas">
<span id="trunc-table"></span><h2>Overview of leading-order error terms in finite difference formulas<a class="headerlink" href="#overview-of-leading-order-error-terms-in-finite-difference-formulas" title="Permalink to this headline">¶</a></h2>
<p id="index-7">Here we list the leading-order terms of the truncation errors
associated with several common finite difference formulas for the
first and second derivatives.</p>
<div class="math" id="equation-trunc:table:fd1:center:eq">
<span class="eqno">(3)</span>\[     \lbrack D_tu \rbrack^n = \frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t} = u'(t_n) + R^n
     ,\]</div>
<div class="math" id="equation-trunc:table:fd1:center">
<span class="eqno">(4)</span>\[     R^n = \frac{1}{24}u'''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^4)}\]</div>
<div class="math" id="equation-trunc:table:fd1:center2:eq">
<span class="eqno">(5)</span>\[     \lbrack D_{2t}u \rbrack^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t} = u'(t_n) + R^n
     ,\]</div>
<div class="math" id="equation-trunc:table:fd1:center2">
<span class="eqno">(6)</span>\[     R^n = \frac{1}{6}u'''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^4)}\]</div>
<div class="math" id="equation-trunc:table:fd1:bw:eq">
<span class="eqno">(7)</span>\[     \lbrack D_t^-u \rbrack^n = \frac{u^{n} - u^{n-1}}{\Delta t} = u'(t_n) + R^n
     ,\]</div>
<div class="math" id="equation-trunc:table:fd1:bw">
<span class="eqno">(8)</span>\[     R^n = -{\frac{1}{2}}u''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}\]</div>
<div class="math" id="equation-trunc:table:fd1:fw:eq">
<span class="eqno">(9)</span>\[     \lbrack D_t^+u \rbrack^n = \frac{u^{n+1} - u^{n}}{\Delta t} = u'(t_n) + R^n
     ,\]</div>
<div class="math" id="equation-trunc:table:fd1:fw">
<span class="eqno">(10)</span>\[     R^n = {\frac{1}{2}}u''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}\]</div>
<div class="math" id="equation-trunc:table:fd1:theta:eq">
<span class="eqno">(11)</span>\[     [\bar D_tu]^{n+\theta} = \frac{u^{n+1} - u^{n}}{\Delta t} = u'(t_{n+\theta}) + R^{n+\theta}
     ,\]</div>
<div class="math" id="equation-trunc:table:fd1:theta">
<span class="eqno">(12)</span>\[     R^{n+\theta} = \frac{1}{2}(1-2\theta)u''(t_{n+\theta})\Delta t -
     \frac{1}{6}((1 - \theta)^3 - \theta^3)u'''(t_{n+\theta})\Delta t^2 +
     {\mathcal{O}(\Delta t^3)}\]</div>
<div class="math" id="equation-trunc:table:fd1:bw2:eq">
<span class="eqno">(13)</span>\[     \lbrack D_t^{2-}u \rbrack^n = \frac{3u^{n} - 4u^{n-1} + u^{n-2}}{2\Delta t} = u'(t_n) + R^n
     ,\]</div>
<div class="math" id="equation-trunc:table:fd1:bw2">
<span class="eqno">(14)</span>\[     R^n = -\frac{1}{3}u'''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^3)}\]</div>
<div class="math" id="equation-trunc:table:fd2:center:eq">
<span class="eqno">(15)</span>\[     \lbrack D_tD_t u \rbrack^n = \frac{u^{n+1} - 2u^{n} + u^{n-1}}{\Delta t^2} = u''(t_n) + R^n
     ,\]</div>
<div class="math" id="equation-trunc:table:fd2:center">
<span class="eqno">(16)</span>\[     R^n = \frac{1}{12}u''''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^4)}\]</div>
<p>It will also be convenient to have the truncation errors for
various means or averages. The
weighted arithmetic mean leads to</p>
<div class="math" id="equation-trunc:table:avg:theta:eq">
<span class="eqno">(17)</span>\[     [\overline{u}^{t,\theta}]^{n+\theta}
      = \theta u^{n+1} + (1-\theta)u^n =
     u(t_{n+\theta}) + R^{n+\theta},\]</div>
<div class="math" id="equation-trunc:table:avg:theta">
<span class="eqno">(18)</span>\[     R^{n+\theta} = {\frac{1}{2}}u''(t_{n+\theta})\Delta t^2\theta (1-\theta) +
     {\mathcal{O}(\Delta t^3)}
     {\thinspace .}\]</div>
<p>The standard arithmetic mean follows from this formula when
<span class="math">\(\theta=1/2\)</span>. Expressed at point <span class="math">\(t_n\)</span> we get</p>
<div class="math" id="equation-trunc:table:avg:arith:eq">
<span class="eqno">(19)</span>\[     [\overline{u}^{t}]^{n} = \frac{1}{2}(u^{n-\frac{1}{2}} + u^{n+\frac{1}{2}})
     = u(t_n) + R^{n},\]</div>
<div class="math" id="equation-trunc:table:avg:arith">
<span class="eqno">(20)</span>\[     R^{n} = \frac{1}{8}u''(t_{n})\Delta t^2 + \frac{1}{384}u''''(t_n)\Delta t^4
     + {\mathcal{O}(\Delta t^6)}{\thinspace .}\]</div>
<p>The geometric mean also has an error <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>:</p>
<div class="math" id="equation-trunc:table:avg:geom:eq">
<span class="eqno">(21)</span>\[     [\overline{u^2}^{t,g}]^{n} = u^{n-\frac{1}{2}}u^{n+\frac{1}{2}} = (u^n)^2 + R^n,\]</div>
<div class="math" id="equation-trunc:table:avg:geom">
<span class="eqno">(22)</span>\[     R^n = - \frac{1}{4}u'(t_n)^2\Delta t^2  + \frac{1}{4}u(t_n)u''(t_n)\Delta t^2
     + {\mathcal{O}(\Delta t^4)}
     {\thinspace .}\]</div>
<p>The harmonic mean is also second-order accurate:</p>
<div class="math" id="equation-trunc:table:avg:harm:eq">
<span class="eqno">(23)</span>\[     [\overline{u}^{t,h}]^{n} = u^n = \frac{2}{\frac{1}{u^{n-\frac{1}{2}}} + \frac{1}{u^{n+\frac{1}{2}}}}
     + R^{n+\frac{1}{2}},\]</div>
<div class="math" id="equation-trunc:table:avg:harm">
<span class="eqno">(24)</span>\[     R^n = - \frac{u'(t_n)^2}{4u(t_n)}\Delta t^2 + \frac{1}{8}u''(t_n)\Delta t^2
     {\thinspace .}\]</div>
</div>
<div class="section" id="software-for-computing-truncation-errors">
<span id="trunc-sympy"></span><h2>Software for computing truncation errors<a class="headerlink" href="#software-for-computing-truncation-errors" title="Permalink to this headline">¶</a></h2>
<p>We can use <tt class="docutils literal"><span class="pre">sympy</span></tt> to aid calculations with Taylor series.
The derivatives can be defined as symbols, say <tt class="docutils literal"><span class="pre">D3f</span></tt> for the
3rd derivative of some function <span class="math">\(f\)</span>. A truncated Taylor series
can then be written as <tt class="docutils literal"><span class="pre">f</span> <span class="pre">+</span> <span class="pre">D1f*h</span> <span class="pre">+</span> <span class="pre">D2f*h**2/2</span></tt>. The following
class takes some symbol <tt class="docutils literal"><span class="pre">f</span></tt> for the function in question
and makes a list of symbols for the derivatives. The
<tt class="docutils literal"><span class="pre">__call__</span></tt> method computes the symbolic form of the series
truncated at <tt class="docutils literal"><span class="pre">num_terms</span></tt> terms.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sp</span>

<span class="k">class</span> <span class="nc">TaylorSeries</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for symbolic Taylor series.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">num_terms</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">num_terms</span>
        <span class="c"># Introduce symbols for the derivatives</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;D</span><span class="si">%d%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the truncated Taylor series at x+h.&quot;&quot;&quot;</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">terms</span> <span class="o">+=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="n">i</span>
        <span class="k">return</span> <span class="n">terms</span>
</pre></div>
</div>
<p>We may, for example, use this class to compute the truncation error
of the Forward Euler finite difference formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">truncation_errors</span> <span class="kn">import</span> <span class="n">TaylorSeries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;u dt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_Taylor</span> <span class="o">=</span> <span class="n">TaylorSeries</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_Taylor</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="go">D1u*dt + D2u*dt**2/2 + D3u*dt**3/6 + D4u*dt**4/24 + u</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FE</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_Taylor</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FE</span>
<span class="go">(D1u*dt + D2u*dt**2/2 + D3u*dt**3/6 + D4u*dt**4/24)/dt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simplify</span><span class="p">(</span><span class="n">FE</span><span class="p">)</span>
<span class="go">D1u + D2u*dt/2 + D3u*dt**2/6 + D4u*dt**3/24</span>
</pre></div>
</div>
<p>The truncation error consists of the terms after the first one (<span class="math">\(u'\)</span>).</p>
<p>The module file <a class="reference external" href="http://tinyurl.com/jvzzcfn/trunc/truncation_errors.py">trunc/truncation_errors.py</a> contains another class <tt class="docutils literal"><span class="pre">DiffOp</span></tt> with symbolic expressions for
most of the truncation errors listed in the previous section.
For example:</p>
<div class="highlight-text"><div class="highlight"><pre>&gt;&gt;&gt; from truncation_errors import DiffOp
&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; u = Symbol(&#39;u&#39;)
&gt;&gt;&gt; diffop = DiffOp(u, independent_variable=&#39;t&#39;)
&gt;&gt;&gt; diffop[&#39;geometric_mean&#39;]
-D1u**2*dt**2/4 - D1u*D3u*dt**4/48 + D2u**2*dt**4/64 + ...
&gt;&gt;&gt; diffop[&#39;Dtm&#39;]
D1u + D2u*dt/2 + D3u*dt**2/6 + D4u*dt**3/24
&gt;&gt;&gt; &gt;&gt;&gt; diffop.operator_names()
[&#39;geometric_mean&#39;, &#39;harmonic_mean&#39;, &#39;Dtm&#39;, &#39;D2t&#39;, &#39;DtDt&#39;,
 &#39;weighted_arithmetic_mean&#39;, &#39;Dtp&#39;, &#39;Dt&#39;]
</pre></div>
</div>
<p>The indexing of <tt class="docutils literal"><span class="pre">diffop</span></tt> applies names that correspond to the operators:
<tt class="docutils literal"><span class="pre">Dtp</span></tt> for <span class="math">\(D^+_t\)</span>, <tt class="docutils literal"><span class="pre">Dtm</span></tt> for <span class="math">\(D_t^-\)</span>, <tt class="docutils literal"><span class="pre">Dt</span></tt> for <span class="math">\(D_t\)</span>, <tt class="docutils literal"><span class="pre">D2t</span></tt> for
<span class="math">\(D_{2t}\)</span>, <tt class="docutils literal"><span class="pre">DtDt</span></tt> for <span class="math">\(D_tD_t\)</span>.</p>
</div>
</div>
<div class="section" id="truncation-errors-in-exponential-decay-ode">
<span id="trunc-decay"></span><h1>Truncation errors in exponential decay ODE<a class="headerlink" href="#truncation-errors-in-exponential-decay-ode" title="Permalink to this headline">¶</a></h1>
<p id="index-8">We shall now compute the truncation error of a finite difference
scheme for a differential equation.
Our first problem involves the following
the linear ODE modeling exponential decay,</p>
<div class="math" id="equation-trunc:decay:ode">
<span class="eqno">(25)</span>\[     u'(t)=-au(t){\thinspace .}\]</div>
<div class="section" id="truncation-error-of-the-forward-euler-scheme">
<span id="trunc-decay-fe"></span><h2>Truncation error of the Forward Euler scheme<a class="headerlink" href="#truncation-error-of-the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>We begin with the Forward Euler scheme for discretizing <a href="#equation-trunc:decay:ode">(25)</a>:</p>
<div class="math" id="equation-trunc:decay:FE:scheme">
<span class="eqno">(26)</span>\[     \lbrack D_t^+ u = -au \rbrack^n\]\[     {\thinspace .}\]</div>
<p>The idea behind the truncation error computation is to insert
the exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> of the differential equation problem
<a href="#equation-trunc:decay:ode">(25)</a>
in the discrete equations <a href="#equation-trunc:decay:FE:scheme">(26)</a> and find the residual
that arises because <span class="math">\({u_{\small\mbox{e}}}\)</span> does not solve the discrete equations.
Instead, <span class="math">\({u_{\small\mbox{e}}}\)</span> solves the discrete equations with a residual <span class="math">\(R^n\)</span>:</p>
<div class="math" id="equation-trunc:decay:FE:uex">
<span class="eqno">(27)</span>\[     [D_t^+ {u_{\small\mbox{e}}} + a{u_{\small\mbox{e}}} = R]^n\]\[     {\thinspace .}\]</div>
<p>From <a href="#equation-trunc:table:fd1:fw:eq">(9)</a>-<a href="#equation-trunc:table:fd1:fw">(10)</a> it follows that</p>
<div class="math">
\[[D_t^+ {u_{\small\mbox{e}}}]^n = {u_{\small\mbox{e}}}'(t_n) +
\frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)},\]</div>
<p>which inserted in <a href="#equation-trunc:decay:FE:uex">(27)</a> results in</p>
<div class="math">
\[{u_{\small\mbox{e}}}'(t_n) +
\frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}
+ a{u_{\small\mbox{e}}}(t_n) = R^n
{\thinspace .}\]</div>
<p>Now, <span class="math">\({u_{\small\mbox{e}}}'(t_n) + a{u_{\small\mbox{e}}}^n = 0\)</span> since <span class="math">\({u_{\small\mbox{e}}}\)</span> solves the differential equation.
The remaining terms constitute the residual:</p>
<div class="math" id="equation-trunc:decay:FE:R">
<span class="eqno">(28)</span>\[     R^n = \frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}\]\[     {\thinspace .}\]</div>
<p>This is the truncation error <span class="math">\(R^n\)</span> of the Forward Euler scheme.</p>
<p>Because <span class="math">\(R^n\)</span> is proportional to <span class="math">\(\Delta t\)</span>, we say that
the Forward Euler scheme is of first order in <span class="math">\(\Delta t\)</span>.
However, the truncation error
is just one error measure, and it is not equal to the true error
<span class="math">\({u_{\small\mbox{e}}}^n - u^n\)</span>. For this simple model problem we can compute
a range of different error measures for the Forward Euler scheme,
including the true error <span class="math">\({u_{\small\mbox{e}}}^n - u^n\)</span>, and all of them
have dominating terms proportional to <span class="math">\(\Delta t\)</span>.</p>
</div>
<div class="section" id="truncation-error-of-the-crank-nicolson-scheme">
<span id="trunc-decay-cn"></span><h2>Truncation error of the Crank-Nicolson scheme<a class="headerlink" href="#truncation-error-of-the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p>For the Crank-Nicolson scheme,</p>
<div class="math" id="equation-trunc:decay:CN:scheme">
<span class="eqno">(29)</span>\[     [D_t u = -au]^{n+\frac{1}{2}},\]</div>
<p>we compute the truncation error by inserting the exact solution of
the ODE and adding a residual <span class="math">\(R\)</span>,</p>
<div class="math" id="equation-trunc:decay:CN:scheme:R">
<span class="eqno">(30)</span>\[     [D_t {u_{\small\mbox{e}}} + a\overline{{u_{\small\mbox{e}}}}^{t} = R]^{n+\frac{1}{2}}
     {\thinspace .}\]</div>
<p>The term <span class="math">\([D_t{u_{\small\mbox{e}}}]^{n+\frac{1}{2}}\)</span> is easily computed
from <a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a>
by replacing <span class="math">\(n\)</span>
with <span class="math">\(n+{\frac{1}{2}}\)</span> in the formula,</p>
<div class="math">
\[\lbrack D_t{u_{\small\mbox{e}}}\rbrack^{n+\frac{1}{2}} = u'(t_{n+\frac{1}{2}}) +
\frac{1}{24}{u_{\small\mbox{e}}}'''(t_{n+\frac{1}{2}})\Delta t^2 + {\mathcal{O}(\Delta t^4)}{\thinspace .}\]</div>
<p>The arithmetic mean is related to <span class="math">\(u(t_{n+\frac{1}{2}})\)</span> by
<a href="#equation-trunc:table:avg:arith:eq">(19)</a>-<a href="#equation-trunc:table:avg:arith">(20)</a> so</p>
<div class="math">
\[[a\overline{{u_{\small\mbox{e}}}}^{t}]^{n+\frac{1}{2}}
= u(t_{n+\frac{1}{2}}) + \frac{1}{8}u''(t_{n})\Delta t^2 +
+ {\mathcal{O}(\Delta t^4)}{\thinspace .}\]</div>
<p>Inserting these expressions in <a href="#equation-trunc:decay:CN:scheme:R">(30)</a> and
observing that <span class="math">\({u_{\small\mbox{e}}}'(t_{n+\frac{1}{2}}) +a{u_{\small\mbox{e}}}^{n+\frac{1}{2}} = 0\)</span>, because
<span class="math">\({u_{\small\mbox{e}}}(t)\)</span> solves the ODE <span class="math">\(u'(t)=-au(t)\)</span> at any point <span class="math">\(t\)</span>,
we find that</p>
<div class="math">
\[R^{n+\frac{1}{2}} = \left(
\frac{1}{24}{u_{\small\mbox{e}}}'''(t_{n+\frac{1}{2}}) + \frac{1}{8}u''(t_{n})
\right)\Delta t^2 + {\mathcal{O}(\Delta t^4)}\]</div>
<p>Here, the truncation error is of second order because the leading
term in <span class="math">\(R\)</span> is proportional to <span class="math">\(\Delta t^2\)</span>.</p>
<p>At this point it is wise to redo some of the computations above
to establish the truncation error of the Backward Euler scheme,
see <a class="reference internal" href="#trunc-exer-decay-be"><em>Exercise 4: Truncation error of the Backward Euler scheme</em></a>.</p>
</div>
<div class="section" id="truncation-error-of-the-rule">
<span id="trunc-decay-theta"></span><h2>Truncation error of the <span class="math">\(\theta\)</span>-rule<a class="headerlink" href="#truncation-error-of-the-rule" title="Permalink to this headline">¶</a></h2>
<p>We may also compute the truncation error of the <span class="math">\(\theta\)</span>-rule,</p>
<div class="math">
\[[\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta}
{\thinspace .}\]</div>
<p>Our computational task is to find <span class="math">\(R^{n+\theta}\)</span> in</p>
<div class="math">
\[[\bar D_t {u_{\small\mbox{e}}}  + a\overline{{u_{\small\mbox{e}}}}^{t,\theta} = R]^{n+\theta}
{\thinspace .}\]</div>
<p>From <a href="#equation-trunc:table:fd1:theta:eq">(11)</a>-<a href="#equation-trunc:table:fd1:theta">(12)</a> and
<a href="#equation-trunc:table:avg:theta:eq">(17)</a>-<a href="#equation-trunc:table:avg:theta">(18)</a> we get
expressions for the terms with <span class="math">\({u_{\small\mbox{e}}}\)</span>.
Using that <span class="math">\({u_{\small\mbox{e}}}'(t_{n+\theta}) + a{u_{\small\mbox{e}}}(t_{n+\theta})=0\)</span>,
we end up with</p>
<div class="math">
\[R^{n+\theta}
=
({\frac{1}{2}}-\theta){u_{\small\mbox{e}}}''(t_{n+\theta})\Delta t +
\frac{1}{2}\theta (1-\theta){u_{\small\mbox{e}}}''(t_{n+\theta})\Delta t^2 + \nonumber\]</div>
<div class="math">
\[ \frac{1}{2}(\theta^2 -\theta + 3){u_{\small\mbox{e}}}'''(t_{n+\theta})\Delta t^2
+ {\mathcal{O}(\Delta t^3)}\]</div>
<p>For <span class="math">\(\theta =1/2\)</span> the first-order term vanishes and the scheme is of
second order, while for <span class="math">\(\theta\neq 1/2\)</span> we only have a first-order scheme.</p>
</div>
<div class="section" id="using-symbolic-software">
<span id="trunc-decay-software"></span><h2>Using symbolic software<a class="headerlink" href="#using-symbolic-software" title="Permalink to this headline">¶</a></h2>
<p>The previously mentioned <tt class="docutils literal"><span class="pre">truncation_error</span></tt> module can be used to
automate the Taylor series expansions and the process of
collecting terms. Here is an example on possible use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">truncation_error</span> <span class="kn">import</span> <span class="n">DiffOp</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">decay</span><span class="p">():</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;u a&#39;</span><span class="p">)</span>
    <span class="n">diffop</span> <span class="o">=</span> <span class="n">DiffOp</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span>
                    <span class="n">num_terms_Taylor_series</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">D1u</span> <span class="o">=</span> <span class="n">diffop</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># symbol for du/dt</span>
    <span class="n">ODE</span> <span class="o">=</span> <span class="n">D1u</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span>     <span class="c"># define ODE</span>

    <span class="c"># Define schemes</span>
    <span class="n">FE</span> <span class="o">=</span> <span class="n">diffop</span><span class="p">[</span><span class="s">&#39;Dtp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span>
    <span class="n">CN</span> <span class="o">=</span> <span class="n">diffop</span><span class="p">[</span><span class="s">&#39;Dt&#39;</span> <span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span>
    <span class="n">BE</span> <span class="o">=</span> <span class="n">diffop</span><span class="p">[</span><span class="s">&#39;Dtm&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">diffop</span><span class="p">[</span><span class="s">&#39;barDt&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">diffop</span><span class="p">[</span><span class="s">&#39;weighted_arithmetic_mean&#39;</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sm</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
    <span class="c"># Residuals (truncation errors)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;FE&#39;</span><span class="p">:</span> <span class="n">FE</span><span class="o">-</span><span class="n">ODE</span><span class="p">,</span> <span class="s">&#39;BE&#39;</span><span class="p">:</span> <span class="n">BE</span><span class="o">-</span><span class="n">ODE</span><span class="p">,</span> <span class="s">&#39;CN&#39;</span><span class="p">:</span> <span class="n">CN</span><span class="o">-</span><span class="n">ODE</span><span class="p">,</span>
         <span class="s">&#39;theta&#39;</span><span class="p">:</span> <span class="n">theta</span><span class="o">-</span><span class="n">ODE</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">R</span>
</pre></div>
</div>
<p>The returned dictionary becomes</p>
<div class="highlight-text"><div class="highlight"><pre>decay: {
 &#39;BE&#39;: D2u*dt/2 + D3u*dt**2/6,
 &#39;FE&#39;: -D2u*dt/2 + D3u*dt**2/6,
 &#39;CN&#39;: D3u*dt**2/24,
 &#39;theta&#39;: -D2u*a*dt**2*theta**2/2 + D2u*a*dt**2*theta/2 -
           D2u*dt*theta + D2u*dt/2 + D3u*a*dt**3*theta**3/3 -
           D3u*a*dt**3*theta**2/2 + D3u*a*dt**3*theta/6 +
           D3u*dt**2*theta**2/2 - D3u*dt**2*theta/2 + D3u*dt**2/6,
}
</pre></div>
</div>
<p>The results are in correspondence with our hand-derived expressions.</p>
</div>
<div class="section" id="empirical-verification-of-the-truncation-error">
<span id="trunc-decay-estimate-r"></span><h2>Empirical verification of the truncation error<a class="headerlink" href="#empirical-verification-of-the-truncation-error" title="Permalink to this headline">¶</a></h2>
<p>The task of this section is to demonstrate how we can compute
the truncation error <span class="math">\(R\)</span> numerically. For example, the truncation
error of the Forward Euler scheme applied to the decay ODE <span class="math">\(u'=-ua\)</span>
is</p>
<div class="math" id="equation-trunc:decay:FE:R:comp">
<span class="eqno">(31)</span>\[     R^n = [D_t^+{u_{\small\mbox{e}}} + a{u_{\small\mbox{e}}}]^n\]\[     {\thinspace .}\]</div>
<p>If we happen to know the exact solution <span class="math">\({u_{\small\mbox{e}}}(t)\)</span>, we can easily evaluate
<span class="math">\(R^n\)</span> from the above formula.</p>
<p>To estimate how <span class="math">\(R\)</span> varies with the discretization parameter <span class="math">\(\Delta
t\)</span>, which has been our focus in the previous mathematical derivations,
we first make the assumption that <span class="math">\(R=C\Delta t^r\)</span> for
appropriate constants <span class="math">\(C\)</span> and
<span class="math">\(r\)</span> and small enough <span class="math">\(\Delta t\)</span>. The rate <span class="math">\(r\)</span> can be estimated from a series
of experiments where <span class="math">\(\Delta t\)</span> is varied. Suppose we have
<span class="math">\(m\)</span> experiments <span class="math">\((\Delta t_i, R_i)\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>.
For two consecutive experiments <span class="math">\((\Delta t_{i-1}, R_{i-1})\)</span>
and <span class="math">\((\Delta t_i, R_i)\)</span>, a corresponding <span class="math">\(r_{i-1}\)</span> can be estimated by</p>
<div class="math" id="equation-trunc:R:empir1">
<span class="eqno">(32)</span>\[     r_{i-1} = \frac{\ln (R_{i-1}/R_i)}{\ln (\Delta t_{i-1}/\Delta t_i)},\]</div>
<p>for <span class="math">\(i=1,\ldots,m-1\)</span>. Note that the truncation error <span class="math">\(R_i\)</span> varies
through the mesh, so <a href="#equation-trunc:R:empir1">(32)</a> is to be applied
pointwise. A complicating issue is that <span class="math">\(R_i\)</span> and <span class="math">\(R_{i-1}\)</span> refer to
different meshes. Pointwise comparisons of the truncation error at a
certain point in all meshes therefore requires any
computed <span class="math">\(R\)</span> to be restricted to the <em>coarsest mesh</em> and that
all finer meshes contain all the points in the coarsest mesh.
Suppose we have
<span class="math">\(N_0\)</span> intervals in the coarsest mesh. Inserting a superscript <span class="math">\(n\)</span> in
<a href="#equation-trunc:R:empir1">(32)</a>, where <span class="math">\(n\)</span> counts mesh points in the coarsest
mesh, <span class="math">\(n=0,\ldots,N_0\)</span>, leads to the formula</p>
<div class="math" id="equation-trunc:R:empir2">
<span class="eqno">(33)</span>\[     r_{i-1}^n = \frac{\ln (R_{i-1}^n/R_i^n)}{\ln (\Delta t_{i-1}/\Delta t_i)}
     {\thinspace .}\]</div>
<p>Experiments are most conveniently defined by <span class="math">\(N_0\)</span> and a number of
refinements <span class="math">\(m\)</span>. Suppose each mesh have twice as many cells <span class="math">\(N_i\)</span> as the previous
one:</p>
<div class="math">
\[N_i = 2^iN_0,\quad \Delta t_i = TN_i^{-1},\]</div>
<p>where <span class="math">\([0,T]\)</span> is the total time interval for the computations.
Suppose the computed <span class="math">\(R_i\)</span> values on the mesh with <span class="math">\(N_i\)</span> intervals
are stored in an array <tt class="docutils literal"><span class="pre">R[i]</span></tt> (<tt class="docutils literal"><span class="pre">R</span></tt> being a list of arrays, one for
each mesh). Restricting this <span class="math">\(R_i\)</span> function to
the coarsest mesh means extracting every <span class="math">\(N_i/N_0\)</span> point and is done
as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stride</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">N_0</span>
<span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">stride</span><span class="p">]</span>
</pre></div>
</div>
<p>The quantity <tt class="docutils literal"><span class="pre">R[i][n]</span></tt> now corresponds to <span class="math">\(R_i^n\)</span>.</p>
<p>In addition to estimating <span class="math">\(r\)</span> for the pointwise values
of <span class="math">\(R=C\Delta t^r\)</span>, we may also consider an integrated quantity
on mesh <span class="math">\(i\)</span>,</p>
<div class="math">
\[R_{I,i} = \left(\Delta t_i\sum_{n=0}^{N_i} (R_i^n)^2\right)^\frac{1}{2}\approx \int_0^T R_i(t)dt
{\thinspace .}\]</div>
<p>The sequence <span class="math">\(R_{I,i}\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>, is also expected to
behave as <span class="math">\(C\Delta t^r\)</span>, with the same <span class="math">\(r\)</span> as for the pointwise quantity
<span class="math">\(R\)</span>, as <span class="math">\(\Delta t\rightarrow 0\)</span>.</p>
<p>The function below computes the <span class="math">\(R_i\)</span> and <span class="math">\(R_{I,i}\)</span> quantities, plots
them and compares with
the theoretically derived truncation error (<tt class="docutils literal"><span class="pre">R_a</span></tt>) if available.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="n">truncation_error</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the truncation error in a problem with one independent</span>
<span class="sd">    variable, using m meshes, and estimate the convergence</span>
<span class="sd">    rate of the truncation error.</span>

<span class="sd">    The user-supplied function truncation_error(dt, N) computes</span>
<span class="sd">    the truncation error on a uniform mesh with N intervals of</span>
<span class="sd">    length dt::</span>

<span class="sd">      R, t, R_a = truncation_error(dt, N)</span>

<span class="sd">    where R holds the truncation error at points in the array t,</span>
<span class="sd">    and R_a are the corresponding theoretical truncation error</span>
<span class="sd">    values (None if not available).</span>

<span class="sd">    The truncation_error function is run on a series of meshes</span>
<span class="sd">    with 2**i*N_0 intervals, i=0,1,...,m-1.</span>
<span class="sd">    The values of R and R_a are restricted to the coarsest mesh.</span>
<span class="sd">    and based on these data, the convergence rate of R (pointwise)</span>
<span class="sd">    and time-integrated R can be estimated empirically.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">N_0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>

    <span class="n">R_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c"># time-integrated R values on various meshes</span>
    <span class="n">R</span>   <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">m</span>    <span class="c"># time series of R restricted to coarsest mesh</span>
    <span class="n">R_a</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">m</span>    <span class="c"># time series of R_a restricted to coarsest mesh</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">legends_R</span> <span class="o">=</span> <span class="p">[];</span>  <span class="n">legends_R_a</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># all legends of curves</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">R_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">truncation_error</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">R_I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t_coarse</span> <span class="o">=</span> <span class="n">t</span>           <span class="c"># the coarsest mesh</span>

        <span class="n">stride</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">N_0</span>
        <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">stride</span><span class="p">]</span>      <span class="c"># restrict to coarsest mesh</span>
        <span class="n">R_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R_a</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">stride</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_coarse</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">legends_R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;N=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_coarse</span><span class="p">,</span> <span class="n">R_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
            <span class="n">legends_R_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;N=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">makeplot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;pointwise truncation error&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends_R</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;R_series.png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;R_series.pdf&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;pointwise error in estimated truncation error&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends_R_a</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;R_error.png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;R_error.pdf&#39;</span><span class="p">)</span>

    <span class="c"># Convergence rates</span>
    <span class="n">r_R_I</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">R_I</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;R integrated in time; r:&#39;</span><span class="p">,</span>
    <span class="k">print</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%.1f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_R_I</span><span class="p">])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>  <span class="c"># two-dim. numpy array</span>
    <span class="n">r_R</span> <span class="o">=</span> <span class="p">[</span><span class="n">convergence_rates</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">R</span><span class="p">[:,</span><span class="n">n</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
           <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_coarse</span><span class="p">))]</span>
</pre></div>
</div>
<p>The first <tt class="docutils literal"><span class="pre">makeplot</span></tt> block demonstrates how to build up two figures
in parallel, using <tt class="docutils literal"><span class="pre">plt.figure(i)</span></tt> to create and switch to figure number
<tt class="docutils literal"><span class="pre">i.</span></tt> Figure numbers start at 1. A logarithmic scale is used on the
<span class="math">\(y\)</span> axis since we expect that <span class="math">\(R\)</span> as a function of time (or mesh points)
is exponential. The reason is that the theoretical estimate
<a href="#equation-trunc:decay:FE:R">(28)</a> contains <span class="math">\({u_{\small\mbox{e}}}''\)</span>, which for the present model
goes like <span class="math">\(e^{-at}\)</span>. Taking the logarithm makes a straight line.</p>
<p>The code follows closely the previously
stated mathematical formulas, but the statements for computing the convergence
rates might deserve an explanation.
The generic help function <tt class="docutils literal"><span class="pre">convergence_rate(h,</span> <span class="pre">E)</span></tt> computes and returns
<span class="math">\(r_{i-1}\)</span>, <span class="math">\(i=1,\ldots,m-1\)</span> from <a href="#equation-trunc:R:empir2">(33)</a>,
given <span class="math">\(\Delta t_i\)</span> in <tt class="docutils literal"><span class="pre">h</span></tt> and
<span class="math">\(R_i^n\)</span> in <tt class="docutils literal"><span class="pre">E</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">r_R_I</span> <span class="pre">=</span> <span class="pre">convergence_rates(dt,</span> <span class="pre">R_I)</span></tt> computes the sequence
of rates <span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> for the model <span class="math">\(R_I\sim\Delta t^r\)</span>,
while the statements</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>  <span class="c"># two-dim. numpy array</span>
<span class="n">r_R</span> <span class="o">=</span> <span class="p">[</span><span class="n">convergence_rates</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">R</span><span class="p">[:,</span><span class="n">n</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_coarse</span><span class="p">))]</span>
</pre></div>
</div>
<p>compute the final rate <span class="math">\(r_{m-2}\)</span> for <span class="math">\(R^n\sim\Delta t^r\)</span> at each mesh
point <span class="math">\(t_n\)</span> in the coarsest mesh. This latter computation deserves
more explanation. Since <tt class="docutils literal"><span class="pre">R[i][n]</span></tt> holds the estimated
truncation error <span class="math">\(R_i^n\)</span> on mesh <span class="math">\(i\)</span>, at point <span class="math">\(t_n\)</span> in the coarsest mesh,
<tt class="docutils literal"><span class="pre">R[:,n]</span></tt> picks out the sequence <span class="math">\(R_i^n\)</span> for <span class="math">\(i=0,\ldots,m-1\)</span>.
The <tt class="docutils literal"><span class="pre">convergence_rate</span></tt> function computes the rates at <span class="math">\(t_n\)</span>, and by
indexing <tt class="docutils literal"><span class="pre">[-1]</span></tt> on the returned array from <tt class="docutils literal"><span class="pre">convergence_rate</span></tt>,
we pick the rate <span class="math">\(r_{m-2}\)</span>, which we believe is the best estimation since
it is based on the two finest meshes.</p>
<p>The <tt class="docutils literal"><span class="pre">estimate</span></tt> function is available in a module
<a class="reference external" href="http://tinyurl.com/jvzzcfn/trunc/trunc_empir.py">trunc_empir.py</a>.
Let us apply this function to estimate the truncation
error of the Forward Euler scheme. We need a function <tt class="docutils literal"><span class="pre">decay_FE(dt,</span> <span class="pre">N)</span></tt>
that can compute <a href="#equation-trunc:decay:FE:R:comp">(31)</a> at the
points in a mesh with time step <tt class="docutils literal"><span class="pre">dt</span></tt> and <tt class="docutils literal"><span class="pre">N</span></tt> intervals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">trunc_empir</span>

<span class="k">def</span> <span class="nf">decay_FE</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>  <span class="c"># exact solution, I and a are global</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u_e</span>  <span class="c"># naming convention when writing up the scheme</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">R</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="c"># Theoretical expression for the trunction error</span>
    <span class="n">R_a</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">R_a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c"># global variables needed in decay_FE</span>
    <span class="n">trunc_empir</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">decay_FE</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">N_0</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">makeplot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The estimated rates for the integrated truncation error <span class="math">\(R_I\)</span> become
1.1, 1.0, and 1.0 for this sequence of four meshes. All the rates
for <span class="math">\(R^n\)</span>, computed as <tt class="docutils literal"><span class="pre">r_R</span></tt>, are also very close to 1 at all mesh points.
The agreement between the theoretical formula <a href="#equation-trunc:decay:FE:R">(28)</a>
and the computed quantity (ref:eq:<cite>trunc:decay:FE:R:comp</cite>) is
very good, as illustrated in
Figures <a class="reference internal" href="#trunc-fig-fe-rates"><em>Estimated truncation error at mesh points for different meshes</em></a> and <a class="reference internal" href="#trunc-fig-fe-error"><em>Difference between theoretical and estimated truncation error at mesh points for different meshes</em></a>.
The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/trunc/trunc_decay_FE.py">trunc_decay_FE.py</a>
was used to perform the simulations and it can easily be modified to
test other schemes (see also Exericse <a class="reference internal" href="#trunc-exer-decay-estimate"><em>Exercise 5: Empirical estimation of truncation errors</em></a>).</p>
<div class="figure" id="trunc-fig-fe-rates">
<img alt="_images/R_series.png" src="_images/R_series.png" style="width: 400px;" />
<p class="caption"><em>Estimated truncation error at mesh points for different meshes</em></p>
</div>
<div class="figure" id="trunc-fig-fe-error">
<img alt="_images/R_error.png" src="_images/R_error.png" style="width: 400px;" />
<p class="caption"><em>Difference between theoretical and estimated truncation error at mesh points for different meshes</em></p>
</div>
</div>
<div class="section" id="increasing-the-accuracy-by-adding-correction-terms">
<span id="trunc-decay-corr"></span><h2>Increasing the accuracy by adding correction terms<a class="headerlink" href="#increasing-the-accuracy-by-adding-correction-terms" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-9"></span><p id="index-10">Now we ask the question: can we add terms in the differential equation
that can help increase the order of the truncation error? To be precise,
let us revisit the Forward Euler scheme for <span class="math">\(u'=-au\)</span>, insert the
exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span>, include a residual <span class="math">\(R\)</span>, but also include
new terms <span class="math">\(C\)</span>:</p>
<div class="math" id="equation-trunc:decay:FE:corr">
<span class="eqno">(34)</span>\[     \lbrack D_t^+ {u_{\small\mbox{e}}} + a{u_{\small\mbox{e}}} = C + R \rbrack^n{\thinspace .}\]</div>
<p>Inserting the Taylor expansions for <span class="math">\([D_t^+{u_{\small\mbox{e}}}]^n\)</span> and keeping
terms up to 3rd order in <span class="math">\(\Delta t\)</span> gives the equation</p>
<div class="math">
\[\frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t - \frac{1}{6}{u_{\small\mbox{e}}}'''(t_n)\Delta t^2
+ \frac{1}{24}{u_{\small\mbox{e}}}''''(t_n)\Delta t^3
+ {\mathcal{O}(\Delta t^4)}  = C^n + R^n{\thinspace .}\]</div>
<p>Can we find <span class="math">\(C^n\)</span> such that <span class="math">\(R^n\)</span> is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>?
Yes, by setting</p>
<div class="math">
\[C^n = \frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t,\]</div>
<p>we manage to cancel the first-order term and</p>
<div class="math">
\[R^n = \frac{1}{6}{u_{\small\mbox{e}}}'''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^3)}{\thinspace .}\]</div>
<p>The correction term <span class="math">\(C^n\)</span> introduces <span class="math">\(\frac{1}{2}\Delta t u''\)</span>
in the discrete equation, and we have to get rid of the derivative
<span class="math">\(u''\)</span>. One idea is to approximate <span class="math">\(u''\)</span> by a second-order accurate finite
difference formula, <span class="math">\(u''\approx (u^{n+1}-2u^n+u^{n-1})/\Delta t^2\)</span>,
but this introduces an additional time level
with <span class="math">\(u^{n-1}\)</span>. Another approach is to rewrite <span class="math">\(u''\)</span> in terms of <span class="math">\(u'\)</span>
or <span class="math">\(u\)</span> using the ODE:</p>
<div class="math">
\[u'=-au\quad\Rightarrow\quad u''=-au' = -a(-au)= a^2u{\thinspace .}\]</div>
<p>This  means that we can simply set
<span class="math">\(C^n = {\frac{1}{2}}a^2\Delta t u^n\)</span>. We can then either
solve the discrete equation</p>
<div class="math" id="equation-trunc:decay:corr:FE:discrete">
<span class="eqno">(35)</span>\[     [D_t^+ u = -au + {\frac{1}{2}}a^2\Delta t u]^n,\]</div>
<p>or we can equivalently discretize the perturbed ODE</p>
<div class="math" id="equation-trunc:decay:corr:FE:ODE">
<span class="eqno">(36)</span>\[     u' = -\hat au ,\quad \hat a = a(1 - {\frac{1}{2}}a\Delta t),\]</div>
<p>by a Forward Euler method. That is, we replace the original coefficient
<span class="math">\(a\)</span> by the perturbed coefficient <span class="math">\(\hat a\)</span>. Observe that
<span class="math">\(\hat a\rightarrow a\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>.</p>
<p>The Forward Euler method applied to <a href="#equation-trunc:decay:corr:FE:ODE">(36)</a>
results in</p>
<div class="math">
\[[D_t^+ u = -a(1 - {\frac{1}{2}}a\Delta t)u]^n{\thinspace .}\]</div>
<p>We can control our computations and verify that the truncation error
of the scheme above is indeed <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.</p>
<p>Another way of revealing the fact that the perturbed ODE leads
to a more accurate solution is to look at the amplification factor.
Our scheme can be written as</p>
<div class="math">
\[u^{n+1} = Au^n,\quad A = 1-\hat a\Delta t = 1 - p + {\frac{1}{2}}p^2,\quad p=a\Delta t,\]</div>
<p>The amplification factor <span class="math">\(A\)</span> as a function of <span class="math">\(p=a\Delta t\)</span> is seen to be
the first three terms of the Taylor series for the exact amplification
factor <span class="math">\(e^{-p}\)</span>. The Forward Euler scheme for <span class="math">\(u=-au\)</span> gives only the
first two terms <span class="math">\(1-p\)</span> of the Taylor series for <span class="math">\(e^{-p}\)</span>. That is,
using <span class="math">\(\hat a\)</span> increases the order of the accuracy in the amplification factor.</p>
<p>Instead of replacing <span class="math">\(u''\)</span> by <span class="math">\(a^2u\)</span>, we use the relation
<span class="math">\(u''=-au'\)</span> and add a term <span class="math">\(-{\frac{1}{2}}a\Delta t u'\)</span>
in the ODE:</p>
<div class="math">
\[u'=-au - {\frac{1}{2}}a\Delta t u'\quad\Rightarrow\quad
\left( 1 + {\frac{1}{2}}a\Delta t\right) u' = -au{\thinspace .}\]</div>
<p>Using a Forward Euler method results in</p>
<div class="math">
\[\left( 1 + {\frac{1}{2}}a\Delta t\right)\frac{u^{n+1}-u^n}{\Delta t}
= -au^n,\]</div>
<p>which after some algebra can be written as</p>
<div class="math">
\[u^{n+1} = \frac{1 - {\frac{1}{2}}a\Delta t}{1+{\frac{1}{2}}a\Delta t}u^n{\thinspace .}\]</div>
<p>This is the same formula as the one arising from a Crank-Nicolson
scheme applied to <span class="math">\(u'=-au\)</span>!
It now recommended to do <a class="reference internal" href="#trunc-exer-decay-corr-be"><em>Exercise 6: Correction term for a Backward Euler scheme</em></a> and
repeat the above steps to see what kind of correction term is needed
in the Backward Euler scheme to make it second order.</p>
<p>The Crank-Nicolson scheme is a bit more challenging to analyze, but
the ideas and techniques are the same. The discrete equation reads</p>
<div class="math">
\[[D_t u = -au ]^{n+\frac{1}{2}},\]</div>
<p>and the truncation error is defined through</p>
<div class="math">
\[[D_t {u_{\small\mbox{e}}} + a\overline{{u_{\small\mbox{e}}}}^{t} = C + R]^{n+\frac{1}{2}},\]</div>
<p>where we have added a correction term.  We need to Taylor expand both
the discrete derivative and the arithmetic mean with aid of
<a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a> and
<a href="#equation-trunc:table:avg:arith:eq">(19)</a>-<a href="#equation-trunc:table:avg:arith">(20)</a>, respectively.
The result is</p>
<div class="math">
\[\frac{1}{24}{u_{\small\mbox{e}}}'''(t_{n+\frac{1}{2}})\Delta t^2 + {\mathcal{O}(\Delta t^4)}
+ \frac{a}{8}{u_{\small\mbox{e}}}''(t_{n+\frac{1}{2}})\Delta t^2 + {\mathcal{O}(\Delta t^4)} = C^{n+\frac{1}{2}} + R^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p>The goal now is to make <span class="math">\(C^{n+\frac{1}{2}}\)</span> cancel the <span class="math">\(\Delta t^2\)</span> terms:</p>
<div class="math">
\[C^{n+\frac{1}{2}} =
\frac{1}{24}{u_{\small\mbox{e}}}'''(t_{n+\frac{1}{2}})\Delta t^2
+ \frac{a}{8}{u_{\small\mbox{e}}}''(t_{n})\Delta t^2{\thinspace .}\]</div>
<p>Using <span class="math">\(u'=-au\)</span>, we have that <span class="math">\(u''=a^2u\)</span>, and we find that <span class="math">\(u'''=-a^3u\)</span>.
We can therefore solve the perturbed ODE problem</p>
<div class="math">
\[u' = -\hat a u,\quad \hat a = a(1 - \frac{1}{12}a^2\Delta t^2),\]</div>
<p>by the Crank-Nicolson scheme and obtain a method that is of fourth
order in <span class="math">\(\Delta t\)</span>. <a class="reference internal" href="#trunc-exer-decay-corr-verify"><em>Exercise 7: Verify the effect of correction terms</em></a>
encourages you to implement these correction terms and calculate
empirical convergence rates to verify that higher-order accuracy
is indeed obtained in real computations.</p>
</div>
<div class="section" id="extension-to-variable-coefficients-1">
<h2>Extension to variable coefficients  (1)<a class="headerlink" href="#extension-to-variable-coefficients-1" title="Permalink to this headline">¶</a></h2>
<p>Let us address the decay ODE with variable coefficients,</p>
<div class="math">
\[u'(t) = -a(t)u(t) + b(t),\]</div>
<p>discretized by the Forward Euler scheme,</p>
<div class="math">
\[[D_t^+ u = -au + b]^n
{\thinspace .}\]</div>
<p>The truncation error <span class="math">\(R\)</span> is as always found by inserting the exact
solution <span class="math">\({u_{\small\mbox{e}}}(t)\)</span> in the discrete scheme:</p>
<div class="math">
\[[D_t^+ {u_{\small\mbox{e}}} + a{u_{\small\mbox{e}}} - b = R]^n
{\thinspace .}\]</div>
<p>Using <a href="#equation-trunc:table:fd1:fw:eq">(9)</a>-<a href="#equation-trunc:table:fd1:fw">(10)</a>,</p>
<div class="math">
\[{u_{\small\mbox{e}}}'(t_n) - \frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}
+ a(t_n){u_{\small\mbox{e}}}(t_n) - b(t_n) = R^n
{\thinspace .}\]</div>
<p>Because of the ODE,</p>
<div class="math">
\[{u_{\small\mbox{e}}}'(t_n) + a(t_n){u_{\small\mbox{e}}}(t_n) - b(t_n) =0,\]</div>
<p>so we are left with the result</p>
<div class="math" id="equation-trunc:decay:vc:R">
<span class="eqno">(37)</span>\[     R^n = -\frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}
     \
     {\thinspace .}\]</div>
<p>We see that the variable coefficients do not pose any additional difficulties
in this case. <a class="reference internal" href="#trunc-exer-decay-varcoeff-cn"><em>Exercise 8: Truncation error of the Crank-Nicolson scheme</em></a> takes the
analysis above one step further to the Crank-Nicolson scheme.</p>
</div>
<div class="section" id="exact-solutions-of-the-finite-difference-equations">
<h2>Exact solutions of the finite difference equations<a class="headerlink" href="#exact-solutions-of-the-finite-difference-equations" title="Permalink to this headline">¶</a></h2>
<p id="index-11">Having a mathematical expression for the numerical solution is very
valuable in program verification since we then know the exact numbers
that the program should produce. Looking at the various
formulas for the truncation errors in
<a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a> and
<a href="#equation-trunc:table:avg:harm:eq">(23)</a>-<a href="#equation-trunc:table:avg:harm">(24)</a> in
the section <a class="reference internal" href="#trunc-table"><em>Overview of leading-order error terms in finite difference formulas</em></a>, we see that all but two of
the <span class="math">\(R\)</span> expressions contains a second or higher order derivative
of <span class="math">\({u_{\small\mbox{e}}}\)</span>. The exceptions are the geometric and harmonic
means where the truncation
error involves <span class="math">\({u_{\small\mbox{e}}}'\)</span> and even <span class="math">\({u_{\small\mbox{e}}}\)</span> in case of the harmonic mean.
So, apart from these two means,
choosing <span class="math">\({u_{\small\mbox{e}}}\)</span> to be a linear function of
<span class="math">\(t\)</span>, <span class="math">\({u_{\small\mbox{e}}} = ct+d\)</span> for constants <span class="math">\(c\)</span> and <span class="math">\(d\)</span>, will make
the truncation error vanish since <span class="math">\({u_{\small\mbox{e}}}''=0\)</span>. Consqeuently,
the truncation error of a finite difference scheme will be zero
since the various
approximations used will all be exact. This means that the linear solution
is an exact solution of the discrete equations.</p>
<p>In a particular differential equation problem, the reasoning above can
be used to determine if we expect a linear <span class="math">\({u_{\small\mbox{e}}}\)</span> to fulfill the
discrete equations. To actually prove that this is true, we can either
compute the truncation error and see that it vanishes, or we can
simply insert <span class="math">\({u_{\small\mbox{e}}}(t)=ct+d\)</span> in the scheme and see that it fulfills
the equations. The latter method is usually the simplest. It will
often be necessary to add some source term to the ODE in order to
allow a linear solution.</p>
<p>Many ODEs are discretized by centered differences.
From the section <a class="reference internal" href="#trunc-table"><em>Overview of leading-order error terms in finite difference formulas</em></a> we see that all the centered
difference formulas have truncation errors involving <span class="math">\({u_{\small\mbox{e}}}'''\)</span> or
higher-order derivatives.
A quadratic solution, e.g., <span class="math">\({u_{\small\mbox{e}}}(t) =t^2 + ct + d\)</span>,
will then make the truncation errors vanish. This observation
can be used to test if a quadratic solution will fulfill the
discrete equations. Note that a quadratic solution will not
obey the equations for a Crank-Nicolson scheme for <span class="math">\(u'=-au+b\)</span>
because the approximation applies an arithmetic mean, which
involves a truncation error with <span class="math">\({u_{\small\mbox{e}}}''\)</span>.</p>
</div>
<div class="section" id="computing-truncation-errors-in-nonlinear-problems">
<span id="trunc-decay-gen"></span><h2>Computing truncation errors in nonlinear problems<a class="headerlink" href="#computing-truncation-errors-in-nonlinear-problems" title="Permalink to this headline">¶</a></h2>
<p>The general nonlinear ODE</p>
<div class="math" id="equation-trunc:decay:gen:ode">
<span class="eqno">(38)</span>\[     u'=f(u,t),\]</div>
<p>can be solved by a Crank-Nicolson scheme</p>
<div class="math" id="equation-trunc:decay:gen:ode">
<span class="eqno">(39)</span>\[     [D_t u'=\overline{f}^{t}]^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p>The truncation error is as always defined as the residual arising
when inserting the
exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> in the scheme:</p>
<div class="math" id="equation-trunc:decay:gen:ode:CN">
<span class="eqno">(40)</span>\[     [D_t {u_{\small\mbox{e}}}' - \overline{f}^{t}= R]^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p>Using <a href="#equation-trunc:table:avg:arith:eq">(19)</a>-<a href="#equation-trunc:table:avg:arith">(20)</a> for
<span class="math">\(\overline{f}^{t}\)</span> results in</p>
<div class="math">
\[\begin{split}[\overline{f}^{t}]^{n+\frac{1}{2}} &amp;=
\frac{1}{2}(f({u_{\small\mbox{e}}}^n,t_n) + f({u_{\small\mbox{e}}}^{n+1},t_{n+1}))\\
&amp;= f({u_{\small\mbox{e}}}^{n+\frac{1}{2}},t_{n+\frac{1}{2}}) +
\frac{1}{8}{u_{\small\mbox{e}}}''(t_{n+\frac{1}{2}})\Delta t^2
+ {\mathcal{O}(\Delta t^4)}{\thinspace .}\end{split}\]</div>
<p>With <a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a> the discrete
equations <a href="#equation-trunc:decay:gen:ode:CN">(40)</a> lead to</p>
<div class="math">
\[{u_{\small\mbox{e}}}'(t_{n+\frac{1}{2}}) +
\frac{1}{24}{u_{\small\mbox{e}}}'''(t_{n+\frac{1}{2}})\Delta t^2
- f({u_{\small\mbox{e}}}^{n+\frac{1}{2}},t_{n+\frac{1}{2}}) -
\frac{1}{8}u''(t_{n+\frac{1}{2}})\Delta t^2
+ {\mathcal{O}(\Delta t^4)} = R^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p>Since <span class="math">\({u_{\small\mbox{e}}}'(t_{n+\frac{1}{2}}) - f({u_{\small\mbox{e}}}^{n+\frac{1}{2}},t_{n+\frac{1}{2}})=0\)</span>,
the truncation error becomes</p>
<div class="math">
\[R^{n+\frac{1}{2}} = (\frac{1}{24}{u_{\small\mbox{e}}}'''(t_{n+\frac{1}{2}})
- \frac{1}{8}u''(t_{n+\frac{1}{2}})) \Delta t^2{\thinspace .}\]</div>
<p>The computational techniques worked well
even for this nonlinear ODE.</p>
</div>
</div>
<div class="section" id="truncation-errors-in-vibration-odes">
<span id="trunc-vib"></span><h1>Truncation errors in vibration ODEs<a class="headerlink" href="#truncation-errors-in-vibration-odes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="linear-model-without-damping">
<span id="trunc-vib-undamped"></span><h2>Linear model without damping<a class="headerlink" href="#linear-model-without-damping" title="Permalink to this headline">¶</a></h2>
<p>The next example on computing the truncation error involves the
following ODE for vibration problems:</p>
<div class="math" id="equation-trunc:vib:undamped:ode">
<span class="eqno">(41)</span>\[     u''(t) + \omega^2 u(t) = 0{\thinspace .}\]</div>
<p>Here, <span class="math">\(\omega\)</span> is a given constant.</p>
<div class="section" id="the-truncation-error-of-a-centered-finite-difference-scheme">
<h3>The truncation error of a centered finite difference scheme<a class="headerlink" href="#the-truncation-error-of-a-centered-finite-difference-scheme" title="Permalink to this headline">¶</a></h3>
<p>Using a standard, second-ordered, central difference for the
second-order derivative time, we have the scheme</p>
<div class="math" id="equation-trunc:vib:undamped:scheme">
<span class="eqno">(42)</span>\[     [D_tD_t u + \omega^2u=0]^n\]\[     {\thinspace .}\]</div>
<p>Inserting the exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> in this equation and adding
a residual <span class="math">\(R\)</span> so that <span class="math">\({u_{\small\mbox{e}}}\)</span> can fulfill the equation results in</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}} + \omega^2{u_{\small\mbox{e}}} =R]^n
{\thinspace .}\]</div>
<p>To calculate the truncation error <span class="math">\(R^n\)</span>, we use
<a href="#equation-trunc:table:fd2:center:eq">(15)</a>-<a href="#equation-trunc:table:fd2:center">(16)</a>, i.e.,</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}}]^n = {u_{\small\mbox{e}}}''(t_n) + \frac{1}{12}{u_{\small\mbox{e}}}''''(t_n)\Delta t^2,\]</div>
<p>and the fact that <span class="math">\({u_{\small\mbox{e}}}''(t) + \omega^2{u_{\small\mbox{e}}}(t)=0\)</span>. The result is</p>
<div class="math">
\[R^n =  \frac{1}{12}{u_{\small\mbox{e}}}''''(t_n)\Delta t^2 + {\mathcal{O}(\Delta t^4)}
{\thinspace .}\]</div>
</div>
<div class="section" id="the-truncation-error-of-approximating">
<h3>The truncation error of approximating <span class="math">\(u'(0)\)</span><a class="headerlink" href="#the-truncation-error-of-approximating" title="Permalink to this headline">¶</a></h3>
<p>The initial conditions for <a href="#equation-trunc:vib:undamped:ode">(41)</a> are
<span class="math">\(u(0)=I\)</span> and <span class="math">\(u'(0)=V\)</span>. The latter involves a finite difference
approximation. The standard choice</p>
<div class="math">
\[[D_{2t}u=V]^0,\]</div>
<p>where <span class="math">\(u^{-1}\)</span> is eliminated with the aid of the discretized ODE
for <span class="math">\(n=0\)</span>, involves a centered difference with an
<span class="math">\({\mathcal{O}(\Delta t^2)}\)</span> truncation error
given by <a href="#equation-trunc:table:fd1:center2:eq">(5)</a>-<a href="#equation-trunc:table:fd1:center2">(6)</a>.
The simpler choice</p>
<div class="math">
\[[D_t^+u = V]^0,\]</div>
<p>is based on a forward difference with a truncation error <span class="math">\({\mathcal{O}(\Delta t)}\)</span>.
A central question is if this initial error will impact the
order of the scheme throughout the simulation.
<a class="reference internal" href="#trunc-exer-vib-ic-fw"><em>Exercise 11: Investigate the impact of approximating </em></a> asks you to quickly perform an
experiment to investigate this question.</p>
</div>
<div class="section" id="truncation-error-of-the-equation-for-the-first-step">
<h3>Truncation error of the equation for the first step<a class="headerlink" href="#truncation-error-of-the-equation-for-the-first-step" title="Permalink to this headline">¶</a></h3>
<p>We have shown that the truncation error of the difference used to
approximate the initial condition <span class="math">\(u'(0)=0\)</span> is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>,
but can also investigate the difference equation used for
the first step. In a truncation error setting, the right way to
view this equation is not to use the initial condition
<span class="math">\([D_{2t}u=V]^0\)</span> to express
<span class="math">\(u^{-1}=u^1 - 2\Delta t V\)</span> in order
to eliminate <span class="math">\(u^{-1}\)</span> from the discretized
differential equation, but the other way around: the fundamental
equation is the discretized initial condition <span class="math">\([D_{2t}u=V]^0\)</span> and we
use the discretized ODE <span class="math">\([D_tD_t + \omega^2 u=0]^0\)</span> to eliminate
<span class="math">\(u^{-1}\)</span> in the disretized initial condition. From <span class="math">\([D_tD_t + \omega^2 u=0]^0\)</span>
we have</p>
<div class="math">
\[u^{-1} = 2u^0 - u^1 - \Delta t^2\omega^2 u^0,\]</div>
<p>which inserted in <span class="math">\([D_{2t}u = V]^0\)</span> gives</p>
<div class="math" id="equation-trunc:vib:undamped:ic:d2">
<span class="eqno">(43)</span>\[     \frac{u^1 - u^0}{\Delta t} + \frac{1}{2}\omega^2\Delta t u^0 = V{\thinspace .}\]</div>
<p>The first term can be recognized as a forward difference such that
the equation can be written in operator notation as</p>
<div class="math">
\[[D_t^+ u + \frac{1}{2}\omega^2\Delta t u = V]^0{\thinspace .}\]</div>
<p>The truncation error is defined as</p>
<div class="math">
\[[D_t^+ {u_{\small\mbox{e}}} + \frac{1}{2}\omega^2\Delta t {u_{\small\mbox{e}}} - V = R]^0{\thinspace .}\]</div>
<p>Using <a href="#equation-trunc:table:fd1:fw:eq">(9)</a>-<a href="#equation-trunc:table:fd1:fw">(10)</a> with
one more term in the Taylor series, we get that</p>
<div class="math">
\[{u_{\small\mbox{e}}}'(0) + \frac{1}{2}{u_{\small\mbox{e}}}''(0)\Delta t + \frac{1}{6}{u_{\small\mbox{e}}}'''(0)\Delta t^2
 + {\mathcal{O}(\Delta t^3)}
+ \frac{1}{2}\omega^2\Delta t {u_{\small\mbox{e}}}(0) - V = R^n{\thinspace .}\]</div>
<p>Now, <span class="math">\({u_{\small\mbox{e}}}'(0)=V\)</span> and <span class="math">\({u_{\small\mbox{e}}}''(0)=-\omega^2 {u_{\small\mbox{e}}}(0)\)</span> so we get</p>
<div class="math">
\[R^n = \frac{1}{6}{u_{\small\mbox{e}}}'''(0)\Delta t^2 + {\mathcal{O}(\Delta t^3)}{\thinspace .}\]</div>
<p>There is another way of analyzing the discrete initial
condition, because eliminating <span class="math">\(u^{-1}\)</span> via the discretized ODE
can be expressed as</p>
<div class="math" id="equation-trunc:vib:undamped:ic:d3">
<span class="eqno">(44)</span>\[     [ D_{2t} u + \Delta t(D_tD_t u - \omega^2 u) = V]^0{\thinspace .}\]</div>
<p>Writing out <a href="#equation-trunc:vib:undamped:ic:d3">(44)</a> shows that the equation is
equivalent to <a href="#equation-trunc:vib:undamped:ic:d2">(43)</a>.
The truncation error is defined by</p>
<div class="math">
\[[ D_{2t} {u_{\small\mbox{e}}} + \Delta t(D_tD_t {u_{\small\mbox{e}}} - \omega^2 {u_{\small\mbox{e}}}) = V + R]^0{\thinspace .}\]</div>
<p>Replacing the difference via
<a href="#equation-trunc:table:fd1:center2:eq">(5)</a>-<a href="#equation-trunc:table:fd1:center2">(6)</a> and
<a href="#equation-trunc:table:fd2:center:eq">(15)</a>-<a href="#equation-trunc:table:fd2:center">(16)</a>, as
well as using <span class="math">\({u_{\small\mbox{e}}}'(0)=V\)</span> and <span class="math">\({u_{\small\mbox{e}}}''(0) = -\omega^2{u_{\small\mbox{e}}}(0)\)</span>,
gives</p>
<div class="math">
\[R^n = \frac{1}{6}u'''(0)\Delta t^2 + {\mathcal{O}(\Delta t^3)}{\thinspace .}\]</div>
</div>
<div class="section" id="computing-correction-terms">
<h3>Computing correction terms<a class="headerlink" href="#computing-correction-terms" title="Permalink to this headline">¶</a></h3>
<p>The idea of using correction terms to increase the order of <span class="math">\(R^n\)</span> can
be applied as described in the section <a class="reference internal" href="#trunc-decay-corr"><em>Increasing the accuracy by adding correction terms</em></a>. We look at</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}} + \omega^2{u_{\small\mbox{e}}} =C + R]^n,\]</div>
<p>and observe that <span class="math">\(C^n\)</span> must be chosen to cancel
the <span class="math">\(\Delta t^2\)</span> term in <span class="math">\(R^n\)</span>. That is,</p>
<div class="math">
\[C^n = \frac{1}{12}{u_{\small\mbox{e}}}''''(t_n)\Delta t^2{\thinspace .}\]</div>
<p>To get rid of the 4th-order derivative we can use the differential
equation: <span class="math">\(u''=-\omega^u\)</span>, which implies <span class="math">\(u'''' = \omega^4 u\)</span>.
Adding the correction term to the ODE results in</p>
<div class="math" id="equation-trunc:vib:undamped:corr:ode">
<span class="eqno">(45)</span>\[     u'' + \omega^2(1 - \frac{1}{12}\omega^2\Delta t^2)u = 0{\thinspace .}\]</div>
<p>Solving this equation by the standard scheme</p>
<div class="math">
\[[D_tD_t u + \omega^2(1 - \frac{1}{12}\omega^2\Delta t^2)u=0]^n,\]</div>
<p>will result in a scheme with trunction error <span class="math">\({\mathcal{O}(\Delta t^4)}\)</span>.</p>
<p>We can use another set of arguments to justify that <a href="#equation-trunc:vib:undamped:corr:ode">(45)</a> leads to a higher-order method.
Mathematical analysis of the scheme <a href="#equation-trunc:vib:undamped:scheme">(42)</a>
reveals that the numerical frequency <span class="math">\(\tilde\omega\)</span> is (approximately
as <span class="math">\(\Delta t\rightarrow 0\)</span>)</p>
<div class="math">
\[\tilde\omega = \omega (1+\frac{1}{24}\omega^2\Delta t^2){\thinspace .}\]</div>
<p>One can therefore attempt to replace <span class="math">\(\omega\)</span> in the ODE by
a slightly smaller <span class="math">\(\omega\)</span> since the numerics will make it larger:</p>
<div class="math">
\[[ u'' + (\omega(1 - \frac{1}{24}\omega^2\Delta t^2))^2 u = 0{\thinspace .}\]</div>
<p>Expanding the squared term and omitting the higher-order term <span class="math">\(\Delta t^4\)</span>
gives exactly the ODE <a href="#equation-trunc:vib:undamped:corr:ode">(45)</a>. Experiments
show that <span class="math">\(u^n\)</span> is computed to 4th order in <span class="math">\(\Delta t\)</span>.</p>
</div>
</div>
<div class="section" id="model-with-damping-and-nonlinearity">
<span id="trunc-vib-gen"></span><h2>Model with damping and nonlinearity<a class="headerlink" href="#model-with-damping-and-nonlinearity" title="Permalink to this headline">¶</a></h2>
<p>The model <a href="#equation-trunc:vib:undamped:ode">(41)</a>
can be extended to include damping <span class="math">\(\beta u'\)</span>,
a nonlinear restoring (spring) force <span class="math">\(s(u)\)</span>, and some
known excitation force <span class="math">\(F(t)\)</span>:</p>
<div class="math" id="equation-trunc:vib:gen:ode1">
<span class="eqno">(46)</span>\[     mu'' + \beta u' + s(u) =F(t){\thinspace .}\]</div>
<p>The coefficient <span class="math">\(m\)</span> usually represents the mass of the system.
This governing equation can by discretized by centered differences:</p>
<div class="math">
\[[mD_tD_t u + \beta D_{2t} u + s(u)=F]^n
{\thinspace .}\]</div>
<p>The exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfills the discrete equations with a residual term:</p>
<div class="math">
\[[mD_tD_t {u_{\small\mbox{e}}} + \beta D_{2t} {u_{\small\mbox{e}}} + s({u_{\small\mbox{e}}})=F + R]^n
{\thinspace .}\]</div>
<p>Using <a href="#equation-trunc:table:fd2:center:eq">(15)</a>-<a href="#equation-trunc:table:fd2:center">(16)</a> and
<a href="#equation-trunc:table:fd1:center2:eq">(5)</a>-<a href="#equation-trunc:table:fd1:center2">(6)</a> we
get</p>
<div class="math">
\[\begin{split}\lbrack mD_tD_t {u_{\small\mbox{e}}} + \beta D_{2t} {u_{\small\mbox{e}}}\rbrack^n &amp;=
m{u_{\small\mbox{e}}}''(t_n) + \beta{u_{\small\mbox{e}}}'(t_n) + \\
&amp;\quad \left(\frac{m}{12}{u_{\small\mbox{e}}}''''(t_n) +
  \frac{\beta}{6}{u_{\small\mbox{e}}}'''(t_n)\right)\Delta t^2 + {\mathcal{O}(\Delta t^4)}\end{split}\]</div>
<p>Combining this with the previous equation, we can collect the terms</p>
<div class="math">
\[m{u_{\small\mbox{e}}}''(t_n) + \beta{u_{\small\mbox{e}}}'(t_n) + \omega^2{u_{\small\mbox{e}}}(t_n) + s({u_{\small\mbox{e}}}(t_n)) - F^n,\]</div>
<p>and set this sum to zero because <span class="math">\({u_{\small\mbox{e}}}\)</span> solves
the differential equation. We are left with
the truncation error</p>
<div class="math" id="equation-trunc:vib:gen:R">
<span class="eqno">(47)</span>\[     R^n = \left(\frac{m}{12}{u_{\small\mbox{e}}}''''(t_n) +
       \frac{\beta}{6}{u_{\small\mbox{e}}}'''(t_n)\right)\Delta t^2 + {\mathcal{O}(\Delta t^4)},\]</div>
<p>so the scheme is of second order.</p>
<p>According to <a href="#equation-trunc:vib:gen:R">(47)</a>, we can add correction terms</p>
<div class="math">
\[C^n = \left(\frac{m}{12}{u_{\small\mbox{e}}}''''(t_n) +
 \frac{\beta}{6}{u_{\small\mbox{e}}}'''(t_n)\right)\Delta t^2,\]</div>
<p>to the right-hand side of the ODE to obtain a fourth-order scheme.
However, expressing <span class="math">\(u''''\)</span> and <span class="math">\(u'''\)</span> in terms
of lower-order derivatives is now harder because the differential equation
is more complicated:</p>
<div class="math">
\[\begin{split}u''' &amp;= \frac{1}{m}(F' - \beta u'' - s'(u)u'),\\
u'''' &amp;= \frac{1}{m}(F'' - \beta u''' - s''(u)(u')^2 - s'(u)u''),\\
&amp;= \frac{1}{m}(F'' - \beta \frac{1}{m}(F' - \beta u'' - s'(u)u')
- s''(u)(u')^2 - s'(u)u''){\thinspace .}\end{split}\]</div>
<p>It is not impossible to discretize the resulting modified ODE, but it is up
to debate whether correction terms are feasible and the way to go.
Computing with a smaller <span class="math">\(\Delta t\)</span> is usually always possible in these
problems to achieve the desired accuracy.</p>
</div>
<div class="section" id="extension-to-quadratic-damping">
<h2>Extension to quadratic damping<a class="headerlink" href="#extension-to-quadratic-damping" title="Permalink to this headline">¶</a></h2>
<p>Instead of the linear damping term <span class="math">\(\beta u'\)</span> in <a href="#equation-trunc:vib:gen:ode1">(46)</a>
we now consider quadratic damping <span class="math">\(\beta |u'|u'\)</span>:</p>
<div class="math" id="equation-trunc:vib:gen:ode2">
<span class="eqno">(48)</span>\[     mu'' + \beta |u'|u' + s(u) =F(t){\thinspace .}\]</div>
<p>A centered difference for <span class="math">\(u'\)</span> gives rise to a nonlinearity, which can
be linearized using a geometric mean:
<span class="math">\([|u'|u']^n \approx |[u']^{n-\frac{1}{2}}|[u']^{n+\frac{1}{2}}\)</span>.
The resulting scheme becomes</p>
<div class="math">
\[[mD_t D_t u]^n + \beta |[D_{t} u]^{n-\frac{1}{2}}|[D_t u]^{n+\frac{1}{2}}
+ s(u^n)=F^n{\thinspace .}\]</div>
<p>The truncation error is defined through</p>
<div class="math">
\[[mD_t D_t {u_{\small\mbox{e}}}]^n +
\beta |[D_{t} {u_{\small\mbox{e}}}]^{n-\frac{1}{2}}|[D_t {u_{\small\mbox{e}}}]^{n+\frac{1}{2}}
+ s({u_{\small\mbox{e}}}^n)-F^n = R^n{\thinspace .}\]</div>
<p>We start with expressing the truncation error of the geometric mean.
According to <a href="#equation-trunc:table:avg:geom:eq">(21)</a>-<a href="#equation-trunc:table:avg:geom">(22)</a>,</p>
<div class="math">
\[|[D_{t} {u_{\small\mbox{e}}}]^{n-\frac{1}{2}}|[D_t {u_{\small\mbox{e}}}]^{n+\frac{1}{2}}
= [|D_t{u_{\small\mbox{e}}}|D_t{u_{\small\mbox{e}}}]^n
- \frac{1}{4}u'(t_n)^2\Delta t^2  + \frac{1}{4}u(t_n)u''(t_n)\Delta t^2
+ {\mathcal{O}(\Delta t^4)}{\thinspace .}\]</div>
<p>Using <a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a>
for the <span class="math">\(D_t{u_{\small\mbox{e}}}\)</span> factors results in</p>
<div class="math">
\[[|D_t{u_{\small\mbox{e}}}|D_t{u_{\small\mbox{e}}}]^n = |{u_{\small\mbox{e}}}' + \frac{1}{24}{u_{\small\mbox{e}}}'''(t_n)\Delta t^2 +
{\mathcal{O}(\Delta t^4)}|({u_{\small\mbox{e}}}' + \frac{1}{24}{u_{\small\mbox{e}}}'''(t_n)\Delta t^2 +
{\mathcal{O}(\Delta t^4)})\]</div>
<p>We can remove the absolute value since it essentially gives a factor 1 or -1
only. Calculating the product, we have the leading-order terms</p>
<div class="math">
\[[D_t{u_{\small\mbox{e}}} D_t{u_{\small\mbox{e}}}]^n = ({u_{\small\mbox{e}}}'(t_n))^2 +
\frac{1}{12}{u_{\small\mbox{e}}}(t_n){u_{\small\mbox{e}}}'''(t_n)\Delta t^2 +
{\mathcal{O}(\Delta t^4)}{\thinspace .}\]</div>
<p>With</p>
<div class="math">
\[m[D_t D_t{u_{\small\mbox{e}}}]^n = m{u_{\small\mbox{e}}}''(t_n) + \frac{m}{12}{u_{\small\mbox{e}}}''''(t_n)\Delta t^2
+{\mathcal{O}(\Delta t^4)},\]</div>
<p>and using the differential equation on the
form <span class="math">\(mu'' + \beta (u')^2 + s(u)=F\)</span>, we end up with</p>
<div class="math">
\[R^n = (\frac{m}{12}{u_{\small\mbox{e}}}''''(t_n) +
\frac{\beta}{12}{u_{\small\mbox{e}}}(t_n){u_{\small\mbox{e}}}'''(t_n))
\Delta t^2 + {\mathcal{O}(\Delta t^4)}{\thinspace .}\]</div>
<p>This result demonstrates that we have
second-order accuracy also with quadratic damping.
The key elements that lead to the second-order accuracy is that
the difference approximations are <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span> <em>and</em> the
geometric mean approximation is also of <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.</p>
</div>
<div class="section" id="the-general-model-formulated-as-first-order-odes">
<span id="trunc-vib-gen-staggered"></span><h2>The general model formulated as first-order ODEs<a class="headerlink" href="#the-general-model-formulated-as-first-order-odes" title="Permalink to this headline">¶</a></h2>
<p>The second-order model <a href="#equation-trunc:vib:gen:ode2">(48)</a> can be
formulated as a first-order system,</p>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:u">
<span class="eqno">(49)</span>\[     u' = v,\]</div>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:v">
<span class="eqno">(50)</span>\[     v' = \frac{1}{m}\left( F(t) - \beta |v|v - s(u)\right){\thinspace .}\]</div>
<p>The system <a href="#equation-trunc:vib:gen:2x2model:ode:u">(49)</a>-<a href="#equation-trunc:vib:gen:2x2model:ode:u">(49)</a> can be solved either by a forward-backward scheme or a centered
scheme on a staggered mesh.</p>
<div class="section" id="the-forward-backward-scheme">
<h3>The forward-backward scheme<a class="headerlink" href="#the-forward-backward-scheme" title="Permalink to this headline">¶</a></h3>
<p>The discretization is based on the idea of stepping
<a href="#equation-trunc:vib:gen:2x2model:ode:u">(49)</a> forward in time and then
using a backward difference in <a href="#equation-trunc:vib:gen:2x2model:ode:v">(50)</a>
with the recently computed (and therefore known) <span class="math">\(u\)</span>:</p>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:u:fw">
<span class="eqno">(51)</span>\[     \lbrack D_t^+ u = v \rbrack^n,\]</div>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:v:bw">
<span class="eqno">(52)</span>\[     \lbrack D_t^-v = \frac{1}{m}( F(t) - \beta |v|v - s(u)) \rbrack^{n+1}{\thinspace .}\]</div>
<p>The term <span class="math">\(|v|v\)</span> gives rise to a nonlinearity <span class="math">\(|v^{n+1}|v^{n+1}\)</span>,
which can be linearized as <span class="math">\(|v^{n}|v^{n+1}\)</span>:</p>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:u:fw2">
<span class="eqno">(53)</span>\[     \lbrack D_t^+ u = v \rbrack^n,\]</div>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:v:bw2">
<span class="eqno">(54)</span>\[     \lbrack D_t^-v \rbrack^{n+1} = \frac{1}{m}( F(t_{n+1}) - \beta |v^n|v^{n+1} - s(u^{n+1})){\thinspace .}\]</div>
<p>Each ODE will have a truncation error when inserting the exact
solutions <span class="math">\({u_{\small\mbox{e}}}\)</span> and <span class="math">\({v_{\small\mbox{e}}}\)</span> in
<a href="#equation-trunc:vib:gen:2x2model:ode:u:fw">(51)</a>-<a href="#equation-trunc:vib:gen:2x2model:ode:v:bw">(52)</a>:</p>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:u:fw:R">
<span class="eqno">(55)</span>\[     \lbrack D_t^+ {u_{\small\mbox{e}}} = {v_{\small\mbox{e}}} + R_u \rbrack^n,\]</div>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:v:bw:R">
<span class="eqno">(56)</span>\[     \lbrack D_t^-{v_{\small\mbox{e}}} \rbrack^{n+1} = \frac{1}{m}( F(t_{n+1}) - \beta |{v_{\small\mbox{e}}}(t_n)|{v_{\small\mbox{e}}}(t_{n+1}) - s({u_{\small\mbox{e}}}(t_{n+1}))) + R_v^{n+1}{\thinspace .}\]</div>
<p>Application of <a href="#equation-trunc:table:fd1:fw:eq">(9)</a>-<a href="#equation-trunc:table:fd1:fw">(10)</a>
and <a href="#equation-trunc:table:fd1:bw:eq">(7)</a>-<a href="#equation-trunc:table:fd1:bw">(8)</a> in
<a href="#equation-trunc:vib:gen:2x2model:ode:u:fw:R">(55)</a> and
<a href="#equation-trunc:vib:gen:2x2model:ode:v:bw:R">(56)</a>, respectively, gives</p>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:u:fw:R2">
<span class="eqno">(57)</span>\[     {u_{\small\mbox{e}}}'(t_n) + \frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}
     = {v_{\small\mbox{e}}}(t_n) + R_u^n,\]</div>
<div class="math">
\[{v_{\small\mbox{e}}}'(t_{n+1}) - \frac{1}{2}{v_{\small\mbox{e}}}''(t_{n+1})\Delta t + {\mathcal{O}(\Delta t^2)}
= \frac{1}{m}(F(t_{n+1}) - \beta|{v_{\small\mbox{e}}}(t_n)|{v_{\small\mbox{e}}}(t_{n+1}) +\nonumber\]</div>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:v:bw:R2">
<span class="eqno">(58)</span>\[     \quad s({u_{\small\mbox{e}}}(t_{n+1}))+ R_v^n{\thinspace .}\]</div>
<p>Since <span class="math">\({u_{\small\mbox{e}}} ' = {v_{\small\mbox{e}}}\)</span>, <a href="#equation-trunc:vib:gen:2x2model:ode:u:fw:R2">(57)</a>
gives</p>
<div class="math">
\[R_u^n = \frac{1}{2}{u_{\small\mbox{e}}}''(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}{\thinspace .}\]</div>
<p>In <a href="#equation-trunc:vib:gen:2x2model:ode:v:bw:R2">(58)</a> we can collect the
terms that constitute the ODE, but the damping term has the wrong
form.
Let us drop the absolute value in the damping term for simplicity.
Adding a substracting the right form <span class="math">\(v^{n+1}v^{n+1}\)</span> helps:</p>
<div class="math">
\[\begin{split}{v_{\small\mbox{e}}}'(t_{n+1}) &amp;-
\frac{1}{m}(F(t_{n+1}) - \beta {v_{\small\mbox{e}}}(t_{n+1}){v_{\small\mbox{e}}}(t_{n+1}) +
s({u_{\small\mbox{e}}}(t_{n+1})) + \\
&amp; (\beta {v_{\small\mbox{e}}}(t_n){v_{\small\mbox{e}}}(t_{n+1}) - \beta {v_{\small\mbox{e}}}(t_{n+1}){v_{\small\mbox{e}}}(t_{n+1}))),\end{split}\]</div>
<p>which reduces to</p>
<div class="math">
\[\begin{split}\frac{\beta}{m}{v_{\small\mbox{e}}}(t_{n+1}({v_{\small\mbox{e}}}(t_n) - {v_{\small\mbox{e}}}(t_{n+1}))
&amp;= \frac{\beta}{m}{v_{\small\mbox{e}}}(t_{n+1}[D_t^-{v_{\small\mbox{e}}}]^{n+1}\Delta t\\
&amp;= \frac{\beta}{m}{v_{\small\mbox{e}}}(t_{n+1}({v_{\small\mbox{e}}}'(t_{n+1})\Delta t +
-\frac{1}{2}{v_{\small\mbox{e}}}'''(t_{n+1})\Delta t^ + {\mathcal{O}(\Delta t^3)}){\thinspace .}\end{split}\]</div>
<p>We end with <span class="math">\(R_u^n\)</span> and <span class="math">\(R_v^{n+1}\)</span> as <span class="math">\({\mathcal{O}(\Delta t)}\)</span>, simply because
all the building blocks in the schemes (the forward and backward
differences and the linearization trick) are only first-order
accurate. However, this analysis is misleading: the building blocks
play together in a way that makes the scheme second-order accurate.
This is shown by considering an alternative, yet equivalent, formulation
of the above scheme.</p>
</div>
<div class="section" id="a-centered-scheme-on-a-staggered-mesh">
<h3>A centered scheme on a staggered mesh<a class="headerlink" href="#a-centered-scheme-on-a-staggered-mesh" title="Permalink to this headline">¶</a></h3>
<p>We now introduce a staggered mesh where we
seek <span class="math">\(u\)</span> at mesh points <span class="math">\(t_n\)</span> and <span class="math">\(v\)</span> at points <span class="math">\(t_{n+\frac{1}{2}}\)</span>
in between the <span class="math">\(u\)</span> points. The staggered mesh makes it easy to
formulate centered differences in the system
<a href="#equation-trunc:vib:gen:2x2model:ode:u">(49)</a>-<a href="#equation-trunc:vib:gen:2x2model:ode:u">(49)</a>:</p>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:u:staggered">
<span class="eqno">(59)</span>\[     \lbrack D_t u = v \rbrack^{n-\frac{1}{2}},\]</div>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:v:staggered">
<span class="eqno">(60)</span>\[     \lbrack D_t v = \frac{1}{m}( F(t) - \beta |v|v - s(u)) \rbrack^{n}{\thinspace .}\]</div>
<p>The term <span class="math">\(|v^n|v^n\)</span> causes trouble since <span class="math">\(v^n\)</span> is not computed, only
<span class="math">\(v^{n-\frac{1}{2}}\)</span> and <span class="math">\(v^{n+\frac{1}{2}}\)</span>. Using geometric mean,
we can express <span class="math">\(|v^n|v^n\)</span> in terms of known quantities:
<span class="math">\(|v^n|v^n \approx |v^{n-\frac{1}{2}}|v^{n+\frac{1}{2}}\)</span>.
We then have</p>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:u:staggered2">
<span class="eqno">(61)</span>\[     \lbrack D_t u \rbrack^{n-\frac{1}{2}} = v^{n-\frac{1}{2}},\]</div>
<div class="math" id="equation-trunc:vib:gen:2x2model:ode:v:staggered2">
<span class="eqno">(62)</span>\[     \lbrack D_t v \rbrack^n = \frac{1}{m}( F(t_n) -
     \beta |v^{n-\frac{1}{2}}|v^{n+\frac{1}{2}} - s(u^n)){\thinspace .}\]</div>
<p>The truncation error in each equation fulfills</p>
<div class="math">
\[\begin{split}\lbrack D_t {u_{\small\mbox{e}}} \rbrack^{n-\frac{1}{2}} &amp;= {v_{\small\mbox{e}}}(t_{n-\frac{1}{2}}) + R_u^{n-\frac{1}{2}},\\
\lbrack D_t {v_{\small\mbox{e}}} \rbrack^n &amp;= \frac{1}{m}( F(t_n) -
\beta |{v_{\small\mbox{e}}}(t_{n-\frac{1}{2}})|{v_{\small\mbox{e}}}(t_{n+\frac{1}{2}}) - s(u^n)) + R_v^n{\thinspace .}\end{split}\]</div>
<p>The truncation error of the centered differences is given
by <a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a>,
and the geometric mean approximation
analysis can be taken from <a href="#equation-trunc:table:avg:geom:eq">(21)</a>-<a href="#equation-trunc:table:avg:geom">(22)</a>.
These results lead to</p>
<div class="math">
\[{u_{\small\mbox{e}}}'(t_{n-\frac{1}{2}}) +
\frac{1}{24}{u_{\small\mbox{e}}}'''(t_{n-\frac{1}{2}})\Delta t^2 + {\mathcal{O}(\Delta t^4)}
= {v_{\small\mbox{e}}}(t_{n-\frac{1}{2}}) + R_u^{n-\frac{1}{2}},\]</div>
<p>and</p>
<div class="math">
\[{v_{\small\mbox{e}}}'(t_n) =
\frac{1}{m}( F(t_n) -
\beta |{v_{\small\mbox{e}}}(t_n)|{v_{\small\mbox{e}}}(t_n) + {\mathcal{O}(\Delta t^2)} - s(u^n)) + R_v^n{\thinspace .}\]</div>
<p>The ODEs fulfilled by <span class="math">\({u_{\small\mbox{e}}}\)</span> and <span class="math">\({v_{\small\mbox{e}}}\)</span> are evident in these equations,
and we achieve second-order accuracy for the truncation error
in both equations:</p>
<div class="math">
\[R_u^{n-\frac{1}{2}}= {\mathcal{O}(\Delta t^2)}, \quad R_v^n = {\mathcal{O}(\Delta t^2)}{\thinspace .}\]</div>
<p>Comparing
<a href="#equation-trunc:vib:gen:2x2model:ode:u:staggered2">(61)</a>-<a href="#equation-trunc:vib:gen:2x2model:ode:v:staggered2">(62)</a>
with
<a href="#equation-trunc:vib:gen:2x2model:ode:u:fw2">(53)</a>-<a href="#equation-trunc:vib:gen:2x2model:ode:v:bw2">(54)</a>,
we can hopefully realize that these schemes are equivalent (which
becomes clear when we implement both).  The obvious advantage with the
staggered mesh approach is that we can all the way use second-order
accurate building blocks and in this way concince ourselves that the
resulting scheme has an error of <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.</p>
</div>
</div>
</div>
<div class="section" id="truncation-errors-in-wave-equations">
<h1>Truncation errors in wave equations<a class="headerlink" href="#truncation-errors-in-wave-equations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="linear-wave-equation-in-1d">
<span id="trunc-wave-1d"></span><h2>Linear wave equation in 1D<a class="headerlink" href="#linear-wave-equation-in-1d" title="Permalink to this headline">¶</a></h2>
<p>The standard, linear wave equation in 1D for a function <span class="math">\(u(x,t)\)</span> reads</p>
<div class="math" id="equation-trunc:wave:pde1D">
<span class="eqno">(63)</span>\[     \frac{\partial^2 u}{\partial t^2} = c^2\frac{\partial^2 u}{\partial x^2} + f(x,t),\quad x\in (0, L),\ t\in (0,T],\]</div>
<p>where <span class="math">\(c\)</span> is the constant wave velocity of the physical medium <span class="math">\([0,L]\)</span>.
The equation can also be more compactly written as</p>
<div class="math" id="equation-trunc:wave:pde1D:v2">
<span class="eqno">(64)</span>\[     u_{tt} = c^2u_{xx} + f,\quad x\in (0, L),\ t\in (0,T],\]</div>
<p>Centered, second-order finite differences are a natural choice for
discretizing the derivatives, leading to</p>
<div class="math" id="equation-trunc:wave:pde1D:fd">
<span class="eqno">(65)</span>\[     [D_t D_t u = c^2 D_xD_x u + f]^n_i\]\[     {\thinspace .}\]</div>
<p>Inserting the exact solution <span class="math">\({u_{\small\mbox{e}}}(x,t)\)</span> in <a href="#equation-trunc:wave:pde1D:fd">(65)</a>
makes this function fulfill the equation if we add the
term <span class="math">\(R\)</span>:</p>
<div class="math" id="equation-trunc:wave:pde1D:fd:R">
<span class="eqno">(66)</span>\[     [D_t D_t {u_{\small\mbox{e}}} = c^2 D_xD_x {u_{\small\mbox{e}}} + f + R]^n_i\]</div>
<p>Our purpose is to calculate the truncation error <span class="math">\(R\)</span>.
From <a href="#equation-trunc:table:fd2:center:eq">(15)</a>-<a href="#equation-trunc:table:fd2:center">(16)</a> we have that</p>
<div class="math">
\[[D_t D_t{u_{\small\mbox{e}}}]_i^n = {u_{\small\mbox{e}, tt}}(x_i,t_n) +
\frac{1}{12}{u_{\small\mbox{e}, tttt}}(x_i,t_n)\Delta t^2 + {\mathcal{O}(\Delta t^4)},\]</div>
<p>when we use a notation taking into account that <span class="math">\({u_{\small\mbox{e}}}\)</span> is a function
of two variables and that derivatives must be partial derivatives.
The notation <span class="math">\({u_{\small\mbox{e}, tt}}\)</span> means <span class="math">\(\partial^2{u_{\small\mbox{e}}} /\partial t^2\)</span>.</p>
<p>The same formula may also be applied to the <span class="math">\(x\)</span>-derivative term:</p>
<div class="math">
\[[D_xD_x{u_{\small\mbox{e}}}]_i^n = {u_{\small\mbox{e}, xx}}(x_i,t_n) +
\frac{1}{12}{u_{\small\mbox{e}, xxxx}}(x_i,t_n)\Delta x^2 + {\mathcal{O}(\Delta x^4)},\]</div>
<p>Equation <a href="#equation-trunc:wave:pde1D:fd:R">(68)</a> now becomes</p>
<div class="math">
\[\begin{split}{u_{\small\mbox{e}, tt}}
+ \frac{1}{12}{u_{\small\mbox{e}, tttt}}(x_i,t_n)\Delta t^2  &amp;=
c^2{u_{\small\mbox{e}, xx}} +
c^2\frac{1}{12}{u_{\small\mbox{e}, xxxx}}(x_i,t_n)\Delta x^2 + f(x_i,t_n) + \\
&amp; \quad  {\mathcal{O}(\Delta t^4,\Delta x^4)} + R^n_i
{\thinspace .}\end{split}\]</div>
<p>Because <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfills the partial differential equation (PDE)
<a href="#equation-trunc:wave:pde1D:v2">(64)</a>, the first, third, and fifth terms cancel out,
and we are left with</p>
<div class="math" id="equation-trunc:wave:1D:R">
<span class="eqno">(67)</span>\[     R^n_i = \frac{1}{12}{u_{\small\mbox{e}, tttt}}(x_i,t_n)\Delta t^2 -
     c^2\frac{1}{12}{u_{\small\mbox{e}, xxxx}}(x_i,t_n)\Delta x^2 +
     {\mathcal{O}(\Delta t^4,\Delta x^4)},\]</div>
<p>showing that the scheme <a href="#equation-trunc:wave:pde1D:fd">(65)</a> is of second order
in the time and space mesh spacing.</p>
</div>
<div class="section" id="finding-correction-terms">
<span id="trunc-wave-1d-corr"></span><h2>Finding correction terms<a class="headerlink" href="#finding-correction-terms" title="Permalink to this headline">¶</a></h2>
<p>Can we add correction terms to the PDE and increase the order of
<span class="math">\(R^n_i\)</span> in <a href="#equation-trunc:wave:1D:R">(67)</a>? The starting point is</p>
<div class="math" id="equation-trunc:wave:pde1D:fd:R">
<span class="eqno">(68)</span>\[     [D_t D_t {u_{\small\mbox{e}}} = c^2 D_xD_x {u_{\small\mbox{e}}} + f + C + R]^n_i\]</div>
<p>From the previous analysis we simply get <a href="#equation-trunc:wave:1D:R">(67)</a>
again, but now with <span class="math">\(C\)</span>:</p>
<div class="math" id="equation-trunc:wave:1D:R:C">
<span class="eqno">(69)</span>\[     R^n_i + C_i^n = \frac{1}{12}{u_{\small\mbox{e}, tttt}}(x_i,t_n)\Delta t^2 -
     c^2\frac{1}{12}{u_{\small\mbox{e}, xxxx}}(x_i,t_n)\Delta x^2 +
     {\mathcal{O}(\Delta t^4,\Delta x^4)}{\thinspace .}\]</div>
<p>The idea is to let <span class="math">\(C_i^n\)</span> cancel the <span class="math">\(\Delta t^2\)</span> and <span class="math">\(\Delta x^2\)</span>
terms to make <span class="math">\(R^n_i = {\mathcal{O}(\Delta t^4,\Delta x^4)}\)</span>:</p>
<div class="math">
\[C_i^n =
\frac{1}{12}{u_{\small\mbox{e}, tttt}}(x_i,t_n)\Delta t^2 -
c^2\frac{1}{12}{u_{\small\mbox{e}, xxxx}}(x_i,t_n)\Delta x^2{\thinspace .}\]</div>
<p>Essentially, it means that we add a new term</p>
<div class="math">
\[C = \frac{1}{12}\left( u_{tttt}\Delta t^2 - c^2u_{xxxx}\Delta x^2\right),\]</div>
<p>to the right-hand side of the PDE.
We must either discretize these 4th-order derivatives directly or
rewrite them in terms of lower-order derivatives with the aid of the
PDE. The latter approach is more feasible. From the PDE we have that</p>
<div class="math">
\[\frac{\partial^2}{\partial t^2} = c^2\frac{\partial^2}{\partial x^2},\]</div>
<p>so</p>
<div class="math">
\[u_{tttt} = c^2u_{xxtt},\quad u_{xxxx} = c^{-2}u_{ttxx}{\thinspace .}\]</div>
<p>Assuming <span class="math">\(u\)</span> is smooth enough that <span class="math">\(u_{xxtt}=u_{ttxx}\)</span>, these relations
lead to</p>
<div class="math">
\[C = \frac{1}{12}((c^2\Delta t^2 - \Delta x^2)u_{xx})_{tt}{\thinspace .}\]</div>
<p>A natural discretization is</p>
<div class="math">
\[C^n_i = \frac{1}{12}((c^2\Delta t^2 - \Delta x^2)
[D_xD_xD_tD_t u]^n_i{\thinspace .}\]</div>
<p>Writing out <span class="math">\([D_xD_xD_tD_t u]^n_i\)</span> as
<span class="math">\([D_xD_x (D_tD_t u)]^n_i\)</span> gives</p>
<div class="math">
\[\begin{split}\frac{1}{\Delta t^2}\biggl(
&amp;\frac{u^{n+1}_{i+1} - 2u^{n}_{i+1} + u^{n-1}_{i+1}}{\Delta x^2} -2\\
&amp;\frac{u^{n+1}_{i} - 2u^{n}_{i} + u^{n-1}_{i}}{\Delta x^2} +
&amp;\frac{u^{n+1}_{i-1} - 2u^{n}_{i-1} + u^{n-1}_{i-1}}{\Delta x^2}
\biggr)\end{split}\]</div>
<p>Now the unknown values <span class="math">\(u^{n+1}_{i+1}\)</span>, <span class="math">\(u^{n+1}_{i}\)</span>,
and <span class="math">\(u^{n+1}_{i-1}\)</span> are <em>coupled</em>, and we must solve a tridiagonal
system to find them. This is in principle straightforward, but it
results in an implicit finite difference schemes, while we had
a convenient explicit scheme without the correction terms.</p>
</div>
<div class="section" id="extension-to-variable-coefficients-2">
<span id="trunc-wave-1d-varcoeff"></span><h2>Extension to variable coefficients  (2)<a class="headerlink" href="#extension-to-variable-coefficients-2" title="Permalink to this headline">¶</a></h2>
<p>Now we address the variable coefficient version of the linear 1D
wave equation,</p>
<div class="math">
\[\frac{\partial^2 u}{\partial t^2} = \frac{\partial}{\partial x}
\left( \lambda(x)\frac{\partial u}{\partial x}\right),\]</div>
<p>or written more compactly as</p>
<div class="math" id="equation-trunc:wave:1D:varcoeff:pde">
<span class="eqno">(70)</span>\[     u_{tt} = (\lambda u_x)_x{\thinspace .}\]</div>
<p>The discrete counterpart to this equation, using arithmetic mean for
<span class="math">\(\lambda\)</span> and centered differences, reads</p>
<div class="math" id="equation-trunc:wave:1D:varcoeff:fd">
<span class="eqno">(71)</span>\[     [D_t D_t u = D_x \overline{\lambda}^{x}D_x u]^n_i{\thinspace .}\]</div>
<p>The truncation error is the residual <span class="math">\(R\)</span> in the equation</p>
<div class="math" id="equation-trunc:wave:1D:varcoef:fd:R">
<span class="eqno">(72)</span>\[     [D_t D_t {u_{\small\mbox{e}}} = D_x \overline{\lambda}^{x}D_x {u_{\small\mbox{e}}} + R]^n_i{\thinspace .}\]</div>
<p>The difficulty in the present is how to compute the truncation error of
the term <span class="math">\([D_x \overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}]^n_i\)</span>.</p>
<p>We start by writing out the outer operator:</p>
<div class="math" id="equation-trunc:wave:1D:varcoeff:outer">
<span class="eqno">(73)</span>\[     [D_x \overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}]^n_i =
     \frac{1}{\Delta x}\left(
     [\overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}]^n_{i+\frac{1}{2}} -
     [\overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}]^n_{i-\frac{1}{2}}
     \right).\]</div>
<p>With the aid of <a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a>
and <a href="#equation-trunc:table:avg:arith:eq">(19)</a>-<a href="#equation-trunc:table:avg:arith">(20)</a> we have</p>
<div class="math">
\[\begin{split}\lbrack D_x {u_{\small\mbox{e}}} \rbrack^n_{i+\frac{1}{2}} &amp; = {u_{\small\mbox{e}, x}}(x_{i+\frac{1}{2}},t_n) +
\frac{1}{24}{u_{\small\mbox{e}, xxx}}(x_{i+\frac{1}{2}},t_n)\Delta x^2 +
{\mathcal{O}(\Delta x^4)},\\
\lbrack\overline{\lambda}^{x}\rbrack_{i+\frac{1}{2}}
&amp;= \lambda(x_{i+\frac{1}{2}}) +
\frac{1}{8}\lambda''(x_{i+\frac{1}{2}})\Delta x^2
+ {\mathcal{O}(\Delta x^4)},\\
[\overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}]^n_{i+\frac{1}{2}} &amp;=
(\lambda(x_{i+\frac{1}{2}}) +
\frac{1}{8}\lambda''(x_{i+\frac{1}{2}})\Delta x^2
+ {\mathcal{O}(\Delta x^4)})\times\\
&amp;\quad ({u_{\small\mbox{e}, x}}(x_{i+\frac{1}{2}},t_n) +
\frac{1}{24}{u_{\small\mbox{e}, xxx}}(x_{i+\frac{1}{2}},t_n)\Delta x^2 +
{\mathcal{O}(\Delta x^4)})\\
&amp;= \lambda(x_{i+\frac{1}{2}}){u_{\small\mbox{e}, x}}(x_{i+\frac{1}{2}},t_n)
+ \lambda(x_{i+\frac{1}{2}})
\frac{1}{24}{u_{\small\mbox{e}, xxx}}(x_{i+\frac{1}{2}},t_n)\Delta x^2 + \\
&amp;\quad {u_{\small\mbox{e}, x}}(x_{i+\frac{1}{2}})
\frac{1}{8}\lambda''(x_{i+\frac{1}{2}})\Delta x^2
+{\mathcal{O}(\Delta x^4)}\\
&amp;= [\lambda {u_{\small\mbox{e}, x}}]^n_{i+\frac{1}{2}} + G^n_{i+\frac{1}{2}}\Delta x^2
+{\mathcal{O}(\Delta x^4)},\end{split}\]</div>
<p>where we have introduced the short form</p>
<div class="math">
\[G^n_{i+\frac{1}{2}} =
(\frac{1}{24}{u_{\small\mbox{e}, xxx}}(x_{i+\frac{1}{2}},t_n)\lambda((x_{i+\frac{1}{2}})
+ {u_{\small\mbox{e}, x}}(x_{i+\frac{1}{2}},t_n)
\frac{1}{8}\lambda''(x_{i+\frac{1}{2}}))\Delta x^2{\thinspace .}\]</div>
<p>Similarly, we find that</p>
<div class="math">
\[\lbrack\overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}\rbrack^n_{i-\frac{1}{2}} =
[\lambda {u_{\small\mbox{e}, x}}]^n_{i-\frac{1}{2}} + G^n_{i-\frac{1}{2}}\Delta x^2
+{\mathcal{O}(\Delta x^4)}{\thinspace .}\]</div>
<p>Inserting these expressions in the outer operator <a href="#equation-trunc:wave:1D:varcoeff:outer">(73)</a>
results in</p>
<div class="math">
\[\begin{split}\lbrack D_x \overline{\lambda}^{x}D_x {u_{\small\mbox{e}}} \rbrack^n_i &amp;=
\frac{1}{\Delta x}(
[\overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}]^n_{i+\frac{1}{2}} -
[\overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}]^n_{i-\frac{1}{2}}
)\\
&amp;= \frac{1}{\Delta x}(
[\lambda {u_{\small\mbox{e}, x}}]^n_{i+\frac{1}{2}} +
G^n_{i+\frac{1}{2}}\Delta x^2 -
[\lambda {u_{\small\mbox{e}, x}}]^n_{i-\frac{1}{2}} -
G^n_{i-\frac{1}{2}}\Delta x^2 +
{\mathcal{O}(\Delta x^4)}
)\\
&amp;= [D_x \lambda {u_{\small\mbox{e}, x}}]^n_i + [D_x G]^n_i\Delta x^2 + {\mathcal{O}(\Delta x^4)}{\thinspace .}\end{split}\]</div>
<p>The reason for <span class="math">\({\mathcal{O}(\Delta x^4)}\)</span> in the remainder is that there
are coefficients in front of this term, say <span class="math">\(H\Delta x^4\)</span>, and the
subtraction and division by <span class="math">\(\Delta x\)</span> results in <span class="math">\([D_x H]^n_i\Delta x^4\)</span>.</p>
<p>We can now use <a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a>
to express the <span class="math">\(D_x\)</span> operator
in <span class="math">\([D_x \lambda {u_{\small\mbox{e}, x}}]^n_i\)</span>
as a derivative and a truncation error:</p>
<div class="math">
\[[D_x \lambda {u_{\small\mbox{e}, x}}]^n_i =
\frac{\partial}{\partial x}\lambda(x_i){u_{\small\mbox{e}, x}}(x_i,t_n)
+ \frac{1}{24}(\lambda{u_{\small\mbox{e}, x}})_{xxx}(x_i,t_n)\Delta x^2
+ {\mathcal{O}(\Delta x^4)}{\thinspace .}\]</div>
<p>Expressions like <span class="math">\([D_x G]^n_i\Delta x^2\)</span> can be treated in an identical
way,</p>
<div class="math">
\[[D_x G]^n_i\Delta x^2 = G_x(x_i,t_n)\Delta x^2
+ \frac{1}{24}G_{xxx}(x_i,t_n)\Delta x^4 + {\mathcal{O}(\Delta x^4)}{\thinspace .}\]</div>
<p>There will be a number of terms with the <span class="math">\(\Delta x^2\)</span> factor. We
lump these now into <span class="math">\({\mathcal{O}(\Delta x^2)}\)</span>.
The result of the truncation error analysis of the spatial derivative
is therefore summarized as</p>
<div class="math">
\[[D_x \overline{\lambda}^{x}D_x {u_{\small\mbox{e}}}]^n_i =
\frac{\partial}{\partial x}
\lambda(x_i){u_{\small\mbox{e}, x}}(x_i,t_n) +
{\mathcal{O}(\Delta x^2)}{\thinspace .}\]</div>
<p>After having treated the <span class="math">\([D_tD_t{u_{\small\mbox{e}}}]^n_i\)</span> term as well, we achieve</p>
<div class="math">
\[R^n_i = {\mathcal{O}(\Delta x^2)} +
\frac{1}{12}{u_{\small\mbox{e}, tttt}}(x_i,t_n)\Delta t^2
{\thinspace .}\]</div>
<p>The main conclusion is that the scheme is of second-order in time
and space also in this variable coefficient case. The key ingredients
for second order are the centered differences and the arithmetic
mean for <span class="math">\(\lambda\)</span>: all those building blocks feature second-order accuracy.</p>
</div>
<div class="section" id="d-wave-equation-on-a-staggered-mesh">
<h2>1D wave equation on a staggered mesh<a class="headerlink" href="#d-wave-equation-on-a-staggered-mesh" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="linear-wave-equation-in-2d-3d">
<span id="trunc-wave-2d"></span><h2>Linear wave equation in 2D/3D<a class="headerlink" href="#linear-wave-equation-in-2d-3d" title="Permalink to this headline">¶</a></h2>
<p>The two-dimensional extension of <a href="#equation-trunc:wave:pde1D">(63)</a> takes the form</p>
<div class="math" id="equation-trunc:wave:pde2D">
<span class="eqno">(74)</span>\[     \frac{\partial^2 u}{\partial t^2} = c^2\left(\frac{\partial^2 u}{\partial x^2}
     + \frac{\partial^2 u}{\partial y^2}\right) + f(x,y,t),\quad (x,y)\in (0, L)\times (0,H),\ t\in (0,T],\]</div>
<p>where now <span class="math">\(c(x,y)\)</span> is the constant wave velocity of the physical medium
<span class="math">\([0,L]\times [0,H]\)</span>. In the compact notation, the PDE
<a href="#equation-trunc:wave:pde2D">(74)</a> can be written</p>
<div class="math" id="equation-trunc:wave:pde2D:v2">
<span class="eqno">(75)</span>\[     u_{tt} = c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad (x,y)\in (0, L)\times (0,H),
     \ t\in (0,T],\]</div>
<p>in 2D, while the 3D version reads</p>
<div class="math" id="equation-trunc:wave:pde3D:v2">
<span class="eqno">(76)</span>\[     u_{tt} = c^2(u_{xx} + u_{yy} + u_{zz}) + f(x,y,z,t),\]</div>
<p>for <span class="math">\((x,y,z)\in (0, L)\times (0,H)\times (0,B)\)</span> and
<span class="math">\(t\in (0,T]\)</span>.</p>
<p>Approximating the second-order derivatives by the standard
formulas <a href="#equation-trunc:table:fd2:center:eq">(15)</a>-<a href="#equation-trunc:table:fd2:center">(16)</a>
yields the scheme</p>
<div class="math">
\[[D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j,k}
{\thinspace .}\]</div>
<p>The truncation error is found from</p>
<div class="math">
\[[D_t D_t {u_{\small\mbox{e}}} = c^2(D_xD_x {u_{\small\mbox{e}}} + D_yD_y {u_{\small\mbox{e}}}) + f + R]^n
{\thinspace .}\]</div>
<p>The calculations from the 1D case can be repeated to the
terms in the <span class="math">\(y\)</span> and <span class="math">\(z\)</span> directions. Collecting terms that
fulfill the PDE, we end up with</p>
<div class="math">
\[R^n_{i,j,k}  = [\frac{1}{12}{u_{\small\mbox{e}, tttt}}\Delta t^2 -
c^2\frac{1}{12}\left( {u_{\small\mbox{e}, xxxx}}\Delta x^2
+ {u_{\small\mbox{e}, yyyy}}\Delta x^2
+ {u_{\small\mbox{e}, zzzz}}\Delta z^2\right)]^n_{i,j,k} +\]</div>
<div class="math">
\[\quad {\mathcal{O}(\Delta t^4,\Delta x^4,\Delta y^4,\Delta z^4)}\nonumber
{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="truncation-errors-in-diffusion-equations">
<span id="trunc-diffu"></span><h1>Truncation errors in diffusion equations<a class="headerlink" href="#truncation-errors-in-diffusion-equations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="linear-diffusion-equation-in-1d">
<span id="trunc-diffu-1d"></span><h2>Linear diffusion equation in 1D<a class="headerlink" href="#linear-diffusion-equation-in-1d" title="Permalink to this headline">¶</a></h2>
<p>The standard, linear, 1D diffusion equation takes the form</p>
<div class="math" id="equation-trunc:diffu:pde1D">
<span class="eqno">(77)</span>\[     \frac{\partial u}{\partial t} = \alpha\frac{\partial^2 u}{\partial x^2} + f(x,t),\quad x\in (0, L),\ t\in (0,T],\]</div>
<p>where <span class="math">\(\alpha &gt; 0\)</span> is the constant diffusion coefficient. A more
compact form of the diffusion equation is <span class="math">\(u_t = \alpha u_{xx}+f\)</span>.</p>
<p>The spatial derivative in the diffusion equation, <span class="math">\(\alpha u_xx\)</span>,
is commonly discretized as <span class="math">\([D_x D_xu]^n_i\)</span>. The time-derivative,
however, can be treated by a variety of methods.</p>
<div class="section" id="the-forward-euler-scheme-in-time">
<h3>The Forward Euler scheme in time<a class="headerlink" href="#the-forward-euler-scheme-in-time" title="Permalink to this headline">¶</a></h3>
<p>Let us start
with the simple Forward Euler scheme:</p>
<div class="math">
\[[D_t^+ u = \alpha D_xD_x u + f]^n{\thinspace .}\]</div>
<p>The truncation error arises as the residual <span class="math">\(R\)</span> when
inserting the exact solution
<span class="math">\({u_{\small\mbox{e}}}\)</span> in the discrete equations:</p>
<div class="math">
\[[D_t^+ {u_{\small\mbox{e}}} = \alpha D_xD_x {u_{\small\mbox{e}}} + f + R]^n_i{\thinspace .}\]</div>
<p>Now, using <a href="#equation-trunc:table:fd1:fw:eq">(9)</a>-<a href="#equation-trunc:table:fd1:fw">(10)</a>
and <a href="#equation-trunc:table:fd2:center:eq">(15)</a>-<a href="#equation-trunc:table:fd2:center">(16)</a>,
we can transform the difference operators to derivatives:</p>
<div class="math">
\[\begin{split}{u_{\small\mbox{e}, t}}(x_i,t_n) &amp;+ \frac{1}{2}{u_{\small\mbox{e}, tt}}(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}
= \alpha{u_{\small\mbox{e}, xx}}(x_i,t_n) + \\
&amp;\frac{\alpha}{12}{u_{\small\mbox{e}, xxxx}}(x_i,t_n)\Delta x^2 + {\mathcal{O}(\Delta x^4)}
+ f(x_i,t_n) + R^n_i{\thinspace .}\end{split}\]</div>
<p>The terms <span class="math">\({u_{\small\mbox{e}, t}}(x_i,t_n) - \alpha{u_{\small\mbox{e}, xx}}(x_i,t_n) - f(x_i,t_n)\)</span>
vansih because <span class="math">\({u_{\small\mbox{e}}}\)</span> solves the PDE. The truncation error then becomes</p>
<div class="math">
\[R^n_i =
\frac{1}{2}{u_{\small\mbox{e}, tt}}(t_n)\Delta t + {\mathcal{O}(\Delta t^2)}
- \frac{\alpha}{12}{u_{\small\mbox{e}, xxxx}}(x_i,t_n)\Delta x^2 + {\mathcal{O}(\Delta x^4)}{\thinspace .}\]</div>
</div>
<div class="section" id="the-crank-nicolson-scheme-in-time">
<h3>The Crank-Nicolson scheme in time<a class="headerlink" href="#the-crank-nicolson-scheme-in-time" title="Permalink to this headline">¶</a></h3>
<p>The Crank-Nicolson method consists of
using a centered difference for <span class="math">\(u_t\)</span> and an arithmetic average of
the <span class="math">\(u_xx\)</span> term:</p>
<div class="math">
\[[D_t u]^{n+\frac{1}{2}}_i = \alpha\frac{1}{2}([D_xD_x u]^n_i +
[D_xD_x u]^{n+1}_i + f^{n+\frac{1}{2}}_i{\thinspace .}\]</div>
<p>The equation for the truncation error is</p>
<div class="math">
\[[D_t {u_{\small\mbox{e}}}]^{n+\frac{1}{2}}_i = \alpha\frac{1}{2}([D_xD_x {u_{\small\mbox{e}}}]^n_i +
[D_xD_x {u_{\small\mbox{e}}}]^{n+1}_i) + f^{n+\frac{1}{2}}_i + R^{n+\frac{1}{2}}_i{\thinspace .}\]</div>
<p>To find the truncation error, we start by expressing the arithmetic
average in terms of values at time <span class="math">\(t_{n+\frac{1}{2}}\)</span>. According to
<a href="#equation-trunc:table:avg:arith:eq">(19)</a>-<a href="#equation-trunc:table:avg:arith">(20)</a>,</p>
<div class="math">
\[\frac{1}{2}([D_xD_x {u_{\small\mbox{e}}}]^n_i + [D_xD_x {u_{\small\mbox{e}}}]^{n+1}_i)
=
[D_xD_x{u_{\small\mbox{e}}}]^{n+\frac{1}{2}}_i +
\frac{1}{8}[D_xD_x{u_{\small\mbox{e}, tt}}]_i^{n+\frac{1}{2}}\Delta t^2
+ {\mathcal{O}(\Delta t^4)}{\thinspace .}\]</div>
<p>With <a href="#equation-trunc:table:fd2:center:eq">(15)</a>-<a href="#equation-trunc:table:fd2:center">(16)</a>
we can express the difference operator
<span class="math">\(D_xD_xu\)</span> in terms of a derivative:</p>
<div class="math">
\[[D_xD_x{u_{\small\mbox{e}}}]^{n+\frac{1}{2}}_i =
{u_{\small\mbox{e}, xx}}(x_i, t_{n+\frac{1}{2}})
+ \frac{1}{12}{u_{\small\mbox{e}, xxxx}}(x_i, t_{n+\frac{1}{2}})\Delta x^2 +
{\mathcal{O}(\Delta x^4)}{\thinspace .}\]</div>
<p>The error term from the arithmetic mean is similarly expanded,</p>
<div class="math">
\[\frac{1}{8}[D_xD_x{u_{\small\mbox{e}, tt}}]_i^{n+\frac{1}{2}}\Delta t^2
= \frac{1}{8}{u_{\small\mbox{e}, ttxx}}(x_i, t_{n+\frac{1}{2}})\Delta t^2
+ {\mathcal{O}(\Delta t^2\Delta x^2)}\]</div>
<p>The time derivative is analyzed using
<a href="#equation-trunc:table:fd1:center:eq">(3)</a>-<a href="#equation-trunc:table:fd1:center">(4)</a>:</p>
<div class="math">
\[[D_t u]^{n+\frac{1}{2}}_i
= {u_{\small\mbox{e}, t}}(x_i,t_{n+\frac{1}{2}}) +
\frac{1}{24}{u_{\small\mbox{e}, ttt}}(x_i,t_{n+\frac{1}{2}})\Delta t^2 +
{\mathcal{O}(\Delta t^4)}{\thinspace .}\]</div>
<p>Summing up all the contributions and notifying that</p>
<div class="math">
\[{u_{\small\mbox{e}, t}}(x_i,t_{n+\frac{1}{2}}) =
\alpha{u_{\small\mbox{e}, xx}}(x_i, t_{n+\frac{1}{2}})
+ f(x_i,t_{n+\frac{1}{2}}),\]</div>
<p>the truncation error is given by</p>
<div class="math">
\[\begin{split}R^{n+\frac{1}{2}}_i
&amp; =
\frac{1}{8}{u_{\small\mbox{e}, xx}}(x_i,t_{n+\frac{1}{2}})\Delta t^2 +
\frac{1}{12}{u_{\small\mbox{e}, xxxx}}(x_i, t_{n+\frac{1}{2}})\Delta x^2 +\\
&amp;\quad \frac{1}{24}{u_{\small\mbox{e}, ttt}}(x_i,t_{n+\frac{1}{2}})\Delta t^2 +
+ {\mathcal{O}(\Delta x^4)} + {\mathcal{O}(\Delta t^4)} + {\mathcal{O}(\Delta t^2\Delta x^2)}\end{split}\]</div>
</div>
</div>
<div class="section" id="linear-diffusion-equation-in-2d-3d">
<h2>Linear diffusion equation in 2D/3D<a class="headerlink" href="#linear-diffusion-equation-in-2d-3d" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="a-nonlinear-diffusion-equation-in-2d">
<h2>A nonlinear diffusion equation in 2D<a class="headerlink" href="#a-nonlinear-diffusion-equation-in-2d" title="Permalink to this headline">¶</a></h2>
</div>
</div>
<div class="section" id="exercises">
<h1>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-1-truncation-error-of-a-weighted-mean">
<span id="trunc-exer-theta-avg"></span><h2>Exercise 1: Truncation error of a weighted mean<a class="headerlink" href="#exercise-1-truncation-error-of-a-weighted-mean" title="Permalink to this headline">¶</a></h2>
<p>Derive the truncation error of the weighted mean in
<a href="#equation-trunc:table:avg:theta:eq">(17)</a>-<a href="#equation-trunc:table:avg:theta">(18)</a>.</p>
<p><strong>Hint.</strong>
Expand <span class="math">\({u_{\small\mbox{e}}}^{n+1}\)</span> and <span class="math">\({u_{\small\mbox{e}}}^n\)</span> around <span class="math">\(t_{n+\theta}\)</span>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">trunc_weighted_mean.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-2-simulate-the-error-of-a-weighted-mean">
<span id="trunc-exer-theta-avg2"></span><h2>Exercise 2: Simulate the error of a weighted mean<a class="headerlink" href="#exercise-2-simulate-the-error-of-a-weighted-mean" title="Permalink to this headline">¶</a></h2>
<p>We consider the weighted mean</p>
<div class="math">
\[{u_{\small\mbox{e}}}(t_n) \approx \theta {u_{\small\mbox{e}}}^{n+1} + (1-\theta){u_{\small\mbox{e}}}^n{\thinspace .}\]</div>
<p>Choose some specific function for <span class="math">\({u_{\small\mbox{e}}}(t)\)</span> and compute the error in
this approximation for a sequence of decreasing <span class="math">\(\Delta t =
t_{n+1}-t_n\)</span> and for <span class="math">\(\theta = 0, 0.25, 0.5, 0.75, 1\)</span>.  Assuming that
the error equals <span class="math">\(C\Delta t^r\)</span>, for some constants <span class="math">\(C\)</span> and <span class="math">\(r\)</span>,
compute <span class="math">\(r\)</span> for the two smallest <span class="math">\(\Delta t\)</span> values for each choice of
<span class="math">\(\theta\)</span> and compare with the truncation error
<a href="#equation-trunc:table:avg:theta:eq">(17)</a>-<a href="#equation-trunc:table:avg:theta">(18)</a>.
Filename: <tt class="docutils literal"><span class="pre">trunc_theta_avg.py</span></tt>.</p>
</div>
<div class="section" id="exercise-3-verify-a-truncation-error-formula">
<span id="trunc-exer-decay-bw2"></span><h2>Exercise 3: Verify a truncation error formula<a class="headerlink" href="#exercise-3-verify-a-truncation-error-formula" title="Permalink to this headline">¶</a></h2>
<p>Set up a numerical experiment as explained in
the section <a class="reference internal" href="#trunc-decay-estimate-r"><em>Empirical verification of the truncation error</em></a> for verifying the formulas
<a href="#equation-trunc:table:fd1:bw2:eq">(13)</a>-<a href="#equation-trunc:table:fd1:bw2">(14)</a>.
Filename: <tt class="docutils literal"><span class="pre">trunc_backward_2level.py</span></tt>.</p>
</div>
<div class="section" id="exercise-4-truncation-error-of-the-backward-euler-scheme">
<span id="trunc-exer-decay-be"></span><h2>Exercise 4: Truncation error of the Backward Euler scheme<a class="headerlink" href="#exercise-4-truncation-error-of-the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>Derive the truncation error of the Backward Euler scheme for
the decay ODE <span class="math">\(u'=-au\)</span> with constant <span class="math">\(a\)</span>. Extend the analysis to
cover the variable-coefficient case <span class="math">\(u'=-a(t)u + b(t)\)</span>.
Filename: <tt class="docutils literal"><span class="pre">trunc_decay_BE.py</span></tt>.</p>
</div>
<div class="section" id="exercise-5-empirical-estimation-of-truncation-errors">
<span id="trunc-exer-decay-estimate"></span><h2>Exercise 5: Empirical estimation of truncation errors<a class="headerlink" href="#exercise-5-empirical-estimation-of-truncation-errors" title="Permalink to this headline">¶</a></h2>
<p>Use the ideas and tools from the section <a class="reference internal" href="#trunc-decay-estimate-r"><em>Empirical verification of the truncation error</em></a> to
estimate the rate of the truncation error of the Backward Euler
and Crank-Nicolson schemes applied to the exponential decay
model <span class="math">\(u'=-au\)</span>, <span class="math">\(u(0)=I\)</span>.</p>
<p><strong>Hint.</strong>
In the Backward Euler scheme, the truncation error can be estimated
at mesh points <span class="math">\(n=1,\ldots,N\)</span>, while the truncation error must
be estimated at midpoints <span class="math">\(t_{n+\frac{1}{2}}\)</span>, <span class="math">\(n=0,\ldots,N-1\)</span> for
the Crank-Nicolson scheme. The <tt class="docutils literal"><span class="pre">truncation_error(dt,</span> <span class="pre">N)</span></tt>
function to be supplied to the <tt class="docutils literal"><span class="pre">estimate</span></tt> function needs to
carefully implement these details and return the right <tt class="docutils literal"><span class="pre">t</span></tt> array
such that <tt class="docutils literal"><span class="pre">t[i]</span></tt> is the time point corresponding to the quantities
<tt class="docutils literal"><span class="pre">R[i]</span></tt> and <tt class="docutils literal"><span class="pre">R_a[i]</span></tt>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">trunc_decay_BNCN.py</span></tt>.</p>
</div>
<div class="section" id="exercise-6-correction-term-for-a-backward-euler-scheme">
<span id="trunc-exer-decay-corr-be"></span><h2>Exercise 6: Correction term for a Backward Euler scheme<a class="headerlink" href="#exercise-6-correction-term-for-a-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>Consider the model <span class="math">\(u'=-au\)</span>, <span class="math">\(u(0)=I\)</span>. Use the ideas of
the section <a class="reference internal" href="#trunc-decay-corr"><em>Increasing the accuracy by adding correction terms</em></a> to add a correction term to the ODE
such that the Backward Euler scheme applied to the perturbed ODE
problem is of second order in <span class="math">\(\Delta t\)</span>. Find the amplification
factor.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">trunc_decay_BE_corr.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-7-verify-the-effect-of-correction-terms">
<span id="trunc-exer-decay-corr-verify"></span><h2>Exercise 7: Verify the effect of correction terms<a class="headerlink" href="#exercise-7-verify-the-effect-of-correction-terms" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/decay/decay_convrate.py">decay_convrate.py</a>
solves <span class="math">\(u'=-au\)</span>, <span class="math">\(u(0)=I\)</span>, by the <span class="math">\(\theta\)</span>-rule and computes
convergence rates. Copy this file and
adjust <span class="math">\(a\)</span> in the <tt class="docutils literal"><span class="pre">solver</span></tt> function such that it incorporates
correction terms. Run the program to verify that the error from the Forward
and Backward Euler schemes with perturbed <span class="math">\(a\)</span> is
<span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, while the error arising from the Crank-Nicolson
scheme with perturbed <span class="math">\(a\)</span> is <span class="math">\({\mathcal{O}(\Delta t^4)}\)</span>.
Filename: <tt class="docutils literal"><span class="pre">trunc_decay_corr_verify.py</span></tt>.</p>
</div>
<div class="section" id="exercise-8-truncation-error-of-the-crank-nicolson-scheme">
<span id="trunc-exer-decay-varcoeff-cn"></span><h2>Exercise 8: Truncation error of the Crank-Nicolson scheme<a class="headerlink" href="#exercise-8-truncation-error-of-the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p>The variable-coefficient ODE <span class="math">\(u'=-a(t)u+b(t)\)</span> can be discretized
in two different ways by the Crank-Nicolson scheme, depending on
whether we use averages for <span class="math">\(a\)</span> and <span class="math">\(b\)</span> or compute them at
the midpoint <span class="math">\(t_{n+\frac{1}{2}}\)</span>:</p>
<div class="math">
\[\lbrack D_t u   = -a\overline{u}^t + b \rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t u   = \overline{-au+b}^t \rbrack^{n+\frac{1}{2}}
{\thinspace .}\]</div>
<p>Compute the truncation error in both cases.
Filename: <tt class="docutils literal"><span class="pre">trunc_decay_CN_vc.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-9-truncation-error-of">
<span id="trunc-exer-decay-nonlin-befe"></span><h2>Exercise 9: Truncation error of <span class="math">\(u'=f(u,t)\)</span><a class="headerlink" href="#exercise-9-truncation-error-of" title="Permalink to this headline">¶</a></h2>
<p>Consider the general nonlinear first-order scalar ODE</p>
<div class="math">
\[u'(t) = f(u(t), t)
{\thinspace .}\]</div>
<p>Show that the truncation error in the Forward Euler scheme,</p>
<div class="math">
\[[D_t^+ u = f(u,t)]^n,\]</div>
<p>and in the Backward Euler scheme,</p>
<div class="math">
\[[D_t^- u = f(u,t)]^n,\]</div>
<p>both are of first order, regardless of what <span class="math">\(f\)</span> is.</p>
<p>Showing the order of the truncation error in the Crank-Nicolson scheme,</p>
<div class="math">
\[[D_t u = f(u,t)]^{n+\frac{1}{2}},\]</div>
<p>is somewhat more involved: Taylor expand <span class="math">\({u_{\small\mbox{e}}}^n\)</span>, <span class="math">\({u_{\small\mbox{e}}}^{n+1}\)</span>,
<span class="math">\(f({u_{\small\mbox{e}}}^n, t_n)\)</span>, and <span class="math">\(f({u_{\small\mbox{e}}}^{n+1}, t_{n+1})\)</span> around <span class="math">\(t_{n+\frac{1}{2}}\)</span>,
and use that</p>
<div class="math">
\[\frac{df}{dt} = \frac{\partial f}{\partial u}u' + \frac{\partial f}{\partial t}
{\thinspace .}\]</div>
<p>Check that the derived truncation error is consistent with previous
results for the case <span class="math">\(f(u,t)=-au\)</span>.
Filename: <tt class="docutils literal"><span class="pre">trunc_nonlinear_ODE.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-10-truncation-error-of">
<span id="trunc-exer-dtdtu"></span><h2>Exercise 10: Truncation error of <span class="math">\([D_t D_tu]^n\)</span><a class="headerlink" href="#exercise-10-truncation-error-of" title="Permalink to this headline">¶</a></h2>
<p>Derive the truncation error of the finite difference approximation
<a href="#equation-trunc:table:fd2:center:eq">(15)</a>-<a href="#equation-trunc:table:fd2:center">(16)</a> to
the second-order derivative.
Filename: <tt class="docutils literal"><span class="pre">trunc_d2u.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-11-investigate-the-impact-of-approximating">
<span id="trunc-exer-vib-ic-fw"></span><h2>Exercise 11: Investigate the impact of approximating <span class="math">\(u'(0)\)</span><a class="headerlink" href="#exercise-11-investigate-the-impact-of-approximating" title="Permalink to this headline">¶</a></h2>
<p>the section <a class="reference internal" href="#trunc-vib-undamped"><em>Linear model without damping</em></a> describes two ways of discretizing
the initial conditon <span class="math">\(u'(0)=V\)</span> for a vibration model
<span class="math">\(u''+\omega^2u=0\)</span>: a centered difference <span class="math">\([D_{2t}u=V]^0\)</span> or
a forward difference <span class="math">\([D_t^+u=V]^0\)</span>.
The program <a class="reference external" href="http://tinyurl.com/jvzzcfn/vib/vib_undamped.py">vib_undamped.py</a>
solves <span class="math">\(u''+\omega^2u=0\)</span> with <span class="math">\([D_{2t}u=0]^0\)</span> and features
a function <tt class="docutils literal"><span class="pre">convergence_rates</span></tt> for computing the order of the
error in the numerical solution. Modify this program such
that it applies the forward difference <span class="math">\([D_t^+u=0]^0\)</span> and
report how this simpler and more convenient approximation impacts
the overall convergence rate of the scheme.
Filename: <tt class="docutils literal"><span class="pre">trunc_vib_ic_fw.py</span></tt>.</p>
</div>
<div class="section" id="exercise-12-investigate-the-accuracy-of-a-simplified-scheme">
<span id="trunc-exer-vib-fbw"></span><h2>Exercise 12: Investigate the accuracy of a simplified scheme<a class="headerlink" href="#exercise-12-investigate-the-accuracy-of-a-simplified-scheme" title="Permalink to this headline">¶</a></h2>
<p>Consider the ODE</p>
<div class="math">
\[mu'' + \beta |u'|u' + s(u) = F(t){\thinspace .}\]</div>
<p>The term <span class="math">\(|u'|u'\)</span> quickly gives rise to nonlinearities and complicates
the scheme. Why not simply apply a backward difference to this term
such that it only involves known values? That is, we propose to solve</p>
<div class="math">
\[[mD_tD_tu + \beta |D_t^-u|D_t^-u + s(u) = F]^n{\thinspace .}\]</div>
<p>Drop the absolute value for simplicity and find the truncation error
of the scheme.
Perform numerical experiments with the scheme and compared with the one
based on centered differences. Can you illustrate the accuracy loss
visually in real computations, or is the asymptotic analysis here
mainly of theoretical interest?
Filename: <tt class="docutils literal"><span class="pre">trunc_vib_bw_damping.pdf</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Truncation Error Analysis</a></li>
<li><a class="reference internal" href="#overview-of-truncation-error-analysis">Overview of truncation error analysis</a><ul>
<li><a class="reference internal" href="#abstract-problem-setting">Abstract problem setting</a></li>
<li><a class="reference internal" href="#error-measures">Error measures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#truncation-errors-in-finite-difference-formulas">Truncation errors in finite difference formulas</a><ul>
<li><a class="reference internal" href="#example-the-backward-difference-for">Example: The backward difference for <span class="math">\(u'(t)\)</span></a></li>
<li><a class="reference internal" href="#example-the-forward-difference-for">Example: The forward difference for <span class="math">\(u'(t)\)</span></a></li>
<li><a class="reference internal" href="#example-the-central-difference-for">Example: The central difference for <span class="math">\(u'(t)\)</span></a></li>
<li><a class="reference internal" href="#overview-of-leading-order-error-terms-in-finite-difference-formulas">Overview of leading-order error terms in finite difference formulas</a></li>
<li><a class="reference internal" href="#software-for-computing-truncation-errors">Software for computing truncation errors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#truncation-errors-in-exponential-decay-ode">Truncation errors in exponential decay ODE</a><ul>
<li><a class="reference internal" href="#truncation-error-of-the-forward-euler-scheme">Truncation error of the Forward Euler scheme</a></li>
<li><a class="reference internal" href="#truncation-error-of-the-crank-nicolson-scheme">Truncation error of the Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#truncation-error-of-the-rule">Truncation error of the <span class="math">\(\theta\)</span>-rule</a></li>
<li><a class="reference internal" href="#using-symbolic-software">Using symbolic software</a></li>
<li><a class="reference internal" href="#empirical-verification-of-the-truncation-error">Empirical verification of the truncation error</a></li>
<li><a class="reference internal" href="#increasing-the-accuracy-by-adding-correction-terms">Increasing the accuracy by adding correction terms</a></li>
<li><a class="reference internal" href="#extension-to-variable-coefficients-1">Extension to variable coefficients  (1)</a></li>
<li><a class="reference internal" href="#exact-solutions-of-the-finite-difference-equations">Exact solutions of the finite difference equations</a></li>
<li><a class="reference internal" href="#computing-truncation-errors-in-nonlinear-problems">Computing truncation errors in nonlinear problems</a></li>
</ul>
</li>
<li><a class="reference internal" href="#truncation-errors-in-vibration-odes">Truncation errors in vibration ODEs</a><ul>
<li><a class="reference internal" href="#linear-model-without-damping">Linear model without damping</a><ul>
<li><a class="reference internal" href="#the-truncation-error-of-a-centered-finite-difference-scheme">The truncation error of a centered finite difference scheme</a></li>
<li><a class="reference internal" href="#the-truncation-error-of-approximating">The truncation error of approximating <span class="math">\(u'(0)\)</span></a></li>
<li><a class="reference internal" href="#truncation-error-of-the-equation-for-the-first-step">Truncation error of the equation for the first step</a></li>
<li><a class="reference internal" href="#computing-correction-terms">Computing correction terms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#model-with-damping-and-nonlinearity">Model with damping and nonlinearity</a></li>
<li><a class="reference internal" href="#extension-to-quadratic-damping">Extension to quadratic damping</a></li>
<li><a class="reference internal" href="#the-general-model-formulated-as-first-order-odes">The general model formulated as first-order ODEs</a><ul>
<li><a class="reference internal" href="#the-forward-backward-scheme">The forward-backward scheme</a></li>
<li><a class="reference internal" href="#a-centered-scheme-on-a-staggered-mesh">A centered scheme on a staggered mesh</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#truncation-errors-in-wave-equations">Truncation errors in wave equations</a><ul>
<li><a class="reference internal" href="#linear-wave-equation-in-1d">Linear wave equation in 1D</a></li>
<li><a class="reference internal" href="#finding-correction-terms">Finding correction terms</a></li>
<li><a class="reference internal" href="#extension-to-variable-coefficients-2">Extension to variable coefficients  (2)</a></li>
<li><a class="reference internal" href="#d-wave-equation-on-a-staggered-mesh">1D wave equation on a staggered mesh</a></li>
<li><a class="reference internal" href="#linear-wave-equation-in-2d-3d">Linear wave equation in 2D/3D</a></li>
</ul>
</li>
<li><a class="reference internal" href="#truncation-errors-in-diffusion-equations">Truncation errors in diffusion equations</a><ul>
<li><a class="reference internal" href="#linear-diffusion-equation-in-1d">Linear diffusion equation in 1D</a><ul>
<li><a class="reference internal" href="#the-forward-euler-scheme-in-time">The Forward Euler scheme in time</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme-in-time">The Crank-Nicolson scheme in time</a></li>
</ul>
</li>
<li><a class="reference internal" href="#linear-diffusion-equation-in-2d-3d">Linear diffusion equation in 2D/3D</a></li>
<li><a class="reference internal" href="#a-nonlinear-diffusion-equation-in-2d">A nonlinear diffusion equation in 2D</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-1-truncation-error-of-a-weighted-mean">Exercise 1: Truncation error of a weighted mean</a></li>
<li><a class="reference internal" href="#exercise-2-simulate-the-error-of-a-weighted-mean">Exercise 2: Simulate the error of a weighted mean</a></li>
<li><a class="reference internal" href="#exercise-3-verify-a-truncation-error-formula">Exercise 3: Verify a truncation error formula</a></li>
<li><a class="reference internal" href="#exercise-4-truncation-error-of-the-backward-euler-scheme">Exercise 4: Truncation error of the Backward Euler scheme</a></li>
<li><a class="reference internal" href="#exercise-5-empirical-estimation-of-truncation-errors">Exercise 5: Empirical estimation of truncation errors</a></li>
<li><a class="reference internal" href="#exercise-6-correction-term-for-a-backward-euler-scheme">Exercise 6: Correction term for a Backward Euler scheme</a></li>
<li><a class="reference internal" href="#exercise-7-verify-the-effect-of-correction-terms">Exercise 7: Verify the effect of correction terms</a></li>
<li><a class="reference internal" href="#exercise-8-truncation-error-of-the-crank-nicolson-scheme">Exercise 8: Truncation error of the Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#exercise-9-truncation-error-of">Exercise 9: Truncation error of <span class="math">\(u'=f(u,t)\)</span></a></li>
<li><a class="reference internal" href="#exercise-10-truncation-error-of">Exercise 10: Truncation error of <span class="math">\([D_t D_tu]^n\)</span></a></li>
<li><a class="reference internal" href="#exercise-11-investigate-the-impact-of-approximating">Exercise 11: Investigate the impact of approximating <span class="math">\(u'(0)\)</span></a></li>
<li><a class="reference internal" href="#exercise-12-investigate-the-accuracy-of-a-simplified-scheme">Exercise 12: Investigate the accuracy of a simplified scheme</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Truncation Error Analysis</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/main_trunc.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="Truncation Error Analysis"
             >previous</a> |</li>
        <li><a href="index.html">Truncation Error Analysis</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>