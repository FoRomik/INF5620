<!DOCTYPE html>
<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to computing with finite difference methods">
<meta name="keywords" content="decay ODE,exponential decay,mesh,grid,mesh function,finite differences,forward difference,finite differences forward,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward difference,finite differences backward,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,centered difference,finite differences centered,averaging arithmetic,weighted average,theta-rule,$\theta$-rule,$\theta$-rule,finite difference operator notation,operator notation, finite differences,directory,folder,doc strings,printf format,format string syntax (Python),representative (mesh function),array arithmetics,array computing,continuous function norms,norm continuous,discrete function norms,mesh function norms,norm discrete (mesh function),error norms,scalar computing,PNG plot,PDF plot,EPS plot,viewing graphics files,cropping images,user interfaces to programs,command-line arguments,reading the command line,list comprehension,option-value pairs (command line),command-line options and values,reading the command line,convergence rate,dictionary,verification,modules,test block (in modules),importing modules,doctests,software testing doctests,unit testing,software testing nose,software testing nose w/doctests,unit testing,software testing unit testing (class-based),problem class,solver class,wrapper (code),visualizer class,problem class,solver class,visualizer class,numerical experiments,scientific experiments,script,Unix wildcard notation,wildcard notation (Unix),stability,amplification factor,A-stable methods,L-stable methods,error amplification factor,error global,consistency,stability,convergence,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order scheme,Taylor-series methods (for ODEs),Adams-Bashforth scheme, 2nd-order,Adams-Bashforth scheme, 3rd order,Runge-Kutta, 4th-order scheme,RK4,adaptive time stepping,Dormand-Prince Runge-Kutta 4-5 method,population dynamics,logistic model,radioactive decay,terminal velocity,geometric mean,averaging geometric,scaling">



<style type="text/css">
    /* blueish style */

    /* Color definitions:  http://www.december.com/html/spec/color0.html
       CSS examples:       http://www.w3schools.com/css/css_examples.asp */

    body {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #000000;
    }
    h1 { font-size: 1.8em; color: #1e36ce; }
    h2 { font-size: 1.5em; color: #1e36ce; }
    h3 { color: #1e36ce; }
    a { color: #1e36ce; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .alert-text-small   { font-size: 80%;  }
    .alert-text-large   { font-size: 130%; }
    .alert-text-normal  { font-size: 90%;  }
    .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:1px solid #bababa;
             -webkit-border-radius: 4px; -moz-border-radius: 4px;
             border-radius: 4px
             color: #555;
             background-color: #f8f8f8;
             background-position: 10px 5px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 55px;
             width: 75%;
     }
     .alert-block {padding-top:14px; padding-bottom:14px}
     .alert-block > p, .alert-block > ul {margin-bottom:1em}
     .alert li {margin-top: 1em}
     .alert-block p+p {margin-top:5px}
     .alert-notice { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_notice.png); }
     .alert-summary  { background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_summary.png); }
     .alert-warning { background-image: url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_warning.png); }
     .alert-question {background-image:url(https://doconce.googlecode.com/hg/bundled/html_images/small_gray_question.png); }

</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Finite difference methods  ',
               1,
               'decay:basics',
               'decay:basics'),
              (' A basic model for exponential decay ',
               2,
               'decay:model',
               'decay:model'),
              (' The Forward Euler scheme ',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              (' Step 1: Discretizing the domain ', 3, None, '___sec3'),
              (' Step 2: Fulfilling the equation at discrete time points ',
               3,
               None,
               '___sec4'),
              (' Step 3: Replacing derivatives by finite differences ',
               3,
               None,
               '___sec5'),
              (' Step 4: Formulating a recursive algorithm ',
               3,
               None,
               '___sec6'),
              (' The Backward Euler scheme ',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              (' The Crank-Nicolson scheme ',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              (' The unifying $\\theta$-rule ',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              (' Constant time step ', 2, None, '___sec10'),
              (' Compact operator notation for finite differences ',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              (' Implementation ', 1, 'decay:impl1', 'decay:impl1'),
              (' Making a solver function ', 2, 'decay:py1', 'decay:py1'),
              (' Function for computing the numerical solution ',
               3,
               None,
               '___sec14'),
              (' Integer division ', 3, None, '___sec15'),
              (' Doc strings ', 3, None, '___sec16'),
              (' Formatting of numbers ', 3, None, '___sec17'),
              (' Running the program ', 3, None, '___sec18'),
              (' Verifying the implementation ', 2, None, '___sec19'),
              (' Running a few algorithmic steps by hand ',
               3,
               None,
               '___sec20'),
              (' Comparison with an exact discrete solution ',
               3,
               None,
               '___sec21'),
              (' Computing the numerical error as a mesh function ',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              (' Computing the norm of the numerical error ',
               2,
               'decay:computing:error:norm',
               'decay:computing:error:norm'),
              (' Scalar computing ', 3, None, '___sec24'),
              (' Plotting solutions ', 2, 'decay:plotting', 'decay:plotting'),
              (' Plotting multiple curves ', 3, None, '___sec26'),
              (' Experiments with computing and plotting ',
               3,
               None,
               '___sec27'),
              (' Combining plot files ', 3, None, '___sec28'),
              (' Plotting with SciTools ', 3, None, '___sec29'),
              (' Creating command-line interfaces ',
               2,
               'decay:commandline',
               'decay:commandline'),
              (' Reading a sequence of command-line arguments ',
               3,
               None,
               '___sec31'),
              (' Working with an argument parser ', 3, None, '___sec32'),
              (' Creating a graphical web user interface ',
               2,
               None,
               '___sec33'),
              (' Making a compute function ', 3, None, '___sec34'),
              (' Generating the user interface ', 3, None, '___sec35'),
              (' Running the web application ', 3, None, '___sec36'),
              (' Computing convergence rates ',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              (' Estimating $r$ ', 3, None, '___sec38'),
              (' Implementation ', 3, None, '___sec39'),
              (' Debugging via convergence rates ', 3, None, '___sec40'),
              (' Memory-saving implementation ', 2, None, '___sec41'),
              (' Software engineering ', 1, None, '___sec42'),
              (' Making a module ',
               2,
               'decay:prog:se:module',
               'decay:prog:se:module'),
              (' Prefixing imported functions by the module name ',
               2,
               'decay:prog:se:import',
               'decay:prog:se:import'),
              (' Doctests ',
               2,
               'decay:prog:se:doctest',
               'decay:prog:se:doctest'),
              (' Unit testing with nose ',
               2,
               'decay:prog:se:nose',
               'decay:prog:se:nose'),
              (' Basic use of nose ', 3, None, '___sec47'),
              (' Alternative assert statements ', 3, None, '___sec48'),
              (' Applying nose ', 3, None, '___sec49'),
              (' Installation of nose ', 3, None, '___sec50'),
              (' Using nose to test modules with doctests ',
               3,
               None,
               '___sec51'),
              (' Classical class-based unit testing ',
               2,
               'decay:prog:se:unittest',
               'decay:prog:se:unittest'),
              (' Basic use of unittest ', 3, None, '___sec53'),
              (' Demonstration of unittest ', 3, None, '___sec54'),
              (' Implementing simple problem and solver classes ',
               2,
               'decay:prog:se:class',
               'decay:prog:se:class'),
              (' The problem class ', 3, None, '___sec56'),
              (' The solver class ', 3, None, '___sec57'),
              (' The visualizer class ', 3, None, '___sec58'),
              (' Combing the objects ', 3, None, '___sec59'),
              (' Improving the problem and solver classes ',
               2,
               'decay:prog:se:class2',
               'decay:prog:se:class2'),
              (' A generic class for parameters ', 3, None, '___sec61'),
              (' The problem class ', 3, None, '___sec62'),
              (' The solver class ', 3, None, '___sec63'),
              (' The visualizer class ', 3, None, '___sec64'),
              (' Performing scientific experiments ',
               1,
               'decay:experiments',
               'decay:experiments'),
              (' Software ', 2, None, '___sec66'),
              (' Combining plot files ', 2, None, '___sec67'),
              (' Interpreting output from other programs ',
               2,
               None,
               '___sec68'),
              (' Making a report ',
               2,
               'decay:exper:report',
               'decay:exper:report'),
              (' Plain HTML ', 3, None, '___sec70'),
              (' HTML with MathJax ', 3, None, '___sec71'),
              (' LaTeX ', 3, None, '___sec72'),
              (' Sphinx ', 3, None, '___sec73'),
              (' Markdown ', 3, None, '___sec74'),
              (' Wiki formats ', 3, None, '___sec75'),
              (' Doconce ', 3, None, '___sec76'),
              (' Worked example ', 3, None, '___sec77'),
              (' Publishing a complete project ',
               2,
               'decay:exper:github',
               'decay:exper:github'),
              (' Exercises and Problems ', 1, None, '___sec79'),
              (" Exercise 1: Derive schemes for Newton's law of cooling ",
               2,
               'decay:app:exer:cooling:schemes',
               'decay:app:exer:cooling:schemes'),
              (" Exercise 2: Implement schemes for Newton's law of cooling ",
               2,
               'decay:app:exer:cooling:py',
               'decay:app:exer:cooling:py'),
              (' Exercise 3: Find time of murder from body temperature ',
               2,
               'decay:app:exer:cooling:murder',
               'decay:app:exer:cooling:murder'),
              (' Exercise 4: Experiment with integer division ',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              (' Exercise 5: Experiment with wrong computations ',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              (' Exercise 6: Plot the error function ',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              (' Exercise 7: Compare methods for a given time mesh ',
               2,
               'decay:exer:plot:dtconst',
               'decay:exer:plot:dtconst'),
              (' Exercise 8: Change formatting of numbers and debug ',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              (' Problem 9: Write a doctest ',
               2,
               'decay:exer:doctest1',
               'decay:exer:doctest1'),
              (' Problem 10: Write a nose test ',
               2,
               'decay:exer:nosetest1',
               'decay:exer:nosetest1'),
              (' Problem 11: Make a module ',
               2,
               'decay:exer:module1',
               'decay:exer:module1'),
              (' Exercise 12: Make use of a class implementation ',
               2,
               'decay:exer:decay_class:exper',
               'decay:exer:decay_class:exper'),
              (' Exercise 13: Generalize a class implementation ',
               2,
               'decay:exer:decay_class2',
               'decay:exer:decay_class2'),
              (' Exercise 14: Generalize an advanced class implementation ',
               2,
               'decay:exer:decay_class3',
               'decay:exer:decay_class3'),
              (' Analysis of finite difference equations ',
               1,
               'decay:analysis',
               'decay:analysis'),
              (' Discouraging numerical solutions ', 3, None, '___sec95'),
              (' Experimental investigation of oscillatory solutions ',
               2,
               None,
               '___sec96'),
              (' Exact numerical solution ', 2, None, '___sec97'),
              (' Stability ', 2, None, '___sec98'),
              (' Comparing amplification factors ', 2, None, '___sec99'),
              (' Series expansion of amplification factors ',
               2,
               None,
               '___sec100'),
              (' The fraction of numerical and exact amplification factors ',
               2,
               None,
               '___sec101'),
              (' The global error at a point ',
               2,
               'decay:analysis:gobal:error',
               'decay:analysis:gobal:error'),
              (' Integrated errors ', 2, None, '___sec103'),
              (' Truncation error ', 2, None, '___sec104'),
              (' Consistency, stability, and convergence ',
               2,
               None,
               '___sec105'),
              (' Exercises ', 1, None, '___sec106'),
              (' Exercise 15: Visualize the accuracy of finite differences $u=e^{-at}$ ',
               2,
               'decay:analysis:exer:fd:exp:plot',
               'decay:analysis:exer:fd:exp:plot'),
              (' Exercise 16: Explore the $\\theta$-rule for exponential growth ',
               2,
               'decay:analysis:exer:growth',
               'decay:analysis:exer:growth'),
              (' Model extensions ', 1, None, '___sec109'),
              (' Generalization: including a variable coefficient ',
               2,
               None,
               '___sec110'),
              (' Generalization: including a source term ',
               2,
               'decay:source',
               'decay:source'),
              (' Schemes ', 3, None, '___sec112'),
              (' Implementation of the generalized model problem ',
               2,
               'decay:general',
               'decay:general'),
              (' Deriving the $\\theta$-rule formula ', 3, None, '___sec114'),
              (' The Python code ', 3, None, '___sec115'),
              (' Coding of variable coefficients ', 3, None, '___sec116'),
              (' Verifying a constant solution ',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              (' Verification via manufactured solutions ',
               2,
               'decay:MMS',
               'decay:MMS'),
              (' Extension to systems of ODEs ', 2, None, '___sec119'),
              (' General first-order ODEs ', 1, None, '___sec120'),
              (' Generic form ', 2, None, '___sec121'),
              (' The $\\theta$-rule ', 2, None, '___sec122'),
              (' An implicit 2-step backward scheme ', 2, None, '___sec123'),
              (' Leapfrog schemes ', 2, None, '___sec124'),
              (' The ordinary Leapfrog scheme ', 3, None, '___sec125'),
              (' The filtered Leapfrog scheme ', 3, None, '___sec126'),
              (' The 2nd-order Runge-Kutta scheme ', 2, None, '___sec127'),
              (' A 2nd-order Taylor-series method ', 2, None, '___sec128'),
              (' The 2nd- and 3rd-order Adams-Bashforth schemes ',
               2,
               None,
               '___sec129'),
              (' 4th-order Runge-Kutta scheme ',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              (' The Odespy software ', 2, None, '___sec131'),
              (' Example: Runge-Kutta methods  ', 2, None, '___sec132'),
              (' Remark about using the $\\theta$-rule in Odespy ',
               3,
               None,
               '___sec133'),
              (' Example: Adaptive Runge-Kutta methods  ',
               2,
               'decay:fd2:adaptiveRK',
               'decay:fd2:adaptiveRK'),
              (' Exercises ', 1, None, '___sec135'),
              (' Exercise 17: Experiment with precision in tests and the size of $u$ ',
               2,
               'decay:fd2:exer:precision',
               'decay:fd2:exer:precision'),
              (' Exercise 18: Implement the 2-step backward scheme ',
               2,
               'decay:fd2:exer:bw2',
               'decay:fd2:exer:bw2'),
              (' Exercise 19: Implement the 2nd-order Adams-Bashforth scheme ',
               2,
               'decay:fd2:exer:AB2',
               'decay:fd2:exer:AB2'),
              (' Exercise 20: Implement the 3rd-order Adams-Bashforth scheme ',
               2,
               'decay:fd2:exer:AB3',
               'decay:fd2:exer:AB3'),
              (' Exercise 21: Analyze explicit 2nd-order methods ',
               2,
               'decay:exer:RK2:Taylor:analysis',
               'decay:exer:RK2:Taylor:analysis'),
              (' Problem 22: Implement and investigate the Leapfrog scheme ',
               2,
               'decay:fd2:exer:leapfrog1',
               'decay:fd2:exer:leapfrog1'),
              (' Problem 23: Make a unified implementation of many schemes ',
               2,
               'decay:fd2:exer:uni',
               'decay:fd2:exer:uni'),
              (' Applications of exponential decay models ',
               1,
               'decay:app',
               'decay:app'),
              (' Scaling ', 2, 'decay:app:scaling', 'decay:app:scaling'),
              (' Evolution of a population ',
               2,
               'decay:app:pop',
               'decay:app:pop'),
              (' Compound interest and inflation ',
               2,
               'decay:app:interest',
               'decay:app:interest'),
              (' Radioactive Decay ',
               2,
               'decay:app:nuclear',
               'decay:app:nuclear'),
              (' Deterministic model ', 3, None, '___sec148'),
              (' Stochastic model ', 3, None, '___sec149'),
              (' Relation between stochastic and deterministic models ',
               3,
               None,
               '___sec150'),
              (" Newton's law of cooling ",
               2,
               'decay:app:Newton:cooling',
               'decay:app:Newton:cooling'),
              (' Decay of atmospheric pressure with altitude ',
               2,
               'decay:app:atm',
               'decay:app:atm'),
              (' Multiple atmospheric layers ', 3, None, '___sec153'),
              (' Simplification: $L=0$ ', 3, None, '___sec154'),
              (' Simplification: one-layer model ', 3, None, '___sec155'),
              (' Compaction of sediments ',
               2,
               'decay:app:sediment',
               'decay:app:sediment'),
              (' Vertical motion of a body in a viscous fluid ',
               2,
               'decay:app:drag',
               'decay:app:drag'),
              (' Overview of forces ', 3, None, '___sec158'),
              (' Equation of motion ', 3, None, '___sec159'),
              (' Terminal velocity ', 3, None, '___sec160'),
              (' A Crank-Nicolson scheme ', 3, None, '___sec161'),
              (' Physical data ', 3, None, '___sec162'),
              (' Verification ', 3, None, '___sec163'),
              (' Scaling ', 3, None, '___sec164'),
              (' Decay ODEs from solving a PDE by Fourier expansions ',
               2,
               'decay:app:diffusion:Fourier',
               'decay:app:diffusion:Fourier'),
              (' Exercises and Projects ', 1, None, '___sec166'),
              (' Exercise 24: Simulate an oscillating cooling process ',
               2,
               'decay:app:exer:cooling:osc',
               'decay:app:exer:cooling:osc'),
              (' Exercise 25: Radioactive decay of Carbon-14 ',
               2,
               'decay:app:exer:radio:C14',
               'decay:app:exer:radio:C14'),
              (' Exercise 26: Simulate stochastic radioactive decay ',
               2,
               'decay:app:exer:stoch:nuclear',
               'decay:app:exer:stoch:nuclear'),
              (' Exercise 27: Radioactive decay of two substances ',
               2,
               'decay:app:exer:radio:twosubst',
               'decay:app:exer:radio:twosubst'),
              (' Exercise 28: Simulate the pressure drop in the atmosphere ',
               2,
               'decay:app:exer:atm1',
               'decay:app:exer:atm1'),
              (' Exercise 29: Make a program for vertical motion in a fluid ',
               2,
               'decay:app:exer:drag:prog',
               'decay:app:exer:drag:prog'),
              (' Project 30: Simulate parachuting ',
               2,
               'decay:app:exer:parachute',
               'decay:app:exer:parachute'),
              (' Exercise 31: Formulate vertical motion in the atmosphere ',
               2,
               'decay:app:exer:drag:atm1',
               'decay:app:exer:drag:atm1'),
              (' Exercise 32: Simulate vertical motion in the atmosphere ',
               2,
               'decay:app:exer:drag:atm2',
               'decay:app:exer:drag:atm2'),
              (' Exercise 33: Compute $y=|x|$ by solving an ODE ',
               2,
               'decay:app:exer:signum',
               'decay:app:exer:signum'),
              (' Exercise 34: Simulate growth of a fortune with random interest rate ',
               2,
               'decay:app:exer:interest',
               'decay:app:exer:interest'),
              (' Exercise 35: Simulate a population in a changing environment ',
               2,
               'decay:app:exer:pop:at',
               'decay:app:exer:pop:at'),
              (' Exercise 36: Simulate logistic growth ',
               2,
               'decay:app:exer:pop:logistic1',
               'decay:app:exer:pop:logistic1'),
              (' Exercise 37: Rederive the equation for continuous compound interest ',
               2,
               'decay:app:exer:interest:derive',
               'decay:app:exer:interest:derive'),
              (' Bibliography ', 1, None, '___sec181')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">


<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\vexd}[1]{{v_{\small\mbox{e}, #1}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\ts}{\thinspace .}

\newcommand{\Ddt}[1]{\frac{D #1}{dt}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}

\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\strain}{\boldsymbol{\varepsilon}}
\newcommand{\stressc}{{\sigma}}
\newcommand{\strainc}{{\varepsilon}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}

% Unit vectors
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\iz}{\boldsymbol{i}_z}

% Index sets
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
%\newcommand{\setl}[1]{#1\setminus\{\set1{#1}\}}
%\newcommand{\setr}[1]{#1\setminus\{\set0{#1}\}}
%\newcommand{\seti}[1]{#1\setminus\{\set0{#1},\set1{#1}\}}
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}

% Finite elements
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
%\newcommand{\xno}[1]{x^{(#1)}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\Yno}[1]{Y_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}

% FEniCS commands
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integerp}{\mathbb{N}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0001"></a>
<!-- begin top navigation -->
<a href="._part0000_main_decay.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0002_main_decay.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end top navigation -->

<p>
<!-- !split -->

<h2>Finite difference methods <a name="decay:basics"></a></h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Goal.</b>
We explain the basic ideas of finite difference methods
using a simple ordinary differential equation \( u'=-au \) as
primary example.
Emphasis is put on the reasoning when discretizing the problem and
introduction of key concepts such as mesh, mesh function,
finite difference approximations, averaging in a mesh,
deriation of algorithms, and discrete operator notation.
</div>
<h3>A basic model for exponential decay <a name="decay:model"></a></h3>

<p>
Our model problem is perhaps the simplest ordinary differential
equation (ODE):

<p>
$$
\begin{equation*}
u'(t) = -au(t),
\end{equation*}
$$

Here, \( a>0 \) is a constant and \( u'(t) \) means differentiation with
respect to time \( t \). This type of equation arises in a number of
widely different phenomena where some quantity \( u \) undergoes
exponential reduction. Examples include radioactive decay, population
decay, investment decay, cooling of an object, pressure decay in the
atmosphere, and retarded motion in fluids (for some of these models,
\( a \) can be negative as well), see the section <a href="._part0008_main_decay.html#decay:app">Applications of exponential decay models</a> for details
and motivation.  We have chosen this particular ODE not only because
its applications are relevant, but even more because studying
numerical solution methods for this simple ODE gives important insight
that can be reused in much more complicated settings, in particular
when solving diffusion-type partial differential equations.

<p>
The analytical solution of the ODE is found by the method of
separation of variables, which results in

<p>
$$
\begin{equation*} u(t) = Ce^{-at},\end{equation*}
$$

for any arbitrary constant \( C \).
To formulate a mathematical problem for which there
is a unique solution, we need a condition to fix the value of \( C \).
This condition is known as the <em>initial condition</em> and stated as
\( u(0)=I \). That is, we know the
value \( I \) of \( u \) when the process starts at \( t=0 \). The exact solution
is then \( u(t)=Ie^{-at} \).

<p>
We seek the solution \( u(t) \) of the ODE for \( t\in (0,T] \). The point \( t=0 \) is not
included since we know \( u \) here and assume that the equation governs
\( u \) for \( t>0 \). The complete ODE problem then reads: find \( u(t) \)
such that

<p>
$$
\begin{equation}
u' = -au,\ t\in (0,T], \quad u(0)=I\thinspace .  \tag{1}
\end{equation}
$$

This is known as a <em>continuous problem</em> because the parameter \( t \)
varies continuously from \( 0 \) to \( T \). For each \( t \) we have a corresponding
\( u(t) \). There are hence infinitely many values of \( t \) and \( u(t) \).
The purpose of a numerical method is to formulate a corresponding
<em>discrete</em> problem whose solution is characterized by a finite number of values,
which can be computed in a finite number of steps on a computer.

<h3>The Forward Euler scheme <a name="decay:schemes:FE"></a></h3>

<p>
Solving an ODE like <a href="#mjx-eqn-1">(1)</a> by a finite difference method
consists of the following four steps:

<p>

<ol>
<li> discretizing the domain,</li>
<li> fulfilling the equation at discrete time points,</li>
<li> replacing derivatives by finite differences,</li>
<li> formulating a recursive algorithm.</li>
</ol>

<h4>Step 1: Discretizing the domain  <a name="___sec3"></a></h4>

<p>
The time domain \( [0,T] \) is represented by a finite number of
\( N_t+1 \) points

<p>
$$
\begin{equation}
0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T\thinspace .
\end{equation}
$$

The collection of points \( t_0,t_1,\ldots,t_{N_t} \) constitutes a <em>mesh</em>
or <em>grid</em>. Often the mesh points will be uniformly spaced in
the domain \( [0,T] \), which means that the spacing \( t_{n+1}-t_n \) is
the same for all \( n \). This spacing is often denoted by \( \Delta t \),
in this case \( t_n=n\Delta t \).

<p>
We seek the solution \( u \) at the mesh points:
\( u(t_n) \), \( n=1,2,\ldots,N_t \). Note that \( u^0 \) is already known as \( I \).
A notational short-form for \( u(t_n) \),
which will be used extensively, is \( u^{n} \). More precisely, we let
\( u^n \) be the <em>numerical approximation</em> to the exact solution \( u(t_n) \)
at \( t=t_n \). The numerical approximation is a <em>mesh function</em>,
here defined only at the mesh points.
When we need to clearly distinguish between the numerical
and the exact solution, we often place a subscript e on the exact
solution, as in \( \uex(t_n) \). Figure <a href="#decay:fdu:e">1</a> shows the
\( t_n \) and \( u_n \) points for \( n=0,1,\ldots,N_t=7 \) as well as \( \uex(t) \)
as the dashed line. The goal of a numerical method for ODEs is
to compute the mesh function by solving a finite set of
<em>algebraic equations</em> derived from the original ODE problem.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Time mesh with discrete solution values. <a name="decay:fdu:e"></a> </p></center>
<p><img src="fig-decay/fdm_u_ue.png" align="bottom" width=600></p>
</center>

<p>
Since finite difference methods produce solutions at the mesh
points only, it is an open question what the solution is between
the mesh points. One can use methods for interpolation to
compute the value of \( u \) between mesh points. The simplest
(and most widely used) interpolation method is to assume that
\( u \) varies linearly between the mesh points, see
Figure <a href="#decay:fdu:ei">2</a>. Given \( u^{n} \)
and \( u^{n+1} \), the value of \( u \) at some \( t\in [t_{n}, t_{n+1}] \)
is by linear interpolation

<p>
$$
\begin{equation}
u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n)\thinspace .
\end{equation}
$$


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Linear interpolation between the discrete solution values (dashed curve is exact solution). <a name="decay:fdu:ei"></a> </p></center>
<p><img src="fig-decay/fdm_u_uei.png" align="bottom" width=600></p>
</center>

<h4>Step 2: Fulfilling the equation at discrete time points  <a name="___sec4"></a></h4>

<p>
The ODE is supposed to hold for all \( t\in (0,T] \), i.e., at an infinite
number of points. Now we relax that requirement and require that
the ODE is fulfilled at a finite set of discrete points in time.
The mesh points \( t_1,t_2,\ldots,t_{N_t} \) are a natural choice of points.
The original ODE is then reduced to  the following \( N_t \) equations:

<p>
$$
\begin{equation}
u'(t_n) = -au(t_n),\quad n=1,\ldots,N_t\thinspace .
\tag{2}
\end{equation}
$$

<h4>Step 3: Replacing derivatives by finite differences  <a name="___sec5"></a></h4>

<p>
The next and most essential step of the method is to replace the
derivative \( u' \) by a finite difference approximation. Let us first
try a one-sided difference approximation (see Figure <a href="#decay:sketch:FE">3</a>),

<p>
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}\thinspace .
\tag{3}
\end{equation}
$$

Inserting this approximation in <a href="#mjx-eqn-2">(2)</a> results in

<p>
$$
\begin{equation}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N_t-1\thinspace .
\tag{4}
\end{equation}
$$

This equation is the discrete counterpart to the original ODE problem
<a href="#mjx-eqn-1">(1)</a>, and often referred to as <em>finite difference scheme</em>
or more generally as the <em>discrete equations</em> of the problem.
The fundamental feature of these equations is that they are <em>algebraic</em>
and can hence be straightforwardly solved to produce the mesh function, i.e.,
the values of \( u \) at
the mesh points (\( u^n \), \( n=1,2,\ldots,N_t \)).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Illustration of a forward difference. <a name="decay:sketch:FE"></a> </p></center>
<p><img src="fig-decay/fd_forward.png" align="bottom" width=400></p>
</center>

<h4>Step 4: Formulating a recursive algorithm  <a name="___sec6"></a></h4>

<p>
The final step is to identify the computational algorithm to be implemented
in a program. The key observation here is to realize that
<a href="#mjx-eqn-4">(4)</a> can be used to compute \( u^{n+1} \) if \( u^n \) is known.
Starting with \( n=0 \), \( u^0 \) is known since \( u^0=u(0)=I \), and
<a href="#mjx-eqn-4">(4)</a> gives an equation for \( u^1 \). Knowing \( u^1 \),
\( u^2 \) can be found from <a href="#mjx-eqn-4">(4)</a>. In general, \( u^n \)
in <a href="#mjx-eqn-4">(4)</a> can be assumed known, and then we can easily solve for
the unknown \( u^{n+1} \):

<p>
$$
\begin{equation}
u^{n+1} = u^n - a(t_{n+1} -t_n)u^n\thinspace .
\tag{5}
\end{equation}
$$

We shall refer to <a href="#mjx-eqn-5">(5)</a> as the Forward Euler (FE) scheme
for our model problem. From a mathematical point of view,
equations of the form <a href="#mjx-eqn-5">(5)</a> are known as
<em>difference equations</em> since they express how differences in
\( u \), like \( u^{n+1}-u^n \), evolve with \( n \).
The finite difference method can be viewed as a method for turning
a differential equation into a difference equation.

<p>
Computation with <a href="#mjx-eqn-5">(5)</a> is straightforward:

<p>
$$
\begin{align*}
u_0 &= I,\\ 
u_1 & = u^0 - a(t_{1} -t_0)u^0 = I(1-a(t_1-t_0)),\\ 
u_2 & = u^1 - a(t_{2} -t_1)u^1 = I(1-a(t_1-t_0))(1 - a(t_2-t_1)),\\ 
u^3 &= u^2 - a(t_{3} -t_2)u^2 = I(1-a(t_1-t_0))(1 - a(t_2-t_1))(1 - a(t_3-t_2)),
\end{align*}
$$

and so on until we reach \( u^{N_t} \).
Very often, \( t_{n+1}-t_n \) is constant for all \( n \), so we can introduce
the common symbol \( \Delta t \) for the time step:
\( \Delta t = t_{n+1}-t_n \), \( n=0,1,\ldots,N_t-1 \).
Using a constant time step \( \Delta t \) in the above calculations gives

<p>
$$
\begin{align*}
u_0 &= I,\\ 
u_1 & = I(1-a\Delta t),\\ 
u_2 & = I(1-a\Delta t)^2,\\ 
u^3 &= I(1-a\Delta t)^3,\\ 
&\vdots\\ 
u^{N_t} &= I(1-a\Delta t)^{N_t}\thinspace .
\end{align*}
$$

This means that we have found a closed formula for \( u^n \), and there is
no need to let a computer generate the sequence \( u^1, u^2, u^3, \ldots \).
However, finding such a formula for \( u^n \) is possible only for a few very
simple problems, so in general finite difference equations must be
solved on a computer.

<p>
As the next sections will show, the scheme <a href="#mjx-eqn-5">(5)</a> is just one
out of many alternative finite difference (and other) methods for
the model problem <a href="#mjx-eqn-1">(1)</a>.

<h3>The Backward Euler scheme <a name="decay:schemes:BE"></a></h3>

<p>
There are several choices of difference approximations in step 3 of
the finite difference method as presented in the previous section.
Another alternative is

<p>
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}\thinspace .
\tag{6}
\end{equation}
$$

Since this difference is based on going backward in time (\( t_{n-1} \))
for information, it is known as the Backward Euler difference.
Figure <a href="#decay:sketch:BE">4</a> explains the idea.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Illustration of a backward difference. <a name="decay:sketch:BE"></a> </p></center>
<p><img src="fig-decay/fd_backward.png" align="bottom" width=400></p>
</center>

<p>
Inserting <a href="#mjx-eqn-6">(6)</a> in <a href="#mjx-eqn-2">(2)</a> yields
the Backward Euler (BE) scheme:

<p>
$$
\begin{equation}
\frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n\thinspace .
\tag{7}
\end{equation}
$$

We assume, as explained under step 4 in the section <a href="#decay:schemes:FE">The Forward Euler scheme</a>,
that we have computed \( u^0, u^1, \ldots, u^{n-1} \) such that
<a href="#mjx-eqn-7">(7)</a> can be used to compute \( u^n \).
For direct similarity with the Forward Euler scheme <a href="#mjx-eqn-5">(5)</a>
we replace \( n \) by \( n+1 \) in <a href="#mjx-eqn-7">(7)</a> and solve for the
unknown value \( u^{n+1} \):

<p>
$$
\begin{equation}
u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n\thinspace .
\tag{8}
\end{equation}
$$

<h3>The Crank-Nicolson scheme <a name="decay:schemes:CN"></a></h3>

<p>
The finite difference approximations used to derive the schemes
<a href="#mjx-eqn-5">(5)</a> and <a href="#mjx-eqn-8">(8)</a> are both one-sided differences,
known to be less accurate than central (or midpoint)
differences. We shall now construct
a central difference at \( t_{n+1/2}=\frac{1}{2} (t_n + t_{n+1}) \), or
\( t_{n+1/2}=(n+\frac{1}{2})\Delta t \) if the mesh spacing is uniform in time.
The approximation reads

<p>
$$
\begin{equation}
u'(t_{n+\frac{1}{2}}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}\thinspace .
\tag{9}
\end{equation}
$$

Note that the fraction on the right-hand side is the same as for the
Forward Euler approximation <a href="#mjx-eqn-3">(3)</a> and
the Backward Euler approximation <a href="#mjx-eqn-6">(6)</a> (with
\( n \) replaced by \( n+1 \)). The accuracy of this fraction as an approximation
to the derivative of \( u \) depends on <em>where</em> we seek the derivative:
in the center of the interval \( [t_{n},t_{n+1}] \) or at the end points.

<p>
With the formula <a href="#mjx-eqn-9">(9)</a>, where \( u' \) is evaluated at
\( t_{n+1/2} \), it is natural to demand the
ODE to be fulfilled at the time points between the mesh points:

<p>
$$
\begin{equation}
u'(t_{n+\frac{1}{2}}) = -au(t_{n+\frac{1}{2}}),\quad n=0,
\ldots,N_t-1\thinspace .
\tag{10}
\end{equation}
$$

Using <a href="#mjx-eqn-9">(9)</a> in <a href="#mjx-eqn-10">(10)</a> results in

<p>
$$
\begin{equation}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -au^{n+\frac{1}{2}},
\tag{11}
\end{equation}
$$

where \( u^{n+\frac{1}{2}} \) is a short form for \( u(t_{n+\frac{1}{2}}) \).
The problem is that we aim to compute \( u^n \) for integer \( n \), implying that
\( u^{n+\frac{1}{2}} \) is not a quantity computed by our method. It must
therefore be
expressed by the quantities that we actually produce, i.e.,
the numerical solution at the
mesh points. One possibility is to approximate \( u^{n+\frac{1}{2}} \)
as an arithmetic mean of the \( u \) values at the neighboring mesh points:

<p>
$$
\begin{equation}
u^{n+\frac{1}{2}} \approx \frac{1}{2} (u^n + u^{n+1})\thinspace .
\tag{12}
\end{equation}
$$

Using <a href="#mjx-eqn-12">(12)</a> in <a href="#mjx-eqn-11">(11)</a> results in

<p>
$$
\begin{equation}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\frac{1}{2} (u^n + u^{n+1})\thinspace .
\tag{13}
\end{equation}
$$

Figure <a href="#decay:sketch:CN">5</a> sketches the geometric interpretation of
such a centered difference.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Illustration of a centered difference. <a name="decay:sketch:CN"></a> </p></center>
<p><img src="fig-decay/fd_centered.png" align="bottom" width=400></p>
</center>

<p>
We assume that \( u^n \) is already computed so that \( u^{n+1} \) is the
unknown, which we can solve for:

<p>
$$
\begin{equation}
u^{n+1} = \frac{1-\frac{1}{2} a(t_{n+1}-t_n)}{1 + \frac{1}{2} a(t_{n+1}-t_n)}u^n\thinspace .
\tag{14}
\end{equation}
$$

The finite difference scheme <a href="#mjx-eqn-14">(14)</a> is often called
the Crank-Nicolson (CN) scheme or a midpoint or centered scheme.

<h3>The unifying \( \theta \)-rule <a name="decay:schemes:theta"></a></h3>

<p>
The Forward Euler, Backward Euler, and Crank-Nicolson schemes can be
formulated as one scheme with a varying parameter \( \theta \):

<p>
$$
\begin{equation}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})
\tag{15}
\thinspace .
\end{equation}
$$


<p>

<ul>
 <li> \( \theta =0 \) gives the Forward Euler scheme</li>
 <li> \( \theta =1 \) gives the Backward Euler scheme, and</li>
 <li> \( \theta =1/2 \) gives the Crank-Nicolson scheme.</li>
 <li> We may alternatively choose any other value of \( \theta \) in \( [0,1] \).</li>
</ul>

As before, \( u^n \) is considered known and \( u^{n+1} \) unknown, so
we solve for the latter:

<p>
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}\thinspace .
\tag{16}
\end{equation}
$$

This scheme is known as the \( \theta \)-rule, or alternatively written as
the "theta-rule".

<p>
<div class="alert alert-block alert-notice alert-text-normal"><b>Derivation.</b>
We start with replacing \( u' \) by the fraction

<p>
$$
\begin{equation*} \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n},\end{equation*}
$$

in the Forward Euler, Backward Euler,
and Crank-Nicolson schemes. Then we observe that
the difference between the methods concerns which point this
fraction approximates the derivative. Or in other words, at which point we
sample the ODE. So far this has been the
end points or the midpoint of \( [t_n,t_{n+1}] \). However, we may choose any point
\( \tilde t \in [t_n,t_{n+1}] \).
The difficulty
is that evaluating the right-hand side \( -au \) at an arbitrary point
faces the same problem as in
the section <a href="#decay:schemes:CN">The Crank-Nicolson scheme</a>: the point value must be expressed
by the discrete \( u \) quantities that we compute by the scheme, i.e.,
\( u^n \) and \( u^{n+1} \). Following the averaging idea from
the section <a href="#decay:schemes:CN">The Crank-Nicolson scheme</a>,
the value of \( u \) at an arbitrary point \( \tilde t \) can be
calculated as a <em>weighted average</em>, which generalizes the arithmetic mean
\( \frac{1}{2}u^n + \frac{1}{2}u^{n+1} \).
If we express \( \tilde t \) as a weighted average
$$ t_{n+\theta} = \theta t_{n+1} + (1-\theta) t_{n},$$

where \( \theta\in [0,1] \) is the weighting factor, we can write

<p>
$$
\begin{equation}
u(\tilde t) = u(\theta t_{n+1} + (1-\theta) t_{n}) \approx
\theta u^{n+1} + (1-\theta) u^{n}\thinspace .
\tag{17}
\end{equation}
$$


<p>
We can now let the ODE hold at the point
\( \tilde t\in [t_n,t_{n+1}] \), approximate \( u' \) by the fraction
\( (u^{n+1}-u^{n})/(t_{n+1}-t_n) \), and approximate the right-hand
side \( -au \) by the weighted average <a href="#mjx-eqn-17">(17)</a>.
The result is <a href="#mjx-eqn-15">(15)</a>.

<p>
</div>
<h3>Constant time step  <a name="___sec10"></a></h3>

<p>
All schemes up to now have been formulated for a general non-uniform
mesh in time: \( t_0,t_1,\ldots,t_{N_t} \). Non-uniform meshes are highly relevant
since one can use many points in regions where \( u \) varies rapidly, and
save points in regions where \( u \) is slowly varying. This is the key idea
of <em>adaptive</em> methods where the spacing of the mesh points
are determined as the computations proceed.

<p>
However, a uniformly distributed set of mesh points is very common and
sufficient for many applications. It therefore makes sense to
present the finite difference schemes for a uniform point distribution
\( t_n=n\Delta t \), where \( \Delta t \) is the constant spacing between
the mesh points, also referred to as the <em>time step</em>.
The resulting formulas look simpler and are perhaps more
well known.

<p>
<div class="alert alert-block alert-summary alert-text-normal"><b>Summary of schemes for constant time step.</b>
$$
\begin{align}
u^{n+1} &= (1 - a\Delta t )u^n  \quad (\hbox{FE})
\tag{18}\\ 
u^{n+1} &= \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})
\tag{19}\\ 
u^{n+1} &= \frac{1-\frac{1}{2} a\Delta t}{1 + \frac{1}{2} a\Delta t} u^n \quad (\hbox{CN})
\tag{20}\\ 
u^{n+1} &= \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})
\tag{21}
\end{align}
$$
</div>
<p>
Not surprisingly, we present these three alternative schemes
because they have different pros and cons, both for the simple ODE
in question (which can easily be solved as accurately as desired), and for
more advanced differential equation problems.

<p>
<div class="alert alert-block alert-question alert-text-normal"><b>Test the understanding.</b>
At this point it can be good training to apply the explained
finite difference discretization techniques to a slightly
different equation. <a href="._part0005_main_decay.html#decay:app:exer:cooling:schemes">Exercise 1: Derive schemes for Newton's law of cooling</a>
is therefore highly recommended to check that the key concepts
are understood.
</div>
<h3>Compact operator notation for finite differences <a name="decay:fd:op"></a></h3>

<p>
Finite difference formulas can be tedious to write and read,
especially for differential equations with many terms and many
derivatives. To save space and help the reader of the scheme to quickly
see the nature of the difference approximations, we introduce a
compact notation. A forward difference approximation is denoted
by the \( D_t^+ \) operator:

<p>
$$
\begin{equation}
[D_t^+u]^n = \frac{u^{n+1} - u^{n}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \tag{22}
\thinspace .
\end{equation}
$$

The notation consists of an operator that approximates
differentiation with respect to an independent variable, here \( t \).
The operator is built of the symbol \( D \), with the variable as subscript
and a superscript denoting the type of difference. The superscript \( \,{}^+ \)
indicates a forward difference.
We place square brackets around the operator and the function it operates
on and specify the mesh point, where the operator is acting, by
a superscript.

<p>
The corresponding operator notation for a centered difference and
a backward difference reads

<p>
$$
\begin{equation}
[D_tu]^n = \frac{u^{n+\frac{1}{2}} - u^{n-\frac{1}{2}}}{\Delta t}
\approx \frac{d}{dt} u(t_n), \tag{23}
\end{equation}
$$

and
$$
\begin{equation}
[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \tag{24}
\thinspace .
\end{equation}
$$

Note that the superscript \( \,{}^- \) denotes the backward
difference, while no superscript implies a central difference.

<p>
An averaging operator is also convenient to have:

<p>
$$
\begin{equation}
[\overline{u}^{t}]^n = \frac{1}{2} (u^{n-\frac{1}{2}} + u^{n+\frac{1}{2}} )
\approx u(t_n) \tag{25}
\end{equation}
$$

The superscript \( t \) indicates that the average is taken along the time
coordinate. The common average \( (u^n + u^{n+1})/2 \) can now be
expressed as \( [\overline{u}^{t}]^{n+1/2} \). (When also spatial coordinates
enter the problem, we need the explicit specification of the coordinate
after the bar.)

<p>
The Backward Euler finite difference approximation to \( u'=-au \) can be written
as follows utilizing the compact notation:

<p>
$$
\begin{equation*}
[D_t^-u]^n = -au^n \thinspace .
\end{equation*}
$$

In difference equations we often place the square brackets around
the whole equation, to indicate at which mesh point the equation applies,
since each term is supposed to be approximated at the same point:

<p>
$$
\begin{equation}
[D_t^- u  = -au]^n \thinspace .
\end{equation}
$$

The Forward Euler scheme takes the form

<p>
$$
\begin{equation}
[D_t^+ u  = -au]^n,
\end{equation}
$$

while the Crank-Nicolson scheme is written as

<p>
$$
\begin{equation}
[D_t u = -a\overline{u}^t]^{n+\frac{1}{2}}\thinspace .
\tag{26}
\end{equation}
$$


<p>
<div class="alert alert-block alert-question alert-text-normal"><b>Question.</b>
Apply <a href="#mjx-eqn-23">(23)</a> and <a href="#mjx-eqn-25">(25)</a> and write out the
expressions to see that <a href="#mjx-eqn-26">(26)</a> is indeed the
Crank-Nicolson scheme.
</div>
<p>
The \( \theta \)-rule can be specified by

<p>
$$
\begin{equation}
[\bar D_t u = -a\overline{u}^{t,\theta}]^{n+\theta},
\tag{27}
\end{equation}
$$

if we define a new time difference and a <em>weighted averaging operator</em>:

<p>
$$
\begin{equation}
\lbrack\bar D_t u\rbrack^{n+\theta} = \frac{u^{n+1}-u^n}{t^{n+1}-t^n},
\tag{28}
\end{equation}
\begin{equation}
\lbrack\overline{u}^{t,\theta}\rbrack^{n+\theta} = (1-\theta)u^{n} + \theta u^{n+1}
\approx u(t_{n+\theta}),
\tag{29}
\end{equation}
$$

where \( \theta\in [0,1] \). Note that for \( \theta =1/2 \) we recover
the standard centered difference and the standard arithmetic mean.
The idea in <a href="#mjx-eqn-27">(27)</a> is to sample the equation at
\( t_{n+\theta} \), use a skew difference at that
point \( [\bar D_t u]^{n+\theta} \), and a skew mean value.
An alternative notation is
$$ [D_t u]^{n+1/2} = \theta [-au]^{n+1} + (1-\theta)[-au]^{n}\thinspace .$$


<p>
Looking at the various examples above and comparing them with the
underlying differential equations, we see immediately which difference
approximations that have been used and at which point they
apply. Therefore, the compact notation effectively communicates the
reasoning behind turning a differential equation into a difference
equation.

<p>
<p>
<!-- begin bottom navigation -->
<a href="._part0000_main_decay.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/prev1.png" border=0 alt="previous"></a>

<a href="._part0002_main_decay.html"><img src="http://hplgit.github.io/doconce/bundled/html_images/next1.png" border=0 alt="next"></a>
<!-- end bottom navigation -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

