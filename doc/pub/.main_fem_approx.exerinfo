
# Information about all exercises in the file main_fem_approx.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_fem_approx.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['linalg1.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:linalg1',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Look up the topic of *vector space* in your favorite linear algebra\nbook or search for the term at Wikipedia.\nProve that vectors in the plane $(a,b)$ form a vector space\nby showing that all the axioms of a vector space\nare satisfied. Similarly,\nprove that all linear functions of the form $ax+b$ constitute a vector space,\n$a,b\\in\\Real$.\n\nOn the contrary,\nshow that all quadratic functions of the form $1 + ax^2 + bx$ *do not*\nconstitute a vector space.',
  'title': 'Linear algebra refresher I',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['linalg2.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:linalg2',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'As an extension of Exercise ref{fem:approx:exer:linalg1}, check out\nthe topic of *inner product spaces*. Suggest a possible inner product\nfor the space of all linear functions of the form $ax+b$, $a,b\\in\\Real$.\nShow that this inner product satisfies the\ngeneral requirements of an inner product in a vector space.',
  'title': 'Linear algebra refresher II',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vec111_approx.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:vec:3Dby2D',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Given $\\f = (1,1,1)$ in $\\Real^3$, find the best approximation vector\n$\\u$ in the plane spanned by the unit vectors $(1,0)$ and $(0,1)$.\nRepeat the calculations using the vectors $(2,1)$ and $(1,2)$.',
  'title': 'Approximate a three-dimensional vector in a plane',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['exp_powers.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:exp:powers',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Let $V$ be a function space with basis functions $x^i$,\n$i=0,1,\\ldots,N$.  Find the best approximation to $f(x)=\\exp(-x)$ on\n$\\Omega =[0,4]$ among all functions in $V$ for $N=2,4,6$. Illustrate\nthe three approximations in three separate plots.  Add the\ncorresponding Taylor polynomial approximation of degree $N$ in each\nplot.',
  'title': 'Approximate the exponential function by power functions',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['sin_powers.py'],
  'heading': '=====',
  'hints': ['One can make a loop over $k$ and call the functions `least_squares` and\n`comparison_plot` from the `approx1D` module.'],
  'keywords': None,
  'label': 'fem:approx:exer:sin:powers',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Let $V$ be a function space with basis functions\n$x^{2i+1}$, $i=0,1,\\ldots,N$.\nFind the best approximation to $f(x)=\\sin(x)$ among all functions in $V$,\nusing $N=8$ for a domain that includes more and more half-periods of\nthe sine function: $\\Omega = [0, k\\pi/2]$, $k=2,3,\\ldots,12$.\nHow does a Taylor series of $\\sin(x)$ around $x$ up to degree 9\nbehave for the largest domain?',
  'title': 'Approximate the sine function by power functions',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tanh_sines_approx1.py'],
  'heading': '=====',
  'hints': ['One may naively call the `least_squares_orth` and `comparison_plot`\nfrom the `approx1D` module in a loop and extend the basis with\none new element in each pass. This approach\nimplies a lot of recomputations.\nA more efficient strategy is to let `least_squares_orth`\ncompute with only one basis function at a time and accumulate\nthe corresponding `u` in the total solution.'],
  'keywords': None,
  'label': 'fem:approx:exer:tanh:sine1',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Find the best approximation of $f(x) = \\tanh (s(x-\\pi))$ on\n$[0, 2\\pi]$ in the space $V$ with basis\n$\\baspsi_i(x) = \\sin((2i+1)x)$, $i\\in\\If = \\{0,\\ldots,N\\}$.\nMake a movie showing how $u=\\sum_{j\\in\\If}c_j\\baspsi_j(x)$\napproximates $f(x)$ as $N$ grows. Choose $s$ such that $f$ is\nsteep ($s=20$ may be appropriate).',
  'title': 'Approximate a steep function by sines',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tanh_sines_approx2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:tanh:sine2',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Make a movie where the steepness ($s$) of the $\\tanh$ function in\nExercise ref{fem:approx:exer:tanh:sine1} grows in "time",\nand for each value of the steepness, the movie shows how the\napproximation improves with increasing $N$.',
  'title': 'Animate the approximation of a steep function by sines',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['Fourier_approx.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:Fourier',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Given a function $f(x)$ on an interval $[0,L]$, look up the formula\nfor the coefficients $a_j$ and $b_j$ in the Fourier series of $f$:\n\n!bt\n\\begin{equation*}\nf(x) = a_0 + \\sum_{j=1}^\\infty a_j\\cos \\left(j\\frac{\\pi x}{L}\\right)\n+ \\sum_{j=1}^\\infty b_j\\sin \\left(j\\frac{\\pi x}{L}\\right)\\tp\n\\end{equation*}\n\n!et\n\nLet an infinite-dimensional vector space $V$ have the basis functions\n$\\cos j\\frac{\\pi x}{L}$ for $j=0,1,\\dots,\\infty$ and\n$\\sin j\\frac{\\pi x}{L}$ for $j=1,\\dots,\\infty$.  Show that the least squares\napproximation method from Section ref{fem:approx:global} leads to a\nlinear system whose solution coincides with the standard formulas for\nthe coefficients in a Fourier series of $f(x)$ (see also\nSection ref{fem:approx:global:Fourier}). You may choose\n\n!bt\n\\begin{equation*} \\baspsi_{2i} = \\cos\\left( i\\frac{\\pi}{L}x\\right),\\quad\n\\baspsi_{2i+1} = \\sin\\left( i\\frac{\\pi}{L}x\\right),\\end{equation*}\n\n!et\nfor $i=0,1,\\ldots,N\\rightarrow\\infty$.\n\nChoose $f(x) = \\tanh(s(x-\\half))$ on $\\Omega=[0,1]$, which is\na smooth function, but with considerable steepness around $x=1/2$\nas $s$ grows in size.\nCalculate the coefficients in the Fourier expansion by\nsolving the linear system, arising from the least squares or Galerkin\nmethods, by hand. Plot\nsome truncated versions of the series together with $f(x)$ to show how\nthe series expansion converges for $s=10$ and $s=100$.',
  'title': 'Fourier series as a least squares approximation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tanh_Lagrange.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:tanh',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Use interpolation/collocation with uniformly distributed\npoints and Chebychev nodes to approximate\n\n!bt\n\\begin{equation*} f(x) = -\\tanh(s(x-\\half)),\\quad x\\in [0,1],\\end{equation*}\n\n!et\nby Lagrange polynomials for $s=10$ and $s=100$, and $N=3,6,9,11$.\nMake separate plots of the approximation for each combination of\n$s$, point type (Chebyshev or uniform), and $N$.',
  'title': 'Approximate a steep function by Lagrange polynomials',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['fe_numberings1.py.'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:fe:exer:mesh1',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider a domain $\\Omega =[0,2]$ divided into the three elements\n$[0,1]$, $[1,1.2]$, and $[1.2,2]$, with two nodes in each element\n(P1 elements).\nSet up the list of coordinates and nodes (`nodes`) and the\nnumbers of the nodes that belong to each element (`elements`) in\ntwo cases: 1) nodes and elements numbered from left to right, and 2)\nnodes and elements numbered from right to left.\n\nThereafter, subdivide the element $[1.2,2]$ into two new equal-sized elements.\nAdd the new node and the two new elements to the data structures created above,\nand try to minimize the modifications.',
  'title': 'Define nodes and elements',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['fe_numberings2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:fe:exer:mesh2',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Repeat Exercise ref{fem:approx:fe:exer:mesh1}, but define the\ndata structures `vertices`, `cells`, and `dof_map` instead of\n`nodes` and `elements`.',
  'title': 'Define vertices, cells, and dof maps',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['fe_sparsity_pattern.pdf'],
  'heading': '=====',
  'hints': ['A matrix entry $(i,j)$ is nonzero if $i$ and $j$ are nodes in the\nsame element.'],
  'keywords': None,
  'label': 'fem:approx:fe:exer:defmesh:sparsity',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Exercise ref{fem:approx:fe:exer:mesh1} describes a element mesh\nwith a total of five elements, but with two different element and\nnode orderings. For each of the two orderings,\nmake a $5\\times 5$ matrix and fill in the entries that will be nonzero.',
  'title': 'Construct matrix sparsity patterns',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['sin_approx_P1.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:fe:exer:Asinwt:symbolic',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Perform hand calculations to find formulas for the coefficient matrix\nand right-hand side\nwhen approximating $f(x) = \\sin (x)$ on\n$\\Omega=[0, \\pi]$ by two P1 elements of size $\\pi/2$.\nSolve the system and compare $u(\\pi/2)$ with\nthe exact value 1.\n\n# Hint: wolframalpha or sympy can help with (1-x)*sin(a*x+b),\n# which is the integral\n# that arises on the right-hand side.\n\n#solution:\n#from fe_approx1D_numint import *\n#c = approximate(sm.sin(x), symbolic=True, d=1, N_e=2, numint=None,\n#                Omega=[0,sm.pi])\n#print sm.simplify(c[1,0].subs('h', sm.pi/2))",
  'title': 'Perform symbolic finite element computations',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tanh_fe_P1P2_approx.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:tanh',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Given\n\n!bt\n\\begin{equation*} f(x) = \\tanh(s(x-\\half))\\end{equation*}\n\n!et\nuse the Galerkin or least squares method with finite elements to find\nan approximate function $u(x)$. Choose $s=40$ and try\n$N_e=4,8,16$ P1 elements and\n$N_e=2,4,8$ P2 elements.\nIntegrate $f\\basphi_i$ numerically.',
  'title': 'Approximate a steep function by P1 and P2 elements',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tanh_fe_P3P4_approx.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:exer:tanh2',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Solve Exercise ref{fem:approx:exer:tanh} using $N_e=1,2,4$ P3 and P4\nelements. How will a collocation/interpolation method work in\nthis case with the same number of nodes?',
  'title': 'Approximate a steep function by P3 and P4 elements',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['Asinwt_interpolation_error.py'],
  'heading': '=====',
  'hints': ['Run a series of experiments: $(h_i,E_)$, $i=0,\\ldots,m$, where $E_i$\nis the $L^2$ norm of the error corresponding to element length $h_i$.\nAssume an error model $E=Ch^r$ and compute $r$ from two successive\nexperiments:\n\n212 <<<!!MATH_BLOCK\nHopefully, the sequence $r_0,\\ldots,r_{m-1}$ converges to the true\n$r$, and $r_{m-1}$ can be taken as an approximation to $r$.'],
  'keywords': None,
  'label': 'fem:approx:fe:exer:Asinwt:interpol:error',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The theory (ref{fem:approx:fe:error:theorem}) from\nSection ref{fem:approx:fe:error} predicts that the\nerror in the P$d$ approximation of a function\nshould behave as $h^{d+1}$. Use experiments to verify this\nasymptotic behavior (i.e., for small enough $h$).\nChoose two examples: $f(x)=Ae^{-\\omega x}$ on $[0,3/\\omega]$\nand $f(x) = A\\sin (\\omega x)$ on $\\Omega=[0, 2\\pi/\\omega]$ for\nconstants $A$ and $\\omega$. What happens if you try\n$f(x)=\\sqrt{x}$ on $[0,1]$?',
  'title': 'Investigate the approximation error in finite elements',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['Heaviside_approx_P1P2.py.'],
  'heading': '=====',
  'hints': ['This $f$ can also be expressed in terms of the Heaviside function $H(x)$:\n$f(x) = H(x-\\halfi)$.\nTherefore, $f$ can be defined by\n\n53 <<<!!CODE_BLOCK  pycod\nmaking the `approximate` function in the\n`fe_approx1D.py` module an obvious candidate to solve the\nproblem. However, `sympy` does not handle symbolic integration\nwith this particular integrand, and the `approximate` function faces a problem\nwhen converting `f` to a Python function (for plotting) since\n`Heaviside` is not an available function in `numpy`. It is better to make\nspecial-purpose code for this case or perform all\ncalculations by hand.'],
  'keywords': None,
  'label': 'fem:approx:fe:exer:Heaviside',
  'no': 17,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Approximate the step function\n\n!bt\n\\begin{equation*} f(x) = \\left\\lbrace\\begin{array}{ll}\n1 & x < \\halfi,\\\\ \n2 & x \\geq \\halfi\n\\end{array}\\right.\n\\end{equation*}\n\n!et\nby 2, 4, and 8 P1 and P2 elements. Compare\napproximations visually.',
  'title': 'Approximate a step function by finite elements',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['approx2D_lsorth_sin.py'],
  'heading': '=====',
  'hints': ['Get ideas from the function `least_squares_orth` in\nSection ref{fem:approx:global:orth} and\nfile "`approx1D.py`": "http://tinyurl.com/jvzzcfn/fem/fe_approx1D.py".'],
  'keywords': None,
  'label': 'fem:approx:fe:exer:2Dsines:symbolic',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Assume we have basis functions $\\basphi_i(x,y)$ in 2D that are\northogonal\nsuch that $(\\basphi_i,\\basphi_j)=0$ when $i\\neq j$.\nThe function `least_squares` in the\nfile "`approx2D.py`": "http://tinyurl.com/jvzzcfn/fem/fe_approx2D.py" will then spend much time on computing off-diagonal terms\nin the coefficient matrix that we know are zero.\nTo speed up the computations, make a\nversion `least_squares_orth` that utilizes the orthogonality among the\nbasis functions. Apply the function to approximate\n\n!bt\n\\[ f(x,y) = x(1-x)y(1-y)e^{-x-y}\\]\n\n!et\non $\\Omega = [0,1]\\times [0,1]$ via basis functions\n\n!bt\n\\[ \\basphi_i(x,y) = \\sin (p\\pi x)\\sin(q\\pi y),\\quad i=q N_x + p\n\\tp\n\\]\n\n!et',
  'title': '2D approximation with orthogonal functions',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['fe_trapez.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:fe:exer:1D:trapez',
  'no': 19,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider approximation of some $f(x)$ on an interval $\\Omega$ using\nthe least squares or Galerkin methods with P1 elements. Derive\nthe element matrix and vector using the\nTrapezoidal rule (ref{fem:approx:fe:numint1:trapez}) for calculating\nintegrals on the reference element. Assemble the contributions, assuming\na uniform cell partitioning, and show that the resulting linear system\nhas the form $c_i=f(\\xno{i})$ for $i\\in\\If$.',
  'title': 'Use the Trapezoidal rule and P1 elements',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['P1_vs_interp.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:fe:exer:1D:P1:vs:interp',
  'no': 20,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Sketch $f(x)$ and find the wave length of the function.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'We want to use $N_P$ elements per wave length. Show that the number\nof elements is then $nN_P$.'},
            {'answer': '',
             'file': None,
             'hints': ['Use the `fe_approx1D_numint` module to compute $u$ and use\nthe technique from Section ref{fem:approx:fe:element:impl:error} to\ncompute the norm of the error.'],
             'solution': '',
             'text': 'The critical quantity for accuracy is the number of elements per\nwave length, not the element size in itself. It therefore suffices\nto study an $f$ with just one wave length in $\\Omega = [0,1]$.\nSet $\\epsilon = 0.5$.\n\nRun the least squares or projection/Galerkin method for\n$N_P=2,4,8,16,32$. Compute the error $E=||u-f||_{L^2}$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Repeat the set of experiments in the above point, but\nuse interpolation/collocation based on the node points to\ncompute $u(x)$ (recall that $c_i$ is now simply $f(\\xno{i})$).\nCompute the error $E=||u-f||_{L^2}$.\nWhich method seems to be most accurate?'}],
  'text': 'We shall approximate the function\n\n!bt\n\\[ f(x) = 1 + \\epsilon\\sin (2\\pi nx),\\quad x\\in \\Omega = [0,1],\\]\n\n!et\nwhere $n\\in\\Integer$ and $\\epsilon \\geq 0$.',
  'title': 'Compare P1 elements and interpolation',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['approx3D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'fem:approx:fe:exer:3D:approx3D',
  'no': 21,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Extend the "`approx2D.py`": "http://tinyurl.com/jvzzcfn/fem/approx2D.py" code to 3D\napplying ideas from Section ref{fem:approx:3D:global}.\nUse a 3D generalization of the test problem in Section\nref{fem:approx:2D:global:code} to test the implementation.',
  'title': 'Implement 3D computations with global basis functions',
  'type': 'Exercise',
  'type_visible': True}]