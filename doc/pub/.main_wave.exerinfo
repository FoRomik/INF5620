
# Information about all exercises in the file main_wave.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_wave.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['wave_standing.py'],
  'heading': '=====',
  'hints': ['Import the `solver` function `wave1D_u0_s.py` into a new file\n`wave_standing.py`. Reimplement the `viz` function in this file\nthat plots either the numerical and exact solution, or the error,\ninstead of just the numerical solution.'],
  'keywords': None,
  'label': 'wave:exer:standingwave',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to simulate standing waves on $[0,L]$\nand illustrate the error in the simulation.\nStanding waves arise from an initial condition\n\n!bt\n\\[ u(x,0)= A \\sin\\left(\\frac{pi}{L}mx\\right),\\]\n\n!et\nwhere $m$ is an integer and $A$ is a freely chosen amplitude.\nThe corresponding exact solution can be computed and reads\n\n!bt\n\\[ \\uex(x,t) =  A\\sin\\left(\\frac{\\pi}{L}mx\\right)\n\\cos\\left(\\frac{\\pi}{L}mct\\right)\\ts\n\\]\n\n!et\nMake an animation where you show\nboth the numerical and the exact solution, or the error. It is of\ninterest to see how the error develops in time.',
  'title': 'Simulate a standing wave',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_u0_s_store.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:store:list',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Extend the `plot_u` function in the file `wave1D_u0_s.py` to also store\nthe solutions `u` in a list.\nTo this end, declare `all_u` as\nan empty list in the `viz` function, outside `plot_u`, and perform\nan append operation inside the `plot_u` function. Note that a\nfunction, like `plot_u`, inside another function, like `viz`,\nremembers all local variables in `viz` function, including `all_u`,\neven when `plot_u` is called (as `user_action`) in the `solver` function.\nTest both `all_u.append(u)` and `all_u.append(u.copy())`.\nWhy does one of these constructions fail to store the solution correctly?\nLet the `viz` function return the `all_u` list\nconverted to a two-dimensional `numpy` array.',
  'title': 'Add storage of solution in a user action function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_u0_s2c.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:store:list:class',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Redo Exercise ref{wave:exer:store:list} using a class for the\nuser action function. That is, define a class `Action` where\nthe `all_u` list is an attribute, and implement the user action\nfunction as a method (the special method `__call__` is a natural\nchoice). The class versions avoids that the user action function\ndepends on parameters defined outside the function (such as `all_u`\nin Exercise ref{wave:exer:store:list}).',
  'title': 'Use a class for the user action function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave_numerics_comparison.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:multiple:C',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The goal of this exercise is to make movies where several curves,\ncorresponding to different Courant numbers, are visualized.\nImport the `solver` function from the `wave1D_u0_s` movie\nin a new file `wave_compare.py`. Reimplement the `viz` function\nsuch that it can take a list of `C` values as argument\nand create a movie with solutions corresponding to the given `C`\nvalues. The `plot_u` function must be changed to store the solution\nin an array (see Exercise ref{wave:exer:store:list} or\nref{wave:exer:store:list:class} for details), `solver` must be\ncomputed for each value of the Courant number, and finally\none must run through each time step and plot all the spatial\nsolution curves in one figure and store it in a file.\n\nThe challenge in such a visualization is to ensure that the curves in\none plot corresponds to the same time point. The easiest remedy is to\nkeep the time and space resolution constant and change the wave\nvelocity $c$ to change the Courant number.',
  'title': 'Compare several Courant numbers in one movie',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['mesh_calculus_1D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:mesh1D:calculus',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Define the discrete derivative of $f_i$ by using centered\ndifferences at internal mesh points and one-sided differences\nat the end points. Implement a scalar version of\nthe computation in a Python function and supply a nose test\nfor the linear case $f(x)=4x-2.5$ where the discrete derivative should\nbe exact.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Vectorize the implementation of the discrete derivative.\nExtend the nose test to check the validity of the implementation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'To compute the discrete integral $F_i$ of $f_i$, we assume that\nthe mesh function $f_i$ varies linearly between the mesh points.\nLet $f(x)$ be such a linear interpolant of $f_i$. We then\nhave\n\n!bt\n\\[ F_i = \\int_{x_0}^{x_i} f(x) dx\\ts\\]\n\n!et\nThe exact integral of a piecewise linear function $f(x)$ is\ngiven by the Trapezoidal rule. S\nhow that if $F_{i}$ is already computed, we can find $F_{i+1}$\nfrom\n\n!bt\n\\[ F_{i+1} = F_i + \\frac{1}{2}(f_i + f_{i+1})\\Delta x\\ts\\]\n\n!et\nMake a function for a scalar implementation of the discrete integral\nas a mesh function. That is, the function should return\n$F_i$ for $i=0,\\ldots,N_x$.\nFor a nose test one can use the fact that the above defined\ndiscrete integral of a linear\nfunction (say $f(x)=4x-2.5$) is exact.'},
            {'answer': '',
             'file': None,
             'hints': ['Interpret the recursive formula for $F_{i+1}$ as a sum.\nMake an array with each element of the sum and use the "cumsum"\n(`numpy.cumsum`) operation to compute the accumulative sum:\n`numpy.cumsum([1,3,5])` is `[1,4,9]`.'],
             'solution': '',
             'text': 'Vectorize the implementation of the discrete integral.\nExtend the nose test to check the validity of the implementation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Create a class `MeshCalculus` that can integrate and differentiate\nmesh functions. The class can just define some methods that call\nthe previously implemented Python functions. Here is an example\non the usage:\n\n!bc pycod\nimport numpy as np\ncalc = MeshCalculus(vectorized=True)\nx = np.linspace(0, 1, 11)        # mesh\nf = np.exp(x)                    # mesh function\ndf = calc.differentiate(f, x)    # discrete derivative\nF = calc.integrate(f, x)         # discrete anti-derivative\n\n!ec'}],
  'text': 'This project explores integration and differentiation of\nmesh functions, both with scalar and vectorized implementations.\nWe are given a mesh function $f_i$ on a spatial one-dimensional\nmesh $x_i=i\\Delta x$, $i=0,\\ldots,N_x$, over the interval $[a,b]$.',
  'title': 'Calculus with 1D mesh functions',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': ['One can use the `plug`\nfunction with `C=1` in the program "`wave1D_dn.py`":\n"http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn.py" for simulating such waves.'],
  'keywords': None,
  'label': 'wave:exer:1D:bceffects',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': ['wave1D_split_ic'],
             'hints': [],
             'solution': '',
             'text': 'Demonstrate that the initial profile is split in two\nwaves, with same shape as the initial profile, but half the amplitude.\nThe two waves are traveling to the left and right. Stop the simulation\nbefore the waves hit the boundaries.'},
            {'answer': '',
             'file': ['wave1D_reflecting_bc'],
             'hints': [],
             'solution': '',
             'text': 'Apply $u_x=0$ at both ends. Demonstrate how the waves are reflected\nfrom the boundaries. Run the simulation for two periods, where one\nperiod is the time it takes for the two waves to reflect and come\nback to exactly the initial condition.'},
            {'answer': '',
             'file': ['wave1D_u0_bc'],
             'hints': [],
             'solution': '',
             'text': 'Repeat the previous experiment, but use $u=0$ at both ends.'},
            {'answer': '',
             'file': ['wave1D_mixed_bc'],
             'hints': [],
             'solution': '',
             'text': 'Repeat the previous experiment, but use $u=0$ at one and $u_x=0$\nat the other. Run the simulation for four periods.'}],
  'text': '# Could be a nice video as answer, where all steps are explained.\n\nThe purpose of this exercise is to increase the understanding of\nthe solutions of the wave equation $u_{tt}=c^2u_xx$\nand how boundary conditions,\nespecially $u=0$ versus $u_x=0$, impact the solution.\n\nWe address plug-shaped waves, starting from rest ($u_t=0$)\nat $t=0$.\nThe plug shape means that $u=1$ in some region and $u=0$ outside this\nregion. Present the simulations as movies with the names indicated\n(and a file extension depending on the movie format).',
  'title': 'Explore the effect of boundary conditions',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_symmetric'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:symmetry:bc',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': ['Symmetry of a function about $x=x_0$ means that\n$f(x_0+h) = f(x_0-h)$.'],
             'solution': '',
             'text': 'Consider the simple "plug" wave where $\\Omega = [-L,L]$ and\n\n!bt\n\\begin{equation*} I(x) = \\left\\lbrace\\begin{array}{ll}\n1, & x\\in [-\\delta, \\delta],\\\\ \n0, & \\hbox{otherwise}\n\\end{array}\\right.\n\\end{equation*}\n\n!et\nfor some number $0 < \\delta < L$.\nThe boundary conditions can be set to $u=0$.\nThe solution to this problem is symmetric around $x=0$.\nThis means that we can simulate the wave process in only the half\nof the domain $[0,L]$. Argue why the symmetry boundary condition\nis $u_x=0$ at $x=0$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Perform simulations of the complete wave problem from\non $[-L,L]$. Thereafter, utilize the\nsymmetry of the solution and run a simulation\nin half of the domain $[0,L]$, using a boundary condition\nat $x=0$. Compare the two solutions and\nmake sure that they are the same.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Prove the symmetry property of the solution\nby setting up the complete initial-boundary value problem\nand showing that if $u(x,t)$ is a solution, then also $u(-x,t)$\nis a solution.'}],
  'text': '',
  'title': 'Explore symmetry boundary conditions',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['pulse1D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:pulse1D',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Use the `pulse` function in `wave1D_dn_vc.py` to investigate\nsending a pulse, located with its peak at $x=0$, through the\nmedium to the right where it hits another medium for $x\\in [0.7,0.9]$\nwhere the wave velocity is decreased by a factor $s_f$.\nReport what happens with a Gaussian pulse, a "cosinehat" pulse,\nhalf a "cosinehat" pulse, and a plug pulse for resolutions\n$N_x=40,80,160$, and $s_f=2,4$. Make a reference solution in\nthe homogeneous case too with $s_f=1$ and $N_x=40$. Use $C=1$\nin the medium outside $[0.7,0.9]$. Simulate until $T=2$.',
  'title': 'Send pulse waves through a layered medium',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Perform numerical experiments and find the convergence rate of the\nerror using\nthe approximation\nand (ref{wave:pde2:var:c:scheme:impl:Neumann2}).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "Switch to $q(x)=\\cos(\\pi x/L)$, which symmetric at $x=0,L$,\nand check the convergence rate\nof the scheme\n(ref{wave:pde2:var:c:scheme:impl:Neumann2}). Now,\n$q_{i-1/2}$ is a 2nd-order approximation to $q_i$,\n$q_{i-1/2}=q_i + 0.25q_i''\\Delta x^2 + \\cdots$, because $q_i'=0$\nfor $i=N_x$ (a similar argument can be applied to the case $i=0$)."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'A third discretization can be based on a simple and convenient,\nbut less accurate, one-sided difference:\n$u_{i}-u_{i-1}=0$ at $i=N_x$ and $u_{i+1}-u_i=0$ at $i=0$.\nDerive the resulting scheme in detail and implement it.\nRun experiments to establish the rate of convergence.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'A fourth technique is to view the scheme as\n\n!bt\n\\[ [D_tD_tu]^n_i = [qD_xu]_{i+\\frac{1}{2}}^n - [qD_xu]_{i-\\frac{1}{2}}^n\n+ [f]_i^n,\\]\n\n!et\nand place the boundary at $x_{i+\\frac{1}{2}}$, $i=N_x$, instead of\nexactly at the physical boundary. With this idea,\nwe can just set $[qD_xu]_{i+\\frac{1}{2}}^n=0$. Derive the complete scheme\nusing this technique. The implementation of the boundary condition at\n$L-\\Delta x/2$ is $\\Oof{\\Delta x^2}$ accurate, but the interesting question\nis what impact the movement of the boundary has on the convergence\nrate (compute the errors as usual over the entire mesh).'}],
  'text': 'We have a 1D wave equation with variable wave velocity:\n$u_t=(qu_x)_x$.\nA Neumann condition $u_x$ at $x=0, L$ can be\ndiscretized as shown in (ref{wave:pde2:var:c:scheme:impl:Neumann})\nand (ref{wave:pde2:var:c:scheme:impl:Neumann2}).\n\nThe aim of this exercise is to examine the rate of the numerical\nerror when using different ways of discretizing the Neumann condition.\nAs test problem, $q=1+(x-L/2)^4$ can be used, with $f(x,t)$\nadapted such that the solution has a simple form, say\n$u(x,t)=\\cos (\\pi x/L)\\cos (\\omega t)$ for some $\\omega = \\sqrt{q}\\pi/L$.',
  'title': 'Compare discretizations of a Neumann condition',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['mesh_calculus_3D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:mesh3D:calculus',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The goal of this project is to redo\nProject ref{wave:exer:mesh1D:calculus} with 2D and 3D\nmesh functions ($f_{i,j}$ and $_{fi,j,k}$).\n\n__Differentiation.__\nThe differentiation results in a discrete gradient\nfunction, which in the 2D case can be represented by a three-dimensional\narray `df[d,i,j]` where `d` represents the direction of\nthe derivative and `i` and `j` are mesh point counters in 2D\n(the 3D counterpart is `df[d,i,j,k]`).\n\n__Integration.__\nThe integral of a 2D mesh function $f_{i,j}$ is defined as\n\n!bt\n\\[ F_{i,j} = \\int_{y_0}^{y_j} \\int_{x_0}^{x_i} f(x,y)dxdy,\\]\n\n!et\nwhere $f(x,y)$ is a function that takes on the values of the\ndiscrete mesh function $f_{i,j}$ at the mesh points, but can also\nbe evaluated in between the mesh points. The particular variation\nbetween mesh points can be taken as bilinear, but this is not\nimportant as we will use a product Trapezoidal rule to approximate\nthe integral over a cell in the mesh and then we only need to\nevaluate $f(x,y)$ at the mesh points.\n\nSuppose $F_{i,j}$ is computed. The calculation of $F_{i+1,j}$\nis then\n\n!bt\n\\begin{align*}\nF_{i+1,j} &= F_{i,j} + \\int_{x_i}^{x_{i+1}}\\int_{y_0}^{y_j} f(x,y)dydx\\\\ \n&\\approx \\Delta x \\int_{y_0}^{y_j} f(x_{i+\\frac{1}{2}},y)dy\\\\ \n& \\approx \\Delta x \\frac{1}{2}\\left(\n\\int_{y_0}^{y_j} f(x_{i},y)dy\n+ \\int_{y_0}^{y_j} f(x_{i+1},y)dy\\right)\n\\end{align*}\n\n!et\nThe integrals in the $y$ direction can be approximated by a Trapezoidal\nrule. A similar idea can be used to compute $F_{i,j+1}$. Thereafter,\n$F_{i+1,j+1}$ can be computed by adding the integral over the final\ncorner cell to $F_{i+1,j} + F_{i,j+1} - F_{i,j}$. Carry out the\ndetails of these computations and extend the ideas to 3D.',
  'title': 'Calculus with 2D/3D mesh functions',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_u0_sv_discont.py'],
  'heading': '=====',
  'hints': ['Section ref{wave:app:string}\nexplains how the density enters the mathematical model. Modify the\n`wave1D_u0_sv.py` code to incorporate the tension and a function\nspecifying the density.'],
  'keywords': None,
  'label': 'wave:app:exer:string:discont',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Simulate waves on a string that consists of two materials with\ndifferent density. The tension in the string is constant, but the\ndensity has a jump at the boundary between the materials.\nExperiment\nwith different sizes of the jump to derive a couple of demonstrations\nthat visualizes the effect on the waves of having a two-material\nstring.',
  'title': 'Simulate waves on a non-homogeneous string',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_u0_sv_damping.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:string:damping',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Formulate a mathematical model for damped waves on a string.\nUse data from Section ref{wave:pde1:guitar:data}, and\ntune the damping parameter so that the string is very close to\nthe rest state after 15 s. Make a movie of the wave motion.',
  'title': 'Simulate damped waves on a string',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave_rod.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:rod',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'A hammer hits the end of an elastic rod. The exercise is to simulate\nthe resulting wave motion using the model (ref{wave:app:elastic:rod:eq})\nfrom Section ref{wave:app:elastic:rod}. Let the rod have length\n$L$ and let the boundary $x=L$ be stress free so that $\\sigma_{xx}=0$,\nimplying that $\\partial u/\\partial x=0$. The left end $x=0$ is\nsubject to a strong stress pulse (the hammer), modeled as\n\n!bt\n\\[ \\sigma_{xx}(t) = \\left\\lbrace\\begin{array}{ll}\nS,& 0 < t \\leq t_s,\\\\ \n0, & t > t_s\n\\end{array}\\right.\n\\]\n\n!et\nThe corresponding condition on $u$ becomes $u_x= S/E$\nfor $t\\leq t_s$ and zero afterwards (recall that\n$\\sigma_{xx} = Eu_x$). This is a non-homogeneous\nNeumann condition, and you will need to approximate this condition\nand combine it with the scheme (the ideas and manipulations follow\nclosely the handling of a non-zero initial condition\n$u_t=V$ in wave PDEs or the corresponding\nsecond-order ODEs for vibrations).',
  'title': 'Simulate elastic waves in a rod',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['pulse1D_analysis.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:pulse1D:analysis',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The experiments performed in Exercise ref{wave:app:exer:pulse1D} shows\nconsiderable numerical noise in the form of non-physical waves,\nespecially for $s_f=4$ and the plug pulse or the half a "cosinehat"\npulse. The noise is much less visible for a Gaussian pulse. Run the\ncase with the plug and half a "cosinehat" pulses for $s_f=1$, $C=0.9,\n0.25$, and $N_x=40,80,160$. Use the numerical dispersion relation to\nexplain the observations.',
  'title': 'Explain why numerical noise occurs',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['pulse1D_harmonic.pdf', 'pulse1D_harmonic.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:pulse1D:harmonic',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Will harmonic averaging of the wave velocity give better numerical\nresults for the case $s_f=4$ in Exercise ref{wave:app:exer:pulse1D}?',
  'title': 'Investigate harmonic averaging in a 1D model',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave3D_u0.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:3D:f77:cy:efficiency',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Extend the `wave2D_u0.py` code and the Cython, Fortran, and C versions to 3D.\nSet up an efficiency experiment to determine the relative efficiency of\npure scalar Python code, vectorized code, Cython-compiled loops,\nFortran-compiled loops, and C-compiled loops.\nNormalize the CPU time for each mesh by the fastest version.',
  'title': 'Test the efficiency of compiled loops in 3D',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami1D_flat.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami1D',
  'no': 17,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'A subsea earthquake leads to an immediate lift of the surface, see\nFigure ref{wave:app:fig:1D:tsunami:flat}. The initial surface shape $I(x)$ is symmetric\naround $x=0$ and will split into two tsunamis, one traveling to the right\nand one to the left, as depicted in Figure ref{wave:app:fig:1D:tsunami:2waves}.\nSince the water surface will remain symmetric with respect to $x=0$, given that\nthe outgoing wave to the left does not come back due to reflection,\nwe insert a boundary $x=0$ and impose a symmetry condition there: $\\partial\\eta\\ \n\\partial x =0$, where $\\eta(x,t)$ is the elevation of the water surface.\nWe are not interested in what happens with the right-going wave after\nit hits the right boundary, so whether we impose\n$\\eta =0$ or $\\partial\\eta /\\partial x=0$ at that boundary is not of importance.\n\nThe shape of the initial surface can be taken as a\nGaussian function,\n\n!bt\n\\begin{equation}\nI(x;I_0,I_a,I_m,I_s) =\nI_0 + I_a\\exp{\\left(-\\left(\\frac{x-I_m}{I_s}\\right)^2\\right)},\n\\end{equation}\n\n!et\nwith $I_m=0$ reflecting the location of the peak of $I(x)$ and\n$I_s$ being a measure of the width of the function $I(x)$\n($I_s$ is $\\sqrt{2}$ times the standard deviation of the familiar\nnormal distribution curve).\n\nSet up the relevant one-dimensional, linear, wave equation for $\\eta$,\nassuming long waves of small amplitude in comparison with the depth,\nas described in Section ref{wave:app:sw:2D}. Import the `viz` method\nfrom the `wave1D.py` program and make a call to it to solve the\npresent tsunami problem.  The constant speed of the right-going wave is\n$c=\\sqrt{gH}$ and use this quantity to determine a suitable time $T$\nfor when the wave hits the right boundary and the simulation is to be\nstopped. An alternative is to check in `plot_u` if $u[-2]$ is\nsignificantly different from 0 and then return `True` to stop\nthe simulation.\n\nFIGURE: [fig-wave/earthquake_tsunami_flat, width=800, frac=1.2] Sketch of initial water surface due to a subsea earthquake. label{wave:app:fig:1D:tsunami:flat}\n\nFIGURE: [fig-wave/earthquake_tsunami_2waves, width=800, frac=1.2] An initial surface elevation is split into two waves. label{wave:app:fig:1D:tsunami:2waves}',
  'title': 'Earthquake-generated tsunami in a 1D model',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_Ropen.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami1D:radiation',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'idx{radiation condition}\nidx{open boundary condition}\n\nTo enable the right-going wave in Exercise ref{wave:app:exer:tsunami1D}\nto leave the computational domain and travel undisturbed through\nthe boundary, one can in a one-dimensional problem impose the\nfollowing condition, called a *radiation condition* or\n*open boundary condition*:\n\n!bt\n\\begin{equation}\n\\frac{\\partial\\eta}{\\partial t} + c\\frac{\\partial\\eta}{\\partial x} = 0,\nlabel{wave:app:exer:tsunami1D:radiation:eq}\n\\end{equation}\n\n!et\nat the right boundary $x=x_R$. The parameter $c$ is the wave velocity,\nwhich for the model in Exercise ref{wave:app:exer:tsunami1D}\nis $c=\\sqrt{gH(x_R)}$.\n\nShow that (ref{wave:app:exer:tsunami1D:radiation:eq}) accepts\na solution $\\eta = g_R(x-ct)$, but not $\\eta = g_L(x+ct)$. This means\nthat (ref{wave:app:exer:tsunami1D:radiation:eq}) will allow any\nright-going wave $g_R(x-ct)$ pass through the boundary.\n\nThe condition (ref{wave:app:exer:tsunami1D:radiation:eq}) can be\ndiscretized by centered differences at the spatial end point $i=N_x$,\ncorresponding to $x=x_R$:\n\n!bt\n\\begin{equation}\n[D_{2t}\\eta + cD_{2x}\\eta =0]^n_{N_x}\nlabel{wave:app:exer:tsunami1D:radiation:eq:op}\n\\thinspace .\n\\end{equation}\n\n!et\nEliminate the fictitious value $\\eta_{N_x+1}^n$ by using\nthe discrete equation at the same point $(n,N_x)$.\nThe equation for the first step, $\\eta_i^1$, is in principal affected,\nbut we can then use the condition $\\eta^1_{N_x}=0$ since the wave\nhas not yet reached the right boundary.\n\nModify the `solver` function in the `wave1D.py` program to\nincorporate the condition (ref{wave:app:exer:tsunami1D:radiation:eq:op}).\nDemonstrate that the tsunami travels through the domain and out of\nthe right boundary without leaving any reflections behind.\nMake a nose test for checking that after a certain time $T$, the surface is\nflat.\n\n__Remark 1.__ The condition (ref{wave:app:exer:tsunami1D:radiation:eq})\nworks perfectly in 1D when $c$ is known. In 2D and 3D, however, the\ncondition reads $\\eta_t + c_x\\eta_x + c_y\\eta_y=0$, where $c_x$ and\n$c_y$ are the wave speeds in the $x$ and $y$ directions, and estimating\nthese components (i.e., the direction of the wave) is often\nchallenging. Other methods are normally used in 2D and 3D to\nlet waves move out of a computational domain.\n\n__Remark 2.__ A radiation or open boundary condition at the left\nboundary takes the same form as (ref{wave:app:exer:tsunami1D:radiation:eq}),\nexcept that there is a minus sign in front of the $c\\eta_x$\nterm. One can easily show that with this sign, the condition accepts\nleft-going waves of the form $\\eta = g_L(x+ct)$.',
  'title': 'Implement an open boundary condition',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami1D_hill.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami1D:hill',
  'no': 19,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the same problem as in Exercise\nref{wave:app:exer:tsunami1D}, but now there is a hill at the sea\nbottom, see Figure ref{wave:app:fig:1D:tsunami:hill}. The wave speed\n$c=\\sqrt{gH(x)} = \\sqrt{g(H_0-B(x))}$ will then be reduced in the\nshallow water above the hill.\n\nFIGURE: [fig-wave/earthquake_tsunami_hill, width=800, frac=1.2] Sketch of an earthquake-generated tsunami passing over a subsea hill. label{wave:app:fig:1D:tsunami:hill}\n\nOne possible form of the\nhill is a Gaussian function,\n\n!bt\n\\begin{equation}\nB(x;B_0,B_a,B_m,B_s) =\nB_0 + B_a\\exp{\\left(-\\left(\\frac{x-B_m}{B_s}\\right)^2\\right)},\nlabel{wave:app:exer:tsunami1D:hill:Gauss}\n\\end{equation}\n\n!et\nbut many other shapes are also possible, e.g., a "cosine hat" where\n\n!bt\n\\begin{equation}\nB(x; B_0, B_a, B_m, B_s) = B_0 + B_a\\cos{\\left( \\pi\\frac{x-B_m}{2B_s}\\right)},\nlabel{wave:app:exer:tsunami1D:hill:cohat}\n\\end{equation}\n\n!et\nwhen $x\\in [B_m - B_s, B_m + B_s]$ while $B=B_0$ outside this\ninterval.\n\nAlso an abrupt construction may be tried:\n!bt\n\\begin{equation}\nB(x; B_0, B_a, B_m, B_s) = B_0 + B_a,\nlabel{wave:app:exer:tsunami1D:hill:box}\n\\end{equation}\n\n!et\nfor $x\\in [B_m - B_s, B_m + B_s]$ while $B=B_0$ outside this\ninterval.\n\n\nVisualize both the bottom topography and the\nwater surface elevation (this requires modifying `plot_u`).\nAllow for a flexible choice of bottom shape,\n(ref{wave:app:exer:tsunami1D:hill:Gauss}),\n(ref{wave:app:exer:tsunami1D:hill:cohat}),\n(ref{wave:app:exer:tsunami1D:hill:box}), or $B(x)=B_0$ (flat)\nand see if the waves become\nqualitatively different. Also investigate the amount of numerical\nnoise that is triggered by rapid changes in the bottom function\nand a small water gap at the top of the hill, and how this noise\nvaries with the mesh resolution $\\Delta x$.\nUse either the open boundary condition from\nExercise ref{wave:app:exer:tsunami1D:radiation}, or set $\\eta =0$ at\nthe right boundary and stop the simulation when the wave hits this\nboundary.',
  'title': 'Earthquake-generated tsunami over a subsea hill',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave2D_n.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:wave2D:Neumann',
  'no': 20,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Modify the "`wave2D_u0.py`":\n"/wave2D_u0/wave2D_u0.py"\nprogram, which solves the 2D wave equation $u_{tt}=c^2(u_{xx}+u_{yy})$\nwith constant wave velocity $c$ and $u=0$ on the boundary, to have\nNeumann boundary conditions: $\\partial u/\\partial n=0$.\nInclude both scalar code (for debugging and reference) and\nvectorized code (for speed).\n\nTo test the code, use $u=1.2$ as solution ($I(x,y)=1.2$, $V=f=0$, and\n$c$ arbitrary), which should be exactly reproduced with any mesh\nas long as the stability criterion is satisfied.\nAnother test is to use the plug-shaped pulse\nin the `pulse` function from Section ref{wave:pde2:software}\nand the "`wave1D_dn_vc.py`": "http://tinyurl.com/jvzzcfn/wave/wave1D_dn_vc.py"\nprogram. This pulse\nis exactly propagated in 1D if $c\\Delta t/\\Delta x=1$. Check\nthat also the 2D program can propagate this pulse exactly\nin $x$ direction ($c\\Delta t/\\Delta x=1$, $\\Delta y$ arbitrary)\nand $y$ direction ($c\\Delta t/\\Delta y=1$, $\\Delta x$ arbitrary).',
  'title': 'Implement Neumann conditions in 2D',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave2D_n2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 21,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Use the following manufactured solution to verify a 2D code\nfor $u_{tt}=c^2(u_{xx}+u_{yy})$ in the spatial domain\n$[0,L_x]\\times [0,L_y]$, with $\\partial u/\\partial n$ on the boundary\n(cf. Exercise ref{wave:app:exer:wave2D:Neumann}):\n\n!bt\n\\begin{equation}\n\\uex(x,y,t)=\\cos(m_xx\\pi/L_x)\\cos(m_yy\\pi/L_y)\\cos (\\omega t),\nlabel{wave:app:exer:standing:waves}\n\\end{equation}\n\n!et\nHere, $m_x$ and $m_y$ are freely chosen integers such that\nthe wave lengths in the $x$ and $y$ directions become $2L_x/m_x$ and\n$2L_y/m_y$, respectively. The parameter $\\omega$ is calculated\nby inserting (ref{wave:app:exer:standing:waves}) in the wave equation.\nThe solution\n(ref{wave:app:exer:standing:waves}) is a *standing wave*\nwith $\\partial u/\\partial n=0$.\nThis $\\uex$ is not an exact solution of the discrete equations so the\ntest must be based on empirical analysis of the convergence.\nThe error $E$ is assumed to behave like\n\n!bt\n\\[\nE = C_t\\Delta t^2 + C_x\\Delta x^2 + C_y\\Delta y^2,\n\\]\n\n!et\nfor some constants $C_t$, $C_x$, and $C_y$.\nChoose $\\Delta t=F_th$, $\\Delta x =F_xh$, and $\\Delta y=F_yh$, where\n$h$ is a common discretization parameter to be varied ($h\\rightarrow 0$)\nand $F_t$, $F_x$, and $F_y$ are freely chosen constant factors\ncompatible with the stability criterion in 2D. The error can then\nbe expressed as\n\n!bt\n\\[\nE = Ch^2,\n\\]\n\n!et\nwhere $C=C_xF_t^2 + C_yF_x^2 + C_tF_t^2$.\nPerform experiments with decreasing $h$, compute $E$, and verify that\n$E/h^2$ is approximately constant.',
  'title': 'Implement a convergence test for a 2D code',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami2D_hill.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami2D:hill',
  'no': 22,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'This exercise extends Exercise ref{wave:app:exer:tsunami1D:hill}\nto a three-dimensional wave phenomenon, governed by the 2D PDE\n(ref{wave:app:sw:2D:eta:2ndoeq}). We assume that the earthquake\narise from a fault along the line $x=0$ in the $xy$-plane so that\nthe initial lift of the surface can be taken as $I(x)$ in\nExercise ref{wave:app:exer:tsunami1D:hill}. That is, a plan wave is\npropagating to the right, but will experience bending because of\nthe bottom.\n\nThe bottom shape is now a function of $x$ and $y$.\nAn "elliptic" Gauss function in two dimensions, with its peak\nat $(B_{mx}, B_{my})$, generalizes\n(ref{wave:app:exer:tsunami1D:hill:Gauss}):\n\n!bt\n\\begin{equation}\nB(x;B_0,B_a,B_{mx}, B_{my} ,B_s, b) =\nB_0 + B_a\\exp{\\left(-\\left(\\frac{x-B_{mx}}{B_s}\\right)^2\n-\\left(\\frac{y-B_{my}}{bB_s}\\right)^2\\right)},\nlabel{wave:app:exer:tsunami2D:hill:Gauss}\n\\end{equation}\n\n!et\nwhere $b$ is a scaling parameter: $b=1$ gives a circular Gaussian\nfunction with circular contour lines, while $b\\neq 1$ gives an elliptic\nshape with elliptic contour lines.\n\nThe "cosine hat" (ref{wave:app:exer:tsunami1D:hill:cohat}) can also be\ngeneralized to\n\n!bt\n\\begin{equation}\nB(x; B_0, B_a, B_{mx}, B_{my}, B_s) =\nB_0 + B_a\\cos{\\left( \\pi\\frac{x-B_{mx}}{2B_s}\\right)}\n\\cos{\\left( \\pi\\frac{y-B_{my}}{2B_s}\\right)},\nlabel{wave:app:exer:tsunami2D:hill:cohat}\n\\end{equation}\n\n!et\nwhen $0 \\leq \\sqrt{x^2+y^2} \\leq B_s$ and $B=B_0$ outside this circle.\n\nA box-shaped obstacle means that\n!bt\n\\begin{equation}\nB(x; B_0, B_a, B_m, B_s, b) = B_0 + B_a\nlabel{wave:app:exer:tsunami2D:hill:box}\n\\end{equation}\n\n!et\nfor $x$ and $y$ inside a rectangle\n!bt\n\\[ B_{mx}-B_s \\leq  x \\leq B_{mx} + B_s,\\quad\nB_{my}-bB_s \\leq  y \\leq B_{my} + bB_s,\n\\]\n\n!et\nand $B=B_0$ outside this rectangle.\nThe $b$ parameter controls the rectangular shape of the cross section of\nthe box.\n\nNote that the initial condition and the listed bottom shapes are\nsymmetric around the line $y=B_{my}$. We therefore expect the\nsurface elevation also to be symmetric with respect to this line.\nThis means that we can halve the computational domain by working\nwith  $[0,L_x]\\times [0, B_{my}]$. Along the upper boundary, $y=B_{my}$,\nwe must impose the symmetry condition $\\partial \\eta/\\partial n=0$.\nSuch a symmetry condition ($-\\eta_x=0$)\nis also needed at the $x=0$ boundary because\nthe initial condition has a symmetry here. At the lower boundary\n$y=0$ we also set a Neumann condition (which becomes $-\\eta_y=0$).\nAt the right boundary $x=L_x$\none can either implement a radiation (or open boundary) condition\nas in Exercise ref{wave:app:exer:tsunami1D:radiation} or just set\n$\\eta = 0$ or use a reflecting condition $\\partial\\eta/\\partial n\n=\\eta_x =0$.\n\nVisualize the surface elevation.  Investigate how different hill shapes,\ndifferent sizes of the water gap above the hill, and different\nresolutions $\\Delta x$ and $\\Delta t$ influence\nthe numerical quality of the solution.',
  'title': 'Earthquake-generated tsunami over a 3D hill',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami3D_hill_compiled.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami2D:hill:compiled',
  'no': 23,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Extend the program from Exercise ref{wave:app:exer:tsunami2D:hill} such\nthat the loops over mesh points, inside the time loop, are\nimplemented in compiled languages.\nConsider implementations in\nCython, Fortran via `f2py`, C via Cython, C via `f2py`, C/C++ via Instant,\nand C/C++ via `scipy.weave`.\nPerform efficiency experiments to investigate the relative performance\nof the various implementations. It is often advantageous to normalize\nCPU times by the fastest method on a given mesh.',
  'title': 'Implement loops in compiled languages',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami3D_hill.f'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami2D:hill:compiled2',
  'no': 24,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'As an extension of Exercise ref{wave:app:exer:tsunami2D:hill:compiled2},\nwrite the whole `tsunami3D_hill.py` code in Fortran, C, or C++ to check\nif there is more to be won with respect to efficiency in large-scale\nproblems. This exercise will also illustrate the difference in\nprogram development with Fortran/C/C++ and Python.',
  'title': 'Write a complete program in Fortran or C',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami2D_hill_mpl.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami:hill:viz:matplotlib',
  'no': 25,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Play with native Matplotlib code for visualizing 2D\nsolutions of the wave equation with variable wave velocity.\nSee if there\nare effective ways to visualize both the solution and the wave\nvelocity.',
  'title': 'Investigate Matplotlib for visualization',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami2D_hill_mayavi.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami:hill:viz:packages',
  'no': 26,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Explore one or more of the programs below\nfor visualizing solutions of 2D or 3D wave equations with variable\nwave velocity. Try to visualize\nboth the solution and the wave velocity in the same plot.\n\n  * "Mayavi": "http://code.enthought.com/projects/mayavi/"\n  * "Paraview": "http://www.paraview.org/"\n  * "OpenDX": "http://www.opendx.org/"',
  'title': 'Investigate visualization packages',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami2D_hill_harmonic.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami:hill:harmonic',
  'no': 27,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'In Exercise ref{wave:app:exer:tsunami1D:hill}, investigate if\nthere is significant difference between the harmonic mean\n(ref{wave:pde2:var:c:mean:harmonic}) and the standard\narithmetic mean (ref{wave:pde2:var:c:mean:arithmetic}).\nUse extreme cases for the investigations where the subsea hill is\nclose to the flat surface. Pay particular attention to the\nbox-shaped obstruction (ref{wave:app:exer:tsunami1D:hill:box}) since\nit has discontinuities.\n\nRepeat the investigations for the case of a box-shaped obstruction\nin the 2D model from Exercise ref{wave:app:exer:tsunami2D:hill}.\n\n__Remark.__ With a small gap between the obstruction and the free surface,\nand with abrupt changes in the bottom shape, the model PDE does not\nnecessarily describe the wave motion in an accurate or qualitatively correct\nway.',
  'title': 'Investigate harmonic vs arithmetic mean',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['seismic2D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:seismic2D',
  'no': 28,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "The goal of this exercise is to simulate seismic waves using the\nPDE model (ref{wave:app:acoustic:seismic:accoustic1a}) in a\n2D $xz$ domain with geological layers.\nIntroduce $m$ horizontal layers of thickness $h_i$, $i=0,\\ldots,m-1$.\nInside layer number $i$ we have a vertical wave velocity $c_{z,i}$\nand a horizontal wave velocity $c_{h,i}$. Make a program\nfor simulating such 2D waves. Test it on a case with 3 layers where\n\n!bt\n\\[ c_{z,0}=c_{z,1}=c_{z,2},\\quad c_{h,0}=c_{h,2},\\quad c_{h,1} \\ll c_{h,0}\n\\thinspace .\n\\]\n\n!et\nLet $s$ be a localized point source at the middle of the Earth's surface\n(the upper boundary)\nand investigate how the resulting wave travels through the medium.\nThe source can be a localized Gaussian peak that oscillates in\ntime for some time interval.\nPlace the boundaries far enough from the expanding wave so that the\nboundary conditions do not disturb the wave. Then the type of\nboundary condition does not matter, except that we physically need\nto have $p=p_0$, where $p_0$ is the atmospheric pressure,\nat the upper boundary.",
  'title': 'Simulate seismic waves in 2D',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['acoustics.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:acoustics',
  'no': 29,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The equation for sound waves in air is derived in Section ref{wave:app:sound}\nand reads\n\n!bt\n\\[ p_{tt} = c^2\\nabla^2 p,\\]\n\n!et\nwhere $p(x,y,z,t)$ is the pressure and $c$\nis the speed of sound, taken as 340 m/s.\n#air at a room temperature 20 C, $p_0$ is reference pressure in the\n#air, typically 1 atm (approximately $10^5$ Pa), and $\\varrho_0$ is\n#the density of air, taken as $1.225\\mbox{ kg/m}^3$.\nHowever, sound is absorbed in the air due to relaxation of molecules\nin the gas. A model for simple relaxation, valid for gases consisting\nonly of one type of molecules, is a term $c^2\\tau_s\\nabla^2 p_t$ in\nthe PDE, where $\\tau_s$ is the relaxation time. If we generate sound\nfrom, e.g., a loudspeaker in the room, this sound source must also\nbe added to the governing equation.\n\nThe PDE with the mentioned type of damping and source then becomes\n\n!bt\n\\begin{equation}\np_tt = c^2\\nabla^p + c^2\\tau_s\\nabla^2 p_t + f,\n\\end{equation}\n\n!et\nwhere $f(x,y,z,t)$ is the source term.\n\nThe walls can absorb some sound. A possible model is to have a "wall layer"\n(thicker than the physical wall)\noutside the room where $c$ is changed such that some of the wave energy\nis reflected and some is absorbed in the wall. The absorption of\nenergy can be taken care of by adding a damping term $bp_t$ in\nthe equation:\n\n!bt\n\\begin{equation}\np_tt + bp_t = c^2\\nabla^p + c^2\\tau_s\\nabla^2 p_t + f\\ts\n\\end{equation}\n\n!et\nTypically, $b=0$ in the room and $b>0$ in the wall. A discontinuity in $b$\nor $c$ will give rise to reflections. It can be wise to use a constant\n$c$ in the wall to control reflections because of the discontinuity between\n$c$ in the air and in the wall, while $b$ is gradually increased\nas we go into the wall to avoid reflections because of rapid changes in $b$.\nAt the outer boundary of the wall the condition $p=0$ or $\\partial p/\\partial n=0$ can be imposed. The waves should anyway be approximately dampened\nto $p=0$ this far out in the wall layer.\n\nThere are two strategies for discretizing the $\\nabla^2 p_t$ term: using\na center difference between times $n+1$ and $n-1$ (if the equation is\nsampled at level $n$), or use a one-sided difference based on levels $n$\nand $n-1$. The latter has the advantage of not leading to any equation system,\nwhile the former is second-order accurate as the scheme for the\nsimple wave equation $p_tt = c^2\\nabla^2 p$. To avoid an equation system,\ngo for the one-sided difference such that the overall scheme becomes\nexplicit and only of first order in time.\n\nDevelop a 3D solver for the specified PDE and introduce a wall layer.\nTest the solver with the method of manufactured solutions. Make some\ndemonstrations where the wall reflects and absorbs the waves (reflection\nbecause of discontinuity in $b$ and absorption because of growing $b$).\nExperiment with the impact of the $\\tau_s$ parameter.',
  'title': 'Modeling 3D acoustic waves in a room',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['advec1D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:advec1D',
  'no': 30,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that under the assumption of $a=\\hbox{const}$,\n\n!bt\n\\begin{equation}\nu(x,t) = I(x - ct)\nlabel{wave:app:exer:advec1D:uexact}\n\\end{equation}\n\n!et\nfulfills the PDE as well as the initial and boundary condition\n(provided $I(0)=I(L)$).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up a computational algorithm and implement it in a function.\nAssume $a$ is constant and positive.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Test implementation by using the remarkable property that\nthe numerical solution is exact at the mesh points if\n$\\Delta t = c^{-1}\\Delta x$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Make a movie comparing the numerical and exact solution for the\nfollowing two choices of initial conditions:\n\n!bt\n\\begin{equation}\n I(x) = \\left\\lbrack\\sin\\left(\\pi\\frac{x}{L}\\right)\\right\\rbrack^{2n}\nlabel{wave:app:exer:advec1D:I:sin}\n\\end{equation}\n\n!et\nwhere $n$ is an integer, typically $n=5$,\nand\n\n!bt\n\\begin{equation}\nI(x) = \\exp{\\left( -\\frac{(x-L/2)^2}{2\\sigma2}\\right)} \\thinspace .\n\\end{equation}\nlabel{wave:app:exer:advec1D:I:gauss}\n\n!et\nChoose $\\Delta t = c^{-1}\\Delta x, 0.9c^{-1}\\Delta x, 0.5c^{-1}\\Delta x$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The performance of the suggested numerical scheme can be investigated\nby analyzing the numerical dispersion relation.\nAnalytically, we have that the *Fourier component*\n\n!bt\n\\[ u(x,t) = e^{i(kx-\\omega t)},\\]\n\n!et\nis a solution of the PDE if $\\omega = kc$. This is the *analytical\ndispersion relation*. A complete solution of the PDE can be built by\nadding up such Fourier components with different amplitudes, where the\ninitial condition $I$ determines the amplitudes. The solution $u$ is\nthen represented by a Fourier series.\n\nA similar discrete Fourier component at $(x_p,t_n)$ is\n\n!bt\n\\[ u_p^q = e^{i(kp\\Delta x -\\tilde\\omega n\\Delta t)},\\]\n\n!et\nwhere in general $\\tilde\\omega$ is a function of $k$, $\\Delta t$, and\n$\\Delta x$, and differs from the exact $\\omega =kc$.\n\nInsert the discrete Fourier component in the numerical scheme and\nderive an expression for $\\tilde\\omega$, i.e.,\nthe discrete dispersion relation. Show in particular that if\nthe $\\Delta t/(c\\Delta x)=1$, the discrete solution coincides with the\nexact solution at the mesh points, regardless of the mesh resolution (!).\nShow that if the stability condition\n\n!bt\n\\[ \\frac{\\Delta t}{c\\Delta x}\\leq 1,\\]\n\n!et\nthe discrete Fourier component cannot grow (i.e., $\\tilde\\omega$ is real).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a test for your implementation where you try to use information\nfrom the numerical dispersion relation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up a computational algorithm for the variable\ncoefficient case and implement it in a function.\nMake a test that the function works for constant $a$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "Let $\\xi = C(x) - t$.\nWe have that\n!bt\n\\[ u_t = f'(\\xi)(-1),\\]\n\n!et\nwhile\n!bt\n\\[ u_x = f'(\\xi)C'(x) = f'(\\xi)\\frac{1}{c(x)},\\]\n\n!et\nimplying that $au_x = f'(\\xi)$. Then we have $u_t + cu_x= -f'(\\xi) +\nf'(\\xi) = 0$.",
             'text': "It can be shown that\nfor an observer moving with velocity $c(x)$, $u$ is constant.\nThis can be used to derive an exact solution when $a$ varies\nwith $x$. Show first that\n\n!bt\n\\begin{equation}\nu(x,t) = f(C(x) - t),\nlabel{wave:app:exer:advec1D:u:avar:sol}\n\\end{equation}\n\n!et\nwhere\n\n!bt\n\\[ C'(x) = \\frac{1}{c(x)},\\]\n\n!et\nis a solution of (ref{wave:app:exer:advec1D:ueq}) for any\ndifferentiable function $f$."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'In general we have $u(x,t) = f(C(x)-t)$ and the solution is\nof this form with $f(\\xi)=I(C^{-1}(\\xi))$.\nMoreover, at $t=0$ we have\n$I(C^{-1}(C(x)))=I(x)$, which is the required initial condition.',
             'text': 'Use the initial condition to show that an exact solution is\n\n!bt\n\\[ u(x,t) = I(C^{-1}(C(x)-t)),\\]\n\n!et\nwith $C^{-1}$ being the inverse function of $C = \\int c^{1}dx$.\nSince $C(x)$ is an integral $\\int_0^x (1/c)dx$,\n$C(x)$ is monotonically increasing and there exists hence an\ninverse function $C^{-1}$ with values in $[0,L]$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement a function for computing $C(x_i)$ and one for computing\n$C^{-1}(x)$ for any $x$. Use these two functions for computing\nthe exact solution $I(C^{-1}(C(x)-t))$.\nEnd up with a function `u_exact_variable_c(x, n, c, I)` that returns\nthe value of $I(C^{-1}(C(x)-t_n))$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Make movies showing a comparison of the numerical and exact solutions\nfor the two initial conditions\n(ref{wave:app:exer:advec1D:I:sin}) and (ref{wave:app:exer:advec1D:I:gauss}).\nChoose $\\Delta t = \\Delta x /\\max_{0,L} c(x)$\nand the velocity of the medium as\n\n o $c(x) = 1 + \\epsilon\\sin(k\\pi x/L)$, $\\epsilon <1$,\n o $c(x) = 1 + I(x)$, where $I$ is given by\n   (ref{wave:app:exer:advec1D:I:sin}) or (ref{wave:app:exer:advec1D:I:gauss}).\n\nThe PDE $u_t + cu_x=0$ expresses that the initial condition $I(x)$\nis transported with velocity $c(x)$.'}],
  'text': 'We shall study the wave equation\n\n!bt\n\\begin{equation}\nu_t + cu_x = 0,\\quad x\\in (0,L],\\ t\\in (0, T],\nlabel{wave:app:exer:advec1D:ueq}\n\\end{equation}\n\n!et\nwith initial condition\n\n!bt\n\\begin{equation}\nu(x,0) = I(x),\\quad x\\in [0,L],\n\\end{equation}\n\n!et\nand *one* periodic boundary condition\n\n!bt\n\\begin{equation}\nu(0,t) = u(L,t)\n\\thinspace .\n\\end{equation}\n\n!et\nThis boundary condition means that what goes out of the domain at $x=L$\ncomes in at $x=0$. Roughly speaking,\nwe need only one boundary condition because of\nthe spatial derivative is of first order only.\n\n__Physical interpretation.__\nThe parameter $c$ can be constant or variable, $c=c(x)$. The\nequation (ref{wave:app:exer:advec1D:ueq}) arises in *transport*\nproblems where a quantity $u$, which could be temperature or\nconcentration of some contaminant, is transported with the velocity\n$c$ of a fluid. In addition to the transport imposed by "travelling with\nthe fluid", $u$ may also be transported by diffusion (such as\nheat conduction or Fickian diffusion), but we have in\nthe model $u_t + cu_x$ assumed that diffusion effects are negligible,\nwhich they often are.\n\n\nA widely used numerical scheme for (ref{wave:app:exer:advec1D:ueq})\napplies a forward difference in time and a backward difference in\nspace when $c>0$:\n\n!bt\n\\begin{equation}\n[D_t^+ u + cD_x^-u = 0]_i^n\nlabel{wave:app:exer:advec1D:u:upwind}\n\\thinspace .\n\\end{equation}\n\n!et\nFor $c<0$ we use a forward difference in space: $[cD_x^+u]_i^n$.\n\n\n\n\n\n\n\nWe shall hereafter assume that $=c(x)>0$.\n\n\n\n\nTo compute (ref{wave:app:exer:advec1D:u:avar:sol}) we need to integrate\n$1/c$ to obtain $C$ and then compute the inverse of $C$.\n\nThe inverse function computation can be easily done if we first think\ndiscretely. Say we have some function $y=g(x)$ and seeks its inverse.\nPlotting $(x_i,y_i)$, where $y_i=g(x_i)$ for some mesh points $x_i$,\ndisplays $g$ as a function of $x$.\nThe inverse function is simply $x$ as a function of $g$, i.e., the\ncurve with points $(y_i,x_i)$. We can therefore quickly compute points\nat the curve of the inverse function. One way of extending these\npoints to a continuous function is to assume a linear variation\n(known as linear interpolation)\nbetween the points (which actually means to draw straight lines between\nthe points, exactly as done by a plotting program).\n\nThe function `wrap2callable` in `scitools.std` can take a set of points\nand return a continuous function that corresponds to linear\nvariation between the points. The computation of the inverse of a\nfunction $g$ on $[0,L]$ can then be done by\n\n!bc pycod\ndef inverse(g, domain, resolution=101):\n    x = linspace(domain[0], domain[L], resolution)\n    y = g(x)\n    from scitools.std import wrap2callable\n    g_inverse = wrap2callable((y, x))\n    return g_inverse\n\n!ec\n\nTo compute $C(x)$ we need to integrate $1/c$, which can be done by\na Trapezoidal rule. Suppose we have computed $C(x_i)$ and need\nto compute $C(x_{i+1})$. Using the Trapezoidal rule with $m$ subintervals\nover the integration domain $[x_i,x_{i+1}]$ gives\n\n!bt\n\\begin{equation}\nC(x_{i+1}) = C(x_i) + \\int_{x_i}^{x_{i+1}} \\frac{dx}{c}\n\\approx h\\left(\n\\frac{1}{2}\\frac{1}{c(x_i)} + \\frac{1}{2}\\frac{1}{c(x_{i+1})}\n+ \\sum_{j=1}^{m-1} \\frac{1}{c(x_i + jh)}\\right),\nlabel{wave:app:exer:advec1D:C:recursion}\n\\end{equation}\n\n!et\nwhere $h=(x_{i+1}-x_i)/m$ is the length of the subintervals used\nfor the integral over $[x_i,x_{i+1}]$.\nWe observe that (ref{wave:app:exer:advec1D:C:recursion}) is a\n*difference equation* which we can solve by repeatedly\napplying (ref{wave:app:exer:advec1D:C:recursion}) for\n$i=0,1,\\ldots,N_x-1$ if a mesh $x_0,x_,\\ldots,x_{N_x}$ is prescribed.\nNote that $C(0)=0$.\n\n\n\n\n\n# Idea: one thing at a time: no f2py intro for du/dn, just u=0 to make it\n# simple\n\n# 1D open boundary cond, try u=0 and du/dn=0 combination too\n# 1D correction terms\n\n# migrate to compiled: idea is to keep it very simple (u=0 cond), or maybe\n# do it in 1D? No, better in 2D, but have f(x,y) as an array (no callback)\n# 2D\n# 2D code simple, u=0, constant coeff\n# 2D visualization with mayavi2, matplotlib, gnuplot (scitools), + mpeg/avi\n# 2D code vectorized\n# 2D code cython\n# 2D code f2py\n# 2D code instant\n\n# Exer: f2py w/callback to Python for f and inlet U_0\n\n# 3D\n# 3D code vectorized\n# 3D code cython\n# main point: visualization with paraview or similar\n\n# apps:\n# shallow water, 1D and 2D\n# string\n# pipe\n# 3D acoustic\n# elastic in the ground, div u\n# blood 1D',
  'title': 'Solve a 1D transport equation',
  'type': 'Project',
  'type_visible': True}]