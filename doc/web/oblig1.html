<?xml version="1.0" encoding="utf-8" ?>
<!--
Automatically generated HTML file from Doconce source
(http://code.google.com/p/doconce/)
-->

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: http://code.google.com/p/doconce/" />

<!--
Color definitions:  http://www.december.com/html/spec/color0.html
CSS examples:       http://www.w3schools.com/css/css_examples.asp
-->

<style type="text/css">
    body {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #000000;
    }
    h1 { font-size: 1.8em; color: #1e36ce; }
    h2 { font-size: 1.5em; color: #1e36ce; }
    h3 { color: #1e36ce; }
    a { color: #1e36ce; text-decoration:none; }
    tt { font-family: "Courier New", Courier; }
    pre { background: #ededed; color: #000; padding: 15px;}
    p { text-indent: 0px; }
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-style: normal; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}

</style>

<!-- Use MathJax to render mathematics -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- Fix slow MathJax rendering in IE8 -->
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">

</head>

<body>
    

<!-- ------------------- main content ------------------------>

<title>First compulsory project in INF5620</title>

<center><h1>First compulsory project in INF5620</h1></center>  <! -- document title -->

<p>

<p>

<h2>Project: 2D wave equation  <a name="___sec0"></a></h2>
<p>

<h3>Mathematical problem  <a name="___sec1"></a></h3>
<p>
The project addresses the two-dimensional, standard, linear wave equation,
with damping,
$$ \frac{\partial^2 u}{\partial t^2} + b\frac{\partial u}{\partial t} =
\frac{\partial}{\partial x}\left( q (x,y)
\frac{\partial u}{\partial x}\right) +
\frac{\partial}{\partial y}\left( q (x,y)
\frac{\partial u}{\partial y}\right) + f(x,y,t),
$$
and with boundary condition
$$ \frac{\partial u}{\partial n} = 0,$$
in a rectangular spatial domain \( [0,L_x]\times [0,L_y] \).
The initial conditions are \( u(x,y,0)=I(x,y) \) and \( u_t(x,y,0)=V(x,y) \).

<p>

<h3>Discretization  <a name="___sec2"></a></h3>
<p>
Derive the discrete set of equations to be implemented in a program:

<p>

<ul>
  <li> the general scheme for computing \( u_{i,j}^{n+1} \) at interior
    spatial mesh points,
  <li> the modified scheme at boundary points (or use the interior
    scheme also at the boundary with extra ghost cells),
  <li> the modified scheme for the first step at interior points,
  <li> the modified scheme for the first step at boundary points.
</ul>

<h3>Implementation  <a name="___sec3"></a></h3>
<p>
Modify the <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/wave/wave2D_u0.py"><tt>wave2D_u0.py</tt></a>
program, which solves the 2D wave equation
with constant wave velocity and \( u=0 \) on the boundary, to the
present problem. You will need to include both scalar (pointwise)
computation of the scheme for debugging and reference as well as a
vectorized version for speed.

<p>

<h3>Verification  <a name="___sec4"></a></h3>
<p>

<h4>Constant solution  <a name="___sec5"></a></h4>
<p>
Construct a test case with constant solution, say \( u=1.2 \),
and make sure this constant is reproduced by the program.

<p>

<h4>Exact 1D solution  <a name="___sec6"></a></h4>
<p>
A simple 1D square or plug wave,
\( I(x,y)=2 \) for \( x \) less than some value and \( I=0 \) otherwise
should when \( c\Delta t/\Delta x=1 \) propagate with exact plug shape
and amplitude 1 through the domain for any \( \Delta y \). This verification
simulates an exact discrete solution of the 1D wave equation in a 2D
program. The plug can be set up to propagate in \( y \) direction too
(choose \( c\Delta t/\Delta y=1 \)). A pure 1D version of the plug pulse
is available
in the program <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/wave/wave1D_dn_vc.py"><tt>wave1D_dn_vc.py</tt></a>
in the <tt>pulse</tt> function.

<p>

<h4>Standing wave  <a name="___sec7"></a></h4>
<p>
Test the program with a manufactured solution, ideally with
\( \partial u/\partial n=0 \) at the boundary. One possible
choice for constant \( q \) is

<p>
$$
\begin{equation}
u(x,y,t)=\exp{(-bt)}\cos(m_xx\pi/L_x)\cos(m_yy\pi/L_y)\cos (\omega t)
\label{wave:app:exer:standing:waves}
\end{equation}
$$
for arbitrary integers \( m_x \) and \( m_y \) and
a suitable choice of \( \omega \). The wave lengths in the \( x \) and \( y \) directions
are \( 2L_x/m_x \) and \( 2L_y/m_y \), respectively.
This solution is a <em>standing wave</em>
with \( \partial u/\partial n=0 \).
Since the given \( u \) is not an exact solution of the discrete equations, the
test must be based on empirical analysis of the convergence.
The error \( E \) is assumed to behave like

<p>
$$
E = C_t\Delta t^2 + C_x\Delta x^2 + C_y\Delta y^2,
$$
for some constants \( C_t \), \( C_x \), and \( C_y \).
Choose \( \Delta t=F_th \), \( \Delta x =F_xh \), and \( \Delta y=F_yh \), where
\( h \) is a common discretization parameter to be varied (\( h\rightarrow 0 \))
and \( F_t \), \( F_x \), and \( F_y \) are freely chosen constant factors
compatible with the stability criterion in 2D. The error can then
be expressed as

<p>
$$
E = Ch^2,
$$
where \( C=C_xF_t^2 + C_yF_x^2 + C_tF_t^2 \).
Perform experiments with decreasing \( h \), compute \( E \), and verify that
\( E/h^2 \) is approximately constant.

<p>

<p>

<h4>Manufactured solution  <a name="___sec8"></a></h4>
<p>
Choose some \( q(x,y)\neq 0 \) and find \( f(x,y,t) \) such that
\eqref{wave:app:exer:standing:waves} is a solution to the problem.
Find corresponding \( I \) and \( V \), and make a convergence test to see
that we have the expected second-order convergence.

<p>

<h3>Suggested application  <a name="___sec9"></a></h3>
<p>
One possible application of the program is to simulate an
earthquake-generated tsunami as described in <a href="../notes/main_wave.html#{wave:app:exer:tsunami2D:hill}">Exercise 18</a>.
For such waves, \( q(x,y)=gH(x,y) \), where \( g \)
is the acceleration of gravity and \( H(x,y) \) is the water depth when
the surface is flat.

<p>
Different groups can choose different extensions of this application.
Suggestions are listed below, but groups are free to come up with
their own ideas.

<p>

<h4>Effect of various hill shapes  <a name="___sec10"></a></h4>
<p>
How does the smoothness of the subsea hill influence the numerical quality
of the solution? In particular, if \( q \) is discontinuous, as in an
approximation of a very steep hill, does this give more numerical
noise than a Gaussian hill shape? Does a small water gap at the
top of the hill give numerical problems? When \( q \) is discontinuous,
will a harmonic averaging of \( q \) give better results than the arithemetic
average?
Use fast 1D simulations to gain initial insight into these questions.

<p>

<h4>Visualization  <a name="___sec11"></a></h4>
<p>
Create some fancy 3D visualization of the water waves <em>and</em> the subsea hill.
Try to make the hill transparent. Suitable tools are

<p>

<ul>
  <li> <a href="http://code.enthought.com/projects/mayavi/">Mayavi</a>
  <li> <a href="http://www.paraview.org/">Paraview</a>
  <li> <a href="http://www.opendx.org/">OpenDX</a>
</ul>

Different groups can explore different tools. Other groups can explore
somewhat less sophisticated tools (but easier to use):

<p>

<ul>
 <li> MATLAB
 <li> Matplotlib
</ul>

<h4>Open boundary condition  <a name="___sec12"></a></h4>
<p>
Implement an open boundary condition at \( x=L_x \), \( u_t + \sqrt{q}u_x=0 \),
as suggested
in <a href="../notes/main_wave.html#wave:app:exer:tsunami1D:radiation">Exercise 14</a>.
See how well this condition works in letting the tsunami pass out of
the domain. The distance from the subsea hill (which disturbes the wave)
and the outlet boundary \( x=L_x \) is an important parameter.

<p>
Instead of using a condition \( u_t + \sqrt{q}u_x=0 \), which is exact only
for plane waves propagating in \( x \) direction, one can add an
artificial domain \( [L_x,L_x+\delta]\times [0,L_y] \) where waves are
sufficiently damped and absorbed. The goal of an open boundary condition
is to avoid waves being reflected back into the domain. Turn on
the damping parameter \( b \) in \( [L_x,L_x+\delta]\times [0,L_y] \),
and test if it is wise to vary \( b \), say in a linear or exponential
fashion to have a smooth transition from \( b=0 \) in the physical
domain and to some significant (efficient) \( b \) value towards the
artificial boundary \( x=L_x+\delta \).

<p>

<p>

<h4>Compiled loops  <a name="___sec13"></a></h4>
<p>
Extend the program with compiled loops using

<p>

<ul>
 <li> Cython code
 <li> Fortran code interfaced via <tt>f2py</tt>
 <li> C/C++ code interfaced via <tt>scipy.weave</tt>
 <li> C/C++ code interfaced via <a href="https://launchpad.net/instant">Instant</a>
 <li> C code interfaced via Cython or <tt>f2py</tt>
</ul>

Note that Instant comes with FEniCS (<tt>sudo apt-get install fenics</tt> on
Ubuntu will install Instant) and it is described in the
<a href="https://launchpad.net/fenics-book">FEniCS book</a>.

<p>

<h4>Parallel computing  <a name="___sec14"></a></h4>
<p>
Make a parallel version of the program using either OpenMP or MPI.
If all loops are migrated to C, one can work with OpenMP or MPI in
the C code.

<p>

<h4>3D wave equation  <a name="___sec15"></a></h4>
<p>
Implement a 3D version of the wave equation and simulate, e.g., seismic
waves. A 3D box can then be built of different layers with different
(constant) wave velocity \( \sqrt{q} \) in each layer.
Visualization of 3D waves is challenging, but one can follow
isosurfaces \( u=\hbox{const} \) through the domain.

<p>

<h3>How to hand in the project  <a name="___sec16"></a></h3>
<p>

<ul>
 <li> Make a project repository on Bitbucket, GitHub, Googlecode, or similar.
   Send the clone command to hpl@simula.no when you are ready to submit
   (or earlier if you need help or want to discuss things).
 <li> Focus on making flexible code with modules.
 <li> Write a short report summarizing the main results.
   See examples on <a href="../writing_reports/index.html">various report formats</a>.
 <li> Be prepared to make a 5-10 min presentation of the main results.
</ul>


<!-- ------------------- end of main content ----------------->
</body>
</html>
    

